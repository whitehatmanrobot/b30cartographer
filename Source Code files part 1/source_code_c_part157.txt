56];
static unsigned int ega_lo_graph_2_0_big[256];
static unsigned int ega_lo_graph_2_1_big[256];
static unsigned int ega_lo_graph_2_2_big[256];
static unsigned int ega_lo_graph_2_3_big[256];
static unsigned int ega_lo_graph_3_0_big[256];
static unsigned int ega_lo_graph_3_1_big[256];
static unsigned int ega_lo_graph_3_2_big[256];
static unsigned int ega_lo_graph_3_3_big[256];
static unsigned int ega_lo_graph_4_0_big[256];
static unsigned int ega_lo_graph_4_1_big[256];
static unsigned int ega_lo_graph_4_2_big[256];
static unsigned int ega_lo_graph_4_3_big[256];
static unsigned int ega_lo_graph_5_0_big[256];
static unsigned int ega_lo_graph_5_1_big[256];
static unsigned int ega_lo_graph_5_2_big[256];
static unsigned int ega_lo_graph_5_3_big[256];

static unsigned int ega_lo_graph_0_0_huge[256];
static unsigned int ega_lo_graph_0_1_huge[256];
static unsigned int ega_lo_graph_0_2_huge[256];
static unsigned int ega_lo_graph_0_3_huge[256];
static unsigned int ega_lo_graph_1_0_huge[256];
static unsigned int ega_lo_graph_1_1_huge[256];
static unsigned int ega_lo_graph_1_2_huge[256];
static unsigned int ega_lo_graph_1_3_huge[256];
static unsigned int ega_lo_graph_2_0_huge[256];
static unsigned int ega_lo_graph_2_1_huge[256];
static unsigned int ega_lo_graph_2_2_huge[256];
static unsigned int ega_lo_graph_2_3_huge[256];
static unsigned int ega_lo_graph_3_0_huge[256];
static unsigned int ega_lo_graph_3_1_huge[256];
static unsigned int ega_lo_graph_3_2_huge[256];
static unsigned int ega_lo_graph_3_3_huge[256];
static unsigned int ega_lo_graph_4_0_huge[256];
static unsigned int ega_lo_graph_4_1_huge[256];
static unsigned int ega_lo_graph_4_2_huge[256];
static unsigned int ega_lo_graph_4_3_huge[256];
static unsigned int ega_lo_graph_5_0_huge[256];
static unsigned int ega_lo_graph_5_1_huge[256];
static unsigned int ega_lo_graph_5_2_huge[256];
static unsigned int ega_lo_graph_5_3_huge[256];
static unsigned int ega_lo_graph_6_0_huge[256];
static unsigned int ega_lo_graph_6_1_huge[256];
static unsigned int ega_lo_graph_6_2_huge[256];
static unsigned int ega_lo_graph_6_3_huge[256];
static unsigned int ega_lo_graph_7_0_huge[256];
static unsigned int ega_lo_graph_7_1_huge[256];
static unsigned int ega_lo_graph_7_2_huge[256];
static unsigned int ega_lo_graph_7_3_huge[256];
#endif

static unsigned int ega_med_and_hi_graph_luts[2048];

#ifdef BIGWIN
static unsigned int ega_med_and_hi_graph_luts_big[3072];

static unsigned int ega_med_and_hi_graph_luts_huge[5120];
#endif


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise EGA mono low graphics :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_ega_mono_lo_graph()
{
sub_note_trace0(EGA_HOST_VERBOSE,"nt_init_ega_mono_lo_graph - NOT SUPPORTED");
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::: Initialise EGA colour low res graphics :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_ega_lo_graph()
{
        static boolean  ega_colour_lo_graph_deja_vu = FALSE;
        unsigned int    i,
                        byte0,
                        byte1,
                        byte2,
                        byte3,
                        byte4,
                        byte5,
                        byte6,
                        byte7,
                        or_of_bytes01,
                        or_of_bytes23,
                        or_of_bytes45,
                        or_of_bytes67;
#ifdef BIGWIN
        unsigned int    or_of_bytes89,
                        or_of_bytesab,
                        or_of_bytescd,
                        or_of_bytesef;
#endif /* BIGWIN */

        sub_note_trace0(EGA_HOST_VERBOSE,"nt_init_ega_lo_graph");

        /* Set up bits-per-pixel for current mode. */
        sc.BitsPerPixel = EGA_BITS_PER_PIXEL;

        /* Initialise look-up table for first call. */
        if( !ega_colour_lo_graph_deja_vu )
        {
                for( i = 0; i < 256; i++ )
                {
                        byte0 = i & 0x1;
                        byte1 = ( i & 0x2 ) >> 1;
                        byte2 = ( i & 0x4 ) >> 2;
                        byte3 = ( i & 0x8 ) >> 3;
                        byte4 = ( i & 0x10 ) >> 4;
                        byte5 = ( i & 0x20 ) >> 5;
                        byte6 = ( i & 0x40 ) >> 6;
                        byte7 = ( i & 0x80 ) >> 7;

#ifdef BIGEND
                        or_of_bytes01 = ( byte1 << 24 ) | ( byte1 << 16 ) |
                                                ( byte0 << 8 ) | byte0;
                        or_of_bytes23 = ( byte3 << 24 ) | ( byte3 << 16 ) |
                                                ( byte2 << 8 ) | byte2;
                        or_of_bytes45 = ( byte5 << 24 ) | ( byte5 << 16 ) |
                                                ( byte4 << 8 ) | byte4;
                        or_of_bytes67 = ( byte7 << 24 ) | ( byte7 << 16 ) |
                                                ( byte6 << 8 ) | byte6;
#endif /* BIGEND */

#ifdef LITTLEND
                        or_of_bytes01 = ( byte0 << 24 ) | ( byte0 << 16 ) |
                                                ( byte1 << 8 ) | byte1;
                        or_of_bytes23 = ( byte2 << 24 ) | ( byte2 << 16 ) |
                                                ( byte3 << 8 ) | byte3;
                        or_of_bytes45 = ( byte4 << 24 ) | ( byte4 << 16 ) |
                                                ( byte5<< 8 ) | byte5;
                        or_of_bytes67 = ( byte6 << 24 ) | ( byte6 << 16 ) |
                                                ( byte7 << 8 ) | byte7;
#endif /* LITTLEND */

                        ega_lo_graph_0_0[i] = or_of_bytes01;
                        ega_lo_graph_0_1[i] = or_of_bytes01 << 1;
                        ega_lo_graph_0_2[i] = or_of_bytes01 << 2;
                        ega_lo_graph_0_3[i] = or_of_bytes01 << 3;

                        ega_lo_graph_1_0[i] = or_of_bytes23;
                        ega_lo_graph_1_1[i] = or_of_bytes23 << 1;
                        ega_lo_graph_1_2[i] = or_of_bytes23 << 2;
                        ega_lo_graph_1_3[i] = or_of_bytes23 << 3;

                        ega_lo_graph_2_0[i] = or_of_bytes45;
                        ega_lo_graph_2_1[i] = or_of_bytes45 << 1;
                        ega_lo_graph_2_2[i] = or_of_bytes45 << 2;
                        ega_lo_graph_2_3[i] = or_of_bytes45 << 3;

                        ega_lo_graph_3_0[i] = or_of_bytes67;
                        ega_lo_graph_3_1[i] = or_of_bytes67 << 1;
                        ega_lo_graph_3_2[i] = or_of_bytes67 << 2;
                        ega_lo_graph_3_3[i] = or_of_bytes67 << 3;

#ifdef BIGWIN
#ifdef BIGEND

                        or_of_bytes01 = ( byte1 << 24 ) | ( byte0 << 16 ) |
                                                ( byte0 << 8 ) | byte0;
                        or_of_bytes23 = ( byte2 << 24 ) | ( byte2 << 16 ) |
                                                ( byte1 << 8 ) | byte1;
                        or_of_bytes45 = ( byte3 << 24 ) | ( byte3 << 16 ) |
                                                ( byte3 << 8 ) | byte2;
                        or_of_bytes67 = ( byte5 << 24 ) | ( byte4 << 16 ) |
                                                ( byte4 << 8 ) | byte4;
                        or_of_bytes89 = ( byte6 << 24 ) | ( byte6 << 16 ) |
                                                ( byte5 << 8 ) | byte5;
                        or_of_bytesab = ( byte7 << 24 ) | ( byte7 << 16 ) |
                                                ( byte7 << 8 ) | byte6;

#endif /* BIGEND */

#ifdef LITTLEND

                        or_of_bytes01 = ( byte0 << 24 ) | ( byte0 << 16 ) |
                                                ( byte0 << 8 ) | byte1;
                        or_of_bytes23 = ( byte1 << 24 ) | ( byte1 << 16 ) |
                                                ( byte2 << 8 ) | byte2;
                        or_of_bytes45 = ( byte2 << 24 ) | ( byte3 << 16 ) |
                                                ( byte3 << 8 ) | byte3;
                        or_of_bytes67 = ( byte4 << 24 ) | ( byte4 << 16 ) |
                                                ( byte4 << 8 ) | byte5;
                        or_of_bytes89 = ( byte5 << 24 ) | ( byte5 << 16 ) |
                                                ( byte6 << 8 ) | byte6;
                        or_of_bytesab = ( byte6 << 24 ) | ( byte7 << 16 ) |
                                                ( byte7 << 8 ) | byte7;

#endif /* LITTLEND */

                        ega_lo_graph_0_0_big[i] = or_of_bytes01;
                        ega_lo_graph_0_1_big[i] = or_of_bytes01 << 1;
                        ega_lo_graph_0_2_big[i] = or_of_bytes01 << 2;
                        ega_lo_graph_0_3_big[i] = or_of_bytes01 << 3;

                        ega_lo_graph_1_0_big[i] = or_of_bytes23;
                        ega_lo_graph_1_1_big[i] = or_of_bytes23 << 1;
                        ega_lo_graph_1_2_big[i] = or_of_bytes23 << 2;
                        ega_lo_graph_1_3_big[i] = or_of_bytes23 << 3;

                        ega_lo_graph_2_0_big[i] = or_of_bytes45;
                        ega_lo_graph_2_1_big[i] = or_of_bytes45 << 1;
                        ega_lo_graph_2_2_big[i] = or_of_bytes45 << 2;
                        ega_lo_graph_2_3_big[i] = or_of_bytes45 << 3;

                        ega_lo_graph_3_0_big[i] = or_of_bytes67;
                        ega_lo_graph_3_1_big[i] = or_of_bytes67 << 1;
                        ega_lo_graph_3_2_big[i] = or_of_bytes67 << 2;
                        ega_lo_graph_3_3_big[i] = or_of_bytes67 << 3;

                        ega_lo_graph_4_0_big[i] = or_of_bytes89;
                        ega_lo_graph_4_1_big[i] = or_of_bytes89 << 1;
                        ega_lo_graph_4_2_big[i] = or_of_bytes89 << 2;
                        ega_lo_graph_4_3_big[i] = or_of_bytes89 << 3;

                        ega_lo_graph_5_0_big[i] = or_of_bytesab;
                        ega_lo_graph_5_1_big[i] = or_of_bytesab << 1;
                        ega_lo_graph_5_2_big[i] = or_of_bytesab << 2;
                        ega_lo_graph_5_3_big[i] = or_of_bytesab << 3;

                        or_of_bytes01 = ( byte0 << 24 ) | ( byte0 << 16 ) |
                                                ( byte0 << 8 ) | byte0;
                        or_of_bytes23 = ( byte1 << 24 ) | ( byte1 << 16 ) |
                                                ( byte1 << 8 ) | byte1;
                        or_of_bytes45 = ( byte2 << 24 ) | ( byte2 << 16 ) |
                                                ( byte2 << 8 ) | byte2;
                        or_of_bytes67 = ( byte3 << 24 ) | ( byte3 << 16 ) |
                                                ( byte3 << 8 ) | byte3;
                        or_of_bytes89 = ( byte4 << 24 ) | ( byte4 << 16 ) |
                                                ( byte4 << 8 ) | byte4;
                        or_of_bytesab = ( byte5 << 24 ) | ( byte5 << 16 ) |
                                                ( byte5 << 8 ) | byte5;
                        or_of_bytescd = ( byte6 << 24 ) | ( byte6 << 16 ) |
                                                ( byte6 << 8 ) | byte6;
                        or_of_bytesef = ( byte7 << 24 ) | ( byte7 << 16 ) |
                                                ( byte7 << 8 ) | byte7;

                        ega_lo_graph_0_0_huge[i] = or_of_bytes01;
                        ega_lo_graph_0_1_huge[i] = or_of_bytes01 << 1;
                        ega_lo_graph_0_2_huge[i] = or_of_bytes01 << 2;
                        ega_lo_graph_0_3_huge[i] = or_of_bytes01 << 3;

                        ega_lo_graph_1_0_huge[i] = or_of_bytes23;
                        ega_lo_graph_1_1_huge[i] = or_of_bytes23 << 1;
                        ega_lo_graph_1_2_huge[i] = or_of_bytes23 << 2;
                        ega_lo_graph_1_3_huge[i] = or_of_bytes23 << 3;

                        ega_lo_graph_2_0_huge[i] = or_of_bytes45;
                        ega_lo_graph_2_1_huge[i] = or_of_bytes45 << 1;
                        ega_lo_graph_2_2_huge[i] = or_of_bytes45 << 2;
                        ega_lo_graph_2_3_huge[i] = or_of_bytes45 << 3;

                        ega_lo_graph_3_0_huge[i] = or_of_bytes67;
                        ega_lo_graph_3_1_huge[i] = or_of_bytes67 << 1;
                        ega_lo_graph_3_2_huge[i] = or_of_bytes67 << 2;
                        ega_lo_graph_3_3_huge[i] = or_of_bytes67 << 3;

                        ega_lo_graph_4_0_huge[i] = or_of_bytes89;
                        ega_lo_graph_4_1_huge[i] = or_of_bytes89 << 1;
                        ega_lo_graph_4_2_huge[i] = or_of_bytes89 << 2;
                        ega_lo_graph_4_3_huge[i] = or_of_bytes89 << 3;

                        ega_lo_graph_5_0_huge[i] = or_of_bytesab;
                        ega_lo_graph_5_1_huge[i] = or_of_bytesab << 1;
                        ega_lo_graph_5_2_huge[i] = or_of_bytesab << 2;
                        ega_lo_graph_5_3_huge[i] = or_of_bytesab << 3;

                        ega_lo_graph_6_0_huge[i] = or_of_bytescd;
                        ega_lo_graph_6_1_huge[i] = or_of_bytescd << 1;
                        ega_lo_graph_6_2_huge[i] = or_of_bytescd << 2;
                        ega_lo_graph_6_3_huge[i] = or_of_bytescd << 3;

                        ega_lo_graph_7_0_huge[i] = or_of_bytesef;
                        ega_lo_graph_7_1_huge[i] = or_of_bytesef << 1;
                        ega_lo_graph_7_2_huge[i] = or_of_bytesef << 2;
                        ega_lo_graph_7_3_huge[i] = or_of_bytesef << 3;

#endif /* BIGWIN */
                }

                ega_colour_lo_graph_deja_vu = TRUE;
        }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::: Initialise EGA med/hi res graphics :::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_ega_med_and_hi_graph_luts()
{
    static boolean   init_ega_med_and_hi_graph_luts_deja_vu = FALSE;
    unsigned int     i,
                     byte0,
                     byte1,
                     byte2,
                     byte3,
                     byte4,
                     byte5,
                     byte6,
                     byte7,
                     or_of_bytes1,
                     or_of_bytes2,
                    *lut0_ptr = &ega_med_and_hi_graph_luts[0],
                    *lut1_ptr = lut0_ptr + LUT_OFFSET,
                    *lut2_ptr = lut1_ptr + LUT_OFFSET,
                    *lut3_ptr = lut2_ptr + LUT_OFFSET;
#ifdef BIGWIN
    unsigned int     or_of_bytes3,
                     or_of_bytes4,
                    *lut0_big_ptr = &ega_med_and_hi_graph_luts_big[0],
                    *lut1_big_ptr = lut0_big_ptr + BIG_LUT_OFFSET,
                    *lut2_big_ptr = lut1_big_ptr + BIG_LUT_OFFSET,
                    *lut3_big_ptr = lut2_big_ptr + BIG_LUT_OFFSET,
                    *lut0_huge_ptr = &ega_med_and_hi_graph_luts_huge[0],
                    *lut1_huge_ptr = lut0_huge_ptr + HUGE_LUT_OFFSET,
                    *lut2_huge_ptr = lut1_huge_ptr + HUGE_LUT_OFFSET,
                    *lut3_huge_ptr = lut2_huge_ptr + HUGE_LUT_OFFSET,
                    *lut4_huge_ptr = lut3_huge_ptr + HUGE_LUT_OFFSET;
#endif /* BIGWIN */

    sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_ega_med_and_hi_graph_luts");

    if (init_ega_med_and_hi_graph_luts_deja_vu)
        return;

    init_ega_med_and_hi_graph_luts_deja_vu = TRUE;

    for(i = 0; i < 256; i++)
    {
        byte0 = i & 0x1;
        byte1 = (i & 0x2) >> 1;
        byte2 = (i & 0x4) >> 2;
        byte3 = (i & 0x8) >> 3;
        byte4 = (i & 0x10) >> 4;
        byte5 = (i & 0x20) >> 5;
        byte6 = (i & 0x40) >> 6;
        byte7 = (i & 0x80) >> 7;

#ifdef BIGEND

        or_of_bytes1 = (byte3 << 24) | (byte2 << 16) | (byte1 << 8) | byte0;
        or_of_bytes2 = (byte7 << 24) | (byte6 << 16) | (byte5 << 8) | byte4;

#endif /* BIGEND */

#ifdef LITTLEND

        or_of_bytes1 = (byte0 << 24) | (byte1 << 16) | (byte2 << 8) | byte3;
        or_of_bytes2 = (byte4 << 24) | (byte5 << 16) | (byte6 << 8) | byte7;

#endif /* LITTLEND */


        lut0_ptr[2*i]   = or_of_bytes2;
        lut0_ptr[2*i+1] = or_of_bytes1;
        lut1_ptr[2*i]   = or_of_bytes2 << 1;
        lut1_ptr[2*i+1] = or_of_bytes1 << 1;
        lut2_ptr[2*i]   = or_of_bytes2 << 2;
        lut2_ptr[2*i+1] = or_of_bytes1 << 2;
        lut3_ptr[2*i]   = or_of_bytes2 << 3;
        lut3_ptr[2*i+1] = or_of_bytes1 << 3;

#ifdef BIGWIN
#ifdef BIGEND

        or_of_bytes1 = (byte2 << 24) | (byte1 << 16) | (byte0 << 8) | byte0;
        or_of_bytes2 = (byte4 << 24) | (byte4 << 16) | (byte3 << 8) | byte2;
        or_of_bytes3 = (byte7 << 24) | (byte6 << 16) | (byte6 << 8) | byte5;

#endif /*BIGEND */

#ifdef LITTLEND

        or_of_bytes1 = (byte0 << 24) | (byte0 << 16) | (byte1 << 8) | byte2;
        or_of_bytes2 = (byte2 << 24) | (byte3 << 16) | (byte4 << 8) | byte4;
        or_of_bytes3 = (byte5 << 24) | (byte6 << 16) | (byte6 << 8) | byte7;

#endif /* LITTLEND */

        lut0_big_ptr[3*i]   = or_of_bytes3;
        lut0_big_ptr[3*i+1] = or_of_bytes2;
        lut0_big_ptr[3*i+2] = or_of_bytes1;
        lut1_big_ptr[3*i]   = or_of_bytes3 << 1;
        lut1_big_ptr[3*i+1] = or_of_bytes2 << 1;
        lut1_big_ptr[3*i+2] = or_of_bytes1 << 1;
        lut2_big_ptr[3*i]   = or_of_bytes3 << 2;
        lut2_big_ptr[3*i+1] = or_of_bytes2 << 2;
        lut2_big_ptr[3*i+2] = or_of_bytes1 << 2;
        lut3_big_ptr[3*i]   = or_of_bytes3 << 3;
        lut3_big_ptr[3*i+1] = or_of_bytes2 << 3;
        lut3_big_ptr[3*i+2] = or_of_bytes1 << 3;

#ifdef BIGEND

        or_of_bytes1 = (byte1 << 24) | (byte1 << 16) | (byte0 << 8) | byte0;
        or_of_bytes2 = (byte3 << 24) | (byte3 << 16) | (byte2 << 8) | byte2;
        or_of_bytes3 = (byte5 << 24) | (byte5 << 16) | (byte4 << 8) | byte4;
        or_of_bytes4 = (byte7 << 24) | (byte7 << 16) | (byte6 << 8) | byte6;

#endif /* BIGEND */

#ifdef LITTLEND

        or_of_bytes1 = (byte0 << 24) | (byte0 << 16) | (byte1 << 8) | byte1;
        or_of_bytes2 = (byte2 << 24) | (byte2 << 16) | (byte3 << 8) | byte3;
        or_of_bytes3 = (byte4 << 24) | (byte4 << 16) | (byte5 << 8) | byte5;
        or_of_bytes4 = (byte6 << 24) | (byte6 << 16) | (byte7 << 8) | byte7;

#endif /* LITTLEND */

        lut0_huge_ptr[4*i]      = or_of_bytes4;
        lut0_huge_ptr[4*i+1]    = or_of_bytes3;
        lut0_huge_ptr[4*i+2]    = or_of_bytes2;
        lut0_huge_ptr[4*i+3]    = or_of_bytes1;
        lut1_huge_ptr[4*i]      = or_of_bytes4 << 1;
        lut1_huge_ptr[4*i+1]    = or_of_bytes3 << 1;
        lut1_huge_ptr[4*i+2]    = or_of_bytes2 << 1;
        lut1_huge_ptr[4*i+3]    = or_of_bytes1 << 1;
        lut2_huge_ptr[4*i]      = or_of_bytes4 << 2;
        lut2_huge_ptr[4*i+1]    = or_of_bytes3 << 2;
        lut2_huge_ptr[4*i+2]    = or_of_bytes2 << 2;
        lut2_huge_ptr[4*i+3]    = or_of_bytes1 << 2;
        lut3_huge_ptr[4*i]      = or_of_bytes4 << 3;
        lut3_huge_ptr[4*i+1]    = or_of_bytes3 << 3;
        lut3_huge_ptr[4*i+2]    = or_of_bytes2 << 3;
        lut3_huge_ptr[4*i+3]    = or_of_bytes1 << 3;
        lut4_huge_ptr[4*i]      = or_of_bytes4 << 4;
        lut4_huge_ptr[4*i+1]    = or_of_bytes3 << 4;
        lut4_huge_ptr[4*i+2]    = or_of_bytes2 << 4;
        lut4_huge_ptr[4*i+3]    = or_of_bytes1 << 4;
#endif /* BIGWIN */
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::: Initialise EGA med res graphics ::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_ega_med_graph()
{
        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_ega_med_graph");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = EGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_ega_med_and_hi_graph_luts();
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::: Initialise hi res graphics :::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_ega_hi_graph()
{

        sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_ega_hi_graph");

        /* Set up the number of bits per pixel for this mode. */
        sc.BitsPerPixel = EGA_BITS_PER_PIXEL;

        /* Initialise the medium- and high-resolution look-up tables. */
        nt_init_ega_med_and_hi_graph_luts();
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::: Paint EGA screen with user defined font ::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void ega_nt_text_with_user_font(int offset,int cur_xpos,int cur_ypos,int len)
{
    int a = offset = cur_xpos = cur_ypos = len;

sub_note_trace0(EGA_HOST_VERBOSE,"ega_nt_text_with_user_font - NOT SUPPORTED");
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::: Paint EGA screen with user defined font ::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void ega_nt_big_text_with_user_font(int offset, int cur_xpos,
                                    int cur_ypos, int len)
{
    int a = offset = cur_xpos = cur_ypos = len;

    sub_note_trace0(EGA_HOST_VERBOSE,
                    "ega_nt_big_text_with_user_font - NOT SUPPORTED");
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::: Paint screen with EGA text ::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen (MODE 13:  PC 320x200. SoftPC 640x400) ::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_lo_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height)
{
    unsigned int   *p0,
                   *ref_p0,
                   *dest_ptr,
                   *save_dest_ptr,
                    data0,
                    data1,
                    data2,
                    data3;
    int  local_width,
         local_height,
         longs_per_scanline;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_ega_lo_graph_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);
    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>200 || width>40 ){
   assert2( NO, "VDM: nt_ega_lo_graph_std() w=%d h=%d", width, height );
   return;
    }


    /* Get source and destination data pointers. */
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_p0 = (unsigned int *) get_regen_ptr(0, offset << 2);
    save_dest_ptr = (unsigned int *) sc.ConsoleBufInfo.lpBitMap +
                    (screen_y << 1) * longs_per_scanline +
                    (screen_x >> 1);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /*
     *  Build up DIB: 4 consecutive bytes in video memory correspond to 8
     * pixels, the first byte containing plane 0 bits, the second byte plane 1
     * and so on. This mode is low resolution so each pixel in video memory
     * becomes a block of 4 pixels on the PC screen.
     *  The DIB contains the bottom line of pixels first, then second bottom
     * so on.
     */
    local_height = height;
    do
    {
        p0 = ref_p0;
        local_width = width;
        dest_ptr = save_dest_ptr;

        do
        {
            data0 = *p0++;
            data3 = HIBYTE(HIWORD(data0));
            data2 = LOBYTE(HIWORD(data0));
            data1 = HIBYTE(LOWORD(data0));
            data0 = LOBYTE(LOWORD(data0));

            *(dest_ptr + longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_3_0[data0] | ega_lo_graph_3_1[data1]
                        | ega_lo_graph_3_2[data2] | ega_lo_graph_3_3[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_2_0[data0] | ega_lo_graph_2_1[data1]
                        | ega_lo_graph_2_2[data2] | ega_lo_graph_2_3[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_1_0[data0] | ega_lo_graph_1_1[data1]
                        | ega_lo_graph_1_2[data2] | ega_lo_graph_1_3[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_0_0[data0] | ega_lo_graph_0_1[data1]
                        | ega_lo_graph_0_2[data2] | ega_lo_graph_0_3[data3];
            dest_ptr++;

        }
        while(--local_width);

        save_dest_ptr += 2 * longs_per_scanline;
        ref_p0 += get_offset_per_line();
    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = screen_x << 1;
    rect.Top = screen_y << 1;
    rect.Right = rect.Left + (width << 4) - 1;
    rect.Bottom = rect.Top + (height << 1) - 1;

    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen (MODE 13:  PC 320x200. SoftPC 960x600) ::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_lo_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height)
{
#ifdef BIGWIN
    unsigned int   *p0,
                   *ref_p0,
                   *dest_ptr,
                   *save_dest_ptr,
                    data0,
                    data1,
                    data2,
                    data3;
    int  local_width,
         local_height,
         longs_per_scanline;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_ega_lo_graph_big off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );
    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>200 || width>40 ){
   assert2( NO, "VDM: nt_ega_lo_graph_big() w=%d h=%d", width, height );
   return;
    }


    /* Get source and destination data pointers. */
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_p0 = (unsigned int *) get_regen_ptr(0, offset << 2);
    save_dest_ptr = (unsigned int *) sc.ConsoleBufInfo.lpBitMap +
                    SCALE(screen_y << 1) * longs_per_scanline +
                    SCALE(screen_x >> 1);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Build up DIB. */
    local_height = height;
    do
    {
        p0 = ref_p0;
        local_width = width;
        dest_ptr = save_dest_ptr;

        do
        {
            data0 = *p0++;
            data3 = HIBYTE(HIWORD(data0));
            data2 = LOBYTE(HIWORD(data0));
            data1 = HIBYTE(LOWORD(data0));
            data0 = LOBYTE(LOWORD(data0));

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2*longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_5_0_big[data0]
                    | ega_lo_graph_5_1_big[data1]
                    | ega_lo_graph_5_2_big[data2]
                    | ega_lo_graph_5_3_big[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2*longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_4_0_big[data0]
                    | ega_lo_graph_4_1_big[data1]
                    | ega_lo_graph_4_2_big[data2]
                    | ega_lo_graph_4_3_big[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2*longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_3_0_big[data0]
                    | ega_lo_graph_3_1_big[data1]
                    | ega_lo_graph_3_2_big[data2]
                    | ega_lo_graph_3_3_big[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2*longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_2_0_big[data0]
                    | ega_lo_graph_2_1_big[data1]
                    | ega_lo_graph_2_2_big[data2]
                    | ega_lo_graph_2_3_big[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2*longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_1_0_big[data0]
                    | ega_lo_graph_1_1_big[data1]
                    | ega_lo_graph_1_2_big[data2]
                    | ega_lo_graph_1_3_big[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2*longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_0_0_big[data0]
                    | ega_lo_graph_0_1_big[data1]
                    | ega_lo_graph_0_2_big[data2]
                    | ega_lo_graph_0_3_big[data3];
            dest_ptr++;

        }
        while( --local_width );

        save_dest_ptr += 3 * longs_per_scanline;
        ref_p0 += get_offset_per_line();
    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 1);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE(width << 4) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    /* Display the DIB. */
    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint win32 screen (MODE 13:  PC 320x200. SoftPC 1280x800) ::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_lo_graph_huge(int offset, int screen_x, int screen_y,
                          int width, int height )
{
#ifdef BIGWIN
    unsigned int   *p0,
                   *ref_p0,
                   *dest_ptr,
                   *save_dest_ptr,
                    data0,
                    data1,
                    data2,
                    data3;
    int  local_width,
         local_height,
         longs_per_scanline;
    SMALL_RECT   rect;


    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_ega_lo_graph_huge off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>200 || width>40 ){
   assert2( NO, "VDM: nt_ega_lo_graph_huge() w=%d h=%d", width, height );
   return;
    }


    /* Get source and destination data pointers. */
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_p0 = (unsigned int *) get_regen_ptr(0, offset << 2);
    save_dest_ptr = (unsigned int *) sc.ConsoleBufInfo.lpBitMap +
                    SCALE(screen_y << 1) * longs_per_scanline +
                    SCALE(screen_x >> 1);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Build up DIB. */
    local_height = height;
    do
    {
        p0 = ref_p0;
        local_width = width;
        dest_ptr = save_dest_ptr;

        do
        {
            data0 = *p0++;
            data3 = HIBYTE(HIWORD(data0));
            data2 = LOBYTE(HIWORD(data0));
            data1 = HIBYTE(LOWORD(data0));
            data0 = LOBYTE(LOWORD(data0));

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_7_0_huge[data0]
                    | ega_lo_graph_7_1_huge[data1]
                    | ega_lo_graph_7_2_huge[data2]
                    | ega_lo_graph_7_3_huge[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_6_0_huge[data0]
                    | ega_lo_graph_6_1_huge[data1]
                    | ega_lo_graph_6_2_huge[data2]
                    | ega_lo_graph_6_3_huge[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_5_0_huge[data0]
                    | ega_lo_graph_5_1_huge[data1]
                    | ega_lo_graph_5_2_huge[data2]
                    | ega_lo_graph_5_3_huge[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_4_0_huge[data0]
                    | ega_lo_graph_4_1_huge[data1]
                    | ega_lo_graph_4_2_huge[data2]
                    | ega_lo_graph_4_3_huge[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_3_0_huge[data0]
                    | ega_lo_graph_3_1_huge[data1]
                    | ega_lo_graph_3_2_huge[data2]
                    | ega_lo_graph_3_3_huge[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_2_0_huge[data0]
                    | ega_lo_graph_2_1_huge[data1]
                    | ega_lo_graph_2_2_huge[data2]
                    | ega_lo_graph_2_3_huge[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_1_0_huge[data0]
                    | ega_lo_graph_1_1_huge[data1]
                    | ega_lo_graph_1_2_huge[data2]
                    | ega_lo_graph_1_3_huge[data3];
            dest_ptr++;

            *(dest_ptr + longs_per_scanline)
                = *(dest_ptr + 2 * longs_per_scanline)
                = *(dest_ptr + 3 * longs_per_scanline)
                = *dest_ptr
                = ega_lo_graph_0_0_huge[data0]
                    | ega_lo_graph_0_1_huge[data1]
                    | ega_lo_graph_0_2_huge[data2]
                    | ega_lo_graph_0_3_huge[data3];
            dest_ptr++;

        }
        while( --local_width );

        save_dest_ptr += 4 * longs_per_scanline;
        ref_p0 += get_offset_per_line();
    } while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 1);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE(width << 4) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    /* Display the DIB. */
    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint Win32 screen (MODE 14: PC 640x200. SoftPC 640x400) :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_med_graph_std(int offset, int screen_x, int screen_y,
                          int width, int height)
{
    register unsigned int   *p0;
    register char           *dest_ptr;
    register int             local_height;
    int                      bytes_per_scanline;
    SMALL_RECT               rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_ega_med_graph_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>200 || width>80 ){
   assert2( NO, "VDM: nt_ega_med_graph_std() w=%d h=%d", width, height );
   return;
    }


    /*
     * Build up device-independent bitmap: one PC pixel is represented by two
     * host pixels, one above the other.
     */
    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    p0 = (unsigned int *) get_regen_ptr(0, offset << 2);
    local_height = height;
    dest_ptr = (char *) sc.ConsoleBufInfo.lpBitMap +
               (screen_y << 1) * bytes_per_scanline +
               screen_x;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Build up the bitmap. */
    do
    {
        ega_colour_hi_munge((unsigned char *) p0,
                            width,
                            (unsigned int *) dest_ptr,
                            ega_med_and_hi_graph_luts,
                            TWO_SCANLINES,
                            bytes_per_scanline);
        p0 += get_offset_per_line();
        dest_ptr += TWO_SCANLINES * bytes_per_scanline;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = (SHORT)screen_x;
    rect.Top = screen_y << 1;
    rect.Right = rect.Left + (width << 3) - 1;
    rect.Bottom = rect.Top + (height << 1) - 1;

    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint Win32 screen MODE 14: PC 640x200. SoftPC 960x600 :::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_med_graph_big(int offset, int screen_x, int screen_y,
                          int width, int height)
{
#ifdef BIGWIN
    register unsigned int   *p0;
    register char           *dest_ptr;
    register int             local_height;
    int                      bytes_per_scanline;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_ega_med_graph_big off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>200 || width>80 ){
   assert2( NO, "VDM: nt_ega_med_graph_big() w=%d h=%d", width, height );
   return;
    }


    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    p0 = (unsigned int *) get_regen_ptr(0, offset << 2);
    local_height = height;
    dest_ptr = (char *) sc.ConsoleBufInfo.lpBitMap +
               SCALE(screen_y << 1) * bytes_per_scanline +
               SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        ega_colour_hi_munge_big( (unsigned char *) p0,
                                width,
                                (unsigned int *) dest_ptr,
                                ega_med_and_hi_graph_luts_big,
                                THREE_SCANLINES,
                                bytes_per_scanline);
        p0 += get_offset_per_line();
        dest_ptr += THREE_SCANLINES * bytes_per_scanline;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE(width << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif  /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint Win32 screen MODE 14: PC 640x200. SoftPC 1280x800 :::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_med_graph_huge(int offset, int screen_x, int screen_y,
                           int width, int height )
{
#ifdef BIGWIN
    register unsigned int   *p0;
    register char           *dest_ptr;
    register int             local_height;
    int                      bytes_per_scanline;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                  "nt_ega_med_graph_huge off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>200 || width>80 ){
   assert2( NO, "VDM: nt_ega_med_graph_huge() w=%d h=%d", width, height );
   return;
    }


    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    p0 = (unsigned int *) get_regen_ptr(0, offset << 2);
    local_height = height;
    dest_ptr = (char *) sc.ConsoleBufInfo.lpBitMap +
               SCALE(screen_y << 1) * bytes_per_scanline +
               SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        ega_colour_hi_munge_huge( (unsigned char *) p0,
                                 width,
                                 (unsigned int *) dest_ptr,
                                 ega_med_and_hi_graph_luts_huge,
                                 FOUR_SCANLINES,
                                 bytes_per_scanline);
        p0 += get_offset_per_line();
        dest_ptr += FOUR_SCANLINES * bytes_per_scanline;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE(width << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint Win32 screen (MODE 16: PC 640x350. SoftPC 960x375) :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height)
{
    register unsigned int   *p0;
    register char           *dest_ptr;
    register int             local_height;
    int                      bytes_per_scanline;
    SMALL_RECT               rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_ega_hi_graph_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>480 || width>80 ){
   assert2( NO, "VDM: nt_ega_hi_graph_std() w=%d h=%d", width, height );
   return;
    }

    /* Build up the device independent bitmap. */
    p0 = ( unsigned int *) get_regen_ptr( 0, offset << 2 );
    local_height = height;
    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    dest_ptr = (char *) sc.ConsoleBufInfo.lpBitMap +
               screen_y * bytes_per_scanline +
               screen_x;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        ega_colour_hi_munge((unsigned char *) p0,
                            width,
                            (unsigned int *) dest_ptr,
                            ega_med_and_hi_graph_luts,
                            ONE_SCANLINE,
                            0);
        p0 += get_offset_per_line();
        dest_ptr += bytes_per_scanline;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = (SHORT)screen_x;
    rect.Top = (SHORT)screen_y;
    rect.Right = rect.Left + (width << 3) - 1;
    rect.Bottom = rect.Top + height - 1;

    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint Win32 screen (MODE 16: PC 640x350. SoftPC 960x525) :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height)
{
#ifdef BIGWIN
    register unsigned int   *p0;
    register char           *dest_ptr;
    register int             local_height;
    register int             local_screen_y;
    register int             scale_width_in_bits;
    int                      bytes_per_scanline;
    BOOL                     two_lines;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_ega_hi_graph_big off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>480 || width>80 ){
   assert2( NO, "VDM: nt_ega_hi_graph_big() w=%d h=%d", width, height );
   return;
    }


    /* Get pointer to video memory. */
    p0 = (unsigned int *) get_regen_ptr(0, offset << 2);

    /*
     * Get pointer into bitmap, which alternates 2 lines and 1 line so that,
     * memory line 0 -> bitmap 0,
     *             1 ->        2,
     *             2 ->        3,
     *             3 ->        5,
     *             4 ->        6 etc.
     * hence the local_screen_y assignment.
     */
    local_screen_y = SCALE(screen_y + 1) - 1;
    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    dest_ptr = (char *) sc.ConsoleBufInfo.lpBitMap +
               local_screen_y * bytes_per_scanline +
               SCALE(screen_x);

    /*
     * 2 lines are output to the SoftPC screen if this is an odd line, 1 line
     * if it is even.
     */
    two_lines = screen_y & 1 ? FALSE : TRUE;

    /*
     * One bit in video memory planes corresponds to one pixel. Each pixel
     * is represented by one byte in the bitmap. Two pixels are scaled to
     * three in the bitmap. `scale_width_in_bits' is the number of bytes that
     * will be output to a bitmap line.
     */
    scale_width_in_bits = SCALE(width << 3);

    /* Storage for actual number of lines in bitmap. */
    local_height = 0;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        ega_colour_hi_munge_big((unsigned char *) p0,
                                width,
                                (unsigned int *) dest_ptr,
                                ega_med_and_hi_graph_luts_big,
                                ONE_SCANLINE,
                                0);

        /* one line done, alternate ones have to be doubled */
        if(two_lines)
        {
            memcpy(dest_ptr + bytes_per_scanline,
                   dest_ptr,
                   scale_width_in_bits);
            dest_ptr += 2 * bytes_per_scanline;
            local_height += 2;
        }
        else
        {
            dest_ptr += bytes_per_scanline;
            local_height++;
        }
        two_lines = !two_lines;

        p0 += get_offset_per_line();
    }
    while(--height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = (SHORT) local_screen_y;
    rect.Right = rect.Left + scale_width_in_bits - 1;
    rect.Bottom = rect.Top + local_height - 1;

    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint Win32 screen (MODE 16: PC 640x350. SoftPC 1280x700) :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_hi_graph_huge(int offset, int screen_x, int screen_y,
                          int width, int height)
{
#ifdef BIGWIN
    register unsigned int   *p0;
    register char           *dest_ptr;
    register int             local_height;
    int                      bytes_per_scanline;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_ega_hi_graph_huge off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>480 || width>80 ){
   assert2( NO, "VDM: nt_ega_hi_graph_huge() w=%d h=%d", width, height );
   return;
    }


    p0 = (unsigned int *) get_regen_ptr(0, offset << 2);
    local_height = height;
    bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    dest_ptr = (char *) sc.ConsoleBufInfo.lpBitMap +
               SCALE(screen_y) * bytes_per_scanline +
               SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        ega_colour_hi_munge_huge((unsigned char *) p0,
                                 width,
                                 (unsigned int *) dest_ptr,
                                 ega_med_and_hi_graph_luts_huge,
                                 ONE_SCANLINE,
                                 0);

        p0 += get_offset_per_line();
        memcpy(dest_ptr + bytes_per_scanline, dest_ptr, SCALE(width << 3));
        dest_ptr += 2 * bytes_per_scanline;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(width << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height) - 1;

    if( sc.ScreenBufHandle )
   if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
      assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
          GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint Win32 screen (MODE : EGA mono low res graphics) ::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_lo_graph_std(int offset, int screen_x, int screen_y,
                              int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_lo_graph_std off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::: Paint function for EGA mono low res graphics on big screen ::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_lo_graph_big(int offset, int screen_x, int screen_y,
                              int width, int height )
{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_lo_graph_big off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::: Paint function for EGA mono low res graphics on huge screen :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_lo_graph_huge(int offset, int screen_x, int screen_y,
                              int width, int height )
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_ega_mono_lo_graph_huge off=%d x=%d y=%d width=%d h=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height );
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::: Paint function for EGA mono med res graphics :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_med_graph_std(int offset, int screen_x, int screen_y,
                               int width, int height)

{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_med_graph_std off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::: Paint function for EGA mono med res graphics on big screen ::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_med_graph_big(int offset, int screen_x, int screen_y,
                               int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_med_graph_big off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::: Paint function for EGA mono med res graphics on huge screen :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_med_graph_huge(int offset, int screen_x, int screen_y,
                                int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_ega_mono_med_graph_huge off=%d x=%d y=%d width=%d h=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::: Paint function for EGA mono hi res graphics :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_hi_graph_std_byte(int offset, int screen_x, int screen_y,
                                   int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_hi_graph_std_byte off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::: Paint function for EGA mono hi res graphics (long):::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_hi_graph_std_long(int offset, int screen_x, int screen_y,
                                   int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_hi_graph_std_long off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::: Paint function for EGA mono hi res graphics :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_hi_graph_std(int offset, int screen_x, int screen_y,
                              int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_hi_graph_std off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::: Paint function for EGA mono hi res graphics on big screen::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_hi_graph_big(int offset, int screen_x, int screen_y,
                             int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
 "nt_ega_mono_hi_graph_big off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
  offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::: Paint function for EGA mono hi res graphics on huge screen:::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_mono_hi_graph_huge(int offset, int screen_x, int screen_y,
                               int width, int height )
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_ega_mono_hi_graph_huge off=%d x=%d y=%d width=%d h=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height);
}

#ifdef MONITOR
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint frozen screen (MODE 13:  PC 320x200. SoftPC 640x400) :::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_lo_frozen_std(int offset, int screen_x, int screen_y,
                          int width, int height)
{
    UTINY   *plane1_ptr,
      *plane2_ptr,
      *plane3_ptr,
      *plane4_ptr;
    ULONG   *dest_ptr,
      *save_dest_ptr,
       mem_loc,
       data0,
       data1,
       data2,
       data3,
       local_width,
       local_height,
       longs_per_scanline,
       bpl = get_bytes_per_line(),
       mem_x = screen_x >> 3,
       max_width = sc.PC_W_Width >> 4,
       max_height = sc.PC_W_Height >> 1;
    SMALL_RECT   rect;
    BOOL         fMutexTaken = FALSE;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_ega_lo_frozen_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);
    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((mem_x >= max_width) || ((ULONG) screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_ega_lo_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (mem_x + width > max_width)
        width = max_width - mem_x;
    if ((ULONG) (screen_y + height) > max_height)
        height = max_height - screen_y;

    /* memory involved here liable to be suddenly removed due to fs switch */
    try
    {
        /* Get source and destination data pointers. */
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);
        plane3_ptr = GET_OFFSET(Plane3Offset);
        plane4_ptr = GET_OFFSET(Plane4Offset);
        longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
        save_dest_ptr = (unsigned int *) sc.ConsoleBufInfo.lpBitMap +
                        (screen_y << 1) * longs_per_scanline +
                        (screen_x >> 1);

        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        fMutexTaken = TRUE;

        /*
         *  Build up DIB: 4 consecutive bytes in video memory correspond to 8
         * pixels the first byte containing plane 0, the second byte plane 1
         * and so on. This mode is low resolution so each pixel in video memory
         * becomes a block of 4 pixels on the PC screen.
         *  The DIB contains the bottom line of pixels first, then second bottom
         * so on.
         */
        local_height = height;
        do
        {
            local_width = width;
            dest_ptr = save_dest_ptr;
       mem_loc = offset;
            do
            {
                data0 = *(plane1_ptr + mem_loc);
                data1 = *(plane2_ptr + mem_loc);
                data2 = *(plane3_ptr + mem_loc);
                data3 = *(plane4_ptr + mem_loc);

                *(dest_ptr + longs_per_scanline)
                    = *dest_ptr
                    = ega_lo_graph_3_0[data0] | ega_lo_graph_3_1[data1]
                            | ega_lo_graph_3_2[data2] | ega_lo_graph_3_3[data3];
                dest_ptr++;

                *(dest_ptr + longs_per_scanline)
                    = *dest_ptr
                    = ega_lo_graph_2_0[data0] | ega_lo_graph_2_1[data1]
                            | ega_lo_graph_2_2[data2] | ega_lo_graph_2_3[data3];
                dest_ptr++;

                *(dest_ptr + longs_per_scanline)
                    = *dest_ptr
                    = ega_lo_graph_1_0[data0] | ega_lo_graph_1_1[data1]
                            | ega_lo_graph_1_2[data2] | ega_lo_graph_1_3[data3];
                dest_ptr++;

                *(dest_ptr + longs_per_scanline)
                    = *dest_ptr
                    = ega_lo_graph_0_0[data0] | ega_lo_graph_0_1[data1]
                            | ega_lo_graph_0_2[data2] | ega_lo_graph_0_3[data3];
                dest_ptr++;
           mem_loc++;
            }
            while(--local_width);
            save_dest_ptr += 2 * longs_per_scanline;
       offset += bpl;
        }
        while(--local_height);

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        fMutexTaken = FALSE;

        /* Display the new image. */
        rect.Left = screen_x << 1;
        rect.Top = screen_y << 1;
        rect.Right = rect.Left + (width << 4) - 1;
        rect.Bottom = rect.Top + (height << 1) - 1;

        if( sc.ScreenBufHandle )
       if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
          assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
              GetLastError() );
    } except(EXCEPTION_EXECUTE_HANDLER)
      {
          assert0(NO, "Handled fault in nt_ega_lo_frozen_std. fs switch?");
          if (fMutexTaken)
             RelMutex(sc.ConsoleBufInfo.hMutex);
          return;
      }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint frozen screen (MODE 14: PC 640x200. SoftPC 640x400) :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_med_frozen_std(int offset, int screen_x, int screen_y,
                           int width, int height)
{
    ULONG    local_height,
       local_width,
       longs_per_scanline,
      *dest_ptr,
      *ref_dest_ptr,
      *lut0_ptr = ega_med_and_hi_graph_luts,
      *lut1_ptr = lut0_ptr + LUT_OFFSET,
      *lut2_ptr = lut1_ptr + LUT_OFFSET,
      *lut3_ptr = lut2_ptr + LUT_OFFSET,
      *l_ptr,
       hi_res,
       lo_res,
       mem_loc,
       bpl = get_bytes_per_line(),
       plane_mask = get_plane_mask(),
       mem_x = screen_x >> 3,
       max_width = sc.PC_W_Width >> 3,
       max_height = sc.PC_W_Height >> 1;
    UTINY   *plane1_ptr,
      *plane2_ptr,
      *plane3_ptr,
      *plane4_ptr;
    SMALL_RECT   rect;
    BOOL        fMutexTaken = FALSE;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_ega_med_frozen_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((mem_x >= max_width) || ((ULONG) screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_ega_med_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (mem_x + width > max_width)
        width = max_width - mem_x;
    if ((ULONG) (screen_y + height) > max_height)
        height = max_height - screen_y;

    /* memory involved here liable to be suddenly removed due to fs switch */
    try
    {
        /*
         * Build up device-independent bitmap: one PC pixel is represented by
         * two host pixels, one above the other.
         */
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);
        plane3_ptr = GET_OFFSET(Plane3Offset);
        plane4_ptr = GET_OFFSET(Plane4Offset);
        longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
        ref_dest_ptr = (ULONG *) sc.ConsoleBufInfo.lpBitMap +
             (screen_y << 1) * longs_per_scanline +
             (screen_x >> 2);

        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        fMutexTaken = TRUE;

        /* Build up the bitmap. */
        local_height = height;
        do
        {
       dest_ptr = ref_dest_ptr;
       mem_loc = offset;
       local_width = width;
       do
       {
           hi_res = 0;
           lo_res = 0;

           /* Get 8 bytes of output data from 1 byte of plane 0 data. */
           if (plane_mask & 1)
           {
          l_ptr = &lut0_ptr[*(plane1_ptr + mem_loc) << 1];
          hi_res = *l_ptr++;
          lo_res = *l_ptr;
           }

           /* Or in the output data from plane 1 */
           if (plane_mask & 2)
           {
          l_ptr = &lut1_ptr[*(plane2_ptr + mem_loc) << 1];
          hi_res |= *l_ptr++;
          lo_res |= *l_ptr;
           }

           /* Or in the output data from plane 2 */
           if (plane_mask & 4)
           {
          l_ptr = &lut2_ptr[*(plane3_ptr + mem_loc) << 1];
          hi_res |= *l_ptr++;
          lo_res |= *l_ptr;
           }

           /* Or in the output data from plane 3 */
           if (plane_mask & 8)
           {
          l_ptr = &lut3_ptr[*(plane4_ptr + mem_loc) << 1];
          hi_res |= *l_ptr++;
          lo_res |= *l_ptr;
           }

           /* Now store it in the bitmap. */
           *(dest_ptr + longs_per_scanline) = *dest_ptr = hi_res;
           dest_ptr++;
           *(dest_ptr + longs_per_scanline) = *dest_ptr = lo_res;
           dest_ptr++;
           mem_loc++;
       }
       while (--local_width);
            ref_dest_ptr += 2 * longs_per_scanline;
       offset += bpl;
        }
        while(--local_height);

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        fMutexTaken = FALSE;

        /* Display the new image. */
        rect.Left = (SHORT)screen_x;
        rect.Top = screen_y << 1;
        rect.Right = rect.Left + (width << 3) - 1;
        rect.Bottom = rect.Top + (height << 1) - 1;

        if( sc.ScreenBufHandle )
       if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
          assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
              GetLastError() );
    } except(EXCEPTION_EXECUTE_HANDLER)
      {
          assert0(NO, "Handled fault in nt_ega_med_frozen_std. fs switch?");
          if (fMutexTaken)
             RelMutex(sc.ConsoleBufInfo.hMutex);
          return;
      }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Paint frozen screen (MODE 16: PC 640x350. SoftPC 640x350) ::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_ega_hi_frozen_std(int offset, int screen_x, int screen_y,
                          int width, int height)
{
    ULONG    local_height,
       local_width,
       longs_per_scanline,
      *dest_ptr,
      *ref_dest_ptr,
      *lut0_ptr = ega_med_and_hi_graph_luts,
      *lut1_ptr = lut0_ptr + LUT_OFFSET,
      *lut2_ptr = lut1_ptr + LUT_OFFSET,
      *lut3_ptr = lut2_ptr + LUT_OFFSET,
      *l_ptr,
       hi_res,
       lo_res,
       mem_loc,
       bpl = get_bytes_per_line(),
       plane_mask = get_plane_mask(),
       mem_x = screen_x >> 3,
       max_width = sc.PC_W_Width >> 3,
       max_height = sc.PC_W_Height;
    UTINY   *plane1_ptr,
      *plane2_ptr,
      *plane3_ptr,
      *plane4_ptr;
    SMALL_RECT   rect;
    BOOL        fMutexTaken = FALSE;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_ega_hi_frozen_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
   assert0( NO, "VDM: rejected paint request due to NULL handle" );
   return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((mem_x >= max_width) || ((ULONG) screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_ega_hi_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (mem_x + width > max_width)
        width = max_width - mem_x;
    if ((ULONG) (screen_y + height) > max_height)
        height = max_height - screen_y;

    /* memory involved here liable to be suddenly removed due to fs switch */
    try
    {

        /* Build up the device independent bitmap. */
        local_height = height;
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);
        plane3_ptr = GET_OFFSET(Plane3Offset);
        plane4_ptr = GET_OFFSET(Plane4Offset);
        longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
        ref_dest_ptr = (ULONG *) sc.ConsoleBufInfo.lpBitMap +
             screen_y * longs_per_scanline +
             (screen_x >> 2);

        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        fMutexTaken = TRUE;

        do
        {
       dest_ptr = ref_dest_ptr;
       local_width = width;
       mem_loc = offset;
       do
       {

           /* Get 8 bytes of output data from 1 byte of plane 0 data. */
           if (plane_mask & 1)
           {
          l_ptr = &lut0_ptr[*(plane1_ptr + mem_loc) << 1];
          hi_res = *l_ptr++;
          lo_res = *l_ptr;
           }

           /* Or in the output data from plane 1 */
           if (plane_mask & 2)
           {
          l_ptr = &lut1_ptr[*(plane2_ptr + mem_loc) << 1];
          hi_res |= *l_ptr++;
          lo_res |= *l_ptr;
           }

           /* Or in the output data from plane 2 */
           if (plane_mask & 4)
           {
          l_ptr = &lut2_ptr[*(plane3_ptr + mem_loc) << 1];
          hi_res |= *l_ptr++;
          lo_res |= *l_ptr;
           }

           /* Or in the output data from plane 3 */
           if (plane_mask & 8)
           {
          l_ptr = &lut3_ptr[*(plane4_ptr + mem_loc) << 1];
          hi_res |= *l_ptr++;
          lo_res |= *l_ptr;
           }

           /* Now store it in the bitmap. */
           *dest_ptr++ = hi_res;
           *dest_ptr++ = lo_res;
           mem_loc++;
       }
       while (--local_width);
            ref_dest_ptr += longs_per_scanline;
       offset += bpl;
        }
        while( --local_height );

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        fMutexTaken = FALSE;

        /* Display the new image. */
        rect.Left = (SHORT)screen_x;
        rect.Top = (SHORT)screen_y;
        rect.Right = rect.Left + (width << 3) - 1;
        rect.Bottom = rect.Top + height - 1;

        if( sc.ScreenBufHandle )
       if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
          assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
              GetLastError() );
    } except(EXCEPTION_EXECUTE_HANDLER)
      {
          assert0(NO, "Handled fault in nt_ega_hi_frozen_std. fs switch?");
          if (fMutexTaken)
             RelMutex(sc.ConsoleBufInfo.hMutex);
          return;
      }
}
#endif /* MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_emm.c ===
/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------

MODULE NAME	: 'Lower layer' of Expanded Memory Manager

	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: April '88

PURPOSE		: NT specific code for EMS LIM rev 4.0
		implementation.

The Following Routines are defined:
		1. host_initialise_EM()
		2. host_deinitialise_EM()
		3. host_allocate_storage()
		4. host_free_storage()
		5. host_reallocate_storage()
		6. host_map_page()
		7. host_unmap_page()
		8. host_alloc_page()
		9. host_free_page()
		10. host_copy_con_to_con()
		11. host_copy_con_to_EM()
		12. host_copy_EM_to_con()
		13. host_copy_EM_to_EM()
		14. host_exchg_con_to_con()
		15. host_exchg_con_to_EM()
		16. host_exchg_EM_to_EM()
		17. host_get_access_key()

*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"

#ifdef LIM

#ifndef MONITOR

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "timeval.h"
#include "xt.h"
#include "emm.h"
#include "sas.h"
#include "debug.h"
#include "umb.h"
#include "host_emm.h"
#include "nt_mem.h"


/*	Global Variables		*/

/*	Forward Declarations		*/

/*	ExternalDeclarations		*/

/*	Local Variables			*/

UTINY	*EM_pagemap_address = 0; /* address of start of pagemap	*/
sys_addr    EM_base_address;	/* EM base intel address */
host_addr   EM_host_base_address = 0;	/* EM base host address */

LOCAL	LONG	EM_size = 0;

	sys_addr    emm_start;
	unsigned int emm_len;
unsigned short EM_starting_page_no;

/*
Support for backwards LIM to speed up backwards M ports

Defines are:
	EM_host_address(offset), returns host address of offset bytes
		into the LIM memory area
	EM_loads(from, to, length), copies length bytes from intel 24 bit
		address from, to host 32 bit address to
	EM_stores(to, from, length), copies length bytes from host 32 bit
		address from to intel 24 bit address to
	EM_moves(from, to, length), copies length bytes from intel 24 bit
		address from to intel 24 bit address to
	EM_memcpy(to, from, length), copies length bytes from host 32 bit
		address from to host 32 bit address to
	EM_pointer(ptr, length), returns a forwards or backwards type
		pointer to ptr for a buffer of size length
*/


#define unix_memmove(dst,src,len) memmove((dst),(src),(len))

#ifdef	BACK_M
#define	EM_host_address(offset) (EM_host_base_address + EM_size - offset)
#define	EM_loads(from, to, length) memcpy(to - (length) + 1, get_byte_addr(from) - (length) + 1, length)
#define	EM_stores(to, from, length) \
	sas_overwrite_memory(to, length); \
	CopyMemory(get_byte_addr(to) - (length) + 1, from - (length) + 1, length)
#define	EM_moves(from,to,length) \
	sas_overwrite_memory(to, length); \
	MoveMemory(get_byte_addr(to) - (length) + 1, get_byte_addr(from) - (length) + 1, length)
#define	EM_memcpy(to, from, length) \
	MoveMemory((to) - (length) + 1, (from) - (length) + 1, length)
#define	EM_pointer(ptr, length) (ptr + length - 1)
#else
#define	EM_host_address(offset) (EM_host_base_address + offset)
#define	EM_loads(from, to, length) memcpy(to, get_byte_addr(from), length)
#define	EM_stores(to, from, length) \
	sas_overwrite_memory(to, length); \
	CopyMemory(get_byte_addr(to), from, length)
#define	EM_moves(from,to,length) \
	sas_overwrite_memory(to, length); \
	MoveMemory(get_byte_addr(to), get_byte_addr(from), length)
#define	EM_memcpy(to, from, length) \
	MoveMemory(to, from, length)
#define	EM_pointer(ptr, length) (ptr)
#endif

#define EM_PAGE_ADDRESS(page_no)    (EM_base_address + page_no * EMM_PAGE_SIZE)


/*
===========================================================================

FUNCTION	: host_initialise_EM

PURPOSE		: allocates the area of memory that is used for
		expanded memory and sets up an area of memory to be used
		for the logical pagemap allocation table.


RETURNED STATUS	: SUCCESS - memory allocated successfully
		  FAILURE - unable to allocate required space

DESCRIPTION	:


=========================================================================
*/
int host_initialise_EM(short size)

/*   IN   short	size		 size of area required in megabytes	*/


{
	long *pagemap_ptr;		/* temp ptr. to logical pagemap	*/
	short i;			/* loop counter			*/
	NTSTATUS    status;

	status = VdmAllocateVirtualMemory(&EM_base_address, size * 0x100000, FALSE);
	if (!NT_SUCCESS(status)) {
#ifdef EMM_DEBUG
	    printf("Couldn't allocate virtual memory for EMM, error code = %lx\n",
		    status);
#endif
	    return FAILURE;
	}
#ifdef EMM_DEBUG
	printf("EMM base address = %lx\n", ((sys_addr)EM_base_address);
#endif

	/* pagemap requires 1 bit per 16K page - i.e. 8 bytes per meg	*/

	if((EM_pagemap_address = (byte *)host_malloc(size * 8)) == (byte *)0)
		return(FAILURE);

	/* initialise pagemap to 0's	*/

	pagemap_ptr = (long *)EM_pagemap_address;
	for(i = 0; i < size * 2; i++)
		*pagemap_ptr++ = 0;

	EM_size = ((long) size) * 0x100000;
	EM_starting_page_no = (unsigned short)(EM_base_address / INTEL_PAGE_SIZE);
	EM_host_base_address = get_byte_addr((sys_addr)EM_base_address);

	return(SUCCESS);


}


/*
===========================================================================

FUNCTION	: host_deinitialise_EM

PURPOSE		: frees the area of memory that was used for
		expanded memory and memory  used
		for the logical pagemap allocation table.


RETURNED STATUS	: SUCCESS - memory freed successfully
		  FAILURE - error ocurred in freeing memory

DESCRIPTION	:


=========================================================================
*/
int host_deinitialise_EM()

{

	if(EM_base_address != 0)
		VdmFreeVirtualMemory(EM_base_address);

	if(EM_pagemap_address != (UTINY *)0)
 		free(EM_pagemap_address);

	EM_size = 0;

	return(SUCCESS);


}


/*
===========================================================================

FUNCTION	: host_allocate_storage

PURPOSE		: allocates an area of memory of requested size, to be
		used as a general data storage area. The area is
		to zeros.

RETURNED STATUS	: storage_ID - (in this case a pointer)
		 NULL - failure to allocate enough space.


DESCRIPTION	: calloc is similar to malloc but returns memory
		initialised to zeros.
		The storage ID returned is a value used to later reference
		the storage area allocated. The macro USEBLOCK in
		"host_emm.h" is used by the manager routines to convert
		this ID into a char pointer

=========================================================================
*/
long host_allocate_storage(int no_bytes)

/*   IN   int	no_bytes	no. of bytes required	*/

{
	return ((long)calloc(1, no_bytes));
}


/*
===========================================================================

FUNCTION	: host_free_storage

PURPOSE		: frees the area of memory that was used for
		data storage


RETURNED STATUS	: SUCCESS - memory freed successfully
		  FAILURE - error ocurred in freeing memory

DESCRIPTION	: In this implementation storage_ID is simply a pointer


=========================================================================
*/
int host_free_storage(long storage_ID)

/*   IN   long	storage_ID		ptr to area of memory	*/

{

	if(storage_ID != (long) 0)
		free((char *)storage_ID);

	return(SUCCESS);

}


/*
===========================================================================

FUNCTION	: host_reallocate_storage

PURPOSE		: increases the size of memory allocated, maintaining the
		contents of the original memory block


RETURNED STATUS	: storage_ID - memory reallocated successfully
		  NULL - error ocurred in reallocating memory

DESCRIPTION	: In this implementation storage_ID is simply a pointer
		Note the value of storage_ID returned may or may not be the
		same as the value given

=========================================================================
*/
long host_reallocate_storage(long storage_ID, int size, int new_size)

/*   IN
long	storage_ID	ptr to area of memory	
int	size		original size - not used in this version
	new_size	new size required
*/
{
	return((long)realloc((char *)storage_ID, new_size));
}


/*
===========================================================================

FUNCTION	: host_map_page

PURPOSE		: produces mapping from an Expanded Memory page to a
		page in Intel physical address space


RETURNED STATUS	: SUCCESS - mapping completed succesfully
		  FAILURE - error ocurred in mapping

DESCRIPTION	: Mapping achieved by simply copying data from the
		expanded memory to Intel memory

=========================================================================
*/

extern NTSTATUS VdmMapDosMemory(ULONG, ULONG, ULONG);

int host_map_page(short EM_page_no, unsigned short segment)

/*   IN
short		EM_page_no;	 Expanded Memory page to be mapped in
unsigned short	segment;	 segment in physical address space to
				 map into
*/

{
	ULONG DosIntelPageNo, VdmIntelPageNo;
	NTSTATUS Status;

	DosIntelPageNo = SEGMENT_TO_INTEL_PAGE(segment);
	VdmIntelPageNo = EMM_PAGE_TO_INTEL_PAGE(EM_page_no) +
			 EM_starting_page_no;


	note_trace2(LIM_VERBOSE,"map page %d to segment 0x%4x", EM_page_no, segment);
	Status = VdmMapDosMemory(DosIntelPageNo,
				 VdmIntelPageNo,
				 EMM_PAGE_SIZE / INTEL_PAGE_SIZE
				 );
#ifdef EMM_DEBUG
	printf("host_map_page, segment=%x, EMpage=%x, Dospage=%x, VdmPage=%x\n",
		segment, EM_page_no, DosIntelPageNo, VdmIntelPageNo);
#endif
	if (NT_SUCCESS(Status)) {
	    return(SUCCESS);
	}
	else
	    return(FAILURE);


}

/*
===========================================================================

FUNCTION	: host_unmap_page

PURPOSE		:unmaps pages from Intel physical address space to an
		Expanded Memory page

RETURNED STATUS	: SUCCESS - unmapping completed succesfully
		  FAILURE - error ocurred in mapping

DESCRIPTION	: Unmapping achieved by simply copying data from Intel
		memory to expanded memory

=========================================================================
*/

extern NTSTATUS VdmUnmapDosMemory(ULONG, ULONG);

int host_unmap_page(unsigned short segment, short EM_page_no)

/*   IN
unsigned short	segment 	segment in physical address space to
				unmap 			
short		EM_page_no 	Expanded Memory page currently
				mapped in			
*/

{
	ULONG	DosIntelPageNo, VdmIntelPageNo;
	NTSTATUS    Status;

	DosIntelPageNo = SEGMENT_TO_INTEL_PAGE(segment);
	VdmIntelPageNo = EMM_PAGE_TO_INTEL_PAGE(EM_page_no) +
			 EM_starting_page_no;

#ifdef EMM_DEBUG
	printf("host_unmap_page, segment=%x, EMpage=%x, Dospage=%x, VdmPage=%x\n",
		segment, EM_page_no, DosIntelPageNo, VdmIntelPageNo);
#endif
	Status = VdmUnmapDosMemory(DosIntelPageNo,
				   EMM_PAGE_SIZE / INTEL_PAGE_SIZE
				   );

	note_trace2(LIM_VERBOSE,"unmap page %d from segment 0x%.4x\n",EM_page_no,segment);
	if (NT_SUCCESS(Status))
	    return (SUCCESS);
	else
	    return(FAILURE);

}


/*
===========================================================================

FUNCTION	: host_alloc_page

PURPOSE		: searches the pagemap looking for a free page, allocates
		that page and returns the EM page no.

RETURNED STATUS	:
		  SUCCESS - Always see note below

DESCRIPTION	: Steps through the Expanded memory Pagemap looking for
		a clear bit, which indicates a free page. When found,
		sets that bit and returns the page number.
		For access purposes the pagemap is divided into long
		word(32bit) sections

NOTE		: The middle layer calling routine (alloc_page()) checks
		that all pages have not been allocated and therefore in
		this implementation the returned status will always be
		SUCCESS.
		However alloc_page still checks for a return status of
		SUCCESS, as some implementations may wish to allocate pages
		dynamically and that may fail.
=========================================================================
*/
short host_alloc_page()

{
	short EM_page_no;		/* page number returned		*/
	long  *ptr;			/* ptr to 32 bit sections in	*/
					/* pagemap			*/
	short i;			/* index into 32 bit section	*/

	NTSTATUS status;

	ptr = (long *)EM_pagemap_address;
	i =0;
	EM_page_no = 0;

	while(*ptr & (MSB >> i++))
	{
		EM_page_no++;

		if(i == 32)
		/*
		 * start on next section
		 */
		{
			ptr++;
			i = 0;
		}	
	}
	/*
	 * Set bit to show that page is allocated
	 */
	*ptr = *ptr | (MSB >> --i);

	/* commit memory to the page */
	status = VdmCommitVirtualMemory(EM_PAGE_ADDRESS(EM_page_no),
					EMM_PAGE_SIZE
					);

	if (!NT_SUCCESS(status))
	    return FAILURE;
	return(EM_page_no);	
}


/*
===========================================================================

FUNCTION	: host_free_page

PURPOSE		: marks the page indicated as being free for further
		allocation

RETURNED STATUS	:
		SUCCESS - Always - see note below	

DESCRIPTION	: clears the relevent bit in the pagemap.

		For access purposes the pagemap is divided into long
		word(32bit) sections.

NOTE		: The middle layer calling routine (free_page()) always
		checks for invalid page numbers so in this implementation		
		the routine will always return SUCCESS.
		However free_page() still checks for a return of SUCCESS
		as other implementations may wish to use it.
=========================================================================
*/
int host_free_page(short EM_page_no)

/*   IN  short 	EM_page_no		page number to be cleared	*/


{
	long  *ptr;			/* ptr to 32 bit sections in	*/
					/* pagemap			*/
	short i;			/* index into 32 bit section	*/


	NTSTATUS    status;

	status = VdmDeCommitVirtualMemory(EM_PAGE_ADDRESS(EM_page_no),
					  EMM_PAGE_SIZE
					  );

	if (!NT_SUCCESS(status))
	    return FAILURE;
	/*
	 * Set pointer to correct 32 bit section and index to correct bit
	 */

	ptr = (long *)EM_pagemap_address;
	ptr += (EM_page_no / 32);
	i = EM_page_no % 32;

	/*
	 * clear bit
	 */
	*ptr = *ptr & ~(MSB >> i);

	return(SUCCESS);	
}


/*
===========================================================================

FUNCTION	: host_copy routines
		host_copy_con_to_con()
		host_copy_con_to_EM()
		host_copy_EM_to_con()
		host_copy_EM_to_EM()

PURPOSE		: copies between conventional and expanded memory


RETURNED STATUS	:
		SUCCESS - Always - see note below	

DESCRIPTION	:
		 The middle layer calling routine always checks for a
		return of SUCCESS as other implementations may
		return FAILURE.
=========================================================================
*/
int host_copy_con_to_con(int length, unsigned short src_seg,
			unsigned short src_off, unsigned short dst_seg,
			unsigned short dst_off)

/*   IN
int		length 		number of bytes to copy	

unsigned short	src_seg 	source segment address	
		src_off 	source offset address	
		dst_seg 	destination segment address	
		dst_off 	destination offset address	
*/
{
	sys_addr from, to;	/* pointers used for copying	*/

	from = effective_addr(src_seg, src_off);
	to = effective_addr(dst_seg, dst_off);

	EM_moves(from, to, length);

	return(SUCCESS);
}

int host_copy_con_to_EM(int length, unsigned short src_seg,
			unsigned short src_off, unsigned short dst_page,
			unsigned short dst_off)

/*   IN
int		length 		number of bytes to copy	

unsigned short	src_seg 	source segment address	
		src_off 	source offset address	
		dst_page 	destination page number	
		dst_off 	destination offset within page	
*/
{
	unsigned char *to;	/* pointers used for copying	*/
	sys_addr from;

	from = effective_addr(src_seg, src_off);
	to = EM_host_address(dst_page * EMM_PAGE_SIZE + dst_off);

	EM_loads(from, to, length);

	return(SUCCESS);
}

int host_copy_EM_to_con(int length, unsigned short src_page,
			unsigned short src_off, unsigned short dst_seg,
			unsigned short dst_off)

/*   IN
int		length 		number of bytes to copy	

unsigned short	src_page 	source page number		
		src_off 	source offset within page	
		dst_seg 	destination segment address	
		dst_off 	destination offset address	
*/
{
	unsigned char *from;	/* pointers used for copying	*/
	sys_addr to;

	from = EM_host_address(src_page * EMM_PAGE_SIZE + src_off);
	to = effective_addr(dst_seg, dst_off);

	EM_stores(to, from, length);

	return(SUCCESS);
}

int host_copy_EM_to_EM(int length, unsigned short src_page,
			unsigned short src_off, unsigned short dst_page,
			unsigned short dst_off)

/*   IN
int		length 		number of bytes to copy	

unsigned short	src_page 	source page number		
		src_off 	source offset within page	
		dst_page 	destination page number	
		dst_off 	destination offset within page	
*/
{
	unsigned char *from, *to;	/* pointers used for copying	*/

	from = EM_host_address(src_page * EMM_PAGE_SIZE + src_off);
	to = EM_host_address(dst_page * EMM_PAGE_SIZE + dst_off);

	EM_memcpy(to, from, length);

	return(SUCCESS);
}


/*
===========================================================================

FUNCTION	: host_exchange routines
		host_exchg_con_to_con()
		host_exchg_con_to_EM()
		host_exchg_EM_to_EM()

PURPOSE		: exchanges data between conventional and expanded memory


RETURNED STATUS	:
		SUCCESS - Everything ok
		FAILURE - Memory allocation failure

DESCRIPTION	:

=========================================================================
*/
int host_exchg_con_to_con(int length, unsigned short src_seg,
			unsigned short src_off, unsigned short dst_seg,
			unsigned short dst_off)

/*   IN
int		length		number of bytes to copy	

unsigned short	src_seg		 source segment address	
		src_off		 source offset address	
		dst_seg		 destination segment address	
		dst_off		 destination offset address		
*/
{
	unsigned char *temp, *pointer;/* pointers used for copying	*/
	sys_addr to, from;

	if ((temp = (unsigned char *)host_malloc(length)) == (unsigned char *)0)
		return(FAILURE);

	pointer = EM_pointer(temp, length);

	from = effective_addr(src_seg, src_off);
	to = effective_addr(dst_seg, dst_off);

	EM_loads(from, pointer, length);    /* source -> temp */
	EM_moves(to, from, length);	    /* dst -> source */
	EM_stores(to, pointer, length);     /* temp -> dst */

	free(temp);

	return(SUCCESS);
}

int host_exchg_con_to_EM(int length, unsigned short src_seg,
			unsigned short src_off, unsigned short dst_page,
			unsigned short dst_off)

/*   IN
int		length 		number of bytes to copy	

unsigned short	src_seg 	source segment address	
		src_off 	source offset address	
		dst_page 	destination page number	
		dst_off 	destination offset within page	
*/
{
	unsigned char *to, *temp, *pointer;/* pointers used for copying	*/
	sys_addr from;

	if ((temp = (unsigned char *)host_malloc(length)) == (unsigned char *)0)
		return(FAILURE);

	pointer = EM_pointer(temp, length);

	from = effective_addr(src_seg, src_off);
	to = EM_host_address(dst_page * EMM_PAGE_SIZE + dst_off);

	EM_loads(from, pointer, length);
	EM_stores(from, to, length);
	EM_memcpy(to, pointer, length);

	free(temp);

	return(SUCCESS);
}

int host_exchg_EM_to_EM(int length, unsigned short src_page,
			unsigned short src_off, unsigned short dst_page,
			unsigned short dst_off)

/*   IN
int		length		number of bytes to copy	

unsigned short	src_page 	source page number		
		src_off 	source offset within page	
		dst_page 	destination page number	
		dst_off 	destination offset within page	
*/
{
	unsigned char *from, *to, *temp, *pointer;
	/* pointers used for copying	*/

	if ((temp = (unsigned char *)host_malloc(length)) == (unsigned char *)0)
		return(FAILURE);

	pointer = EM_pointer(temp, length);

	from = EM_host_address(src_page * EMM_PAGE_SIZE + src_off);
	to = EM_host_address(dst_page * EMM_PAGE_SIZE + dst_off);

	EM_memcpy(pointer, from, length);
	EM_memcpy(from, to, length);
	EM_memcpy(to, pointer, length);

	free(temp);

	return(SUCCESS);
}


/*
===========================================================================

FUNCTION	: host_get_access_key

PURPOSE		: produces a random access key for use with LIM function 30
		'Enable/Disable OS/E Function Set Functions'

RETURNED STATUS	: none

DESCRIPTION	: Two 16 bit random values are required for the 'access key'
		We use the microsecond field from the get time of day routine
		to provide this.

=========================================================================
*/
void host_get_access_key(unsigned short access_key[2])

/*  OUT  unsigned short	access_key[2]	source segment address		*/

{
	struct host_timeval time;   /* structure for holding time	*/

        host_GetSysTime(&time);

        access_key[0] = time.tv_usec & 0xffff;
	access_key[1] = (time.tv_usec  >> 3) & 0xffff;

	return;
}

#endif /* MONITOR */
	
#endif /* LIM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_cpu.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title	: NT 3.0 CPU initialization
 *
 * Description	: Initialize the CPU and its registers.
 *
 * Author	: Paul Huckle / Henry Nash
 *
 * Notes	: None
 */

static char SccsID[]="@(#)sun4_a3cpu.c	1.2 5/24/91 Copyright Insignia Solutions Ltd.";

#include <stdio.h>
#include <sys/types.h>
#include <malloc.h>
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "trace.h"
#include "yoda.h"
#include "debug.h"

#include "sim32.h"

#ifdef CPU_40_STYLE
#include "cpu_c.h"
#endif

GLOBAL	quick_event_delays	host_delays;
GLOBAL	host_addr Start_of_M_area;
#ifdef CPU_40_STYLE
GLOBAL	IHPE Length_of_M_area;
#else
GLOBAL  IU32 Length_of_M_area;
#endif
#ifdef A2CPU
extern	void	route_on();
extern	void	route_on_fragment_no_interrupt_check();
extern	void	service_int();
#endif

#ifdef I286
extern word	m_s_w;
word		protected_mode;
word		gdt_limit;
long		gdt_base;
word		idt_limit;
long		idt_base;
#endif

#define setBASE(base, value) base = (0xff000000 | (value & 0xffffff))
#define setLIMIT(limit, value) limit = value

#ifndef PROD
    extern RTL_CRITICAL_SECTION IcaLock;
#endif




/*
	Host_start_cpu: This function starts up the cpu emulation if
	we are running a software emulation, or if a 486 is present,
	starts up this emulation.
*/
void	host_start_cpu()
{
  cpu_simulate ();
}


/*
	host_simulate: This function starts up the cpu emulation
	for recursive CPU calls from the Insignia BIOS
*/
void	host_simulate()
{
    ASSERT(IcaLock.OwningThread != NtCurrentTeb()->ClientId.UniqueThread);

#ifdef _ALPHA_
    //
    // For Alpha AXP, set the arithmetic trap ignore bit since the code
    // generators are incapable of generating proper Alpha instructions
    // that follow trap shadow rules.
    //
    // N.B. In this mode all floating point arithmetic traps are ignored.
    //      Imprecise exceptions are not converted to precise exceptions
    //      and correct IEEE results are not stored in the destination
    //      registers of trapping instructions. Only the hardware FPCR
    //      status bits can be used to determine if any traps occurred.
    //

    ((PSW_FPCR)&(NtCurrentTeb()->FpSoftwareStatusRegister))->ArithmeticTrapIgnore = 1;
#endif

    cpu_simulate ();

    ASSERT(IcaLock.OwningThread != NtCurrentTeb()->ClientId.UniqueThread);
}


/*
	Host_set_hw_int: Cause a hardware interrupt to be generated. For
	software cpu this just means setting a bit in cpu_interrupt_map.
*/
void	host_set_hw_int()
{
	cpu_interrupt(CPU_HW_INT, 0);
}

/*
	Host_clear_hw_int: Cause a hardware interrupt to be cleared. For
	software cpu this just means clearing a bit in cpu_interrupt_map.
        Monitor has it's own version, a3 cpu has it's own (differently named
        version).
*/
#ifndef MONITOR
void	host_clear_hw_int()
{
#ifndef CCPU
#ifdef CPU_40_STYLE

    cpu_clearHwInt();
#else
    IMPORT void a3_cpu_clear_hw_int();

    a3_cpu_clear_hw_int();
#endif /* CPU_40_STYLE */
#endif /* not CCPU */
}
#endif


#ifdef CCPU

void host_cpu_init() {}

#endif

#ifdef A3CPU
void host_cpu_init()
{
	host_delays.com_delay = 10;
	host_delays.keyba_delay = 8;
	host_delays.timer_delay = 7;
	host_delays.fdisk_delay_1 = 100;
	host_delays.fdisk_delay_2 = 750;
	host_delays.fla_delay = 0;
}

void setSTATUS(word flags)
{
    setNT((flags >> 14) & 1);
    setIOPL((flags >> 12) & 3);
    setOF((flags >> 11) & 1);
    setDF((flags >> 10) & 1);
    setIF((flags >> 9) & 1);
    setTF((flags >> 8) & 1);
    setSF((flags >> 7) & 1);
    setZF((flags >> 6) & 1);
    setAF((flags >> 4) & 1);
    setPF((flags >> 2) & 1);
    setCF(flags & 1);
}

/*
 * Do the Iret for the benefit of the Iret hooks.
 * Unwind stack for flags, cs & ip.
 * Seems too simple - does the CPU require more cleanup information???
 * or will the unwinding bop sort it out??
 */
VOID EmulatorEndIretHook()
{
    UNALIGNED word *sptr;

    /* Stack points at CS:IP & Flags of interrupted instruction */
    sptr = (word *)Sim32GetVDMPointer( (getSS() << 16)|getSP(), 2, (UCHAR)(getPE() ? TRUE : FALSE));
    if (sptr)
    {
        setIP(*sptr++);
        setCS(*sptr++);
        setSTATUS(*sptr);
        setSP(getSP()+6);
    }
#ifndef PROD
    else
        printf("NTVDM extreme badness - can't get stack pointer %x:%x mode:%d\n",getSS(), getSP(), getPE());
#endif  /* PROD */
}
#endif /* A3CPU */

void host_cpu_reset()
{
}


void host_cpu_interrupt()
{
}

#ifdef CPU_40_STYLE

typedef struct NT_CPU_REG {
    IU32 *nano_reg;         /* where the nano CPU keeps the register */
    IU32 *reg;              /* where the light compiler keeps the reg */
    IU32 *saved_reg;        /* where currently unused bits are kept */
    IU32 universe_8bit_mask;/* is register in 8-bit form? */
    IU32 universe_16bit_mask;/* is register in 16-bit form? */
} NT_CPU_REG;

typedef struct NT_CPU_INFO {
    /* Variables for deciding what mode we're in */
    BOOL *in_nano_cpu;      /* is the Nano CPU executing? */
    IU32 *universe;         /* the mode that the CPU is in */

    /* General purpose register pointers */
    NT_CPU_REG eax, ebx, ecx, edx, esi, edi, ebp;

    /* Variables for getting SP or ESP. */
    BOOL *stack_is_big;     /* is the stack 32-bit? */
    IU32 *nano_esp;         /* where the Nano CPU keeps ESP */
    IU8 **host_sp;          /* ptr to variable holding stack pointer as a
                               host address */
    IU8 **ss_base;          /* ptr to variables holding base of SS as a
                               host address */
    IU32 *esp_sanctuary;    /* top 16 bits of ESP if we're now using SP */

    IU32 *eip;

    /* Segment registers. */
    IU16 *cs, *ds, *es, *fs, *gs, *ss;

    IU32 *flags;

    /* CR0, mainly to let us figure out if we're in real or protect mode */
    IU32 *cr0;
} NT_CPU_INFO;

GLOBAL NT_CPU_INFO nt_cpu_info;

LOCAL void initNtCpuRegInfo IFN6(
    NT_CPU_REG *, info,
    IU32 *, nano_reg,
    IU32 *, main_reg,
    IU32 *, saved_reg,
    IU32, in_8bit_form,
    IU32, in_16bit_form
)
{
    info->nano_reg = nano_reg;
    info->reg = main_reg;
    info->saved_reg = saved_reg;
    info->universe_8bit_mask = in_8bit_form;
    info->universe_16bit_mask = in_16bit_form;
}



GLOBAL void InitNtCpuInfo IFN0()
{
    BOOL *gdp_bool;

    /* Variables for deciding what mode we're in, and hence where the */
    /* register values are kept. */

    /* Horrible hack, part 1. InNanoCpu is a BOOL, so GLOBAL_InNanoCpu */
    /* is not an l-value, hence we can't take its address. */
#ifdef ALPHA
    nt_cpu_info.in_nano_cpu = (BOOL *) ((IHPE) GDP_PTR + 1223);
#else /* ALPHA */
    nt_cpu_info.in_nano_cpu = (BOOL *) ((IHPE) GDP_PTR + 631);
#endif /* ALPHA */
#ifndef PROD
    gdp_bool = (BOOL *) ((IHPE) GDP_PTR + GdpOffsetFromName("InNanoCpu"));
    if (nt_cpu_info.in_nano_cpu != gdp_bool) {
        always_trace0("InNanoCpu GDP offset will be wrong in PROD builds");
    }
    nt_cpu_info.in_nano_cpu = gdp_bool;
#endif

    nt_cpu_info.universe = &GLOBAL_CurrentUniverse;

    /* Variables needed to get the value SP or ESP. */

    /* Horrible hack, part 2: as for InNanoCpu, so for stackIsBig. */
#ifdef ALPHA
    nt_cpu_info.stack_is_big = (BOOL *) ((IHPE) GDP_PTR + 7047);
#else /* ALPHA */
    nt_cpu_info.stack_is_big = (BOOL *) ((IHPE) GDP_PTR + 4355);
#endif /* ALPHA */
#ifndef PROD
    gdp_bool = (BOOL *) ((IHPE) GDP_PTR + GdpOffsetFromName("stackIsBig"));
    if (nt_cpu_info.stack_is_big != gdp_bool) {
        always_trace0("stackIsBig GDP offset will be wrong in PROD builds");
    }
    nt_cpu_info.stack_is_big = gdp_bool;
#endif

    nt_cpu_info.nano_esp = &GLOBAL_nanoEsp;
    nt_cpu_info.host_sp = &GLOBAL_HSP;
    nt_cpu_info.ss_base = &GLOBAL_notionalSsBase;
    nt_cpu_info.esp_sanctuary = &GLOBAL_ESPsanctuary;

    /* Pointers to the segment registers. */
    nt_cpu_info.cs = &GLOBAL_CsSel;
    nt_cpu_info.ds = &GLOBAL_DsSel;
    nt_cpu_info.es = &GLOBAL_EsSel;
    nt_cpu_info.fs = &GLOBAL_FsSel;
    nt_cpu_info.gs = &GLOBAL_GsSel;
    nt_cpu_info.ss = &GLOBAL_SsSel;

    /* EIP & flags, neither of which are likely to be very reliable. */
    nt_cpu_info.eip = (IU32 *)&GLOBAL_CleanedRec;
    nt_cpu_info.flags = &GLOBAL_EFLAGS;

    nt_cpu_info.cr0 = &GLOBAL_R_CR0;
    /* General purpose registers. */
    initNtCpuRegInfo(&nt_cpu_info.eax, &GLOBAL_nanoEax, &GLOBAL_R_EAX,
                     &GLOBAL_EAXsaved, 1 << ConstraintRAL_LS8,
                     1 << ConstraintRAX_LS16);
    initNtCpuRegInfo(&nt_cpu_info.ebx, &GLOBAL_nanoEbx, &GLOBAL_R_EBX,
                     &GLOBAL_EBXsaved, 1 << ConstraintRBL_LS8,
                     1 << ConstraintRBX_LS16);
    initNtCpuRegInfo(&nt_cpu_info.ecx, &GLOBAL_nanoEcx, &GLOBAL_R_ECX,
                     &GLOBAL_ECXsaved, 1 << ConstraintRCL_LS8,
                     1 << ConstraintRCX_LS16);
    initNtCpuRegInfo(&nt_cpu_info.edx, &GLOBAL_nanoEdx, &GLOBAL_R_EDX,
                     &GLOBAL_EDXsaved, 1 << ConstraintRDL_LS8,
                     1 << ConstraintRDX_LS16);
    initNtCpuRegInfo(&nt_cpu_info.esi, &GLOBAL_nanoEsi, &GLOBAL_R_ESI,
                     &GLOBAL_ESIsaved, 0, 1 << ConstraintRSI_LS16);
    initNtCpuRegInfo(&nt_cpu_info.edi, &GLOBAL_nanoEdi, &GLOBAL_R_EDI,
                     &GLOBAL_EDIsaved, 0, 1 << ConstraintRDI_LS16);
    initNtCpuRegInfo(&nt_cpu_info.ebp, &GLOBAL_nanoEbp, &GLOBAL_R_EBP,
                     &GLOBAL_EBPsaved, 0, 1 << ConstraintRBP_LS16);
}

#endif /* CPU_40_STYLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_devs.h ===
/*
    The following definitions were derived from the "CD-ROM Programmer's
    Guide for MS-DOS CD-ROM Extensions, Version 2.21" January 1992
                                                                      */
#define MSCDEX_VERSION  0x0215

#define CDSTAT_ERROR    0X8000
#define CDSTAT_BUSY     0X0200
#define CDSTAT_DONE     0X0100

#define CDERR_WRITE_PROTECT 0
#define CDERR_UNKNOWN_UNIT  1
#define CDERR_NOT_READY     2
#define CDERR_UNKNOWN_CMD   3
#define CDERR_CRC           4
#define CDERR_STRUCT_LENGTH 5
#define CDERR_SEEK          6
#define CDERR_UNKNOWN_MEDIA 7
#define CDERR_SECT_NOTFOUND 8
#define CDERR_WRITE_FAULT   10
#define CDERR_READ_FAULT    11
#define CDERR_GENERAL       12
#define CDERR_PARAMETER     13          // Per mscdex spec
#define CDERR_DISK_CHANGE   15

#define DEVICE_INIT         0
#define IOCTL_READ          3
#define INPUT_FLUSH         7
#define OUTPUT_FLUSH        11
#define IOCTL_WRITE         12
#define DEVICE_OPEN         13
#define DEVICE_CLOSE        14
#define READ_LONG           128
#define READ_LONG_PREFETCH  130
#define SEEK                131
#define PLAY_AUDIO          132
#define STOP_AUDIO          133
#define WRITE_LONG          134
#define WRITE_LONG_VERIFY   135
#define RESUME_AUDIO        136


#define IOCTLR_RADDR        0
#define IOCTLR_LOCHEAD      1
#define IOCTLR_ERRSTAT      3
#define IOCTLR_AUDINFO      4
#define IOCTLR_DRVBYTES     5
#define IOCTLR_DEVSTAT      6
#define IOCTLR_SECTSIZE     7
#define IOCTLR_VOLSIZE      8
#define IOCTLR_MEDCHNG      9
#define IOCTLR_DISKINFO     10
#define IOCTLR_TNOINFO      11
#define IOCTLR_QINFO        12
#define IOCTLR_SUBCHANINFO  13
#define IOCTLR_UPCCODE      14
#define IOCTLR_AUDSTAT      15

#define IOCTLW_EJECT        0
#define IOCTLW_LOCKDOOR     1
#define IOCTLW_RESETDRV     2
#define IOCTLW_AUDINFO      3
#define IOCTLW_DRVBYTES     4
#define IOCTLW_CLOSETRAY    5

#define MODE_HSG            0
#define MODE_REDBOOK        1

typedef union _SECTOR_ADDR {
    BYTE b[4];
    ULONG dw;
} SECTOR_ADDR;


#pragma pack(1)

typedef struct _REQUESTHEADER {
    BYTE rhLength;
    BYTE rhUnit;
    BYTE rhFunction;
    WORD rhStatus;
    BYTE rhReserved[8];

    BYTE irwrData;
    LPBYTE irwrBuffer;
    WORD irwrBytes;
} REQUESTHEADER, *LPREQUESTHEADER;

typedef struct _DEVICE_HEADER {
    DWORD link;
    WORD attributes;
    WORD strategy;
    WORD interrupt;
    BYTE name[8];
    WORD reserved;
    BYTE drive;
    BYTE numunits;
    BYTE reserved2[10];
} DEVICE_HEADER, *PDEVICE_HEADER;

typedef struct _DRIVE_DEVICE_LIST {
    BYTE Unit;
    DWORD DeviceHeader;
} DRIVE_DEVICE_LIST, *PDRIVE_DEVICE_LIST;


typedef struct _IOCTLR_RADDR_BLOCK {
    BYTE ctlcode;                   // 0
    DWORD devheader;
} IOCTLR_RADDR_BLOCK, *PIOCTLR_RADDR_BLOCK;


typedef struct _IOCTLR_LOCHEAD_BLOCK {
    BYTE ctlcode;                   // 1
    BYTE addrmode;
    SECTOR_ADDR headlocation;
} IOCTLR_LOCHEAD_BLOCK, *PIOCTLR_LOCHEAD_BLOCK;


typedef struct _IOCTLR_ERRSTAT_BLOCK {
    BYTE ctlcode;                   // 3
    BYTE statistics;                // array of undefined length
} IOCTLR_ERRSTAT_BLOCK, *PIOCTLR_ERRSTAT_BLOCK;


typedef struct _IOCTLR_AUDINFO_BLOCK {
    BYTE ctlcode;                   // 4
    BYTE chan0;
    BYTE vol0;
    BYTE chan1;
    BYTE vol1;
    BYTE chan2;
    BYTE vol2;
    BYTE chan3;
    BYTE vol3;
} IOCTLR_AUDINFO_BLOCK, *PIOCTLR_AUDINFO_BLOCK;


typedef struct _IOCTLR_DRVBYTES_BLOCK {
    BYTE ctlcode;                   // 5
    BYTE numbytes;
    BYTE buffer[128];
} IOCTLR_DRVBYTES_BLOCK, *PIOCTLR_DRVBYTES_BLOCK;


typedef struct _IOCTLR_DEVSTAT_BLOCK {
    BYTE ctlcode;                   // 6
    DWORD devparms;
} IOCTLR_DEVSTAT_BLOCK, *PIOCTLR_DEVSTAT_BLOCK;

#define DEVSTAT_DOOR_OPEN       0X00000001
#define DEVSTAT_DOOR_UNLOCKED   0X00000002
#define DEVSTAT_SUPPORTS_COOKED 0X00000004
#define DEVSTAT_READ_WRITE      0X00000008
#define DEVSTAT_PLAYS_AV        0X00000010
#define DEVSTAT_SUPPORTS_ILEAVE 0X00000020
#define DEVSTAT_SUPPORTS_PRFTCH 0X00000080
#define DEVSTAT_SUPPORTS_CHMAN  0X00000100
#define DEVSTAT_SUPPORTS_RBOOK  0X00000200
#define DEVSTAT_NO_DISC         0X00000800
#define DEVSTAT_SUPPORTS_RWSCH  0X00001000


typedef struct _IOCTLR_SECTSIZE_BLOCK {
    BYTE ctlcode;                   // 7
    BYTE readmode;
    WORD sectsize;
} IOCTLR_SECTSIZE_BLOCK, *PIOCTLR_SECTSIZE_BLOCK;


typedef struct _IOCTLR_VOLSIZE_BLOCK {
    BYTE ctlcode;                   // 8
    DWORD size;
} IOCTLR_VOLSIZE_BLOCK, *PIOCTLR_VOLSIZE_BLOCK;


typedef struct _IOCTLR_MEDCHNG_BLOCK {
    BYTE ctlcode;                   // 9
    BYTE medbyte;
} IOCTLR_MEDCHNG_BLOCK, *PIOCTLR_MEDCHNG_BLOCK;

#define MEDCHNG_NOT_CHANGED 1
#define MEDCHNG_DONT_KNOW   0
#define MEDCHNG_CHANGED     0XFF


typedef struct _IOCTLR_DISKINFO_BLOCK {
    BYTE ctlcode;                   // 10
    BYTE tracklow;
    BYTE trackhigh;
    SECTOR_ADDR startleadout;
} IOCTLR_DISKINFO_BLOCK, *PIOCTLR_DISKINFO_BLOCK;


typedef struct _IOCTLR_TNOINFO_BLOCK {
    BYTE ctlcode;                   // 11
    BYTE trknum;
    SECTOR_ADDR start;
    BYTE trkctl;
} IOCTLR_TNOINFO_BLOCK, *PIOCTLR_TNOINFO_BLOCK;


typedef struct _IOCTLR_QINFO_BLOCK {
    BYTE ctlcode;                   // 12
    BYTE ctladr;
    BYTE trknum;
    BYTE pointx;
    BYTE min;
    BYTE sec;
    BYTE frame;
    BYTE zero;
    BYTE apmin;
    BYTE apsec;
    BYTE apframe;
} IOCTLR_QINFO_BLOCK, *PIOCTLR_QINFO_BLOCK;


typedef struct _IOCTLR_SUBCHANINFO_BLOCK {
    BYTE ctlcode;                   // 13
    SECTOR_ADDR startsect;
    DWORD transaddr;
    DWORD numsect;
} IOCTLR_SUBCHANINFO_BLOCK, *PIOCTLR_SUBCHANINFO_BLOCK;


typedef struct _IOCTLR_UPCCODE_BLOCK {
    BYTE ctlcode;                   // 14
    BYTE ctladr;
    BYTE upcean[7];
    BYTE zero;
    BYTE aframe;
} IOCTLR_UPCCODE_BLOCK, *PIOCTLR_UPCCODE_BLOCK;


typedef struct _IOCTLR_AUDSTAT_BLOCK {
    BYTE ctlcode;                   // 15
    WORD audstatbits;
    SECTOR_ADDR startloc;
    SECTOR_ADDR endloc;
} IOCTLR_AUDSTAT_BLOCK, *PIOCTLR_AUDSTAT_BLOCK;

#define AUDSTAT_PAUSED 1


typedef struct _IOCTLW_LOCKDOOR_BLOCK {
    BYTE ctlcode;                   // 1
    BYTE lockfunc;
} IOCTLW_LOCKDOOR_BLOCK, *PIOCTLW_LOCKDOOR_BLOCK;


typedef struct _IOCTLW_AUDINFO_BLOCK {
    BYTE ctlcode;                   // 3
    BYTE chan0;
    BYTE vol0;
    BYTE chan1;
    BYTE vol1;
    BYTE chan2;
    BYTE vol2;
    BYTE chan3;
    BYTE vol3;
} IOCTLW_AUDINFO_BLOCK, *PIOCTLW_AUDINFO_BLOCK;


typedef struct _IOCTLW_DRVBYTES_BLOCK {
    BYTE ctlcode;                   // 4
    BYTE buffer;
} IOCTLW_DRVBYTES_BLOCK, *PIOCTLW_DRVBYTES_BLOCK;



typedef struct _READ_LONG_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    DWORD transaddr;
    WORD numsect;
    SECTOR_ADDR startsect;
    BYTE readmode;
    BYTE ileavesize;
    BYTE ileaveskip;
} READ_LONG_BLOCK, *PREAD_LONG_BLOCK;


typedef struct _SEEK_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    DWORD transaddr;
    WORD numsect;
    SECTOR_ADDR startsect;
} SEEK_BLOCK, *PSEEK_BLOCK;


typedef struct _PLAY_AUDIO_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    SECTOR_ADDR startsect;
    DWORD numsect;
} PLAY_AUDIO_BLOCK, *PPLAY_AUDIO_BLOCK;


typedef struct _WRITE_LONG_BLOCK {
    BYTE header[13];
    BYTE addrmode;
    DWORD transaddr;
    WORD numsect;
    SECTOR_ADDR startsect;
    BYTE readmode;
    BYTE ileavesize;
    BYTE ileaveskip;
} WRITE_LONG_BLOCK, *PWRITE_LONG_BLOCK;


#pragma pack()

#define MAXDRIVES 26

typedef VOID (*PFNSVC)(VOID);

typedef struct _DRIVE_INFO {
    HANDLE Handle;
    USHORT DriveNum;
    USHORT LogicalBlocksPerSecond;
    BOOLEAN Playing;
    BOOLEAN Paused;
    BOOLEAN ValidVTOC;
    BOOLEAN StatusAvailable;
    DWORD LastError;
    BYTE    MediaStatus;
    SECTOR_ADDR PlayStart; //BUGBUG zero on reset, new disc, play complete
    DWORD   PlayCount;
    SUB_Q_CURRENT_POSITION current;
    CDROM_TOC VTOC;
} DRIVE_INFO, *PDRIVE_INFO;


VOID ApiReserved (VOID);
VOID ApiGetNumberOfCDROMDrives (VOID);
VOID ApiGetCDROMDriveList (VOID);
VOID ApiGetCopyrightFileName (VOID);
VOID ApiGetAbstractFileName (VOID);
VOID ApiGetBDFileName (VOID);
VOID ApiReadVTOC (VOID);
VOID ApiAbsoluteDiskRead (VOID);
VOID ApiAbsoluteDiskWrite (VOID);
VOID ApiCDROMDriveCheck (VOID);
VOID ApiMSCDEXVersion (VOID);
VOID ApiGetCDROMDriveLetters (VOID);
VOID ApiGetSetVolDescPreference (VOID);
VOID ApiGetDirectoryEntry (VOID);
VOID ApiSendDeviceRequest (VOID);
VOID IOCTLRead (VOID);
VOID IOCTLWrite (VOID);

PCDROM_TOC ReadTOC (PDRIVE_INFO DrvInfo);
BOOLEAN GetAudioStatus (PDRIVE_INFO DrvInfo);

DWORD
ProcessError(
    PDRIVE_INFO DrvInfo,
    USHORT Command,
    USHORT Subcmd
    );

HANDLE
OpenPhysicalDrive(
    int DriveNum
    );




#define DEBUG_MOD    0x01
#define DEBUG_API    0x02
#define DEBUG_IO     0x04
#define DEBUG_STATUS 0x08
#define DEBUG_ERROR  0x80

#ifdef DEBUG

USHORT DebugLevel = 0;

#define DebugPrint(LEVEL,STRING)                \
    {                                           \
        if (DebugLevel & LEVEL)                 \
            OutputDebugString (STRING);         \
    }

#define DebugFmt(LEVEL,STRING, PARM)            \
    {                                           \
    char szBuffer[80];                          \
        if (DebugLevel & LEVEL) {               \
            sprintf (szBuffer, STRING, PARM);   \
            OutputDebugString (szBuffer);       \
        }                                       \
    }

#else

#define DebugPrint(LEVEL,STRING) {}
#define DebugFmt(LEVEL,STRING,PARM) {}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_eoi.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title        :       Host EOI hook controller
 *
 * Description  :       This module handles host specific ica code
 *                      - EOI hook
 *                      - ICA lock
 *
 * Author       :       D.A.Bartlett
 *
 * Notes        :   30-Oct-1993 Jonle , Rewrote it
 */


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <stdio.h>
#include <vdm.h>
#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include CpuH
#include "sas.h"
#include "quick_ev.h"
#include "ica.h"
#include "host_rrr.h"
#include "error.h"
#include "nt_uis.h"
#include "nt_reset.h"
#include "nt_eoi.h"

// from monitor.lib
HANDLE ThreadLookUp(PVOID);
extern PVOID CurrentMonitorTeb;

// from nt_timer.c
extern ULONG GetPerfCounter(VOID);
extern BOOLEAN HandshakeInProgress;


RTL_CRITICAL_SECTION IcaLock;   // ICA critical section lock

//
// IcaLockTimeout is used by VDM kernel component to wait on IcaLock. It is One second
// timeout in 100 nanosecond units.  For User mode NTVDM, the timeout is controlled by
// RTL critical section timeout value.
//
LARGE_INTEGER IcaLockTimeout = {(ULONG)(-1 * 1000 * 1000 * 10), -1};

ULONG UndelayIrqLine=0;
ULONG DelayIrqLine=0xffffffff;  // all ints are blocked until, spckbd loaded

#ifdef MONITOR
ULONG iretHookActive=0;
ULONG iretHookMask  =0;
ULONG AddrIretBopTable=0;  // seg:offset
#endif

HANDLE hWowIdleEvent = INVALID_HANDLE_VALUE;

/*
 *  EOI defines, types, global data
 *
 */
static EOIHOOKPROC EoiHooks[16]={NULL};  // must be init to NULL


#ifndef MONITOR
void DelayIrqQuickEvent(long param);
q_ev_handle DelayHandle[16];
#define pNtVDMState ((PULONG)(Start_of_M_area + FIXED_NTVDMSTATE_LINEAR))

LARGE_INTEGER BlockTime = {0,0};
extern LARGE_INTEGER CurrHeartBeat;
void host_TimeStamp(PLARGE_INTEGER pliTime);
#endif


/*
 * Called by wow32 to fetch the hWowIdleEvent, which wowexec waits on
 * in the wow nonpreemptive scheduler.
 */
HANDLE RegisterWOWIdle(VOID)
{
    return hWowIdleEvent;
}

/*
 * Called by WOW32 to inform the WOW idle code that the current WOW
 * task may be scheduled\descheduled.
 */

void
BlockWOWIdle(
     BOOL Blocking
     )
{
   host_ica_lock();

   if (Blocking) {
       *pNtVDMState |= VDM_WOWBLOCKED;

#ifndef MONITOR
       BlockTime = CurrHeartBeat;
#endif

       }
   else {
       *pNtVDMState &= ~VDM_WOWBLOCKED;



#ifndef MONITOR
       if (BlockTime.QuadPart &&
           (CurrHeartBeat.QuadPart >= BlockTime.QuadPart + SYSTEM_TICK_INTV/2))
          {
           BlockTime.QuadPart = 0;
           host_ica_unlock();

           ActivityCheckAfterTimeSlice();
           return;
           }
#endif
       }

   host_ica_unlock();
}



/*
 *  (WOWIdle)...check if an app requires hw interrupts servicing but all WOW
 *   threads are blocked. If so then the call will cause wowexec to awaken
 *   to handle them. Called from ica interrupt routines. NB. Default action
 *   of routine is to check state and return as fast as possible.
 */
void
WOWIdle(
     BOOL Force
     )
{
    if (VDMForWOW && (Force || (*pNtVDMState & VDM_WOWBLOCKED))) {
        SetEvent(hWowIdleEvent);
        }

}




/*  RegisterEoiHook
 *
 *  Registers an call back function to be invoked upon eoi of
 *  a hardware interrupt.
 *
 *  entry: IrqLine     -  IrqNumber to register
 *         EoiHookProc -  function pointer to be called upon eoi
 *
 *  returns FALSE if the the IrqLine already has an eoi hook registered
 */
BOOL RegisterEOIHook(int IrqLine, EOIHOOKPROC EoiHookProc)
{

    if (!EoiHooks[IrqLine]) {
        EoiHooks[IrqLine] = EoiHookProc;
        return(TRUE);
        }

    return(FALSE);
}



/*  RemoveEOIHook
 *
 *  entry: IrqLine     -  IrqNumber to remove
 *         EoiHookProc -  function pointer previously registered
 */
BOOL RemoveEOIHook(int IrqLine, EOIHOOKPROC EoiHookProc)
{
    if (EoiHooks[IrqLine] == EoiHookProc) {
        EoiHooks[IrqLine] = NULL;
        return(TRUE);
        }
    return(FALSE);
}



/*   host_EOI_hook
 *
 *   base callback function to invoke device specific Eoi Hook routines
 *
 *   Entry: IrqLine    - Line number
 *          CallCount  - The ica Call count for this Irq
 *                       If the Call count is -1 then a pending
 *                       interrupt is being canceled.
 *
 */
VOID host_EOI_hook(int IrqLine, int CallCount)
{
     if ((ULONG)IrqLine >= sizeof(EoiHooks)/sizeof(EOIHOOKPROC)) {
#if DBG
         DbgPrint("ntvdm.Eoi_hook: Invalid IrqLine=%lx\n", (ULONG)IrqLine);
#endif
         return;
         }

     if (EoiHooks[IrqLine]) {
         (*EoiHooks[IrqLine])(IrqLine, CallCount);
         }
}


/*  host_DelayHwInterrupt
 *
 *  base callback function to queue a HW interrupt at a later time
 *
 *  entry: IrqLineNum   - Irq Line Number
 *         CallCount - Number of interrupts, May be Zero
 *         Delay     - Delay time in usecs
 *                     if Delay is 0xFFFFFFFF then per IrqLine data
 *                     structures are freed, use for cleanup when
 *                     the IrqLine is no longer needed for DelayedInterrupts
 *
 *  Notes: The expected granularity is around 1 msec, but varies depending
 *         on the platform.
 *
 *
 */
BOOL host_DelayHwInterrupt(int IrqLineNum, int CallCount, ULONG Delay)
{
   int adapter;
   ULONG  IrqLine;

#ifdef MONITOR
   NTSTATUS status;
   VDMDELAYINTSDATA DelayIntsData;
#else
   ULONG TicCount;
#endif

   host_ica_lock();

   //
   // Anything to do (only one delayed Irql at a time)
   //

   IrqLine = 1 << IrqLineNum;
   if (!(DelayIrqLine & IrqLine) || Delay == 0xffffffff) {

       //
       // force a minimum delay of 1 ms
       //
       if (Delay < 1000) {
           Delay = 1000;
           }

#ifdef MONITOR

       //
       // Set Kernel timer for this IrqLine
       //
       DelayIntsData.Delay        = Delay;
       DelayIntsData.DelayIrqLine = IrqLineNum;
       DelayIntsData.hThread      = ThreadLookUp(CurrentMonitorTeb);
       if (DelayIntsData.hThread) {
           status = NtVdmControl(VdmDelayInterrupt, &DelayIntsData);
           if (!NT_SUCCESS(status))  {
#if DBG
               DbgPrint("NtVdmControl.VdmDelayInterrupt status=%lx\n",status);
#endif
               host_ica_unlock();
               return FALSE;
               }

           }

#else

        //
        // Cancel delay hw interrupt, delete quick event if any
        //
        if (Delay == 0xFFFFFFFF) {
            if (DelayHandle[IrqLineNum]) {
                delete_q_event(DelayHandle[IrqLineNum]);
                DelayIrqLine &= ~IrqLine;
                DelayHandle[IrqLineNum] = 0;
                }
            host_ica_unlock();
            return TRUE;
            }


        //
        // Mark The IrqLine as delayed until timer fires and queue a quick
        // event, (a bit early for overhead in dispatching quick events).
        //
        DelayIrqLine |= IrqLine;
        DelayHandle[IrqLineNum] = add_q_event_i(DelayIrqQuickEvent,
                                                Delay - 200,
                                                IrqLineNum
                                                );

        //
        // Keep Wow Tasks active
        //
        WOWIdle(TRUE);



#endif
        }


   //
   // If we have more interrupts to generate, register them
   //
   if (CallCount) {
       adapter = IrqLineNum >> 3;
       ica_hw_interrupt(adapter,
                        (UCHAR)(IrqLineNum - (adapter << 3)),
                        CallCount
                        );
       }


   host_ica_unlock();
   return TRUE;
}



#ifndef MONITOR
/*
 * QuickEvent call back function
 *
 */
void DelayIrqQuickEvent(long param)
{
   ULONG IrqLineNum = param;

   host_ica_lock();

   DelayHandle[IrqLineNum] = 0;
   ica_RestartInterrupts(1 << IrqLineNum);

   host_ica_unlock();

}
#endif



// ICA critical section locking code
// This is needed to control access to the ICA from different threads.

void host_ica_lock(void)
{

    if (HandshakeInProgress && CurrentMonitorTeb == NtCurrentTeb()) {
        HANDLE Thread;
        //
        // If the current thread is the MainThread and  does NOT already own
        // the ICA critical section, then we will try to suspend the thread
        // to do fullscreen/windowed handshake.
        //

        Thread = NtCurrentTeb()->ClientId.UniqueThread;
        if (Thread != IcaLock.OwningThread) {  // No synchronization needed
            CheckScreenSwitchRequest(hMainThreadSuspended);
        }
    }
    RtlEnterCriticalSection(&IcaLock);
}

void host_ica_unlock(void)
{
    RtlLeaveCriticalSection(&IcaLock);
}

void InitializeIcaLock(void)
{
    RtlInitializeCriticalSection(&IcaLock);


    if (VDMForWOW)  {
       if(!(hWowIdleEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
           DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
           TerminateVDM();
           }
       }
}



#ifdef MONITOR
//
// Force creation of the LazyCreate LockSemaphore
// for the ica lock.
// It is assumed that:
//    the cpu thread Owns the critsect
//    the HeartBeat Thread will wait on the critsect creating contention
//
// This is done by polling for a lock count greater than zero
// and verifying that the lock semaphore has been created.
// If these conditions are not met we will end up polling infinitely.
// Sounds dangerous but it is okay, since we will either get a
// CreateSemaphore or a timeout(deadlock) error from the rtl critical
// section code, which will result in an exception.
//
VOID WaitIcaLockFullyInitialized(VOID)
{
   DWORD Delay = 0;

   do {
      Sleep(Delay++);
   } while (IcaLock.LockCount < 1 || !IcaLock.LockSemaphore);
}
#endif



// The following routines are used to support IRET hooks. If an interrupt
// uses an IRET hook then the ICA will not generate a interrupt of that
// type until the IRET hook has been called.


// Exported for vdmredir

void SoftPcEoi(int Adapter, int* Line) {
    ica_eoi(Adapter, Line, 0);
}




//
//  Restart delayed interrupts
//  IcaLock should be held upon entry
//

BOOL ica_restart_interrupts(int adapter)
{
    int i;

    if((i = ica_scan_irr(adapter)) & 0x80) {
        ica_interrupt_cpu(adapter, i &= 0x07);
        return TRUE;
        }

    return FALSE;
}
//New ICA interrupt state reset function

void ica_reset_interrupt_state(void)
{
    int line_no;

    host_ica_lock();

    for(line_no = 0; line_no < 8; line_no++)  {
        VirtualIca[ICA_MASTER].ica_count[line_no] =
        VirtualIca[ICA_SLAVE].ica_count[line_no]  = 0;
        ica_clear_int(ICA_MASTER,line_no);
        ica_clear_int(ICA_SLAVE,line_no);
        }


    //Clear interrupt counters
    VirtualIca[ICA_MASTER].ica_cpu_int =
    VirtualIca[ICA_SLAVE].ica_cpu_int  = FALSE;

#ifdef MONITOR
    iretHookActive = 0;
#endif
    DelayIrqLine  = 0;

    //Tell CPU to remove any pending interrupts
    host_clear_hw_int();

    host_ica_unlock();
}

//
// Retry DelayInts (not iret hooks!)
//
// IrqLine - IrqLineBitMask, to be cleared
//
VOID ica_RestartInterrupts(ULONG IrqLine)
{
#ifdef MONITOR

     //
     // on x86 we may get multiple bits set
     // so check both slave and master
     //
    UndelayIrqLine = 0;

    if (!ica_restart_interrupts(ICA_SLAVE))
        ica_restart_interrupts(ICA_MASTER);
#else
    host_ica_lock();

    DelayIrqLine &= ~IrqLine;

    ica_restart_interrupts(IrqLine >> 3 ? ICA_SLAVE : ICA_MASTER);

    host_ica_unlock();
#endif
}

#ifdef MONITOR
extern IU16 getMSW(void);

IU32 host_iret_bop_table_addr(IU32 line)
{
    ULONG AddrBopTable, IretBopSize;

    ASSERT(line <= 15);

    if (!(iretHookMask & (1 << line))) {
        return 0;
        }

    if (getMSW() & 1) {
        AddrBopTable = (VDM_PM_IRETBOPSEG << 16) | VDM_PM_IRETBOPOFF;
        IretBopSize = VDM_PM_IRETBOPSIZE;
    }
    else {
        AddrBopTable = AddrIretBopTable;
        IretBopSize = VDM_RM_IRETBOPSIZE;
    }
    return AddrBopTable + IretBopSize * line;

}
#endif /* MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_event.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title        :   Win32 Input Module.
 *
 * Description  :   This module contains data and functions that
 *          process Win32 messages.
 *
 * Author   :   D.A.Bartlett
 *
 * Notes    :
 */



/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdmapi.h>
#include <malloc.h>
#include <stdlib.h>
#include <excpt.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <winuserp.h>
#include "conapi.h"
#include "conroute.h"
#include "insignia.h"

#include "host_def.h"
#include "xt.h"
#include "sas.h"
#include CpuH
#include "bios.h"
#include "gvi.h"
#include "error.h"
#include "config.h"
#include "keyboard.h"
#include "keyba.h"
#include "idetect.h"
#include "gmi.h"
#include "egamode.h"
#include "gfx_upd.h"
#include "nt_graph.h"
#include "nt_uis.h"
#include <stdio.h>
#include "trace.h"
#include "video.h"
#include "debug.h"
#include "ckmalloc.h"
#include "mouse.h"
#include "mouse_io.h"
#include "ica.h"

#include "nt_mouse.h"
#include "nt_event.h"
#include "nt_det.h"
#include "nt_vdd.h"
#include "nt_timer.h"
#include "nt_sb.h"

#include "host.h"
#include "host_hfx.h"
#include "host_nls.h"
#include "spcfile.h"
#include "host_rrr.h"

#include "nt_thred.h"
#include "nt_uis.h"

#include "ntcheese.h"
#include "nt_reset.h"
#include "nt_fulsc.h"
#include <vdm.h>
#include "nt_eoi.h"
#include "nt_com.h"
#include "nt_pif.h"
#include "yoda.h"
/*================================================================
External references.
================================================================*/


// Jonle Mod
// defined in base\keymouse\keyba.c
VOID KbdResume(VOID);
VOID RaiseAllDownKeys(VOID);
int IsKeyDown(int Key);

// defined in nt_devs.c
VOID nt_devices_block_or_terminate(VOID);
HANDLE hWndConsole;
HANDLE hKbdHdwMutex;
ULONG  KbdHdwFull;         // contains num of keys in 6805 buffer
#ifndef MONITOR
WORD   BWVKey = 0;
char   achES[]="EyeStrain";
#endif
#ifdef YODA
BOOL   bYoda;
#endif
BOOL   stdoutRedirected=FALSE;
ULONG  CntrlHandlerState=0;

IMPORT void RestoreKbdLed(void);

#if defined(JAPAN) || defined(KOREA)
extern UINT ConsoleInputCP;
extern UINT ConsoleOutputCP;
extern DWORD ConsoleNlsMode;
#endif // JAPAN || KOREA
extern PVOID  CurrentMonitorTeb;
extern RTL_CRITICAL_SECTION IcaLock;

/*::::::::::::::::::::::::::::::::::: Key history control variables/defines */

#define MAX_KEY_EVENTS (100)
static PKEY_EVENT_RECORD key_history_head, key_history_tail;
static PKEY_EVENT_RECORD key_history;
static key_history_count;

int GetHistoryKeyEvent(PKEY_EVENT_RECORD LastKeyEvent, int KeyNumber);
void update_key_history(INPUT_RECORD *InputRecords, DWORD RecordsRead);
void InitKeyHistory();
void InitQueue(void);
void ReturnUnusedKeyEvents(int UnusedKeyEvents);
int CalcNumberOfUnusedKeyEvents(void);


/*:::::::::::::::::::::::::::::: Local static data and defines for keyboard */

void nt_key_down_action(PKEY_EVENT_RECORD KeyEvent);
void nt_key_up_action(PKEY_EVENT_RECORD KeyEvent);

void nt_process_keys(PKEY_EVENT_RECORD KeyEvent);
void nt_process_mouse(PMOUSE_EVENT_RECORD MouseEvent);
void nt_process_focus(PFOCUS_EVENT_RECORD FocusEvent);
void nt_process_menu(PMENU_EVENT_RECORD MenuEvent);
void nt_process_suspend_event();
void nt_process_screen_scale(void);


//
// keyboard control state syncronization
//
KEY_EVENT_RECORD fake_shift = { TRUE, 1, VK_SHIFT, 0x2a, 0, SHIFT_PRESSED};
KEY_EVENT_RECORD fake_caps = { TRUE, 1, VK_CAPITAL, 0x3a, 0, CAPSLOCK_ON};
KEY_EVENT_RECORD fake_ctl = { TRUE, 1, VK_CONTROL, 0x1d, 0, 0};
KEY_EVENT_RECORD fake_alt = { TRUE, 1, VK_MENU, 0x38, 0, 0};
KEY_EVENT_RECORD fake_numlck = { TRUE, 1, VK_NUMLOCK, 0x45, 0, ENHANCED_KEY};
KEY_EVENT_RECORD fake_scroll = { TRUE, 1, VK_SCROLL, 0x46, 0, 0};
DWORD ToggleKeyState = NUMLOCK_ON;   // default state on dos boot up

void AltUpDownUp(void);

/*::::::::::::::::::::::::::::::::::: Key message passing control variables */

int EventStatus = ES_NOEVENTS;

/*:::::::::::::::::::::::::::: Mouse positions and current button states */

BOOL SetNextMouseEvent(void);
BOOL PointerAttachedWindowed = FALSE;    /* So re-attached on FS switch */
BOOL DelayedReattachMouse = FALSE;     /* but ClientRect wrong so delay attach*/


#define MOUSEEVENTBUFFERSIZE (32)

int MouseEBufNxtFreeInx;    /* Index to next free entry in event buffer */
int MouseEBufNxtEvtInx;         /* Index to next event to use in mouse evt buf */
int MouseEventCount=0;

struct
{
    POINT mouse_pos;               /* Mouse postion */
    UCHAR mouse_button_left;         /* State of left button */
    UCHAR mouse_button_right;        /* State of right button */
} MouseEventBuffer[MOUSEEVENTBUFFERSIZE];


ULONG NoMouseTics;

ULONG event_thread_blocked_reason = 0xFFFFFFFF;
ULONG EventThreadKeepMode = 0;


HCURSOR cur_cursor = NULL;     /* Current cursor handle */
#ifdef X86GFX
half_word saved_text_lines; /* No of lines for last SelectMouseBuffer. */
#endif /* X86GFX */


/*@ACW========================================================================
Flag to keep track of whether or not the Hide Pointer system menu item is
greyed (i.e. the window is iconised) or enabled.
============================================================================*/
BOOL bGreyed=FALSE;


/*::::::::::::::::::::::::::::: Variables used to control key message Queue */

#define KEY_QUEUE_SIZE (25)

typedef struct
{BYTE ATcode; BOOL UpKey;} KeyQEntry;

typedef struct
{
    short KeyCount;          /* Number of keys in the queue */
    short QHead;             /* Head of queue */
    short QTail;             /* Tail of queue */
    KeyQEntry Keys[KEY_QUEUE_SIZE];  /* Keys in queue */
} KeyQueueData;

static KeyQueueData KeyQueue;
static volatile BOOL InitComplete;

/*:::::: Variables used to control blocking and unblocking the application & event threads */

HANDLE hSuspend;             /* request both app and console threads to be suspened */
HANDLE hResume;              /* Signal that console and app threads can continue */
HANDLE hConsoleSuspended;    /* Signal console thread is suspended */
HANDLE hMainThreadSuspended; /* Signal app thread is suspended */
HANDLE hConsoleStop;
HANDLE hConsoleStopped;
HANDLE hConsoleResume;
/*::::::::::::: Variable to hold current screen scale ::::::::::::::::::::::*/

int savedScale;

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Local functions */

DWORD nt_event_loop(void);
BOOL CntrlHandler(ULONG CtrlType);
void send_up_keys(void);


VOID ReturnBiosBufferKeys(VOID);
DWORD ConsoleEventThread(PVOID pv);

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: Start event processing thread ::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_start_event_thread(void)
{
    //
    // create kbd hardware mutex and kbd not full event
    //
    if (!(hKbdHdwMutex = CreateMutex(NULL, FALSE, NULL)))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    //
    // events to block\resume console and app threads
    //      hResume:             Manual, init= signaled
    //      hSuspend:            Manual, init= Not signaled
    //      hConsoleSuspended:   Manual, init= Signaled
    //      hMainThreadSuspened: Manual, init= Not Signaled
    //
    if (!(hResume = CreateEvent(NULL, TRUE, TRUE, NULL)))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    if (!(hSuspend = CreateEvent(NULL, TRUE, FALSE, NULL)))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    if (!(hConsoleSuspended = CreateEvent(NULL, TRUE, TRUE, NULL)))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    if (!(hMainThreadSuspended = CreateEvent(NULL, TRUE, FALSE, NULL)))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    //
    // Create Event Thread,
    //        event queue
    //
    // The Event Thread is created suspended to prevent us
    // from receiving input before the DOS is ready
    //
    if (!VDMForWOW)
    {

        if (!(hConsoleResume = CreateEvent(NULL, FALSE, FALSE, NULL)))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

        if (!(hConsoleStop = CreateEvent(NULL, FALSE, FALSE, NULL)))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

        if (!(hConsoleStopped = CreateEvent(NULL, FALSE, FALSE, NULL)))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

        //
        //  Register Control 'C' handler, for DOS only
        //
        if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE)CntrlHandler,TRUE))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

        ThreadInfo.EventMgr.Handle = CreateThread(NULL,
                                                  8192,
                                                  ConsoleEventThread,
                                                  NULL,
                                                  CREATE_SUSPENDED,
                                                  &ThreadInfo.EventMgr.ID);
        if (!ThreadInfo.EventMgr.Handle)
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);


        InitQueue();
        check_malloc(key_history,MAX_KEY_EVENTS,KEY_EVENT_RECORD);
        InitKeyHistory();
    }

    return;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: Start event processing thread ::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_remove_event_thread(void)
{
    if (VDMForWOW)
    {
        //
        // Only close the handles if VDMForWOW.  The event thread my still using
        // these events.  We can safely close the handles when event thread
        // exits its event loop.
        //

        CloseHandle(hSuspend);
        CloseHandle(hResume);
        CloseHandle(hConsoleSuspended);
        CloseHandle(hMainThreadSuspended);
        if (sc.FocusEvent != INVALID_HANDLE) {
            CloseHandle(sc.FocusEvent);
        }
    }
    else if (ThreadInfo.EventMgr.Handle)
    {
        NtAlertThread(ThreadInfo.EventMgr.Handle);
    }
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::: Process events ::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

VOID EventThreadSleep(DWORD dwMilliseconds)
{
    NTSTATUS status;

    //
    // Note, the Suspend takes long time to come back.  So if suspend event is
    // detected, we don't check if the 'wait' is actually longer than dwMilliseconds.)
    //

    status = WaitForSingleObject(hSuspend, dwMilliseconds);
    if (status == 0)
    {
        nt_process_suspend_event();
    }
}
DWORD ConsoleEventThread(PVOID pv)
{

    DWORD dwRet = (DWORD)-1;

    try
    {
        SetThreadPriority(ThreadInfo.EventMgr.Handle, THREAD_PRIORITY_HIGHEST);
        DisableScreenSwitch(hConsoleSuspended);
        DelayMouseEvents(2);

        dwRet = nt_event_loop();

        CloseHandle(ThreadInfo.EventMgr.Handle);
        CloseHandle(hSuspend);
        CloseHandle(hResume);
        CloseHandle(hConsoleSuspended);
        CloseHandle(hMainThreadSuspended);
        CloseHandle(hConsoleStop);
        CloseHandle(hConsoleStopped);
        CloseHandle(hConsoleResume);
        if (sc.FocusEvent != INVALID_HANDLE) {
            CloseHandle(sc.FocusEvent);
        }
        ThreadInfo.EventMgr.Handle = NULL;
        ThreadInfo.EventMgr.ID = 0;
    }
    except(VdmUnhandledExceptionFilter(GetExceptionInformation()))
    {
        ;  // we shouldn't arrive here
    }

    return (dwRet);
}

DWORD nt_event_loop(void)
{
    DWORD RecordsRead;
    DWORD loop;
    NTSTATUS status;
    HANDLE Events[3];
    BOOL  success;

    /*
     * The con server is optimized to avoid extra CaptureBuffer allocations
     * when the number of InputRecords is less than "INPUT_RECORD_BUFFER_SIZE".
     * Currently INPUT_RECORD_BUFFER_SIZE is defined internally to the
     * con server as Five records. See ntcon\client\iostubs.c.
     */

    INPUT_RECORD InputRecord[5];


    /* the console input handle shouldn't get changed during the lifetime
       of the ntvdm
    */
    Events[0] = hSuspend;                    // from fullscreen/windowed switch
    Events[1] = GetConsoleInputWaitHandle(); // sc.InputHandle
    Events[2] = hConsoleStop;                // from nt_block_event_thread
    /* Get and process events */

    while (TRUE)
    {
        //
        // Wait for the InputHandle to be signalled, or a suspend event.
        //
        status = NtWaitForMultipleObjects(3,
                                          Events,
                                          WaitAny,
                                          TRUE,
                                          NULL
                                         );

        //
        // Input handle was signaled, Read the input, without
        // waiting (otherwise we may get blocked and be unable to
        // handle the suspend event).
        //
        if (status == 1)
        {
            EnableScreenSwitch(FALSE, hConsoleSuspended);
            success = ReadConsoleInputExW(sc.InputHandle,
                                    &InputRecord[0],
                                    sizeof(InputRecord)/sizeof(INPUT_RECORD),
                                    &RecordsRead,
                                    CONSOLE_READ_NOWAIT
                                    );


            if (success)
            {
                if (!RecordsRead)
                {
                    continue;
                }

                update_key_history(&InputRecord[0], RecordsRead);
            }
            else
            {
                DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
                break; //Read from console failed
            }
        }
        else if (status == 0)
        {
            //
            // Console Suspend event was signaled
            //
            nt_process_suspend_event();
            continue;
        }
        else if (status == 2)
        {
            SetEvent(hConsoleStopped);
            SetEvent(hConsoleSuspended);
            status = NtWaitForSingleObject(hConsoleResume, TRUE, NULL);
            ResetEvent(hConsoleSuspended);

            //
            // If error, probably cause handle was closed, so exit
            // if alerted signal to exit
            //
            if (status)
            {
                ExitThread(0);
            }
            continue;
        }
        else
        {

            //
            // alerted or User apc, This means to terminate
            // Got an error, inform the user.
            //
            if (!NT_SUCCESS(status))
            {
                DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            }
            return (0);
        }

        //
        // At this point, we need to block screen switch operation
        //
        DisableScreenSwitch(hConsoleSuspended);
        //
        // Process the Input Events
        //
        for (loop = 0; loop < RecordsRead; loop++)
        {
            switch (InputRecord[loop].EventType)
            {

            case MOUSE_EVENT:
                nt_process_mouse(&InputRecord[loop].Event.MouseEvent);
                break;

            case KEY_EVENT:
                if (WaitKbdHdw(0xffffffff))
                {
                    return (0);
                }

                do
                {

                    if (KbdHdwFull > 8)
                    {
                        ULONG Delay = KbdHdwFull;

                        HostReleaseKbd();
                        HostIdleNoActivity();
                        EventThreadSleep(Delay);
                        if (WaitKbdHdw(0xffffffff))
                            return (0);
                    }

                    nt_process_keys(&InputRecord[loop].Event.KeyEvent);

                } while (++loop < RecordsRead &&
                         InputRecord[loop].EventType == KEY_EVENT);
                loop--;
                HostReleaseKbd();
                HostIdleNoActivity();
                break;

            case MENU_EVENT:
                nt_process_menu(&InputRecord[loop].Event.MenuEvent);
                break;


            case FOCUS_EVENT:
                nt_process_focus(&InputRecord[loop].Event.FocusEvent);
                break;

            case WINDOW_BUFFER_SIZE_EVENT:
                nt_mark_screen_refresh();
                break;

            default:
                fprintf(trace_file,"Undocumented event from console\n");
                break;
            }
        }

        //
        // 10 ms delay to encourage the console to pack events together
        //
        EventThreadSleep(10);
    }

    return (0);
}


/*:::::::::::::::::::::: Update key history buffer ::::::::::::::::::::::::*/

void update_key_history(register INPUT_RECORD *InputRecords,
                        register DWORD RecordsRead)
{
    for (;RecordsRead--;InputRecords++)
    {
        if (InputRecords->EventType == KEY_EVENT)
        {

            //Transfer key event to history buffer
            *key_history_tail = InputRecords->Event.KeyEvent;

            //Update ptrs to history buffer

            if (++key_history_tail >= &key_history[MAX_KEY_EVENTS])
                key_history_tail = key_history;

            //Check for buffer overflow

            if (key_history_tail == key_history_head)
            {
                //Buffer overflow, bump head ptr and loss oldest key

                if (++key_history_head >= &key_history[MAX_KEY_EVENTS])
                    key_history_head = key_history;
            }

            //Update history counter

            if (key_history_count != MAX_KEY_EVENTS)
                key_history_count++;
        }
    }
    return;
}

/*:::::::::::::::: Remove last key added to key history buffer ::::::::::::::*/

int GetHistoryKeyEvent(PKEY_EVENT_RECORD LastKeyEvent, int KeyNumber)
{
    int KeyReturned = FALSE;
    int KeysBeforeWrap = key_history_tail-key_history;

    if (key_history_count >= KeyNumber)
    {
        if (KeysBeforeWrap < KeyNumber)
        {
            //Wrap

            *LastKeyEvent = key_history[MAX_KEY_EVENTS -
                                        (KeyNumber - KeysBeforeWrap)];
        }
        else
        {
            //No warp
            *LastKeyEvent = key_history_tail[0-KeyNumber];
        }

        KeyReturned = TRUE;
    }

    return (KeyReturned);
}

/*:::::::::::::::::::: Init key history buffer ::::::::::::::::::::::::::::::*/

void InitKeyHistory()
{
    key_history_head = key_history_tail = key_history;
    key_history_count = 0;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Process menu events :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_process_focus(PFOCUS_EVENT_RECORD FocusEvent)
{

    BOOL slow;

    sc.Focus = FocusEvent->bSetFocus;

    if (sc.Focus)
    {
        /* input focus acquired */
        AltUpDownUp();
        EnableScreenSwitch(FALSE, hConsoleSuspended);

        MouseInFocus();
        if (PointerAttachedWindowed && sc.ScreenState == WINDOWED)
        {
            MouseHide();
            PointerAttachedWindowed = FALSE; /* only used in switch */
            DelayedReattachMouse = TRUE;
        }

        /* set the event in case waiting for focus to go fullscreen */
        if (sc.FocusEvent != INVALID_HANDLE)
        {
            PulseEvent(sc.FocusEvent);
        }

#ifndef MONITOR
        if (sc.ModeType == GRAPHICS)
            host_mark_screen_refresh();
#endif
    }
    else    /* input focus lost */
    {

        EnableScreenSwitch(FALSE, hConsoleSuspended);
        slow = savedScreenState != sc.ScreenState;

        MouseOutOfFocus();      /* turn off mouse 'attachment' */

#ifndef PROD
        fprintf(trace_file,"Focus lost\n");
#endif
    }
    DisableScreenSwitch(hConsoleSuspended);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Process menu events :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


void nt_process_menu(PMENU_EVENT_RECORD MenuEvent)
{

/*================================================================
Code to handle the event resulting from the user choosing the
Settings... menu option from the system menu.

Andrew Watson 6/2/92
Ammended to do the mouse attach/detach menu stuff 26/8/92
Ammended to do Alt key processing.
12-Apr-1994 Jonle fixed key processing

================================================================*/

    switch (MenuEvent->dwCommandId)
    {
    // consrv sends when it gets an initmenu, and indicates
    // that a sys menu is coming up, and we are losing kbd focus
    case WM_INITMENU:

        /* stop cursor cliping */
        MouseSystemMenuON();
        break;

        //
        // consrv sends when sys menu is done and we regain focus
        //
    case WM_MENUSELECT:
        AltUpDownUp(); // resync key states
        MouseSystemMenuOFF();
        break;

    case IDM_POINTER:
        {
            BOOL bIcon;


            /* is the SoftPC window NOT an icon? */
            if (VDMConsoleOperation(VDM_IS_ICONIC,&bIcon) &&
                !bIcon)
            {
                if (bPointerOff) /* if the pointer is not visible */
                {
                    MouseDisplay();
                }
                else/* hide the pointer */
                {
                    MouseHide();
                }
            }
            break;
        }

    } /* End of switch */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::: Process suspend event thread event ::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_process_suspend_event()
{
    NTSTATUS Status;

    //
    //Tell the requesting thread that we have blocked
    //
    SetEvent(hConsoleSuspended);

    //
    // Wait for the resume event to wake us up
    //
    Status = NtWaitForSingleObject(hResume, TRUE, NULL);

    // If error, probably cause handle was closed, so exit
    // if alerted signal to exit
    //
    if (Status)
    {
        ExitThread(0);
    }
    DisableScreenSwitch(hConsoleSuspended);
}



/*
 *  Resets the vdm's toggle key state according to the
 *  Current incoming key state from console by sending
 *  fake keys to the vdm as needed.
 *  the caller must be holding the keyboard mutex.
 */

void SyncToggleKeys(WORD wVirtualKeyCode, DWORD dwControlKeyState)
{
    DWORD CurrKeyState;

    CurrKeyState = dwControlKeyState;

    //
    // If the key is one of the toggles, and changed state
    // invert the current state, since want we really want
    // is the toggle state before this key was pressed.
    //
    if (wVirtualKeyCode == VK_SHIFT &&
        (CurrKeyState & SHIFT_PRESSED) != (ToggleKeyState & SHIFT_PRESSED))
    {
        CurrKeyState ^= SHIFT_PRESSED;
    }

    if (wVirtualKeyCode == VK_NUMLOCK &&
        (CurrKeyState & NUMLOCK_ON) != (ToggleKeyState & NUMLOCK_ON))
    {
        CurrKeyState ^= NUMLOCK_ON;
    }

    if (wVirtualKeyCode == VK_SCROLL &&
        (CurrKeyState & SCROLLLOCK_ON) != (ToggleKeyState & SCROLLLOCK_ON))
    {
        CurrKeyState ^= SCROLLLOCK_ON;
    }

    if (wVirtualKeyCode == VK_CAPITAL &&
        (CurrKeyState & CAPSLOCK_ON) != (ToggleKeyState & CAPSLOCK_ON))
    {
        /*
         * KbdBios does not toggle capslock if Ctl is down.
         * Nt does the opposite always toggling capslock state.
         * Force NT conform behaviour by sending:
         *    Ctl up, Caps Dn, Caps Up, Ctl dn
         * so that KbdBios will toggle its caps state
         * before processing the current Ctl-Caps keyevent.
         */
        if (dwControlKeyState & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))
        {
            nt_key_up_action(&fake_ctl);
            if (IsKeyDown(30))
            {    // capslock
                nt_key_up_action(&fake_caps);
            }
            nt_key_down_action(&fake_caps);
            nt_key_up_action(&fake_caps);
            nt_key_down_action(&fake_ctl);
        }

        CurrKeyState ^= CAPSLOCK_ON;
    }


    if ((CurrKeyState & SHIFT_PRESSED) &&
        !(ToggleKeyState & SHIFT_PRESSED))
    {
        nt_key_down_action(&fake_shift);
    }
    else if (!(CurrKeyState & SHIFT_PRESSED) &&
             (ToggleKeyState & SHIFT_PRESSED))
    {
        nt_key_up_action(&fake_shift);
    }


    if ((CurrKeyState & NUMLOCK_ON) != (ToggleKeyState & NUMLOCK_ON))
    {
        if (IsKeyDown(90))
        {
            nt_key_up_action(&fake_numlck);
        }
        nt_key_down_action(&fake_numlck);
        nt_key_up_action(&fake_numlck);
    }

    if ((CurrKeyState & CAPSLOCK_ON) != (ToggleKeyState & CAPSLOCK_ON))
    {
        if (IsKeyDown(30))
        {  //  capslock
            nt_key_up_action(&fake_caps);
        }
        nt_key_down_action(&fake_caps);
        nt_key_up_action(&fake_caps);
    }

    if ((CurrKeyState & SCROLLLOCK_ON) != (ToggleKeyState & SCROLLLOCK_ON))
    {
        if (IsKeyDown(125))
        {  // scrolllock
            nt_key_up_action(&fake_scroll);
        }
        nt_key_down_action(&fake_scroll);
        nt_key_up_action(&fake_scroll);
    }

}

/*
 *  AltUpDownUp - Ensures all kbdhdw keys are in the up state
 *
 *                Does handling for CW apps with alt triggerred menus
 *                to force them out of the menu state.
 *
 *  This works for ALT-Esc, Alt-Enter, Alt-Space because we
 *  we haven't received an Alt-up when we receive the lose focus
 *  event. (We actually never receive the alt-up). Thus we can
 *  detect when a dos app might be in its alt triggered menu.
 *
 *  Alt-TAB does not work, because user32 got ?smart? and sends an
 *  alt-up before switching focus, breaking our detection algorithm.
 *  Also other hot keys which are meaningful to various dos apps
 *  are not handled. Note that this is the same detection algorithm
 *  used by win 3.1.
 *
 */
void AltUpDownUp(void)
{
    ULONG ControlKeyState = 0;

    EventThreadSleep(100);
    if (WaitKbdHdw(0xffffffff))
        return;

    if (IsKeyDown(60) || IsKeyDown(62))
    {    // left alt, right alt

        nt_key_up_action(&fake_alt);    // Alt Up

        HostReleaseKbd();
        EventThreadSleep(100);
        if (WaitKbdHdw(0xffffffff))
            ExitThread(1);

        nt_key_down_action(&fake_alt);  // Alt Down

        HostReleaseKbd();
        EventThreadSleep(100);
        if (WaitKbdHdw(0xffffffff))
            ExitThread(1);

        nt_key_up_action(&fake_alt);    // Alt Up

        HostReleaseKbd();
        EventThreadSleep(20);
        if (WaitKbdHdw(0xffffffff))
            ExitThread(1);

    }

    RaiseAllDownKeys();

    //
    // resync the control key states in case they changed since we last had the kbd focus.
    //

    if (GetKeyState(VK_CAPITAL) & 1) {
        ControlKeyState |= CAPSLOCK_ON;
    }

    if (GetKeyState(VK_NUMLOCK) & 1) {
        ControlKeyState |= NUMLOCK_ON;
    }

    if (GetKeyState(VK_SCROLL) & 1) {
        ControlKeyState |= SCROLLLOCK_ON;
    }

    if ((ControlKeyState & CAPSLOCK_ON) != (ToggleKeyState & CAPSLOCK_ON)) {
        nt_key_down_action(&fake_caps);
        nt_key_up_action(&fake_caps);
    }

    if ((ControlKeyState & NUMLOCK_ON) != (ToggleKeyState & NUMLOCK_ON)) {
        nt_key_down_action(&fake_numlck);
        nt_key_up_action(&fake_numlck);
    }

    if ((ControlKeyState & SCROLLLOCK_ON) != (ToggleKeyState & SCROLLLOCK_ON)) {
        nt_key_down_action(&fake_scroll);
        nt_key_up_action(&fake_scroll);
    }

    ToggleKeyState = ControlKeyState;


    HostReleaseKbd();

}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::: Process event, Class registered message handler :::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#define TOGGLEKEYBITS (SHIFT_PRESSED | NUMLOCK_ON | SCROLLLOCK_ON | CAPSLOCK_ON)

VOID nt_process_keys(PKEY_EVENT_RECORD KeyEvent)
{
#ifdef KOREA
    // For Korean 103 keyboard layout support.
    if (!is_us_mode() && GetConsoleOutputCP() != 437)
    {
        switch (KeyEvent->wVirtualKeyCode)
        {
        case VK_MENU:
        case VK_CONTROL:
            if (KeyEvent->dwControlKeyState & ENHANCED_KEY)
                KeyEvent->dwControlKeyState &= ~ENHANCED_KEY;
            break;
        case VK_HANGEUL:
            if (KeyEvent->wVirtualScanCode == 0xF2)
                KeyEvent->wVirtualScanCode = 0x38;
            break;
        case VK_HANJA:
            if (KeyEvent->wVirtualScanCode == 0xF1)
                KeyEvent->wVirtualScanCode = 0x1D;
            break;
        }
    }
#endif
    // Check the last toggle key states, for change
    if ((ToggleKeyState & TOGGLEKEYBITS)
        != (KeyEvent->dwControlKeyState & TOGGLEKEYBITS))
    {
        SyncToggleKeys(KeyEvent->wVirtualKeyCode, KeyEvent->dwControlKeyState);
        ToggleKeyState = KeyEvent->dwControlKeyState & TOGGLEKEYBITS;
    }

    /*............................... Maintain shift states in case of pastes */

    if (KeyEvent->bKeyDown)
    {


#ifndef MONITOR
        //
        // Check for windowed graphics resize
        //
        if (BWVKey && (KeyEvent->wVirtualKeyCode == BWVKey))
        {
            nt_process_screen_scale();
        }
#endif


        switch (KeyEvent->wVirtualKeyCode)
        {
#ifdef YODA
        case VK_F11:
            if (getenv("YODA"))
            {
                EventStatus |= ~ES_YODA;
            }
            break;
#endif

        case VK_SHIFT:
            fake_shift = *KeyEvent;
            break;

        case VK_MENU:
            fake_alt = *KeyEvent;
            break;

        case VK_CONTROL:
            fake_ctl = *KeyEvent;
            break;
        }

        nt_key_down_action(KeyEvent);

    }
    else
    {    /* ! KeyEvent->bKeyDown */

        /*
         * We don't get a CTRL-Break key make code cause console
         * eats it when it invokes the CntrlHandler. We must fake
         * it here, rather than in the CntrlHandler, cause
         * CntrlHandler is asynchronous and we may lose the state
         * of the Cntrl-Key.
         * 25-Aug-1992 Jonle
         * Also SysRq/Printscreen key. Simon May 93
         */
        if (KeyEvent->wVirtualKeyCode == VK_CANCEL)
        {
            nt_key_down_action(KeyEvent);
        }

        nt_key_up_action(KeyEvent);   /* Key up */

    }   /* ! KeyEvent->bKeyDown */

} /* nt_process_keys */



/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::: Process key down event :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_key_down_action(PKEY_EVENT_RECORD KeyEvent)
{
    BYTE ATcode;

    ATcode = KeyMsgToKeyCode(KeyEvent);

    if (ATcode)
        (*host_key_down_fn_ptr)(ATcode);

}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::: Process keyup event ::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_key_up_action(PKEY_EVENT_RECORD KeyEvent)
{
    BYTE ATcode;

    ATcode = KeyMsgToKeyCode(KeyEvent);

    if (ATcode)
        (*host_key_up_fn_ptr)(ATcode);

}



/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::: Process mouse button and movement events :::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/



void nt_process_mouse(PMOUSE_EVENT_RECORD MouseEvent)
{
    int LastMouseInx;
    POINT mouse_pos;
    UCHAR mouse_button_left, mouse_button_right;

    host_ica_lock();

    if (NoMouseTics)
    {
        ULONG CurrTic;
        CurrTic = NtGetTickCount();
        if (CurrTic > NoMouseTics ||
            (NoMouseTics == 0xffffffff && CurrTic < (0xffffffff >> 1)))
        {
            NoMouseTics = 0;
            MouseEBufNxtEvtInx = MouseEBufNxtFreeInx = 0;
        }
        else
        {
            host_ica_unlock();
            return;
        }
    }


    /*:::::::::::::::::::::::::::::::::::::::::::::::::: Setup button state */

    mouse_button_left = MouseEvent->dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED
                        ? 1 : 0;

    mouse_button_right = MouseEvent->dwButtonState & RIGHTMOST_BUTTON_PRESSED
                         ? 1 : 0;

    /*::::::::::::::::::::::::::::::::::::::::::::::: Get new mouse postion */

    mouse_pos.x = MouseEvent->dwMousePosition.X;    /* Mouse X */
    mouse_pos.y = MouseEvent->dwMousePosition.Y;    /* Mouse Y */

    /*
     * Fix for the case where mouse events are still delivered when the cursor
     * is outside the window because one of the mouse buttons is down. This can
     * cause negative numbers in mouse_pos which can cause divide overflow in
     * mouse interrupt handler code.
     */
#ifdef X86GFX
    if (sc.ScreenState == WINDOWED)
#endif /* X86GFX */
    {
        ULONG maxWidth = sc.PC_W_Width,
        maxHeight = sc.PC_W_Height;

        if ((sc.ModeType == TEXT) && get_pix_char_width() &&
            get_host_char_height())
        {
            maxWidth /= get_pix_char_width();
            maxHeight /= get_host_char_height();
        }
        if (mouse_pos.x < 0)
            mouse_pos.x = 0;
        else if ((ULONG)mouse_pos.x >= maxWidth)
            mouse_pos.x = maxWidth - 1;
        if (mouse_pos.y < 0)
            mouse_pos.y = 0;
        else if ((ULONG)mouse_pos.y >= maxHeight)
            mouse_pos.y = maxHeight - 1;
    }


    LastMouseInx = MouseEBufNxtFreeInx ? MouseEBufNxtFreeInx - 1
                   : MOUSEEVENTBUFFERSIZE - 1;

    //
    // If the previous mouse event is the same as the last
    // then drop the event.
    //
    if (MouseEBufNxtEvtInx != MouseEBufNxtFreeInx &&
        MouseEventBuffer[LastMouseInx].mouse_pos.x == mouse_pos.x &&
        MouseEventBuffer[LastMouseInx].mouse_pos.y == mouse_pos.y &&
        MouseEventBuffer[LastMouseInx].mouse_button_left ==  mouse_button_left &&
        MouseEventBuffer[LastMouseInx].mouse_button_right == mouse_button_right)
    {
        host_ica_unlock();
        return;
    }


    //
    // If not too many events in the mouse buffer
    //    or no outstanding mouse events
    //    or the mouse button state has changed.
    // Add the current mouse data to the next free position in
    // the MouseEventBuffer
    //


    if (MouseEventCount <= MOUSEEVENTBUFFERSIZE/2 ||
        MouseEBufNxtEvtInx == MouseEBufNxtFreeInx ||
        MouseEventBuffer[LastMouseInx].mouse_button_left != mouse_button_left ||
        MouseEventBuffer[LastMouseInx].mouse_button_right != mouse_button_right)
    {
        LastMouseInx = MouseEBufNxtFreeInx;
        if (++MouseEBufNxtFreeInx == MOUSEEVENTBUFFERSIZE)
        {
            MouseEBufNxtFreeInx = 0;
        }

        MouseEventCount++;

        //
        // if the buffer is full drop the oldest event
        //
        if (MouseEBufNxtFreeInx == MouseEBufNxtEvtInx)
        {
            always_trace0("Mouse event input buffer overflow");
            if (++MouseEBufNxtEvtInx == MOUSEEVENTBUFFERSIZE)
                MouseEBufNxtEvtInx = 0;
        }
    }


    MouseEventBuffer[LastMouseInx].mouse_pos = mouse_pos;
    MouseEventBuffer[LastMouseInx].mouse_button_left = mouse_button_left;
    MouseEventBuffer[LastMouseInx].mouse_button_right = mouse_button_right;

    DoMouseInterrupt();

    host_ica_unlock();
}


/*  MoreMouseEvents - returns TRUE if there are more mousevents
 *  to be retrieved.
 *
 *  Assumes caller has the IcaLock
 */
BOOL MoreMouseEvents(void)
{
    return (MouseEBufNxtEvtInx != MouseEBufNxtFreeInx);
}


/*
 *  GetNextMouseEvent - copies the next available Mouse Event to
 *  the global data structure os_pointer. if there are no new events
 *  nothing is copied.
 *
 *  Assumes caller has the IcaLock
 */
void GetNextMouseEvent(void)
{

    if (MouseEBufNxtEvtInx != MouseEBufNxtFreeInx)
    {
        os_pointer_data.x = (SHORT)MouseEventBuffer[MouseEBufNxtEvtInx].mouse_pos.x;
        os_pointer_data.y = (SHORT)MouseEventBuffer[MouseEBufNxtEvtInx].mouse_pos.y;
        os_pointer_data.button_l = MouseEventBuffer[MouseEBufNxtEvtInx].mouse_button_left;
        os_pointer_data.button_r = MouseEventBuffer[MouseEBufNxtEvtInx].mouse_button_right;

        if (++MouseEBufNxtEvtInx == MOUSEEVENTBUFFERSIZE)
            MouseEBufNxtEvtInx = 0;

        MouseEventCount--;
    }

}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::Flush all outstanding mouse events :::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void FlushMouseEvents(void)
{
    host_ica_lock();
    MouseEBufNxtEvtInx = MouseEBufNxtFreeInx = 0;
    host_ica_unlock();
}

//
// count == ticks to throwaway, mouse events
//
VOID DelayMouseEvents(ULONG count)
{
    host_ica_lock();

    NoMouseTics = NtGetTickCount();
    count = 110 *(count+1);
    count = NoMouseTics + count;
    if (count > NoMouseTics)
        NoMouseTics = count;
    else
        NoMouseTics = 0xffffffff; // wrap!

    MouseEBufNxtEvtInx = MouseEBufNxtFreeInx = 0;
    host_ica_unlock();
}


#ifndef X86GFX
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::: Process screen scale event :::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_process_screen_scale(void)
{
    SAVED BOOL init = FALSE;


    host_ica_lock();
    if (!init)
    {
        init = TRUE;
        savedScale = get_screen_scale();
    }
    if (savedScale == 4)
        savedScale = 2;
    else
        savedScale++;
    EventStatus |= ES_SCALEVENT;
    host_ica_unlock();
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::: See if  there is a scale event and if so return the new scale :::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
GLOBAL void GetScaleEvent(void)
{
    int  Scale;

    if (EventStatus & ES_SCALEVENT)
    {
        host_ica_lock();
        Scale = savedScale;
        EventStatus &= ~ES_SCALEVENT;
        host_ica_unlock();
        host_set_screen_scale(Scale);
    }
}
#endif


#ifdef YODA
void CheckForYodaEvents(void)
{
    static HANDLE YodaEvent = NULL;

    /*:::::::::::::::::::::::::::::::::: check for Yoda event object signal */

    if (YodaEvent == NULL)
    {
        if ((YodaEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,"YodaEvent")) == NULL)
        {
            always_trace0("Failed to open Yoda event object\n");
            YodaEvent =  (HANDLE) -1;
        }
    }

    if (YodaEvent && YodaEvent != (HANDLE) -1)
    {
        if (!WaitForSingleObject(YodaEvent,0))
        {
            ResetEvent(YodaEvent);
            Enter_yoda();
        }
    }

    // check for yoda kbd event
    if (EventStatus & ES_YODA)
    {
        EventStatus &= ~ES_YODA;
        Enter_yoda();
    }

}
#endif


// Host funcs to support base keyboard Mods. (Prevents Windows calls from
// appearing in base).
/*  WaitKbdHdw
 *
 *  Synchronizes access to kbd hardware
 *  between event thread and cpu thread
 *
 *  entry: DWORD dwTimeOut   - Millisecs to wait
 *
 *  exit:  DWORD dwRc - return code from WaitForSingleObject()
 *
 */
DWORD WaitKbdHdw(DWORD dwTime)
{
    DWORD dwRc, dwErr;
    HANDLE Thread, hSuspended;


    Thread = NtCurrentTeb()->ClientId.UniqueThread;
    if (Thread == IcaLock.OwningThread) {  // No synchronization needed
        dwErr = dwRc = WaitForSingleObject(hKbdHdwMutex, dwTime);
    } else {
        HANDLE events[2] = {hKbdHdwMutex, hSuspend};

        rewait:
        dwErr = dwRc = WaitForMultipleObjects(2, events, FALSE, dwTime);
        if (dwRc == 1) {
            hSuspended = CurrentMonitorTeb == NtCurrentTeb() ? hMainThreadSuspended : hConsoleSuspended;
            SetEvent(hSuspended);
            WaitForSingleObject(hResume, INFINITE);
            DisableScreenSwitch(hSuspended);
            goto rewait;
        }
    }
    if (dwRc == WAIT_TIMEOUT)
    {
        if (dwTime < 0x10000)
        {
            dwErr = 0;
        }
    }
    else if (dwRc == 0xFFFFFFFF)
    {
        dwErr = GetLastError();
    }

    if (dwErr)
    {
        DisplayErrorTerm(EHS_FUNC_FAILED,dwErr,__FILE__,__LINE__);
    }

    return (dwRc);
}

GLOBAL VOID HostReleaseKbd(VOID)
{
    ReleaseMutex(hKbdHdwMutex);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: Register new cursor :::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void RegisterDisplayCursor(HCURSOR newC)
{
    cur_cursor = newC;
    //if(GetFocus() == sc.Display) SetCursor(newC);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::: Initialise event queue :::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void InitQueue(void)
{
    /*:::::::::::::::::::::::::::::: Initialise key queue control variables */

    KeyQueue.KeyCount = KeyQueue.QHead = KeyQueue.QTail = 0;
    EventStatus = ES_NOEVENTS;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Control handler */

BOOL CntrlHandler(ULONG CtrlType)
{
    switch (CtrlType)
    {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
        break;

    case SYSTEM_ROOT_CONSOLE_EVENT:
        //
        // top most console process is going away
        // remember this so we will terminate the vdm in
        // nt_block_event, when the dos app voluntarily exits
        //
        CntrlHandlerState |= CNTRL_SYSTEMROOTCONSOLE;

        // fall thru to see if we should terminate now

    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
#ifndef PROD
        if (VDMForWOW)
        {  // shouldn't happen
            printf("WOW: Received EndTask Notice, but we shouldn't\n");
            break;
        }
#endif
        if (CntrlHandlerState & CNTRL_PUSHEXIT)
        {
            ExitProcess(0);
            return (FALSE);
        }

        if ((CntrlHandlerState & CNTRL_PIFALLOWCLOSE) ||
            (!(CntrlHandlerState & CNTRL_SHELLCOUNT) &&
             (CntrlHandlerState & CNTRL_VDMBLOCKED)))
        {
            TerminateVDM();
            return (FALSE);
        }

        break;

#ifndef PROD
    default:   // shouldn't happen
        printf("NTVDM: Received unknown CtrlType=%lu\n",CtrlType);
#endif
    }
    return (TRUE);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::: Functions to block/resume the event thread :::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Currently param is only used to indicate whether the command is exiting but
 * the PIF setting shows window should not close.
 */

void nt_block_event_thread(ULONG BlockFlags)
{
    DWORD        dw;
    int          UnusedKeyEvents;
    COORD        scrSize;

    nt_init_event_thread();  // does nothing if init already

    /* remember the reason why we are blocked.
     *  0 == the application is not being terminated, instead, it is
     *  executing either a 32 bits application or command.com(TSR installed
     *  or shell out).
     *  1 == application is terminating.
     *  if the application is terminating, we are safe to re-enable
     *  stream io on nt_resume_event_thread.
    */

    event_thread_blocked_reason = BlockFlags;
    EventThreadKeepMode         = 0;

#if !defined(JAPAN) && !defined(KOREA)

    /////////////////////////////////////////////////////////////////////////
    //
    // If we need to preserve the mode,
    //     save current mode in EventThreadKeepMode.  (This is for simplicity
    //         such that in fullscreen case, it is easier for us to know which
    //         mode to set to.)
    //
    // In general EventThreadKeepode == 0 if it is the top level
    //     ntvdm (i.e. exiting top level ntvdm.).
    //     Otherwise, it is exiting at lease second level (nested case).
    //
    // In ResetConsoleState (on block event thread) we will check:
    //
    //     windowed mode:
    //         if (EventThreadKeepMode != 0)
    //             there is an old mode needs to be restore.
    //             don't change original console state.
    //         else
    //             set console back to original mode (stored in sc)
    //
    //     fullscreen text mode:
    //
    //         if (!EventThreadKeepMode)
    //             we just exited an appp and is going back to
    //             top level ntvdm.  We need to restore original console state
    //         if (EventThreadKeepMode)
    //             don't destroy current setting.  For simplicity, use
    //                EventThreadKeepMode value to set current fullscreen
    //                mode.
    //
    //     fullscreen graphic mode:
    //
    //         Pretend we are going to fullscrren text mode.
    //         if (!EventThreadKeepMode)
    //             we are exiting from top level ntvdm app.  Use old code.
    //         if (EventThreadKeepMode)
    //             Set to the saved mode.
    //
    //
    // In SetupConsoleMode (on resume) we will check:
    //     if (EventThreadKeepMode != 0)
    //         Don't reset original console state.
    //     else  // don't need to restore mode
    //         original console state = current state;
    //

    /////////////////////////////////////////////////////////////
    //
    // What jonle's suggestion is:
    //
    //     ntvdm switches to the closest DOS video mode
    //     ntvdm remembers the mode it sets to
    //     run dos apps
    //     before exiting the top level dos app
    //     check if current mode == the mode ntvdm set to
    //     if yes then ntvdm switches console state back to the original state
    //     else leave it alone.
    //
    //     I will leave this suggestion to next time I change the code or next
    //     release.  Basically we need to:
    //         Remember the DOS mode we set to in calcScreenParams()
    //         In nt_block_event_thread, if we are exiting top level dos app,
    //         compare current mode with the mode we saved in CalcScreenParams().
    //         if they are the same, do what we do today.
    //         else we leave current mode alone.  That means we need to set
    //         console state/window info to the corresponding mode.  Need to
    //         check for windowed mode, fullscreen mode and graphic mode.  Some
    //         mode, we can leave it alone but some mode we may need to actually
    //         set it.  (I am pretty sure we need to complete change the way
    //         we handle fullscreen graphic mode.  See comments there too.)
    //
    ///////////////////////////////////////////////////////////////////

    if (CntrlHandlerState & CNTRL_SHELLCOUNT) {
        EventThreadKeepMode = ((DWORD) sas_hw_at_no_check(vd_rows_on_screen)) + 1;
    }
#endif

    // Send notification message for VDDs */
    nt_devices_block_or_terminate();
    VDDBlockUserHook();


    /*::::::::::::::::::::::::::::::::::::::::::::::::::::: Turn off sound */
    InitSound(FALSE);
    SbCloseDevices();

    /*::::::::::::::::::::::::::::::::::::::::::::: Block the event thread */

    if (!VDMForWOW)
    {
        HANDLE events[2];

        ResetMouseOnBlock();            // remove mouse pointer menu item

        //
        // suspend the event thread and wait for it to block
        //
        events[0] = hConsoleStopped;
        events[1] = hSuspend;
        ResetEvent(hConsoleResume);
        SetEvent(hConsoleStop);

        rewaitEventThread:
        dw = WaitForMultipleObjects(2, events, FALSE, INFINITE);
        if (dw == 0) {
            CheckScreenSwitchRequest(hMainThreadSuspended);
        }
        else if (dw ==  1)
        {
            SetEvent(hMainThreadSuspended);
            WaitForSingleObject(hResume, INFINITE);
            DisableScreenSwitch(hMainThreadSuspended);
            goto rewaitEventThread;
        } else {
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);
            TerminateVDM();
        }
        /*::::::::::::::::::::::::::::::::: Flush screen output, reset console */


        if (sc.ScreenState == STREAM_IO)
            stream_io_update();
        else
        {
            if (sc.ScreenState != FULLSCREEN)
#if defined(JAPAN) || defined(KOREA)
                if (ConsoleInitialised == TRUE && ConsoleNoUpdates == FALSE)
#endif // JAPAN || KOREA
                {
                    if (get_mode_change_required()) {
                        (void)(*choose_display_mode)();
                        set_mode_change_required(FALSE);
                    }
                    (*update_alg.calc_update)();
                }

            ResetConsoleState();

            // Ensure system pointer visible.
            while (ShowConsoleCursor(sc.OutputHandle,TRUE) < 0)
                ;

#ifdef MONITOR
            if (sc.ScreenState == FULLSCREEN) RegainRegenMemory();
#endif

            /* If keeping window open when exiting and fullscreen, return to desktop */
            /* Transition made simple as VDM de-registered from console */
            if (BlockFlags == 1 && sc.ScreenState == FULLSCREEN)
            {
                SetConsoleDisplayMode(sc.OutputHandle, CONSOLE_WINDOWED_MODE, &scrSize);
            }
        }

        // Turn off PIF Reserved & ShortCut Keys
        DisablePIFKeySetup();


        /*::: Push unused key events from kbd hardware back into the console */

        UnusedKeyEvents = CalcNumberOfUnusedKeyEvents();

        ReturnUnusedKeyEvents(UnusedKeyEvents);

        /*::: Push unused keys from 16 bit bios buffer back into the console */
        ReturnBiosBufferKeys();

        /*::: Flush outstanding mouse events */

        FlushMouseEvents();

        /*::: Restore Console modes */

        if (!SetConsoleMode(sc.InputHandle,sc.OrgInConsoleMode))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);

        if (!SetConsoleMode(sc.OutputHandle,sc.OrgOutConsoleMode))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);

#if defined(JAPAN) || defined(KOREA)
        // 32bit IME status restore
        if (SetConsoleNlsMode( sc.InputHandle, ConsoleNlsMode & (~NLS_IME_DISABLE)))
        {
    #ifdef JAPAN_DBG
            DbgPrint( "NTVDM: 32bit IME status restore %08x success\n", ConsoleNlsMode );
    #endif
        }
        else
        {
            DbgPrint( "NTVDM: SetConsoleNlsMode Error %08x\n", GetLastError() );
        }

        // Set cursor mode
        if (!SetConsoleCursorMode( sc.OutputHandle,
                                   TRUE,            // Bringing
                                   TRUE             //  Double byte cursor
                                 ))
        {
    #ifdef JAPAN_DBG
            DbgPrint( "NTVDM: SetConsoleCursorMode Error\n" );
    #endif
        }

        // NtConsoleFlag, for full screen graphics app running second time.
        // NtConsoleFlag is in $NtDisp
        {
            sys_addr FlagAddr;
            extern word NtConsoleFlagSeg;
            extern word NtConsoleFlagOff;

            FlagAddr = effective_addr( NtConsoleFlagSeg, NtConsoleFlagOff );
            sas_store( FlagAddr, 0x01 );
        }
#endif // JAPAN || KOREA
        if (!(CntrlHandlerState & CNTRL_SHELLCOUNT) &&
            CntrlHandlerState & CNTRL_SYSTEMROOTCONSOLE)
        {
            TerminateVDM();
        }
        //
        // Reset the Active buffer field in sc.
        //
        sc.ActiveOutputBufferHandle = sc.OutputHandle;
        MouseDetachMenuItem(FALSE);
    }

    // clear kbd state flags in biosdata area
    sas_store (kb_flag,0);
    sas_store (kb_flag_1,0);
    sas_store (kb_flag_2,0);
    sas_store (kb_flag_3,KBX);
    sas_store (alt_input,0);


    /*::: Suspend timer thread */

    SuspendTimerThread();


    /*::: Close printer ports and comms ports */

    host_lpt_close_all();       /* Close all open printer ports */

    if (!(CntrlHandlerState & CNTRL_SHELLCOUNT))
        host_com_close_all();   /* Close all open comms ports */

    CntrlHandlerState |= CNTRL_VDMBLOCKED;

#ifndef PROD
    fprintf(trace_file,"Blocked event thread\n");
#endif

}

/*::::::::::::::::::::::::::::::::::::: Resume event and heart beat threads */

void nt_resume_event_thread(void)
{
    IMPORT DWORD TlsDirectError;    //Direct access 'used' flag

    //
    // If wow enters here we are in a really bad way
    // since it means they are trying to reload
    //
    if (VDMForWOW)
    {
        TerminateVDM();
        return;
    }

#if defined(JAPAN) || defined(KOREA)
    if (event_thread_blocked_reason == 1 &&
#else
    /* re-enable stream io if we don't need to save original mode */
    if (EventThreadKeepMode == 0 &&
#endif
        StreamIoSwitchOn && !host_stream_io_enabled)
    {
        /* renew the screen buffer and window size */
        if (!GetConsoleScreenBufferInfo(sc.OutputHandle,
                                        &sc.ConsoleBuffInfo))

            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);

        enable_stream_io();
#ifdef X86GFX
        /* tell video bios we are back to stream io */
        sas_store_no_check( (int10_seg<<4)+useHostInt10, STREAM_IO);
#endif

    }
    nt_init_event_thread();  // does nothing if init already

    CntrlHandlerState &= ~CNTRL_VDMBLOCKED;
#ifndef PROD
    fprintf(trace_file,"Resume event thread\n");
#endif

    //
    // Reset hMainThreadSuspended before register console VDM
    //
    ResetEvent(hMainThreadSuspended);

    // Setup Console modes
    SetupConsoleMode();

    // Turn PIF Reserved & ShortCut Keys back on
    EnablePIFKeySetup();

    //
    // re-enable direct access error panels.
    TlsSetValue(TlsDirectError, 0);

    ica_reset_interrupt_state();

    // Send notification message for VDDs */
    VDDResumeUserHook();

    if (sc.ScreenState != STREAM_IO)
    {
        DoFullScreenResume();
        MouseAttachMenuItem(sc.ActiveOutputBufferHandle);
    }
    ResumeTimerThread(); /* Restart timer thread */

    // set kbd state flags in biosdata area
    if (!VDMForWOW)
    {
        SyncBiosKbdLedToKbdDevice();
    }

    KbdResume();
#ifdef JAPAN
    SetModeForIME();
#endif // JAPAN

    //
    // Let go the event thread
    //
    SetEvent(hConsoleResume);
}


void
SyncBiosKbdLedToKbdDevice(
                         void
                         )
{
    unsigned char KbdLed = 0;

    ToggleKeyState = 0;
    if (GetKeyState(VK_CAPITAL) & 1) {
        ToggleKeyState |= CAPSLOCK_ON;
        KbdLed |= CAPS_STATE;
    }

    if (GetKeyState(VK_NUMLOCK) & 1) {
        ToggleKeyState |= NUMLOCK_ON;
        KbdLed |= NUM_STATE;
    }

    if (GetKeyState(VK_SCROLL) & 1) {
        ToggleKeyState |= SCROLLLOCK_ON;
        KbdLed |= SCROLL_STATE;
    }

    sas_store (kb_flag,KbdLed);
    sas_store (kb_flag_2,(unsigned char)(KbdLed >> 4));

    return;
}


#define NUMBBIRECS 32
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::: Return keys in BIOS buffer          ::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
VOID ReturnBiosBufferKeys(VOID)
{
    int i;
    DWORD dwRecs;
    word BufferHead;
    word BufferTail;
    word BufferEnd;
    word BufferStart;
    word w;
    USHORT usKeyState;
    UCHAR  AsciiChar, Digit;
    WCHAR  UnicodeChar;

    INPUT_RECORD InputRecord[NUMBBIRECS];

    sas_loadw(BIOS_KB_BUFFER_HEAD, &BufferHead);
    sas_loadw(BIOS_KB_BUFFER_TAIL, &BufferTail);
    sas_loadw(BIOS_KB_BUFFER_END,  &BufferEnd);
    sas_loadw(BIOS_KB_BUFFER_START,&BufferStart);

    i = NUMBBIRECS - 1;
    while (BufferHead != BufferTail)
    {

        /*
         * Get Scode\char from bios buffer, starting from
         * the last key entered.
         */
        BufferTail -= 2;
        if (BufferTail < BufferStart)
        {
            BufferTail = BufferEnd-2;
        }
        sas_loadw(BIOS_VAR_START + BufferTail, &w);

        InputRecord[i].EventType = KEY_EVENT;
        InputRecord[i].Event.KeyEvent.wVirtualScanCode = w >> 8;
        AsciiChar = (UCHAR)w & 0xFF;
        (UCHAR)InputRecord[i].Event.KeyEvent.uChar.AsciiChar = AsciiChar;

        /*
         *  Translate the character stuff in InputRecord.
         *  we start filling InputRecord from the bottom
         *  we are working from the last key entered, towards
         *  the oldest key.
         */
        if (!BiosKeyToInputRecord(&InputRecord[i].Event.KeyEvent))
        {
            ;    // error in translation skip it
        }

        // normal case
        else if (InputRecord[i].Event.KeyEvent.wVirtualScanCode)
        {
            InputRecord[i].Event.KeyEvent.bKeyDown = FALSE;
            InputRecord[i-1] = InputRecord[i];
            i--;
            InputRecord[i--].Event.KeyEvent.bKeyDown = TRUE;
        }

        //  Special character codes with no scan code are
        //  generated by simulating the alt-num pad entry
        else if (InputRecord[i].Event.KeyEvent.uChar.AsciiChar)
        {
            UnicodeChar = InputRecord[i].Event.KeyEvent.uChar.UnicodeChar;

            // write out what we have, ensuring we have space
            if (i != NUMBBIRECS - 1)
            {
                WriteConsoleInputVDMW(sc.InputHandle,
                                      &InputRecord[i+1],
                                      NUMBBIRECS - i - 1,
                                      &dwRecs);
                i = NUMBBIRECS - 1;
            }



            // restore NUMLOCK state if needed
            usKeyState = (USHORT)GetKeyState(VK_NUMLOCK);
            if (!(usKeyState & 1))
            {
                InputRecord[i].EventType = KEY_EVENT;
                InputRecord[i].Event.KeyEvent.wVirtualScanCode  = 0x45;
                InputRecord[i].Event.KeyEvent.uChar.UnicodeChar = 0;
                InputRecord[i].Event.KeyEvent.wVirtualKeyCode   = VK_NUMLOCK;
                InputRecord[i].Event.KeyEvent.dwControlKeyState = NUMLOCK_ON;
                InputRecord[i].Event.KeyEvent.wRepeatCount      = 1;
                InputRecord[i--].Event.KeyEvent.bKeyDown = FALSE;
                InputRecord[i] = InputRecord[0];
                InputRecord[i--].Event.KeyEvent.bKeyDown = TRUE;
            }

            // alt up
            InputRecord[i].EventType = KEY_EVENT;
            InputRecord[i].Event.KeyEvent.wVirtualScanCode  = 0x38;
            InputRecord[i].Event.KeyEvent.uChar.UnicodeChar = UnicodeChar;
            InputRecord[i].Event.KeyEvent.wVirtualKeyCode   = VK_MENU;
            InputRecord[i].Event.KeyEvent.dwControlKeyState = NUMLOCK_ON;
            InputRecord[i].Event.KeyEvent.wRepeatCount      = 1;
            InputRecord[i--].Event.KeyEvent.bKeyDown = FALSE;

            // up/down for each digits, starting with lsdigit
            while (AsciiChar)
            {
                Digit = AsciiChar % 10;
                AsciiChar /= 10;

                InputRecord[i].EventType = KEY_EVENT;
                InputRecord[i].Event.KeyEvent.uChar.UnicodeChar = 0;
                InputRecord[i].Event.KeyEvent.wVirtualScanCode= aNumPadSCode[Digit];
                InputRecord[i].Event.KeyEvent.wVirtualKeyCode = VK_NUMPAD0+Digit;
                InputRecord[i].Event.KeyEvent.dwControlKeyState = NUMLOCK_ON | LEFT_ALT_PRESSED;
                InputRecord[i].Event.KeyEvent.bKeyDown = FALSE;
                InputRecord[i-1] = InputRecord[i];
                i--;
                InputRecord[i--].Event.KeyEvent.bKeyDown = TRUE;
            }

            // send alt down
            InputRecord[i].EventType = KEY_EVENT;
            InputRecord[i].Event.KeyEvent.wVirtualScanCode  = 0x38;
            InputRecord[i].Event.KeyEvent.uChar.UnicodeChar = 0;
            InputRecord[i].Event.KeyEvent.wVirtualKeyCode   = VK_MENU;
            InputRecord[i].Event.KeyEvent.dwControlKeyState = NUMLOCK_ON | LEFT_ALT_PRESSED;
            InputRecord[i].Event.KeyEvent.wRepeatCount      = 1;
            InputRecord[i--].Event.KeyEvent.bKeyDown = TRUE;


            // toggel numpad state if needed
            if (!(usKeyState & 1))
            {
                InputRecord[i].EventType = KEY_EVENT;
                InputRecord[i].Event.KeyEvent.wVirtualScanCode  = 0x45;
                InputRecord[i].Event.KeyEvent.uChar.UnicodeChar = 0;
                InputRecord[i].Event.KeyEvent.wVirtualKeyCode   = VK_NUMLOCK;
                InputRecord[i].Event.KeyEvent.dwControlKeyState = NUMLOCK_ON;
                InputRecord[i].Event.KeyEvent.wRepeatCount      = 1;
                InputRecord[i].Event.KeyEvent.bKeyDown = FALSE;
                InputRecord[i-1] = InputRecord[i];
                i--;
                InputRecord[i--].Event.KeyEvent.bKeyDown = TRUE;
            }
        }




        /*  If buffer is full or
         *     bios buffer is empty and got stuff in buffer
         *     Write it out
         */
        if ((BufferHead == BufferTail && i != NUMBBIRECS - 1) || i < 0)
        {
            WriteConsoleInputVDMW(sc.InputHandle,
                                  &InputRecord[i+1],
                                  NUMBBIRECS - i - 1,
                                  &dwRecs);
            i = NUMBBIRECS - 1;
        }
    }


    sas_storew(BIOS_KB_BUFFER_TAIL, BufferTail);

    return;
}




/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::: Return key to the console input buffer ::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void ReturnUnusedKeyEvents(int UnusedKeyEvents)
{
    INPUT_RECORD InputRecords[MAX_KEY_EVENTS];
    DWORD RecsWrt;
    int KeyToRtn, KeyInx;

    /* Return keys to console input buffer */

    if (UnusedKeyEvents)
    {
        //
        // Make sure we only retrieve the max number of events that we recorded.
        //

        if (UnusedKeyEvents > MAX_KEY_EVENTS) {
            UnusedKeyEvents = MAX_KEY_EVENTS;
        }
        for (KeyToRtn = 1, KeyInx = UnusedKeyEvents-1;
            KeyToRtn <= UnusedKeyEvents &&
            GetHistoryKeyEvent(&InputRecords[KeyInx].Event.KeyEvent,KeyToRtn);
            KeyToRtn++,KeyInx--)
        {
            InputRecords[KeyToRtn - 1].EventType = KEY_EVENT;
        }

        if (!WriteConsoleInputVDMW(sc.InputHandle,InputRecords,KeyToRtn,&RecsWrt))
            always_trace0("Console write failed\n");
    }

    /* Clear down key history buffer and event queue */
    InitKeyHistory();
    InitQueue();
}


/*
 *  Attempts to terminate this console group
 */
void cmdPushExitInConsoleBuffer (void)
{
    if (VDMForWOW)
    {
        return;
    }
    CntrlHandlerState |= CNTRL_PUSHEXIT;

    /*
     *  Signal all processes in this group that they should be
     *  terminating. Do this by posting a WM_CLOSE message to
     *  the console window, which causes console to send control
     *  close event to all processes.
     *
     *  The vdm must be able to receive control events from the
     *  console after posting the WM_CLOSE msg since the vdm's
     *  CntrlHandler is still registered. To be safe we do
     *  vdm specific cleanup first, and let the CntrlHandler
     *  do the ExitProcess(). This avoids possible deadlock\race
     *  conditions with the console.
     */
    host_applClose();
    ExitVDM(FALSE,0);
    PostMessage(hWndConsole, WM_CLOSE, 0,0);
    ExitThread(0);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::: Calculate no. of keys to return to console input buffer :::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

extern int keys_in_6805_buff(int *part_key_transferred);

int CalcNumberOfUnusedKeyEvents()
{
    int part_key_transferred;

    //Get the number of keys in the 6805 buffer
    return (keys_in_6805_buff(&part_key_transferred) + KeyQueue.KeyCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_ertbl.c ===
#include "host_def.h"
#include "insignia.h"
/*[
	Name:		nt_ertbl.c
        Derived From:   New Development
        Author:         apg
        Created On:     15 Apr 1991
        Sccs ID:        @(#)sun4_ertbl.c	1.1 4/17/91
	Purpose:	NT specific error types.

        (c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
]*/

static char SccsID[]="@(#)sun4_ertbl.c	1.1 4/17/91 Copyright Insignia Solutions Ltd.";

#include "error.h"

GLOBAL ERROR_STRUCT host_errors[] =
{
	{ EH_ERROR, EV_EXTRA_CHAR },		/* FUNC_FAILED */
	{ EH_ERROR, EV_EXTRA_CHAR },		/* SYSTEM ERROR */
	{ EH_ERROR, EV_EXTRA_CHAR },		/* UNSUPPORT BAUD RATE */
	{ EH_ERROR, 0 },			/* Error opening com port */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_fulsc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "host_def.h"
#include "insignia.h"

/*
 * ==========================================================================
 *      Name:           nt_fulsc.c
 *      Author:         Jerry Sexton
 *      Derived From:
 *      Created On:     27th January 1992
 *      Purpose:        This module contains the code required to handle
 *                      transitions between graphics and text modes, and
 *                      windowed and full-screen displays for SoftPC running
 *                      under the x86 monitor.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 * ==========================================================================
 */

/*
 * ==========================================================================
 * Other Includes
 * ==========================================================================
 */
#ifdef X86GFX
    #include <ntddvdeo.h>
#endif
#include <vdm.h>
#include <stdlib.h>
#include <string.h>
#include "conapi.h"

#include "xt.h"
#include CpuH
#include "gvi.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "video.h"
#include "egacpu.h"
#include "egavideo.h"
#include "egagraph.h"
#include "egaports.h"
#include "egamode.h"
#include "ckmalloc.h"
#include "sas.h"
#include "ica.h"
#include "ios.h"
#include "config.h"
#include "idetect.h"
#include "debug.h"

#include "nt_thred.h"
#include "nt_fulsc.h"
#include "nt_graph.h"
#include "nt_uis.h"
#include "host_rrr.h"
#include "nt_det.h"
#include "nt_mouse.h"
#include "nt_event.h"
#include "ntcheese.h"
#include "nt_eoi.h"
#include "nt_reset.h"

#if defined(X86GFX) && (defined(JAPAN) || defined(KOREA))
    #include "sim32.h"
LOCAL   void CallVDM(word CS, word IP);
#endif // X86GFX && (JAPAN || KOREA)
/*
 * ==========================================================================
 * Global Data
 * ==========================================================================
 */
GLOBAL BOOL     ConsoleInitialised = FALSE;
GLOBAL BOOL     ConsoleNoUpdates = FALSE;
#ifdef X86GFX
GLOBAL BOOL     BiosModeChange = FALSE;
GLOBAL DWORD mouse_buffer_width = 0,
mouse_buffer_height = 0;
#endif /* X86GFX */
GLOBAL BOOL blocked_in_gfx_mode = FALSE;  /* need to force text mode? */
#ifndef PROD
GLOBAL UTINY    FullScreenDebug = FALSE;
#endif /* PROD */

/* We have to prevent bad values from oddball video cards (eg Prodesigner II
 * EISA) from blatting us before we can load our private baby mode table in
 * ntio.sys. We have to keep another copy to be copied into memory to prevent
 * this. We should only need modes 3 & b.
 */
GLOBAL UTINY tempbabymode[] =
/* 80x25 stuff */
{
    0x50, 0x18, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x02, 0x67,
    0x5f, 0x4f, 0x50, 0x82, 0x55, 0x81, 0xbf, 0x1f, 0x00, 0x4f,
    0x0d, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x8e, 0x8f, 0x28,
    0x1f, 0x96, 0xb9, 0xa3, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x14, 0x07, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
    0x3f, 0x0c, 0x00, 0x0f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x0e, 0x00, 0xff,
/* mode b stuff */
    0x5e, 0x32, 0x08, 0x00, 0x97, 0x01, 0x0f, 0x00, 0x06, 0xe7,
    0x6d, 0x5d, 0x5e, 0x90, 0x61, 0x8f, 0xbf, 0x1f, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa2, 0x8e, 0x99, 0x2f,
    0x00, 0xa1, 0xb9, 0xe3, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04,
    0x05, 0x14, 0x07, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
    0x3f, 0x01, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x05, 0x0f, 0xff
};

/*
 * ==========================================================================
 * Local Data
 * ==========================================================================
 */

/* The resolution and font-size at start-up. */
LOCAL COORD startUpResolution;
LOCAL COORD startUpFontSize;

/* General purpose console buffer. */
LOCAL CHAR_INFO consoleBuffer[MAX_CONSOLE_SIZE];

LOCAL BOOL WinFrozen = FALSE;

/* Console info from startup which is needed for synchronisation */
LOCAL int ConVGAHeight;
LOCAL int ConTopLine;

/* saved information for console re-integration */
LOCAL CONSOLE_SCREEN_BUFFER_INFO         ConsBufferInfo;
LOCAL StartupCharHeight;

LOCAL half_word saved_text_lines; /* No of lines for last SelectMouseBuffer. */

#if defined(JAPAN) || defined(KOREA)
// #3086: VDM crash when exit 16bit apps of video mode 11h -yasuho
LOCAL half_word saved_video_mode = 0xFF; // save previous video mode
#endif  // JAPAN || KOREA

/* Variable to check for changes in screen state. */
GLOBAL DWORD savedScreenState;
BOOL nt_init_called = 0;

IMPORT CONSOLE_CURSOR_INFO StartupCursor;

IMPORT void low_set_mode(int);
IMPORT VOID recalc_text(int);
IMPORT VOID enable_gfx_update_routines(VOID);
IMPORT VOID disable_gfx_update_routines(VOID);
#ifdef X86GFX
IMPORT void vga_misc_inb(io_addr, half_word *);
#endif /* X86GFX */
#if defined(JAPAN) || defined(KOREA)
    #ifdef i386
        #define CONSOLE_BUFSIZE (80*50*2*2)
extern byte FromConsoleOutput[];
extern int FromConsoleOutputFlag;
IMPORT word FullScreenResumeSeg;
IMPORT word FullScreenResumeOff;
IMPORT sys_addr mouseCFsysaddr;
    #endif // i386

IMPORT BOOL CurNowOff;  // mskkbug #2002: lotus1-2-3 display garbage -yasuho
IMPORT word textAttr;   // Console attributes will be taken over to VDM.
#endif // JAPAN || KOREA
/*
 * ==========================================================================
 * Local Function Declarations
 * ==========================================================================
 */
VOID enableUpdates(VOID);
VOID disableUpdates(VOID);
VOID copyConsoleToRegen(SHORT, SHORT, SHORT, SHORT);
VOID getVDMCursorPosition(VOID);
VOID setVDMCursorPosition(UTINY, PCOORD);
VOID waitForInputFocus(VOID);
GLOBAL int getModeType(VOID);
#ifdef X86GFX
VOID AddTempIVTFixups(VOID);
VOID GfxReset(VOID);
#endif /* X86GFX */
GLOBAL VOID calcScreenParams IFN2( USHORT *, pCharHeight, USHORT *, pVgaHeight );

/*
 * ==========================================================================
 * Global Functions
 * ==========================================================================
 */

GLOBAL VOID nt_init_event_thread(VOID)
{
    note_entrance0("nt_init_event_thread");

    /*
     * May be called more than once, if event thread enters
     * resume\block code before normally intialized
     */
    if (nt_init_called)
        return;
    else
        nt_init_called++;

#if !defined(i386) && defined(JAPAN)
    // for $ias.sys to display the status on bottom line.
    if (!is_us_mode())
    {
        CHAR_INFO   Buffer[80];
        COORD       bufSize,  bufCoord;
        SMALL_RECT  writeRegion;
        register PCHAR_INFO buf = Buffer;
        register half_word  *plane = get_screen_ptr(80*24*4); //bottom line
        register int nChars = 80;

        while (nChars--)
        {
            buf->Char.AsciiChar = *plane++;
            buf->Attributes = *plane++;
            buf++;
            plane += 2;
        }

        bufSize.X = 80;
        bufSize.Y = 1;
        bufCoord.X = 0;
        bufCoord.Y = 0;
        writeRegion.Left = 0;
        writeRegion.Top = 24;
        writeRegion.Right = 79;
        writeRegion.Bottom = 24;
        WriteConsoleOutput(sc.OutputHandle,
                           Buffer,
                           bufSize,
                           bufCoord,
                           &writeRegion);
    }
#endif // !i386 && JAPAN

    if (sc.ScreenState != STREAM_IO)
    {
        USHORT dummy1, dummy2;

        //
        // Force native bios fonts to be reloaded.  On ConsoleInit, the native
        // bios fonts were loaded into 0xa0000.  But, after we get here, some
        // program/driver may trash it.  So, we need to reload it again. In case
        // the user switches to fullscreen before nt_resume_event_thread is called.
        //

        calcScreenParams (&dummy1, &dummy2);

        /*
        ** Copy the console buffer to the regen buffer.
        ** Don't want to adjust the copy from top of console window, console
        ** does it itself if we resize the window. Tim September 92.
        */
        copyConsoleToRegen(0, 0, VGA_WIDTH, (SHORT)ConVGAHeight);

        /*
        ** Tim September 92, adjust cursor position if console window size is
        ** adjusted.
        */
        ConsBufferInfo.dwCursorPosition.Y -= (SHORT)ConTopLine;


#if defined(JAPAN)
        // mskkbug#3704: DOS/V messages are not cleared when command.com starts
        // 11/14/93 yasuho  12/8/93 yasuho
        // Don't set cursor position on startup
        if (!is_us_mode())
        {
            ConsBufferInfo.dwCursorPosition.X = sas_hw_at_no_check(VID_CURPOS);
            ConsBufferInfo.dwCursorPosition.Y = sas_hw_at_no_check(VID_CURPOS+1);
        }
#endif  //JAPAN
        /* Set up SoftPC's cursor. */
        setVDMCursorPosition((UTINY)StartupCharHeight,
                             &ConsBufferInfo.dwCursorPosition);

        if (sc.ScreenState == WINDOWED)
            enableUpdates();
    }
    else
        enableUpdates();

    // set kbd state flags in biosdata area, according to the real kbd Leds
    if (!VDMForWOW)
    {
        SyncBiosKbdLedToKbdDevice();
        // we have sync up the BIOS led states with the system, we now let the
        // event thread go
        ResumeThread(ThreadInfo.EventMgr.Handle);
    }

    KbdResume(); // JonLe Mod
}


#ifdef X86GFX
/*
* Find the address of the ROM font, load it up into the correct
* portion of the regen area and set Int 43 to point to it.
*
* Size of font we are loading is known, so don't listen to what
* the native BIOS returns to us in CX. BIOS might be returning
* character height we set in recalc_text() above. Tim Oct 92.
*/

NativeFontAddr nativeFontAddresses[6]; /* pointers to native BIOS ROM fonts */
/* 8x14, 8x8 pt1, 8x8 pt2, 9x14, 8x16 and 9x16 */


sys_addr GET_BIOS_FONT_ADDRESS IFN1(int, FontIndex)
{
    sys_addr addr;

    if (nativeFontAddresses[FontIndex].seg == 0)
    {
        sas_loadw(0x43 * 4,     &nativeFontAddresses[FontIndex].off);
        sas_loadw(0x43 * 4 + 2, &nativeFontAddresses[FontIndex].seg);
    }
    addr = (((sys_addr)nativeFontAddresses[FontIndex].seg << 4) +
            (sys_addr)nativeFontAddresses[FontIndex].off);
    return (addr);
}

/*
*****************************************************************************
** locateNativeBIOSfonts() X86 only.
*****************************************************************************
** Get the addresses of the BIOS ROM fonts. (Insignia video ROM not loaded)
** ntdetect.com runs the INT 10 to look the addresses up on system boot and
** stores them in page 0 at 700.
** This function is called once on startup X86 only. It gets the addresses of
** the native ROM fonts and stores them in the nativeFontAddresses[] array.
*/
VOID locateNativeBIOSfonts IFN0()
{
    HKEY  wowKey;
    DWORD size, i;
    BOOL  error = TRUE;

    if (RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                       "SYSTEM\\CurrentControlSet\\Control\\WOW",
                       0,
                       KEY_QUERY_VALUE,
                       &wowKey
                     ) == ERROR_SUCCESS)
    {

        size = 6 * 4;   // six bios fonts
        if (RegQueryValueEx (wowKey, "RomFontPointers", NULL, NULL,
                             (LPBYTE)&nativeFontAddresses,&size) == ERROR_SUCCESS &&
            size == 6 * 4)
        {

            error = FALSE;
        }
        RegCloseKey (wowKey);
    }
    if (error)
    {
        for (i = 0; i < 6; i++)
        {
            nativeFontAddresses[i].off = 0;
            nativeFontAddresses[i].seg = 0;
        }
    }
} /* end of locateNativeBIOSfonts() */

/*
****************************************************************************
** loadNativeBIOSfont() X86 only.
****************************************************************************
** Loads the appropriate font, specified by current window size, into the
** font area in video RAM.
** This function is called on every windowed startup and resume. *Never* on
** a full-screen startup or resume. The font is loaded so that it will be
** available for full-screen text mode, but easier to load when windowed.
** Remember a mode change will load the corect font.
*/
VOID loadNativeBIOSfont IFN1( int, vgaHeight )
{
    sys_addr fontadd;   // location of font
    UTINY *regenptr;    // destination in video
    int cellsize;       // individual character size
    int skip;           // gap between characters
    int loop, pool;
    UINT OutputCP;


    #ifdef ARCX86
    if (UseEmulationROM)
        return;
    #endif /* ARCX86 */

    /*
    ** ordered this way as 80x50 console is default
    **  VGA_HEIGHT_4 = 50
    **  VGA_HEIGHT_3 = 43
    **  VGA_HEIGHT_2 = 28
    **  VGA_HEIGHT_1 = 25
    **  VGA_HEIGHT_0 = 22
    */
    if (vgaHeight == VGA_HEIGHT_4 || vgaHeight == VGA_HEIGHT_3)
    {
        cellsize = 8;
        fontadd = GET_BIOS_FONT_ADDRESS(F8x8pt1);
    }
    else
        if (vgaHeight == VGA_HEIGHT_2)
    {
        cellsize = 14;
        fontadd = GET_BIOS_FONT_ADDRESS(F8x14);
    }
    else
    {
        cellsize = 16;
        fontadd = GET_BIOS_FONT_ADDRESS(F8x16);
    }

    // set Int 43 to point to font
    sas_storew(0x43 * 4, (word)(fontadd & 0xffff));
    sas_storew(0x43 * 4 + 2, (word)(fontadd >> 4 & 0xf000));

/* BUGBUG, williamh
   We should have set int43 to the new font read from the CPI font.
   This would require at least 4KB buffer in real mode address space.
   The question is who is going to use this vector? So far, we haven't found
   any applications use the vector(ROM BIOS is okay because the set video mode
   function will reset the font and our new font will be lost anyway).

*/

    if (!sc.Registered || (OutputCP = GetConsoleOutputCP()) == 437 ||
        !LoadCPIFont(OutputCP, (WORD)8, (WORD)cellsize))
    {
        // now load it into the regen memory. We load it in at a0000 where
        // an app will have to get to it. Luckily, this means we don't
        // conflict with the text on the screen

        skip = 32 - cellsize;

        regenptr = (half_word *)0xa0000;

        if (cellsize == 8)      /* 8x8 font comes in two halves */
        {
            for (loop = 0; loop < 128; loop++)
            {
                for (pool = 0; pool < cellsize; pool++)
                    *regenptr++ = *(UTINY *)fontadd++;
                regenptr += skip;
            }
            fontadd = GET_BIOS_FONT_ADDRESS(F8x8pt2);
            for (loop = 0; loop < 128; loop++)
            {
                for (pool = 0; pool < cellsize; pool++)
                    *regenptr++ = *(UTINY *)fontadd++;
                regenptr += skip;
            }
        }
        else
        {
            for (loop = 0; loop < 256; loop++)
            {
                for (pool = 0; pool < cellsize; pool++)
                    *regenptr++ = *(UTINY *)fontadd++;
                regenptr += skip;
            }
        }
    }
} /* end of loadNativeBIOSfont() */

/* this function loads font data from EGA.CPI file located at %systemroot%\system32.
   It is the same file console server used to load ROM font when the video
   is in full screen. This function covers code page 437(ROM default). However,
   the caller should make its best decision to call this function if the
   output code page is not 437. This function doesn't care what code page
   was provided.
   The font size are limitted to(an assumption made by nt video driver and
   the console server):
   ** width must be 8 pixels.
   ** Height must less or equal to 16 pixels.

*/



BOOL LoadCPIFont(UINT CodePageID, WORD FontWidth, WORD FontHeight)
{
    BYTE Buffer[16 * 256];
    DWORD dw, BytesRead, FilePtr;
    BYTE *VramAddr, *pSrc;
    DWORD nChars;
    PCPIFILEHEADER pCPIFileHeader = (PCPIFILEHEADER)Buffer;
    PCPICODEPAGEHEADER pCPICodePageHeader = (PCPICODEPAGEHEADER) Buffer;
    PCPICODEPAGEENTRY pCPICodePageEntry = (PCPICODEPAGEENTRY) Buffer;
    PCPIFONTHEADER pCPIFontHeader = (PCPIFONTHEADER) Buffer;
    PCPIFONTDATA   pCPIFontData   = (PCPIFONTDATA) Buffer;
    BOOL    bDOSCPI = FALSE;
    HANDLE hCPIFile;

    /* max font height is 16 pixels and font width must be 8 pixels */
    if (FontHeight > 16 || FontWidth != 8)
        return (FALSE);

    if (ulSystem32PathLen + CPI_FILENAME_LENGTH > sizeof(Buffer))
        return (FALSE);
    RtlMoveMemory( Buffer, pszSystem32Path, ulSystem32PathLen);
    RtlMoveMemory(&Buffer[ulSystem32PathLen], CPI_FILENAME, CPI_FILENAME_LENGTH);

    // the file must be opened in READONLY mode or the CreateFileA will fail
    // because the console sevrer always keeps an opened handle to the file
    // and the file is opened READONLY.

    hCPIFile = CreateFileA(Buffer, GENERIC_READ, FILE_SHARE_READ,
                           NULL, OPEN_EXISTING, 0, NULL);
    if (hCPIFile == INVALID_HANDLE_VALUE)
        return (FALSE);

    if (!ReadFile(hCPIFile, Buffer, sizeof(CPIFILEHEADER), &BytesRead, NULL) ||
        BytesRead != sizeof(CPIFILEHEADER))
    {
        CloseHandle(hCPIFile);
        return (FALSE);
    }
    if (memcmp(pCPIFileHeader->Signature, CPI_SIGNATURE_NT, CPI_SIGNATURE_LENGTH))
    {
        if (memcmp(pCPIFileHeader->Signature, CPI_SIGNATURE_DOS,CPI_SIGNATURE_LENGTH))
        {
            CloseHandle(hCPIFile);
            return (FALSE);
        }
        else
            bDOSCPI = TRUE;
    }

    // move the file pointer to the code page table header
    FilePtr = pCPIFileHeader->OffsetToCodePageHeader;
    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == (DWORD) -1)
    {
        CloseHandle(hCPIFile);
        return (FALSE);
    }

    if (!ReadFile(hCPIFile, Buffer, sizeof(CPICODEPAGEHEADER), &BytesRead, NULL) ||
        BytesRead != sizeof(CPICODEPAGEHEADER))
    {
        CloseHandle(hCPIFile);
        return (FALSE);
    }
    // how many code page entries in the file
    dw = pCPICodePageHeader->NumberOfCodePages;
    FilePtr += BytesRead;

    // serach for the specific code page
    while (dw > 0 &&
           ReadFile(hCPIFile, Buffer, sizeof(CPICODEPAGEENTRY), &BytesRead, NULL) &&
           BytesRead == sizeof(CPICODEPAGEENTRY))
    {
        if (pCPICodePageEntry->CodePageID == CodePageID)
            break;
        if (dw > 1)
        {
            if (!bDOSCPI)
                FilePtr += pCPICodePageEntry->OffsetToNextCodePageEntry;
            else
                FilePtr = pCPICodePageEntry->OffsetToNextCodePageEntry;

            if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == (DWORD) -1)
            {
                CloseHandle(hCPIFile);
                return (FALSE);
            }
        }
        dw--;
    }
    if (dw == 0)
    {
        CloseHandle(hCPIFile);
        return (FALSE);
    }
    // seek to the font header for the code page
    if (!bDOSCPI)
        FilePtr += pCPICodePageEntry->OffsetToFontHeader;
    else
        FilePtr = pCPICodePageEntry->OffsetToFontHeader;
    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == (DWORD) -1)
    {
        CloseHandle(hCPIFile);
        return (FALSE);
    }
    if (!ReadFile(hCPIFile, Buffer, sizeof(CPIFONTHEADER), &BytesRead, NULL) ||
        BytesRead != sizeof(CPIFONTHEADER))
    {
        CloseHandle(hCPIFile);
        return (FALSE);
    }
    // number of fonts with the specific code page
    dw = pCPIFontHeader->NumberOfFonts;

    while (dw != 0 &&
           ReadFile(hCPIFile, Buffer, sizeof(CPIFONTDATA), &BytesRead, NULL) &&
           BytesRead == sizeof(CPIFONTDATA))
    {
        if (pCPIFontData->FontHeight == FontHeight &&
            pCPIFontData->FontWidth == FontWidth)
        {
            nChars = pCPIFontData->NumberOfCharacters;
            if (ReadFile(hCPIFile, Buffer, nChars * FontHeight, &BytesRead, NULL) &&
                BytesRead == nChars * FontHeight)
                break;
            else
            {
                CloseHandle(hCPIFile);
                return (FALSE);
            }
        }
        else
        {
            if (SetFilePointer(hCPIFile,
                               (DWORD)pCPIFontData->NumberOfCharacters * (DWORD)pCPIFontData->FontHeight,
                               NULL,
                               FILE_CURRENT) == (DWORD) -1)
            {
                CloseHandle(hCPIFile);
                return (FALSE);
            }
            dw--;
        }
    }

    CloseHandle(hCPIFile);

    if (dw != 0)
    {
        VramAddr = (BYTE *)0xa0000;
        pSrc = Buffer;
        for (dw = nChars; dw > 0; dw--)
        {
            RtlMoveMemory(VramAddr, pSrc, FontHeight);
            pSrc += FontHeight;
            // font in VRAM is always 32 bytes
            VramAddr += 32;
        }
        return (TRUE);
    }
    return (FALSE);
}
#endif /* X86GFX */

/*
***************************************************************************
** calcScreenParams(), setup our screen screen parameters as determined
** by current Console state.
** Called from ConsoleInit() and DoFullScreenResume().
** Returns current character height (8,14,16) and lines (22-50).
** Tim Jan 93, extracted common code from init and resume funx.
***************************************************************************
*/
GLOBAL VOID calcScreenParams IFN2( USHORT *, pCharHeight, USHORT *, pVgaHeight )
{
    USHORT   consoleWidth,
    consoleHeight,
    vgaHeight,
    charHeight,
    scanLines;
    half_word temp;

    /* Get console information. */
    if (!GetConsoleScreenBufferInfo(sc.OutputHandle, &ConsBufferInfo))
        ErrorExit();

    /* Now sync the SoftPC screen to the console. */
    if (sc.ScreenState == WINDOWED)
    {
        consoleWidth = ConsBufferInfo.srWindow.Right -
                       ConsBufferInfo.srWindow.Left + 1;
        consoleHeight = ConsBufferInfo.srWindow.Bottom -
                        ConsBufferInfo.srWindow.Top + 1;
    }
#ifdef X86GFX
    else        /* FULLSCREEN */
    {
        if (!GetConsoleHardwareState(sc.OutputHandle,
                                     &startUpResolution,
                                     &startUpFontSize))
            ErrorExit();
        consoleWidth = startUpResolution.X / startUpFontSize.X;
        consoleHeight = startUpResolution.Y / startUpFontSize.Y;
    }
#endif

    /*
     * Set the display to the nearest VGA text mode size, which is one of
     * 80x22, 80x25, 80x28, 80x43 or 80x50.
     */
#if defined(JAPAN) || defined(KOREA)
    // Japanese mode is only 25 lines, now.
    if (is_us_mode() && ( GetConsoleOutputCP() == 437 ))
    {
#endif // JAPAN || KOREA
        if (consoleHeight <= MID_VAL(VGA_HEIGHT_0, VGA_HEIGHT_1))
        {
            /* 22 lines */
            vgaHeight = VGA_HEIGHT_0;
            scanLines = 351;
            charHeight = 16;
        }
        else if (consoleHeight <= MID_VAL(VGA_HEIGHT_1, VGA_HEIGHT_2))
        {
            /* 25 lines */
            vgaHeight = VGA_HEIGHT_1;
            scanLines = 399;
            charHeight = 16;
        }
        else if (consoleHeight <= MID_VAL(VGA_HEIGHT_2, VGA_HEIGHT_3))
        {
            /* 28 lines */
            vgaHeight = VGA_HEIGHT_2;
            scanLines = 391;
            charHeight = 14;
        }
        else if (consoleHeight <= MID_VAL(VGA_HEIGHT_3, VGA_HEIGHT_4))
        {
            /* 43 lines */
            vgaHeight = VGA_HEIGHT_3;
            scanLines = 349;
            charHeight = 8;
        }
        else
        {
            /* 50 lines */
            vgaHeight = VGA_HEIGHT_4;
            scanLines = 399;
            charHeight = 8;
        }

#if defined(JAPAN) || defined(KOREA)
        // Japanese mode is only 25 lines, now.  for RAID #1429
    }
    else
    {
        /* 25 lines */
        vgaHeight = VGA_HEIGHT_1;
        scanLines = 474; // change from 399
        charHeight = 19; // change from 16
    #ifdef JAPAN_DBG
        DbgPrint( "NTVDM: calcScreenParams() Set Japanese 25line mode\n" );
    #endif
        // Get Console attributes
        textAttr = ConsBufferInfo.wAttributes;
    }
#endif // JAPAN || KOREA
    if (sc.ScreenState == WINDOWED)
    {
        /* The app may have shutdown in a gfx mode - force text mode back */
        if (blocked_in_gfx_mode)
        {
            low_set_mode(3);
            inb(EGA_IPSTAT1_REG,&temp);
            outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);   /* re-enable video */
            (*choose_display_mode)();
            blocked_in_gfx_mode = FALSE;
        }

        /*
         * Set screen height appropriately for current window size.
         * Now call video routine to set the character height, updating the
         * BIOS RAM as it does so.
         */
        set_screen_height_recal( scanLines ); /* Tim Oct 92 */
        recalc_text(charHeight);

        /* badly written apps assume 25 line mode page len is 4096 */
        if (vgaHeight == 25)
            sas_storew_no_check(VID_LEN, 0x1000);
#ifdef X86GFX
        loadNativeBIOSfont( vgaHeight );
#endif  /* X86GFX */

    }
#ifdef X86GFX
    else        /* FULLSCREEN */
    {
        // Can't see why we wouldn't want this for resume too.
        // set_char_height( startUpFontSize.Y ); /* Tim Oct 92 */

        /* clear this condition on fullscreen resume */
        blocked_in_gfx_mode = FALSE;

        /*
        ** Adjust height appropriately, Tim September 92.
        ** In full-screen lines is 21 cos 22x16=352, slightly too big.
        */
        if (vgaHeight==22)
            vgaHeight = 21;
        charHeight = startUpFontSize.Y;
    #if defined(JAPAN) || defined(KOREA)
        if (GetConsoleOutputCP() != 437)
            charHeight = 19;
        #ifdef JAPAN_DBG
        DbgPrint("NTVDM:calcScreenParams() charHeight == %d\n", charHeight );
        #endif
    #endif // JAPAN || KOREA
        sas_store_no_check(ega_char_height, (half_word) charHeight);
        sas_store_no_check(vd_rows_on_screen, (half_word) (vgaHeight - 1));
        /* compatibility with bios 80x25 startup */
        if (vgaHeight == 25)
            sas_storew_no_check(VID_LEN, 0x1000);
        else
            sas_storew_no_check(VID_LEN, (word) ((vgaHeight + 1) *
                                                 sas_w_at_no_check(VID_COLS) * 2));
    }
#endif /* X86GFX */
    sas_storew_no_check(VID_COLS, 80);   // fixup from 40 char shutdown
    *pCharHeight = charHeight;
    *pVgaHeight  = vgaHeight;

} /* end of calcScreenParams() */

/***************************************************************************
 * Function:                                                               *
 *      ConsoleInit                                                        *
 *                                                                         *
 * Description:                                                            *
 *      Does all the graphics work required on SoftPC start-up.            *
 *      Will split or modify later to accomodate the SCS initialisation    *
 *      that loses the config.sys etc output.                              *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID ConsoleInit(VOID)
{
    USHORT   charHeight, vgaHeight, cursorLine, topLine;

    note_entrance0("ConsoleInit");

#ifdef X86GFX

    /* Now GetROMsMapped called from config after sas_init */

    /*
     * Set emulation to a known state when starting up windowed. This has to
     * be done after the ROMS are mapped but before we start to look at
     * things like BIOS variables.
     */
    GfxReset();

#endif
    initTextSection();
    if (sc.FocusEvent == INVALID_HANDLE) {

        /*
         * Set up input focus details (we do it here as the fullscreen stuff
         * is what is really interested in it).
         */
        sc.Focus = TRUE;
        sc.FocusEvent = CreateEvent((LPSECURITY_ATTRIBUTES) NULL,
                                    FALSE,
                                    FALSE,
                                    NULL);
        if (sc.FocusEvent == NULL) {
            ErrorExit();
        }
    }

#ifdef X86GFX
    #ifdef SEPARATE_DETECT_THREAD
    /* Create screen state transition detection thread. */
    CreateDetectThread();
    #endif /* SEPARATE_DETECT_THREAD */
#endif /* X86GFX */

    /*
     * We don't want to call paint routines until config.sys processed or if
     * the monitor is writing directly to the frame buffer (fullscreen), so...
     */
    disableUpdates();

    /*
    ** Get console window size and set up our stuff accordingly.
    */
    calcScreenParams( &charHeight, &vgaHeight );

    StartupCharHeight = charHeight;
#ifdef X86GFX
    if (sc.ScreenState != WINDOWED)
    {
        /*
         * Do we need to update the emulation? If we don't do this here then
         * a later state dump of the VGA registers to the VGA emulation may
         * ignore an equal value of the char height and get_chr_height() will
         * be out of step.
         */
        if (get_char_height() != startUpFontSize.Y)
        {
            half_word newht;

            outb(EGA_CRTC_INDEX, 9);           /* select char ht reg */
            inb(EGA_CRTC_DATA, &newht);        /* preserve current top 3 bits */
            newht = (newht & 0xe0) | (startUpFontSize.Y & 0x1f);
            outb(EGA_CRTC_DATA, newht);
        }
    #if defined(JAPAN) || defined(KOREA)
        // for "screeen size incorrect"
        // if ( !is_us_mode() )   // BUGBUG
        if (GetConsoleOutputCP() != 437)
        {
            set_char_height( 19 );
        #ifdef JAPAN_DBG
            DbgPrint( "ConsoleInit() set_char_height 19 \n" );
        #endif
        }
        else
    #endif // JAPAN || KOREA
            set_char_height( startUpFontSize.Y ); /* Tim Oct 92 */

        /*
         * Select a graphics screen buffer so we get mouse coordinates in
         * pixels.
         */
        //SelectMouseBuffer(); //Tim. moved to nt_std_handle_notification().

        /*
         * Prevent mode change happening to ensure dummy paint funcs
         * are kept. (mode change set from bios mode set up).
         */
    #if (defined(JAPAN) || defined(KOREA))       // this should go to US build also
        StartupCharHeight = get_char_height();
    #endif // (JAPAN || KOREA)
        set_mode_change_required(FALSE);
    }
#endif //X86GFX

    /*
     * Work out the top line to be displayed in the VGA window, which is line
     * zero of the console unless the cursor would not be displayed, in which
     * case the window is moved down until the cursor is on the bottom line.
     */
    cursorLine = ConsBufferInfo.dwCursorPosition.Y;
    if (cursorLine < vgaHeight)
        topLine = 0;
    else
        topLine = cursorLine - vgaHeight + (SHORT) 1;

    ConVGAHeight = vgaHeight;
    ConTopLine = topLine;

    ConsoleInitialised = TRUE;
}


/***************************************************************************
 * Function:                                                               *
 *      GfxReset                                                           *
 *                                                                         *
 * Description:                                                            *
 *      Called from ConsoleInit to program up the vga hardware into some   *
 *      known state. This compensates on the X86 for not initialising via  *
 *      our bios.    Essential for windowed running, but probably needed   *
 *      for the what-mode-am-i-in stuff as well.                           *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID GfxReset(VOID)
{
#ifdef X86GFX
    half_word temp;
    DWORD    flags;

    /* Check to see if we are currently running windowed or full-screen. */
    if (!GetConsoleDisplayMode(&flags))
        ErrorExit();
    savedScreenState = sc.ScreenState = (flags & CONSOLE_FULLSCREEN_HARDWARE) ?
                       FULLSCREEN : WINDOWED;

    /* Do windowed specific stuff. */
    if (sc.ScreenState == WINDOWED)
    {
        /* Don't need this now cos we use our video BIOS in windowed */
        /* Tim August 92: low_set_mode(3); */
        /* sas_fillsw(0xb8000, 0x0720, 16000); */
        inb(EGA_IPSTAT1_REG,&temp);

        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */

        /* Turn off the VTRACE interrupt, enabled by low_set_mode(3)
           this is a dirty hack and must be fixed properly */

        ega_int_enable = 0;
    }

#endif
}

/***************************************************************************
 * Function:                                                               *
 *      ResetConsoleState                                                  *
 *                                                                         *
 * Description:                                                            *
 *      Attempts to put the console window back to the state in which      *
 *      it started up.                                                     *
 *                                                                         *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID ResetConsoleState(VOID)
{
#ifdef X86GFX
    /*
     * Table of valid hardware states to be passed to
     * SetConsoleHardwareState. NOTE: this table is a copy of a static table
     * in SrvSetConsoleHardwareState, and so must be updated if that table
     * changes.
     */
    SAVED HARDWARE_STATE validStates[] =
    {
        ///Now 21{ 22, { 640, 350 }, { 8, 16 } },       /* 80 x 22 mode. */
        { 21, { 640, 350}, { 8, 16}},        /* 80 x 21 mode. */
        { 25, { 720, 400}, { 8, 16}},        /* 80 x 25 mode. */
    #if defined(JAPAN) || defined(KOREA)
        // ntraid:mskkbug#2997,3034     10/25/93 yasuho
        // crash screen when exit 16bit apps
        // This is DOS/V specific screen resolution/size
        // CAUTION: This entry must be above { 25, ...} lines.
        { 25, { 640, 480}, { 8, 18}},        /* 80 x 25 mode. */
    #endif // JAPAN || KOREA
        { 28, { 720, 400}, { 8, 14}},        /* 80 x 28 mode. */
        { 43, { 640, 350}, { 8,  8}},        /* 80 x 43 mode. */
    #define MODE_50_INDEX   4
        { 50, { 720, 400}, { 8,  8}}         /* 80 x 50 mode. */
    };
    USHORT linesOnScreen;
    COORD       cursorPos;
    CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
    ULONG i, j, videoWidth, mode, tableLen;
    #if defined(JAPAN) || defined(KOREA)
    // ntraid:mskkbug#2997,3034 10/25/93 yasuho
    // crash screen when exit 16bit apps
    ULONG DOSVIndex = 2;        // Please careful. This is index of validState
    #endif // JAPAN || KOREA
    half_word *from, *videoLine, currentPage, misc;
    #if defined(JAPAN) || defined(KOREA)
    ULONG line_offset;
    byte DosvMode;
    #endif // JAPAN || KOREA
    static COORD screenRes; /* value provided by GetConsHwState() */
    static COORD fontSize;  /* value provided by GetConsHwState() */
#endif /* X86GFX */
    PCHAR_INFO to;
    ULONG videoHeight, nChars;
    COORD       bufferCoord, bufferSize;
    SMALL_RECT writeRegion;
#if defined(JAPAN) && defined(i386)
    int skip = 0; // for mode 73h
#endif // JAPAN & i386


    SMALL_RECT  newWin;
    BOOL itfailed = FALSE;

#if (defined(JAPAN) || defined(KOREA))
    // #3086: VDM crash when exit 16bit apps of video mode 11h
    // 12/8/93 yasuho
    saved_video_mode = sas_hw_at_no_check(vd_video_mode);
#endif  // (JAPAN || KOREA)
#ifdef X86GFX
    if (sc.ScreenState == WINDOWED)
    {
#endif /* X86GFX */

        closeGraphicsBuffer();

#if !defined(JAPAN) && !defined(KOREA)
        if (!EventThreadKeepMode && StreamIoSwitchOn && !host_stream_io_enabled)
        {
#endif // !JAPAN && !KOREA
            /* restore screen buffer and window size */
            SetConsoleScreenBufferSize(sc.OutputHandle, sc.ConsoleBuffInfo.dwSize);
            newWin.Top = newWin.Left = 0;
            newWin.Bottom = sc.ConsoleBuffInfo.srWindow.Bottom -
                            sc.ConsoleBuffInfo.srWindow.Top;
            newWin.Right = sc.ConsoleBuffInfo.srWindow.Right -
                           sc.ConsoleBuffInfo.srWindow.Left;
            SetConsoleWindowInfo(sc.OutputHandle, TRUE, &newWin);
#if !defined(JAPAN) && !defined(KOREA)
        }
#endif // !JAPAN && !KOREA
        /*
        ** Tim September 92, don't resize window on way out of DOS app cos
        ** MS (Sudeep) said so. Don't want to do the associated recalc_text()
        ** either.
        ** This keeps the window re-sizing issue nice and simple, but there'll
        ** be people who don't like having a DOS window size forced upon them.
        */
#if 0
        /* Now resize the window to start-up size. */
        newWin.Top = newWin.Left = 0;
        newWin.Bottom = ConsBufferInfo.srWindow.Bottom -
                        ConsBufferInfo.srWindow.Top;
        newWin.Right = ConsBufferInfo.srWindow.Right -
                       ConsBufferInfo.srWindow.Left;

        if (!SetConsoleWindowInfo(sc.OutputHandle, TRUE, &newWin))
            itfailed = TRUE;

        if (!SetConsoleScreenBufferSize(sc.OutputHandle,ConsBufferInfo.dwSize))
            ErrorExit();
        if (itfailed)   //try 'it' again...
            if (!SetConsoleWindowInfo(sc.OutputHandle, TRUE, &newWin))
                ErrorExit();

            /*
             * Now call video routine to set the character height, updating the
             * BIOS RAM as it does so.
             */
        recalc_text(StartupCharHeight);
#endif  //Zero

#if defined(JAPAN) || defined(KOREA)
// kksuzuka #1457,1458,2373
// We must update console buffer for IME status control
//#if 0
//#endif // JAPAN
        /* williamh. If we really want to do the following thing,
                     we have to copy regen to console buffer.
                     since we are runniing in windowed TEXT mode
                     the console always has our up-to-date regen
                     content, the following actually is not necessary
                     It worked before taking this out it because console
                     doesn't verify the parameters we passed. No console
                     has the checking and we are in trouble if we continue
                     to do so.
        */

        /* Clear the undisplayed part of the console buffer. */
        bufferSize.X = MAX_CONSOLE_WIDTH;
        bufferSize.Y = MAX_CONSOLE_HEIGHT;
        videoHeight = (SHORT) (sas_hw_at_no_check(vd_rows_on_screen) + 1);
        to = consoleBuffer + bufferSize.X * videoHeight;
        nChars = bufferSize.X * ( bufferSize.Y - videoHeight );
    #if defined(JAPAN) || defined(KOREA)
        if (nChars)
        {
    #endif // JAPAN || KOREA

            while (nChars--)
            {
                to->Char.AsciiChar = 0x20;
    #if defined(JAPAN) || defined(KOREA)
                to->Attributes = textAttr;
    #else // !JAPAN && !KOREA
                to->Attributes = 7;
    #endif // !JAPAN && !KOREA
                to++;
            }
            bufferCoord.X      = 0;
            bufferCoord.Y      = (SHORT)videoHeight;
            writeRegion.Left   = 0;
            writeRegion.Top    = (SHORT)videoHeight;
            writeRegion.Right  = MAX_CONSOLE_WIDTH-1;
            writeRegion.Bottom = bufferSize.Y-1;
            if (!WriteConsoleOutput(sc.OutputHandle,
                                    consoleBuffer,
                                    bufferSize,
                                    bufferCoord,
                                    &writeRegion))
                ErrorExit();
    #if defined(JAPAN) || defined(KOREA)
        }
    #endif // JAPAN || KOREA
#endif // JAPAN || KOREA
        /*
        ** Tim, September 92. Put the Console cursor to the same place as the
        ** SoftPC cursor. We already do this in full-screen text mode below.
        ** Specifcally to fix weird cursor position problem with 16-bit nmake,
        ** but seems like a good safety idea anyway.
        */
        getVDMCursorPosition();

        doNullRegister();   /* revert console back to ordinary window */

#ifdef X86GFX
    }
    else /* FULLSCREEN */
    {
        /*
         * If SoftPC blocks in a text mode, sync console srceen buffer to regen
         * area.
         */
        if (getModeType() == TEXT)
        {
    #if defined(JAPAN) || defined(KOREA)
            /* restore screen buffer and window size */
            SetConsoleScreenBufferSize(sc.OutputHandle, sc.ConsoleBuffInfo.dwSize);
            newWin.Top = newWin.Left = 0;
            newWin.Bottom = sc.ConsoleBuffInfo.srWindow.Bottom -
                            sc.ConsoleBuffInfo.srWindow.Top;
            newWin.Right = sc.ConsoleBuffInfo.srWindow.Right -
                           sc.ConsoleBuffInfo.srWindow.Left;
            SetConsoleWindowInfo(sc.OutputHandle, TRUE, &newWin);
            /* Get the current screen buffer info. */
            if (!GetConsoleScreenBufferInfo(sc.OutputHandle, &bufferInfo))
                ErrorExit();
            linesOnScreen = bufferInfo.srWindow.Bottom - bufferInfo.srWindow.Top + 1;
    #else // JAPAN || KOREA

            if (!EventThreadKeepMode)
            {
                if (StreamIoSwitchOn && !host_stream_io_enabled)
                {
                    /* restore screen buffer and window size */
                    SetConsoleScreenBufferSize(sc.OutputHandle, sc.ConsoleBuffInfo.dwSize);
                    newWin.Top = newWin.Left = 0;
                    newWin.Bottom = sc.ConsoleBuffInfo.srWindow.Bottom -
                                    sc.ConsoleBuffInfo.srWindow.Top;
                    newWin.Right = sc.ConsoleBuffInfo.srWindow.Right -
                                   sc.ConsoleBuffInfo.srWindow.Left;
                    SetConsoleWindowInfo(sc.OutputHandle, TRUE, &newWin);
                    linesOnScreen = newWin.Bottom + 1;
                }
                else
                {
                    /* Get the current screen buffer info. */
                    if (!GetConsoleScreenBufferInfo(sc.OutputHandle, &bufferInfo))
                        ErrorExit();
                    linesOnScreen = bufferInfo.srWindow.Bottom - bufferInfo.srWindow.Top + 1;
                }
            }
            else
            {
                linesOnScreen = (USHORT) EventThreadKeepMode;
                if (linesOnScreen == 1) linesOnScreen = 50;
            }
    #endif

            /* Get nearest screen size SetConsoleHardwareState will allow. */
            tableLen = sizeof(validStates) / sizeof(HARDWARE_STATE);
    #if defined(JAPAN) || defined(KOREA)
            // ntraid:mskkbug#2997,3034 10/25/93 yasuho
            // crash screen when exit 16bit apps
            if (!is_us_mode())
                mode = DOSVIndex;
            else
    #endif // JAPAN || KOREA
                for (mode = 0; mode < tableLen; mode++)
                    if (validStates[mode].LinesOnScreen == linesOnScreen)
                        break;

                    /* Set it to 50 line mode if we had a funny number of lines. */
            if (mode == tableLen)
            {
                assert0(FALSE,
                        "Non standard lines on blocking - setting 50 lines");
                mode = MODE_50_INDEX;
            }

            /*
            ** Tim September 92, if the console hardware state is the same as
            ** we are about to set it, do not bother setting it.
            ** This should stop the screen from flashing.
            */
            if (!GetConsoleHardwareState(sc.OutputHandle,
                                         &screenRes,
                                         &fontSize))
                assert1( NO,"VDM: GetConsHwState() failed:%#x",GetLastError() );

            /* Sync the console to the regen buffer. */
            currentPage = sas_hw_at_no_check(vd_current_page);
            vga_misc_inb(0x3cc, &misc);
            if (misc & 1)                       // may be mono mode
                videoLine = (half_word *) CGA_REGEN_START +
                            (VIDEO_PAGE_SIZE * currentPage);
            else
                videoLine = (half_word *) MDA_REGEN_START +
                            (VIDEO_PAGE_SIZE * currentPage);
    #ifdef JAPAN
            // Get DOS/V Virtual VRAM addres
            {

                if (!is_us_mode())
                {
                    DosvMode = sas_hw_at_no_check( DosvModePtr );
        #ifdef JAPAN_DBG
                    DbgPrint( "NTVDM: ResetConsoleState DosvMode=%02x\n", DosvMode );
        #endif
                    if (DosvMode == 0x03)
                    {
                        videoLine = (half_word *)( DosvVramPtr );
                        skip = 0;
                    }
                    else if (DosvMode == 0x73)
                    {
                        videoLine = (half_word *)( DosvVramPtr );
                        skip = 2;
                    }
                    else
                    {
                        skip = 0;
                        videoLine = (half_word *)( DosvVramPtr );
        #ifdef JAPAN_DBG
                        DbgPrint( "Set Dosv mode %02x-> to 03\n", DosvMode );
        #endif
                        sas_store( DosvModePtr, 0x03 );
                    }
        #ifdef JAPAN_DBG
                    DbgPrint( "skip=%d\n", skip );
        #endif
                }
            }
    #elif defined(KOREA) // JAPAN
            // Get HDOS Virtual VRAM addres
            {

                if (!is_us_mode())
                {
                    DosvMode = sas_hw_at_no_check( DosvModePtr );
        #ifdef KOREA_DBG
                    DbgPrint( "NTVDM: ResetConsoleState HDosMode=%02x\n", DosvMode );
        #endif
                    if (DosvMode == 0x03)
                    {
                        videoLine = (half_word *)( DosvVramPtr );
                    }
                    else
                    {
                        videoLine = (half_word *)( DosvVramPtr );
        #ifdef KOREA_DBG
                        DbgPrint( "Set HDos mode %02x-> to 03\n", DosvMode );
        #endif
                        sas_store( DosvModePtr, 0x03 );
                    }
                }
            }
    #endif // KOREA
            to = consoleBuffer;
            videoWidth   = sas_w_at_no_check(VID_COLS);
    #ifdef JAPAN
            if (DosvMode == 0x73)
                line_offset = videoWidth * 2 * 2;
            else
                line_offset = videoWidth * 2;
    #elif defined(KOREA) // JAPAN
            line_offset = videoWidth * 2;
    #endif // KOREA
            videoHeight  = (SHORT) (sas_hw_at_no_check(vd_rows_on_screen) + 1);
            bufferSize.X = MAX_CONSOLE_WIDTH;
            bufferSize.Y = MAX_CONSOLE_HEIGHT;
            if (bufferSize.X * bufferSize.Y > MAX_CONSOLE_SIZE)
            {
                assert1(FALSE, "Buffer size, %d, too large",
                        bufferSize.X * bufferSize.Y);
                ErrorExit();
            }
            for (i = 0; i < videoHeight; i++)
            {
                from = videoLine;
                for (j = 0; j < videoWidth; j++)
                {
                    to->Char.AsciiChar = *from++;
                    to->Attributes = *from++;
                    to++;
    #ifdef JAPAN
                    // write extened attribute to console.
                    if (*from > 0)
                        to->Attributes |= (*from << 8);
                    from += skip;
    #elif defined(KOREA)  // JAPAN
                    // write extened attribute to console.
                    if (*from > 0)
                        to->Attributes |= (*from << 8);
    #endif // KOREA
                }
                for (; j < (ULONG)bufferSize.X; j++)
                {
                    to->Char.AsciiChar = 0x20;
                    to->Attributes = 7;
                    to++;
                }
    #if defined(JAPAN) || defined(KOREA)
                videoLine += line_offset;
    #else // !JAPAN && !KOREA
                videoLine += videoWidth * 2;
    #endif // !JAPAN && !KOREA
            }
            for (; i < (ULONG)bufferSize.Y; i++)
                for (j = 0; j < (ULONG)bufferSize.X; j++)
                {
                    to->Char.AsciiChar = 0x20;
                    to->Attributes = 7;
                    to++;
                }
            bufferCoord.X = bufferCoord.Y = 0;
            writeRegion.Left = writeRegion.Top = 0;
            writeRegion.Right = bufferSize.X - 1;
            writeRegion.Bottom = bufferSize.Y - 1;

            doNullRegister();   /* revert back to normal console */

            if (screenRes.X != validStates[mode].Resolution.X ||
                screenRes.Y != validStates[mode].Resolution.Y ||
                fontSize.X  != validStates[mode].FontSize.X   ||
                fontSize.Y  != validStates[mode].FontSize.Y   ||
                sas_hw_at_no_check(VID_COLS) == 40 ||
    #if defined(JAPAN) || defined(KOREA)
                (!is_us_mode() ? fontSize.Y  != (sas_hw_at_no_check(ega_char_height)-1) : fontSize.Y  != sas_hw_at_no_check(ega_char_height)))
    #else // !JAPAN && !KOREA
                fontSize.Y  != sas_hw_at_no_check(ega_char_height))
    #endif // !JAPAN && !KOREA
            {
                /* Set up the screen. */
                if (!SetConsoleHardwareState( sc.OutputHandle,
                                              validStates[mode].Resolution,
                                              validStates[mode].FontSize))
                {
                    /*
                    ** Tim Sept 92, attempt a recovery.
                    */
                    assert1( NO, "VDM: SetConsoleHwState() failed:%#x",
                             GetLastError() );
                }
            }

            /* put VDM screen onto console screen */
            if (!WriteConsoleOutput(sc.OutputHandle,
                                    consoleBuffer,
                                    bufferSize,
                                    bufferCoord,
                                    &writeRegion))
                ErrorExit();

    #if 0  //STF removed with new mouse stuff??
            /*
            ** Tim, September 92.
            ** Try this after the WriteConsoleOutput(), can now copy the
            ** right stuff from video memory to console.
            ** For mouse purposes we have selected a graphics buffer, so now
            ** we must reselect the text buffer.
            */
            if (!SetConsoleActiveScreenBuffer(sc.OutputHandle))
                ErrorExit();
    #endif //STF

            /*
             * Get the cursor position from the BIOS RAM and tell the
             * console.
             * Set up variables getVDMCursorPosition() needs. Tim Jan 93.
             */
    #if !defined(JAPAN) && !defined(KOREAN)
            if (!EventThreadKeepMode)
            {
    #endif
            sc.PC_W_Height = screenRes.Y;
            sc.CharHeight  = fontSize.Y;
    #if !defined(JAPAN) && !defined(KOREAN)
            }
    #endif
            getVDMCursorPosition();
        }
        else /* GRAPHICS */
        {
            /*
            ** A tricky issue. If we were just in a full-screen graphics
            ** mode, we are just about to lose the VGA state and can't get
            ** it back very easily. So do we pretend we are still in the
            ** graphics mode or pretend we are in a standard text mode?
            ** Seems like standard text mode is more sensible. Tim Feb 93.
            */

            //
            // If fact, after discussed with jonle, I believe what he wants
            // is leaving the mode alone.  If app does not restore mode back
            // to text mode, just leave it in graphic mode.  This is the DOS's
            // behavior.  Since this should apply to either KeepMode or not
            // KeepMode case,  I decided to change it in later release.
            //
            sas_store_no_check( vd_video_mode, 0x3 );
            blocked_in_gfx_mode = TRUE;
    #if !defined(JAPAN) && !defined(KOREAN)
            if (!EventThreadKeepMode)
            {
    #endif

    #if 0  //STF removed with new mouse stuff??
            /*
            ** Tim, September 92, think we want one of these here too.
            ** Change to the normal console text buffer.
            */
            if (!SetConsoleActiveScreenBuffer(sc.OutputHandle))
                ErrorExit();
    #endif //STF

            /* Get the current screen buffer info. */
            if (!GetConsoleScreenBufferInfo(sc.OutputHandle, &bufferInfo))
                ErrorExit();

            linesOnScreen = bufferInfo.srWindow.Bottom - bufferInfo.srWindow.Top + 1;
    #if !defined(JAPAN) && !defined(KOREAN)
            }
            else
            {
                if (EventThreadKeepMode != 1)
                    linesOnScreen = (USHORT) EventThreadKeepMode;
                else
                    linesOnScreen = 50;
            }
    #endif

            /* Get nearest screen size SetConsoleHardwareState will allow. */
            tableLen = sizeof(validStates) / sizeof(HARDWARE_STATE);
    #if defined(JAPAN) || defined(KOREA)
            // ntraid:mskkbug#2997,3034 10/25/93 yasuho
            // crash screen when exit 16bit apps
            if (!is_us_mode())
                mode = DOSVIndex;
            else
    #endif // JAPAN
                for (mode = 0; mode < tableLen; mode++)
                    if (validStates[mode].LinesOnScreen == linesOnScreen)
                        break;

                    /* Set it to 50 line mode if we had a funny number of lines. */
            if (mode == tableLen)
            {
                assert0(FALSE,
                        "Non standard lines on blocking - setting 50 lines");
                mode = MODE_50_INDEX;
            }

            /* Clear the console buffer. */
            bufferSize.X = MAX_CONSOLE_WIDTH;
            bufferSize.Y = MAX_CONSOLE_HEIGHT;
            nChars = bufferSize.X * bufferSize.Y;
            if (nChars > MAX_CONSOLE_SIZE)
            {
                assert1(FALSE, "Buffer size, %d, too large", nChars);
                ErrorExit();
            }
            to = consoleBuffer;
            while (nChars--)
            {
                to->Char.AsciiChar = 0x20;
                to->Attributes = 7;
                to++;
            }
            bufferCoord.X = bufferCoord.Y = 0;
            writeRegion.Left = writeRegion.Top = 0;
            writeRegion.Right = MAX_CONSOLE_WIDTH-1;
            writeRegion.Bottom = bufferSize.Y-1;

            doNullRegister();   /* revert back to normal console */

            if (!WriteConsoleOutput(sc.OutputHandle,
                                    consoleBuffer,
                                    bufferSize,
                                    bufferCoord,
                                    &writeRegion))
                ErrorExit();

            /* Set the cursor to the top left corner. */
            cursorPos.X = 0;
            cursorPos.Y = 0;
            if (!SetConsoleCursorPosition(sc.OutputHandle, cursorPos))
                ErrorExit();
    #ifndef PROD
            if (sc.ScreenState == WINDOWED)     // transient switch??
                assert0(NO, "Mismatched screenstate on shutdown");
    #endif

            /* Set up the screen. */
            SetConsoleHardwareState(sc.OutputHandle,
                                    validStates[mode].Resolution,
                                    validStates[mode].FontSize);
        }
        /*
        ** Tim September 92, close graphics screen buffer on way out when in
        ** full-screen.
        */
        closeGraphicsBuffer();
    }
#endif /* X86GFX */

    /*Put console's cursor back to the shape it was on startup.*/
    SetConsoleCursorInfo(sc.OutputHandle, &StartupCursor);
#if defined(JAPAN) || defined(KOREA)
    //  mskkbug#2002: lotus1-2-3 display garbage        9/24/93 yasuho
    CurNowOff = !StartupCursor.bVisible;        // adjust cursor state
#endif  // JAPAN

    /* reset the current_* variables in nt_graph.c */
    resetWindowParams();
}


#ifdef X86GFX

/***************************************************************************
 * Function:                                                               *
 *      SwitchToFullScreen                                                 *
 *                                                                         *
 * Description:                                                            *
 *      Handles transitions from text to graphics modes when running       *
 *      windowed. Waits until the window has input focus and then requests *
 *      a transition to full-screen operation as graphics modes cannot be  *
 *      run in a window.                                                   *
 *                                                                         *
 * Parameters:                                                             *
 *      Restore - if TRUE, the text needs to be restored.                  *
 *                if FALSE, this call will be followed by bios mode change *
 *                so, there is no need to restore text.                    *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID SwitchToFullScreen(BOOL Restore)
{
    DWORD    flags;
    SAVED COORD    scrSize;
    BOOL     success;
    NTSTATUS status;

    /* Freeze until the window receives input focus. */
    //if (! sc.Focus )  //awaiting console fix.
    if (GetForegroundWindow() != hWndConsole)
    {
        // Frozen window is no longer supported.
        //FreezeWinTitle();       /* Add `-FROZEN' to the console title. */

        /* Now wait until input focus is received. */
        waitForInputFocus();

        //UnFreezeWinTitle(); /* Remove frozen message */
    }

    /*
     * We are about to go full-screen but there will be a delay while the
     * detection thread does its hand-shaking. So disable screen writes before
     * we switch to prevent inadvertent updates while running full-screen.
     */
    disableUpdates();

    /* The window now has input focus so request to go full-screen. */
    if (!Restore)
    {
        BiosModeChange = TRUE;
    }
    else
    {
        BiosModeChange = FALSE;
    }
    EnableScreenSwitch(FALSE, hMainThreadSuspended);
    success = SetConsoleDisplayMode(sc.OutputHandle,
                               CONSOLE_FULLSCREEN_MODE,
                               &scrSize);
    DisableScreenSwitch(hMainThreadSuspended);
    if (success) {
        while (sc.ScreenState == WINDOWED) {
            status = WaitForSingleObject(hSuspend, INFINITE);
            if (status == 0) {
                SetEvent(hMainThreadSuspended);
                WaitForSingleObject(hResume, INFINITE);
                DisableScreenSwitch(hMainThreadSuspended);
            }
        }
    }
    else
    {
        if (GetLastError() == ERROR_INVALID_PARAMETER)
        {
            RcErrorDialogBox(ED_INITFSCREEN, NULL, NULL);
        }
        else if (NtCurrentPeb()->SessionId != 0)
        {
            if (GetLastError() == ERROR_CTX_GRAPHICS_INVALID)
            {
                RcErrorDialogBox(ED_INITGRAPHICS, NULL, NULL);
            }
        }
        else
        {
            ErrorExit();
        }
    }
    if (!Restore)
    { // Really no need to test.  Should always set to false
        BiosModeChange = FALSE;
    }
}

/***************************************************************************
 * Function:                                                               *
 *      CheckForFullscreenSwitch                                           *
 *                                                                         *
 * Description:                                                            *
 *      Checks to see if there has been a transition between windowed and  *
 *      fullscreen and does any console calls necessary. This is called    *
 *      on a timer tick before the graphics tick code.                     *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID CheckForFullscreenSwitch(VOID)
{
    half_word mode, lines;

    if (sc.ScreenState == STREAM_IO)
        return;

    /*
     * Do any console calls relating to screen state changes. They have to be
     * done now as they cannot be done on the same thread as the screen switch
     * hand-shaking.
     */
    if (sc.ScreenState != savedScreenState)
    {
        if (sc.ScreenState == WINDOWED)
        {
            if (sc.ModeType == TEXT)
            {

                /* Remove frozen window indicator if necessary. */
                //UnFreezeWinTitle();

    #if 0  //STF removed with new mouse stuff??
                /* Revert to text buffer. */
                closeGraphicsBuffer(); /* Tim Oct 92 */
    #endif //STF

                /* Get Window to correct shape */
                textResize();

                /* Enable screen updates. */
                enableUpdates();

    #ifdef JAPAN
// for RAID #875
                {
                    register int  i, j, k;
                    register char *p;
                    int DBCSStatus;
                    int text_skip;
                    // mode73h support
                    if (!is_us_mode() && (sas_hw_at_no_check(DosvModePtr) == 0x73 ))
                    {
                        text_skip = 4;
                    }
                    else
                    {
                        text_skip = 2;
                    }

                    if (BOPFromDispFlag)
                    {  // CP == 437 is OK
                        k = 0;
                        // p = DosvVramPtr;
                        p = get_screen_ptr(0);
                        Int10FlagCnt++;
                        for (i = 0; i < 50; i++)
                        {   // lines == 50
                            DBCSStatus = FALSE;
                            for (j = 0; j < 80; j++)
                            {
                                if (DBCSStatus)
                                {
                                    Int10Flag[k] = INT10_DBCS_TRAILING | INT10_CHANGED;
                                    DBCSStatus = FALSE;
                                }
                                else if (DBCSStatus = is_dbcs_first( *p ))
                                {
                                    Int10Flag[k] = INT10_DBCS_LEADING | INT10_CHANGED;
                                }
                                else
                                {
                                    Int10Flag[k] = INT10_SBCS | INT10_CHANGED;
                                }
                                k++; p += text_skip;
                            }
                        }
                    }
                }
                // notice video format to console
                VDMConsoleOperation(VDM_SET_VIDEO_MODE,
                                    (LPVOID)((sas_hw_at_no_check(DosvModePtr) == 0x73) ? TRUE : FALSE));
    #elif defined(KOREA) // JAPAN
                // notice video format to console
                VDMConsoleOperation(VDM_SET_VIDEO_MODE, (LPVOID)FALSE);
    #endif // KOREA
                /*
                 * Now get the image on the screen (timer updates currently
                 * disabled).
                 */
                (void)(*update_alg.calc_update)();

            }
        }
        else /* FULLSCREEN */
        {
            int cnt = 0; /* Counter to break out of the cursor off loop. */

            /* Disable screen updates*/
            disableUpdates();

    #if defined(JAPAN) || defined(KOREA)
// call 16bit to initialize DISP.SYS
        #if defined(JAPAN_DBG) || defined(KOREA_DBG)
            DbgPrint("NTVDM: change to Fullscreen\n" );
        #endif
            /* Update saved variable. */
            savedScreenState = sc.ScreenState;
// -williamh-
// For NT-J, the int10h has several layers. On the top is DISP_WIN.SYS
// and then $DISP.SYS and then NTIO.SYS(spcmse).
// ON WINDOWED:
// every INT10h call is routed from DISP_WIN.SYS to 32bits.
//
// ON FULLSCREEN:
// DBCS int 10h calls are routed from DISP_WIN.SYS to $DISP.SYS
// SBCS int 10h calls are routed from DISP_WIN.SYS to NTIO.SYS which in
// turn to MOUDE_VIDEO_IO(set mode) and ROM VIDEO.
//
// why only check for DBCS mode?
//      because the *(dbcs vector) == 0  and disp_win revectors
//      every int10h call to ntio.sys -- $DISP.SYS never gets chances
// why only check for mode 73 and 3?
//      because they are the only DBCS-text modes and we have to
//      ask $disp.sys to refresh the screen. If the video is in
//      graphic mode then we are frozen right now and the $disp.sys
//      must have the correct video state, no necessary to tell
//      it about this screen transition
//
            if (!is_us_mode() &&
        #if defined(JAPAN)
                ( (sas_hw_at_no_check(DosvModePtr) == 0x03) ||
                  (sas_hw_at_no_check(DosvModePtr) == 0x73) ))
            {
        #else  // JAPAN
                ( (sas_hw_at_no_check(DosvModePtr) == 0x03) ))
            {
        #endif // KOREA

                extern word DispInitSeg, DispInitOff;
                BYTE   saved_mouse_CF;
                sas_load(mouseCFsysaddr, &saved_mouse_CF);
        #if DBG
                {
                    PVDM_TIB VdmTib;

                    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
                    // Now I'm in cpu_simulate
                    InterlockedDecrement(&VdmTib->NumTasks);
        #endif
                    CallVDM(DispInitSeg, DispInitOff);
        #if DBG
                    InterlockedIncrement(&VdmTib->NumTasks);
                }
        #endif
                sas_store_no_check(mouseCFsysaddr, saved_mouse_CF);

            }
    #endif // JAPAN || KOREA
            /* Disable mouse 'attached'ness if enabled */
            if (bPointerOff)
            {
                PointerAttachedWindowed = TRUE;
                MouseDisplay();
            }

    #if 0 //STF removed with new mouse stuff
            /* remove any graphics buffer from frozen screen */
            closeGraphicsBuffer();
    #endif

            /* Do mouse scaling */
            mode = sas_hw_at_no_check(vd_video_mode);
            lines = sas_hw_at_no_check(vd_rows_on_screen) + 1;
            SelectMouseBuffer(mode, lines);

            /* force mouse */
            ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT, 1);

            /*
             * Now turn off console cursor - otherwise can ruin screen trying to
             * draw system's cursor. The VDM will have to worry about the mouse
             * image.
             */
            //  while(ShowConsoleCursor(sc.OutputHandle, FALSE) >=0 && cnt++ < 200);
        } /* FULLSCREEN */

        /* Update saved variable. */
        savedScreenState = sc.ScreenState;
    }
    /* Delayed Client Rect query */
    if (DelayedReattachMouse)
    {
        DelayedReattachMouse = FALSE;
        MovePointerToWindowCentre();
    }
}

/*
***************************************************************************
** getNtScreenState() - return 0 for windowed, 1 for full-screen.
***************************************************************************
** Tim July 92.
*/
GLOBAL UTINY getNtScreenState IFN0()
{
    return ( (UTINY) sc.ScreenState );
}

/*
***************************************************************************
** hostModeChange() - called from video bios, ega_vide.c:ega_set_mode()
***************************************************************************
**
** When changing to a graphics mode action the transition to full-screen if
** we are currently windowed.
**
** On entry AX should still contain the value when the video BIOS set mode
** function was called.
** Call to SwitchToFullScreen() with parameter indicating whether we want a
** clear screen with the impending host video BIOS mode change.
**
** Return a boolean indicating to the real BIOS whether the mode change
** has occured.
**
** Tim August 92.
*/
GLOBAL BOOL hostModeChange IFN0()
{
    half_word vid_mode;

    vid_mode = getAL() & 0x7f;

    if (getNtScreenState() == WINDOWED)
    {
        if (vid_mode > 3 && vid_mode != 7)
        {
            /*
             * We have to tell the hand-shaking code the BIOS is causing
             * the mode change so that it can do a BIOS mode change when
             * the switch has been done. This has to be implemented as a
             * global variable because the hand-shaking is on a different
             * thread.
             */
            SwitchToFullScreen(FALSE);
            // rapid Window to full screen and back cause this to fail,
            // remove call since it will get done on the next timer
            // event. 28-Feb-1993 Jonle
            // SelectMouseBuffer();
            return ( TRUE );
        }
        else
            return (FALSE);
    }
    else
        return ( FALSE );
} /* end hostModeChange() */
#endif /* X86GFX */

/***************************************************************************
 * Function:                                                               *
 *      DoFullScreenResume                                                 *
 *                                                                         *
 * Description:                                                            *
 *      Called by SCS to restart SoftPC when a DOS application restarts    *
 *      after being suspended or starts up for the first time after SoftPC *
 *      has been booted by another application which has since terminated. *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/

GLOBAL VOID DoFullScreenResume(VOID)
{
    USHORT vgaHeight, height;
#ifndef X86GFX
    PVOID pDummy;
#endif

#ifdef X86GFX
    DWORD flags;

    //
    // First free regen memory to guarantee RegisterConsoleVDM would succeed
    //

    LoseRegenMemory();
#endif

    //
    // re-register with console for fullscreen switching.
    // We need to do this early because we don't want screen state changed after
    // we query the screen state.  That will make us out of sync with real
    // screen state.  Note, the timer thread is blocked at this point.  No screen switch
    // could occur until we let go the timer thread.
    //

    ResetEvent(hErrorHardwareEvent);
    if (!RegisterConsoleVDM( VDMForWOW ?
                             CONSOLE_REGISTER_WOW : CONSOLE_REGISTER_VDM,
#ifdef X86GFX
                             hStartHardwareEvent,
                             hEndHardwareEvent,
                             hErrorHardwareEvent,
#else
                             NULL,
                             NULL,
                             NULL,
#endif

                             0,               // sectionname no longer used
                             &stateLength,
#ifndef X86GFX
                             &pDummy,
#else
                             (PVOID *) &videoState,
#endif
                             NULL,            // sectionname no longer used
                             0,               // sectionname no longer used
                             textBufferSize,
                             (PVOID *) &textBuffer
                           )
       )
        ErrorExit();

#ifdef X86GFX
    /*
    ** Tim July 92.
    ** Set sc.ScreenState, a windowed/full-screen transition might
    ** have happenened when SoftPC was inactive.
    ** Copied from GfxReset().
    */
    if (!GetConsoleDisplayMode(&flags))
        ErrorExit();

    #if defined(JAPAN) || defined(KOREA)
    sc.ScreenState = (flags == (CONSOLE_FULLSCREEN_HARDWARE | CONSOLE_FULLSCREEN)) ? FULLSCREEN : WINDOWED;
    #else // !JAPAN && !KOREA
    sc.ScreenState = (flags & CONSOLE_FULLSCREEN_HARDWARE) ? FULLSCREEN : WINDOWED;
    #endif // !JAPAN && !KOREA

    if (sc.ScreenState == WINDOWED)
    {

        //
        // Since we release the regen memory right before we registerConsolVDM, now get it back
        // if windowed mode.
        //
        RegainRegenMemory();
    }

    #if defined(JAPAN) || defined(KOREA)
    // mskkbug#3226: Incorrect display when exit DOS on video mode 73
    // 11/24/93 yasuho
    // Adjust video mode with DosvMode
    if (sc.ScreenState == FULLSCREEN)
    {
        half_word       mode;

        mode = sas_hw_at_no_check(vd_video_mode);
        if (!is_us_mode() && mode != sas_hw_at_no_check(DosvModePtr))
            sas_store_no_check(DosvModePtr, mode);
    }
    #endif

    /* Put the regen memory in the correct state. */
    if (sc.ScreenState != savedScreenState)
    {
        if (sc.ScreenState == WINDOWED)
        {
            enableUpdates(); /* Tim September 92, allow graphics ticks */
            /*
            ** Tim Jan 93. Get the next nt_graphics_tick() to decide
            ** what the current display mode is, set the update and
            ** paint funx appropriately and redraw the screen.
            */
            set_mode_change_required( TRUE );
            host_graphics_tick();

            /* Ensure idling system enabled & reset */
            IDLE_ctl(TRUE);
            IDLE_init();
        }
        else
        {
            disableUpdates(); /* Tim September 92, stop graphics ticks */

            /* Ensure idling system disabled as can't detect fullscreen idling*/
            IDLE_ctl(FALSE);
        }
        savedScreenState = sc.ScreenState;
    }

    /*
    ** Tim July 92:
    ** set the KEYBOARD.SYS internal variable to 0 for windowed and
    ** 1 for full-screen.
    ** If a transition has happened when SoftPC was inactive we
    ** need to get into the appropriate state.
    */
    {
        if (sc.ScreenState==WINDOWED)
        {
            sas_store_no_check( (int10_seg<<4)+useHostInt10, WINDOWED );
        }
        else
        {
            sas_store_no_check( (int10_seg<<4)+useHostInt10, FULLSCREEN );
        }
    }
#endif /* X86GFX */

#ifdef X86GFX
    sc.Registered = TRUE;
    /* stateLength can be 0 if fullscreen is disabled in the console */
    if (stateLength)
        RtlZeroMemory(videoState, sizeof(VIDEO_HARDWARE_STATE_HEADER));
#else
    /*
    ** Create graphics buffer if we need one. Tim Oct 92.
    */
    if (sc.ModeType==GRAPHICS)
        graphicsResize();
#endif
#if !defined(JAPAN) && !defined(KOREA) /* ???? NO REASON TO DO THIS STUFF TWICE ???????
                and if this is REALY necessary, we should count
                in the IME status line(s) (40:84) */
    /*
    ** Tim September 92.
    ** If window size is not suitable for a DOS app, snap-to-fit
    ** appropriately. Put cursor in correct place.
    ** Do the ConsoleInit() and nt_init_event_thread() type of things.
    ** Leave full-screen as it was.
    */
    if (sc.ScreenState != WINDOWED)
    {
        /* Get console info, including the current cursor position. */
        if (!GetConsoleScreenBufferInfo(sc.OutputHandle, &ConsBufferInfo))
            ErrorExit();
        /* Hard-wired for f-s resume - needs to be set properly. */
        height = 8;
        /* Set up BIOS variables etc. */
        setVDMCursorPosition( (UTINY)height,
                              &ConsBufferInfo.dwCursorPosition);
        /* Copy the console buffer to the regen buffer. */
        copyConsoleToRegen(0, 0, VGA_WIDTH, (SHORT)ConVGAHeight);
    }
#endif // !JAPAN && !KOREA

    /*
    ** Get console window size and set up our stuff accordingly.
    */
#ifdef JAPAN
    // save BIOS work area 0x484 for $IAS
    {
        byte save;
    #ifndef i386
        // for ichitaro
        static byte lines = 24;
    #endif // !i386

        if (!is_us_mode())
        {
            save = sas_hw_at_no_check( 0x484 );
    #ifndef i386
            if (save < lines)
                lines = save;
    #endif // !i386
            calcScreenParams( &height, &vgaHeight );
    #ifndef i386
            if (lines < sas_hw_at_no_check( 0x484 ))
                sas_store_no_check( 0x484, lines );
        #ifdef JAPAN_DBG
            DbgPrint(" NTVDM: DoFullScreenResume() set %d lines/screen\n",
                     sas_hw_at_no_check( 0x484 ) + 1 );
        #endif
    #else // i386
            sas_store( 0x484, save );
    #endif // i386
        }
        else
            calcScreenParams( &height, &vgaHeight );
    }
#else // !JAPAN
    calcScreenParams( &height, &vgaHeight );
#endif // !JAPAN

    /*
    ** Window resize code copied out of nt_graph.c:textResize().
    */
    {
        resizeWindow( 80, vgaHeight );
    }

    /* Copy the console buffer to the regen buffer. */
#ifdef JAPAN
    // for $IAS, KKCFUNC
    if (!is_us_mode())
    {
        SHORT rows;

        rows = sas_hw_at_no_check( 0x484 );

        if (rows+1 != vgaHeight && ConsBufferInfo.dwCursorPosition.Y>= rows+1)
            copyConsoleToRegen(0, 1, VGA_WIDTH, (SHORT)(rows+1));
        else
            copyConsoleToRegen(0, 0, VGA_WIDTH, (SHORT)(rows+1));
    #ifdef JAPAN_DBG
        DbgPrint( "NTVDM: copyConsoleToRegen (All)\n" );
    #endif
    }
    else
        copyConsoleToRegen(0, 0, VGA_WIDTH, vgaHeight); // kksuzuka#4009
#else // !JAPAN
    copyConsoleToRegen(0, 0, VGA_WIDTH, vgaHeight);
#endif // !JAPAN

    /*
    ** Make sure cursor is not below bottom line.
    */
#ifdef JAPAN
    // scroll up if $IAS is loaded.
    if (!is_us_mode())
    {
        byte rows;

        rows = sas_hw_at_no_check( 0x484 );
        if (ConsBufferInfo.dwCursorPosition.Y >= rows+1)
        {
            ConsBufferInfo.dwCursorPosition.Y = rows;
    #ifdef JAPAN_DBG
            DbgPrint( "NTVDM: CursorPosition reset %d\n", rows );
    #endif
        }
    #ifdef JAPAN_DBG
        DbgPrint(" NTVDM:DoFullScreenResume() set cur pos %d,%d\n", ConsBufferInfo.dwCursorPosition.X, ConsBufferInfo.dwCursorPosition.Y );
    #endif
    }
    else
#endif // JAPAN
        if (ConsBufferInfo.dwCursorPosition.Y >= vgaHeight)
    {
        ConsBufferInfo.dwCursorPosition.Y = vgaHeight-1;
    }
    setVDMCursorPosition(( UTINY)height, &ConsBufferInfo.dwCursorPosition);

#if defined(JAPAN) || defined(KOREA)
    #ifdef i386
    // #3741: WordStar6.0: Hilight color is changed after running in window
    // 11/27/93 yasuho
    // Also call VDM when in US mode, because we necessary restore the
    // palette and DAC registers
    if (sc.ScreenState == FULLSCREEN && FullScreenResumeSeg)
    {
        CallVDM(FullScreenResumeSeg, FullScreenResumeOff);
    }
    #endif // i386
#endif // JAPAN
} /* end of DoFullScreenResume() */

/***************************************************************************
 * Function:                                                               *
 *      GfxCloseDown                                                       *
 *                                                                         *
 * Description:                                                            *
 *      Hook from host_terminate to ensure section closed so can then start*
 *      more VDMs.                                                         *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID (Errors handled internally in CloseSection)                   *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID GfxCloseDown(VOID)
{
    /* Text and Video sections previously closed here... */
}
#if 0  // Forzen window is no longer supported a-stzong 5/15/01
    #ifdef X86GFX
/***************************************************************************
 * Function:                                                               *
 *      FreezeWinTitle                                                     *
 *                                                                         *
 * Description:                                                            *
 *      Adds -FROZEN to the relevant console window title                  *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID FreezeWinTitle(VOID)
{
    wchar_t  title[MAX_TITLE_LEN],*ptr;
    SHORT    max;
    ULONG    len;

    if (WinFrozen)
        return;

    //
    // The buffer contains the string plus the terminating null.
    // So keep the string length less the null in len.
    // Console can fail this call with silly error codes in low memory cases
    // or if original title contains dubious chars.
    //

    len = wcslen(wszFrozenString);

    max = (SHORT) (MAX_TITLE_LEN - len);
    if (!GetConsoleTitleW(title, max))
        title[0] = L'\0';

    //
    // Remove any trailing spaces or tabs from the title string
    //

    if (len = wcslen(title))
    {
        ptr = title + len - 1;
        while (*ptr == L' ' || *ptr == L'\t')
            *ptr-- = L'\0';
    }

    //
    // Add " - FROZEN" or the international equivalent to
    // the end of the title string.
    //

    wcscat(title, wszFrozenString);
    if (!SetConsoleTitleW(title))
        ErrorExit();
    WinFrozen = TRUE;

}

/***************************************************************************
 * Function:                                                               *
 *      UnFreezeWinTitle                                                   *
 *                                                                         *
 * Description:                                                            *
 *      Removes -FROZEN from the relevant console window title               *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID UnFreezeWinTitle(VOID)
{
    wchar_t  title[MAX_TITLE_LEN];
    ULONG    len,orglen;

    if (! WinFrozen)
        return;

    if (!GetConsoleTitleW(title, MAX_TITLE_LEN))
        ErrorExit();


    //
    // The buffer contains the string plus the terminating null.
    // So keep the string length less the null in len.
    //

    len = wcslen(wszFrozenString);
    orglen = wcslen(title);
    title[orglen - len] = L'\0';
    if (!SetConsoleTitleW(title))
        ErrorExit();
    WinFrozen = FALSE;

    //
    // Now that we're thawing, put the mouse menu item
    // back into the system menu.
    // Andy!

    MouseAttachMenuItem(sc.ActiveOutputBufferHandle);
}
    #endif
#endif

/*
 * ==========================================================================
 * Local Functions
 * ==========================================================================
 */

/***************************************************************************
 * Function:                                                               *
 *      enableUpdates                                                      *
 *                                                                         *
 * Description:                                                            *
 *      Restarts the reflection of regen buffer updates to paint routines. *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
VOID enableUpdates(VOID)
{
    enable_gfx_update_routines();
    ConsoleNoUpdates = FALSE;
}

/***************************************************************************
 * Function:                                                               *
 *      disableUpdates                                                     *
 *                                                                         *
 * Description:                                                            *
 *      Stops changes to the regen buffer being reflected to paint         *
 *      routines.                                                          *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
VOID disableUpdates(VOID)
{
    disable_gfx_update_routines();
    ConsoleNoUpdates = TRUE;
}

/***************************************************************************
 * Function:                                                               *
 *      copyConsoleToRegen                                                 *
 *                                                                         *
 * Description:                                                            *
 *      Copies the contents of the console buffer to the video regen       *
 *      buffer.                                                            *
 *                                                                         *
 * Parameters:                                                             *
 *      startCol - start column of console buffer                          *
 *      startLine - start line of console buffer                           *
 *      width - width of console buffer                                    *
 *      height - height of console buffer                                  *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
VOID copyConsoleToRegen(SHORT startCol, SHORT startLine, SHORT width,
                        SHORT height)
{
    CHAR_INFO   *from;
    COORD        bufSize,
    bufCoord;
    LONG         nChars;
    SMALL_RECT   readRegion;

    register half_word  *to;
#ifdef X86GFX
    half_word    misc;
    register half_word  *vc;
#endif
#if defined(JAPAN) || defined(KOREA)
    #ifdef i386
    register half_word *toDosv = (half_word *)FromConsoleOutput;
    #endif  // i386
#endif // JAPAN || KOREA


    /* Allocate the buffer to get the console data into */
    nChars = width * height;
    assert0(nChars <= MAX_CONSOLE_SIZE, "Console buffer overflow");

    /* Get the console data. */
    bufSize.X = width;
    bufSize.Y = height;
    bufCoord.X = 0;
    bufCoord.Y = 0;
    readRegion.Left = startCol;
    readRegion.Top = startLine;
    readRegion.Right = startCol + width - (SHORT) 1;
    readRegion.Bottom = startLine + height - (SHORT) 1;
    if (!ReadConsoleOutput(sc.OutputHandle,
                           consoleBuffer,
                           bufSize,
                           bufCoord,
                           &readRegion))
        ErrorExit();

    /* Copy the console data to the regen buffer. */
    from = consoleBuffer;

#ifndef X86GFX  // on MIPS we actually want to write to the VGA bitplanes.
    to = EGA_planes;
    #if defined(JAPAN)
    // copy from beneath block and modified
    // save Console Output for MS-DOS/V
    // mode73h support
    {
        register sys_addr V_vram;

        // We now use DosvVramPtr to host extended attributes in video mode 73h.
        V_vram = DosvVramPtr;

        if (!is_us_mode() && saved_video_mode == 0xff)
            goto skip_copy_console;

        if (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x73)
        {
            while (nChars--)
            {
                *to++ = from->Char.AsciiChar;
                *to++ = (half_word) from->Attributes;
                *to++ = (half_word)( (from->Attributes
                                      & ( COMMON_LVB_GRID_HORIZONTAL
                                          | COMMON_LVB_GRID_LVERTICAL
                                          | COMMON_LVB_REVERSE_VIDEO
                                          | COMMON_LVB_UNDERSCORE )
                                     ) >> 8 );
                *to++ = 0x00;

//          sas_store_no_check(V_vram++, from->Char.AsciiChar);
//          sas_store_no_check(V_vram++, (half_word) from->Attributes);
                sas_store_no_check(V_vram++, (half_word)( (from->Attributes
                                                           & ( COMMON_LVB_GRID_HORIZONTAL
                                                               | COMMON_LVB_GRID_LVERTICAL
                                                               | COMMON_LVB_REVERSE_VIDEO
                                                               | COMMON_LVB_UNDERSCORE )
                                                          ) >> 8 ));
                sas_store_no_check(V_vram++, 0x00);

                from++;
            }
        }
        else
        {
            while (nChars--)
            {
                *to++ = from->Char.AsciiChar;
                *to   = (half_word) from->Attributes;

//          sas_store_no_check(V_vram++, from->Char.AsciiChar);
//          sas_store_no_check(V_vram++, (half_word) from->Attributes);

                from++;
                to += 3;
            }
        }
    }
    skip_copy_console:
    #elif defined(KOREA) // !JAPAN
    {
        register sys_addr V_vram;

        V_vram = DosvVramPtr;

        if (!is_us_mode() && saved_video_mode == 0xff)
            goto skip_copy_console;

        while (nChars--)
        {
            *to++ = from->Char.AsciiChar;
            *to   = (half_word) from->Attributes;

//          sas_store_no_check(V_vram++, from->Char.AsciiChar);
//          sas_store_no_check(V_vram++, (half_word) from->Attributes);

            from++;
            to += 3;
        }
    }
    skip_copy_console:
    #else  // !KOREA
    while (nChars--)
    {
        *to++ = from->Char.AsciiChar;
        *to = (half_word) from->Attributes;
        from++;
        to += 3;        // skipping interleaved font planes.
    }
    #endif // !KOREA
    host_mark_screen_refresh();
#else

    /*
     * In V86 mode PC memory area is mapped to the bottom 1M of virtual memory,
     * so the following is legal.
     */
    vga_misc_inb(0x3cc, &misc);
    if (misc & 1)                       // may be mono mode
        to = (half_word *) CGA_REGEN_START;
    else
        to = (half_word *) MDA_REGEN_START;
    #ifdef JAPAN
    // change Vram addres to DosVramPtr from B8000
    if (!is_us_mode())
    {
        // #3086: VDM crash when exit 16bit apps of video mode 11h
        // 12/8/93 yasuho
        if (saved_video_mode == 0x03 || saved_video_mode == 0x73)
            to = (half_word *)DosvVramPtr;
        else
            to = (half_word *)FromConsoleOutput;
    }
    #elif defined(KOREA) // JAPAN
    // change Vram addres to DosVramPtr from B8000
    if (!is_us_mode())
    {
        // #3086: VDM crash when exit 16bit apps of video mode 11h
        // 12/8/93 yasuho
        if (saved_video_mode == 0x03)
            to = (half_word *)DosvVramPtr;
        else
            to = (half_word *)FromConsoleOutput;
    }
    #endif // KOREA

    vc = (half_word *) video_copy;

    #ifdef JAPAN
    // mode73h support
    if (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x73)
    {
        while (nChars--)
        {
            *toDosv++ = *to++ = *vc++ = from->Char.AsciiChar;
            *toDosv++ = *to++ = *vc++ = (half_word) from->Attributes;
            *toDosv++ = *to++ = *vc++ = ( (from->Attributes
                                           & ( COMMON_LVB_GRID_HORIZONTAL
                                               | COMMON_LVB_GRID_LVERTICAL
                                               | COMMON_LVB_REVERSE_VIDEO
                                               | COMMON_LVB_UNDERSCORE )
                                          ) >> 8 );
            *toDosv++ = *to++ = *vc++ = 0x00; // reserved in DosV
            from++;
        }
    }
    else
    {
        while (nChars--)
        {
            *toDosv++ = *to++ = *vc++ = from->Char.AsciiChar;
            *toDosv++ = *to++ = *vc++ = (half_word) from->Attributes;
            from++;
        }
    }
    // for RAID #875   copy from CheckForFullscreenSwitch()
    {
        register int  i, j, k;
        register char *p;
        int DBCSStatus;
        int text_skip;

        // mode73h support
        if (!is_us_mode() && ( sas_hw_at_no_check(DosvModePtr) == 0x73))
            text_skip = 4;
        else
            text_skip = 2;

        if (BOPFromDispFlag)
        {  // CP == 437 is OK
            k = 0;
            //p = DosvVramPtr;  // BUG!
            p = get_screen_ptr(0);
            Int10FlagCnt++;
            for (i = 0; i < 50; i++)
            {   // lines == 50
                DBCSStatus = FALSE;
                for (j = 0; j < 80; j++)
                {
                    if (DBCSStatus)
                    {
                        Int10Flag[k] = INT10_DBCS_TRAILING | INT10_CHANGED;
                        DBCSStatus = FALSE;
                    }
                    else if (DBCSStatus = is_dbcs_first( *p ))
                    {
                        Int10Flag[k] = INT10_DBCS_LEADING | INT10_CHANGED;
                    }
                    else
                    {
                        Int10Flag[k] = INT10_SBCS | INT10_CHANGED;
                    }
                    k++; p += text_skip;
                }
            }
        }
    }
    FromConsoleOutputFlag = TRUE;
    #elif defined(KOREA) // JAPAN
    while (nChars--)
    {
        *toDosv++ = *to++ = *vc++ = from->Char.AsciiChar;
        *toDosv++ = *to++ = *vc++ = (half_word) from->Attributes;
        from++;
    }

    FromConsoleOutputFlag = TRUE;
    #else // !KOREA
    while (nChars--)
    {
        *to++ = *vc++ = from->Char.AsciiChar;
        *to++ = *vc++ = (half_word) from->Attributes;
        from++;
    }
    #endif // !KOREA
#endif
}

/***************************************************************************
 * Function:                                                               *
 *      getVDMCursorPosition                                               *
 *                                                                         *
 * Description:                                                            *
 *      Gets the cursor position from BIOS variables and tells the console *
 *      where to place its cursor.                                         *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
VOID getVDMCursorPosition(VOID)
{
    half_word currentPage;
    word cursorWord;
    COORD cursorPos;
    BOOL setok;

    /* Get the current video page. */
    currentPage = sas_hw_at_no_check(vd_current_page);

    /* Store cursor position in BIOS variables. */
    cursorWord = sas_w_at_no_check(VID_CURPOS + (currentPage * 2));

    /* Set the console cursor. */
    cursorPos.X = (SHORT) (cursorWord & 0xff);
    cursorPos.Y = (cursorWord >> 8) & (SHORT) 0xff;

    //
    // Since apps can set whatever values to 40:50 cursor position.
    // We need to make sure the range is within the limit that console will accept.
    //

    if ((sc.CharHeight * cursorPos.Y) >= sc.PC_W_Height)
        cursorPos.Y = (sc.PC_W_Height / sc.CharHeight) - 1;

    if ((sc.CharWidth * cursorPos.X) >= sc.PC_W_Width)
        cursorPos.X = (sc.PC_W_Width / sc.CharWidth) - 1;

    if (!stdoutRedirected)
    {
        setok = SetConsoleCursorPosition(sc.OutputHandle, cursorPos);
        if (!setok)
        {

            if (GetLastError() != ERROR_INVALID_HANDLE) // ie. output redirected
                ErrorExit();
        }
    }
}

/***************************************************************************
 * Function:                                                               *
 *      setVDMCursorPosition                                               *
 *                                                                         *
 * Description:                                                            *
 *      Positions SoftPC's cursor, setting the relevant BIOS variables.    *
 *                                                                         *
 * Parameters:                                                             *
 *      height          - the current character height                     *
 *      cursorPos       - the coordinates of the cursor                    *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
VOID setVDMCursorPosition(UTINY height, PCOORD cursorPos)
{
    CONSOLE_CURSOR_INFO cursorInfo;
    ULONG port6845,
    cursorStart,
    cursorEnd,
    colsOnScreen,
    videoLen,
    pageOffset,
    cursorWord;
    UTINY currentPage;

    /* Get cursor size. */
    if (!GetConsoleCursorInfo(sc.OutputHandle, &cursorInfo))
        ErrorExit();

    /* Work out cursor start and end pixels. */
#if defined(JAPAN) || defined(KOREA)
    if (!is_us_mode())
        height = 8;             // for dosv cursor
#endif // JAPAN || KOREA
    cursorStart = height - (height * cursorInfo.dwSize / 100);
    if (cursorStart == height)
        cursorStart--;
    cursorEnd = height - 1;

    if (sc.ScreenState == WINDOWED)
    {

        /* Pass cursor size to video ports. */
        port6845 = sas_w_at_no_check(VID_INDEX);
        outb((io_addr) port6845, R10_CURS_START);
        outb((io_addr) (port6845 + 1), (half_word) cursorStart);
        outb((io_addr) port6845, R11_CURS_END);
        outb((io_addr) (port6845 + 1), (half_word) cursorEnd);
    }

    /* Get the current video page. */
    currentPage = sas_hw_at_no_check(vd_current_page);

    /* Set BIOS variables. */
    sas_storew_no_check(VID_CURMOD,
                        (word) ((cursorStart << 8) | (cursorEnd & 0xff)));

    /* Work out cursor position. */
    colsOnScreen = sas_w_at_no_check(VID_COLS);
    videoLen = sas_w_at_no_check(VID_LEN);
    pageOffset = cursorPos->Y * colsOnScreen * 2 + (cursorPos->X << 1);
    cursorWord = (currentPage * videoLen + pageOffset) / 2;

    if (sc.ScreenState == WINDOWED)
    {

        /* Send cursor position to video ports. */
        outb((io_addr) port6845, R14_CURS_ADDRH);
        outb((io_addr) (port6845 + 1), (half_word) (cursorWord >> 8));
        outb((io_addr) port6845, R15_CURS_ADDRL);
        outb((io_addr) (port6845 + 1), (half_word) (cursorWord & 0xff));
    }

    /* Store cursor position in BIOS variables. */
    sas_storew_no_check(VID_CURPOS + (currentPage * 2),
                        (word) ((cursorPos->Y << 8) | (cursorPos->X & 0xff)));

    if (sc.ScreenState == WINDOWED)
    {
#ifdef MONITOR
        resetNowCur();        /* reset static vars holding cursor pos. */
#endif
        do_new_cursor();      /* make sure the emulation knows about it */
    }
}

VOID waitForInputFocus()
{
    HANDLE events[2] = {hSuspend, sc.FocusEvent};
    ULONG retCode;

    while (TRUE) {
        retCode = WaitForMultipleObjects(2, events, FALSE, INFINITE);
        if (retCode == 0) {
            //
            // If we get suspend request while waiting for input focus
            //
            SetEvent(hMainThreadSuspended); // enable screen switch
            WaitForSingleObject(hResume, INFINITE);
            DisableScreenSwitch(hMainThreadSuspended);
        } else if (retCode == 1) {
            return;
        } else {
            ErrorExit();
            return;
        }
    }
}

VOID AddTempIVTFixups()
{
    /* BOP        17,   IRET */
    UTINY code[] = { 0xc4, 0xc4, 0x17, 0xcf};

    //location is random but should be safe until DOS is initialised!!!
    sas_stores(0x40000, code, sizeof(code));    // new Int 17 code
    sas_storew(0x17*4, 0);                      // Int 17h offset
    sas_storew((0x17*4) + 2, 0x4000);           // Int 17h segment
}

#if defined(JAPAN) || defined(KOREA)
    #ifdef X86GFX
/***************************************************************************
 * Function:                                                               *
 *      call 16bits subroutine                                             *
 *                                                                         *
 * Description:                                                            *
 *      This function makes necessary mode transition before calling       *
 *      16bits call.                                                       *
 *                                                                         *
 * Parameters:                                                             *
 *      word CS:IP is the 16bits code to be executed.                      *
 *      It should return with BOP 0xFE                                     *
 * Return value:                                                           *
 *      none                                                               *
 *                                                                         *
 ***************************************************************************/
LOCAL  void CallVDM(word CS, word IP)
{

    /*****************************
    - williamh -
   What we did here is:
   (1). save current VDM context
   (2). switch VDM context to real mode
   (3). switch VDM stack to DOSX real mode stack
   (4). set our real mode target to the VDM context
   (5). execute the VDM
   (6). switch stack to DOSX protected mode stack
   (7). switch VDM context to protected mode
   (8). restor VDM context

   Don't ask me why. We don't have a generic software
   interrupt simulation mechanism like Windows does.
   ***************************************************/


    IMPORT void DpmiSwitchToRealMode(void);
    IMPORT void DpmiSwitchToDosxStack(void);
    IMPORT void DpmiSwitchFromDosxStack(void);
    IMPORT void DpmiSwitchToProtectedMode(void);
    WORD    OldAX, OldBX, OldCX, OldDX, OldSI, OldDI;
    WORD    OldES, OldDS, OldSS, OldCS, OldGS, OldFS;
    WORD    OldSP, OldIP, OldMSW;
    if (getMSW() & MSW_PE)
    {

        OldAX = getAX(); OldBX = getBX(); OldCX = getCX();
        OldDX = getDX(); OldSI = getSI(); OldDI = getDI();
        OldES = getES(); OldDS = getDS(); OldSS = getSS();
        OldCS = getCS(); OldGS = getGS(); OldFS = getFS();
        OldSP = getSP(); OldIP = getIP();
        OldMSW = getMSW();

        DpmiSwitchToRealMode();
        DpmiSwitchToDosxStack();
        setCS(CS);
        setIP(IP);
        host_simulate();
        DpmiSwitchFromDosxStack();
        DpmiSwitchToProtectedMode();
        setAX(OldAX); setBX(OldBX); setCX(OldCX);
        setDX(OldDX); setSI(OldSI); setDI(OldDI);
        setES(OldES); setDS(OldDS); setSS(OldSS);
        setCS(OldCS); setGS(OldGS); setFS(OldGS);
        setSP(OldSP); setIP(OldIP);
        setMSW(OldMSW);
    }
    else
    {
        OldCS = getCS();
        OldIP = getIP();
        setCS(CS);
        setIP(IP);
        host_simulate();
        setCS(OldCS);
        setIP(OldIP);
    }

}
    #endif  /* X86GFX */
#endif  /* JAPAN || KOREA*/

/***************************************************************************
 * Function:                                                               *
 *      getModeType                                                        *
 *                                                                         *
 * Description:                                                            *
 *      Look up video mode to determine whether the VGA current mode is    *
 *      graphics or text.                                                  *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      int - TEXT or GRAPHICS.                                            *
 *                                                                         *
 ***************************************************************************/
int getModeType(VOID)
{
    half_word mode;
    int modeType;

    mode = sas_hw_at_no_check(vd_video_mode);
    switch (mode)
    {
    case 0:
    case 1:
    case 2:
    case 3:
    case 7:
    case 0x20:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
        modeType = TEXT;
        break;
    default:
        modeType = GRAPHICS;
        break;
    }
    return (modeType);
}

#ifdef X86GFX
/***************************************************************************
 * Function:                                                               *
 *      host_check_mouse_buffer                                            *
 *                                                                         *
 * Description:                                                            *
 *      Called when an INT 10h, AH = 11h is being executed, this function  *
 *      checks to see if the number of lines on the screen for a text mode *
 *      has changed and if so selects a new mouse buffer.                  *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID host_check_mouse_buffer(VOID)
{
    half_word mode,
    sub_func,
    font_height,
    text_lines;
    IU16 scan_lines;

    /* Get the current video mode. */
    mode = sas_hw_at_no_check(vd_video_mode);
    #ifdef V7VGA
    if (mode > 0x13)
        mode += 0x4c;
    else if ((mode == 1) && (extensions_controller.foreground_latch_1))
        mode = extensions_controller.foreground_latch_1;
    #endif /* V7VGA */

    /*
     * Check to see if we are in a text mode whose mouse virtual coordinates
     * are affected by the number of lines on the screen.
     */
    if ((mode == 0x2) || (mode == 0x3) || (mode == 0x7))
    {

        /* Work out the font height being set. */
        sub_func = getAL();
        switch (sub_func)
        {
        case 0x10:
            font_height = getBH();
            break;
        case 0x11:
            font_height = 14;
            break;
        case 0x12:
            font_height = 8;
            break;
        case 0x14:
            font_height = 16;
            break;
        default:

            /*
             * The above are the only functions that re-program the no. of lines
             * on the screen, so do nothing if we have something else.
             */
            return;
        }

        /* Get the number of scan lines for this mode. */
        if (!(get_EGA_switches() & 1) && (mode < 4))
        {
            scan_lines = 200; /* Low res text mode */
        }
        else
        {
            switch (get_VGA_lines())
            {
            case S200:
                scan_lines = 200;
                break;
            case S350:
                scan_lines = 350;
                break;
            case S400:
                scan_lines = 400;
                break;
            default:

                /* Dodgy value in BIOS data area - don't do anything. */
                assert0(NO, "invalid VGA lines in BIOS data");
                return;
            }
        }

        /* Now work out the number of text lines on the screen. */
        text_lines = scan_lines / font_height;

        /* If the number of lines has changed, select a new mouse buffer. */
        if (text_lines != saved_text_lines)
            SelectMouseBuffer(mode, text_lines);

    } /* if ((mode == 0x2) || (mode == 0x3) || (mode == 0x7)) */
}

/***************************************************************************
 * Function:                                                               *
 *      SelectMouseBuffer                                                  *
 *                                                                         *
 * Description:                                                            *
 *      Selects the correct screen ratio for the video mode.at the         *
 *                                                                         *
 * Parameters:                                                             *
 *      mode    - the video mode for which we are setting a screen buffer. *
 *      lines   - for text modes: the number of character lines on the     *
 *                screen, 0 denotes the default for this mode.             *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID SelectMouseBuffer(half_word mode, half_word lines)
{
    DWORD        width,
    height;

    /*
    ** When stdout is being redirected we must not set up the graphics
    ** buffer for the mouse. Otherwise 32-bit progs like MORE crash
    ** cos they ask console for the active console handle and get
    ** confused. We get told by DOS Em. when stdout is being
    ** redirected and do not set up the buffer.
    ** Tim Jan 93.
    */
    if (stdoutRedirected)
        return;

    /* Work out the screen resolution. */
    switch (mode & 0x7f)
    {
    case 0x0:
    case 0x1:
        width = 640;
        height = 200;
        break;
    case 0x2:
    case 0x3:
    case 0x7:
        switch (lines)
        {
        case 0:
        case 25:
            saved_text_lines = 25;
            width = 640;
            height = 200;
            break;
        case 43:
            saved_text_lines = 43;
            width = 640;
            height = 344;
            break;
        case 50:
            saved_text_lines = 50;
            width = 640;
            height = 400;
            break;
        default:
            assert1(NO, "strange number of lines for text mode - %d", lines);
            return;
        }
        break;
    case 0x4:
    case 0x5:
    case 0x6:
    case 0xd:
    case 0xe:
        width = 640;
        height = 200;
        break;
    case 0xf:
    case 0x10:
        width = 640;
        height = 350;
        break;
    case 0x11:
    case 0x12:
        width = 640;
        height = 480;
        break;
    case 0x13:
        width = 640;
        height = 200;
        break;
    case 0x40:
        width = 640;
        height = 400;
        break;
    case 0x41:
    case 0x42:
        width = 1056;
        height = 344;
        break;
    case 0x43:
        width = 640;
        height = 480;
        break;
    case 0x44:
        width = 800;
        height = 480;
        break;
    case 0x45:
        width = 1056;
        height = 392;
        break;
    case 0x60:
        width = 752;
        height = 408;
        break;
    case 0x61:
        width = 720;
        height = 536;
        break;
    case 0x62:
        width = 800;
        height = 600;
        break;
    case 0x63:
    case 0x64:
    case 0x65:
        width = 1024;
        height = 768;
        break;
    case 0x66:
        width = 640;
        height = 400;
        break;
    case 0x67:
        width = 640;
        height = 480;
        break;
    case 0x68:
        width = 720;
        height = 540;
        break;
    case 0x69:
        width = 800;
        height = 600;
        break;
    default:

        /* No change if we get an unknown mode. */
        assert1(NO, "unknown mode - %d", mode);
        return;
    }

    //
    // Set the variables to let apps like Word and Works which call
    // INT 33h AX = 26h to find out the size of the current virtual
    // screen.
    // Andy!

    VirtualX = (word)width;
    VirtualY = (word)height;

    /* Save current dimensions. */
    mouse_buffer_width = width;
    mouse_buffer_height = height;

}
#endif /* X86GFX */

void host_enable_stream_io(void)
{
    sc.ScreenState = STREAM_IO;
    host_stream_io_enabled = TRUE;

}
void host_disable_stream_io(void)
{
    DWORD mode;

    if (!GetConsoleMode(sc.InputHandle, &mode))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    mode |= (ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT);
    if (!SetConsoleMode(sc.InputHandle,mode))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);


    if (!GetConsoleMode(sc.OutputHandle, &mode))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
    if (!stdoutRedirected)
    {
        mode &= ~(ENABLE_WRAP_AT_EOL_OUTPUT | ENABLE_PROCESSED_OUTPUT);

        if (!SetConsoleMode(sc.OutputHandle,mode))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);
    }

    ConsoleInit();
    (void)(*choose_display_mode)();
    /*
    ** Copy the console buffer to the regen buffer.
    ** Don't want to adjust the copy from top of console window, console
    ** does it itself if we resize the window. Tim September 92.
    */
    copyConsoleToRegen(0, 0, VGA_WIDTH, (SHORT)ConVGAHeight);

    /*
    ** Tim September 92, adjust cursor position if console window size is
    ** adjusted.
    */
    ConsBufferInfo.dwCursorPosition.Y -= (SHORT)ConTopLine;

    /* Set up SoftPC's cursor. */
    setVDMCursorPosition((UTINY)StartupCharHeight,
                         &ConsBufferInfo.dwCursorPosition);

    if (sc.ScreenState == WINDOWED)
        enableUpdates();

    MouseAttachMenuItem(sc.ActiveOutputBufferHandle);
    host_stream_io_enabled = FALSE;
}

VOID EnableScreenSwitch(BOOLEAN OnlyFullScreenMode, HANDLE handle)
{
    if (!OnlyFullScreenMode || sc.ScreenState == FULLSCREEN) {
        SetEvent(handle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_error.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <conapi.h>
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 2.0
 *
 * Title        : General Error Handler
 *
 * Description  : General purpose error handler.  It handles both
 *                general SoftPC errors (error numbers 0 - 999) and
 *                host specific errors (error numbers >= 1000)
 *
 * Author(s)    : Dave Bartlett (based on module by John Shanly)
 *
 * Parameters   : int used to index an array of error messages
 *                held in message.c, and a bit mask indicating
 *                the user's possible options:
 *                    Quit, Reset, Continue, Setup
 *
 */


#include <sys/types.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>

#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "gvi.h"
#include "error.h"
#include "config.h"
#include "dterm.h"
#include "host_rrr.h"
#include "host_nls.h"

#include "nt_graph.h"
#include "nt_uis.h"
#include "nt_reset.h"
#include "ckmalloc.h"

#include "trace.h"
#include "nt_event.h"



extern DWORD (*pW32HungAppNotifyThread)(UINT);
extern PVOID  CurrentMonitorTeb;   // thread that is currently executing instructions.
int error_window_options = 0;

VOID SuspendTimerThread(VOID);
VOID ResumeTimerThread(VOID);


/*::::::::::::::::::::::::::::::::: Internally used variables and functions */

typedef struct _ErrorDialogBoxInfo{
     DWORD   dwOptions;
     DWORD   dwReply;
     HWND    hWndCon;
     char   *message;
     char   *pEdit;
     char    Title[MAX_PATH];
     }ERRORDIALOGINFO, *PERRORDIALOGINFO;

char achPERIOD[]=". ";


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: STDOUT macro */

#define ERRORMSG              OutputDebugString
#define HIDEDLGITM(d,b)       ShowWindow(GetDlgItem(d,b),SW_HIDE);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int ErrorDialogBox(char *message, char *Edit, DWORD dwOptions);
DWORD ErrorDialogBoxThread(VOID *pv);
int WowErrorDialogEvents(ERRORDIALOGINFO *pedgi);
BOOL CALLBACK ErrorDialogEvents(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
void SwpButtons(HWND hDlg, DWORD dwOptions);
void SwpDosDialogs(HWND hDlg, HWND hWndCon,HWND SwpInsert, UINT SwpFlags);
DWORD OemMessageToAnsiMessage(CHAR *, CHAR *);
DWORD AnsiMessageToOemMessage(CHAR *pBuff, CHAR *pMsg);
ULONG WOWpSysErrorBox(LPSTR,LPSTR,USHORT,USHORT,USHORT);


#ifndef MONITOR

  /*
   *  Do things the old fashioned way for some of the cpu building tools
   *  which cannot be changed to match our host
   */


#ifdef host_error_ext
#undef host_error_ext
#endif
SHORT host_error_ext(int error_num, int options, ErrDataPtr data)
{
    return host_error(error_num, options, NULL);
}

#ifdef host_error
#undef host_error
#endif
SHORT host_error(int error_num, int options, char *extra_char);

#ifdef host_error_conf
#undef host_error_conf
#endif
SHORT host_error_conf(int config_panel, int error_num, int options,
                       char *extra_char)
{
   return host_error(error_num, options, extra_char);
}

ERRORFUNCS nt_error_funcs = { host_error_conf,host_error,host_error_ext};
ERRORFUNCS *working_error_funcs = &nt_error_funcs;
#endif





/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Display error, terminate ::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int DisplayErrorTerm(int ErrorNo,       /* Softpc Error number */
                     DWORD OSErrno,         /* OS Error number */
                     char *Filename,        /* File name of file containing err */
                     int Lineno)            /* LIne number of error */
{
    char Msg[EHS_MSG_LEN];
    CHAR FormatStr[EHS_MSG_LEN]="%s %lxh";
    DWORD myerrno, len;

    UNUSED(ErrorNo);    //Always internal error

#ifndef PROD
    sprintf(Msg,"NTVDM:ErrNo %#x, %s:%d\n", OSErrno, Filename, Lineno);
    OutputDebugString(Msg);
#endif

    // assume NT error if either of top two bits set (err or warning).
    // this means we'll confuse some of the lesser NT errors but we get a
    // second chance if the mapping fails.
    if (OSErrno & 0xc0000000)
        myerrno = RtlNtStatusToDosError(OSErrno);
    else
        myerrno = OSErrno;

           // Now get message from system
    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        myerrno,
                        0,
                        Msg,
                        EHS_MSG_LEN,
                        NULL
                        );
    if (!len) {
        LoadString(GetModuleHandle(NULL),
                   ED_FORMATSTR0,
                   FormatStr,
                   sizeof(FormatStr)/sizeof(CHAR));

        _snprintf(Msg, EHS_MSG_LEN, FormatStr, szSysErrMsg, OSErrno);
        Msg[EHS_MSG_LEN-1] = '\0';
        }

    return(host_error(EHS_SYSTEM_ERROR, ERR_QUIT, Msg));
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Display host error ::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


SHORT host_error(int error_num, int options, char *extra_char)
{
    char message[EHS_MSG_LEN];
    ULONG uLen = EHS_MSG_LEN -2;
   
    if(extra_char) {
       uLen -= strlen(extra_char);
    }

    host_nls_get_msg(error_num, message, uLen);

    if (extra_char && *extra_char) {
       strcat(message,"\n");
       strcat(message,extra_char);
       }


#ifndef PROD
    OutputDebugString(message);
    if (extra_char) {
        OutputDebugString("\n");
        }
#endif

    ErrorDialogBox(message, NULL, RMB_ICON_STOP | RMB_ABORT | RMB_IGNORE);

    return ERR_CONT;
}


DWORD TlsDirectError;
//
// Called directly from C or via bop. Type checked against global 'DirectError'
// to see if called already in this app. 'DirectError' cleared on VDM resume.
//
// This function is expected to be called by 16 bit threads
// which is doing the unsupported service. For DosApps this is
// the CPU thread, For WOW this is one of the individual 16 bit tasks.
//
//
VOID host_direct_access_error(ULONG type)
{
    CHAR message[EHS_MSG_LEN];
    CHAR acctype[EHS_MSG_LEN];
    CHAR dames[EHS_MSG_LEN];
    DWORD dwDirectError;


       /*
        *  Get the direct error record for the current thread
        *  if TlsGetValue returns NULL
        *     - could be invalid index (TlsAlloc failed)
        *     - actual value is 0, (no bits set)
        *  In both cases we will go ahead with the popup
        */
    dwDirectError = (DWORD)TlsGetValue(TlsDirectError);

       // don't annoy user with repeated popups
    if ((dwDirectError & (1<<type)) != 0)
        return;

    TlsSetValue(TlsDirectError, (LPVOID)(dwDirectError | (1 << type)));

    if (LoadString(GetModuleHandle(NULL), D_A_MESS,
                   dames, sizeof(dames)/sizeof(CHAR)) &&
        LoadString(GetModuleHandle(NULL), D_A_MESS + type + 1,
                   acctype, sizeof(acctype)/sizeof(CHAR))     )
       {
        _snprintf(message, EHS_MSG_LEN, dames, acctype);
        message[EHS_MSG_LEN-1] = '\0';
        }
    else {
        strcpy(message, szDoomMsg);
        }


    ErrorDialogBox(message, NULL, RMB_ICON_STOP | RMB_ABORT | RMB_IGNORE);
}


/*
 *   RcErrorDialogBox
 *
 *   Displays standard dialog Box for errors and warnings
 *   Looks up the error message from ntvdm's reource string table
 *
 *   entry: UINT wId   - string table resource index
 *          CHAR *msg1 - Optional OEM strings which are displayed
 *          CHAR *msg2   before the main error message. Each string
 *                       is limited to MAX_PATH inclusive of NULL,
 *                       (auto-truncate).
 *
 *   exit:
 *
 */
void RcErrorDialogBox(UINT wId, CHAR *msg1, CHAR *msg2)
{
     DWORD dw, dwTotal;
     CHAR  ErrMsg[MAX_PATH*4];

     dwTotal = 0;
     dw = OemMessageToAnsiMessage(ErrMsg, msg1);
     if (dw) {
         dwTotal += dw;
         strcpy(&ErrMsg[dwTotal], achPERIOD);
         dwTotal += sizeof(achPERIOD) - 1;
         }

     dw = OemMessageToAnsiMessage(&ErrMsg[dwTotal], msg2);
     if (dw) {
         dwTotal += dw;
         strcpy(&ErrMsg[dwTotal], achPERIOD);
         dwTotal += sizeof(achPERIOD) - 1;
         }

     if (!LoadString(GetModuleHandle(NULL), wId, &ErrMsg[dwTotal], MAX_PATH))
         {
          strcpy(ErrMsg, szDoomMsg);
          }

     ErrorDialogBox(ErrMsg, NULL, RMB_ICON_STOP | RMB_ABORT | RMB_IGNORE);
}



/*
 *   RcMessageBox
 *
 *   Displays standard dialog Box for errors and warnings
 *   Looks up the error message from ntvdm's reource string table
 *
 *   Optionally shows an edit dialog control. The edit control
 *   is placed just below the first line of the message text,
 *   leaving only enuf space to display a one line message.
 *
 *   entry: UINT wId   - string table resource index
 *          CHAR *msg1 - Optional OEM strings which are displayed
 *          CHAR *msg2   before the main error message. Each string
 *                       is limited to MAX_PATH inclusive of NULL,
 *                       (auto-truncate).
 *
 *         If RMB_EDIT is specified msg2 is NOT used for messages
 *         to be displayed, rather is used for the default string for the
 *         edit control. The hiword of dwOPtions is used as max size of
 *         edit buffer, and must be less than MAX_PATH
 *
 *          DWORD dwOptions - accepts
 *                            RMB_ABORT
 *                            RMB_RETRY
 *                            RMB_IGNORE       msg box equivalent
 *                            RMB_ICON_INFO  - IDI_ASTERICK
 *                            RMB_ICON_BANG  - IDI_EXCLAMATION
 *                            RMB_ICON_STOP  - IDI_HAND
 *                            RMB_ICON_WHAT  - IDI_QUESTION
 *                            RMB_EDIT       - edit dialog control
 *
 *   exit: returns RMB_ABORT RMB_RETRY RMB_IGNORE RMB_EDIT
 *         If RMB_EDIT is specified msg2 is used to return
 *         the contents of the edit control
 *
 */
int RcMessageBox(UINT wId, CHAR *msg1, CHAR *msg2, DWORD dwOptions)

{
     DWORD dw, dwTotal;
     char *pEdit;
     CHAR  ErrMsg[MAX_PATH*4];
     CHAR  Edit[MAX_PATH];
     int   i;

     dwTotal = 0;
     dw = OemMessageToAnsiMessage(ErrMsg, msg1);
     if (dw) {
         dwTotal += dw;
         strcpy(&ErrMsg[dwTotal], achPERIOD);
         dwTotal += sizeof(achPERIOD) - 1;
         }

     if (dwOptions & RMB_EDIT)  {
         dw = OemMessageToAnsiMessage(Edit, msg2);
         pEdit = Edit;
         }
     else {
         dw = OemMessageToAnsiMessage(&ErrMsg[dwTotal], msg2);
         if (dw) {
             dwTotal += dw;
             strcpy(&ErrMsg[dwTotal], achPERIOD);
             dwTotal += sizeof(achPERIOD) - 1;
             }
         pEdit = NULL;
         }

     if (!LoadString(GetModuleHandle(NULL), wId, &ErrMsg[dwTotal], MAX_PATH))
         {
          strcpy(ErrMsg, szDoomMsg);
          }

     i = ErrorDialogBox(ErrMsg, pEdit, dwOptions);

     if (pEdit) {
         AnsiMessageToOemMessage(msg2, pEdit);
         }

     return i;
}



/*
 *  AnsiMessageToOemMessage
 *
 *  converts string messages from ansi to oem strings, for display output
 *
 *  entry:  CHAR *msg
 *          Each string is limited to MAX_PATH inclusive of NULL,
 *                       (auto-truncate).
 *
 *          CHAR *pBuff - destination buffer, must be at least MAX_PATH
 *
 *   exit:  returns string len
 */
DWORD AnsiMessageToOemMessage(CHAR *pBuff, CHAR *pMsg)
{
   PUNICODE_STRING pUnicode;
   ANSI_STRING     AnsiString;
   OEM_STRING      OemString;

   if (!pBuff)
       return 0;

   if (!pMsg || !*pMsg) {
       *pBuff = '\0';
       return 0;
       }

   RtlInitString(&AnsiString, pMsg);
   if (AnsiString.Length > MAX_PATH) {
       AnsiString.Length = MAX_PATH-1;
       AnsiString.MaximumLength = MAX_PATH;
       }

   OemString.MaximumLength = AnsiString.MaximumLength;
   OemString.Buffer        = pBuff;
   *(OemString.Buffer+AnsiString.Length) = '\0';
   pUnicode = &NtCurrentTeb()->StaticUnicodeString;
   if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(pUnicode,
                                                &AnsiString,
                                                FALSE))    ||
       !NT_SUCCESS(RtlUnicodeStringToOemString((POEM_STRING)&OemString,
                                                pUnicode,
                                                FALSE)) )
      {
       OemString.Length = 0;
       }

   return OemString.Length;
}


/*
 *  OemMessageToAnsiMessage
 *
 *  converts string messages from oem to ansi strings, for display output
 *
 *  entry:  CHAR *msg
 *          Each string is limited to MAX_PATH inclusive of NULL,
 *                       (auto-truncate).
 *
 *          CHAR *pBuff - destination buffer, must be at least MAX_PATH
 *
 *   exit:  returns string len
 */
DWORD OemMessageToAnsiMessage(CHAR *pBuff, CHAR *pMsg)
{
   PUNICODE_STRING pUnicode;
   ANSI_STRING     AnsiString;
   OEM_STRING      OemString;

   if (!pBuff)
       return 0;

   if (!pMsg || !*pMsg) {
       *pBuff = '\0';
       return 0;
       }

   RtlInitString(&OemString, pMsg);
   if (OemString.Length > MAX_PATH) {
       OemString.Length = MAX_PATH-1;
       OemString.MaximumLength = MAX_PATH;
       }
   AnsiString.MaximumLength = OemString.MaximumLength;
   AnsiString.Buffer        = pBuff;
   *(AnsiString.Buffer+OemString.Length) = '\0';
   pUnicode = &NtCurrentTeb()->StaticUnicodeString;
   if (!NT_SUCCESS(RtlOemStringToUnicodeString(pUnicode,
                                               &OemString,
                                                FALSE))    ||
       !NT_SUCCESS(RtlUnicodeStringToAnsiString((POEM_STRING)&AnsiString,
                                                pUnicode,
                                                FALSE)) )
      {
       AnsiString.Length = 0;
       }

   return AnsiString.Length;
}


/*
 * Thread call back function for EnumThreadWindows
 * entry:  HWND   hWnd   - window handle to verify
 *         LPARAM lParam - address of edgi->hWnd == ThreadID
 *
 * exit:   TRUE  - to continue enumeration
 *         FALSE - edgi->hWnd has window handle for TopLevelWindow of thread
 *
 */
BOOL CALLBACK GetThreadTopLevelWindow(HWND hWnd, LPARAM lParam)
{
   PDWORD pdw = (PDWORD)lParam;

   if (GetWindowThreadProcessId(hWnd, NULL) == *pdw)
      {
       *pdw = (DWORD)hWnd;
       return FALSE;
       }
   return TRUE;
}


/*  ErrorDialogBox
 *
 *  Displays standard dialog Box for errors and warnings
 *
 */
int ErrorDialogBox(char *message, char *pEdit, DWORD dwOptions)
{
    static BOOL bCalled=0;
    HANDLE      hThread = NULL;
    HWND        hWndApp;
    DWORD       dwThreadID, dw;
    ERRORDIALOGINFO edgi;


    if (bCalled) {  // recursive call, so stop annoying the user
        return RMB_IGNORE;
        }
    bCalled++;


       /* Raid HotFix 3381 - alpha stress hang. All RISC implementations.
        * If we leave the heartbeat generating timer hardware interrupts
        * all of the time, we will continually add quick events which
        * don't go off until the popup is dismissed. This will suck up
        * local heap and CPU at a hipriority.
        */
    SuspendTimerThread();

       // init err dialog info
    edgi.message   = message;
    edgi.dwReply   = 0;
    edgi.hWndCon   = hWndConsole;
    edgi.dwOptions = dwOptions;
    edgi.pEdit     = pEdit;

        // get window handle for the offending app
    if (VDMForWOW) {
        hWndApp = (HWND)GetCurrentThreadId();
        EnumWindows((WNDENUMPROC)GetThreadTopLevelWindow,(LPARAM)&hWndApp);
        if (hWndApp == (HWND)GetCurrentThreadId()) {
            hWndApp = HWND_DESKTOP;
        }
    }
    else
    {
        hWndApp = edgi.hWndCon;

        //
        // Set suspended event for the current thread to allow
        // screen switch to proceed.
        //
        if (CurrentMonitorTeb != NtCurrentTeb()) {
            EnableScreenSwitch(FALSE, hConsoleSuspended);
        } else {
            EnableScreenSwitch(FALSE, hMainThreadSuspended);
        }
    }

        //
        // get title of app, using DefWindowProc in lieu of
        // GetWindowText to avoid callbacks into threads window proc
        //
    if (hWndApp == HWND_DESKTOP ||
        !DefWindowProc(hWndApp, WM_GETTEXT,
                                (WPARAM) (sizeof(edgi.Title)-1),
                                (LPARAM) edgi.Title) )
      {
        edgi.Title[0] = '\0';
        }


    //
    // if this dialog has an edit window, then we have to use our own
    // dialog, which contains an edit box, and we MUST do it from
    // a separate thread, to avoid problems with full screen switching.
    // Editwnd is only used for Pif file options see cmdpif.
    //
    // If no editwnd then we can use the systems harderror thread
    // which is safe to do without a secondary thread.
    //


    if (dwOptions & RMB_EDIT) {
       dw = 5;
       do {
          hThread = CreateThread(NULL,           // security
                       0,                     // stack size
                       ErrorDialogBoxThread,  // start address
                       &edgi,                 // thread argument
                       0,                     // flags
                       &dwThreadID            // gets thread ID
                       );
          if (hThread)
             break;
          else
             Sleep(5000);

          } while (dw--);
       }
    if (hThread)  {
        do {
            dw = WaitForSingleObject(hThread, 1000);
           } while (dw == WAIT_TIMEOUT && !edgi.dwReply);
        CloseHandle(hThread);
        }
    else {
        ErrorDialogBoxThread(&edgi);
        }

    ResumeTimerThread();

    if (edgi.dwReply == RMB_ABORT) {
        //
        // if current thread is a wow task, then invoke wow32 to kill it.
        //

        if (VDMForWOW &&  NtCurrentTeb()->WOW32Reserved && pW32HungAppNotifyThread)  {
            (*pW32HungAppNotifyThread)(0);
            }
        else {
            TerminateVDM();
            }
        }

    bCalled--;
    if (!VDMForWOW) {
        if (CurrentMonitorTeb != NtCurrentTeb()) {
            DisableScreenSwitch(hConsoleSuspended);
        } else {
            DisableScreenSwitch(hMainThreadSuspended);
        }
    }
    return (int) edgi.dwReply;
}





/*  ErrorDialogBoxThread
 *
 *  Worker routine for ErrorDialogBox.  In WOW VDMs this function is
 *  run as its own thread.  For other VDMs it is called directly.
 *
 *  WOW: If the user chooses terminate, it will not return.
 *
 *  exit: fills in pedgi.dwReply with ret code from DialogBoxParam
 *        IDB_QUIT, IDB_CONTINUE
 */
DWORD ErrorDialogBoxThread(VOID *pv)
{
    int    i;
    ERRORDIALOGINFO *pedgi = pv;
    char *pch;
    char *pLast;
#ifdef DBCS
    static char *pTemplate  = "ERRORPANEL";
    static char *pTemplate2 = "ERRORPANEL2";
    LANGID LangID;
#endif // DBCS


#ifndef DBCS // kksuzuka:#4003 don't need isgraph check
        // skip leading white space
    pch = pedgi->Title;
    while (*pch && !isgraph(*pch)) {
        pch++;
        }

        // move string to beg of buffer, strip trailing white space
    i = 0;
    pLast = pedgi->Title;
    while (*pch) {
       pedgi->Title[i++] = *pch;
       if (isgraph(*pch)) {
           pLast = &pedgi->Title[i];
           }
       pch++;
       }
   *pLast = '\0';
#endif // !DBCS


    if (pedgi->dwOptions & RMB_EDIT) {
        if (pedgi->hWndCon != HWND_DESKTOP) {
            SetForegroundWindow(pedgi->hWndCon);
            }

#ifdef DBCS
        LangID = GetSystemDefaultLangID();
        // KKFIX 10/19/96
        if ((BYTE)LangID == 0x04) {  // Chinese
            pTemplate = pTemplate2;
        }
#endif // DBCS
        i = DialogBoxParam(GetModuleHandle(NULL),
#ifdef DBCS
                           (LPCTSTR)pTemplate,
#else // !DBCS
                           "ERRORPANEL",
#endif // !DBCS
                           GetDesktopWindow(),
                           ErrorDialogEvents,
                           (LPARAM) pedgi
                           );
        }
    else {
        i = WowErrorDialogEvents(pedgi);
        }

    if (i == -1) {
        pedgi->dwReply = RMB_ABORT;
        }
    else {
        pedgi->dwReply = i;
        }

   return 0;
}





BOOL CALLBACK ErrorDialogEvents(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    ERRORDIALOGINFO *pedgi;
    CHAR  szBuff[MAX_PATH];
    CHAR  FormatStr[EHS_MSG_LEN];
    int i;
    LPSTR  lpstr;
    LONG  l;

    /*:::::::::::::::::::::::::::::::::::::::::::::::::::: Process messages */
    switch(wMsg)
    {
        /*:::::::::::::::::::::::::::::::::::::: Initialise Dialog controls */
        case WM_INITDIALOG:
             pedgi = (PERRORDIALOGINFO) lParam;

             // set the desired icon
            switch (pedgi->dwOptions & (RMB_ICON_INFO | RMB_ICON_BANG |
                                        RMB_ICON_STOP | RMB_ICON_WHAT))
              {
               case RMB_ICON_STOP: lpstr = NULL;            break;
               case RMB_ICON_INFO: lpstr = IDI_ASTERISK;    break;
               case RMB_ICON_BANG: lpstr = IDI_EXCLAMATION; break;
               case RMB_ICON_WHAT: lpstr = IDI_QUESTION;    break;
               default:            lpstr = IDI_APPLICATION; break;
               }
            if (lpstr)  { // default is STOP sign
               SendDlgItemMessage(hDlg, IDE_ICON, STM_SETICON,
                                  (WPARAM)LoadIcon(NULL,lpstr), 0);
               }

            SwpButtons(hDlg, pedgi->dwOptions);

               // set Edit control message if we have one
            if (pedgi->dwOptions & RMB_EDIT)  {
                SetWindowText(GetDlgItem(hDlg,IDE_EDIT), pedgi->pEdit);
                if (*pedgi->pEdit) {
                    SendDlgItemMessage(hDlg, IDE_EDIT,
                                       EM_SETSEL,
                                       (WPARAM)0,
                                       (LPARAM)strlen(pedgi->pEdit));
                    }
                 SendDlgItemMessage(hDlg, IDE_EDIT,
                                    EM_LIMITTEXT,
                                    (WPARAM)HIWORD(pedgi->dwOptions),
                                    (LPARAM)0);
                }
            else {
                ShowWindow(GetDlgItem(hDlg,IDE_EDIT), SW_HIDE);
                }

                // set err message text
            SetWindowText(GetDlgItem(hDlg,IDE_ERRORMSG), pedgi->message);

                // set app title text
            if (*pedgi->Title) {

                if (!LoadString(GetModuleHandle(NULL),
                               strlen(pedgi->Title) < 80 ? ED_FORMATSTR1:ED_FORMATSTR2,
                               FormatStr,
                               sizeof(FormatStr)/sizeof(CHAR))) {
                   strcpy(FormatStr, "%s");
                   }

                sprintf(szBuff,
                        FormatStr,
                        pedgi->Title
                        );

                SetWindowText(GetDlgItem(hDlg,IDE_APPTITLE), szBuff);
                }

            SwpDosDialogs(hDlg, pedgi->hWndCon, HWND_TOPMOST, 0);

            SetWindowLong(hDlg, DWL_USER, (LONG)pedgi);

            break;


        /*:::::::::::::::::::::::::::::::: Trap and process button messages */
        case WM_COMMAND:
            pedgi = (PERRORDIALOGINFO)GetWindowLong(hDlg,DWL_USER);
            i = (int) LOWORD(wParam);
            switch (i) {
                 case IDB_QUIT:
                      if (pedgi->pEdit) {
                          *pedgi->pEdit = '\0';
                          }
                      EndDialog(hDlg,RMB_ABORT);
                      break;

                 case IDB_RETRY:
                      if (pedgi->pEdit) {
                          *pedgi->pEdit = '\0';
                          }
                      EndDialog(hDlg,RMB_RETRY);
                      break;

                 case IDCANCEL:
                 case IDB_CONTINUE:
                      if (pedgi->pEdit) {
                          *pedgi->pEdit = '\0';
                          }
                      EndDialog(hDlg,RMB_IGNORE);
                      break;

                 case IDB_OKEDIT:
                      if (pedgi->pEdit) {
                          l = SendDlgItemMessage(hDlg, IDE_EDIT,
                                            WM_GETTEXT,
                                            (WPARAM)HIWORD(pedgi->dwOptions),
                                            (LPARAM)pedgi->pEdit);
                          if (!l)
                             *(pedgi->pEdit) = '\0';
                          }
                      EndDialog(hDlg, RMB_EDIT);
                      break;

                 default:
                     return(FALSE);
                 }
        /*:::::::::::::::::::::::::::::::::::::::::: Not processing message */
        default:
            return(FALSE);      /* Message not processed */
    }
   return TRUE;
}



/*
 *  SwpButtons - SetWindowPos\showstate for the vraious buttons
 *
 *  entry: HWND  hDlg,        - DialogBox window handle
 *         DWORD dwOptions
 *
 */
void SwpButtons(HWND hDlg, DWORD dwOptions)
{
     RECT  rect;
     POINT point;
     long  DlgWidth, ButWidth, xOrg, xIncr, yClientPos;
     WORD  wButtons;

      // count number of buttons being shown
     wButtons = 0;
     if (dwOptions & RMB_ABORT) {
         wButtons++;
         }
     if (dwOptions & RMB_RETRY)  {
         wButtons++;
         }
     if (dwOptions & RMB_IGNORE) {
         wButtons++;
         }
     if (dwOptions & RMB_EDIT)  {
         wButtons++;
         }

      // figure out where first button goes,
      // and how much space between buttons

     GetWindowRect(GetDlgItem(hDlg,IDB_QUIT), &rect);
     point.x = rect.left;
     point.y = rect.top;
     ScreenToClient(hDlg, &point);
     DlgWidth = point.x;
     GetWindowRect(GetDlgItem(hDlg,IDB_OKEDIT), &rect);
     point.x = rect.right;
     point.y = rect.top;
     ScreenToClient(hDlg, &point);
     DlgWidth = point.x - DlgWidth;
     yClientPos = point.y;

     ButWidth = rect.right - rect.left;
     xIncr = ButWidth + ButWidth/2;

     if (wButtons & 1) {  // odd number of buttons
         xOrg = (DlgWidth - ButWidth)/2;
         if (wButtons > 1)
             xOrg -= xIncr;
         }
     else {               // even number of buttons
         xOrg = DlgWidth/2 - (ButWidth + ButWidth/4);
         if (wButtons == 4)
             xOrg -= xIncr;
         }


      // set each of the buttons in their correct place


     if (dwOptions & RMB_ABORT) {
         SetWindowPos(GetDlgItem(hDlg,IDB_QUIT), 0,
                      xOrg, yClientPos, 0,0,
                      SWP_NOSIZE | SWP_NOZORDER);
         xOrg += xIncr;
         }
     else {
         ShowWindow(GetDlgItem(hDlg,IDB_QUIT), SW_HIDE);
         }

     if (dwOptions & RMB_RETRY)  {
         SetWindowPos(GetDlgItem(hDlg,IDB_RETRY), 0,
                      xOrg, yClientPos, 0,0,
                      SWP_NOSIZE | SWP_NOZORDER);
         xOrg += xIncr;
         }
     else {
         ShowWindow(GetDlgItem(hDlg,IDB_RETRY), SW_HIDE);
         }

     if (dwOptions & RMB_IGNORE) {
         SetWindowPos(GetDlgItem(hDlg,IDB_CONTINUE), 0,
                      xOrg, yClientPos, 0,0,
                      SWP_NOSIZE | SWP_NOZORDER);
         xOrg += xIncr;
         }
     else {
         ShowWindow(GetDlgItem(hDlg,IDB_CONTINUE), SW_HIDE);
         }

     if (dwOptions & RMB_EDIT)  {
         SetWindowPos(GetDlgItem(hDlg,IDB_OKEDIT), 0,
                      xOrg, yClientPos, 0,0,
                      SWP_NOSIZE | SWP_NOZORDER);
         xOrg += xIncr;
         // if we have edit control, its button is awlays
         // the default button
         SendMessage(hDlg, DM_SETDEFID,
                     (WPARAM)IDB_OKEDIT,
                     (LPARAM)0);
         }
     else {
         ShowWindow(GetDlgItem(hDlg,IDB_OKEDIT), SW_HIDE);
         }
}


/*
 *  SwpDosDialogs - SetWindowPos for Dos Dialogs
 *
 *  used by Dos dialog procedures to position themselves
 *  relative to the current Dos session
 *
 *  entry: HWND hDlg,            - DialogBox window handle
 *         HWND hWndCon,         - Window handle for dos session
 *         HWND SwpInsert,       - SetWindowPos's placement order handle
 *         UINT SwpFlags         - SetWindowPos's window positioning flags
 */
void SwpDosDialogs(HWND hDlg, HWND hWndCon,
                   HWND SwpInsert, UINT SwpFlags)
{
    RECT  rDeskTop, rDosSess;
    long  DlgWidth,DlgHeight;

    GetWindowRect(GetDesktopWindow(), &rDeskTop);
    GetWindowRect(hDlg, &rDosSess);
    DlgWidth  = rDosSess.right - rDosSess.left;
    DlgHeight = rDosSess.bottom - rDosSess.top;


        // center the dialog, if no hWnd for console
    if (hWndCon == HWND_DESKTOP) {
        rDosSess.left  = (rDeskTop.right - DlgWidth)/2;
        rDosSess.top   = (rDeskTop.bottom  - DlgHeight)/2;
        }
        // pos relative to console window, staying on screen
    else {
        GetWindowRect(hWndCon, &rDosSess);
        rDosSess.left += (rDosSess.right - rDosSess.left - DlgWidth)/3;
        if (rDosSess.left + DlgWidth > rDeskTop.right) {
            rDosSess.left = rDeskTop.right - DlgWidth - GetSystemMetrics(SM_CXICONSPACING)/2;
            }
        if (rDosSess.left < rDeskTop.left) {
            rDosSess.left = rDeskTop.left + GetSystemMetrics(SM_CXICONSPACING)/2;
            }

        rDosSess.top += DlgHeight/4;
        if (rDosSess.top + DlgHeight > rDeskTop.bottom) {
            rDosSess.top = rDeskTop.bottom - DlgHeight - GetSystemMetrics(SM_CYICONSPACING)/2;
            }
        if (rDosSess.top < rDeskTop.top) {
            rDosSess.top = rDeskTop.top + GetSystemMetrics(SM_CYICONSPACING)/2;
            }
        }

     SetWindowPos(hDlg, SwpInsert,
                  rDosSess.left, rDosSess.top,0,0,
                  SWP_NOSIZE | SwpFlags);
}



/*
 *  WowErrorDialogEvents
 *
 *  Uses WOWpSysErrorBox, to safely create a message box on WOW
 *  Replaces the functionality of the User mode DialogBox
 *  "ErrorDialogEvents"
 */
int WowErrorDialogEvents(ERRORDIALOGINFO *pedgi)
{
   CHAR  szTitle[MAX_PATH];
   CHAR  szMsg[EHS_MSG_LEN];
   CHAR  FormatStr[EHS_MSG_LEN]="%s\n";
   USHORT wButt1, wButt2, wButt3;

   if (*pedgi->Title) {
       LoadString(GetModuleHandle(NULL), ED_FORMATSTR3,
                   FormatStr, sizeof(FormatStr)/sizeof(CHAR));
       sprintf(szMsg, FormatStr, pedgi->Title);
       }
   else {
       szMsg[0] = '\0';
       }

   strcat(szMsg, pedgi->message);
   if (pedgi->dwOptions & RMB_ABORT) { // abort means terminate which uses "close" button.
      strcat(szMsg, " ");

      if (!LoadString(GetModuleHandle(NULL), ED_WOWPROMPT,
                  szTitle, sizeof(szTitle) - 1))
         {
          szTitle[0] = '\0';
          }
      strcat(szMsg, szTitle);
      }
   if (!LoadString(GetModuleHandle(NULL),
                   VDMForWOW ? ED_WOWTITLE : ED_DOSTITLE,
                   szTitle,
                   sizeof(szTitle) - 1
                   ))

       {
        szTitle[0] = '\0';
        }

   wButt1 = pedgi->dwOptions & RMB_ABORT ? SEB_CLOSE : 0;
   wButt2 = pedgi->dwOptions & RMB_RETRY ? SEB_RETRY : 0;
   wButt3 = pedgi->dwOptions & RMB_IGNORE ? SEB_IGNORE : 0;

   if (wButt1) {
       wButt1 |= SEB_DEFBUTTON;
       }
   else if (wButt2) {
       wButt1 |= SEB_DEFBUTTON;
       }
   else if (wButt3) {
       wButt2 |= SEB_DEFBUTTON;
       }

   switch (WOWpSysErrorBox(szTitle,
                          szMsg,
                          wButt1,
                          wButt2,
                          wButt3) )
      {
       case 1:
          return RMB_ABORT;
       case 2:
          return RMB_RETRY;
       case 3:
          return RMB_IGNORE;
       }
  return RMB_ABORT;
}


/*
 * The next values should be in the same order
 * with the ones in IDOK and STR_OK lists
 */
#define  SEB_USER_OK         0  /* Button with "OK".     */
#define  SEB_USER_CANCEL     1  /* Button with "Cancel"  */
#define  SEB_USER_ABORT      2  /* Button with "&Abort"   */
#define  SEB_USER_RETRY      3  /* Button with "&Retry"   */
#define  SEB_USER_IGNORE     4  /* Button with "&Ignore"  */
#define  SEB_USER_YES        5  /* Button with "&Yes"     */
#define  SEB_USER_NO         6  /* Button with "&No"      */
#define  SEB_USER_CLOSE      7  /* Button with "&Close"   */

static USHORT rgsTranslateButton[] =
{  SEB_USER_OK,
   SEB_USER_CANCEL,
   SEB_USER_YES,
   SEB_USER_NO,
   SEB_USER_ABORT,
   SEB_USER_RETRY,
   SEB_USER_IGNORE,
   SEB_USER_CLOSE
};

#define SEB_XBTN(wBtn) \
((0 == (wBtn)) || ((wBtn) > sizeof(rgsTranslateButton)/sizeof(rgsTranslateButton[0])) ? \
(wBtn) : \
(rgsTranslateButton[(wBtn)-1]+1))

#define SEB_TRANSLATE(wBtn) \
((wBtn) & SEB_DEFBUTTON ? SEB_XBTN((wBtn) & ~SEB_DEFBUTTON) | SEB_DEFBUTTON  : \
SEB_XBTN(wBtn))

/*++
 *  WOWpSysErrorBox
 *
 *  32-bit Implementation of of SysErrorBox, which doesn't exist in Win32
 *  This is the only safe way to raise a message box for WOW, and is also
 *  safe to use for dos apps.
 *
 *  History:
 *  23-Mar-93 DaveHart Created
--*/
ULONG WOWpSysErrorBox(
    LPSTR  szTitle,
    LPSTR  szMessage,
    USHORT wBtn1,
    USHORT wBtn2,
    USHORT wBtn3)
{
    NTSTATUS Status;
    ULONG dwParameters[MAXIMUM_HARDERROR_PARAMETERS];
    ULONG dwResponse;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeTitle;
    UNICODE_STRING UnicodeMessage;
    char szDesktop[10];   // only needs to be big enough for "Default"
    DWORD dwUnused;

    RtlInitAnsiString(&AnsiString, szTitle);
    RtlAnsiStringToUnicodeString(&UnicodeTitle, &AnsiString, TRUE);

    RtlInitAnsiString(&AnsiString, szMessage);
    RtlAnsiStringToUnicodeString(&UnicodeMessage, &AnsiString, TRUE);

    dwParameters[0] = ((ULONG)TRUE << 16) | (ULONG) SEB_TRANSLATE(wBtn1);
    dwParameters[1] = ((ULONG)SEB_TRANSLATE(wBtn2) << 16) | (ULONG) SEB_TRANSLATE(wBtn3);
    dwParameters[2] = (ULONG)&UnicodeTitle;
    dwParameters[3] = (ULONG)&UnicodeMessage;

    ASSERT(4 < MAXIMUM_HARDERROR_PARAMETERS);

    if (GetUserObjectInformation(
            GetThreadDesktop( GetCurrentThreadId() ),
            UOI_NAME,
            szDesktop,
            sizeof(szDesktop),
            &dwUnused
            ) &&
        RtlEqualMemory(szDesktop, "Default", 8)) {

        dwParameters[HARDERROR_PARAMETERS_FLAGSPOS] = HARDERROR_FLAGS_DEFDESKTOPONLY;
    } else {
        dwParameters[HARDERROR_PARAMETERS_FLAGSPOS] = 0;
    }

    //
    // OR in 0x10000000 to force the hard error through even if
    // SetErrorMode has been called.
    //

    Status = NtRaiseHardError(
        STATUS_VDM_HARD_ERROR | 0x10000000,
        MAXIMUM_HARDERROR_PARAMETERS,
        1 << 2 | 1 << 3,
        dwParameters,
        0,
        &dwResponse
        );

    RtlFreeUnicodeString(&UnicodeTitle);
    RtlFreeUnicodeString(&UnicodeMessage);

    return NT_SUCCESS(Status) ? dwResponse : 0;
}

/*
 *  Exported routine for wow32 to invoke a system error box
 *  Uses WowpSysErrorBox
 */

ULONG WOWSysErrorBox(
    LPSTR  szTitle,
    LPSTR  szMessage,
    USHORT wBtn1,
    USHORT wBtn2,
    USHORT wBtn3)
{
   ULONG ulRet;

   SuspendTimerThread();

   ulRet = WOWpSysErrorBox(szTitle,
                           szMessage,
                           wBtn1,
                           wBtn2,
                           wBtn3);

   ResumeTimerThread();

   return ulRet;
}









#ifndef PROD
/*
 *  HostDebugBreak
 *
 *  Raises a breakpoint by creating an access violation
 *  to give us a chance to get into a user mode debugger
 *
 */
void HostDebugBreak(void)
{
  DbgBreakPoint();
}
#endif

VOID RcErrorBoxPrintf(UINT wId, CHAR *szMsg)
{
    CHAR message[EHS_MSG_LEN];
    CHAR acctype[EHS_MSG_LEN];
    CHAR dames[EHS_MSG_LEN];


    OemMessageToAnsiMessage(acctype, szMsg);

    if (LoadString(GetModuleHandle(NULL),wId,
                    dames, sizeof(dames)/sizeof(CHAR)))
       {
        _snprintf(message,EHS_MSG_LEN, dames, acctype);
        message[EHS_MSG_LEN-1] = '\0';
        }
    else  {
        strcpy(message, szDoomMsg);
        }

    ErrorDialogBox(message, NULL, RMB_ICON_STOP | RMB_ABORT | RMB_IGNORE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_fdisk.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"

/*
 * [ Product:        SoftPC-AT Revision 3.0
 *
 * Name:           nt_fdisk.c
 *
 * Derived From:   unix_fdisk.c (Andrew Guthrie/Ade Brownlow)
 *
 * Authors:        Jerry Sexton
 *
 * Created On:     7th August 1991
 *
 * Purpose:        This module handles the host side of opening, closing,
 *                 verfiying and locking hard disks.
 *
 * (c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 *
 * ] */

#include <stdio.h>
#include <stdlib.h>
#include <sys\types.h>
#include "xt.h"
#include "config.h"
#include "trace.h"
#include "error.h"
#include "nt_uis.h"
#include "nt_reset.h"
#include "nt_fdisk.h"

/********************************************************/
/*
 * Maximum disk size is 32 Megabytes for DOS. Our disk geometry is based upon
 * a variable number of cylinders (as per user request when creating a virgin
 * hard disk) with bytes per sector, sectors per track and heads per drive
 * fixed as per above. Since a real disk always contains an integral number
 * of cylinders and since we allow the user to specify disk size at a
 * granularity of 1 Megabyte, this means we allocate disk space in terms of
 * an integral number of 30 cylinders (30,60, ...). (30 cylinders is
 * approximately 1 Megabyte). One disk allocation unit = 30 cylinders. The
 * max.number of allocation units is 32. For the AT, it is possible to have
 * larger disks (e.g up to 1024 cylinders and 16 heads). For compatability
 * with SoftPC Rev.1, we still use Rev.1 limitations on disk geometry
 */
#define ONEMEG                                  1024 * 1024
#define HD_MAX_DISKALLOCUN                      32
#define HD_SECTORS_PER_TRACK                    17
#define HD_HEADS_PER_DRIVE                      4
#define HD_BYTES_PER_SECTOR                     512
#define HD_SECTORS_PER_CYL (HD_HEADS_PER_DRIVE * HD_SECTORS_PER_TRACK)
#define HD_BYTES_PER_CYL   (HD_BYTES_PER_SECTOR * HD_SECTORS_PER_CYL)
#define HD_DISKALLOCUNSIZE (HD_BYTES_PER_CYL * 30)
#define MIN_PARSIZE (HD_SECTORS_PER_TRACK * HD_HEADS_PER_DRIVE * 30)
#define MAX_PARSIZE (MIN_PARSIZE * HD_MAX_DISKALLOCUN)
#define SECTORS 0x0c            /* offset in buffer for sectors in partition
                                 * marker */
#define MAX_PARTITIONS  5
#define START_PARTITION 0x1be
#define SIZE_PARTITION  16
#define SIGNATURE_LEN   2


/*
 * drive information ... indication of whether file is open; the file
 * descriptor, and the current file pointer value
 */
typedef struct
{
        int   fd;
        int   valid_fd;
        int   curoffset;
        SHORT n_cyl;
        SHORT valid_n_cyl;
        UTINY n_heads;
        UTINY valid_n_heads;
        int   n_sect;
        int   valid_n_sect;
        BOOL  open;
        BOOL  valid_open;
        BOOL  readonly;
        BOOL  valid_readonly;
} DrvInfo;

LOCAL DrvInfo fdiskAdapt[2];

// fail nicely if this is set - should only need to be used for initialisation
// support. Set in config dependant on CONT_FILE environment var
//
LOCAL BOOL DiskValid = FALSE;

GLOBAL VOID host_using_fdisk(BOOL status)
{
    DiskValid = status;
}

GLOBAL SHORT
host_fdisk_valid
        (UTINY hostID, ConfigValues *vals, NameTable *table, CHAR *errStr)
{
        DrvInfo *adaptP;

        adaptP = fdiskAdapt + (hostID - C_HARD_DISK1_NAME);

        adaptP->n_cyl = (SHORT) 30;
        adaptP->n_heads = 4;
        adaptP->n_sect = 17;
        return C_CONFIG_OP_OK;

}

GLOBAL VOID
host_fdisk_change(UTINY hostID, BOOL apply)
{
    return;     // don't bother if no disk.
}

GLOBAL SHORT
host_fdisk_active(UTINY hostID, BOOL active, CHAR *errString)
{
    return C_CONFIG_OP_OK;        // just say it's there...
}

GLOBAL VOID
host_fdisk_term(VOID)
{
        host_fdisk_change(C_HARD_DISK1_NAME, FALSE);
        host_fdisk_change(C_HARD_DISK2_NAME, FALSE);
}

GLOBAL VOID
host_fdisk_get_params(int driveid, int *n_cyl, int *n_heads, int *n_sect)
{
        DrvInfo *adaptP = &fdiskAdapt[driveid];

        *n_cyl = adaptP->n_cyl;
        *n_heads = adaptP->n_heads;
        *n_sect = adaptP->n_sect;
}

GLOBAL VOID
host_fdisk_seek0(driveid)
int             driveid;
{

    return;             // don't bother if no disk.
}

/********************************************************/
/*
 * Read and write routines (called from diskbios.c & fdisk.c
 */
int
host_fdisk_rd(int driveid, int offset, int nsecs, char *buf)
{
    return(0);          // no disk...no data
}

int
host_fdisk_wt(int driveid, int offset, int nsecs, char *buf)
{
    return(0);          // no disk...no data
}

// FDISK support


#pragma pack(1)

#define  MAX_FDISK_NAME     9
typedef struct _FDISKDATA {
    BYTE            drive;
    BYTE            idle_counter;
    CHAR            drive_letter;
    BOOLEAN         auto_locked;
    HANDLE          fdisk_fd;
    DWORD           num_heads;
    LARGE_INTEGER   num_cylinders;
    DWORD           sectors_per_track;
    DWORD           bytes_per_sector;
    DWORD           align_factor;
    USHORT          owner_pdb;
    CHAR            device_name[MAX_FDISK_NAME];
#if defined(NEC_98)
    BYTE            partition_type; //  FS type
#endif // NEC_98
}   FDISKDATA, *PFDISKDATA;


// Bios Parameter Block  (BPB)
// copied from DEMDASD.H
typedef struct  A_BPB {
WORD        SectorSize;                 // sector size in bytes
BYTE        ClusterSize;                // cluster size in sectors
WORD        ReservedSectors;            // number of reserved sectors
BYTE        FATs;                       // number of FATs
WORD        RootDirs;                   // number of root directory entries
WORD        Sectors;                    // number of sectors
BYTE        MediaID;                    // media descriptor
WORD        FATSize;                    // FAT size in sectors
WORD        TrackSize;                  // track size in sectors;
WORD        Heads;                      // number of heads
DWORD       HiddenSectors;              // number of hidden sectors
DWORD       BigSectors;                 // number of sectors for big media
} BPB, *PBPB;

typedef struct  _BOOTSECTOR {
    BYTE    Jump;
    BYTE    Target[2];
    BYTE    OemName[8];
    BPB     bpb;
} BOOTSECTOR, * PBOOTSECTOR;

#pragma pack()



// this is the cylinder size of a 2.88  diskette
#define     MAX_DISKIO_SIZE     0x9000
#define     FDISK_IDLE_PERIOD   30
PFDISKDATA  fdisk_data_table = NULL;
BYTE        number_of_fdisk = 0;
DWORD       max_align_factor = 0;
DWORD       disk_buffer_pool = 0;
DWORD       cur_align_factor;
WORD        fdisk_open_count = 0;

WORD        * pFDAccess = 0;

extern      USHORT * pusCurrentPDB;

extern      int     DiskOpenRetry(CHAR);


BOOL nt_fdisk_init(
    BYTE    drive,
    PBPB    bpb,
    PDISK_GEOMETRY disk_geometry
);



BOOL nt_fdisk_close(BYTE drive);

PFDISKDATA get_fdisk_data(
    BYTE drive
);

BOOL get_fdisk_handle(
    PFDISKDATA  fdisk_data,
    USHORT      pdb,
    BOOL        auto_lock
);


VOID FdiskTerminatePDB(USHORT PDB);
VOID HostFdiskReset(VOID);

BOOL close_fdisk(
    PFDISKDATA fdisk_data
);


BOOL nt_fdisk_init(BYTE drive, PBPB bpb, PDISK_GEOMETRY disk_geometry)
{
    PFDISKDATA  fdisk_data;
    PUNICODE_STRING unicode_string;
    ANSI_STRING ansi_string;
    NTSTATUS status;
    OBJECT_ATTRIBUTES   fdisk_obj;
    IO_STATUS_BLOCK io_status_block;
    FSCTL_QUERY_FAT_BPB_BUFFER boot_sector_first_0x24_bytes;
    HANDLE  fd;
    FILE_ALIGNMENT_INFORMATION align_info;
    CHAR   dos_device_name[] = "\\\\.\\?:";
    CHAR nt_device_name[] = "\\DosDevices\\?:";

    nt_device_name[12] =
    dos_device_name[4] = drive + 'A';
    RtlInitAnsiString( &ansi_string, nt_device_name);

    unicode_string =  &NtCurrentTeb()->StaticUnicodeString;

    status = RtlAnsiStringToUnicodeString(unicode_string,
                                          &ansi_string,
                                          FALSE
                                          );
    if ( !NT_SUCCESS(status) )
        return FALSE;


    InitializeObjectAttributes(
                               &fdisk_obj,
                               unicode_string,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    status = NtOpenFile(
                        &fd,
                        FILE_READ_ATTRIBUTES | SYNCHRONIZE | FILE_READ_DATA,
                        &fdisk_obj,
                        &io_status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    if (!NT_SUCCESS(status))
        return FALSE;

    // get geomerty information, the caller wants this
    status = NtDeviceIoControlFile(fd,
                                   0,
                                   NULL,
                                   NULL,
                                   &io_status_block,
                                   IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                   NULL,
                                   0,
                                   disk_geometry,
                                   sizeof (DISK_GEOMETRY)
                                   );
    if (!NT_SUCCESS(status)) {
        NtClose(fd);
        return FALSE;
    }
    // get alignment factor
    status = NtQueryInformationFile(fd,
                                    &io_status_block,
                                    &align_info,
                                    sizeof(FILE_ALIGNMENT_INFORMATION),
                                    FileAlignmentInformation
                                    );

    if (!NT_SUCCESS(status)) {
        NtClose(fd);
        return(FALSE);
    }
    if (align_info.AlignmentRequirement > max_align_factor)
        max_align_factor = align_info.AlignmentRequirement;


#if defined(NEC_98)
        {
        DWORD Sectors;
        DWORD SectorSize, ClusterSize, TotalClusters, FreeClusters;
        DWORD TrackSize;
        CHAR chRoot[]="?:\\";

        chRoot[0] = drive + 'A';
        if (!GetDiskFreeSpace(chRoot,
                              &SectorSize,
                              &ClusterSize,
                              &TotalClusters,
                              &FreeClusters))
        {
                NtClose(fd);
                return FALSE;
        }
        Sectors = disk_geometry->Cylinders.LowPart *
                  disk_geometry->TracksPerCylinder *
                  disk_geometry->SectorsPerTrack;
        bpb->SectorSize = (WORD)SectorSize;
        bpb->ClusterSize = (BYTE) ClusterSize;
        bpb->ReservedSectors = 1;
        bpb->FATs = 2;
        bpb->RootDirs = (Sectors > 32680) ? 512 : 64;
        bpb->MediaID = 0xF8;
        bpb->TrackSize = (WORD) disk_geometry->SectorsPerTrack;
        bpb->Heads = (WORD) disk_geometry->TracksPerCylinder;
        if (Sectors >= 40000)
        {
                TrackSize = 256 * ClusterSize + 2;
                bpb->FATSize = (WORD) ((Sectors - bpb->ReservedSectors
                                          - bpb->RootDirs * 32 / 512 +
                                          TrackSize - 1 ) / TrackSize);
        }
        else
        {
                bpb->FATSize = (WORD) (((Sectors / ClusterSize) * 3 / 2) /
                                       512 + 1);
        }
        bpb->HiddenSectors = Sectors;
        Sectors = TotalClusters * ClusterSize;
        if (Sectors >= 0x10000) {
                bpb->Sectors = 0;
                bpb->BigSectors = Sectors;
        }
        else
        {
                bpb->Sectors = (WORD) Sectors;
                bpb->BigSectors = 0;
        }
        bpb->HiddenSectors -= Sectors;
}
#else  // !NEC_98

    /* get BPB, it will fail if the drive is not a FAT partition */
    status = NtFsControlFile(fd,
                             0,
                             NULL,
                             NULL,
                             &io_status_block,
                             FSCTL_QUERY_FAT_BPB,
                             NULL,
                             0,
                             &boot_sector_first_0x24_bytes,
                             sizeof(boot_sector_first_0x24_bytes)
                             );
    if (!NT_SUCCESS(status)) {
        NtClose(fd);
        return (FALSE);
    }

    *bpb = ((PBOOTSECTOR)&boot_sector_first_0x24_bytes)->bpb;
#endif // !NEC_98


    // enlarge the table
    fdisk_data = (PFDISKDATA) realloc(fdisk_data_table,
                                      (number_of_fdisk + 1) * sizeof(FDISKDATA)
                                      );
    if(fdisk_data == NULL) {
        NtClose(fd);
        return FALSE;
    }
    fdisk_data_table = fdisk_data;
    fdisk_data += number_of_fdisk;
    fdisk_data->drive_letter = drive + 'A';
    fdisk_data->drive = number_of_fdisk;
    fdisk_data->fdisk_fd = INVALID_HANDLE_VALUE;
    fdisk_data->num_heads = disk_geometry->TracksPerCylinder;
    fdisk_data->sectors_per_track = disk_geometry->SectorsPerTrack;
    fdisk_data->bytes_per_sector = disk_geometry->BytesPerSector;
    fdisk_data->num_cylinders = disk_geometry->Cylinders;
    fdisk_data->align_factor = align_info.AlignmentRequirement;
    strcpy(fdisk_data->device_name, dos_device_name);
    number_of_fdisk++;
    NtClose(fd);
    return TRUE;
}


ULONG nt_fdisk_read(
    BYTE    drive,
    PLARGE_INTEGER offset,
    ULONG   size,
    PBYTE   buffer
)
{
    PFDISKDATA fdisk_data;
    ULONG   size_returned = 0;

    if ((fdisk_data = get_fdisk_data(drive)) == NULL)
        return 0;
#if defined(NEC_98)
    if( fdisk_data->partition_type == PARTITION_IFS )
        return 0;
#endif // NEC_98
    if (get_fdisk_handle(fdisk_data, *pusCurrentPDB, FALSE)) {
        return(disk_read(fdisk_data->fdisk_fd,
                         offset,
                         size,
                         buffer));
    } else {
        return FALSE;
    }
}



ULONG nt_fdisk_write(
    BYTE    drive,
    PLARGE_INTEGER offset,
    ULONG   size,
    PBYTE   buffer
)
{
    PFDISKDATA fdisk_data;
    ULONG   size_returned = 0;

    if ((fdisk_data = get_fdisk_data(drive)) == NULL)
        return 0;
#if defined(NEC_98)
    if( fdisk_data->partition_type == PARTITION_IFS )
        return 0;
#endif // NEC_98

    if (get_fdisk_handle(fdisk_data, *pusCurrentPDB, TRUE)) {
        // must lock the drive. This is very important.
        size_returned = disk_write(fdisk_data->fdisk_fd,
                                   offset,
                                   size,
                                   buffer);
    }
    return size_returned;
}


BOOL nt_fdisk_verify(
    BYTE            drive,
    PLARGE_INTEGER   offset,
    ULONG           size
)
{

    PFDISKDATA fdisk_data;
    ULONG   size_returned = 0;
    VERIFY_INFORMATION verify_info;

    if ((fdisk_data = get_fdisk_data(drive)) == NULL)
        return FALSE;

    if (get_fdisk_handle(fdisk_data, *pusCurrentPDB, FALSE)) {
        verify_info.StartingOffset = *offset;
        verify_info.Length = size;
        return(DeviceIoControl(fdisk_data->fdisk_fd,
                               IOCTL_DISK_VERIFY,
                               &verify_info,
                               sizeof(VERIFY_INFORMATION),
                               NULL,
                               0,
                               &size_returned,
                               NULL
                               ));
    }
    return(FALSE);
}



BOOL nt_fdisk_close(BYTE drive)
{
    PFDISKDATA  fdisk_data;
    if ((fdisk_data = get_fdisk_data(drive)) == NULL)
        return FALSE;
    return(close_fdisk(fdisk_data));
}


BOOL close_fdisk(PFDISKDATA fdisk_data)
{

    if (fdisk_data->fdisk_fd != INVALID_HANDLE_VALUE){
        CloseHandle(fdisk_data->fdisk_fd);
        fdisk_data->auto_locked = FALSE;
        fdisk_data->fdisk_fd = INVALID_HANDLE_VALUE;
        fdisk_data->owner_pdb = 0;
        (*(pFDAccess))--;
        fdisk_open_count--;
    }
    return TRUE;
}



PFDISKDATA get_fdisk_data(BYTE drive)
{

    WORD i;

    for (i = 0; i < number_of_fdisk; i++)
        if (fdisk_data_table[i].drive == drive)
            return &fdisk_data_table[i];
    return NULL;
}


BOOL get_fdisk_handle(PFDISKDATA fdisk_data, USHORT pdb, BOOL auto_lock)
{

    DWORD   share_access;
    DWORD   last_error;



    if (fdisk_data->fdisk_fd != INVALID_HANDLE_VALUE &&
        ((auto_lock && !fdisk_data->auto_locked) || fdisk_data->owner_pdb != pdb))

         close_fdisk(fdisk_data);

    share_access = (auto_lock) ? FILE_SHARE_READ :
                                 FILE_SHARE_READ | FILE_SHARE_WRITE;

    while (fdisk_data->fdisk_fd == INVALID_HANDLE_VALUE) {

        fdisk_data->fdisk_fd = CreateFile (fdisk_data->device_name,
                                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                           share_access,
                                           NULL,
                                           OPEN_EXISTING,
                                           0,
                                           0
                                           );
        if (fdisk_data->fdisk_fd != INVALID_HANDLE_VALUE) {
            fdisk_data->auto_locked = auto_lock ? TRUE : FALSE;
            fdisk_data->owner_pdb = pdb;
            fdisk_open_count++;
            (*(pFDAccess))++;
            break;
        }
        else {
            last_error = GetLastError();

            if (last_error == ERROR_SHARING_VIOLATION &&
                DiskOpenRetry(fdisk_data->drive_letter) == RMB_RETRY)
                    continue;
            else if (last_error == ERROR_ACCESS_DENIED) {
                /* the user doesn't have enough privilege to
                 * directly access the drive, display the pop up
                 * "terminate" ->terminate ntvdm process
                 * "ignore" -> fail the call and let application
                 *             handles the error.
                 */

                host_direct_access_error((ULONG)NOSUPPORT_HARDDISK);
                break;
            }
            else
                /* simply fail the call for other error conditions */
                break;

        }

    }

    if(fdisk_data->fdisk_fd != INVALID_HANDLE_VALUE) {
        // have the current align factor updated
        cur_align_factor = fdisk_data->align_factor;
    }
    fdisk_data->idle_counter = FDISK_IDLE_PERIOD;

    return(!(fdisk_data->fdisk_fd == INVALID_HANDLE_VALUE));
}

void fdisk_heart_beat(void)
{
    WORD i;
    PFDISKDATA fdisk_data;
    if (fdisk_open_count != 0) {
        for (i = 0; i < number_of_fdisk; i++) {
            fdisk_data = &fdisk_data_table[i];
            if(fdisk_data->fdisk_fd != INVALID_HANDLE_VALUE &&
               --fdisk_data->idle_counter == 0){
               close_fdisk(fdisk_data);
            }
        }
    }
}


VOID HostFdiskReset(VOID)
{
    FdiskTerminatePDB((USHORT)0);
}

VOID FdiskTerminatePDB(USHORT PDB)
{
    WORD i;
    PFDISKDATA fdisk_data;

    if (fdisk_open_count != 0) {
        for(i = 0; i < number_of_fdisk; i++) {
            fdisk_data = &fdisk_data_table[i];
            if (fdisk_data->fdisk_fd != INVALID_HANDLE_VALUE &&
                (PDB == 0 || fdisk_data->owner_pdb == PDB)) {
                close_fdisk(fdisk_data);
            }
        }
    }


}
// Generic disk read.
// this function takes care of buffer alignment requirement(cur_align_factor)
// and split the calls to file system if the given size is larger than
// MAX_DISKIO_SIZE -- File system may fail the request if the size
// is too big. We create a buffer worhty for 36KB(cylinder size of a
// 2.88 floppy) the first time application touch disks.

ULONG disk_read(
    HANDLE  fd,
    PLARGE_INTEGER offset,
    DWORD   size,
    PBYTE   buffer
)
{
    PBYTE   read_buffer;
    DWORD   block_size;
    DWORD   size_returned;
    DWORD   read_size;

    if (fd == INVALID_HANDLE_VALUE ||
        (SetFilePointer(fd, offset->LowPart, &offset->HighPart,
                        FILE_BEGIN) == 0xFFFFFFFF))
        {
        return 0;
    }
    block_size = (size <= MAX_DISKIO_SIZE)  ? size : MAX_DISKIO_SIZE;

    // if the given buffer is not aligned, use our buffer and do a
    // double copy
    if (cur_align_factor != 0) {
        read_buffer = get_aligned_disk_buffer();
        if (read_buffer == NULL)
            return 0;
    }
    else {
        read_buffer = buffer;
    }
    read_size = 0;
    while (size != 0) {
        if (size < block_size)
            block_size = size;
        if (!ReadFile(fd, (PVOID)read_buffer, block_size, &size_returned, 0)
            || size_returned != block_size)
                break;
        if(cur_align_factor != 0) {
            // read operation, read and then copy
            memcpy(buffer, (PVOID)read_buffer, block_size);
            buffer += block_size;
        }
        else
            read_buffer += block_size;
        size -= block_size;
        read_size += block_size;
    }
    return read_size;
}

ULONG disk_write(
    HANDLE  fd,
    PLARGE_INTEGER offset,
    DWORD   size,
    PBYTE   buffer
)
{
    PBYTE   write_buffer;
    DWORD   block_size;
    DWORD   size_returned;
    DWORD   written_size;

    if (fd == INVALID_HANDLE_VALUE ||
        (SetFilePointer(fd, offset->LowPart, &offset->HighPart,
                        FILE_BEGIN) == 0xFFFFFFFF))
        {
        return 0;
    }
    block_size = (size <= MAX_DISKIO_SIZE)  ? size : MAX_DISKIO_SIZE;

    // if the given buffer is not aligned, use our buffer and do a
    // double copy
    if (cur_align_factor != 0 &&
        (write_buffer = get_aligned_disk_buffer()) == NULL)
        return 0;
    written_size = 0;
    while (size != 0) {
        if (size < block_size)
            block_size = size;
        if(cur_align_factor != 0)
            // write operation, copy and then write
            memcpy((PVOID)write_buffer, buffer, block_size);
        else
            write_buffer = buffer;

        if (!WriteFile(fd, (PVOID)write_buffer, block_size, &size_returned, 0)
            || size_returned != block_size)
            break;
        size -= block_size;
        buffer += block_size;
        written_size += block_size;
    }
    return written_size;
}

// Hard disk verify actually goes to file system directly because
// the IOCTL_DISK_VERIFY will do the work. This ioctl doesn't work for
// floppy. This function is mainly provided for floppy verify.
BOOL disk_verify(
    HANDLE  fd,
    PLARGE_INTEGER offset,
    DWORD   size
)
{
    PBYTE   verify_buffer;
    DWORD   block_size;
    DWORD   size_returned;

    if (fd == INVALID_HANDLE_VALUE ||
        (SetFilePointer(fd, offset->LowPart, &offset->HighPart,
                        FILE_BEGIN) == 0xFFFFFFFF))
        {
        return FALSE;
    }
    block_size = (size <= MAX_DISKIO_SIZE)  ? size : MAX_DISKIO_SIZE;
    // if this is the first time application do a real work,
    // allocate the buffer
    if ((verify_buffer = get_aligned_disk_buffer()) == NULL)
        return FALSE;
    while (size != 0) {
        if (size < block_size)
            block_size = size;
        if (!ReadFile(fd, (PVOID)verify_buffer, block_size, &size_returned, 0)
            || size_returned != block_size)
            {
            return FALSE;
        }
        size -= block_size;
    }
    return TRUE;
}

PBYTE get_aligned_disk_buffer(void)
{
    // if we don't have the buffer yet, get it
    if (disk_buffer_pool == 0) {
        disk_buffer_pool = (DWORD) malloc(MAX_DISKIO_SIZE + max_align_factor);
        if (disk_buffer_pool == 0)
            return NULL;
    }
    return((PBYTE)((disk_buffer_pool + cur_align_factor) & ~(cur_align_factor)));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_hfx.c ===
#include "host_def.h"
#include "insignia.h"
/*
 * SoftPC Revision 2.0
 *
 * Title	: unix_hfx.c
 *
 * Description	: Stubbs for HFX
 *
 */

#include <stdio.h>
#include "xt.h"
#include "host_hfx.h"
#include "hfx.h"
#include "debug.h"

void get_hostname IFN2(int, fd, char *, name)
{
}

void get_host_fd IFN2(char *, name,int, fd)
{
}

void init_fd_hname()
{
}

void host_concat IFN3(char *, path,char *, name,char *, result)
{
}

word host_create IFN4(char *, name, word, attr, half_word, create_new, word *, fd)
{
	return (0);
}

void host_to_dostime IFN3(long, secs_since_70, word *, date, word *, time)
{
}

long host_get_datetime IFN2(word *, date,word *, thetime)
{
	return (0);
}

int host_set_time IFN2(word, fd, long, hosttime)
{
	return (0);
}


word host_open IFN6(char *, name, half_word, attrib, word *, fd, double_word *, size, word *, date, word *, thetime)
{
	return (0);
}

/* General purpose file move function. This was added for use by the new
   general purpose truncate code. It can copy between file systems, can
   overwrite the existing destination file, and can pad the destination
   file to the given length if the source file is less than that length. */
int	mvfile	IFN3(char *, from, char *, to, int, length)
{
	return (0);
}

word host_truncate IFN2(word, fd, long, size)
{
	return (0);
}

word host_close IFN1(word, fd)
{
	word	xen_err = 0;
	return(0);
}

word host_commit IFN1(word, fd)
{
	return(0);
}

word host_write IFN4(word, fd, unsigned char *, buf, word, num, word *, count)
{
	return (0);
}

word host_read IFN4(word, fd, unsigned char *, buf, word, num, word *, count)
{
	return(0);
}

word host_delete IFN1(char *, name)
{
	return(0);
}

int hfx_rename IFN2(char *, from,char *, to)
{
	return(0);
}


word host_rename IFN2(char *, from, char *, to)
{
    word	xen_err = 0;
    return(0);
}


half_word host_getfattr IFN1(char *, name)
{
	half_word	attr;
	return(0);
}

word host_get_file_info IFN4(char *, name, word *, thetime, word *, date, double_word *, size)
{
	return(0);
}

word host_set_file_attr IFN2(char *, name, half_word, attr)
{
	return(0);
}

word host_lseek IFN4(word, fd, double_word, offset,int, whence, double_word *, position)
{
	return(0);
}

word host_lock IFN3(word, fd, double_word, start, double_word, length)
{
	return(0);
}

word host_unlock IFN3(word, fd, double_word, start, double_word, length)
{
	return(0);
}

host_check_lock()
{
	return(0);
}

void host_disk_info IFN2(DOS_DISK_INFO *, disk_info, int, drive)
{
}
/* 
 *
 * Remove directory function.
 */
word host_rmdir IFN1(char *, host_path)
{
	return (0);
}

/* 
 *
 * Make directory function.
 */
word host_mkdir IFN1(char *, host_path)
{
	return (0);
}

/*
 *
 * Change directory function.  This function only validates the path
 * given.  DOS decides whether to actually change directory at a higher
 * level.  Success is returned if the path exists and is a directory.
 * If the path exists but the file is not a directory, then a special
 * code is returned, as to return error_path_not_found would be
 * ambiguous.
 */
word host_chdir IFN1(char *, host_path)
{
	return (0);
}


/*
 *
 * Function to return the volume ID of a network drive.
 * Eleven characters are available for the name to be output.
 *
 * The last field in the network drive path it output unless it
 * is more than eleven characters long in which case ten characters
 * are output with an appended tilde.
 */
void host_get_volume_id IFN2(char *, net_path, char *, volume_id)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_graph.c ===
#include <windows.h>
#include "host_def.h"
#include "insignia.h"

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        Name:           nt_graph.c
        Author:         Dave Bartlett (based on module by John Shanly)
        Derived From:   X_graph.c
        Created On:     10/5/1991
        Sccs ID:        @(#)nt_graph.c  1.29 04/17/91
        Purpose:
                This modules contain all Win32 specific functions required to
                support HERC, CGA and EGA emulations.  It is by definition
                Win32 specific. It contains full support for the Host
                Graphics Interface (HGI).

                This module handles all graphics output to the screen.

        (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

        Modifications:
        Tim August 92. nt_set_paint_routine() no longer calls TextToGraphics()
            during a full-screen to windowed transition.
        Tim September 92. New function resizeWindow(), called from textResize()
            for resizing the console window.
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#ifdef X86GFX
#include <ntddvdeo.h>
#endif
#include <sys\types.h>

#include "xt.h"
#include CpuH
#include "sas.h"
#include "ica.h"
#include "gvi.h"
#include "cga.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "egagraph.h"
#include "egacpu.h"
#include "egaports.h"
#include "egamode.h"
#include "host.h"
#include "host_rrr.h"
#include "error.h"
#include "config.h"             /* For definition of HERC, CGA, EGA, VGA */
#include "idetect.h"
#include "video.h"
#include "ckmalloc.h"
#include "conapi.h"

#include "nt_graph.h"
#include "nt_cga.h"
#include "nt_ega.h"
#include "nt_event.h"
#include "nt_mouse.h"
#include "ntcheese.h"
#include "nt_uis.h"
#include "nt_fulsc.h"
#include "nt_det.h"

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include "trace.h"
#include "debug.h"


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: IMPORTS */

/* Globals used in various functions to synchronise the display */

#ifdef EGG
extern int  ega_int_enable;
#endif

#if defined(NEC_98)
extern NEC98_VRAM_COPY  *video_copy;
extern unsigned char   *graph_copy;
unsigned int csr_g_x,csr_g_y;
unsigned int csr_x_old,csr_y_old;
unsigned int csr_tick = 0;
int csr_now_visible;
IMPORT BOOL NowFreeze;
void nt_graph_cursor(void);
void nt_remove_old_cursor(void);
void nt_graph_paint_cursor(void);
#else  // !NEC_98
extern byte  *video_copy;
#endif // !NEC_98

static int flush_count = 0;      /*count of graphic ticks since last flush*/

// DIB_PAL_INDICES shouldn't be used, use CreateDIBSECTION to get better
// performance characteristics.

#define DIB_PAL_INDICES 2

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: EXPORTS */

SCREEN_DESCRIPTION sc;

#ifdef BIGWIN
int             horiz_lut[256];
#endif
int             host_screen_scale;
int             host_display_depth = 8;
int             top_plane;
char            *DIBData;
PBITMAPINFO     MonoDIB;
PBITMAPINFO     CGADIB;
PBITMAPINFO     EGADIB;
PBITMAPINFO     VGADIB;

void            (*paint_screen)();
BOOL            FunnyPaintMode;
#if defined(NEC_98)
void (*cursor_paint)();
#endif // NEC_98

#if defined(JAPAN) || defined(KOREA)
// mskkbug#2002: lotus1-2-3 display garbage
// refer from nt_fulsc.c:ResetConsoleState()
BOOL            CurNowOff = FALSE;
#endif // JAPAN || KOREA
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Paint functions */

static PAINTFUNCS std_mono_paint_funcs =
{
#if defined(NEC_98)
        nt_text,               //
        nt_text20_only,        // Graph on(at PIF file) Text 20
        nt_text25_only,        // Graph on(at PIF file) Text 25
        nt_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_text,
        nt_cga_mono_graph_std,
        nt_cga_mono_graph_std,
        nt_text,
        nt_ega_mono_lo_graph_std,
        nt_ega_mono_med_graph_std,
        nt_ega_mono_hi_graph_std,
        nt_vga_mono_graph_std,
        nt_vga_mono_med_graph_std,
        nt_vga_mono_hi_graph_std,
#ifdef V7VGA
        nt_v7vga_mono_hi_graph_std,
#endif /* V7VGA */
};

static PAINTFUNCS big_mono_paint_funcs =
{
#if defined(NEC_98)
        nt_text,               //
        nt_text20_only,        // Graph on(at PIF file) Text 20
        nt_text25_only,        // Graph on(at PIF file) Text 25
        nt_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_text,
        nt_cga_mono_graph_big,
        nt_cga_mono_graph_big,
        nt_text,
        nt_ega_mono_lo_graph_big,
        nt_ega_mono_med_graph_big,
        nt_ega_mono_hi_graph_big,
        nt_vga_mono_graph_big,
        nt_vga_mono_med_graph_big,
        nt_vga_mono_hi_graph_big,
#ifdef V7VGA
        nt_v7vga_mono_hi_graph_big,
#endif /* V7VGA */
};

static PAINTFUNCS huge_mono_paint_funcs =
{
#if defined(NEC_98)
        nt_text,               //
        nt_text20_only,        // Graph on(at PIF file) Text 20
        nt_text25_only,        // Graph on(at PIF file) Text 25
        nt_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_text,
        nt_cga_mono_graph_huge,
        nt_cga_mono_graph_huge,
        nt_text,
        nt_ega_mono_lo_graph_huge,
        nt_ega_mono_med_graph_huge,
        nt_ega_mono_hi_graph_huge,
        nt_vga_mono_graph_huge,
        nt_vga_mono_med_graph_huge,
        nt_vga_mono_hi_graph_huge,
#ifdef V7VGA
        nt_v7vga_mono_hi_graph_huge,
#endif /* V7VGA */
};

static PAINTFUNCS std_colour_paint_funcs =
{
#if defined(NEC_98)
        nt_text,               //
        nt_text20_only,        // Graph on(at PIF file) Text 20
        nt_text25_only,        // Graph on(at PIF file) Text 25
        nt_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_text,
        nt_cga_colour_med_graph_std,
        nt_cga_colour_hi_graph_std,
        nt_text,
        nt_ega_lo_graph_std,
        nt_ega_med_graph_std,
        nt_ega_hi_graph_std,
        nt_vga_graph_std,
        nt_vga_med_graph_std,
        nt_vga_hi_graph_std,
#ifdef V7VGA
        nt_v7vga_hi_graph_std,
#endif /* V7VGA */
};

static PAINTFUNCS big_colour_paint_funcs =
{
#if defined(NEC_98)
        nt_text,               //
        nt_text20_only,        // Graph on(at PIF file) Text 20
        nt_text25_only,        // Graph on(at PIF file) Text 25
        nt_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_text,
        nt_cga_colour_med_graph_big,
        nt_cga_colour_hi_graph_big,
        nt_text,
        nt_ega_lo_graph_big,
        nt_ega_med_graph_big,
        nt_ega_hi_graph_big,
        nt_vga_graph_big,
        nt_vga_med_graph_big,
        nt_vga_hi_graph_big,
#ifdef V7VGA
        nt_v7vga_hi_graph_big,
#endif /* V7VGA */
};

static PAINTFUNCS huge_colour_paint_funcs =
{
#if defined(NEC_98)
        nt_text,               //
        nt_text20_only,        // Graph on(at PIF file) Text 20
        nt_text25_only,        // Graph on(at PIF file) Text 25
        nt_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_text,
        nt_cga_colour_med_graph_huge,
        nt_cga_colour_hi_graph_huge,
        nt_text,
        nt_ega_lo_graph_huge,
        nt_ega_med_graph_huge,
        nt_ega_hi_graph_huge,
        nt_vga_graph_huge,
        nt_vga_med_graph_huge,
        nt_vga_hi_graph_huge,
#ifdef V7VGA
        nt_v7vga_hi_graph_huge,
#endif /* V7VGA */
};

#ifdef MONITOR
#ifndef NEC_98
static PAINTFUNCS std_frozen_paint_funcs =
{
        nt_dummy_frozen,
        nt_cga_med_frozen_std,
        nt_cga_hi_frozen_std,
        nt_dummy_frozen,
        nt_ega_lo_frozen_std,
        nt_ega_med_frozen_std,
        nt_ega_hi_frozen_std,
        nt_vga_frozen_std,
        nt_vga_med_frozen_std,
        nt_vga_hi_frozen_std,
#ifdef V7VGA
        nt_dummy_frozen,
#endif /* V7VGA */
};

static PAINTFUNCS big_frozen_paint_funcs =
{
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
#ifdef V7VGA
        nt_dummy_frozen,
#endif /* V7VGA */
};

static PAINTFUNCS huge_frozen_paint_funcs =
{
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
        nt_dummy_frozen,
#ifdef V7VGA
        nt_dummy_frozen,
#endif /* V7VGA */
};
#endif // !NEC_98
#endif /* MONITOR */

static INITFUNCS mono_init_funcs =
{
#if defined(NEC_98)
        nt_init_text,               //
        nt_init_text20_only,        // Graph on(at PIF file) Text 20
        nt_init_text25_only,        // Graph on(at PIF file) Text 25
        nt_init_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_init_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_init_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_init_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_init_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_init_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_init_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_init_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_init_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_init_text,
        nt_init_cga_mono_graph,
        nt_init_cga_mono_graph,
        nt_init_text,
        nt_init_ega_mono_lo_graph,
        nt_init_ega_med_graph,
        nt_init_ega_hi_graph,
        nt_init_vga_hi_graph,
};

static INITFUNCS colour_init_funcs =
{
#if defined(NEC_98)
        nt_init_text,               //
        nt_init_text20_only,        // Graph on(at PIF file) Text 20
        nt_init_text25_only,        // Graph on(at PIF file) Text 25
        nt_init_graph200_only,      // Graph on(at PIF file) Graph 200
        nt_init_graph200slt_only,   // Graph on(at PIF file) Graph 200
        nt_init_graph400_only,      // Graph on(at PIF file) Graph 400
        nt_init_text20_graph200,    // Graph on(at PIF file) Text20graph200
        nt_init_text20_graph200slt, // Graph on(at PIF file) Text20graph200
        nt_init_text25_graph200,    // Graph on(at PIF file) Text25graph200
        nt_init_text25_graph200slt, // Graph on(at PIF file) Text25graph200
        nt_init_text20_graph400,    // Graph on(at PIF file) Text20graph400
        nt_init_text25_graph400,    // Graph on(at PIF file) Text25graph400
#endif // NEC_98
        nt_init_text,
        nt_init_cga_colour_med_graph,
        nt_init_cga_colour_hi_graph,
        nt_init_text,
        nt_init_ega_lo_graph,
        nt_init_ega_med_graph,
        nt_init_ega_hi_graph,
        nt_init_vga_hi_graph,
};

#ifdef MONITOR
#ifndef NEC_98
static INITFUNCS frozen_init_funcs =
{
        nt_init_text,
        nt_init_cga_colour_med_graph,
        nt_init_cga_colour_hi_graph,
        nt_init_text,
        nt_init_ega_lo_graph,
        nt_init_ega_med_graph,
        nt_init_ega_hi_graph,
        nt_init_vga_hi_graph,
};
#endif // !NEC_98
#endif /* MONITOR */

/*::::::::::::::::::::::::::::::::::::::::::::::: Adaptor function protocol */

void nt_init_screen (void);
void nt_init_adaptor (int, int);
void nt_change_mode (void);
void nt_set_screen_scale(int);
void nt_set_palette(PC_palette *, int);
void nt_set_border_colour(int);
void nt_clear_screen (void);
void nt_flush_screen (void);
void nt_mark_screen_refresh (void);
void nt_graphics_tick (void);
void nt_start_update (void);
void nt_end_update (void);
void nt_paint_cursor IPT3(int, cursor_x, int, cursor_y, half_word, attr);

void nt_set_paint_routine(DISPLAY_MODE, int);
void nt_change_plane_mask(int);
void nt_update_fonts (void);
void nt_select_fonts(int, int);
void nt_free_font(int);

void    nt_mode_select_changed(int);
void    nt_color_select_changed(int);
void    nt_screen_address_changed(int, int);
void    nt_cursor_size_changed(int, int);
void    nt_scroll_complete (void);
void    make_cursor_change(void);

boolean nt_scroll_up(int, int, int, int, int, int);
boolean nt_scroll_down(int, int, int, int, int, int);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static PAINTFUNCS *nt_paint_funcs;      /* Function ptrs for paint functions */
static INITFUNCS *nt_init_funcs;        /* Function ptrs for init functions */

VIDEOFUNCS      nt_video_funcs =
{
        nt_init_screen,
        nt_init_adaptor,
        nt_change_mode,
        nt_set_screen_scale,
        nt_set_palette,
        nt_set_border_colour,
        nt_clear_screen,
        nt_flush_screen,
        nt_mark_screen_refresh,
        nt_graphics_tick,
        nt_start_update,
        nt_end_update,
        nt_scroll_up,
        nt_scroll_down,
        nt_paint_cursor,
        nt_set_paint_routine,
        nt_change_plane_mask,
        nt_update_fonts,
        nt_select_fonts,
        nt_free_font,
        nt_mode_select_changed,
        nt_color_select_changed,
        nt_screen_address_changed,
        nt_cursor_size_changed,
        nt_scroll_complete
};

static int      current_char_height = 0;
static int      current_height; /* Use to avoid redundant resizing */
static int      current_width;  /* Use to avoid redundant resizing */
static int      current_bits_per_pixel;
static int      current_mode_type = TEXT;
static int      current_mode;
static int      current_scale;
static int      palette_size;   /* Size of PC palette */
static PC_palette *the_palette; /* Pointer to PC palette structure */
static int      update_vlt = FALSE;      /* TRUE when new one needed */
static int      host_plane_mask = 0xf;
static int      plane_masks[4];

#ifdef BIGWIN

/*
 * * tiny_lut[] is the building block of all the strecthing fuctions. * It
 * performs a two to three bit mapping. * The four entries are three bits
 * wide. The outside two bits in * each entry are the original bits, the
 * inside bit is the new bit. * There are two methods to create the new bit: *
 * 1) Logical Op upon the two old bits eg. OR, AND * 2) Copy one of the bits
 * eg. New bit will be a copy of the left bit. * static short tiny_lut[4] = {
 * 0, 3, 6, 7 }; This is an OR * static short tiny_lut[4] = { 0, 1, 6, 7 };
 * This is a left bit copy * Potential advantage of copy instead of logical
 * op is that there is no * bias towards white or black versions of the same
 * image. * eg. when a menu entry is highlighted by inversion. *
 *
 * 00 -> 000 * 01 -> 001 * 10 -> 110 * 11 -> 111
 */

/* favours black if 0, 1, 4, 7, or white if 0, 3, 6, 7 */
static short    tiny_lut[4] =
{
        0, 1, 6, 7
};

/*
 * dubble_up is used for simple byte doubling for x2 size windows
 */
static word dubble_up[] = {
    0x0000, 0x0003, 0x000c, 0x000f, 0x0030, 0x0033, 0x003c, 0x003f, 0x00c0,
    0x00c3, 0x00cc, 0x00cf, 0x00f0, 0x00f3, 0x00fc, 0x00ff, 0x0300, 0x0303,
    0x030c, 0x030f, 0x0330, 0x0333, 0x033c, 0x033f, 0x03c0, 0x03c3, 0x03cc,
    0x03cf, 0x03f0, 0x03f3, 0x03fc, 0x03ff, 0x0c00, 0x0c03, 0x0c0c, 0x0c0f,
    0x0c30, 0x0c33, 0x0c3c, 0x0c3f, 0x0cc0, 0x0cc3, 0x0ccc, 0x0ccf, 0x0cf0,
    0x0cf3, 0x0cfc, 0x0cff, 0x0f00, 0x0f03, 0x0f0c, 0x0f0f, 0x0f30, 0x0f33,
    0x0f3c, 0x0f3f, 0x0fc0, 0x0fc3, 0x0fcc, 0x0fcf, 0x0ff0, 0x0ff3, 0x0ffc,
    0x0fff, 0x3000, 0x3003, 0x300c, 0x300f, 0x3030, 0x3033, 0x303c, 0x303f,
    0x30c0, 0x30c3, 0x30cc, 0x30cf, 0x30f0, 0x30f3, 0x30fc, 0x30ff, 0x3300,
    0x3303, 0x330c, 0x330f, 0x3330, 0x3333, 0x333c, 0x333f, 0x33c0, 0x33c3,
    0x33cc, 0x33cf, 0x33f0, 0x33f3, 0x33fc, 0x33ff, 0x3c00, 0x3c03, 0x3c0c,
    0x3c0f, 0x3c30, 0x3c33, 0x3c3c, 0x3c3f, 0x3cc0, 0x3cc3, 0x3ccc, 0x3ccf,
    0x3cf0, 0x3cf3, 0x3cfc, 0x3cff, 0x3f00, 0x3f03, 0x3f0c, 0x3f0f, 0x3f30,
    0x3f33, 0x3f3c, 0x3f3f, 0x3fc0, 0x3fc3, 0x3fcc, 0x3fcf, 0x3ff0, 0x3ff3,
    0x3ffc, 0x3fff, 0xc000, 0xc003, 0xc00c, 0xc00f, 0xc030, 0xc033, 0xc03c,
    0xc03f, 0xc0c0, 0xc0c3, 0xc0cc, 0xc0cf, 0xc0f0, 0xc0f3, 0xc0fc, 0xc0ff,
    0xc300, 0xc303, 0xc30c, 0xc30f, 0xc330, 0xc333, 0xc33c, 0xc33f, 0xc3c0,
    0xc3c3, 0xc3cc, 0xc3cf, 0xc3f0, 0xc3f3, 0xc3fc, 0xc3ff, 0xcc00, 0xcc03,
    0xcc0c, 0xcc0f, 0xcc30, 0xcc33, 0xcc3c, 0xcc3f, 0xccc0, 0xccc3, 0xcccc,
    0xcccf, 0xccf0, 0xccf3, 0xccfc, 0xccff, 0xcf00, 0xcf03, 0xcf0c, 0xcf0f,
    0xcf30, 0xcf33, 0xcf3c, 0xcf3f, 0xcfc0, 0xcfc3, 0xcfcc, 0xcfcf, 0xcff0,
    0xcff3, 0xcffc, 0xcfff, 0xf000, 0xf003, 0xf00c, 0xf00f, 0xf030, 0xf033,
    0xf03c, 0xf03f, 0xf0c0, 0xf0c3, 0xf0cc, 0xf0cf, 0xf0f0, 0xf0f3, 0xf0fc,
    0xf0ff, 0xf300, 0xf303, 0xf30c, 0xf30f, 0xf330, 0xf333, 0xf33c, 0xf33f,
    0xf3c0, 0xf3c3, 0xf3cc, 0xf3cf, 0xf3f0, 0xf3f3, 0xf3fc, 0xf3ff, 0xfc00,
    0xfc03, 0xfc0c, 0xfc0f, 0xfc30, 0xfc33, 0xfc3c, 0xfc3f, 0xfcc0, 0xfcc3,
    0xfccc, 0xfccf, 0xfcf0, 0xfcf3, 0xfcfc, 0xfcff, 0xff00, 0xff03, 0xff0c,
    0xff0f, 0xff30, 0xff33, 0xff3c, 0xff3f, 0xffc0, 0xffc3, 0xffcc, 0xffcf,
    0xfff0, 0xfff3, 0xfffc, 0xffff
};
#endif                          /* BIGWIN */

/*:::::::::: Temporary colour table to make colours work :::::::::::::::*/
extern BYTE     Red[];
extern BYTE     Green[];
extern BYTE     Blue[];

#ifndef NEC_98
GLOBAL boolean  host_stream_io_enabled = FALSE;
#endif // !NEC_98

GLOBAL COLOURTAB defaultColours =
    {
        DEFAULT_NUM_COLOURS,
        Red,
        Green,
        Blue,
    };

BYTE    Mono[] = { 0, 0xff };

GLOBAL COLOURTAB monoColours =
    {
        MONO_COLOURS,
        Mono,
        Mono,
        Mono,
    };

/*
 * Bit masks for attribute bytes
 */

#define BOLD    0x08            /* Bold bit   */

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::: Useful Constants */

#define MOUSE_DELAY 2
#define TICKS_PER_FLUSH 2       /* PC ticks per screen flush     */

/*:::::::::::::::::::::::::::::::::::::::::: Not supporting v7vga mode, yet */

#undef    is_v7vga_mode
#define   is_v7vga_mode(x)  (FALSE)

static int      mode_change_now;
static int      ega_tick_delay;
static BOOL     CursorResizeNeeded = FALSE;

/*:::::::::::: Definition of local functions declared later in file ????????*/
void set_screen_sizes();
void check_win_size();
void select_paint_routines();
void dummy_paint_screen();
#ifdef BIGWIN
void init_lut();
#endif
void prepare_surface();




/*
 * ================================================================
 * Functions supporting the Host Graphics Interface (HGI)
 * ================================================================
 */

/*
*****************************************************************************
** closeGraphicsBuffer()
*****************************************************************************
** Centralised place to close (and destroy) graphics buffer. For X86 and JAZZ
** Tim October 92.
**
** sc.ScreenBufHandle is handle to the graphics buffer
** sc.OutputHandle is handle to the text buffer
**
** Important to set the successfully closed handle to NULL.
** Safety first, set the active handle to sc.OutputHandle before attempting
** to close the graphics buffer handle.
**
** Small change: only do this if sc.ScreenBufHandle is set, otherwise bad
** things happen. Screen flashes when we suspend in full-screen and during
** a transition to full-screen in text mode, whatever is on screen gets
** written to B800 - not a good idea if page 2 is active (This happens
** in Brief). Tim and DAB Jan 93.
*/
GLOBAL VOID closeGraphicsBuffer IFN0()
{
        if( sc.ScreenBufHandle != (HANDLE)0 ){

                MouseDetachMenuItem(TRUE);

#if defined(NEC_98)
        {
            INPUT_RECORD InputRecord[128];
            DWORD RecordsRead;
            if(GetNumberOfConsoleInputEvents(sc.InputHandle, &RecordsRead))
                if (RecordsRead)
                    ReadConsoleInputW(sc.InputHandle,
                                         &InputRecord[0],
                                         sizeof(InputRecord)/sizeof(INPUT_RECORD),
                                         &RecordsRead);
#endif // NEC_98
                if( !SetConsoleActiveScreenBuffer( sc.OutputHandle ) ){
                        assert2( NO, "VDM: SCASB() failed:%#x H=%#x",
                                GetLastError(), sc.OutputHandle );
                }
#if defined(NEC_98)
                if (RecordsRead)
                    WriteConsoleInputW(sc.InputHandle,
                                         &InputRecord[0],
                                         RecordsRead,
                                         &RecordsRead);
        }
#endif // NEC_98

                /*
                 *  Cleanup ALL handles associated with screen buffer
                 *  01-Mar-1993 Jonle
                 */
                CloseHandle(sc.ScreenBufHandle);
                sc.ScreenBufHandle = (HANDLE)0;
                sc.ColPalette = (HPALETTE)0;

                /*
                 * Point to the current output handle.
                 */
                sc.ActiveOutputBufferHandle = sc.OutputHandle;
                MouseAttachMenuItem(sc.ActiveOutputBufferHandle);

#ifndef MONITOR
                //
                // Turn the pointer back on when going from graphics
                // to text mode since the selected buffer has changed
                //

                MouseDisplay();
#endif  // MONITOR

                CloseHandle(sc.ConsoleBufInfo.hMutex);
                sc.ConsoleBufInfo.hMutex = 0;
#ifdef X86GFX

                /*
                 * Make sure a buffer is selected next time SelectMouseBuffer
                 * is called.
                 */
                mouse_buffer_width = 0;
                mouse_buffer_height = 0;
#endif /* X86GFX */
        }
} /* end of closeGraphicsBuffer() */

GLOBAL void resetWindowParams()
{
        /*
         * Reset saved video params
         */
        current_height = current_width = 0;
        current_char_height = 0;
        current_mode_type = TEXT;
        current_bits_per_pixel = 0;
        current_scale = 0;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::: Initialise screen :::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_screen(void)
{
    static int      med_res_swapped = FALSE;
    static boolean  already_called = FALSE;

#ifdef X86GFX
    sc.Registered = FALSE;
#endif
    sub_note_trace0(ALL_ADAPT_VERBOSE, "nt_init_screen\n");

    /* If an error occurs before the user interface has been initialised then
       host_error makes a call to nt_init_screen. Thus a check is made here to
       see if the user interface has already been initialised. If it has then
       this function should simply return. */

    if(already_called) return;

    already_called = TRUE;

#ifdef BIGWIN
    /* set up the look-up-table for fast horizontal stretching */
    init_lut();
#endif

    /*:::::::::::::::::::::::::::::::::::::::::: Allocate video copy buffer */

#if defined(NEC_98)
    if(!video_copy) video_copy = (NEC98_VRAM_COPY *) host_malloc(0x8000);
    if(!graph_copy) graph_copy = (unsigned char *) host_malloc(0x40000);
#else  // !NEC_98
#ifdef MONITOR
    if(!video_copy) video_copy = (byte *) host_malloc(0x8000);
#else
    if(!video_copy) video_copy = (byte *) host_malloc(0x20000);
#endif

    /*::::::::::::::::::::::::::::::::: Allocate DAC and EGA planes buffers */

    if(!EGA_planes) EGA_planes = (byte *) host_malloc(4*EGA_PLANE_SIZE);
    if(!DAC) DAC = (PC_palette *) host_malloc(sizeof(PC_palette) * VGA_DAC_SIZE);
#endif // !NEC_98

#if defined(NEC_98)
    if (video_copy == NULL)
#else  // !NEC_98
    if (video_copy == NULL || EGA_planes == NULL || DAC == NULL)
#endif // !NEC_98
        host_error(EG_MALLOC_FAILURE, ERR_QUIT, "");

    /* Set current screen height to prevent the window changing shape between
       init_screen and init_adaptor */

#if defined(NEC_98)
        current_height = NEC98_WIN_HEIGHT;  current_width = NEC98_WIN_WIDTH;
#else  // !NEC_98
    video_adapter = (half_word) config_inquire(C_GFX_ADAPTER, NULL);
    switch (video_adapter)
    {
        case CGA:
            current_height = CGA_WIN_HEIGHT;  current_width = CGA_WIN_WIDTH;
            break;

        case EGA:
            current_height = EGA_WIN_HEIGHT;  current_width = EGA_WIN_WIDTH;
            break;
    }
#endif // !NEC_98

    /*::::::::::::::::: Setup the screen dimensions for the initial adaptor */

#if defined(NEC_98)
    set_screen_sizes();
#else  // !NEC_98
    host_set_screen_scale((SHORT) config_inquire(C_WIN_SIZE, NULL));
    set_screen_sizes(video_adapter);
#endif // !NEC_98

    /*:::: Set pixel values to be used for FG and BG (mainly in mono modes) */

    sc.PCForeground = RGB(255,255,255); /* White RGB */
    sc.PCBackground = RGB(0,0,0);        /* Black RGB */

    /* Choose the routines appropriate for the monitor and window size. */
    select_paint_routines();
}

#ifdef MONITOR
/* The mouse calls this func when it sees a mode change. If we're windowed
 * we pass it off to the softpc bios (who may want to switch to fullscreen).
 * If we're fullscreen we do nothing as the native bios will take care of
 * everything.
 */
void host_call_bios_mode_change(void)
{
    extern void ega_video_io();
    half_word mode;

    if (sc.ScreenState == WINDOWED)
    {
        ega_video_io();
    }
    else
    {

        /*
         * We have a fullscreen mode change so we need to change the mouse
         * buffer so that we get mouse coordinates of the correct resolution.
         */
        mode = getAL();
        SelectMouseBuffer(mode, 0);
    }
}
#endif /* MONITOR */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Initialise adaptor ::::::::::::::::::::::::::::*/

void nt_init_adaptor(int adaptor, int height)
{
    sub_note_trace2(ALL_ADAPT_VERBOSE,
                    "nt_init_adaptor adapt=%d height=%d\n", adaptor, height);

    /*Avoid delaying mode changes,otherwise update may use old paint routines*/

    if((adaptor == EGA) || (adaptor == VGA))
        mode_change_now = ega_tick_delay = 0;

    // Lose for console integration
    //  set_screen_sizes(adaptor);
    //  check_win_size(height);
    //  prepare_surface();
    //  nt_change_mode();
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::: Called at every mode change to initialise fonts etc ::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_change_mode(void)
{
    /*::::::::::::::::::::::::::::::::::::: Display current postion in code */

    sub_note_trace0(ALL_ADAPT_VERBOSE, "nt_change_mode");

    /*:::::::::::::::::::: Setup update vectors and initialise paint system */

#ifndef NEC_98
    switch(video_adapter)
    {
        /*::::::::::::::::::::::::::::::::::::::::::::::: CGA mode selected */

        case CGA:               // Adapter is always VGA on NT
            break;

        /*::::::::::::::::::::::::::::::::::::::: EGA or VGA modes selected */

        case EGA:   case VGA:
            break;

        /*::::::::::::::::::::::::::::::::::::::::::: Unknown viseo adaptor */

        default:
            sub_note_trace0(ALL_ADAPT_VERBOSE,"**** Unknown video adaptor ****");
            break;
    }
#endif // !NEC_98
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::: Clear screen :::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_clear_screen(void)
{
    CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;
    COORD coord;
    DWORD nCharWritten;
    IMPORT int soft_reset;

    if ((! ConsoleInitialised) || (! soft_reset))       // ignore startup stuff
        return;

    if (ConsoleNoUpdates)
        return;

    sub_note_trace0(ALL_ADAPT_VERBOSE, "nt_clear_screen");

    if(sc.ScreenBufHandle) return;

#ifndef X86GFX
    if (sc.ScreenState == FULLSCREEN)   // don't want sudden screen clears
        return;
#endif

    /*::::::::::::::::::::::::::::: Get information on current screen size */

    GetConsoleScreenBufferInfo(sc.OutputHandle,&ScreenInfo);

    /*::::::::::::::::::::::::::::::::::::::::::::::::::: Clear characters */

    coord.X = coord.Y = 0;
    FillConsoleOutputCharacter(sc.OutputHandle, ' ',
                                ScreenInfo.dwSize.X * ScreenInfo.dwSize.Y,
                                coord,&nCharWritten);

    /*::::::::::::::::::::::::::::::::::::::::::::::::::: Clear Attributes */

    coord.X = coord.Y = 0;
    FillConsoleOutputAttribute(sc.OutputHandle, (WORD) sc.PCBackground,
                              ScreenInfo.dwSize.X * ScreenInfo.dwSize.Y,
                              coord,&nCharWritten);
#ifdef MONITOR
#ifndef NEC_98
    /*
    ** Called during a mode change...
    ** Trash video copy so future updates will know what has changed.
    ** Alternatively mon_text_update() could listen to dirty_flag.
    */
    memfill( 0xff, &video_copy[ 0 ], &video_copy[ 0x7fff ] ); /* Tim Oct 92 */
#endif // !NEC_98
#endif
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::: Flush screen :::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_flush_screen(void)
{
    sub_note_trace0(ALL_ADAPT_VERBOSE, "nt_flush_screen");

    if (ConsoleInitialised == TRUE && ConsoleNoUpdates == FALSE &&
        !get_mode_change_required())
#ifdef X86GFX
        if (sc.ScreenState == WINDOWED)
#endif
            (void)(*update_alg.calc_update)();
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Mark screen for refresh :::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_mark_screen_refresh(void)
{
        sub_note_trace0(ALL_ADAPT_VERBOSE, "nt_mark_screen_refresh");

        screen_refresh_required();
        update_vlt = TRUE;
}

void UpdateScreen(void)
{
    if (ConsoleInitialised == TRUE && ConsoleNoUpdates == FALSE)
#ifdef X86GFX
        if (sc.ScreenState == WINDOWED)
#endif
        {
            (*update_alg.calc_update)();
            ega_tick_delay = EGA_TICK_DELAY;
            flush_count = 0;
        }
}
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::: Handle graphics ticks ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_graphics_tick(void)
{

#ifndef NEC_98
    if (sc.ScreenState == STREAM_IO) {
        if (++flush_count == TICKS_PER_FLUSH){
            stream_io_update();
            flush_count = 0;
        }
        return;
    }
#endif // !NEC_98

#ifdef EGG
#ifndef NEC_98
    if((video_adapter == EGA) || (video_adapter == VGA))
    {
        /* two timer ticks since mode_change_required became true ?
           (really need same stuff for CGA, but not done yet)
           Now just delay screen update, & only if display REALLY changed */
#endif // !NEC_98

        /*
        ** When VGA registers get hit during a mode change, postpone
        ** the call to *choose_display_mode() by EGA_TICK_DELAY ticks.
        ** This will delay window resizing and eliminate possibility
        ** of doing it more than once per mode change. Tim Jan 93.
        */

        /*Has mode_change_required been set (implying EGA regs have changed)*/
        if (mode_change_now) {
            if (--mode_change_now == 0) {
                (void)(*choose_display_mode)();
                // must do this after video mode has been selected
                // otherwise, the mouse code can come in and update the
                // screen. See nt_flush_screen
                set_mode_change_required(FALSE);
            }
        }
        else if (get_mode_change_required()) {
            mode_change_now = EGA_TICK_DELAY - 1;
            /* Delay mouse input and flush all pending mouse events. */
            DelayMouseEvents(MOUSE_DELAY);
        }
        else
        {
            /*................ Only update if a mode change is not imminent */

            if(++flush_count == TICKS_PER_FLUSH)
            {

#if defined(NEC_98)
                if(update_vlt || get_palette_change_required())
                    set_the_vlt();

                if (ConsoleNoUpdates == FALSE){
                        NEC98GLOBS->dirty_flag++;
#else  // !NEC_98
                if(update_vlt || get_palette_change_required())
                    set_the_vlt();

                if (ConsoleInitialised == TRUE && ConsoleNoUpdates == FALSE)
#endif // !NEC_98
#ifdef X86GFX
                    if (sc.ScreenState == WINDOWED)
#endif
#if defined(NEC_98)
                        {
#endif // !NEC_98
                        (void)(*update_alg.calc_update)();
#if defined(NEC_98)
                          if(sc.ModeType ==GRAPHICS)
                              nt_graph_cursor();
                        }
                        }
#endif // NEC_98

                ega_tick_delay = EGA_TICK_DELAY;

                /* batch cursor changes as some naffola apps (Word) change
                 * cursor around every char!!
                 */
                if (CursorResizeNeeded)
                    make_cursor_change();

                flush_count = 0;
             }
        }
#ifndef NEC_98
    }
    else
#endif // !NEC_98
#endif /* EGG */
#ifndef NEC_98
    {
        /*:::::::::: Update the screen as required for mda and cga and herc */

        if(++flush_count == TICKS_PER_FLUSH)
        {
            if(update_vlt) set_the_vlt();

            if (ConsoleInitialised == TRUE && ConsoleNoUpdates == FALSE)
#ifdef X86GFX
                if (sc.ScreenState == WINDOWED)
#endif
                    (void)(*update_alg.calc_update)();

            flush_count = 0;
        }
    }
#endif // !NEC_98
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Start screen update ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_start_update(void)
{
   IDLE_video();
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: End screen update ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_end_update(void) {   }

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::: Scroll screen up :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

boolean nt_scroll_up(int tlx, int tly, int brx, int bry, int amount, int col)
{
    CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;
    COORD dwDestinationOrigin;    /* Location of rectangle */
    SMALL_RECT ScrollRectangle;   /* Rectangle to scroll */
    CHAR_INFO Fill;               /* Fill exposed region with */

    return(FALSE);

    /*::::::::::::::::::::::::::::::::: Tell the outside world where we are */

    sub_note_trace6(ALL_ADAPT_VERBOSE,
        "nt_scroll_up tlx=%d tly=%d brx=%d bry=%d amount=%d col=%d\n",
         tlx, tly, brx, bry, amount, col);

    if(sc.ScreenBufHandle || sc.ModeType == GRAPHICS)
        return(FALSE);     //Screen buffer undefined or in graphics mode

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#ifdef BIGWIN
        tlx = SCALE(tlx);
        tly = SCALE(tly);
        brx = brx & 1 ? SCALE(brx + 1) - 1 : SCALE(brx);
        bry = bry & 1 ? SCALE(bry + 1) - 1 : SCALE(bry);

        /* odd numbers don't multiply by 1.5 very accurately */
        amount = SCALE(amount);
#endif


    /* is this a scroll or just an area fill? */
    if (bry - tly - amount + 1 == 0)
    {
        //DbgPrint("F");
        return(FALSE);   // its just a fill HACK - should do this with host fill
    }

    /*:::::::::::::::::::::::::::::::::::::: Get Console screen information */

    GetConsoleScreenBufferInfo(sc.OutputHandle, &ScreenInfo);

    /*::::::::::::::::::::::::::::::::::::::: Calculate rectangle to scroll */

    ScrollRectangle.Top = (tly + amount) / get_char_height();
    ScrollRectangle.Left = tlx / get_pix_char_width();

    ScrollRectangle.Bottom = bry / get_char_height();
    ScrollRectangle.Right = brx / get_pix_char_width();

    /*::::::::::::::::::::::::::::::::::::: Calculate destination rectangle */

    dwDestinationOrigin.Y = tly / get_char_height();
    dwDestinationOrigin.X = ScrollRectangle.Left;

    /*::::: Setup fill character information for area exposed by the scroll */

    Fill.Char.AsciiChar = ' ';
    Fill.Attributes = col << 4;

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::: Scroll screen */

    //DbgPrint(".");
    ScrollConsoleScreenBuffer(sc.OutputHandle, &ScrollRectangle,
                              NULL, dwDestinationOrigin, &Fill);

    /*:::::::::::::::::::::::::::::::::::::::::::::::: Fill in exposed area */

    return(TRUE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Scroll screen down :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

boolean nt_scroll_down(int tlx,int tly,int brx,int bry,int amount,int col)
{
    CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;
    COORD dwDestinationOrigin;    /* Location of rectangle */
    SMALL_RECT ScrollRectangle;   /* Rectangle to scroll */
    CHAR_INFO Fill;               /* Fill exposed region with */

    /*::::::::::::::::::::::::::::::::: Tell the outside world where we are */

    sub_note_trace6(ALL_ADAPT_VERBOSE,
        "nt_scroll_down tlx=%d tly=%d brx=%d bry=%d amount=%d col=%d\n",
         tlx, tly, brx, bry, amount, col);

    return(FALSE);
    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

    if(sc.ScreenBufHandle) return(FALSE);

#ifdef BIGWIN
        tlx = SCALE(tlx);
        tly = SCALE(tly);
        brx = brx & 1 ? SCALE(brx + 1) - 1 : SCALE(brx);
        bry = bry & 1 ? SCALE(bry + 1) - 1 : SCALE(bry);

        /* odd numbers don't multiply by 1.5 very accurately */
        amount = SCALE(amount);
#endif
    if (sc.ModeType == GRAPHICS)
        return(FALSE);  // don't think console can scroll graphics

    /* is this a scroll or just an area fill? */
    if (bry - tly - amount + 1 == 0) {
        return(FALSE);   // its just a fill HACK - should do this with host fill
    }

    /*:::::::::::::::::::::::::::::::::::::: Get Console screen information */

    GetConsoleScreenBufferInfo(sc.OutputHandle, &ScreenInfo);

    /*::::::::::::::::::::::::::::::::::::::: Calculate rectangle to scroll */

    ScrollRectangle.Top = tly / get_char_height();
    ScrollRectangle.Left = tlx / get_pix_char_width();

    ScrollRectangle.Bottom = (bry - amount) / get_char_height();
    ScrollRectangle.Right = brx / get_pix_char_width();

    /*::::::::::::::::::::::::::::::::::::: Calculate destination rectangle */

    dwDestinationOrigin.Y = ScrollRectangle.Top + (amount / get_char_height());
    dwDestinationOrigin.X = ScrollRectangle.Left;

    /*::::: Setup fill character information for area exposed by the scroll */

    Fill.Char.AsciiChar = ' ';
    Fill.Attributes = col << 4;

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::: Scroll screen */

    ScrollConsoleScreenBuffer(sc.OutputHandle, &ScrollRectangle,
                              NULL, dwDestinationOrigin, &Fill);

    /*:::::::::::::::::::::::::::::::::::::::::::::::: Fill in exposed area */

    return(TRUE);

}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Paint cursor :::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_paint_cursor IFN3(int, cursor_x, int, cursor_y, half_word, attr)
{
#if defined(NEC_98)         // NEC {
    static COORD CursorPos;                                     // NEC
    static CONSOLE_CURSOR_INFO CursorInfo;                      // NEC
    static BOOL csr_visible = FALSE;                            // NEC
    static DWORD csrSize = 0;                                   // NEC
#else                                                           // NEC
    COORD CursorPos;
#endif                                                          // NEC

    /*::::::::::::::::::::::::::::::::::::::::::::::::::: Guess where we are */

    sub_note_trace3(ALL_ADAPT_VERBOSE, "nt_paint_cursor x=%d, y=%d, attr=%d\n",
                    cursor_x, cursor_y, attr);

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::: Update cursor */

#if defined(NEC_98)
    if(sc.ModeType == GRAPHICS){
        if(csr_tick>3 && csr_now_visible &&
           !((csr_g_x == cursor_x)&&(csr_g_y == cursor_y))){
            nt_remove_old_cursor();
            csr_tick = 0;
        }
    } else {
        CursorInfo.bVisible = TRUE;
        CursorInfo.dwSize =
                (get_cursor_height() * 100)/get_char_height();
        if ((LINES_PER_SCREEN < cursor_y)
                ||(is_cursor_visible()==FALSE)
                || (get_cursor_height() == 0)) {
                        CursorInfo.bVisible = FALSE;
        }
        if(csr_visible != CursorInfo.bVisible ||
           csrSize != CursorInfo.dwSize){
            csr_visible = CursorInfo.bVisible;
            csrSize = CursorInfo.dwSize;
            SetConsoleCursorInfo(sc.OutputHandle,&CursorInfo);
        }
        if(csr_g_x != cursor_x || csr_g_y != cursor_y){
            CursorPos.X = cursor_x;  CursorPos.Y = cursor_y;
            SetConsoleCursorPosition(sc.OutputHandle,CursorPos);
        }
    }
    csr_g_x = cursor_x;
    csr_g_y = cursor_y;
#else  // !NEC_98
    if(is_cursor_visible() && (get_screen_height() > cursor_y))
    {

        /*::::::::::::::::::::::::::::::::::::::::::::::::::::: Draw cursor */

        if(get_cursor_height() > 0)
        {
            /*...................................... Set new cursor postion */

            CursorPos.X = (SHORT)cursor_x;
        CursorPos.Y = (SHORT)cursor_y;
            SetConsoleCursorPosition(sc.OutputHandle,CursorPos);
        }
    }
#endif // !NEC_98
}

void nt_cursor_size_changed(int lo, int hi)
{
    UNREFERENCED_FORMAL_PARAMETER(lo);
    UNREFERENCED_FORMAL_PARAMETER(hi);
    CursorResizeNeeded = TRUE;
}

void make_cursor_change(void)
{
    CONSOLE_CURSOR_INFO CursorInfo;
    CONSOLE_FONT_INFO font;
    COORD fontsize;

    SAVED DWORD CurrentCursorSize = (DWORD)-1;
    SAVED BOOL MyCurNowOff = FALSE;

    if(sc.ScreenState == FULLSCREEN) return;

    CursorResizeNeeded = FALSE;

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::: Update cursor */

    if(is_cursor_visible())
    {

        /*::::::::::::::::::::::::::::::::::::::::::::::::::::: Draw cursor */

        if(get_cursor_height() > 0)
        {
            /*...........................................Change cursor size */

            if(get_cursor_height())
            {
                /* value has to be percentage of block filled */
#if (defined(JAPAN) || defined(KOREA)) && !defined(NEC_98)
                // support Dosv cursor
                if ( !is_us_mode() ) {
                    CursorInfo.dwSize = ( (get_cursor_height() ) * 100)/(get_cursor_height()+get_cursor_start());
                    //DbgPrint("Char height=%d\n", get_char_height() );
                }
                else {
                    CursorInfo.dwSize = (get_cursor_height() * 100)/get_char_height();
                }
#else // !JAPAN
                CursorInfo.dwSize = (get_cursor_height() * 100)/get_char_height();
#endif // !JAPAN
                /* %age may be too small on smaller fonts, check size */
                fontsize.X = fontsize.Y = 0;

                /* get font index */
                if (GetCurrentConsoleFont(sc.OutputHandle, TRUE,  &font) == FALSE)
                    CursorInfo.dwSize = 20;             /* min 20% */
                else
                {
                    fontsize = GetConsoleFontSize(sc.OutputHandle, font.nFont);
                    if (fontsize.Y != 0)   /* what's the error return???? */
                    {
                        if(((WORD)(100 / fontsize.Y)) >= CursorInfo.dwSize)
                            CursorInfo.dwSize = (DWORD) (100/fontsize.Y + 1);
                    }
                    else
                        CursorInfo.dwSize = (DWORD)20;  /* min 20% */
                }

                if(CurrentCursorSize != CursorInfo.dwSize || MyCurNowOff)
                {
                    CurrentCursorSize = CursorInfo.dwSize;
                    MyCurNowOff = FALSE;
                    CursorInfo.bVisible = TRUE;
                    SetConsoleCursorInfo(sc.OutputHandle,&CursorInfo);
                }
            }
        }
    }
    else        /* Turn cursor image off */
    {
        if (MyCurNowOff == FALSE)
        {
            CursorInfo.dwSize = 1;
            CursorInfo.bVisible = FALSE;
            SetConsoleCursorInfo(sc.OutputHandle,&CursorInfo);
            MyCurNowOff = TRUE;
        }
    }
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::: Set up the appropriate paint routine  :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_set_paint_routine(DISPLAY_MODE mode, int height)
{
    int  oldModeType;

    /* Tracing message. */
    sub_note_trace2(ALL_ADAPT_VERBOSE, "nt_set_paint_routine mode=%d height=%d", mode, height);

    /* Save old mode type for checking for text -> graphics transition. */
    oldModeType = sc.ModeType;

    /* For freezing. */
    FunnyPaintMode = FALSE;

    /* Set up paint vectors. */
    switch((int) mode)
    {

#if defined(NEC_98)
        case NEC98_TEXT_40:
            sc.ModeType = TEXT;
            paint_screen = nt_paint_funcs->NEC98_text;
            (*nt_init_funcs->NEC98_text) ();
            break;

        case NEC98_TEXT_80:
            sc.ModeType = TEXT;
            paint_screen = nt_paint_funcs->NEC98_text;
            (*nt_init_funcs->NEC98_text) ();
            break;

        case NEC98_TEXT_20L:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text20_only;
            cursor_paint = nt_cursor20_only;
            (*nt_init_funcs->NEC98_text20_only) ();
            break;

        case NEC98_TEXT_25L:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text25_only;
            cursor_paint = nt_cursor25_only;
            (*nt_init_funcs->NEC98_text25_only) ();
            break;

        case NEC98_GRAPH_200:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_graph200_only;
            cursor_paint = dummy_cursor_paint;
            (*nt_init_funcs->NEC98_graph200_only) ();
            break;

        case NEC98_GRAPH_200_SLT:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_graph200slt_only;
            cursor_paint = dummy_cursor_paint;
            (*nt_init_funcs->NEC98_graph200slt_only) ();
            break;

        case NEC98_GRAPH_400:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_graph400_only;
            cursor_paint = dummy_cursor_paint;
            (*nt_init_funcs->NEC98_graph400_only) ();
            break;

        case NEC98_T20L_G200:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text20_graph200;
            cursor_paint = nt_cursor20;
            (*nt_init_funcs->NEC98_text20_graph200) ();
            break;

        case NEC98_T20L_G200_SLT:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text20_graph200slt;
            cursor_paint = nt_cursor20;
            (*nt_init_funcs->NEC98_text20_graph200slt) ();
            break;

        case NEC98_T25L_G200:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text25_graph200;
            cursor_paint = nt_cursor25;
            (*nt_init_funcs->NEC98_text25_graph200) ();
            break;

        case NEC98_T25L_G200_SLT:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text25_graph200slt;
            cursor_paint = nt_cursor25;
            (*nt_init_funcs->NEC98_text25_graph200slt) ();
            break;

        case NEC98_T20L_G400:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text20_graph400;
            cursor_paint = nt_cursor20;
            (*nt_init_funcs->NEC98_text20_graph400) ();
            break;

        case NEC98_T25L_G400:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->NEC98_text25_graph400;
            cursor_paint = nt_cursor25;
            (*nt_init_funcs->NEC98_text25_graph400) ();
            break;
#else  // !NEC_98
        /* CGA modes (40 columns). */
        case TEXT_40_FUN:
            assert1(NO,"Funny text mode selected %s",get_mode_string(mode));
            FunnyPaintMode = TRUE;
        case CGA_TEXT_40_SP:
        case CGA_TEXT_40_SP_WR:
        case CGA_TEXT_40:
        case CGA_TEXT_40_WR:
            sc.ModeType = TEXT;
            paint_screen = nt_paint_funcs->cga_text;
            (*nt_init_funcs->cga_text) ();
            break;

        /* CGA modes (80 columns). */
        case TEXT_80_FUN:
            assert1(NO,"Funny text mode selected %s",get_mode_string(mode));
            FunnyPaintMode = TRUE;
        case CGA_TEXT_80_SP:
        case CGA_TEXT_80_SP_WR:
        case CGA_TEXT_80:
        case CGA_TEXT_80_WR:
            sc.ModeType = TEXT;
            paint_screen = nt_paint_funcs->cga_text;
            (*nt_init_funcs->cga_text) ();
            break;

        /* CGA modes (graphics). */
        case CGA_MED_FUN:
            assert1(NO,"Funny graphics mode %s",get_mode_string(mode));
            FunnyPaintMode = TRUE;
        case CGA_MED:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->cga_med_graph;
            (*nt_init_funcs->cga_med_graph)();
            break;

        case CGA_HI_FUN:
            assert1(NO,"Funny graphics mode %s",get_mode_string(mode));
            FunnyPaintMode = TRUE;
        case CGA_HI:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->cga_hi_graph;
            (*nt_init_funcs->cga_hi_graph)();
            break;

        /* EGA modes (40 columns). */
        case EGA_TEXT_40_SP:
        case EGA_TEXT_40_SP_WR:
        case EGA_TEXT_40:
        case EGA_TEXT_40_WR:
            sc.ModeType = TEXT;
            paint_screen = nt_paint_funcs->ega_text;
            (*nt_init_funcs->ega_text) ();
            break;

        /* EGA modes (80 columns) */
        case EGA_TEXT_80_SP:
        case EGA_TEXT_80_SP_WR:
        case EGA_TEXT_80:
        case EGA_TEXT_80_WR:
            sc.ModeType = TEXT;
            paint_screen = nt_paint_funcs->ega_text;
            (*nt_init_funcs->ega_text) ();
            break;

        /* EGA modes (graphics). */
        case EGA_HI_FUN:
            assert1(NO, "Funny graphics mode %s", get_mode_string(mode));
            FunnyPaintMode = TRUE;
        case EGA_HI:
        case EGA_HI_WR:
        case EGA_HI_SP:
        case EGA_HI_SP_WR:
            sc.ModeType = GRAPHICS;
            if(get_256_colour_mode())
            {
#ifdef V7VGA
                if (get_seq_chain4_mode() && get_chain4_mode())
                {
                    paint_screen = nt_paint_funcs->v7vga_hi_graph;
                    (*nt_init_funcs->vga_hi_graph)();
                }
                else
#endif /* V7VGA */
                {
                    if (get_chain4_mode())
                    {
#ifdef MONITOR
                        if (nt_paint_funcs == &std_frozen_paint_funcs)
                            if (Frozen256Packed)     //2 possible frozen formats
                                paint_screen = nt_vga_frozen_pack_std;
                            else
                                paint_screen = nt_paint_funcs->vga_graph;
                        else
#endif /* MONITOR */
                            paint_screen = nt_paint_funcs->vga_graph;
                    }
                    else
                    {
                        if (get_char_height() == 2)
                            paint_screen = nt_paint_funcs->vga_med_graph;
                        else
                            paint_screen = nt_paint_funcs->vga_hi_graph;
                    }
                    (*nt_init_funcs->vga_hi_graph)();
                }
            }
            else
            {
                paint_screen = nt_paint_funcs->ega_hi_graph;
                (*nt_init_funcs->ega_hi_graph)();
            }
            break;

        case EGA_MED_FUN:
            assert1(NO, "Funny graphics mode %s", get_mode_string(mode));
            FunnyPaintMode = TRUE;
        case EGA_MED:
        case EGA_MED_WR:
        case EGA_MED_SP:
        case EGA_MED_SP_WR:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->ega_med_graph;
            (*nt_init_funcs->ega_med_graph)();
            break;

        case EGA_LO_FUN:
            assert1(NO, "Funny graphics mode %s", get_mode_string(mode));
            FunnyPaintMode = TRUE;
        case EGA_LO:
        case EGA_LO_WR:
        case EGA_LO_SP:
        case EGA_LO_SP_WR:
            sc.ModeType = GRAPHICS;
            paint_screen = nt_paint_funcs->ega_lo_graph;
            (*nt_init_funcs->ega_lo_graph)();
            break;

#endif // !NEC_98
        default:
            assert1(NO,"bad mode for host paint routine selection %d\n",(int)mode);
            paint_screen = dummy_paint_screen;
            break;
    }

#ifdef X86GFX
    /*
     * Display a message for the user if changing from a text mode to a
     * graphics mode while windowed. This is because graphics modes must be
     * run full-screen.
     */
     {
        /*
        ** Tim August 92. Do not want to do a TextToGraphics() during a
        ** full-screen to windowed transition. Otherwise the display gets
        ** set back to full-screen!
        */
#ifndef NEC_98
        extern int BlockModeChange; /* Tim August 92, in nt_fulsc.c */
        if ((BlockModeChange == 0) &&
            (sc.ScreenState == WINDOWED) &&
            (oldModeType == TEXT) &&
            (sc.ModeType == GRAPHICS))
        {
            SwitchToFullScreen(FALSE);
        }
        else
#endif // !NEC_98
        {

            /* No call to TextToGraphics() */
            check_win_size(height);
        }
     }
#else

    /*................................................... Apply mode change */
    check_win_size(height);
#endif  /* X86GFX */
    current_mode = mode;
}

#ifdef BIGWIN
/* creates lut for medium or high resolution bit map stretching */

static void
init_lut()

{
        long            i;

        for (i = 0; i < 256; i++)
        {
                horiz_lut[i] = ((tiny_lut[i & 3])
                                + (tiny_lut[(i >> 2) & 3] << 3)
                                + (tiny_lut[(i >> 4) & 3] << 6)
                                + (tiny_lut[(i >> 6) & 3] << 9));
        }
}


/* 8 bit lut version */
/* expands a high resolution bitmap by a half horizontally */

void high_stretch3(buffer, length)

unsigned char   *buffer;
int             length;
{
    int inp, outp;
    register long temp;

    outp = SCALE(length) - 1;

    for(inp = length - 1; inp > 0;)
    {
        temp = horiz_lut[buffer[inp]] | (horiz_lut[buffer[inp - 1]] << 12);
        inp -= 2;

        buffer[outp--] = (unsigned char) temp;
        buffer[outp--] = (unsigned char) (temp >> 8);
        buffer[outp--] = (unsigned char) (temp >> 16);
    }
}

void high_stretch4(buffer, length)

unsigned char *buffer;
int length;
{
    int inp, outp;
    word temp;

    outp = SCALE(length - 1);

    for(inp = length - 1; inp >= 0; inp--, outp -= 2)
    {
        temp = dubble_up[buffer[inp]];
        buffer[outp+1] = (unsigned char) (temp & 0xff);
        buffer[outp] = (unsigned char) ((temp >> 8) & 0xff);
    }
}
#endif                          /* BIGWIN */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Select paint routines :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static void select_paint_routines(void)
{
    /*::::::::::::::::::::::::::::::::::::::::::: Display trace information */

#ifndef NEC_98
    sub_note_trace2((CGA_HOST_VERBOSE | EGA_HOST_VERBOSE),
                    "select_paint_routine scale=%d depth=%d",
                    get_screen_scale(), host_display_depth);
#endif // !NEC_98

    /*::::::::::::::::::::::::::::::::::::::::::::::: Select paint routines */

#if defined(NEC_98)
    if(host_display_depth > 1){                // color mode
        nt_paint_funcs = &std_colour_paint_funcs;
        nt_init_funcs = &colour_init_funcs;
    }else{                                     // mono mode
        nt_paint_funcs = &std_mono_paint_funcs;
        nt_init_funcs = &mono_init_funcs;
    }
#else  // !NEC_98
    if(host_display_depth > 1)
    {
        if (get_screen_scale() == 2)
            nt_paint_funcs = &std_colour_paint_funcs;
        else if (get_screen_scale() == 3)
            nt_paint_funcs = &big_colour_paint_funcs;
        else
            nt_paint_funcs = &huge_colour_paint_funcs;

        nt_init_funcs = &colour_init_funcs;
    }
    else
    {
        if (get_screen_scale() == 2)
            nt_paint_funcs = &std_mono_paint_funcs;
        else if (get_screen_scale() == 3)
            nt_paint_funcs = &big_mono_paint_funcs;
        else
            nt_paint_funcs = &huge_mono_paint_funcs;

        nt_init_funcs = &mono_init_funcs;
    }
#endif // !NEC_98
}

#ifdef MONITOR
GLOBAL void select_frozen_routines(void)
{
#ifndef NEC_98
    if (get_screen_scale() == 2)
        nt_paint_funcs = &std_frozen_paint_funcs;
    else if (get_screen_scale() == 3)
        nt_paint_funcs = &big_frozen_paint_funcs;
    else
        nt_paint_funcs = &huge_frozen_paint_funcs;

    nt_init_funcs = &frozen_init_funcs;
#endif // !NEC_98
}
#endif /* MONITOR */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Prepare surface :::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void prepare_surface(void)
{
    CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;
    COORD coord;
    DWORD nCharWritten;

    sub_note_trace0(ALL_ADAPT_VERBOSE, "prepare surface");

    /*:::::::::::::::::::::::::::::: Get information on current screen size */

    GetConsoleScreenBufferInfo(sc.OutputHandle,&ScreenInfo);

    /*:::::::::::::::::::::::::::::::::::::::::::::::::::: Clear characters */

    coord.X = coord.Y = 0;
    FillConsoleOutputCharacter(sc.OutputHandle, ' ',
                               ScreenInfo.dwSize.X * ScreenInfo.dwSize.Y,
                               coord,&nCharWritten);

    /*:::::::::::::::::::::::::::::::::::::::::::::::::::: Clear Attributes */

    coord.X = coord.Y = 0;
    FillConsoleOutputAttribute(sc.OutputHandle, (WORD) sc.PCBackground,
                               ScreenInfo.dwSize.X * ScreenInfo.dwSize.Y,
                               coord,&nCharWritten);

}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Global function to tell anybody what the screen scale is :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int get_screen_scale(void)   { return(host_screen_scale); }

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Reverse word :::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

half_word reverser(register half_word value)
{
    return( (half_word)
            (((value & 1) << 7) |
            ((value & 2) << 5) |
            ((value & 4) << 3) |
            ((value & 8) << 1) |
            ((value & 16) >> 1) |
            ((value & 32) >> 3) |
            ((value & 64) >> 5) |
            ((value & 128) >> 7)));
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Check window size ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static void check_win_size(register int height)
{
    register int width;
    extern int soft_reset;

    if (! soft_reset)   // we want top get the chance to integrate with
        return;         // console before changing size

    /*:::::::::::::::::::::::::::::::::::::::::::::: Calculate screen width */

#if defined(NEC_98)
       width = NEC98_WIN_WIDTH;
#else  // !NEC_98
    if(sas_hw_at(vd_video_mode) > 0x10)
    {
        if(alpha_num_mode())
            width = get_chars_per_line() * get_pix_char_width();
        else
            width = get_chars_per_line() * get_char_width() *
                    (get_256_colour_mode() ? 2 : 1);
        if (width == 0)
            width = CGA_WIN_WIDTH;
    }
    else
       width = CGA_WIN_WIDTH;
#endif // !NEC_98

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::: Resize window */

    if (sc.ModeType == TEXT)
    {
        if((current_mode_type != TEXT) ||
           (get_char_height() != current_char_height) ||
           (current_height != height)  ||
           (current_width != width))
        {

            /* Get width and height. Note no SCALE for text modes. */
            sc.PC_W_Width = width;
            sc.PC_W_Height = height*get_host_pix_height();
            textResize();

            current_height = height;
            current_width = width;
            current_mode_type = TEXT;
            current_char_height = get_char_height();
        }
    }
    else
    {
        if((current_mode_type != GRAPHICS) ||
           (current_height != height) ||
           (current_width != width) ||
           (current_bits_per_pixel != sc.BitsPerPixel) ||
           (current_scale != host_screen_scale))
        {
            sc.PC_W_Width = SCALE(width);
            sc.PC_W_Height = SCALE(height*get_host_pix_height());
#ifndef NEC_98
            graphicsResize();
#endif // !NEC_98

            current_height = height;
            current_width = width;
            current_mode_type = GRAPHICS;
            current_bits_per_pixel = sc.BitsPerPixel;
            current_scale = host_screen_scale;
        }
    }

#if defined(NEC_98)
            graphicsResize();
#endif // NEC_98
    sc.CharHeight = current_char_height;

    /*::::::::::::::::::::::::::::::::::::::::::: Display trace information */

    sub_note_trace2(ALL_ADAPT_VERBOSE,
                    "check_win_size width = %d, height = %d",
                    width, height);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::: Set the VLT ??? ::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#if defined(NEC_98)
static  PALETTEENTRY    defaultpalette[20]=
{
    { 0x00,0x00,0x00,0x00 },       // 0
    { 0x80,0x00,0x00,0x00 },       // 1
    { 0x00,0x80,0x00,0x00 },       // 2
    { 0x80,0x80,0x00,0x00 },       // 3
    { 0x00,0x00,0x80,0x00 },       // 4
    { 0x80,0x00,0x80,0x00 },       // 5
    { 0x00,0x80,0x80,0x00 },       // 6
    { 0xC0,0xC0,0xC0,0x00 },       // 7
    {  192, 220, 192,   0 },       // 8
    {  166, 202, 240,   0 },       // 9
    {  255, 251, 240,   0 },       // 10
    {  160, 160, 164,   0 },       // 11
    { 0x80,0x80,0x80,0x00 },       // 12
    { 0xFF,0x00,0x00,0x00 },       // 13
    { 0x00,0xFF,0x00,0x00 },       // 14
    { 0xFF,0xFF,0x00,0x00 },       // 15
    { 0x00,0x00,0xFF,0x00 },       // 16
    { 0xFF,0x00,0xFF,0x00 },       // 17
    { 0x00,0xFF,0xFF,0x00 },       // 18
    { 0xFF,0xFF,0xFF,0x00 },       // 19
};

static  PALETTEENTRY    textpalette[8]=
{
    { 0x00,0x00,0x00,0x00 },       // BLACK
    { 0x00,0x00,0xFF,0x00 },       // BLUE
    { 0xFF,0x00,0x00,0x00 },       // RED
    { 0xFF,0x00,0xFF,0x00 },       // MAGENTA
    { 0x00,0xFF,0x00,0x00 },       // GREEN
    { 0x00,0xFF,0xFF,0x00 },       // CYAN
    { 0xFF,0xFF,0x00,0x00 },       // YELLOW
    { 0xFF,0xFF,0xFF,0x00 },       // WHITE
};

#endif // NEC_98
void set_the_vlt(void)
{
#if defined(NEC_98)
    PALETTEENTRY        NEC98_color[VGA_DAC_SIZE];
    unsigned long       ulLoop;
    BYTE                palRed,palGreen,palBlue;

    /*  set deault palette for PC-9821 display driver */
    palRed = palGreen = palBlue = 0;
    for( ulLoop=0 ; ulLoop<256 ; ulLoop++ ){
                NEC98_color[ulLoop].peRed   = palRed;
                NEC98_color[ulLoop].peGreen = palGreen;
        NEC98_color[ulLoop].peBlue  = palBlue;
        NEC98_color[ulLoop].peFlags = (BYTE)0x00;
        if (!(palRed   += 32))
        if (!(palGreen += 32))
        palBlue += 64;
        }

        /*      set SYSTEM color palette for Windows */
    for( ulLoop=0 ; ulLoop<10 ; ulLoop++ ){
        NEC98_color[ulLoop] = defaultpalette[ulLoop];
        NEC98_color[ulLoop+246]  = defaultpalette[ulLoop+10];
    }

        /*      set NEC98 TEXT color palette */
    for( ulLoop=0 ; ulLoop<8 ; ulLoop++ ){
        NEC98_color[ulLoop+16] = textpalette[ulLoop];
    }

        /*      set NEC98 GRAPH color palette */
        for( ulLoop=0 ; ulLoop<16 ; ulLoop++ ){
        NEC98_color[ulLoop+32] = NEC98Display.palette.data[ulLoop] ;
    }

     SetPaletteEntries(sc.ColPalette, 0, VGA_DAC_SIZE, &NEC98_color[0]);
     IDLE_video();
     set_palette_change_required(FALSE);

#else  // !NEC_98
    PALETTEENTRY vga_color[VGA_DAC_SIZE];
    int i, ind;
    byte mask, top_bit;

    /*::::::::::::::::: Map DAC specified colour value to Win32 palette */

    if(video_adapter == VGA)
    {
        if(get_256_colour_mode())
        {
            /*.......... In 256 colour mode, create new palette entries */

            for (i = 0; i < VGA_DAC_SIZE; i++)
            {
                ind = i & get_DAC_mask();

                vga_color[i].peFlags = 0;

                vga_color[i].peRed = (BYTE) (DAC[ind].red * 4);
                vga_color[i].peGreen = (BYTE) (DAC[ind].green * 4);
                vga_color[i].peBlue = (BYTE) (DAC[ind].blue * 4);
            }

            /*..................... Apply new colours to output palette */

            SetPaletteEntries(sc.ColPalette, 0, VGA_DAC_SIZE, &vga_color[0]);

            /* Progs that cycle the DACs get hit by idle detect unless..*/

            IDLE_video();
        }
        else
        {
            /* if not in 256 colour mode then... if bit 7 of attr mode
               register set then... video bits 7 & 6 = bits 3 & 2 of pixel
               padding reg ('top_bit') video bits 5-0 from palette reg.
               (establish by 'mask') if bit 7 of attr mode register clear
               then... video bits 7 - 4 = bits 3 - 0 of pixel padding reg
               ('top_bit') video bits 3-0 from palette reg. (establish by
               'mask') */

            /*.................................... Set mask and top bit */

            if(get_colour_select())
            {
                mask = 0xf;
                top_bit = (byte) ((get_top_pixel_pad() << 6)
                          | (get_mid_pixel_pad() << 4));
            }
            else
            {
                mask = 0x3f;
                top_bit = (byte) (get_top_pixel_pad() << 6);
            }

            /*..................... Construct new Win32 palette entries */

            for (i = 0; i < VGA_DAC_SIZE; i++)
            {
                /*...................... Calculate palette index number */

                ind = i & host_plane_mask;

                /*
                 * If attribute controller, mode select, blink bit set in
                 * graphics mode, pixels 0-7 select palette entries 8-15
                 * i.e. bit 3, 0->1.
                 */
                if ((sc.ModeType == GRAPHICS) && (bg_col_mask == 0x70))
                    ind |= 8;

                ind = get_palette_val(ind);
                ind = top_bit | (ind & mask);
                ind &= get_DAC_mask();

                /*........................ Construct next palette entry */

                vga_color[i].peFlags = 0;
                vga_color[i].peRed = (BYTE) (DAC[ind].red * 4);
                vga_color[i].peGreen = (BYTE) (DAC[ind].green * 4);
                vga_color[i].peBlue = (BYTE) (DAC[ind].blue * 4);
            }

            SetPaletteEntries(sc.ColPalette, 0, VGA_DAC_SIZE, &vga_color[0]);
        }

        set_palette_change_required(FALSE);
    }
#endif // !NEC_98

    /*::::::::::::::::::::::::::::::::::::::::::::::::::::: Display changes */

#if defined(NEC_98)
    if(sc.ScreenBufHandle && sc.ModeType == GRAPHICS)
    {
        /*
        ** For extra safety, cos set_the_vlt() can get called in text mode.
        */

        {
            INPUT_RECORD InputRecord[128];
            DWORD RecordsRead;
            if(GetNumberOfConsoleInputEvents(sc.InputHandle, &RecordsRead))
                if (RecordsRead)
                    ReadConsoleInputW(sc.InputHandle,
                                         &InputRecord[0],
                                         sizeof(InputRecord)/sizeof(INPUT_RECORD),
                                         &RecordsRead);
           if( !SetConsoleActiveScreenBuffer( sc.ScreenBufHandle ) ){
                    assert2( NO, "VDM: SCASB() failed:%#x H=%#x",
                             GetLastError(), sc.ScreenBufHandle );
                    return;
            }
            sc.ActiveOutputBufferHandle = sc.ScreenBufHandle;
            if (RecordsRead)
                WriteConsoleInputW(sc.InputHandle,
                                     &InputRecord[0],
                                     RecordsRead,
                                     &RecordsRead);
        }
        if(!SetConsolePalette(sc.ScreenBufHandle, sc.ColPalette, SYSPAL_STATIC))
            assert1( NO, "SetConsolePalette() failed:%#x\n", GetLastError() );
    }
    else if(sc.ScreenBufHandle && NowFreeze == TRUE)
    {
        /*
        ** For extra safety, cos set_the_vlt() can get called in text mode.
        */
        {
            INPUT_RECORD InputRecord[128];
            DWORD RecordsRead;
            if(GetNumberOfConsoleInputEvents(sc.InputHandle, &RecordsRead))
                if (RecordsRead)
                    ReadConsoleInputW(sc.InputHandle,
                                         &InputRecord[0],
                                         sizeof(InputRecord)/sizeof(INPUT_RECORD),
                                         &RecordsRead);
            if( !SetConsoleActiveScreenBuffer( sc.ScreenBufHandle ) ){
                    assert2( NO, "VDM: SCASB() failed:%#x H=%#x",
                             GetLastError(), sc.ScreenBufHandle );
                    return;
            }
            if (RecordsRead)
                WriteConsoleInputW(sc.InputHandle,
                                     &InputRecord[0],
                                     RecordsRead,
                                     &RecordsRead);
        }
        if(!SetConsolePalette(sc.ScreenBufHandle, sc.ColPalette, SYSPAL_STATIC))
            assert1( NO, "SetConsolePalette() failed:%#x\n", GetLastError() );
    }
#else  // !NEC_98
    if (sc.ScreenBufHandle)             // only sensible in gfx context
    {
        /*
        ** For extra safety, cos set_the_vlt() can get called in text mode.
        */
        if( !SetConsoleActiveScreenBuffer( sc.ScreenBufHandle ) ){
                assert2( NO, "VDM: SCASB() failed:%#x H=%#x",
                         GetLastError(), sc.ScreenBufHandle );
                return;
        }
        if(!SetConsolePalette(sc.ScreenBufHandle, sc.ColPalette, SYSPAL_STATIC))
            assert1( NO, "SetConsolePalette() failed:%#x\n", GetLastError() );
    }
#endif // !NEC_98

    update_vlt = FALSE;
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::: Set screen sizes - update the screen description structure :::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#if defined(NEC_98)
static void set_screen_sizes()
#else  // !NEC_98
static void set_screen_sizes(int adaptor)
#endif // !NEC_98
{
#if defined(NEC_98)
        sc.PC_W_Width = SCALE(NEC98_WIN_WIDTH);
        sc.PC_W_Height = SCALE(NEC98_WIN_HEIGHT);
        sc.CharWidth = SCALE(NEC98_CHAR_WIDTH);
        sc.CharHeight = SCALE(NEC98_CHAR_HEIGHT);
#else  // !NEC_98
    UNUSED(adaptor);

    sc.PC_W_Width = SCALE(CGA_WIN_WIDTH);
    sc.PC_W_Height = SCALE(CGA_WIN_HEIGHT);
    sc.CharWidth = CGA_CHAR_WIDTH;
    sc.CharHeight = CGA_CHAR_HEIGHT;
#endif // !NEC_98
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::; Change to plane mask ::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_change_plane_mask(int plane_mask)
{
        if (host_plane_mask != plane_mask)  host_plane_mask = 0xf;

        update_vlt = TRUE;
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::: Dummy Paint Routines for all the IBM screen modes :::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static void dummy_paint_screen(int offset, int host_x, int host_y,
                                           int width, int height)
{
    UNUSED(offset);
    UNUSED(host_x);
    UNUSED(host_y);
    UNUSED(width);
    UNUSED(height);

    sub_note_trace5((CGA_HOST_VERBOSE | EGA_HOST_VERBOSE),
                    "dummy_paint_screen off=%d x=%d y=%d width=%d h=%d",
                    offset, host_x, host_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: Set downloaded font ???? :::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_set_downloaded_font(int value)
{
    UNUSED(value);

    sub_note_trace1((CGA_HOST_VERBOSE | EGA_HOST_VERBOSE),
                    "host_set_downloaded_font value=%d", value);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::: Free Font ::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_free_font(int index)
{
    UNUSED(index);

    sub_note_trace0(EGA_HOST_VERBOSE,"nt_free_font - NOT SUPPORTED");
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::: Select font :::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_select_fonts(int font1, int font2)
{
    UNUSED(font1);
    UNUSED(font2);

    sub_note_trace0(EGA_HOST_VERBOSE,"nt_select_fonts - NOT SUPPORTED");
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Update fonts ::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_update_fonts(void) { }

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Set palette :::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_set_palette(PC_palette *palette, int size)
{
    UNUSED(palette);
    UNUSED(size);

    sub_note_trace0(EGA_HOST_VERBOSE,"nt_set_palette - NOT SUPPORTED");
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Set screen scale ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_set_screen_scale(int scale)
{
    if (scale != host_screen_scale)
    {
        host_screen_scale = scale;

        /*
         * Don't want to do any painting if this is called on initialisation
         * and sc.PC_W_Width is as good a variable as any to check for this.
         */
        if (sc.PC_W_Width)
        {
            select_paint_routines();
            nt_set_paint_routine(current_mode, current_height);
            nt_mark_screen_refresh();
        }
    }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::: Set border colour ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_set_border_colour(int colour)
{
    UNUSED(colour);

    sub_note_trace0(ALL_ADAPT_VERBOSE,"nt_set_border_colour - NOT SUPPORTED");
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Resize window :::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*
*****************************************************************************
** windowSize() resizes the console window to the specified height and width.
*****************************************************************************
** Called from resizeWindow() below.
*/
VOID windowSize IFN4( int, w, int, h, int, top, int, left )
{
        SMALL_RECT WinSize;

        WinSize.Top    = (SHORT)top;
        WinSize.Left   = (SHORT)left;
        WinSize.Bottom = top  + h - 1;
        WinSize.Right  = left + w - 1;

#ifndef PROD
        //fprintf(trace_file, "newW: %d.%d at %d.%d\n", h, w, top, left);
#endif
        if( !SetConsoleWindowInfo( sc.OutputHandle, TRUE, &WinSize ) )
                assert3( NO, "VDM: SetConsoleWindowInfo() w=%d h=%d failed:%#x",
                        w, h, GetLastError() );
}

/*
*****************************************************************************
** bufferSize() resizes the console buffer to the specified height and width.
*****************************************************************************
** Called from resizeWindow() below.
*/
VOID bufferSize IFN2( int, w, int, h )
{
        COORD      ScrSize;

        ScrSize.X = (SHORT)w;
        ScrSize.Y = (SHORT)h;
#ifndef PROD
        //fprintf(trace_file, "newB: %d.%d\n", h, w);
#endif
        if( !SetConsoleScreenBufferSize( sc.OutputHandle, ScrSize ) )
                assert3( NO, "VDM: SetCons...BufferSize() w=%d h=%d failed:%#x",
                        w, h, GetLastError() );
}

/*
*****************************************************************************
* resizeWindow()
*****************************************************************************
* Sizes the console window and buffer as appropriate.
*
* The buffer must be able at all times to keep everything displayed
* in the window.
* So we check if the displayed portion would fall out of the buffer
* and shrink the window appropriately.
*
* Then allocate the new buffer.  This may affect the maximum window
* size, so retrieve these values.
*
* Now the desired proportions of the Window are clipped to the
* (eventually just updated) maximum, and if different from what
* we have already, the change is made.
*
* In order to keep "screen flashing" to a minimum, try to restore
* the displayed portion (top and left) of the buffer.
*/
VOID resizeWindow IFN2( int, w, int, h )
{
#define MIN(a,b)        ((a)<(b)?(a):(b))

        int     oldTop, oldLeft;        /* present values       */
        int     newTop, newLeft;/* new values           */
        COORD   oldW,           /* present window size  */
                oldB;           /* present buffer size  */
        CONSOLE_SCREEN_BUFFER_INFO bufferInfo;

#if defined(JAPAN) || defined(KOREA)
        // Clipping Window height
        if ( GetConsoleCP() != 437 ) {
        // if ( !is_us_mode() ) {  // Didn't come BOP
            if( h > 25 ){
                /* Shouldn't get this anymore said Tim */
#ifdef JAPAN_DBG
                DbgPrint( "NTVDM: resizeWindow() clipping height:%d->25\n", h  );
#endif
                h = 25;
            }
        } else
#endif // JAPAN || KOREA
        if( h > 50 ){
                /* Shouldn't get this anymore said Tim */
                assert1( NO, "VDM: resizeWindow() clipping height:%d", h  );
                h = 50;
        }
        if( !GetConsoleScreenBufferInfo( sc.OutputHandle, &bufferInfo) )
                assert1( NO, "VDM: GetConsoleScreenBufferInfo() failed:%#x",
                        GetLastError() );

        oldTop  = bufferInfo.srWindow.Top;
        oldLeft = bufferInfo.srWindow.Left;

        oldW.X  = bufferInfo.srWindow.Right  - bufferInfo.srWindow.Left + 1;
        oldW.Y  = bufferInfo.srWindow.Bottom - bufferInfo.srWindow.Top  + 1;
        oldB    = bufferInfo.dwSize;
#ifndef PROD
        //fprintf(trace_file, "resz: %d.%d\n", h, w);
        //fprintf(trace_file, "oldW: %d.%d\n", oldW.Y, oldW.X);
        //fprintf(trace_file, "maxW: %d.%d\n", bufferInfo.dwMaximumWindowSize.Y, bufferInfo.dwMaximumWindowSize.X);
        //fprintf(trace_file, "oldB: %d.%d\n", oldB.Y, oldB.X);
#endif
        /*
         * Reduce window width and height as necessary:
         */
        if (    bufferInfo.srWindow.Bottom >= h
             || bufferInfo.srWindow.Right  >= w ) {
                windowSize( MIN(w,oldW.X), MIN(h,oldW.Y), 0, 0);
        }

        /*
         * Change Buffer width and height as required.
         */
        if ( oldB.X || h != oldB.Y ) {
                bufferSize( w, h );

                /*
                 * This increase in Buffer size may have affected maximum
                 * possible window sizes:
                 */
                if( !GetConsoleScreenBufferInfo( sc.OutputHandle, &bufferInfo) )
                        assert1( NO, "VDM: GetConsoleScreenBufferInfo() failed:%#x",
                                GetLastError() );
#ifndef PROD
                //fprintf(trace_file, "maxW: %d.%d\n", bufferInfo.dwMaximumWindowSize.Y, bufferInfo.dwMaximumWindowSize.X);
#endif
        }
        /*
        ** Clip requested values to Window maximum and
        ** compute new (possible) top and left values.
        */

        newLeft = w - bufferInfo.dwMaximumWindowSize.X;
        if ( newLeft > 0 ) {
                w = bufferInfo.dwMaximumWindowSize.X;
        } else
                newLeft = 0;

        newTop = h - bufferInfo.dwMaximumWindowSize.Y;
        if ( newTop > 0 ) {
                h = bufferInfo.dwMaximumWindowSize.Y;
        } else
                newTop = 0;

#if defined(NEC_98)
        if(get_char_height() == 20) h = 20;
#endif // !NEC_98
        /*
         * Check if we need to enlarge the window now.
         * Settle for old top and left if they were smaller.
         * This avoids unnecessary updates in the window.
         */
        if ( w > oldW.X || h > oldW.Y )
                windowSize( w, h, MIN(newTop,oldTop), MIN(newLeft,oldLeft) );

} /* end of resizeWindow() */

/*
** Controls the size of the window when in a text mode.
** scale=2 selects normal (small) size
** scale=3 selects bit 1.5x
** If this function is called before the SoftPC window has been created,
** the "sv_screen_scale" variable needs to be changed. This governs
** the SCALE() macro, which is used just to specify the window
** dimensions at creation. If the SoftPC window already exists then the
** size is changed by a more complex sequence.
*/

//Used by the text paint functions
#if defined(NEC_98)
GLOBAL int now_height = 25, now_width = 80;
#else  // !NEC_98
GLOBAL int now_height = 80, now_width = 50;
#endif // !NEC_98

void textResize(void)
{

    if(sc.PC_W_Height && sc.PC_W_Width &&
       get_host_char_height() && get_pix_char_width())
    {
        now_height = sc.PC_W_Height/get_host_char_height();
        now_width = sc.PC_W_Width / get_pix_char_width();

        select_paint_routines();
        nt_change_mode();

        resizeWindow(now_width, now_height); /* Tim, September 92 */
     }
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::                                                                      ::*/
/*:: graphicsResize:                                                      ::*/
/*::                                                                      ::*/
/*:: Resize SoftPC window when in a graphics mode by selecting a new      ::*/
/*:: active screen buffer.                                                ::*/
/*::                                                                      ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void graphicsResize(void)
{
        DWORD    headerSize;
        LPBITMAPINFO     infoStructPtr;

#if defined(NEC_98)
        HANDLE   saveHandle;
#else  // !NEC_98
        if (sc.ScreenState == FULLSCREEN)
            return;
#endif // !NEC_98

        /* Destroy previous data. */
        closeGraphicsBuffer(); /* Tim Oct 92 */

        if (sc.ConsoleBufInfo.lpBitMapInfo != NULL)
            free((char *) sc.ConsoleBufInfo.lpBitMapInfo);

        /*
         * Create a `BITMAPINFO' structure - sc.PC_W_Width pixels x
         * sc.PC_W_Height pixels x sc.BitsPerPixel bits-per-pixel.
         */
#if defined(NEC_98)
        headerSize = CreateSpcDIB(640,             // screen width
                                  400,             // screen height
                                  8,               // bits-per-pixel
                                  DIB_PAL_COLORS,
                                  0,
                                  (COLOURTAB *) NULL,
                                  &infoStructPtr);
#else  // !NEC_98
        headerSize = CreateSpcDIB(sc.PC_W_Width,
                                  sc.PC_W_Height,
                                  sc.BitsPerPixel,
                                  DIB_PAL_COLORS,
                                  0,
                                  (COLOURTAB *) NULL,
                                  &infoStructPtr);
#endif // !NEC_98

        /* Initialise the console info structure. */
        sc.ConsoleBufInfo.dwBitMapInfoLength = headerSize;
        sc.ConsoleBufInfo.lpBitMapInfo = infoStructPtr;
        sc.ConsoleBufInfo.dwUsage = DIB_PAL_COLORS;

        /* Create a screen buffer using the above `BITMAPINFO' structure. */
        sc.ScreenBufHandle =
            CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL,
                                      CONSOLE_GRAPHICS_BUFFER,
                                      &sc.ConsoleBufInfo);

        if (sc.ScreenBufHandle == (HANDLE)-1)
        {
            sc.ScreenBufHandle = NULL;
            assert1( NO, "VDM: graphics screen buffer creation failed:%#x\n",
                                GetLastError());
        }

        /* 'cos old palette discarded with close buffer */
        if (sc.ColPalette == (HPALETTE)0)
        {
            CreateDisplayPalette();
            set_palette_change_required(TRUE);
        }

#if defined(NEC_98)
        saveHandle = sc.ActiveOutputBufferHandle;
#endif // NEC_98
        /* save the handle away to a useful place */
        MouseDetachMenuItem(TRUE);
        sc.ActiveOutputBufferHandle = sc.ScreenBufHandle;
        MouseAttachMenuItem(sc.ActiveOutputBufferHandle);
#if defined(NEC_98)
        sc.ActiveOutputBufferHandle = saveHandle;
#endif // NEC_98

        /*
         * Make it the current screen buffer, which resizes the window
         * on the display.
         */
#if defined(NEC_98)
    if(sc.ModeType == GRAPHICS || sc.ScreenState == FULLSCREEN)
    {
        INPUT_RECORD InputRecord[128];
        DWORD RecordsRead;
        if(GetNumberOfConsoleInputEvents(sc.InputHandle, &RecordsRead))
            if (RecordsRead)
                ReadConsoleInputW(sc.InputHandle,
                                     &InputRecord[0],
                                     sizeof(InputRecord)/sizeof(INPUT_RECORD),
                                     &RecordsRead);
#endif // NEC_98
        SetConsoleActiveScreenBuffer(sc.ScreenBufHandle);
#if defined(NEC_98)
        sc.ActiveOutputBufferHandle = sc.ScreenBufHandle;
        if (RecordsRead)
            WriteConsoleInputW(sc.InputHandle,
                                 &InputRecord[0],
                                 RecordsRead,
                                 &RecordsRead);
    }
#endif // !NEC_98

        /*
         * Get a pointer to the last line of the bitmap to build
         * upside-down pictures.
         */
        sc.BitmapLastLine = (char *) sc.ConsoleBufInfo.lpBitMap +
            (sc.PC_W_Height - 1) *
            BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::                                                                      ::*/
/*:: CreateSpcDIB:                                                        ::*/
/*::                                                                      ::*/
/*:: Create a new SoftPC device independent bitmap.                       ::*/
/*:: Parameters:                                                          ::*/
/*::    width           - width of the bitmap in pixels.                  ::*/
/*::    height          - height of the bitmap in pixels.                 ::*/
/*::    bitsPerPixel    - number of bits representing one pixel in the    ::*/
/*::                      bitmap.                                         ::*/
/*::    wUsage          - type of bitmap to create, can be DIB_PAL_COLORS,::*/
/*::                      DIB_RGB_COLORS or DIB_PAL_INDICES.              ::*/
/*::    DIBColours      - Only interrogated for DIB_RGB_COLORS bitmaps,   ::*/
/*::                      defines the number of entries in the colour     ::*/
/*::                      table. If set to USE_COLOURTAB the colour table ::*/
/*::                      contains the same number of entries as the      ::*/
/*::                      `colours' table, otherwise DIBColours contains  ::*/
/*::                      the actual number of entries to be used.        ::*/
/*::    colours         - Only interrogated for DIB_RGB_COLORS bitmaps,   ::*/
/*::                      points to a COLOURTAB structure which contains  ::*/
/*::                      the RGB values to be loaded into the bitmap's   ::*/
/*::                      colour table.                                   ::*/
/*::    infoPtr         - The address in which to return a pointer to the ::*/
/*::                      BITMAPINFO structure allocated by this routine. ::*/
/*::                                                                      ::*/
/*:: Return value:                                                        ::*/
/*::        The size of the BITMAPINFO structure allocated on success, -1 ::*/
/*::    on failure.                                                       ::*/
/*::                                                                      ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL DWORD CreateSpcDIB(int width, int height, int bitsPerPixel,
                          WORD wUsage, int DIBColours,
                          COLOURTAB *colours, BITMAPINFO **infoPtr)
{
    PBITMAPINFO     pDibInfo;       /* Returned data structure. */
    int             i,              /* Counting variable. */
                    maxColours,     /* Maximum number of colours. */
                    coloursUsed,    /* Value to be put in biClrUsed field. */
                    nActualColours, /* Number of colours in RGB_COLOURS bitmap. */
                    tabSize;        /* Size of colour table to allocate. */
    DWORD           allocSize;      /* Total size to allocate. */

    /* Work out size of DIB colour table. */
    maxColours = 1 << bitsPerPixel;
    switch (wUsage)
    {

    case DIB_PAL_COLORS:
        tabSize = maxColours * sizeof(WORD);
        coloursUsed = 0;
        break;

    case DIB_RGB_COLORS:
        if (colours == NULL)
            return((DWORD) -1);
        nActualColours = (DIBColours == USE_COLOURTAB) ?
                            colours->count :
                            DIBColours;
        tabSize = nActualColours * sizeof(RGBQUAD);
        coloursUsed = nActualColours;
        break;

    case DIB_PAL_INDICES:
        tabSize = 0;
        coloursUsed = 0;
        break;

    default:
        always_trace0("Illegal wUsage parameter passed to CreateSpcDIB.");
        return((DWORD) -1);

    }

    /* Allocate space for the BITMAPINFO structure. */
    allocSize = sizeof(BITMAPINFOHEADER) + tabSize;
    check_malloc(pDibInfo, allocSize, BITMAPINFO);

    /* Initialise BITMAPINFOHEADER. */
    pDibInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pDibInfo->bmiHeader.biWidth = width;
    pDibInfo->bmiHeader.biHeight = -height;
    pDibInfo->bmiHeader.biPlanes = 1;
    pDibInfo->bmiHeader.biBitCount = (WORD) bitsPerPixel;
    pDibInfo->bmiHeader.biCompression = BI_RGB;
    pDibInfo->bmiHeader.biSizeImage = width * height / 8 * bitsPerPixel;
    pDibInfo->bmiHeader.biXPelsPerMeter = 0;
    pDibInfo->bmiHeader.biYPelsPerMeter = 0;
    pDibInfo->bmiHeader.biClrUsed = coloursUsed;
    pDibInfo->bmiHeader.biClrImportant = 0;

    /* Initialise colour table. */
    switch (wUsage)
    {

    case DIB_PAL_COLORS:

        /*
         * Colour table is an array of WORD indexes into currently realized
         * palette.
         */
        for (i = 0; i < maxColours; i++)
            ((WORD *) pDibInfo->bmiColors)[i] = (WORD) i;
        break;

    case DIB_RGB_COLORS:

        /*
         * Colour table is an array of RGBQUAD structures. If the `colours'
         * array contains fewer than `nActualColours' entries the colour
         * table will not be completely filled. In this case `colours' is
         * repeated until the table is full.
         */
        for (i = 0; i < nActualColours; i++)
        {
            pDibInfo->bmiColors[i].rgbBlue  =
                colours->blue[i % colours->count];
            pDibInfo->bmiColors[i].rgbGreen =
                colours->green[i % colours->count];
            pDibInfo->bmiColors[i].rgbRed   =
                colours->red[i % colours->count];
            pDibInfo->bmiColors[i].rgbReserved = 0;
        }
        break;

    case DIB_PAL_INDICES:

        /* No colour table DIB uses system palette. */
        break;

    default:
        break;

    }
    *infoPtr = pDibInfo;
    return(allocSize);
}


/* Holding place for stub functions */

void nt_mode_select_changed(int dummy)
{
    UNUSED(dummy);
#ifndef PROD
    fprintf(trace_file, "WARNING - nt_mode_select_changed\n");
#endif
}

void nt_color_select_changed(int dummy)
{
    UNUSED(dummy);
#ifndef PROD
    fprintf(trace_file, "WARNING - nt_color_select_changed\n");
#endif
}

void nt_screen_address_changed(int lo, int hi)
{
    UNUSED(lo);
    UNUSED(hi);

    sub_note_trace0(EGA_HOST_VERBOSE, "WARNING - nt_screen_address_changed\n");
}

void nt_scroll_complete()        { }


void host_stream_io_update(half_word * buffer, word count)
{
    DWORD dwBytesWritten;

    WriteConsoleA(sc.OutputHandle,
                  buffer,
                  count,
                  &dwBytesWritten,
                  NULL
                  );
    flush_count = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_hosts.c ===
/***************************************************************************
 *                                                                         *
 *  PROGRAM     : HOST_UIS.c                                               *
 *                                                                         *
 *  PURPOSE     : Host UI code                                             *
 *                                                                         *
 ****************************************************************************/


#include <windows.h>
#include "conapi.h"
#include "insignia.h"
#include "host_def.h"

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include <stdio.h>
#include "trace.h"
#include "debug.h"
#include "host_rrr.h"

#include "nt_graph.h"
#include "nt_event.h"
#include "nt_uis.h"
#include "nt_reset.h"

#ifdef HUNTER
#include "nt_hunt.h"
#endif /*HUNTER*/

#if defined(JAPAN) || defined(KOREA)
#include "video.h"
#endif // JAPAN || KOREA
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::: Global variables */

HANDLE InstHandle;


CONSOLE_CURSOR_INFO StartupCursor;

#ifdef DBCS
#if defined(JAPAN) || defined(KOREA)
UINT ConsoleInputCP;
UINT ConsoleOutputCP;
DWORD ConsoleNlsMode;         // 32bit IME disable and enable

// for GetStringBitmap() in video.c
HDC hdcVDM;
HFONT hFont16;
HFONT hFont24;

#endif // JAPAN || KOREA
extern BOOL VDMForWOW;
#endif // DBCS
/*:::::::::::::::::::::::::::::::::::::::: Fast graphics associated defines */

BYTE Red[] = {   0,   0,   0,   0, 128, 128, 128, 192, 128,   0,   0,
                         0, 255, 255, 255, 255 };

BYTE Green[]={   0,   0, 128, 128,   0, 0, 128, 192, 128,   0, 255,
                       255,   0,   0, 255, 255 };

BYTE Blue[] ={   0, 128,   0, 128,   0, 128,   0, 192, 128, 255,   0,
                       255,   0, 255,   0, 255 };

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: External functions */

LONG nt_process_event(HWND hWnd, WORD message, LONG wParam, LONG lParam);

/*::::::::::::::::::::::::::::::::::::::::::::: Internal function protocols */

BOOL SoftInit(void);
WORD HeartBeat(HWND hWnd, WORD msg, int nIDEvent, DWORD dwTime);

PSTR String(WORD StrResID);
void InitScreenDesc(void);

#ifdef HUNTER
void HunterMenuMake(void);
#endif /* HUNTER */

#if defined(JAPAN) || defined(KOREA)
// Create 24dot font
void CreateVDMFont( HDC hdc );
void GetLogFont( int size, LOGFONT *lplf );
#endif // JAPAN || KOREA
HANDLE   SCS_hStdIn=0;
HANDLE   SCS_hStdOut=0;
HANDLE   SCS_hStdErr=0;

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : init_host_uis()                                            *
 *                                                                          *
 *  PURPOSE    : Creates the main app. window, calls an initialization      *
 *               functions                                                  *
 *                                                                          *
 ****************************************************************************/

int init_host_uis()
{
    InitScreenDesc();

    if(CreateDisplayPalette())
    {
        SelectPalette(sc.DispDC,sc.ColPalette,0);/* Select foreground palette */
    }

    return(1);
}

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : SetupConsoleMode()                                         *
 *                                                                          *
 *  PURPOSE    : Setup console mode and get handles                         *
 *                                                                          *
 ****************************************************************************/

void SetupConsoleMode(void)
{
    DWORD mode;

#ifdef DBCS
#include "error.h"

    LANGID LangID;

    LangID = GetSystemDefaultLangID();

    //if ((LangID == 0x404 || LangID == 0x804) && !VDMForWOW) {
    //Chinese
    if (((BYTE)LangID == 0x04) && !VDMForWOW) {
        if (GetConsoleCP() != 437) {

            CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;
            COORD coord;
            DWORD nCharWritten;

            //host_error(ED_UNSUPPORT_CP, ERR_QUIT, "");

    /*::::::::::::::::::::::::::::: Get information on current screen size */

            GetConsoleScreenBufferInfo(sc.OutputHandle,&ScreenInfo);

    /*::::::::::::::::::::::::::::::::::::::::::::::::::: Clear characters */

            coord.X = coord.Y = 0;

            SetConsoleCursorPosition(sc.OutputHandle, coord);

            FillConsoleOutputCharacter(sc.OutputHandle, ' ',
                          ScreenInfo.dwSize.X * ScreenInfo.dwCursorPosition.Y,
                                coord,&nCharWritten);

            SetConsoleCP(437);
            SetConsoleOutputCP(437);

        }
    }
#endif
#if defined(JAPAN) || defined(KOREA)
#ifdef i386
#ifndef NEC_98
    {
        extern int FromConsoleOutputFlag;

        FromConsoleOutputFlag = FALSE;
    }
#endif // !NEC_98
#endif // i386
    // 32bit IME disable
    if ( !VDMForWOW ) {
      if ( GetConsoleNlsMode( sc.InputHandle, &ConsoleNlsMode ) ) {
        //DbgPrint( "NTVDM: GetConsoleMode %x, %08x\n", sc.InputHandle, ConsoleNlsMode );
        if ( SetConsoleNlsMode( sc.InputHandle, ConsoleNlsMode | NLS_IME_DISABLE ) ) {
            //DbgPrint( "NTVDM: 32bit IME disable %08x Success\n", ConsoleNlsMode | NLS_IME_DISABLE );
        }
        else {
            DbgPrint( "NTVDM: SetConsoleNlsMode Error %08x\n", GetLastError() );
        }
      }
    }
    /*::::::::::::::::::::::::::::::::::::::::::: Set console input/output code page */
#ifndef NEC_98

    ConsoleInputCP = GetConsoleCP();
    ConsoleOutputCP = GetConsoleOutputCP();

    {
        static int FirstStartFlag = TRUE;

        if ( FirstStartFlag ) {

            if ( !VDMForWOW ) {
#ifdef JAPAN_DBG
                DbgPrint("NTVDM: Create hdc for NTFONT\n" );
#endif
                hdcVDM = CreateDC( "DISPLAY", NULL, NULL, NULL );
                CreateVDMFont( hdcVDM );
                //SelectObject( hdcVDM, GetStockObject(OEM_FIXED_FONT) );
            }
            FirstStartFlag = FALSE;
        }
        else {
            if ( BOPFromDispFlag ) {
                if ( ConsoleInputCP == 437 && ConsoleOutputCP == 437 ) {
                    //DbgPrint( "CP473->437, DBCSVectorReset\n" );
                    SetDBCSVector( 437 );
                    SetVram();
                }
                else if ( ConsoleInputCP != 437 && ConsoleOutputCP != 437 ) {
                    //DbgPrint( "CP932->932, DBCSVectorSet\n" );
                    SetDBCSVector( ConsoleInputCP );
                    SetVram();
                }
                else {
                    DbgPrint( "NTVDM: InputCP != OutputCP \n" );
                }
            }
            else {
                SetConsoleCP( 437 );
                SetConsoleOutputCP( 437 );

                SetDBCSVector( 437 );
                SetVram();
            }
        }
    }
#endif // !NEC_98
#endif // JAPAN || KOREA
    /*::::::::::::::::::::::::::::::::::::::::::: Set console input mode */

    if(!GetConsoleMode(sc.InputHandle, &sc.OrgInConsoleMode))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#ifndef NEC_98
    mode = sc.OrgInConsoleMode &
           ~(ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT);
    if (!host_stream_io_enabled)
        mode |= (ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT);
#else //NEC_98
    mode = (sc.OrgInConsoleMode | ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT)&
           ~(ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT);
#endif //NEC_98
    /*.............................................. Set new console mode */

    if(!SetConsoleMode(sc.InputHandle,mode))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);
    /*::::::::::::::::::::::::::::::::::::::::::: Set console output mode */

    if(!GetConsoleMode(sc.OutputHandle, &sc.OrgOutConsoleMode))
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    /*.............................................. Set new console mode */

#if defined(NEC_98)
// STREAM_IO codes are disabled now till Beta-1
    if(!stdoutRedirected)
#else  // !NEC_98
    if(!stdoutRedirected && !host_stream_io_enabled)
#endif // !NEC_98
    {
        mode = sc.OrgOutConsoleMode &
               ~(ENABLE_WRAP_AT_EOL_OUTPUT | ENABLE_PROCESSED_OUTPUT);

       if(!SetConsoleMode(sc.OutputHandle,mode))
          DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);
    }

    if(!GetConsoleCursorInfo(sc.OutputHandle, &StartupCursor))
    {
        assert1(NO, "NTVDM:can't get initial cursor size. Err %d", GetLastError());
        /* add own defaults */
        StartupCursor.dwSize = 20;
        StartupCursor.bVisible = TRUE;
    }

#if !defined(JAPAN) && !defined(KOREA)
    if (!EventThreadKeepMode)
    {
#endif // !JAPAN && !KOREA
        if(!GetConsoleScreenBufferInfo(sc.OutputHandle, &sc.ConsoleBuffInfo))
            DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(), __FILE__,__LINE__);
#if !defined(JAPAN) && !defined(KOREA)
    }
#endif // !JAPAN && !KOREA

}


/****************************************************************************
 *                                                                          *
 *  FUNCTION   : InitScreenDesc                                             *
 *                                                                          *
 *  PURPOSE    : Initialise screen description structure                    *
 *                                                                          *
 ****************************************************************************/

void InitScreenDesc(void)
{
SECURITY_ATTRIBUTES sa;

    /*::::::::::::::::::::::::::::::::::::::::::: Get console output handle */

    if((sc.OutputHandle = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE)
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
    //
    // Save this handle as the active handle until a new one is
    // selected.
    //

    sc.ActiveOutputBufferHandle = sc.OutputHandle;
    sc.ScreenBufHandle = (HANDLE)0;

    /*:::::::::::::::::::::::::::::::::::::::::::: Get console input handle */

    if((sc.InputHandle = GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE)
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);

    /*:::::::::::::::::::::::::::::: check out if stdin has been redirected */

    if(GetFileType(sc.InputHandle) != FILE_TYPE_CHAR)
    {
       sa.nLength = sizeof (SECURITY_ATTRIBUTES);
       sa.lpSecurityDescriptor = NULL;
       sa.bInheritHandle = TRUE;
       sc.InputHandle = CreateFile("CONIN$",GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_WRITE | FILE_SHARE_READ,
                                   &sa,OPEN_EXISTING, 0, NULL);

       if(sc.InputHandle == (HANDLE)-1)
          DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
       else{
          SetStdHandle (STD_INPUT_HANDLE,sc.InputHandle);
       }
    }

    /*:::::::::::::::::::::::::::: check out if stdout has been redirected */

    if(GetFileType(sc.OutputHandle) != FILE_TYPE_CHAR)
    {
       stdoutRedirected = TRUE;
       sa.nLength = sizeof (SECURITY_ATTRIBUTES);
       sa.lpSecurityDescriptor = NULL;
       sa.bInheritHandle = TRUE;
       sc.OutputHandle = CreateFile("CONOUT$",GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_WRITE | FILE_SHARE_READ,
                                    &sa,OPEN_EXISTING, 0, NULL);

       if(sc.OutputHandle == (HANDLE)-1)
          DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
       else {
          SetStdHandle (STD_OUTPUT_HANDLE,sc.OutputHandle);
          SetStdHandle (STD_ERROR_HANDLE,sc.OutputHandle);
       }
    }

    // Keep SCS in sync with these handles for starting non-dos binaries
    SCS_hStdIn  = sc.InputHandle;
    SCS_hStdOut = sc.OutputHandle;
    SCS_hStdErr = sc.OutputHandle;

    /*:::::::::::::::::::::::::::::::::::::::::::::::::: Setup console mode */

    SetupConsoleMode();

#ifdef HUNTER
    HunterMenuMake();
#endif /*HUNTER*/

    /*::::::::::::::::::::::::::: Tell console to post us a closedown event */

    // we only want notification for DOS NTVDM runnig on an existing console
    if (!VDMForWOW && !DosSessionId)
        SetLastConsoleEventActive();
    sc.StaticPalette = TRUE;
    sc.FontsAreOpen = FALSE;
    sc.FocusEvent = INVALID_HANDLE;
}
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : BOOL CreateDisplayPalette(void)                            *
 *                                                                          *
 *  PURPOSE    : Create logical palette                                     *
 *               Assumes Colour monitor supporting 16 colours               *
 *                                                                          *
 ****************************************************************************/

BOOL CreateDisplayPalette(void)
{
    register int i;
    register PALETTEENTRY *PalEntry;
    NPLOGPALETTE LogPalette;              /* Pointer to logical palette */

   /*::::::: Allocate memory for a logical palette with PALETTESIZE entries */

   LogPalette = (NPLOGPALETTE) LocalAlloc(LMEM_FIXED,
                                       (sizeof(LOGPALETTE) +
                                       (sizeof(PALETTEENTRY) * PALETTESIZE)));

    /*:::::::::::::::::::::::::::::::::::::::::::::::: Allocation failed !! */

    if(!LogPalette) return(FALSE);      /* Function failed, no memory */

    /*::: Set the size and version fields of the logical palette structure. */

    LogPalette->palVersion = 0x300;
    LogPalette->palNumEntries = PALETTESIZE;

    /*::::::::::::::::::: Fill in intensities for all palette entry colors */

    for(i=0,PalEntry=LogPalette->palPalEntry; i < PALETTESIZE;i++,PalEntry++)
    {
        if(i < sizeof(Red)/sizeof(BYTE))
        {
            PalEntry->peRed = Red[i];   PalEntry->peGreen = Green[i];
            PalEntry->peBlue  = Blue[i];
        }
        else
        {
            PalEntry->peRed = PalEntry->peGreen = PalEntry->peBlue = 0;
        }

        PalEntry->peFlags = sc.StaticPalette ? 0 : PC_RESERVED;
    }

    /*:::::::: Create a logical color palette from the LOGPALETTE structure */

    sc.ColPalette = CreatePalette((LPLOGPALETTE) LogPalette);
    LocalFree((HANDLE)LogPalette);

    return(sc.ColPalette ? TRUE : FALSE);
}


/*============================================================================
Function to display a menu option on the Console system menu. This is used for
the control of Trapper.
============================================================================*/

#ifdef HUNTER
void HunterMenuMake(void)
{
HMENU hTest,hTrapperPopup,hMainPopup,hErrorPopup;
static BOOL  bTrapperMenuFlag=FALSE;

if(!bTrapperMenuFlag)
   {
   /*========================================================================
   The Menus have been drawn once already. Need to delete these and reappend
   them to the Console menu for the new output buffer. Isn't Console just such
   a bore?
   ========================================================================*/

   DestroyMenu(hTrapperPopup);
   DestroyMenu(hMainPopup);
   DestroyMenu(hErrorPopup);
   }

hTrapperPopup = CreateMenu();
hMainPopup    = CreateMenu();
hErrorPopup   = CreateMenu();

AppendMenu(hMainPopup,MF_STRING,IDM_MFAST,"&Fast forward");
AppendMenu(hMainPopup,MF_STRING,IDM_MNEXT,"&Next screen");
AppendMenu(hMainPopup,MF_STRING,IDM_MPREV,"&Prev screen");
AppendMenu(hMainPopup,MF_STRING,IDM_MSHOW,"&Show screen");
AppendMenu(hMainPopup,MF_STRING,IDM_MCONT,"&Continue");
AppendMenu(hMainPopup,MF_STRING,IDM_MABOR,"&Abort");

AppendMenu(hErrorPopup,MF_STRING,IDM_EFLIP,"&Flip screen");
AppendMenu(hErrorPopup,MF_STRING,IDM_ENEXT,"&Next error");
AppendMenu(hErrorPopup,MF_STRING,IDM_EPREV,"&Prev error");
AppendMenu(hErrorPopup,MF_STRING,IDM_EALL,"&All errors");
AppendMenu(hErrorPopup,MF_STRING,IDM_ECLEA,"&Clear errors");

AppendMenu(hTrapperPopup,MF_POPUP,hMainPopup,"&Main");
AppendMenu(hTrapperPopup,MF_POPUP,hErrorPopup,"&Error");

/* if graphics mode, then use sc.ScreenBuffer */

/* hTest = ConsoleMenuControl(sc.ScreenBuffer,IDM_TRAPPER,IDM_ECLEA); */

/* else text mode, then use sc.OutputHandle */
hTest = ConsoleMenuControl(sc.OutputHandle,IDM_TRAPPER,IDM_ECLEA);

AppendMenu(hTest,MF_POPUP,hTrapperPopup,"&Trapper");
bTrapperMenuFlag=TRUE; /* draw the trapper menu just once */
}
#endif /* HUNTER */
#if defined(JAPAN) || defined(KOREA)
// Create 24dot font
void GetLogFont( int size, LOGFONT *lplf )
{

#ifdef JAPAN_DBG
    DbgPrint("NTVDM: GetLogFont %d\n", size );
#endif
    strcpy( lplf->lfFaceName, "Terminal" );

    if ( size == 16 ) {
        lplf->lfHeight = 18;
        lplf->lfWidth = 8;
    }
    else if ( size == 24 ) {
        lplf->lfHeight = 27;
        lplf->lfWidth = 12;
    }
    lplf->lfEscapement  = 0;
    lplf->lfOrientation = 0;
    lplf->lfWeight      = 0; // default
    lplf->lfItalic      = 0;
    lplf->lfUnderline   = 0;
    lplf->lfStrikeOut   = 0;
#if defined(JAPAN)
    lplf->lfCharSet        = SHIFTJIS_CHARSET;
#elif defined(KOREA) // JAPAN
    lplf->lfCharSet        = HANGEUL_CHARSET;
#endif // KOREA
    lplf->lfOutPrecision   = OUT_DEFAULT_PRECIS;
    lplf->lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    lplf->lfQuality        = DEFAULT_QUALITY;
    lplf->lfPitchAndFamily = FIXED_PITCH | FF_DONTCARE;

    return;
}

void CreateVDMFont( HDC hdc )
{
    LOGFONT logfont;

#ifdef JAPAN_DBG
    DbgPrint("NTVDM: CreateVDMFont\n" );
#endif

    GetLogFont( 16, &logfont );
    hFont16 = CreateFontIndirect( &logfont );
    assert0( hFont16 != 0, "CreateVDMFont fail\n" );

    GetLogFont( 24, &logfont );
    hFont24 = CreateFontIndirect( &logfont );
    assert0( hFont24 != 0, "CreateVDMFont fail\n" );

}
#endif // JAPAN || KOREA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_input.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title		:	Win32 Input Module.
 *
 * Description	:	This module contains data and functions to
 *			implement the SoftPC keyboard/mouse input subsystem.
 *
 * Author	:	D.A.Bartlett (based on X_input.c)
 *
 * Notes	:	HELP!!!!!!
 * Mods		:	Tim May 28, 92. Yoda break now on F11 if set YODA=1.
 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>

#include "insignia.h"
#include "host_def.h"
#include "xt.h"
#include "keyboard.h"
#include "keyba.h"
#include "ica.h"
#include "error.h"
#include "config.h"
#include "keyba.h"
#include "gmi.h"
#include "nt_uis.h"
#include "sas.h"
#include <stdio.h>
#include "trace.h"
#include "video.h"
#include "debug.h"
#include "nt_event.h"
#include "nt_reset.h"
#include "bios.h"
#include CpuH

#include "host.h"
#include "host_hfx.h"
#include "host_nls.h"
#include "spcfile.h"


// The command bits for the kbd light (same as real hardware)
#define CAPS_LOCK       0x04
#define NUM_LOCK 	0x02
#define SCROLL_LOCK     0x01

// functions available thru the keyb functions table
void nt_kb_prepare(void) {}


#if NOTUSEDNOTUSED
void nt_kb_light_off IFN1(half_word, kyLight) {}
void nt_kb_restore(void) {}
#endif

void nt_kb_light_on(UCHAR);
void nt_kb_init(void);
void nt_kb_shutdown(void);


// the keyb functions table
KEYBDFUNCS nt_keybd_funcs = {nt_kb_prepare,   // not implemented
                             nt_kb_prepare,   // not implemented
                             nt_kb_prepare,   // not implemented
                             nt_kb_prepare,   // not implemented
                             nt_kb_light_on,
                             nt_kb_light_on   // not implemented
                             };


/*
 *   nt_kb_light_on
 *
 *   This code gets called whenever kbdhdw  tries to change the kbd leds.
 *   We cannot allow changes to the real leds because this would get us
 *   out of sync with user32 physical keyboard state. So what we do is
 *   to send fake keys to the kbd hdw to reset the state to what the
 *   the latest state is according to the console input
 *
 *   Caller should hold the kbd mutex
 */
void nt_kb_light_on (unsigned char kyLight)
{
   DWORD KeyState;
   unsigned char ChangeBits;

   ChangeBits = kyLight >> 4;

   KeyState = (ToggleKeyState & ~(CAPSLOCK_ON | NUMLOCK_ON | SCROLLLOCK_ON));

   if(ChangeBits & CAPS_LOCK) {
      if (kyLight & CAPS_LOCK)
          KeyState |= CAPSLOCK_ON;
      }
   else {
      KeyState |= ToggleKeyState & CAPSLOCK_ON;
      }

   if(ChangeBits & NUM_LOCK) {
      if(kyLight & NUM_LOCK)
         KeyState |= NUMLOCK_ON;
      }
   else {
      KeyState |= ToggleKeyState & NUMLOCK_ON;
      }


   if(ChangeBits & SCROLL_LOCK) {
      if(kyLight & SCROLL_LOCK)
         KeyState |= SCROLLLOCK_ON;
      }
   else {
      KeyState |= ToggleKeyState & SCROLLLOCK_ON;
      }

   if (ToggleKeyState != KeyState) {
       SyncToggleKeys( 0, KeyState);
       }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_keycd.c ===
/***************************************************************************
 *									   *
 *  MODULE	: nt_keycd.c						   *
 *									   *
 *  PURPOSE	: Convert a windows key message to a PC keyboard number	   *
 *									   *
 *  FUNCTIONS	: KeyMsgToKeyCode()					   *
 *									   *
 ****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "windows.h"

//
// OEM Scancode to (ie Scancode set 1) to keynum table.
// Somehow this has to end up being loaded rather than compiled in...
//
#define UNDEFINED 0
#if defined(NEC_98)
//FOR DISABLE 106 KeyBoard Emulation Mode       // NEC 971208
#define  SC_HANKAKU  0x29   // ZENKAKU HANKAKU
#define  SC_NUMLOCK  0x45   // Num Lock
#define  SC_SCROLLLOCK 0x46 // Scroll Lock
#define  SC_VF3      0x5d   // vf3
#define  SC_VF4      0x5e   // vf4
#define  SC_VF5      0x5f   // vf5
//FOR 106 KeyBoard                              // NEC 970623
#define  SC_CAPS     0x3A   // CAPS KEY
#define  SC_KANA     0x70   // KATAKANA
#define  SC_UNDERBAR 0x73   // "\" "_"
#define  SC_AT       0x1A   // "@" "`"
#define  SC_YAMA     0x0D   // "^" "~"
#endif //NEC_98

/*@ACW=======================================================================

Microsoft now use scan code set 1 as their base scan code set. This means that
we had to change ours also. Not only that, two tables are needed now: one to
hold the regular keyset, the other to hold the ENHANCED key options. Scan code
set 1 differs to scan code set 3 in that some scan codes are the same for
different keystrokes. So when an enhanced bit is set in the KEY_EVENT_RECORD.
dwControlKeyState, a second (very sparse) table is substituted for the regular
one.
A small, teensy, weensy detail... All the key numbers are mapped to different
scancode values for the regular keys just to make life a little more fun!

============================================================================*/

#if defined(NEC_98)
BYTE Scan1ToKeynum[] =
{
    // Keynum           Scancode        US encoding


    UNDEFINED,          //  0x0
    110,                //  0x1         Escape
    2,                  //  0x2         1 !
    3,                  //  0x3         2 @
    4,                  //  0x4         3 #
    5,                  //  0x5         4 $
    6,                  //  0x6         5 %
    7,                  //  0x7         6 ^
    8,                  //  0x8         7 &
    9,                  //  0x9         8 *
    10,                 //  0xa         9 (
    11,                 //  0xb         0 )
    12,                 //  0xc         - _
    41,                 //  0xd         ^ `
    15,                 //  0xe         Backspace
    16,                 //  0xf         Tab
    17,                 //  0x10        q Q
    18,                 //  0x11        w W
    19,                 //  0x12        e E
    20,                 //  0x13        r R
    21,                 //  0x14        t T
    22,                 //  0x15        y Y
    23,                 //  0x16        u U
    24,                 //  0x17        i I
    25,                 //  0x18        o O
    26,                 //  0x19        p P
    1,                  //  0x1a        @ ~
    27,                 //  0x1b        [ {
    43,                 //  0x1c        Enter
    58,                 //  0x1d        Left Control
    31,                 //  0x1e        a A
    32,                 //  0x1f        s S
    33,                 //  0x20        d D
    34,                 //  0x21        f F
    35,                 //  0x22        g G
    36,                 //  0x23        h H
    37,                 //  0x24        j J
    38,                 //  0x25        k K
    39,                 //  0x26        l L
    13,                 //  0x27        = +
    40,                 //  0x28        ; +
    UNDEFINED,          //  0x29        HANKAKU/ZENKAKU
    44,                 //  0x2a        Left Shift
    28,                 //  0x2b        ] {
    46,                 //  0x2c        z Z
    47,                 //  0x2d        x X
    48,                 //  0x2e        c C
    49,                 //  0x2f        v V
    50,                 //  0x30        b B
    51,                 //  0x31        n N
    52,                 //  0x32        m M
    53,                 //  0x33        , <
    54,                 //  0x34        . >
    55,                 //  0x35        / ?
    57,                 //  0x36        Right Shift (see extended table)
    100,                //  0x37        Keypad *
    60,                 //  0x38        Left Alt
    61,                 //  0x39        Space
    30,                 //  0x3a        Caps Lock
    112,                //  0x3b        F1
    113,                //  0x3c        F2
    114,                //  0x3d        F3
    115,                //  0x3e        F4
    116,                //  0x3f        F5
    117,                //  0x40        F6
    118,                //  0x41        F7
    119,                //  0x42        F8
    120,                //  0x43        F9
    121,                //  0x44        F10
    90,                 //  0x45        Num Lock
    125,                //  0x46        Scroll Lock
    91,                 //  0x47        Keypad Home 7
    96,                 //  0x48        Keypad Up 8
    101,                //  0x49        Keypad Pg Up
    105,                //  0x4a        Keypad -
    92,                 //  0x4b        Keypad Left 4
    97,                 //  0x4c        Keypad 5
    102,                //  0x4d        Keypad Right 6
    106,                //  0x4e        Keypad +
    93,                 //  0x4f        Keypad End 1
    98,                 //  0x50        Keypad Down 2
    103,                //  0x51        Keypad Pg Down 3
    99,                 //  0x52        Keypad Ins 0
    104,                //  0x53        Keypad Del .
    136,                //  0x54        COPY
    UNDEFINED,          //  0x55
    45,                 //  0x56        International Key UK = \ |
    122,                //  0x57        F11
    123,                //  0x58        F12
    128,                //  0x59        Keypad =
    129,                //  0x5a        NFER
    130,                //  0x5b        XFER
    131,                //  0x5c        Keypad ,
    132,                //  0x5d        F13
    133,                //  0x5e        F14
    134,                //  0x5f        F15
    UNDEFINED,          //  0x60
    UNDEFINED,          //  0x61
    UNDEFINED,          //  0x62
    UNDEFINED,		//  0x63	
    UNDEFINED,          //  0x64
    UNDEFINED,          //  0x65
    UNDEFINED,          //  0x66
    UNDEFINED,          //  0x67
    UNDEFINED,          //  0x68
    UNDEFINED,          //  0x69
    UNDEFINED,          //  0x6a
    UNDEFINED,          //  0x6b
    UNDEFINED,          //  0x6c
    UNDEFINED,          //  0x6d
    UNDEFINED,          //  0x6e
    UNDEFINED,          //  0x6f
    69,                 //  0x70        KANA
    UNDEFINED,          //  0x71
    UNDEFINED,          //  0x72
    127,                //  0x73        \ _
    UNDEFINED,          //  0x74
    UNDEFINED,          //  0x75
    UNDEFINED,          //  0x76
    UNDEFINED,          //  0x77
    UNDEFINED,          //  0x78
    130,                //  0x79        XFER
    UNDEFINED,          //  0x7a
    129,                //  0x7b        NFER
    UNDEFINED,          //  0x7c
    42,                 //  0x7d        \ |
    UNDEFINED,          //  0x7e
    UNDEFINED,          //  0x7f
    UNDEFINED,          //  0x80
    UNDEFINED,          //  0x81
    UNDEFINED,          //  0x82
    UNDEFINED,          //  0x83
    UNDEFINED           //  0x84
};

/*@ACW====================================================================

Note that in the following extended keyboard table, the shift key values
have also been given an entry because these keys can be used as modifiers
for the other extended keys.

========================================================================*/


BYTE Scan1ToKeynumExtended[] =
{
    // Keynum           Scancode        US encoding

    31,                 //  0x0
    UNDEFINED,          //  0x1
    UNDEFINED,          //  0x2
    UNDEFINED,          //  0x3
    UNDEFINED,          //  0x4
    UNDEFINED,          //  0x5
    UNDEFINED,          //  0x6
    UNDEFINED,          //  0x7
    UNDEFINED,          //  0x8
    UNDEFINED,          //  0x9
    UNDEFINED,          //  0xa
    UNDEFINED,          //  0xb
    UNDEFINED,          //  0xc
    UNDEFINED,          //  0xd
    UNDEFINED,          //  0xe
    UNDEFINED,          //  0xf
    UNDEFINED,          //  0x10
    UNDEFINED,          //  0x11
    UNDEFINED,          //  0x12
    UNDEFINED,          //  0x13
    UNDEFINED,          //  0x14
    UNDEFINED,          //  0x15
    UNDEFINED,          //  0x16
    UNDEFINED,          //  0x17
    UNDEFINED,          //  0x18
    UNDEFINED,          //  0x19
    UNDEFINED,          //  0x1a
    UNDEFINED,          //  0x1b
    108,                //  0x1c        Extended 1c Num Enter
    63,                 //  0x1d        Extended 1d right ctrl
    UNDEFINED,          //  0x1e
    UNDEFINED,          //  0x1f
    UNDEFINED,          //  0x20
    UNDEFINED,          //  0x21
    UNDEFINED,          //  0x22
    UNDEFINED,          //  0x23
    UNDEFINED,          //  0x24
    UNDEFINED,          //  0x25
    UNDEFINED,          //  0x26
    UNDEFINED,          //  0x27
    UNDEFINED,          //  0x28
    UNDEFINED,          //  0x29
    44,                 //  0x2a        Extended 2a left shift
    UNDEFINED,          //  0x2b
    UNDEFINED,          //  0x2c
    UNDEFINED,          //  0x2d
    UNDEFINED,          //  0x2e
    UNDEFINED,          //  0x2f
    UNDEFINED,          //  0x30
    UNDEFINED,          //  0x31
    UNDEFINED,          //  0x32
    UNDEFINED,          //  0x33
    UNDEFINED,          //  0x34
    95,                 //  0x35        Extended 35 keypad /
    57,                 //  0x36        Extended 36 right shift
#if 1
    136,                //  0x37        Extended 37 COPY key
#else
    UNDEFINED,          //  0x37
#endif
    62,                 //  0x38        Extended 38 right alt ->not true:"XFER"
    UNDEFINED,          //  0x39
    UNDEFINED,          //  0x3a
    UNDEFINED,          //  0x3b
    UNDEFINED,          //  0x3c
    UNDEFINED,          //  0x3d
    UNDEFINED,          //  0x3e
    UNDEFINED,          //  0x3f
    UNDEFINED,          //  0x40
    UNDEFINED,          //  0x41
//#if 1                                             //NEC98 for 106 keyboard
//    63,                 //  0x42        Extended 42 right ctrl
//    64,                 //  0x43        Extended 43 right alt
//#else                                             //NEC98 for 106 keyboard
    UNDEFINED,          //  0x42
    UNDEFINED,          //  0x43
//#endif                                            //NEC98 for 106 keyboard
    UNDEFINED,          //  0x44
    90,                 //  0x45        Num Lock
    137,                //  0x46        STOP
    80,                 //  0x47        Extended 47 Home
    83,                 //  0x48        Extended 48 Up
    85,                 //  0x49        Extended 49 Page up
#if 1                                             //NEC98 for 106 keyboard
    105,                //  0x4a        Extended 4a Keypad -
#else                                             //NEC98 for 106 keyboard
    UNDEFINED,          //  0x4a        Extended 4a Keypad -
#endif                                            //NEC98 for 106 keyboard
    79,                 //  0x4b        Extended 4b Left
    UNDEFINED,          //  0x4c
    89,                 //  0x4d        Extended 4d Right
#if 1                                             //NEC98 for 106 keyboard
    106,                //  0x4e        Extended 4e Keypad +
#else                                             //NEC98 for 106 keyboard
    UNDEFINED,          //  0x4e        Extended 4e Keypad +
#endif                                            //NEC98 for 106 keyboard
    81,                 //  0x4f        Extended 4f End
    84,                 //  0x50        Extended 50 Down
    86,                 //  0x51        Extended 51 Page Down
    75,                 //  0x52        Extended 52 Insert
    76,                 //  0x53        Extended 53 Delete

};


#else  // !NEC_98
BYTE Scan1ToKeynum[] =
{
    // Keynum		Scancode	US encoding


    UNDEFINED,		//  0x0		
    110,		//  0x1		Escape
    2,			//  0x2		1 !
    3,			//  0x3		2 @
    4,			//  0x4		3 #
    5,			//  0x5		4 $
    6,			//  0x6		5 %
    7,			//  0x7		6 ^
    8,			//  0x8		7 &
    9,			//  0x9		8 *
    10,			//  0xa		9 (
    11,			//  0xb		0 )
    12,			//  0xc		- _		
    13,			//  0xd		= +
    15,			//  0xe		Backspace
    16,			//  0xf		Tab
    17,			//  0x10	q Q
    18,			//  0x11	w W
    19,			//  0x12	e E
    20,			//  0x13	r R
    21,			//  0x14	t T
    22,			//  0x15	y Y
    23,			//  0x16	u U
    24,			//  0x17	i I
    25,			//  0x18	o O
    26,			//  0x19	p P
    27,			//  0x1a	[ {
    28,			//  0x1b	] }
    43,			//  0x1c	Enter
    58,			//  0x1d	Left Control
    31,			//  0x1e	a A
    32,			//  0x1f	s S
    33,			//  0x20	d D
    34,			//  0x21	f F
    35,			//  0x22	g G
    36,			//  0x23	h H
    37,			//  0x24	j J
    38,			//  0x25	k K
    39,			//  0x26	l L
    40,			//  0x27	; :
    41,			//  0x28	' "
    1,			//  0x29	` ~
    44,			//  0x2a	Left Shift
    42,			//  0x2b	\ | or International Key UK = ~ #
    46,			//  0x2c	z Z
    47,			//  0x2d	x X
    48,			//  0x2e	c C
    49,			//  0x2f	v V
    50,			//  0x30	b B
    51,			//  0x31	n N
    52,			//  0x32	m M
    53,			//  0x33	, <
    54,			//  0x34	. >
    55,			//  0x35	/ ?
    57,			//  0x36	Right Shift (see extended table)
    100,		//  0x37	Keypad *
    60,			//  0x38	Left Alt
    61,			//  0x39	Space
    30,			//  0x3a	Caps Lock
    112,		//  0x3b	F1
    113,		//  0x3c	F2
    114,		//  0x3d	F3
    115,		//  0x3e	F4
    116,		//  0x3f	F5
    117,		//  0x40	F6
    118,		//  0x41	F7
    119,		//  0x42	F8
    120,		//  0x43	F9
    121,		//  0x44	F10
    90, 		//  0x45	Numlock and Pause both have ScanCode 45
    125,		//  0x46	Scroll Lock
    91,			//  0x47	Keypad Home 7
    96,			//  0x48	Keypad Up 8
    101,		//  0x49	Keypad Pg Up
    105,		//  0x4a	Keypad -
    92,			//  0x4b	Keypad Left 4
    97,			//  0x4c	Keypad 5
    102,		//  0x4d	Keypad Right 6
    106,		//  0x4e	Keypad +
    93,			//  0x4f	Keypad End 1
    98,			//  0x50	Keypad Down 2
    103,		//  0x51	Keypad Pg Down 3
    99,			//  0x52	Keypad Ins 0
    104,		//  0x53	Keypad Del .
    UNDEFINED,		//  0x54	
    UNDEFINED,		//  0x55	
    45,			//  0x56	International Key UK = \ |
    122,		//  0x57	F11
    123,		//  0x58	F12
    UNDEFINED,		//  0x59	
#ifdef	JAPAN
// Use 45,56,59,65-69 for Japanese extend key No.
    65,			//  0x5a	AX keyboard MUHENKAN
    66,			//  0x5b	AX keyboard HENKAN
#else // !JAPAN
    UNDEFINED,		//  0x5a	
    UNDEFINED,		//  0x5b	
#endif // !JAPAN
    UNDEFINED,		//  0x5c	
    UNDEFINED,		//  0x5d
    UNDEFINED,		//  0x5e
    UNDEFINED,		//  0x5f
    UNDEFINED,		//  0x60	
    UNDEFINED,		//  0x61	
    UNDEFINED,		//  0x62	
    UNDEFINED,		//  0x63	
    UNDEFINED,		//  0x64	
    UNDEFINED,		//  0x65	
    UNDEFINED,		//  0x66	
    UNDEFINED,		//  0x67	
    UNDEFINED,		//  0x68
    UNDEFINED,		//  0x69	
    UNDEFINED,		//  0x6a	
    UNDEFINED,		//  0x6b	
    UNDEFINED,		//  0x6c	
    UNDEFINED,		//  0x6d	
    UNDEFINED,		//  0x6e	
    UNDEFINED,		//  0x6f	
#ifdef	JAPAN
    69,			//  0x70	106 keyboard KATAKANA
    UNDEFINED,		//  0x71	
    UNDEFINED,		//  0x72	
    56,	  		//  0x73	AX/106 keyboard "RO"
    UNDEFINED,		//  0x74	
    UNDEFINED,		//  0x75	
    UNDEFINED,		//  0x76	
    59,			//  0x77	106 keyboard ZENKAKU
    UNDEFINED,		//  0x78
    67,			//  0x79	106 keyboard HENKAN
    UNDEFINED,		//  0x7a
    68,			//  0x7b	106 keyboard MUHENKAN
    UNDEFINED,		//  0x7c	
    45,			//  0x7d	106 keyboard yen mark
    UNDEFINED,		//  0x7e	
#else
    UNDEFINED,		//  0x70	
    UNDEFINED,		//  0x71	
    UNDEFINED,		//  0x72	
    56,			//  0x73	Brazilian ABNT / ?
    UNDEFINED,  	//  0x74
    UNDEFINED,		//  0x75	
    UNDEFINED,		//  0x76	
    UNDEFINED,		//  0x77	
    UNDEFINED,		//  0x78
    UNDEFINED,		//  0x79	
    UNDEFINED,		//  0x7a	
    UNDEFINED,		//  0x7b
    94,       		//  0x7c	Extended kbd (IBM 122 key)
    14,			//  0x7d	Extended kbd (IBM 122 key)
    107,		//  0x7e	Brazilian ABNT numpad .
#endif
    UNDEFINED,		//  0x7f
    UNDEFINED,		//  0x80
    UNDEFINED,		//  0x81
    UNDEFINED,		//  0x82
    UNDEFINED,		//  0x83
    UNDEFINED		//  0x84	
};

/*@ACW====================================================================

Note that in the following extended keyboard table, the shift key values
have also been given an entry because these keys can be used as modifiers
for the other extended keys.

========================================================================*/


BYTE Scan1ToKeynumExtended[] =
{
    // Keynum		Scancode	US encoding

    31,			//  0x0
    UNDEFINED,		//  0x1
    UNDEFINED,		//  0x2
    UNDEFINED,		//  0x3
    UNDEFINED,		//  0x4
    UNDEFINED,		//  0x5
    UNDEFINED,		//  0x6
    UNDEFINED,		//  0x7		
    UNDEFINED,		//  0x8		
    UNDEFINED,		//  0x9
    UNDEFINED,		//  0xa
    UNDEFINED,		//  0xb
    UNDEFINED,		//  0xc
    UNDEFINED,	        //  0xd		
    UNDEFINED,		//  0xe		
    UNDEFINED,		//  0xf		
    UNDEFINED,		//  0x10
    UNDEFINED,		//  0x11	
    UNDEFINED,		//  0x12	
    UNDEFINED,		//  0x13	
    UNDEFINED,		//  0x14	
    UNDEFINED,		//  0x15	
    UNDEFINED,		//  0x16	
    UNDEFINED,		//  0x17	
    UNDEFINED,		//  0x18
    UNDEFINED,		//  0x19	
    UNDEFINED,		//  0x1a	
    UNDEFINED,		//  0x1b	
    108,		//  0x1c	Extended 1c Num Enter
    64,			//  0x1d	Extended 1d Right Ctrl
    UNDEFINED,		//  0x1e	
    UNDEFINED,		//  0x1f	
    UNDEFINED,		//  0x20
    UNDEFINED,		//  0x21	
    UNDEFINED,		//  0x22	
    UNDEFINED,		//  0x23	
    UNDEFINED,		//  0x24	
    UNDEFINED,		//  0x25	
    UNDEFINED,		//  0x26	
    UNDEFINED,		//  0x27	
    UNDEFINED,		//  0x28
    UNDEFINED,		//  0x29	
    44,	 	 	//  0x2a	Extended 2a left shift
    UNDEFINED,		//  0x2b	
    UNDEFINED,		//  0x2c	
    UNDEFINED,		//  0x2d	
    UNDEFINED,		//  0x2e	
    UNDEFINED,		//  0x2f	
    UNDEFINED,		//  0x30
    UNDEFINED,		//  0x31	
    UNDEFINED,		//  0x32	
    UNDEFINED,		//  0x33	
    UNDEFINED,		//  0x34	
    95,			//  0x35	Extended 35 keypad /
    57, 		//  0x36	Extended 36 right shift
    124,		//  0x37	PrintScreen
    62, 		//  0x38	Extended 38 right alt
    UNDEFINED,		//  0x39	
    UNDEFINED,		//  0x3a	
    UNDEFINED,		//  0x3b	
    UNDEFINED,		//  0x3c	
    UNDEFINED,		//  0x3d
    UNDEFINED,		//  0x3e	
    UNDEFINED,		//  0x3f	
    UNDEFINED,		//  0x40	
    UNDEFINED,		//  0x41	
    UNDEFINED,		//  0x42	
    UNDEFINED,		//  0x43	
    UNDEFINED,		//  0x44	
    90,			//  0x45	Num Lock
    126,		//  0x46
    80,			//  0x47	Extended 47 Home
    83,			//  0x48	Extended 48 Up
    85,			//  0x49	Extended 49 Page up
    UNDEFINED,		//  0x4a
    79,			//  0x4b	Extended 4b Left
    UNDEFINED,		//  0x4c	
    89,			//  0x4d	Extended 4d Right
    UNDEFINED,		//  0x4e	
    81,			//  0x4f	Extended 4f End
    84,			//  0x50	Extended 50 Down
    86,			//  0x51	Extended 51 Page Down
    75,			//  0x52	Extended 52 Insert
    76,			//  0x53	Extended 53 Delete

};
#endif // !NEC_98



/*
 *  Table for translating BiosBuffer scan codes with special
 *  NULL ascii chars, and their associated control flags
 *  If it is not in this table The Bios scan code should
 *  be the same as the win32 Scan code.
 */
#define FIRST_NULLCHARSCAN      0x54
#define LAST_NULLCHARSCAN       0xa6

typedef struct _NullAsciiCharScan {
    WORD    wWinSCode;
    DWORD   dwControlState;
} NULLCHARSCAN;

NULLCHARSCAN aNullCharScan[] =
{
// WinSCode    dwControlState           BiosSCode      Keys

      0x3b,    SHIFT_PRESSED,           //  0x54       Shift+F1
      0x3c,    SHIFT_PRESSED,           //  0x55       Shift+F2
      0x3d,    SHIFT_PRESSED,           //  0x56       Shift+F3
      0x3e,    SHIFT_PRESSED,           //  0x57       Shift+F4
      0x3f,    SHIFT_PRESSED,           //  0x58       Shift+F5
      0x40,    SHIFT_PRESSED,           //  0x59       Shift+F6
      0x41,    SHIFT_PRESSED,           //  0x5a       Shift+F7
      0x42,    SHIFT_PRESSED,           //  0x5b       Shift+F8
      0x43,    SHIFT_PRESSED,           //  0x5c       Shift+F9
      0x44,    SHIFT_PRESSED,           //  0x5d       Shift+F10
      0x3b,    LEFT_CTRL_PRESSED,       //  0x5e       Ctrl+F1
      0x3c,    LEFT_CTRL_PRESSED,       //  0x5f       Ctrl+F2
      0x3d,    LEFT_CTRL_PRESSED,       //  0x60       Ctrl+F3
      0x3e,    LEFT_CTRL_PRESSED,       //  0x61       Ctrl+F4
      0x3f,    LEFT_CTRL_PRESSED,       //  0x62       Ctrl+F5
      0x40,    LEFT_CTRL_PRESSED,       //  0x63       Ctrl+F6
      0x41,    LEFT_CTRL_PRESSED,       //  0x64       Ctrl+F7
      0x42,    LEFT_CTRL_PRESSED,       //  0x65       Ctrl+F8
      0x43,    LEFT_CTRL_PRESSED,       //  0x66       Ctrl+F9
      0x44,    LEFT_CTRL_PRESSED,       //  0x67       Ctrl+F10
      0x3b,    LEFT_ALT_PRESSED,        //  0x68       Alt+F1
      0x3c,    LEFT_ALT_PRESSED,        //  0x69       Alt+F2
      0x3d,    LEFT_ALT_PRESSED,        //  0x6a       Alt+F3
      0x3e,    LEFT_ALT_PRESSED,        //  0x6b       Alt+F4
      0x3f,    LEFT_ALT_PRESSED,        //  0x6c       Alt+F5
      0x40,    LEFT_ALT_PRESSED,        //  0x6d       Alt+F6
      0x41,    LEFT_ALT_PRESSED,        //  0x6e       Alt+F7
      0x42,    LEFT_ALT_PRESSED,        //  0x6f       Alt+F8
      0x43,    LEFT_ALT_PRESSED,        //  0x70       Alt+F9
      0x44,    LEFT_ALT_PRESSED,        //  0x71       Alt+F10
      0,       0,                       //  0x72       Ctrl+PrtSc
      0x4b,    LEFT_CTRL_PRESSED,       //  0x73       Ctrl+Left
      0x4d,    LEFT_CTRL_PRESSED,       //  0x74       Ctrl+Right
      0x4f,    LEFT_CTRL_PRESSED,       //  0x75       Ctrl+End
      0x51,    LEFT_CTRL_PRESSED,       //  0x76       Ctrl+PgDn
      0x47,    LEFT_CTRL_PRESSED,       //  0x77       Ctrl+Home
      0x2,     LEFT_ALT_PRESSED,        //  0x78       Alt+1
      0x3,     LEFT_ALT_PRESSED,        //  0x79       Alt+2
      0x4,     LEFT_ALT_PRESSED,        //  0x7a       Alt+3
      0x5,     LEFT_ALT_PRESSED,        //  0x7b       Alt+4
      0x6,     LEFT_ALT_PRESSED,        //  0x7c       Alt+5
      0x7,     LEFT_ALT_PRESSED,        //  0x7d       Alt+6
      0x8,     LEFT_ALT_PRESSED,        //  0x7e       Alt+7
      0x9,     LEFT_ALT_PRESSED,        //  0x7f       Alt+8
      0xa,     LEFT_ALT_PRESSED,        //  0x80       Alt+9
      0xb,     LEFT_ALT_PRESSED,        //  0x81       Alt+0
      0xc,     LEFT_ALT_PRESSED,        //  0x82       Alt+-
      0xd,     LEFT_ALT_PRESSED,        //  0x83       Alt+=
      0x49,    LEFT_CTRL_PRESSED,       //  0x84       Ctrl+PgUp
      0,       0,                       //  0x85       ?????
      0,       0,                       //  0x86       ?????
      0x85,    SHIFT_PRESSED,           //  0x87       Shift+F11
      0x86,    SHIFT_PRESSED,           //  0x88       Shift+F12
      0x85,    LEFT_CTRL_PRESSED,       //  0x89       Ctrl+F11
      0x86,    LEFT_CTRL_PRESSED,       //  0x8a       Ctrl+F12
      0x85,    LEFT_ALT_PRESSED,        //  0x8b       Alt+F11
      0x86,    LEFT_ALT_PRESSED,        //  0x8c       Alt+F12
      0x48,    LEFT_CTRL_PRESSED,       //  0x8d       Ctrl+Up
      0x4a,    LEFT_CTRL_PRESSED,       //  0x8e       Ctrl+-
      0x4c,    LEFT_CTRL_PRESSED,       //  0x8f       Ctrl+5
      0x4e,    LEFT_CTRL_PRESSED,       //  0x90       Ctrl++
      0x50,    LEFT_CTRL_PRESSED,       //  0x91       Ctrl+Down
      0x52,    LEFT_CTRL_PRESSED,       //  0x92       Ctrl+Ins
      0x53,    LEFT_CTRL_PRESSED,       //  0x93       Ctrl+Del
      0,       0,                       //  0x94       ?????
      0,       0,                       //  0x95       ?????
      0,       0,                       //  0x96       ?????
      0x47,    LEFT_ALT_PRESSED,        //  0x97       Alt+Home
      0x48,    LEFT_ALT_PRESSED,        //  0x98       Alt+Up
      0x49,    LEFT_ALT_PRESSED,        //  0x99       Alt+PgUp
      0,       0,                       //  0x9a       ?????
      0x4b,    LEFT_ALT_PRESSED,        //  0x9b       Alt+Left
      0,       0,                       //  0x9c       ?????
      0x4d,    LEFT_ALT_PRESSED,        //  0x9d       Alt+Right
      0,       0,                       //  0x9e       ?????
      0x4f,    LEFT_ALT_PRESSED,        //  0x9f       Alt+End
      0x50,    LEFT_ALT_PRESSED,        //  0xa0       Alt+Down
      0x51,    LEFT_ALT_PRESSED,        //  0xa1       Alt+PgDn
      0x52,    LEFT_ALT_PRESSED,        //  0xa2       Alt+Ins
      0x53,    LEFT_ALT_PRESSED,        //  0xa3       Alt+Del
      0,       0,                       //  0xa4       ?????
      0xf,     LEFT_ALT_PRESSED,        //  0xa5       Alt+Tab
      0x1c,    LEFT_ALT_PRESSED         //  0xa6       Alt+Enter
};


WORD aNumPadSCode[] = // index by VK_NUMPAD0 as zero offset
{
    0x52,      // VK_NUMPAD0 - 60
    0x4f,      // VK_NUMPAD1   61
    0x50,      // VK_NUMPAD2   62
    0x51,      // VK_NUMPAD3   63
    0x4b,      // VK_NUMPAD4   64
    0x4c,      // VK_NUMPAD5   65
    0x4d,      // VK_NUMPAD6   66
    0x47,      // VK_NUMPAD7   67
    0x48,      // VK_NUMPAD8   68
    0x49       // VK_NUMPAD9   69
};






 /****************************************************************************
  *									     *
  *  FUNCTIONS	 : BYTE KeyMsgToKeyCode(WORD vKey, DWORD KeyFlags)	     *
  *									     *
  *  PURPOSE	  : Convert a windows key message to a PC keyboard number    *
  *                 Return 0 if not mapped.				     *
  *									     *
  ****************************************************************************/

BYTE KeyMsgToKeyCode(PKEY_EVENT_RECORD KeyEvent)
{
    /*:::::::::::::::::::::::::::::::::::: do we need the enhanced key set ? */

#if defined(NEC_98)
// for 106 keyboard. need to get keyboard type.
    int KeyboardType;
    KeyboardType = GetKeyboardType(1);
#endif // !NEC_98

    // Both Pause and Numlock have ScanCode==0x45,
    // so simple table lookup by ScanCode doesn't work
    // use wVirtualKeyCode to check for Pause
    if(KeyEvent->wVirtualScanCode == 0x45 && KeyEvent->wVirtualKeyCode == VK_PAUSE) {
       return 126;
    }

    if(!(KeyEvent->dwControlKeyState & ENHANCED_KEY))
    {
#ifdef	JAPAN
	/* Check CTRL-ALT-DEL key */
	if  (KeyEvent->wVirtualScanCode==0x53
	&&  (KeyEvent->dwControlKeyState & RIGHT_ALT_PRESSED
	||   KeyEvent->dwControlKeyState & LEFT_ALT_PRESSED)
	&&  (KeyEvent->dwControlKeyState & RIGHT_CTRL_PRESSED
	||   KeyEvent->dwControlKeyState & LEFT_CTRL_PRESSED)){
		return(0);
	}
#endif // JAPAN
	/*............................... the regular keyset is what we need */
#if defined(NEC_98)
        switch(KeyboardType) {
        case 0xD01:
            switch(KeyEvent->wVirtualScanCode){      // 971208    Disable 106 Keyboard Emulation Mode
            case SC_SCROLLLOCK:
                    return(Scan1ToKeynum[SC_VF4]);   // Convert Scroll Lock to vf4
            case SC_HANKAKU:
                    return(Scan1ToKeynum[SC_VF5]);   // Convert HANKAKU ZENKAKU Key to vf5
            }
            break;
        case 0x0D05:
//for keypad
            if(!(KeyEvent->dwControlKeyState & NUMLOCK_ON)) {
                if(KeyEvent->wVirtualScanCode >= 0x47 &&
                    KeyEvent->wVirtualScanCode <= 0x53 )
                    return (Scan1ToKeynumExtended[KeyEvent->wVirtualScanCode]);
            }
//for Caps Lock
            if(KeyEvent->wVirtualScanCode == SC_CAPS) {    // CAPS
                if(!(KeyEvent->dwControlKeyState & SHIFT_PRESSED))
                    return (0);
            }
//for KANA
            if(KeyEvent->wVirtualScanCode == SC_KANA) {    // KATAKANA
                if(!(KeyEvent->dwControlKeyState & (SHIFT_PRESSED |
                    LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)))
                    return (0);
            }
//for "`" & "~" & "_"
            if(!(KeyEvent->dwControlKeyState & NLS_KATAKANA)) {
                if(KeyEvent->wVirtualScanCode == SC_AT) {       // SHIFT + "@" -> "`"
                    if(KeyEvent->dwControlKeyState & SHIFT_PRESSED)
                        return (41);
                }
                if(KeyEvent->wVirtualScanCode == SC_YAMA) {     // SHIFT + "^" -> "~"
                    if(KeyEvent->dwControlKeyState & SHIFT_PRESSED)
                        return (1);
                }
//"_" key
                if(KeyEvent->wVirtualScanCode == SC_UNDERBAR) { // NON SHIFT"_" -> "\"
                    if(!(KeyEvent->dwControlKeyState & (SHIFT_PRESSED | LEFT_ALT_PRESSED |
                        RIGHT_ALT_PRESSED | LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)))
                        return (42);
                }
            }
        }
#endif // NEC_98

        return  KeyEvent->wVirtualScanCode > sizeof(Scan1ToKeynum)
		   ? 0
                   : Scan1ToKeynum[KeyEvent->wVirtualScanCode];
    }
    else
    {
#ifdef	JAPAN
	/* Check CTRL-ALT-DEL key */
	if(KeyEvent->wVirtualScanCode==0x53
	&&(KeyEvent->dwControlKeyState & RIGHT_ALT_PRESSED
	|| KeyEvent->dwControlKeyState & LEFT_ALT_PRESSED)
	&&(KeyEvent->dwControlKeyState & RIGHT_CTRL_PRESSED
	|| KeyEvent->dwControlKeyState & LEFT_CTRL_PRESSED)){
		return(0);
	}
#endif // JAPAN
        /*.................................. we do need the extended key set */

#if defined(NEC_98)
        switch(KeyboardType) {
        case 0xD01:
            switch(KeyEvent->wVirtualScanCode){   // 971208    Disable 106 Keyboard Emulation Mode
            case SC_NUMLOCK:
                return(Scan1ToKeynum[SC_VF3]);    // Convert Num Lock Key to vf3
            }
            break;
        }
#endif // NEC_98


        return  KeyEvent->wVirtualScanCode > sizeof(Scan1ToKeynumExtended)
		   ? 0
                   : Scan1ToKeynumExtended[KeyEvent->wVirtualScanCode];
    }
}





/*  BiosKeyToInputRecord
 *
 *  Translates Bios Buffer Keys to win32 console type of key_events.
 *
 *  entry: pKeyEvent                     - addr of KEY_EVENT structure
 *         pKeyEvent->uChar.AsciiChar    - Bios Buffer character
 *         pKeyEvent->wVirtualScanCode   - Bios Buffer scan code
 *
 *  exit: all KEY_EVENT fields are filled in.
 *        The AsciiChar has been converted to unicode
 *
 *  If a character is not in the current keyboard layout
 *  we return TRUE with: dwControlKeyState |= NUMLOCK_ON;
 *                       wVirtualKeyCode   = VK_MENU;
 *                       wVirtualScanCode  = 0x38;
 *                       OemChar (not unicode)
 */
BOOL BiosKeyToInputRecord(PKEY_EVENT_RECORD pKeyEvent)
{
    USHORT   KeyState;
    NTSTATUS Status;
    UCHAR    AsciiChar=(UCHAR)pKeyEvent->uChar.AsciiChar;
    WCHAR    UnicodeChar;

    pKeyEvent->wRepeatCount = 1;
    pKeyEvent->wVirtualKeyCode = 0;
    pKeyEvent->dwControlKeyState = 0;

        // we treat 0xF0 Ascii Char as NULL char just like the bios
    if (AsciiChar == 0xF0 && pKeyEvent->wVirtualScanCode) {
        AsciiChar = 0;
        }


      // convert oem char to unicode character, cause we can do it more
      // efficiently than console (already going thru char by char).
    Status = RtlOemToUnicodeN(&UnicodeChar,
                              sizeof(WCHAR),
                              NULL,
                              &AsciiChar,
                              1 );
    if (!NT_SUCCESS(Status)) {
        return FALSE;
        }



           // Convert BiosBuffer ScanCode for  NULL asciiChars to
           // windows scan code
    if ( (!AsciiChar) &&
         pKeyEvent->wVirtualScanCode >= FIRST_NULLCHARSCAN &&
         pKeyEvent->wVirtualScanCode <= LAST_NULLCHARSCAN  )
       {
         pKeyEvent->wVirtualScanCode -= FIRST_NULLCHARSCAN;
         pKeyEvent->dwControlKeyState = aNullCharScan[pKeyEvent->wVirtualScanCode].dwControlState;
         pKeyEvent->wVirtualScanCode  = aNullCharScan[pKeyEvent->wVirtualScanCode].wWinSCode;
         }


            // Some CTRL-Extended keys have special bios scan codes
            // These scan codes are not recognized by windows. Change
            // to a windows compatible scan code, and set CTRL flag
    else if (AsciiChar == 0xE0 && pKeyEvent->wVirtualScanCode)  {
        pKeyEvent->dwControlKeyState = ENHANCED_KEY;
        if (AsciiChar == 0xE0) {
            pKeyEvent->dwControlKeyState |= LEFT_CTRL_PRESSED;
            switch (pKeyEvent->wVirtualScanCode) {
              case 0x73: pKeyEvent->wVirtualScanCode = 0x4B;
                         break;
              case 0x74: pKeyEvent->wVirtualScanCode = 0x4D;
                         break;
              case 0x75: pKeyEvent->wVirtualScanCode = 0x4f;
                         break;
              case 0x76: pKeyEvent->wVirtualScanCode = 0x51;
                         break;
              case 0x77: pKeyEvent->wVirtualScanCode = 0x47;
                         break;
              case 0x84: pKeyEvent->wVirtualScanCode = 0x49;
                         break;
              case 0x8D: pKeyEvent->wVirtualScanCode = 0x48;
                         break;
              case 0x91: pKeyEvent->wVirtualScanCode = 0x50;
                         break;
              case 0x92: pKeyEvent->wVirtualScanCode = 0x52;
                         break;
              case 0x93: pKeyEvent->wVirtualScanCode = 0x53;
                         break;

              default: // the rest should have correct scan codes
                       // but not CTRL bit
                    pKeyEvent->dwControlKeyState &= ~LEFT_CTRL_PRESSED;
              }
            }

        AsciiChar   = 0;
        UnicodeChar = 0;
        }


            // The keypad "/" and the keypad "enter" special cases

    else if (pKeyEvent->wVirtualScanCode == 0xE0)  {
        pKeyEvent->dwControlKeyState = ENHANCED_KEY;
        if (AsciiChar == 0x2f) {               // is keypad "/"
            pKeyEvent->wVirtualScanCode = 0x35;
            pKeyEvent->wVirtualKeyCode  = VK_DIVIDE;
            }
        else {                    // is keypad enter   chars == 0xd, 0xa
            pKeyEvent->wVirtualScanCode = 0x1C;
            pKeyEvent->wVirtualKeyCode  = VK_RETURN;
            if (AsciiChar == 0xA) {
                pKeyEvent->dwControlKeyState |= LEFT_CTRL_PRESSED;
                }
            }
        }



        // get control flags\VirtualKey for normal ascii characters,

    else if (AsciiChar &&
              pKeyEvent->wVirtualScanCode != 0x01 &&  // ESC
              pKeyEvent->wVirtualScanCode != 0x0E &&  // Backspace
              pKeyEvent->wVirtualScanCode != 0x0F &&  // Tab
              pKeyEvent->wVirtualScanCode != 0x1C )   // Enter
        {

        KeyState = (USHORT) VkKeyScanW(UnicodeChar);

        if (KeyState == 0xFFFF)  {
             /*  fail means not a physical key (ALT-NUMPAD entry sequence)
              *  Proper emeulation requires that we generate it by doing
              *  ALT-NUMLOCK-xxx-NUMLOCK-ALT.
              *  We shortcut this by sending console, the final key event.
              *  hoping that apps won't notice the difference.
              */
            pKeyEvent->wVirtualScanCode  = 0;
            pKeyEvent->wVirtualKeyCode   = VK_MENU;  // dummy opt
            }
        else {
            pKeyEvent->wVirtualKeyCode   = (WORD)LOBYTE(KeyState);
            if (KeyState & 0x100)
                pKeyEvent->dwControlKeyState |= SHIFT_PRESSED;
            if (KeyState & 0x200)
                pKeyEvent->dwControlKeyState |= LEFT_CTRL_PRESSED;
            if (KeyState & 0x400)
                pKeyEvent->dwControlKeyState |= LEFT_ALT_PRESSED;

              // some keys get mapped to different scan codes (NUMPAD)
              // so get matching scan code
            pKeyEvent->wVirtualScanCode  = (USHORT)MapVirtualKey(pKeyEvent->wVirtualKeyCode,0);
            }
        }


      // Get a Virtual KeyCode, if we don't have one yet
    if (!pKeyEvent->wVirtualKeyCode)  {
        pKeyEvent->wVirtualKeyCode = (USHORT)MapVirtualKey(pKeyEvent->wVirtualScanCode,3);
        if (!pKeyEvent->wVirtualKeyCode) {
             return FALSE;
             }
        }

    pKeyEvent->uChar.UnicodeChar = UnicodeChar;


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_hunt.c ===
#include "windows.h"
#include "host_def.h"
#include "insignia.h"
/*[
Name:  hunt.c
	Derived From:	X_hunt.c ( base 2.0 )
	Author:		gvdl ( Original by Mike McCusker )
	Created On:	3 May 1991
Sccs ID: 07/29/91 @(#)hunt.c 1.7
	Purpose:	Contains all host_dependent code for hunter

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#include <stdio.h>
#include <errno.h>
#include TypesH


#include "xt.h"
#include "ios.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "gvi.h"
#include "cga.h"
#include "error.h"
#include "config.h"
#include "nt_uis.h"



#include "debug.h"

#ifdef HUNTER
#include "hunter.h"


extern HANDLE InstHandle;

/*
* ============================================================================
* Global Defines and Declarations
* ============================================================================
*/
GLOBAL HANDLE TrapperDump = -1;

LOCAL  VOID  nt_hunter_init IPT1(SHORT, mode);
LOCAL  VOID  nt_hunter_activate_menus IPT0();
LOCAL  VOID  host_flip_video_ind IPT0();
LOCAL  VOID  nt_hunter_mark_error IPT2(int, x, int, y);
LOCAL  VOID  nt_hunter_erase_error IPT0();
LOCAL  VOID  nt_hunter_draw_box IPT1(BOX *, b);
LOCAL  ULONG nt_hunter_image_check IPT0();
LOCAL  VOID  nt_hunter_display_image IPT0();



DWORD CreateTrapperWindow IPT0();
LONG FAR PASCAL TrapperWindowEvents IPT4(HWND, hTrapWnd, WORD, message, LONG, wParam, LONG, lParam);





GLOBAL HUNTER_HOST_FUNCS hunter_host_funcs = 
{
nt_hunter_init,
nt_hunter_activate_menus,
host_flip_video_ind,
nt_hunter_mark_error,
nt_hunter_mark_error,
nt_hunter_draw_box,      
nt_hunter_draw_box,      
nt_hunter_image_check,
nt_hunter_display_image,
};


LOCAL BOX	lastBox;		/* last box drawn during movement */

HWND  hTrapWnd;

LOCAL VOID nt_hunter_activate_menus IFN0()
{
printf("nt_hunter_activate_menus() called\n");
}

LOCAL VOID host_flip_video_ind IFN0()
{
printf("host_flip_video() called\n");
}



LOCAL VOID nt_hunter_init IFN1(SHORT, mode)
{
    char *dumpFile;

    /* Read environment to see if we have a trapper file to open. */
    if ((dumpFile = host_getenv("HUDUMPFILE")) != NULL)
    {
	TrapperDump = CreateFile((LPCTSTR) dumpFile,
				 (DWORD) GENERIC_WRITE,
				 (DWORD) 0,
				 (LPSECURITY_ATTRIBUTES) NULL,
				 (DWORD) CREATE_ALWAYS,
				 (DWORD) FILE_ATTRIBUTE_NORMAL,
				 (HANDLE) 0);
	if (TrapperDump == (HANDLE) -1)
	    printf("Failed to open trapper file \"%s\".\n", dumpFile);
    }
}

LOCAL VOID nt_hunter_draw_box IFN1(BOX *, b)
{
HDC  hDC;
HPEN hPen;
int  x1,x2,y1,y2;


x1=(b->top_x >> 1);
y1=(b->top_y >> 1);
x2=(b->bot_x >> 1);
y2=(b->bot_y >> 1);

hDC=GetDC(hTrapWnd);
SetROP2(hDC,R2_COPYPEN);
hPen=CreatePen(PS_SOLID,0,RGB(0,255,0));
SelectObject(hDC,hPen);

MoveToEx(hDC,x1,y1,NULL);
LineTo(hDC,x1,y2);
LineTo(hDC,x2,y2);
LineTo(hDC,x2,y1);
LineTo(hDC,x1,y1);
DeleteObject(hPen);
ReleaseDC(hTrapWnd,hDC);
}


LOCAL VOID nt_hunter_mark_error IFN2(int, x, int, y)
{
int  x1,x2,y1,y2;
HPEN hPen;
HDC  hDC;


x1=x-4;
y1=y-4;
x2=x+4;
y2=y+4;


hDC=GetDC(hTrapWnd);
SetROP2(hDC,R2_XORPEN);
hPen=CreatePen(PS_SOLID,0,RGB(0,255,0));
SelectObject(hDC,hPen);

/*
*   Draw cross in the approximate region of error 
*/

MoveToEx(hDC,x1,y,NULL);
LineTo(hDC,x2,y);
MoveToEx(hDC,x,y1,NULL);
LineTo(hDC,x,y2);
DeleteObject(hPen);
ReleaseDC(hTrapWnd,hDC);

}

LOCAL VOID nt_hunter_erase_error IFN0()
{
InvalidateRect(hTrapWnd,NULL,TRUE);
}

LOCAL ULONG nt_hunter_image_check IFN0()
{
printf("nt_hunter_image_check() called\n");
return FALSE;
}

LOCAL VOID nt_hunter_display_image IFN0()
{
printf("nt_hunter_display_image() called\n");
}


DWORD CreateTrapperWindow IFN0()
{
WNDCLASS  WndCls;
MSG msg;
HDC  hDC;
HPEN hPen;


WndCls.style	       = CS_HREDRAW | CS_VREDRAW;
WndCls.lpfnWndProc   = (WNDPROC) TrapperWindowEvents;
WndCls.hInstance     = GetModuleHandle(NULL);
WndCls.hIcon	       = NULL;
WndCls.hCursor       = LoadCursor(NULL,IDC_ARROW);
WndCls.hbrBackground = GetStockObject(BLACK_BRUSH);
WndCls.lpszMenuName  = NULL;
WndCls.lpszClassName = (LPSTR) "Trapper";
WndCls.cbClsExtra    = 0;
WndCls.cbWndExtra    = 0;

RegisterClass(&WndCls);

hTrapWnd = CreateWindow("Trapper", "Trapper",WS_THICKFRAME | WS_OVERLAPPED | 
                                             WS_CAPTION,
                                  200,200,520,440, (HWND) NULL, NULL,
                                  GetModuleHandle(NULL), (LPSTR) NULL);

ShowWindow(hTrapWnd,SW_SHOWNORMAL);
UpdateWindow(hTrapWnd);

while(GetMessage(&msg, NULL, NULL, NULL))
   {
   TranslateMessage(&msg);   
   DispatchMessage(&msg);    /* Dispatch Message to event handler */
   }

}

/*============================================================================

Function to handle the messages passed to the trapper monitor window.
Since we send no messages to it, the function responds with default action
to any that it does get.

============================================================================*/


LONG FAR PASCAL TrapperWindowEvents IFN4(HWND, hTrapWnd, WORD, message, LONG, wParam, LONG, lParam)
{
PAINTSTRUCT	ps;

switch(message)
   {
   case WM_PAINT:
   BeginPaint(hTrapWnd,&ps);
   EndPaint(hTrapWnd,&ps);
   return 0;
   }
return(DefWindowProc(hTrapWnd, message, wParam, lParam));
}
#endif /*HUNTER*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_lpt.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddvdm.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
#include <malloc.h>

/*
 *	Name:			nt_lpt.c
 *	Derived From:		Sun 2.0 sun4_lpt.c
 *	Author:			D A Bartlett
 *	Created On:
 *	Purpose:		NT specific parallel port functions
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 *

 * Note. This port is unlike most ports because the config system has been
 *     removed. It was the job of the config system to validate and open the
 *     printer ports. The only calls to the host printer system are now
 *     make from printer.c. and consist of the following calls.
 *
 *
 *    1) host_print_byte
 *    2) host_print_auto_feed
 *    3) host_print_doc
 *    4) host_lpt_status
 *
 *
 *    On the Microsoft model the printer ports will be opened when they are
 *    written to.
 *
 *    Modifications:
 *
 *    Tim June 92. Amateur attempt at buffered output to speed things up.
 *
 */


/*


Work outstanding on this module,

1) Check the usage of port_state
2) Check error handling in write function
3) host_print_doc() always flushs the port, is this correct ?
4) host_print_auto_feed - what should this function do ?
5) Error handling in host_printer_open(), UIF needed ?

*/



/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#ifdef PRINTER

/* SoftPC include files */
#include "xt.h"
#include "error.h"
#include "config.h"
#include "timer.h"
#include "host_lpt.h"
#include "hostsync.h"
#include "host_rrr.h"
#include "gfi.h"
#include "debug.h"
#include "idetect.h"
#include "sas.h"
#include "printer.h"
#ifndef PROD
#include "trace.h"
#endif

#if defined(NEC_98)
boolean flushBuffer IFN0();
boolean host_print_buffer();
#else  // !NEC_98

boolean flushBuffer IFN1(int, adapter);
#ifdef MONITOR
extern BOOLEAN MonitorInitializePrinterInfo(WORD, PWORD, PUCHAR, PUCHAR, PUCHAR, PUCHAR);
extern BOOLEAN MonitorEnablePrinterDirectAccess(WORD, HANDLE, BOOLEAN);
extern BOOLEAN MonitorPrinterWriteData(WORD Adapter, BYTE Value);

extern  sys_addr lp16BitPrtBuf;
extern  sys_addr lp16BitPrtCount;
extern  sys_addr lp16BitPrtId;
boolean host_print_buffer(int adapter);
#endif
#endif // !NEC_98


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: Macros ::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#if defined(NEC_98)
#define get_lpt_status()        (host_lpt.port_status)
#define set_lpt_status(val)     (host_lpt.port_status = (val))
#else  // !NEC_98
#ifdef MONITOR

sys_addr lpt_status_addr;

#define get_lpt_status(adap) \
			(sas_hw_at_no_check(lpt_status_addr+(adap)))
#define set_lpt_status(adap,val) \
			(sas_store_no_check(lpt_status_addr+(adap), (val)))

#else /* MONITOR */

#define get_lpt_status(adap)		(host_lpt[(adap)].port_status)
#define set_lpt_status(adap,val)	(host_lpt[(adap)].port_status = (val))

#endif /* MONITOR */
#endif // !NEC_98

#if defined(NEC_98)         
#define KBUFFER_SIZE 5120       // Buffer Extend 
#define HIGH_WATER 5100         
#define DIRECT_ACCESS_HIGH_WATER    5100
#else  // !NEC_98
#define KBUFFER_SIZE 1024	// Buffering macros
#define HIGH_WATER 1020
#define DIRECT_ACCESS_HIGH_WATER    1020
#endif // !NEC_98

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: Structure for host specific state data ::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

typedef struct
{
    ULONG port_status;		   // Port status
    HANDLE handle;                 // Printer handle
    int inactive_counter;          // Inactivate counter
    int inactive_trigger;	   // When equal to inactive_counter close port
    int bytesInBuffer;             // current size of buffer
    int flushThreshold; 	   //
    DWORD FileType;                // DISK, CHAR, PIPE etc.
    BOOLEAN active;                // Printer open and active
    BOOLEAN dos_opened;            // printer opened with DOS open
    byte *kBuffer;                 // output buffer
    BOOLEAN direct_access;
    BOOLEAN no_device_attached;
} HOST_LPT;

#if defined(NEC_98)         
HOST_LPT host_lpt;                                              
#else  // !NEC_98
HOST_LPT host_lpt[NUM_PARALLEL_PORTS];
#endif // !NEC_98

#ifndef NEC_98
#ifdef MONITOR

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::: On x86 machines the host_lpt_status table is kept on the 16-bit  ::::*/
/*:::: side in order to reduce the number of expensive BOPs. Here we    ::::*/
/*:::: are passed the address of the table.				::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL void host_printer_setup_table(sys_addr table_addr, word nPorts, word * portAddr)
{
    lpt_status_addr = table_addr + 3 * NUM_PARALLEL_PORTS;

    //  Now fill in the TIB entries for printer_info
    MonitorInitializePrinterInfo (nPorts,
				  portAddr,
				  (LPBYTE)(table_addr + NUM_PARALLEL_PORTS),
				  (LPBYTE)(table_addr + 2 * NUM_PARALLEL_PORTS),
				  (LPBYTE)(table_addr),
				  (LPBYTE)(lpt_status_addr)
				 );
}

#endif /* MONITOR */
#endif // !NEC_98

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::: Set auto close trigger :::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


#if defined(NEC_98)
VOID host_set_inactivate_counter()
#else  // !NEC_98
VOID host_set_inactivate_counter(int adapter)
#endif // !NEC_98
{
#if defined(NEC_98)
    FAST HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
    FAST HOST_LPT *lpt = &host_lpt[adapter];
#endif // !NEC_98
    int close_in_ms;				// Flush rate in milliseconds

    /*::::::::::::::::::::::::::::::::::::::::::::::: Is auto close enabled */


    if(!config_inquire(C_AUTOFLUSH, NULL))
    {
	lpt->inactive_trigger = 0;	    /* Disable auto flush */
	return;			    /* Autoflush not active */
    }

    /*::::::::::::::::::::::::::::::::::::::::::: Calculate closedown count */

    close_in_ms = ((int) config_inquire(C_AUTOFLUSH_DELAY, NULL)) * 1000;

    lpt->inactive_trigger = close_in_ms / (SYSTEM_TICK_INTV/1000);

    lpt->inactive_counter = 0;	    //Reset  close down counter
    lpt->no_device_attached = FALSE;
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::: Open printer :::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#if defined(NEC_98)
SHORT host_lpt_open(BOOLEAN direct_access)
#else  // !NEC_98
SHORT host_lpt_open(int adapter, BOOLEAN direct_access)
#endif // !NEC_98
{
    DWORD BytesReturn;

#if defined(NEC_98)
    FAST HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
    FAST HOST_LPT *lpt = &host_lpt[adapter];	 // Adapter control structure
#endif // !NEC_98
    CHAR *lptName;				 // Adapter filename

    if (!direct_access)
	lpt->no_device_attached = FALSE;
    else if (lpt->no_device_attached)
	return FALSE;

    lpt->bytesInBuffer = 0;			// Init output buffer index

    /*::::::::::::::::::::::::::::::::::::::::: Get printer name for Config */

    /* use a different device name for DONGLE support */
#if defined(NEC_98)
    lptName = (CHAR *) config_inquire((UTINY)((direct_access ? C_VDMLPT1_NAME :
								C_LPT1_NAME)
					      ), NULL);
#else  // !NEC_98
    lptName = (CHAR *) config_inquire((UTINY)((direct_access ? C_VDMLPT1_NAME :
								C_LPT1_NAME)
					      + adapter), NULL);

#ifndef PROD
    fprintf(trace_file, "Opening printer port %s (%d)\n",lptName,adapter);
#endif
#endif // !NEC_98

    if ((lpt->kBuffer = (byte *)host_malloc (KBUFFER_SIZE)) == NULL) {
        // dont put a popup here as the caller of this routine handles it
        return(FALSE);
    }
    lpt->flushThreshold = HIGH_WATER;

    /*:::::::::::::::::::::::::::::::::::::::::::::::::::::::: Open printer */


    lpt->direct_access = FALSE;
    lpt->active = FALSE;

    lpt->handle = CreateFile(lptName,
                             GENERIC_WRITE,
			     direct_access ? 0 : FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);


    /*:::::::::::::::::::::::::::::::::::::::::::::::::: Valid open request */

    if(lpt->handle == (HANDLE) -1)
    {
        host_free (lpt->kBuffer);
	// UIF needed to inform user that the open attempt failed
#ifndef PROD
	fprintf(trace_file, "Failed to open printer port\n");
#endif
	if (direct_access && GetLastError() == ERROR_FILE_NOT_FOUND)
	    lpt->no_device_attached = TRUE;

	return(FALSE);
    }


    /*::::::::::::::::::::::::::::::::::::::Activate port and reset status */

    lpt->FileType = GetFileType(lpt->handle);
    // can not open direct_access access to a redirected device.
    if (direct_access && lpt->FileType != FILE_TYPE_CHAR) {
	CloseHandle(lpt->handle);
	return FALSE;
    }
    lpt->active = TRUE;
#if defined(NEC_98)
    set_lpt_status(0);
#else  // !NEC_98
    set_lpt_status(adapter, 0);
#endif // !NEC_98
    lpt->direct_access = direct_access;
    if (lpt->direct_access) {
	lpt->flushThreshold = DIRECT_ACCESS_HIGH_WATER;
#ifndef NEC_98
#ifdef MONITOR
	MonitorEnablePrinterDirectAccess((WORD)adapter, lpt->handle, TRUE);
#endif
#endif // !NEC_98
    }


    /*:::::::::::::::::::::::::::::::::::::::::: Setup auto close counters */

#if defined(NEC_98)
    host_set_inactivate_counter();
#else  // !NEC_98
    host_set_inactivate_counter(adapter);
#endif // !NEC_98

    return(TRUE);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: Close all printer ports ::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


GLOBAL void host_lpt_close_all(void)
{
    FAST HOST_LPT *lpt;
    FAST int i;


    /*::::::::::: Scan through printer adapters updating auto flush counters */


#if defined(NEC_98)
    lpt = &host_lpt;
    if(lpt->active) host_lpt_close();
#else  // !NEC_98
    for(i=0, lpt = &host_lpt[0]; i < NUM_PARALLEL_PORTS; i++, lpt++)
    {

	if(lpt->active)
	    host_lpt_close(i);	       /* Close printer port */
    }
#endif // !NEC_98
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::: Close printer :::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#if defined(NEC_98)
VOID host_lpt_close()
#else  // !NEC_98
VOID host_lpt_close(int adapter)
#endif // !NEC_98
{
    DWORD   BytesReturn;

#if defined(NEC_98)
    FAST HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
    FAST HOST_LPT *lpt = &host_lpt[adapter];

    if (lpt->direct_access)
	printer_is_being_closed(adapter);
#endif // !NEC_98


#if defined(NEC_98)
        host_print_buffer ();
#else  // !NEC_98
#ifdef MONITOR
    if (sas_hw_at_no_check(lp16BitPrtId) == adapter){
        host_print_buffer (adapter);
        sas_store_no_check(lp16BitPrtId,0xff);
    }
#endif
#endif // !NEC_98
    /*::::::::::::::::::::::::::::::::::::::::: Is the printer port active */

    if(lpt->active)
    {
	/*
	** Tim June 92. Flush output buffer to get the last output out.
	** If there's an error I think we've got to ignore it.
	*/
#if defined(NEC_98)
        (void)flushBuffer();
#else  // !NEC_98
	(void)flushBuffer(adapter);
#endif // !NEC_98

#ifndef NEC_98
#ifndef PROD
	fprintf(trace_file, "Closing printer port (%d)\n",adapter);
#endif
#ifdef MONITOR
	if (lpt->direct_access)
	    MonitorEnablePrinterDirectAccess((WORD)adapter, lpt->handle, FALSE);
#endif
#endif // !NEC_98
        CloseHandle(lpt->handle);     /* Close printer port */
        host_free (lpt->kBuffer);
	lpt->handle = (HANDLE) -1;    /* Mark device as closed */

	lpt->active = FALSE;	      /* Deactive printer port */
#if defined(NEC_98)
        set_lpt_status(0);
#else  // !NEC_98
	set_lpt_status(adapter, 0);	      /* Reset port status */
#ifndef PROD
        fprintf(trace_file, "Counter expired, closing LPT%d\n", adapter+1);
#endif
#endif // !NEC_98
    }
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::: Return the status of the lpt channel for an adapter :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#if defined(NEC_98)
GLOBAL ULONG host_lpt_status()
{
        return(get_lpt_status());
}
#else  // !NEC_98
GLOBAL ULONG host_lpt_status(int adapter)
{
    return(get_lpt_status(adapter));
}
#endif // !NEC_98

#ifndef NEC_98
GLOBAL UCHAR host_read_printer_status_port(int adapter)
{
    FAST HOST_LPT *lpt = &host_lpt[adapter];
    UCHAR   PrinterStatus;
    DWORD   BytesReturn;


    if(!lpt->active)
    {
	/*:::::::::::::::::::::::::::: Port inactive, attempt to reopen it */

	if(!host_lpt_open(adapter, TRUE))
	{
#ifndef PROD
	    fprintf(trace_file, "file open error %d\n", GetLastError());
#endif
	    set_lpt_status(adapter, HOST_LPT_BUSY);
	    return(FALSE);	     /* exit, printer not active !!!! */
	}
    }
    if (lpt->bytesInBuffer)
	flushBuffer(adapter);
    if (!DeviceIoControl(lpt->handle,
		     IOCTL_VDM_PAR_READ_STATUS_PORT,
		     NULL,		    // no input buffer
		     0,
		     &PrinterStatus,
		     sizeof(PrinterStatus),
		     &BytesReturn,
		     NULL		    // no overlap
                     )) {

#ifndef PROD
       fprintf(trace_file,
               "host_read_printer_status_port failed, error = %ld\n",
               GetLastError()
               );
#endif
        PrinterStatus = 0;
    }
    return(PrinterStatus);
}
#endif // !NEC_98

#ifndef NEC_98
BOOLEAN host_set_lpt_direct_access(int adapter, BOOLEAN direct_access)
{
    DWORD   BytesReturn;

    FAST HOST_LPT *lpt = &host_lpt[adapter];

    host_lpt_close(adapter);
    host_lpt_open(adapter, direct_access);
    if (!lpt->active)
	set_lpt_status(adapter, HOST_LPT_BUSY);
    return (lpt->active);
}
#endif // !NEC_98

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Print a byte ::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*
** Buffer up bytes before they are printed.
** Strategy:
** Save each requested byte in the buffer.
** When the buffer gets full or there's a close request write the
** buffered stuff out.
** Don't forget about errors, eg if the write fails. What about a write
** failure during the close request though? Tough said Tim.
*/
/*
** flushBuffer()
** Finally write what is in the buffer to the parallel port. It could be a
** real port or a networked printer.
** Input parameter is the parallel port adapter number 0=LPT1
** Return value of TRUE means write was OK.
*/
#if defined(NEC_98)
boolean flushBuffer IFN0()
#else  // !NEC_98
boolean flushBuffer IFN1( int, adapter )
#endif // !NEC_98
{
#if defined(NEC_98)
        FAST HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
	FAST HOST_LPT *lpt = &host_lpt[adapter];
#endif // !NEC_98
	DWORD BytesWritten;

#ifndef NEC_98
	if (lpt->direct_access) {
	    DeviceIoControl(lpt->handle,
			    IOCTL_VDM_PAR_WRITE_DATA_PORT,
			    lpt->kBuffer,
			    lpt->bytesInBuffer,
			    NULL,
			    0,
			    &BytesWritten,
			    NULL
			    );

	    lpt->bytesInBuffer = 0;
	    return TRUE;

	}
#endif // !NEC_98


	if( !WriteFile( lpt->handle, lpt->kBuffer,
	                lpt->bytesInBuffer, &BytesWritten, NULL )
	  ){
#ifndef PROD
		fprintf(trace_file, "lpt write error %d\n", GetLastError());
#endif
		lpt->bytesInBuffer = 0;
		return(FALSE);
	}else{
                lpt->bytesInBuffer = 0;


                /*
                 *  If the print job is being spooled, the spooler can
                 *  take a long time to get started, because of the spoolers
                 *  low priority. This is especially bad for dos apps in which
                 *  idle detection fails or in full screen idle detection is
                 *  inactive. To help push the print job thru the system,
                 *  idle a bit now.
                 */
                if (lpt->FileType == FILE_TYPE_PIPE) {
                    Sleep(10);
                }
		return( TRUE );
	}
}	/* end of flushBuffer() */

/*
** Put another byte in to the buffer. If the buffer is full call the
** flush function.
** Return value of TRUE means OK, return FALSE means did a flush and
** it failed.
*/
#if defined(NEC_98)
boolean toBuffer IFN1(BYTE, b )
#else  // !NEC_98
boolean toBuffer IFN2( int, adapter, BYTE, b )
#endif // !NEC_98
{
#if defined(NEC_98)
        HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
	HOST_LPT *lpt = &host_lpt[adapter];
#endif // !NEC_98
	boolean status = TRUE;

	lpt->kBuffer[lpt->bytesInBuffer++] = b;

	if( lpt->bytesInBuffer >= lpt->flushThreshold ){
#if defined(NEC_98)
                status = flushBuffer();
#else  // !NEC_98
		status = flushBuffer( adapter );
#endif // !NEC_98
	}
	return( status );
}	/* end of toBuffer() */

#if defined(NEC_98)
GLOBAL BOOL host_print_byte(byte value)
#else  // !NEC_98
GLOBAL BOOL host_print_byte(int adapter, byte value)
#endif // !NEC_98
{
#if defined(NEC_98)
    FAST HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
    FAST HOST_LPT *lpt = &host_lpt[adapter];
#endif // !NEC_98

    /*:::::::::::::::::::::::::::::::::::::::::::: Is the printer active ? */

    if(!lpt->active)
    {
	/*:::::::::::::::::::::::::::: Port inactive, attempt to reopen it */

#if defined(NEC_98)
	if(!host_lpt_open(FALSE))
        {
            set_lpt_status(HOST_LPT_BUSY);
            return(FALSE);
        }
#else  // !NEC_98
	if(!host_lpt_open(adapter, FALSE))
	{
#ifndef PROD
	    fprintf(trace_file, "file open error %d\n", GetLastError());
#endif
	    set_lpt_status(adapter, HOST_LPT_BUSY);
	    return(FALSE);	     /* exit, printer not active !!!! */
	}
#endif // !NEC_98
    }
#ifndef NEC_98
#if defined(MONITOR)
    if (lpt->direct_access) {
	MonitorPrinterWriteData((WORD)adapter, value);
    }
    else
#endif
#endif // !NEC_98
	 {

        /*:::::::::::::::::::::::::::::::::::::::::::::::: Send byte to printer */

#if defined(NEC_98)
        if(toBuffer((BYTE) value) == FALSE)
        {
            set_lpt_status(HOST_LPT_BUSY);
            return(FALSE);
        }
#else  // !NEC_98
        if(toBuffer(adapter, (BYTE) value) == FALSE)
        {
            set_lpt_status(adapter, HOST_LPT_BUSY);
            return(FALSE);
        }
#endif // !NEC_98
    }

    /*::::::::::::::::::::::::::: Update idle and activate control variables */

    lpt->inactive_counter = 0; /* Reset inactivity counter */
    IDLE_comlpt();	       /* Tell Idle system there is printer activate */

    return(TRUE);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: LPT heart beat call ::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


GLOBAL void host_lpt_heart_beat(void)
{
#if defined(NEC_98)
    FAST HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
    FAST HOST_LPT *lpt = &host_lpt[0];
#endif // !NEC_98
    int i;

#if defined(NEC_98)
    {
        extern void NEC98_lpt_busy_check(void);

        NEC98_lpt_busy_check();
}
#endif // NEC_98

    /*::::::::::: Scan through printer adapters updating auto close counters */


#if defined(NEC_98)
    if(lpt->active && lpt->inactive_trigger &&
       ++lpt->inactive_counter == lpt->inactive_trigger)
    {
        host_lpt_close();
    }
#else  // !NEC_98
    for(i=0; i < NUM_PARALLEL_PORTS; i++, lpt++)
    {

	/*:::::::::::::::::::::::::::::::::::::::: Check auto close counters */

	if(lpt->active && lpt->inactive_trigger &&
	   ++lpt->inactive_counter == lpt->inactive_trigger)
        {
	    host_lpt_close(i);	    /* Close printer port */
	}
    }
#endif // !NEC_98
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::: Flush the printer port ::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#if 0
#if defined(NEC_98)
GLOBAL boolean host_print_doc()
{
        if(host_lpt.active) host_lpt_close();
        return(TRUE);
}
#else  // !NEC_98
GLOBAL boolean host_print_doc(int adapter)
{
    if(host_lpt[adapter].active) host_lpt_close(adapter);	    /* Close printer port */

    return(TRUE);
}
#endif // !NEC_98
#endif

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::: Reset the printer port ::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

#if defined(NEC_98)
GLOBAL void host_reset_print()
{
    if(host_lpt.active)
        host_lpt_close();
}
#else  // !NEC_98
GLOBAL void host_reset_print(int adapter)
{
    if(host_lpt[adapter].active)
	host_lpt_close(adapter);	    /* Close printer port */
}
#endif // !NEC_98


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::: host_print_auto_feed :::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
#ifndef NEC_98
GLOBAL void host_print_auto_feed(int adapter, BOOL value)
{
    UNREFERENCED_FORMAL_PARAMETER(adapter);
    UNREFERENCED_FORMAL_PARAMETER(value);
}
#else //NEC_98
GLOBAL void host_print_auto_feed(BOOL value)
{
    UNREFERENCED_FORMAL_PARAMETER(value);
}
#endif //NEC_98

#ifdef MONITOR

#if defined(NEC_98)
GLOBAL boolean host_print_buffer()
{
    FAST HOST_LPT *lpt = &host_lpt;
#else  // !NEC_98
GLOBAL boolean host_print_buffer(int adapter)
{
    FAST HOST_LPT *lpt = &host_lpt[adapter];
#endif // !NEC_98
    word cb;
    byte i,ch;

#ifndef NEC_98
    cb = sas_w_at_no_check(lp16BitPrtCount);
    if (!cb)
        return (TRUE);
#endif // !NEC_98

    /*:::::::::::::::::::::::::::::::::::::::::::: Is the printer active ? */

    if(!lpt->active)
    {
	/*:::::::::::::::::::::::::::: Port inactive, attempt to reopen it */

#if defined(NEC_98)
	if(!host_lpt_open(FALSE))
#else  // !NEC_98
	if(!host_lpt_open(adapter, FALSE))
#endif // !NEC_98
	{
#ifndef PROD
	    fprintf(trace_file, "file open error %d\n", GetLastError());
#endif
#if defined(NEC_98)
            set_lpt_status(HOST_LPT_BUSY);
#else  // !NEC_98
	    set_lpt_status(adapter, HOST_LPT_BUSY);
#endif // !NEC_98
	    return(FALSE);	     /* exit, printer not active !!!! */
	}
    }

#ifndef NEC_98
    if (!lpt->direct_access) {
        /*:::::::::::::::::::::::::::::::::::::::::::::::: Send byte to printer */

        for (i=0; i <cb; i++) {
            ch = sas_hw_at_no_check(lp16BitPrtBuf+i);
            if(toBuffer(adapter, ch) == FALSE)
            {
                set_lpt_status(adapter, HOST_LPT_BUSY);
                return(FALSE);
            }
        }
    }
    else {
	// we must no have any int 17 printing data waiting when we
	// we in direct access mode
	ASSERT(cb == 0);
	return FALSE;
    }
#endif // !NEC_98

    /*::::::::::::::::::::::::::: Update idle and activate control variables */

    lpt->inactive_counter = 0; /* Reset inactivity counter */
    IDLE_comlpt();	       /* Tell Idle system there is printer activate */

    return(TRUE);
}
#endif // MONITOR

GLOBAL void host_lpt_dos_open(int adapter)
{
#ifndef NEC_98
    FAST HOST_LPT *lpt = &host_lpt[adapter];

    lpt->dos_opened = TRUE;
#endif // !NEC_98
}

GLOBAL void host_lpt_dos_close(int adapter)
{
#ifndef NEC_98
    FAST HOST_LPT *lpt = &host_lpt[adapter];

    if (lpt->active)
        host_lpt_close(adapter);       /* Close printer port */
    lpt->dos_opened = FALSE;
#endif // !NEC_98
}

GLOBAL void host_lpt_flush_initialize()
{
#ifndef NEC_98
    FAST HOST_LPT *lpt;
    FAST int i;

    for(i=0, lpt = &host_lpt[0]; i < NUM_PARALLEL_PORTS; i++, lpt++)
        lpt->dos_opened = FALSE;

#endif // !NEC_98
}

#endif /* PRINTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_inthk.c ===
/*[
 *
 *  Name:	    nt_inthk.c
 *
 *  Derived From:   (original)
 *
 *  Author:	    Dave Bartlett
 *
 *  Created On:     11 Jan 1995
 *
 *  Coding Stds:    2.4
 *
 *  Purpose:        This module implements the memory management functions
 *                  required for 486 NT.
 *
 *  Include File:   nt_inthk.h
 *
 *  Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
]*/


#ifdef CPU_40_STYLE

/* Need all of the following to include nt.h and windows.h in the same file. */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "insignia.h"
#include "host_def.h"

#include "gdpvar.h"
#include "nt_inthk.h"
#include "debug.h"

/* Make local symbols visible if debugging. */
#ifndef PROD
#define LOCAL
#endif /* not PROD */

/* Macros and typedefs. */


/* Hardware interrupt handler */
LOCAL BOOL (*HWIntHandler)(ULONG) = NULL;

#if defined(CCPU) || !defined(PROD)
/* Software interrupt handler */
LOCAL BOOL (*SWIntHandler)(ULONG) = NULL;

/* Exception interrupt handler */
LOCAL BOOL (*EXIntHandler)(ULONG,ULONG) = NULL;

#endif /* CCPU */

/* Global Functions. */

/*(
============================= host_hwint_hook =================================
PURPOSE:
	This function is called from the ICA during the process of ACKing an
	hardware interrupt. This function will call a hardware interrupt handler
	if one is defined.

INPUT:
	Interrupt vector number generated from hardware interrupt
OUTPUT:
	Return value - TRUE    hardware interrupt processed
		       FALSE   process hardware interrupt in normal way
================================================================================
)*/


#if defined(CCPU) || !defined(PROD)
GLOBAL BOOL host_hwint_hook IFN1(IS32, int_no)
{
    BOOL returnStatus = FALSE;

    /* hardware interrupt handler defined ? */
    if(HWIntHandler)
    {
	returnStatus = (HWIntHandler)((ULONG) int_no);

#ifndef PROD
	if(!returnStatus)
	    always_trace0("Hardware interrupt handler failed");

#endif /* PROD */
    }

    return( returnStatus );
}
#endif

/*(
======================= VdmInstallHardwareIntHandler ===========================
PURPOSE:
	Register a hardware interrupt handler called before the CPU dispatches
	the interrupt.

INPUT:
	Hardware interrupt handler function

OUTPUT:
	Return value - NTSTATUS

================================================================================
)*/

GLOBAL NTSTATUS	VdmInstallHardwareIntHandler IFN1(PVOID, HardwareIntHandler)
{
#ifdef CCPU
    HWIntHandler = HardwareIntHandler;
#else
    GLOBAL_VDM_HwIntHandler = HardwareIntHandler;
#endif
    return(STATUS_SUCCESS);
}

/*(
============================= host_swint_hook =================================
PURPOSE:
	This function is called from the CCPU prior to provessing a software
	interrupt. This function will call a software interrupt handler
	if one is defined.

INPUT:
	Interrupt number
OUTPUT:
	Return value - TRUE    software interrupt processed
		       FALSE   process software interrupt in normal way

================================================================================
)*/


#if defined(CCPU) || !defined(PROD)
GLOBAL BOOL host_swint_hook IFN1(IS32, int_no)
{
    BOOL returnStatus = FALSE;

    /* software interrupt handler defined ? */
    if(SWIntHandler)
    {
	returnStatus = (SWIntHandler)((ULONG) int_no);

#ifndef PROD

	if(!returnStatus)
	    always_trace0("Software interrupt handler failed");

#endif /* PROD */
    }

    return( returnStatus );
}
#endif /* CCPU */

/*(
======================= VdmInstallSoftwareIntHandler ===========================
PURPOSE:
	Register a software interrupt handler called before the CPU dispatches
	the software interrupt.

INPUT:
	Software interrupt handler function

OUTPUT:
	Return value - NTSTATUS
================================================================================
)*/

GLOBAL NTSTATUS	VdmInstallSoftwareIntHandler IFN1(PVOID, SoftwareIntHandler)
{
#ifdef CCPU
    SWIntHandler = SoftwareIntHandler;
#else
    GLOBAL_VDM_SoftIntHandler = SoftwareIntHandler;
#endif
    return(STATUS_SUCCESS);
}

/*(
============================= host_exint_hook =================================
PURPOSE:
	This function is called from the CPU prior to processing a CPU
	exception interrupt. This function will call a exception interrupt
	handler if one is defined.

INPUT:
	Exception number
	Exception error code
OUTPUT:
	Return value - TRUE    hardware interrupt processed
		       FALSE   process hardware interrupt in normal way

================================================================================
)*/


#if defined(CCPU) || !defined(PROD)
GLOBAL BOOL host_exint_hook IFN2(IS32, exp_no, IS32, error_code)
{
    BOOL returnStatus = FALSE;

    /* exception interrupt handler defined ? */
    if(EXIntHandler)
    {
	returnStatus = (EXIntHandler)((ULONG) exp_no, (ULONG) error_code);

#ifndef PROD

	if(!returnStatus)
	    always_trace0("Exception interrupt handler failed (%x)");

#endif /* PROD */
    }

    return( returnStatus );
}
#endif /* CCPU */

/*(
======================= VdmInstallFaultHandler ===========================
PURPOSE:
	Register a CPU exception interrupt handler called before the CPU
	dispatches the exceptioninterrupt.

INPUT:
	Exception interrupt handler function

OUTPUT:
	Return value - NTSTATUS
================================================================================
)*/

GLOBAL NTSTATUS	VdmInstallFaultHandler IFN1(PVOID, FaultHandler)
{
#ifdef CCPU
    EXIntHandler = FaultHandler;
#else
    GLOBAL_VDM_FaultHandler = FaultHandler;
#endif
    return(STATUS_SUCCESS);
}

#endif /* CPU_40_STYLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_mess.c ===
#include "host_def.h"
/*
 *
 * Title	: Win32 specific error messages
 *
 * Description	: Text of Win32 specific error messages.
 *
 * Author	: M.McCusker
 *
 * Notes	: Add new error message to array. Message should 
 *		  not be longer than 100 characters.
 *
 *		  These messages should have an entry in hs_error.h
 *		  and are offset by 1000
 *
 * Mods: (r2.3) : Modified the text of the comms error messages.
 */

/* For Internationalization purposes it my be a good idea to move these
   message to the resource file. (Dave Bartlett) */

char	*hs_err_message[] = {
/*			0         1         2         3         4         5         6         7         8         9         * */
/*			0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890 */
/* FUNC_FAILED */	"Function failed",
/* EHS_SYSTEM_ERROR */	"NTVDM has encountered a System Error",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_mouse.c ===
#include "windows.h"
#include "insignia.h"
#include "host_def.h"
#include <stdio.h>
#include <sys/types.h>
#include <string.h>
#include "conapi.h"
#include "xt.h"
#include CpuH
#include "egacpu.h"
#include "trace.h"
#include "debug.h"
#include "gvi.h"
#include "error.h"
#include "config.h"
#include "bios.h"
#include "mouse_io.h"
#include "video.h"
#include "nt_graph.h"
#include "host_nls.h"
#include "sas.h"
#include "ica.h"
#include "idetect.h"
#include "host_rrr.h"
#include "nt_mouse.h"
#include "ntcheese.h"
#include "nt_uis.h"
#include "nt_reset.h"
#include "nt_eoi.h"
#include "nt_event.h"
#include <ntddvdeo.h>
#include "nt_fulsc.h"


#define TEXT_MODE          1
#define GRAPHICS_MODE      2
#define NOTHING            0xff
#define NOT_INSTALLED      0
#define INSTALLED          1

#define get_pix_height() (get_pc_pix_height() * get_host_pix_height())


GLOBAL BOOL  pointer_emulation_status = POINTER_EMULATION_OS;
GLOBAL word  VirtualX,VirtualY;
GLOBAL BOOL  bPointerOff=FALSE;
GLOBAL MOUSE_STATUS os_pointer_data;

IMPORT word         DRAW_FS_POINTER_SEGMENT, DRAW_FS_POINTER_OFFSET;
IMPORT word         POINTER_OFF_SEGMENT, POINTER_OFF_OFFSET;
IMPORT word         POINTER_ON_SEGMENT, POINTER_ON_OFFSET;
IMPORT word         CP_X_S, CP_X_O, CP_Y_S, CP_Y_O;
IMPORT sys_addr     conditional_off_sysaddr;

IMPORT word         F9_SEGMENT,F9_OFFSET;
IMPORT word         savedtextoffset,savedtextsegment;

#ifdef X86GFX
IMPORT sys_addr     mouseCFsysaddr;   // sas address of internal cursor flag
IMPORT word         button_off,button_seg;
IMPORT boolean mouse_io_interrupt_busy;
#ifdef JAPAN
IMPORT sys_addr     saved_ac_sysaddr, saved_ac_flag_sysaddr;
#endif // JAPAN

#define cursor_in_black_hole(cpx, cpy)  \
    (cpx >= black_hole.top_left.x && \
     cpx <= black_hole.bottom_right.x && \
     cpy >= black_hole.top_left.y && \
     cpy <= black_hole.bottom_right.y)

#endif //X86GFX


LOCAL BOOL           mouse_state;
LOCAL BOOL           bFullscTextBkgrndSaved = FALSE;
LOCAL BOOL           bPointerInSamePlace = FALSE;
LOCAL word           text_ptr_bkgrnd=0;  // safe place for screen background
LOCAL sys_addr       old_text_addr;
RECT                 WarpBorderRect;     // in screen coordinates
RECT                 WarpClientRect;     // in client coordinates

LOCAL POINT          pMiddle; // centre point of the current Console window
LOCAL POINT          pLast = {0,0};
LOCAL BOOL           bAlertMessage=TRUE;
LOCAL BOOL           b256mode=FALSE;
LOCAL int            old_x=319;    // previous pointer state (position)
LOCAL int            old_y=99;     // in virtual coordinates.
LOCAL short          m2pX=8,m2pY=16;      // Mickey to pixel ratios
LOCAL BOOL           bFunctionZeroReset = TRUE;
LOCAL BOOL           bFunctionFour = FALSE;
LOCAL IS16           newF4x,newF4y;



GLOBAL  VOID    host_os_mouse_pointer(MOUSE_CURSOR_STATUS *,MOUSE_CALL_MASK *,

                                      MOUSE_VECTOR *);

FORWARD BOOL   WarpSystemPointer(IS16 *,IS16 *);
FORWARD void   MovePointerToWindowCentre(void);
FORWARD void   host_mouse_install1(void);
FORWARD void   host_mouse_install2(void);
FORWARD void   mouse_restore_cursor(void);
FORWARD void   deinstall_host_mouse(void);
FORWARD BOOL   mouse_installed(void);
FORWARD BOOL   mouse_in_use(void);
FORWARD void   mouse_reset(void);
FORWARD void   mouse_set_position(USHORT,USHORT);
FORWARD void   mouse_cursor_display(void);
FORWARD void   mouse_cursor_undisplay(void);
FORWARD void   mouse_cursor_mode_change(void);
FORWARD BOOL   HasConsoleClientRectChanged(void);
FORWARD void   MouseDisplay();
FORWARD void   CToS(RECT *);
FORWARD void   MouseDetachMenuItem(BOOL);
FORWARD void   MouseAttachMenuItem(HANDLE);
FORWARD void   MouseReattachMenuItem(HANDLE);
FORWARD void   ResetMouseOnBlock(void);
FORWARD void   ScaleToWindowedVirtualCoordinates(IS16 *,IS16 *,MOUSE_VECTOR *);
FORWARD void   host_m2p_ratio(word *,word *,word *,word *);
FORWARD void   host_x_range(word *,word *,word *,word *);
FORWARD void   host_y_range(word *,word *,word *,word *);
FORWARD void   EmulateCoordinates(half_word,IS16,IS16,IS16 *,IS16 *);
FORWARD void   AssembleCallMask(MOUSE_CALL_MASK *);
FORWARD void   FullscTextPtr(int, int);
FORWARD void   WindowedGraphicsScale(half_word,IS16,IS16,IS16 *,IS16 *);
FORWARD void   dummy(short *,short *,unsigned short *);
FORWARD void   LimitCoordinates(half_word,IS16 *,IS16 *);
#ifdef X86GFX
FORWARD void   CleanUpMousePointer();
FORWARD void   FullscreenWarpSystemPointer(POINT *);
FORWARD void   ScaleToFullscreenVirtualCoordinates(IS16 *,IS16 *,MOUSE_VECTOR *);
#endif //X86GFX
FORWARD void   TextScale(IS16 *,IS16 *,IS16 *, IS16 *);

void LazyMouseInterrupt();
VOID MouseEoiHook(int IrqLine, int CallCount);
BOOLEAN bSuspendMouseInterrupts=FALSE;

#ifdef JAPAN
extern int is_us_mode();
#endif // JAPAN

GLOBAL   HOSTMOUSEFUNCS   the_mouse_funcs =
{
   mouse_restore_cursor,
   deinstall_host_mouse,
   mouse_installed,
   mouse_in_use,
   mouse_reset,
   mouse_set_position,
   dummy,
   mouse_cursor_display,
   mouse_cursor_undisplay,
   mouse_cursor_mode_change
};

BOOL   bMouseMenuItemAdded=FALSE;
HMENU  hM;

//
// look up table to convert the video mode number to a mode type indicator
//

LOCAL half_word TextOrGraphicsModeLUT[] =
   {
   TEXT_MODE,    TEXT_MODE,    TEXT_MODE,    TEXT_MODE,    GRAPHICS_MODE,
   GRAPHICS_MODE,GRAPHICS_MODE,NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      GRAPHICS_MODE,GRAPHICS_MODE,
   GRAPHICS_MODE,GRAPHICS_MODE,GRAPHICS_MODE,GRAPHICS_MODE,GRAPHICS_MODE,
   GRAPHICS_MODE,NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      TEXT_MODE,    NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      TEXT_MODE,
   TEXT_MODE,    TEXT_MODE,    TEXT_MODE,    TEXT_MODE,    TEXT_MODE,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      NOTHING,      NOTHING,      NOTHING,      NOTHING,
   NOTHING,      GRAPHICS_MODE,GRAPHICS_MODE,GRAPHICS_MODE
   };

#define DEFAULT_VIDEO_MODE 0x14
half_word Max_Standard_Mode = 0x13;
LOCAL int VirtualScrCtrLUTx[] =
   {
   319,         // mode 0
   319,         // mode 1
   319,         // mode 2
   319,         // mode 3
   319,         // mode 4
   319,         // mode 5
   319,         // mode 6
   319,         // mode 7
   319,         // mode 8
   319,         // mode 9
   319,         // mode a
   319,         // mode b
   319,         // mode c
   319,         // mode d
   319,         // mode e
   319,         // mode f
   319,         // mode 10
   319,         // mode 11
   319,         // mode 12
   159,         // mode 13
   319          // Unknown Mode (default to mode 12)
                // NOTE, we really needs to find out what is the resolution for
                // the non-standard mode
   };
LOCAL int VirtualScrCtrLUTy[] =
   {
   99,         // mode 0
   99,         // mode 1
   99,         // mode 2
   99,         // mode 3
   99,         // mode 4
   99,         // mode 5
   99,         // mode 6
   99,         // mode 7
   99,         // mode 8
   99,         // mode 9
   99,         // mode a
   99,         // mode b
   99,         // mode c
   99,         // mode d
   99,         // mode e
   174,        // mode f
   174,        // mode 10
   239,        // mode 11
   239,        // mode 12
   99,         // mode 13
   239         // Unknown Mode (deault to mode 12)
               // NOTE, we really needs to find out what is the resolution for
               // the non-standard mode
   };

//
// A look up table to convert a console cell location to a virtual pixel
// coordinate.
//

int ConsoleTextCellToVPCellLUT[] =
   {
   0, 8, 16, 24, 32, 40, 48, 56,
   64, 72, 80, 88, 96, 104, 112, 120,
   128, 136, 144, 152, 160, 168, 176, 184,
   192, 200, 208, 216, 224, 232, 240, 248,
   256, 264, 272, 280, 288, 296, 304, 312,
   320, 328, 336, 344, 352, 360, 368, 376,
   384, 392, 400, 408, 416, 424, 432, 440,
   448, 456, 464, 472, 480, 488, 496, 504,
   512, 520, 528, 536, 544, 552, 560, 568,
   576, 584, 592, 600, 608, 616, 624, 632,
   640, 648, 656, 664, 672, 680, 688, 696
   };


//
// This structure holds the information provided by int 33h functions 7 and 8.
// If one of these functions have been called, then the appropriate flag in
// the structure is set and the handler for this will ignore the default bounds
// for the current video mode and will use the values in the structure instead.
// The flags will clear if a mode change has been detected too.
//

struct
   {
   word xmin;
   word ymin;
   word xmax;
   word ymax;
   BOOL bF7;
   BOOL bF8;
   } confine = {0,0,639,199,FALSE,FALSE};
//
// Mouse interrupt regulation mechanisms
//
BOOLEAN bMseEoiPending = FALSE;
ULONG MseIntLazyCount = 0;

//
//
// The code starts here
//
//

GLOBAL void host_mouse_install1(void)
{
mouse_state = INSTALLED;
RegisterEOIHook(9, MouseEoiHook);
mouse_install1();
}


GLOBAL void host_mouse_install2(void)
{
mouse_install2();
}


GLOBAL void mouse_restore_cursor()
{
/* If mouse not in use exit */

if(!mouse_in_use())
   return;

}

GLOBAL void deinstall_host_mouse()
{
mouse_state = NOT_INSTALLED;
}


GLOBAL BOOL mouse_installed()
{
return (mouse_state);
}

void dummy(short *pooh1,short *pooh2, unsigned short *pooh3)
{
}

GLOBAL BOOL mouse_in_use()
{
#if defined(NEC_98)
return(TRUE);
#else  // !NEC_98
return(mouse_state == INSTALLED && in_text_mode() == FALSE);
#endif // !NEC_98
}

GLOBAL void mouse_reset()
{
#ifdef X86GFX

half_word vm;
word xx,yy;

//
// Set the internal cursor flag to "just off"
// the real driver sets the internal cursor flag to -1
// so do I.
//

sas_store(mouseCFsysaddr,0xff); // cursor hidden

//
// Set the fast track position words in the 16 bit driver.
// First igure out the video mode, and from this, the virtual
// screen centre.
//

sas_load(0x449,&vm);
#ifdef JAPAN
    vm = (is_us_mode()) ? vm : ((vm == 0x72) ? 0x12 : 3);
#endif // JAPAN
if (vm > Max_Standard_Mode) {
    vm = DEFAULT_VIDEO_MODE;
}
xx = (word)VirtualScrCtrLUTx[vm];
yy = (word)VirtualScrCtrLUTy[vm];

//
// The values for the confining virtual pixel coordinate rectangle
// as set up by int 33h functions 7 and 8 are now released and the
// default virtual bounds are used.
//

confine.bF7 = FALSE;   // reset the flag indicating a int 33h function 7
confine.bF8 = FALSE;   // reset the flag indicating a int 33h function 8

bFunctionZeroReset = TRUE;

//
// write the centre position data back to the 16 bit driver.
//

if(sc.ScreenState == FULLSCREEN)
   {
   //
   // Force a host_os_mouse_pointer call to do the
   // write back into the 16 bit driver.
   //
   LazyMouseInterrupt();
   }
#endif /*X86GFX */

//
// Set the default Mickey to pixel ratios
// This is set to 8 pixels to 8 Mickeys in the horizontal direction
// and 16 pixels to 8 Mickeys in the vertical.
//

m2pX = 8;
m2pY = 16;

}


GLOBAL void mouse_set_position IFN2(USHORT, newx, USHORT, newy)
{
#ifdef X86GFX
word      currentCS, currentIP, currentCX, currentDX;
boolean   currentIF;
half_word internalCF;

   //
   // write the new position to the 16 bit driver for the fast
   // int33hf3 calls on X86.
   //

   sas_storew(effective_addr(button_seg,((word)(button_off+2))),(word)newx);
   sas_storew(effective_addr(button_seg,((word)(button_off+4))),(word)newy);

#endif //X86GFX


//
// Both Fullscreen and MouseHidePointer enabled windowed mode
// mouse emulations are driven by a set of emulated counters.
// X,Y values are held independently to these counters and rely
// on this function to set up absolute values for X and Y. Note:
// reset does this too.
//

if(sc.ScreenState == WINDOWED && bPointerOff)
   {
   newF4x = (IS16)newx;
   newF4y = (IS16)newy;
   bFunctionFour = TRUE;
   return;
   }
#ifdef X86GFX
else if(sc.ScreenState == FULLSCREEN)
   {
   //
   // The values that are passed in are hot and fresh from the app.
   // Since they have not been tainted by the base, they are still
   // in virtual coordinates which is cool.
   //

   //
   // Get the internal cursor flag from the 16 bit driver
   //

   sas_load(mouseCFsysaddr,&internalCF);

   //
   // Only draw the pointer if the internal cursor flag
   // is zero. Note: less than zero == don't draw.
   //

   if(!internalCF)
      {
      /* if conditional off is diabled or the cursor is outside the
       *         conditional off rectangle, move the cursor
       */

      if (sas_hw_at_no_check(conditional_off_sysaddr) == 0 ||
          !cursor_in_black_hole(newx, newy))
          {
          currentCS=getCS();
          currentIP=getIP();
          currentCX=getCX();
          currentDX=getDX();
          currentIF=getIF();
          setCS(DRAW_FS_POINTER_SEGMENT); // sacrificial data
          setIP(DRAW_FS_POINTER_OFFSET);
          setCX((word)newx);
          setDX((word)newy);
          setIF(FALSE);
          //
          // call back to 16bits move cursor code.
          //

          host_simulate();

          //
          // Tidy up
          //

          setCX(currentCX);
          setDX(currentDX);
          setCS(currentCS);
          setIP(currentIP);
          setIF(currentIF);
      }
      else {
          /* the cursor was moved into the conditional rectangle, hide it */
          sas_store(mouseCFsysaddr, 0xff);
          host_hide_pointer();
      }
   }
   newF4x = (IS16)newx;
   newF4y = (IS16)newy;
   bFunctionFour = TRUE;

   //
   // update the last mouse position global locators
   //

   old_x = newx;
   old_y = newy;
   }
#endif //X86GFX
}

GLOBAL void mouse_cursor_display()
{
}

GLOBAL void mouse_cursor_undisplay()
{
}

GLOBAL void mouse_cursor_mode_change()
{
}


GLOBAL  void host_mouse_conditional_off_enabled(void)
{
#ifdef X86GFX
    word x, y;

    /*  hide the cursor if
     *  (1). we are in full screen  and
     *  (2). the cursor is on and is in the conditional area
     */
    if (sc.ScreenState == FULLSCREEN &&
        !sas_hw_at_no_check(mouseCFsysaddr)) {

        x = sas_w_at_no_check(effective_addr(CP_X_S, CP_X_O));
        y = sas_w_at_no_check(effective_addr(CP_Y_S, CP_Y_O));
        if (cursor_in_black_hole(x, y)) {
            sas_store(mouseCFsysaddr, 0xff);
            host_hide_pointer();
        }
    }
#endif


}
//==============================================================================
// Hook function that forms the communication transition between
// the host and the base for os pointer emulation. This function
// is called by mouse_int1() which lives in mouse_io.c
//==============================================================================


VOID host_os_mouse_pointer(MOUSE_CURSOR_STATUS *mcs,MOUSE_CALL_MASK *call_mask,
                           MOUSE_VECTOR *counter)
{
#ifdef X86GFX
sys_addr int33f3addr;
#endif // X86GFX

host_ica_lock(); // synch with the event thread

GetNextMouseEvent();

#ifdef X86GFX

if(sc.ScreenState == FULLSCREEN)
   {
   ScaleToFullscreenVirtualCoordinates(&mcs->position.x,&mcs->position.y,counter);
   }
else
#endif // X86GFX
   {
   ScaleToWindowedVirtualCoordinates(&mcs->position.x,&mcs->position.y,counter);
   }

//
// Create a condition mask for use by any call back installed
// by the application.
//

AssembleCallMask(call_mask);

//
// Tell the base about the button state
//

mcs->button_status=os_pointer_data.button_l | os_pointer_data.button_r<<1;

host_ica_unlock();  // synch with the event thread


//
// Has the pointer moved since the last mouse interrupt.
// This can happen if a button press occurs but no physical
// movement of the mouse body takes place.
//

if(bPointerInSamePlace)
   {
   //
   // The mouse has not moved since the last mouse
   // hardware interrupt.
   //

   *call_mask &= ~1;
   }
else
   {
#ifdef X86GFX
   half_word internalCF;
#endif // X86GFX

   //
   // The mouse has moved.
   //

   *call_mask |= 1;

#ifdef X86GFX

   //
   // Inquire from the 16 bit driver whether or not the
   // pointer can be drawn.
   // internalCF < 0 -> cannot draw
   // internalCF == 0 okay to draw.
   //

   sas_load(mouseCFsysaddr,&internalCF);

   //
   // If the system has fullscreen capabilities and is in fullscreen
   // mode, then if the pointer has been switched on, draw it on the
   // fullscreen display.
   //

   if(sc.ScreenState == FULLSCREEN && !internalCF)
      {
      half_word v;
      static half_word hwLastModeType;

      if (sas_hw_at_no_check(conditional_off_sysaddr) == 0 ||
          !cursor_in_black_hole(mcs->position.x, mcs->position.y))
      {
          //
          // Get the current BIOS video mode a la B.D.A.
          //

          sas_load(0x449,&v);

#ifdef JAPAN
          if (!is_us_mode() ||
             (hwLastModeType = TextOrGraphicsModeLUT[v]) == GRAPHICS_MODE)
#else // !JAPAN
          if (v > Max_Standard_Mode) {
              v = DEFAULT_VIDEO_MODE;
          }
          if((hwLastModeType = TextOrGraphicsModeLUT[v]) == GRAPHICS_MODE)
#endif // !JAPAN
             {
             word currentCS,currentIP;     // save those interesting Intel registers
             word currentCX,currentDX;
             boolean   currentIF;

             //
             // Do the host simulate here to draw the cursor image
             // for the full screen graphics
             //

             currentCS=getCS();
             currentIP=getIP();
             currentCX=getCX();
             currentDX=getDX();
             currentIF=getIF();
             setCS(DRAW_FS_POINTER_SEGMENT);
             setIP(DRAW_FS_POINTER_OFFSET);
             setCX(mcs->position.x);
             setDX(mcs->position.y);
             setIF(FALSE);
             //
             // call to 16bits move cursor code
             //

             host_simulate();

             //
             // Restore the 16 bit context.
             //

             setCX(currentCX);
             setDX(currentDX);
             setCS(currentCS);
             setIP(currentIP);
             setIF(currentIF);
             }
          else // TEXT_MODE
             {
             //
             // if there has been a switch from graphics mode to text mode
             // then there cannot have been a backround saved.
             //

             if(hwLastModeType == GRAPHICS_MODE)
                {
                bFullscTextBkgrndSaved = FALSE;
                hwLastModeType = TEXT_MODE;
                }

             //
             // Use some 32 bit code to draw the text pointer because
             // no hardware i/o is involved and we need only to write to
             // the display buffer (16 bit code is needed to do video
             // i/os in fullscreen mode).
             //

             FullscTextPtr(mcs->position.x,mcs->position.y);
             }
        }
        else {
            sas_store(mouseCFsysaddr, 0xff);
            host_hide_pointer();
        }
    }
#endif     // X86GFX
   }


//
// Write data to the 16 bit driver for int 33h function 3 to pick up
// without having to BOP to the 32 bit side.
// Int 33h function 3 requires this data:
//     BX = button status
//     CX = virtual pixel position in x
//     DX = virtual pixel position in y
//

#ifdef X86GFX
int33f3addr = effective_addr(button_seg,button_off);
sas_storew(int33f3addr,mcs->button_status);
sas_storew(int33f3addr+=2, (word)(mcs->position.x));
sas_storew(int33f3addr+=2, (word)(mcs->position.y));
#endif //X86GFX
}

//==============================================================================
// Function to munge the status register value for the InPort adapter.
// Nothing much else to say about it really.
//
//==============================================================================

void AssembleCallMask(MOUSE_CALL_MASK *call_mask)
{
static int old_l_button=0;      // previous mouse button state
static int old_r_button=0;


//
// add in the left button current status
//

if(os_pointer_data.button_l)
   {
   //
   // Left button is down.
   //

   if(!old_l_button)
      {
      //
      // The button has just been pressed
      //

      *call_mask |= (1<<1);
      }
   else
      {
      //
      // The button was down on the last hardware interrupt, so
      // release the edge detect.
      //

      *call_mask &= ~(1<<1);
      }
   }
else
   {
   //
   // Left button is up.
   //

   if(old_l_button)
      {
      //
      // The button has just been released
      //

      *call_mask |= (1<<2);
      }
   else
      {
      //
      // The button was up on the last hardware interrupt, so
      // release the edge detect.
      //

      *call_mask &= ~(1<<2);
      }
   }

//
// add in the right button current status
//

if(os_pointer_data.button_r)
   {
   //
   // Right button is down.
   //

   if(!old_r_button)
      {
      //
      // The button has just been pressed
      //

      *call_mask |= (1<<3);
      }
   else
      {
      //
      // The button was down on the last hardware interrupt, so
      // release the edge detect.
      //

      *call_mask &= ~(1<<3);
      }
   }
else
   {
   //
   // Right button is up.
   //

   if(old_r_button)
      {
      //
      // The button has just been released
      //

      *call_mask |= (1<<4);
      }
   else
      {
      //
      // The button was up on the last hardware interrupt, so
      // release the edge detect.
      //

      *call_mask &= ~(1<<4);
      }
   }

//
//
// save the current mouse button status.
//

old_l_button = os_pointer_data.button_l;
old_r_button = os_pointer_data.button_r;

}

#ifdef X86GFX
//=========================================================================
// Function to scale mouse coordinates as retrieved from USER
// to virtual coordinates as defined by the Microsoft Mouse
// Programmer's Reference.
//=========================================================================

void ScaleToFullscreenVirtualCoordinates(IS16 *outx,IS16 *outy,
                                         MOUSE_VECTOR *counter)
{
half_word video_mode,textorgraphics;
IS16 internalX = 0, internalY = 0;
static IS16 lastinternalX=0, lastinternalY=0;
POINT  vector;                 // Magnitude and direction since last call


//
// Manage the system pointer so that it never sticks to a system
// imposed boundary. Also get a relative displacement of the mouse.
//

FullscreenWarpSystemPointer(&vector);

//
// return the internal counter values back to the base
// code for it to use to generate the counters there.
//

counter->x = (MOUSE_SCALAR)vector.x;
counter->y = (MOUSE_SCALAR)vector.y;

//
// Get the current BIOS video mode from the B.D.A. This comes
// in handy in a couple of places later.
//

sas_load(0x449,&video_mode);
#ifdef JAPAN
video_mode = (is_us_mode()) ? video_mode : ( (video_mode == 0x72) ? 0x12 : 3);
#endif // JAPAN
if (video_mode > Max_Standard_Mode) {
    video_mode = DEFAULT_VIDEO_MODE;
}

//
// checkout some global flags with indicate if one of the int 33h
// functions which are capable of changing the position of the
// DOS mouse driver pointer have been called since the last mouse
// hardware interrupt.
//

if(bFunctionZeroReset)
   {
   //
   // Calculate the centre of the default virtual screen
   // and set the current generated coordinates to it.
   //

   internalX = (IS16)VirtualScrCtrLUTx[video_mode];
   internalY = (IS16)VirtualScrCtrLUTy[video_mode];

   bFunctionZeroReset = FALSE;
   }
else if(bFunctionFour)
   {
   //
   // The application has set the pointer to a new location.
   // Tell the internal cartesian coordinate system about this.
   //

   internalX = newF4x;  // This is where the pointer was set to
   internalY = newF4y;  // by the app on the last pending call to f4

   //
   // Don't come in here again until the next function 4.
   //

   bFunctionFour = FALSE;
   }
else
   {
   //
   // The most frequent case. Determine the new, raw pointer position
   // by adding the system pointer movement vector to the last position
   // of the emulated pointer.
   //

   internalX = lastinternalX + (IS16)vector.x;
   internalY = lastinternalY + (IS16)vector.y;
   }

//
// use the video mode to determine if we're running text or graphics
//

textorgraphics=TextOrGraphicsModeLUT[video_mode];

//
// Scale the coordinates appropriately for the current video mode
// and the type (text or graphics) that it is.
//

if(textorgraphics == TEXT_MODE)
   {
   //
   // The virtual cell block is 8 by 8 virtual pixels for any text mode.
   // This means that the cell coordinates in virtual pixels increments
   // by 8 in the positive x and y directions and the top left hand corner
   // of the cell starts at 0,0 and has the virtual pixel value for the
   // whole text cell.
   //

   TextScale(&internalX,&internalY,outx,outy);
   }

else // GRAPHICS_MODE
   {
   LimitCoordinates(video_mode,&internalX,&internalY);
   *outx = internalX;
   *outy = internalY;
   }

//
// Set up the current emulated position for next time through
// this function.
//

lastinternalX = internalX;
lastinternalY = internalY;

//
// Signal that the pointer hasn't moved, if it hasn't
//

bPointerInSamePlace = (!vector.x && !vector.y) ? TRUE : FALSE;

//
// save the current position for next time.
//

old_x = *outx;
old_y = *outy;
}

//==============================================================================
// Function to make sure that the system pointer can be made to move in a
// given cartesian direction without hitting and finite boundaries as specified
// by the operating system.
//==============================================================================
void FullscreenWarpSystemPointer(POINT *vector)
{
static POINT pMyLast;         // System pointer position data from last time through
POINT  pCurrent;

//
// Get a system mouse pointer absolute position value back from USER.
//

GetCursorPos(&pCurrent);

//
// Calculate the vector displacement of the system pointer since
// the last call to this function.
//

vector->x = pCurrent.x - pMyLast.x;
vector->y = pCurrent.y - pMyLast.y;

//
// Has the system pointer hit a border? If so, warp the system pointer
// back to the convienient location of 0,0.
//


if(pCurrent.x >= (LONG)1000 || pCurrent.x <= (LONG)-1000 ||
   pCurrent.y >= (LONG)1000 || pCurrent.y <= (LONG)-1000)
   {
   //
   // If the counters have warped, set the system pointer
   // to the relavent position.
   //

   SetCursorPos(0,0);
   pMyLast.x = 0L;        // prevent a crazy warp
   pMyLast.y = 0L;
   }
else
   {
   //
   // update the last position data of the
   // system pointer for next time through.
   //
   pMyLast = pCurrent;
   }
}

#endif // X86GFX

//=========================================================================
// Function to scale mouse coordinates as returned by the event loop
// mechanism to virtual coordinates as defined by the Microsoft Mouse
// Programmer's Reference. The method used for scaling depends on the style
// of mouse buffer selected, the current video mode and if (for X86) the
// video system is operating in full screen or windowed mode.
//
// Output: Virtual cartesian coordinates in the same pointers
//=========================================================================

void ScaleToWindowedVirtualCoordinates(IS16 *outx,IS16 *outy,
                                       MOUSE_VECTOR *counter)
{
half_word video_mode,textorgraphics;
SAVED SHORT last_text_good_x = 0, last_text_good_y = 0;

sas_load(0x449,&video_mode);
#ifdef JAPAN
video_mode = (is_us_mode()) ? video_mode : ( (video_mode == 0x72) ? 0x12 : 3);
#endif // JAPAN
if (video_mode > Max_Standard_Mode) {
    video_mode = DEFAULT_VIDEO_MODE;
}
//
// Follow different code paths if the user has the system pointer
// hidden or displayed.
//

if(!bPointerOff)
   {
   //
   // The pointer has not been hidden by the user, so use the
   // x,y values as got from the system pointer via the Windows
   // messaging system.
   //

   //
   // get the video mode to determine if we're running text or graphics
   //

   textorgraphics=TextOrGraphicsModeLUT[video_mode];

   if(textorgraphics == TEXT_MODE)
      {
      //
      // validate received data to ensure not graphics mode coords
      // received during mode switch.
      //

      if(os_pointer_data.x > 87)
         {
         *outx = last_text_good_x;
         }
      else
         {
         *outx = (IS16)ConsoleTextCellToVPCellLUT[os_pointer_data.x];
         last_text_good_x = *outx;
         }
      if(os_pointer_data.y > 87)
         {
         *outy = last_text_good_y;
         }
      else
         {
         *outy = (IS16)ConsoleTextCellToVPCellLUT[os_pointer_data.y];
         last_text_good_y = *outy;
         }
      }
   else // GRAPHICS_MODE
      {
      //
      // If the mouse is NOT in a warping mode, then x,y's as received
      // from the console are scaled if they are for a low resolution
      // video mode and these are what the application sees and the
      // system pointer image is in the correct place to simulate the
      // 16 bit pointer.
      // If the application decides to extend the x,y bounds returned
      // from the driver beyond the limits of the console being used,
      // these x,y's are not appropriate, and the mouse must be switched
      // into warp mode by the user and the code will emulate the x,y
      // generation.
      //

      WindowedGraphicsScale(video_mode,(IS16)(os_pointer_data.x),
                            (IS16)(os_pointer_data.y),outx,outy);
      }

   //
   // No warping, so set up the old_x and old_y values directly.
   // Signal that the pointer hasn't moved, if it hasn't
   //

   bPointerInSamePlace = (old_x == *outx && old_y == *outy) ? TRUE : FALSE;

   //
   // Set these statics for the next time through.
   //

   old_x = *outx;
   old_y = *outy;
   }
else
   {
   //
   // The user has set the system pointer to be hidden via the
   // console's system menu.
   // Handle by emulating the counters and generating absolute x,y
   // data from this.
   //

   IS16 move_x,move_y;

   //
   // Get positional data from the system pointer and maintain some
   // counters.
   //

   if(WarpSystemPointer(&move_x,&move_y))
      {
      //
      // The mouse moved.
      // Generate some new emulated absolute position information.
      //

      EmulateCoordinates(video_mode,move_x,move_y,outx,outy);

      //
      // Save up the current emulated position for next time through.
      //


      old_x = *outx;
      old_y = *outy;

      //
      // Send back the relative motion since last time through.
      //

      counter->x = move_x;
      counter->y = move_y;

      bPointerInSamePlace = FALSE;
      }
   else
      {
      //
      // No recorded movement of the mouse.
      //

      *outx = (IS16)old_x;
      *outy = (IS16)old_y;
      counter->x = counter->y = 0;
      bPointerInSamePlace = TRUE;
      }
   }
}


//==============================================================================
// Function to scale the incoming fullscreen coordinates to mouse motion (both
// absolute and relative) for fullscreen text mode.
// Note: if the application chooses to, it can reset the virtual coordinate
// bounds of the virtual screen. This function checks the bound flags and either
// selects the default values or the app imposed values.
//
// This function is also used to modify the coordinates produced directly from
// the motion counters in windowed text mode.
//==============================================================================

void TextScale(IS16 *iX,IS16 *iY,IS16 *oX, IS16 *oY)
{
half_word no_of_rows;

//
// Calculate the current system pointer location in virtual
// pixels for the application.
//

if(confine.bF7)
   {
   //
   // Limits have been imposed by the application.
   //

   if(*iX < confine.xmin)
      {
      *iX = confine.xmin;
      }
   else if(*iX > confine.xmax)
      {
      *iX = confine.xmax;
      }
   }
else // use the default virtual screen constraints.
   {
   //
   // No limits have been imposed by the application.
   // x is always 0 -> 639 virtual pixels for text mode
   //

   if(*iX < 0)
      {
      *iX = 0;
      }
   else if(*iX > 639)
      {
      *iX = 639;
      }
   }

//
// Bind the y cartesian coordinate appropriately
//

if(confine.bF8)
   {
   //
   // Limits have been imposed by the application.
   //

   if(*iY < confine.ymin)
      {
      *iY = confine.ymin;
      }
   else if(*iY > confine.ymax)
      {
      *iY = confine.ymax;
      }
   }
else
   {
   //
   // The application has not imposed constraints on the Y virtual pixel
   // motion, so confine the Y movement to the default virtual pixel size
   // of the virtual screen for the current video mode.
   //

   if(*iY < 0)
      {
      *iY = 0;
      }
   else
      {
      //
      // Get the number of text rows minus one, from the B.D.A.
      //

      sas_load(0x484,&no_of_rows);

      switch(no_of_rows)
         {
         case 24:
            {
            //
            // 25 rows, so there are 200 vertical virtual pixels
            //
            if(*iY > 199)
               {
               *iY = 199;
               }
            break;
            }
         case 42:
            {
            //
            // 43 rows, so there are 344 vertical virtual pixels
            //
            if(*iY > 343)
               {
               *iY = 343;
               }
            break;
            }
         case 49:
            {
            //
            // 50 rows, so there are 400 vertical virtual pixels
            //
            if(*iY > 399)
               {
               *iY = 399;
               }
            break;
            }
         default:
            {
            //
            // default - assume 25 rows, so there are
            // 200 vertical virtual pixels
            //
            if(*iY > 199)
               {
               *iY = 199;
               }
            break;
            }
         }
      }
   }
*oX = *iX;
*oY = *iY;
}


//==============================================================================
// Fit the raw x,y coordinates generated from the counters to the bounds of
// the virtual screen that is currently set up. This can be set up either by
// the application (in the confine structure) or as set by the mouse driver
// as default.
//==============================================================================

void LimitCoordinates(half_word vm,IS16 *iX,IS16 *iY)
{
//
// Select the appropriate conditioning code for
// the current video mode.
//
switch(vm)
   {

   //
   // Do the common text modes.
   //

   case(2):
   case(3):
   case(7):
      {
      IS16 oX,oY;

      //
      // Scale the generated coordinates for the given text mode
      // and the number of rows of text displayed on the screen.
      //

      TextScale(iX,iY, &oX, &oY);
      *iX = oX;
      *iY = oY;
      break;
      }

   //
   // The regular VGA supported graphics video modes.
   //
   // The following modes are all 640 x 200 virtual pixels
   //
   case(4):
   case(5):
   case(6):
   case(0xd):
   case(0xe):
   case(0x13):
      {
      if(confine.bF7)
         {
         //
         // Limits have been imposed by the application.
         //

         if(*iX < confine.xmin)
            {
            *iX = confine.xmin;
            }
         else if(*iX > confine.xmax)
            {
            *iX = confine.xmax;
            }
         }
      else
         {
         //
         // The application has not imposed limits, so use
         // the default virtual screen bounds as defined byt
         // the mouse driver.
         //

         if(*iX < 0)
            *iX = 0;
         else if(*iX > 639)
            *iX = 639;
         }

      if(confine.bF8)
         {
         //
         // Limits have been imposed by the application.
         //

         if(*iY < confine.ymin)
            {
            *iY = confine.ymin;
            }
         else if(*iY > confine.ymax)
            {
            *iY = confine.ymax;
            }
         }
      else
         {
         //
         // The application has not imposed limits, so use
         // the default virtual screen bounds as defined byt
         // the mouse driver.
         //
         if(*iY < 0)
            *iY = 0;
         else if(*iY > 199)
            *iY = 199;
         }
      break;
      }
   //
   // The following modes are all 640 x 350 virtual pixels
   //
   case(0xf):
   case(0x10):
      {
      if(confine.bF7)
         {
         //
         // Limits have been imposed by the application.
         //

         if(*iX < confine.xmin)
            {
            *iX = confine.xmin;
            }
         else if(*iX > confine.xmax)
            {
            *iX = confine.xmax;
            }
         }
      else
         {
         //
         // The application has not imposed limits, so use
         // the default virtual screen bounds as defined byt
         // the mouse driver.
         //

         if(*iX < 0)
            *iX = 0;
         else if(*iX > 639)
            *iX = 639;
         }

      if(confine.bF8)
         {
         //
         // Limits have been imposed by the application.
         //

         if(*iY < confine.ymin)
            {
            *iY = confine.ymin;
            }
         else if(*iY > confine.ymax)
            {
            *iY = confine.ymax;
            }
         }
      else
         {
         //
         // The application has not imposed limits, so use
         // the default virtual screen bounds as defined byt
         // the mouse driver.
         //

         if(*iY < 0)
            *iY = 0;
         else if(*iY > 349)
            *iY = 349;
         }
      break;
      }
   //
   // The following modes are all 640 x 480 virtual pixels
   //
   case(0x11):
   case(0x12):
   case(DEFAULT_VIDEO_MODE):
      {
      if(confine.bF7)
         {
         //
         // Limits have been imposed by the application.
         //

         if(*iX < confine.xmin)
            {
            *iX = confine.xmin;
            }
         else if(*iX > confine.xmax)
            {
            *iX = confine.xmax;
            }
         }
      else
         {
         //
         // The application has not imposed limits, so use
         // the default virtual screen bounds as defined byt
         // the mouse driver.
         //

         if(*iX < 0)
            *iX = 0;
         else if(*iX > 639)
            *iX = 639;
         }

      if(confine.bF8)
         {
         //
         // Limits have been imposed by the application.
         //

         if(*iY < confine.ymin)
            {
            *iY = confine.ymin;
            }
         else if(*iY > confine.ymax)
            {
            *iY = confine.ymax;
            }
         }
      else
         {
         //
         // The application has not imposed limits, so use
         // the default virtual screen bounds as defined byt
         // the mouse driver.
         //

         if(*iY < 0)
            *iY = 0;
         else if(*iY > 479)
            *iY = 479;
         }
      break;
      }

   //
   // From here on down are the Video7 modes
   //

   case(0x60):
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 751)
         *iX = 751;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 407)
         *iY = 407;
      break;
      }
   case(0x61):
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 719)
         *iX = 719;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 535)
         *iY = 535;
      break;
      }
   case(0x62):
   case(0x69):
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 799)
         *iX = 799;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 599)
         *iY = 599;
      break;
      }
   case(0x63):
   case(0x64):
   case(0x65):
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 1023)
         *iX = 1023;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 767)
         *iY = 767;
      break;
      }
   case(0x66):
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 639)
         *iX = 639;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 399)
         *iY = 399;
      break;
      }
   case(0x67):
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 639)
         *iX = 639;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 479)
         *iY = 479;
      break;
      }
   case(0x68):
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 719)
         *iX = 719;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 539)
         *iY = 539;
      break;
      }
   default:
      {
      if(*iX < 0)
         *iX = 0;
      else if(*iX > 639)
         *iX = 639;

      if(*iY < 0)
         *iY = 0;
      else if(*iY > 199)
         *iY = 199;
      break;
      }
   }
}

//==============================================================================
// Function to scale the incoming windowed coordinates since the window size
// can be larger (for the low resolution modes) than the virtual screen size
// for that mode.
//==============================================================================

void WindowedGraphicsScale(half_word vm,IS16 iX,IS16 iY,IS16 *oX, IS16 *oY)
{
//#if !defined(i386) && defined(JAPAN) //DEC-J Dec. 21 1993 TakeS
//in use of $disp.sys, mouse cursor cannot move correctly.
//if( is_us_mode() ){
//#endif // _ALPHA_ && JAPAN
switch(vm)
   {
   //
   // The following modes are all 640 x 200 virtual pixels
   //
   case(4):
   case(5):
   case(6):
   case(0xd):
   case(0xe):
   case(0x13):
      {
      //
      // Low resolution graphics modes. The window is 640 x 400 real host
      // pixels, but the virtual screen resolution is 640 x 200. Hence
      // must divide the y value by 2 to scale appropriately.
      //

      iY >>= 1;
      break;
      }
   }
//#if !defined(i386) && defined(JAPAN) //DEC-J Dec. 21 1993 TakeS
//}else
//  iY >>= 1;
//#endif // _ALPHA_ && JAPAN
//
// prepare the cartesian coordinate values to return.
//

*oX = iX;
*oY = iY;
}

//===========================================================================
// Function to turn on the mouse cursor in FULLSCREEN mode.
// Note: This function only gets called after the 16 bit code checks
// to see if the internal cursor flag is zero. The 16 bit code does
// not do the BOP if, after incrementing this counter, the above is
// true.
//===========================================================================

void host_show_pointer()
{
#ifdef X86GFX

if(sc.ScreenState == FULLSCREEN)
   {
   half_word v;
   sas_load(0x449,&v);

#ifdef JAPAN
   if (!is_us_mode() || TextOrGraphicsModeLUT[v] == GRAPHICS_MODE)
#else // !JAPAN
   if (v > Max_Standard_Mode) {
       v = DEFAULT_VIDEO_MODE;
   }
   if(TextOrGraphicsModeLUT[v] == GRAPHICS_MODE)
#endif // !JAPAN
   {
          word currentCS,currentIP; // save those interesting Intel registers
          boolean currentIF;

          sas_storew(effective_addr(CP_X_S,CP_X_O),(word)old_x);
          sas_storew(effective_addr(CP_Y_S,CP_Y_O),(word)old_y);
          currentCS=getCS();
          currentIP=getIP();
          currentIF=getIF();
          setCS(POINTER_ON_SEGMENT);
          setIP(POINTER_ON_OFFSET);
          setIF(FALSE);
          host_simulate();

          setCS(currentCS);
          setIP(currentIP);
          setIF(currentIF);
    }
    else //TEXT_MODE
    {
          FullscTextPtr(old_x,old_y);
    }

   LazyMouseInterrupt();
   }
#endif // X86GFX
}

//===========================================================================
// Function to turn off the mouse cursor in FULLSCREEN mode.
// Note: This function only gets called after the 16 bit code checks
// to see if the internal cursor flag is zero. The 16 bit code does
// not do the BOP if, after decrementing this counter, the above is
// true.
//===========================================================================

void host_hide_pointer()
{
#ifdef X86GFX

if(sc.ScreenState == FULLSCREEN)
   {
   half_word v;

   sas_load(0x449,&v);

#ifdef JAPAN
   if (!is_us_mode() || TextOrGraphicsModeLUT[v] == GRAPHICS_MODE)
#else // !JAPAN
   if (v > Max_Standard_Mode) {
       v = DEFAULT_VIDEO_MODE;
   }
   if(TextOrGraphicsModeLUT[v] == GRAPHICS_MODE)
#endif // !JAPAN
      {
      word currentCS,currentIP; // save those interesting Intel registers
      boolean currentIF;

      currentCS=getCS();
      currentIP=getIP();
      currentIF=getIF();
      setCS(POINTER_OFF_SEGMENT);
      setIP(POINTER_OFF_OFFSET);
      setIF(FALSE);
      host_simulate();

      setCS(currentCS);
      setIP(currentIP);
      setIF(currentIF);
      }
   else //TEXT_MODE
      {
      if(bFullscTextBkgrndSaved)
         {
         sas_storew(old_text_addr,text_ptr_bkgrnd);
         bFullscTextBkgrndSaved = FALSE;
         }
      }
   LazyMouseInterrupt();
   }
#endif // X86GFX
}

//=========================================================================
// Function to remove the mouse pointer item from the console system menu
// when SoftPC lets an application quit or iconise.
// If the system pointer is OFF i.e. clipped to a region in the current window,
// then relinquish it to the system.
//
// bForce allows the code which gets called when there is a fullscreen to
// windowed graphics switch on x86 to force the menu item off.
//=========================================================================

void MouseDetachMenuItem(BOOL bForce)
{
if(bMouseMenuItemAdded || bForce)
   {
   DeleteMenu(hM,IDM_POINTER,MF_BYCOMMAND);
   bMouseMenuItemAdded=FALSE;
   ClipCursor(NULL);
   }
bAlertMessage=TRUE; // blocking, so reset the int33h f11 alert mechanism
}

void MouseAttachMenuItem(HANDLE hBuff)
{
if(!bMouseMenuItemAdded)
   {
   //
   // Read in the relavent string from resource
   //

   hM = ConsoleMenuControl(hBuff,IDM_POINTER,IDM_POINTER);
   AppendMenuW(hM,MF_STRING,IDM_POINTER,wszHideMouseMenuStr);
   bMouseMenuItemAdded=TRUE;

   //
   // initial state -> system pointer is ON
   //

   bPointerOff=FALSE;
   }
}

//=========================================================================
// Function to determine if the active output buffer has changed if the VDM
// has done something weird like resized or gone from graphics to fullscreen
// or vice versa. If so, a new handle to the new buffer must be got, and the
// old menu item deleted and a new menu item attach so that the new buffer
// "knows" about the menu item I.D.
//=========================================================================

void MouseReattachMenuItem(HANDLE hBuff)
{
static HANDLE hOld = 0;   // The handle for the last buffer selected.

//
// If the output buffer has not changed, then don't do anything.
//

if(hOld == hBuff)
   return;

//
// First thing, remove the old menu item.
//

MouseDetachMenuItem(TRUE);

//
// Next, Add in the new menu item for the current buffer.
//

MouseAttachMenuItem(hBuff);

//
// Record the value of the latest buffer for next time.
//

hOld = hBuff;
}

void MouseHide(void)
{

ModifyMenuW(hM,IDM_POINTER,MF_BYCOMMAND,IDM_POINTER,
            wszDisplayMouseMenuStr);

//
// Clip the pointer to a region inside the console window
// and move the pointer to the window centre
//

while(ShowConsoleCursor(sc.ActiveOutputBufferHandle,FALSE)>=0)
   ;
MovePointerToWindowCentre();
bPointerOff=TRUE;
}

void MouseDisplay(void)
{

ModifyMenuW(hM,IDM_POINTER,MF_BYCOMMAND,IDM_POINTER,
            wszHideMouseMenuStr);

//
// Let the pointer move anywhere on the screen
//

ClipCursor(NULL);
while(ShowConsoleCursor(sc.ActiveOutputBufferHandle,TRUE)<0)
   ;
bPointerOff=FALSE;
}

void MovePointerToWindowCentre(void)
{
RECT rTemp;

//
// Get current console client rectangle, set the clipping region to match
// the client rect. Retrieve the new clipping rect from the system (is
// different from what we requested!) and save it.
//
VDMConsoleOperation(VDM_CLIENT_RECT,&WarpClientRect);
rTemp = WarpClientRect;
CToS(&rTemp);
ClipCursor(&rTemp);
GetClipCursor(&WarpBorderRect);

//
// Note : LowerRight clip point is exclusive, UpperLeft point is inclusive
//
WarpBorderRect.right--;
WarpBorderRect.bottom--;

pMiddle.x = ((WarpBorderRect.right - WarpBorderRect.left)>>1)
             +WarpBorderRect.left;
pMiddle.y = ((WarpBorderRect.bottom - WarpBorderRect.top)>>1)
             +WarpBorderRect.top;
//
// move the pointer to the centre of the client area
//

SetCursorPos((int)pMiddle.x,(int)pMiddle.y);

//
// Prevent the next counter calculation from resulting in a
// large warp.
//

pLast = pMiddle;
}

//=============================================================================
// Function to convert a rectangle structure from client coordinates to
// screen coordinates.
//=============================================================================

void CToS(RECT *r)
{
POINT pt;

//
// Sort out the top, lefthand corner of the rectangle.
//

pt.x = r->left;
pt.y = r->top;
VDMConsoleOperation(VDM_CLIENT_TO_SCREEN,(LPVOID)&pt);
r->left = pt.x;
r->top = pt.y;

//
// Now do the bottom, right hand corner.
//

pt.x = r->right;
pt.y = r->bottom;
VDMConsoleOperation(VDM_CLIENT_TO_SCREEN,(LPVOID)&pt);
r->right = pt.x;
r->bottom = pt.y;
}


//=============================================================================
//
//  Function - EmulateCoordinates.
//  Purpose  - When the mouse is hidden by the user in windowed mode, this
//             function generate absolute x,y values from the relative motion
//             of the system pointer between mouse hardware interrupts
//
//  Returns  - Nothing.
//
//
//
//  Author   - Andrew Watson.
//  Date     - 19-Mar-1994.
//
//=============================================================================

void EmulateCoordinates(half_word video_mode,IS16 move_x,IS16 move_y,IS16 *x,IS16 *y)
{
static IS16 lastinternalX=0,lastinternalY=0;
IS16 internalX,internalY;

//
// If the  application has reset the mouse, set the x,y position to
// the centre of the default virtual screen for the current video mode.
//


if(bFunctionZeroReset)
   {
   //
   // Calculate the centre of the default virtual screen
   // and set the current generated coordinates to it.
   //

   internalX = (VirtualX >> 1) - 1;
   internalY = (VirtualY >> 1) - 1;

   bFunctionZeroReset = FALSE;
   }
else if(bFunctionFour)
   {
   //
   // The application has set the pointer to a new location.
   // Tell the counter emulation about this.
   //

   internalX = newF4x;
   internalY = newF4y;

   //
   // Don't come in here again until the next function 4.
   //

   bFunctionFour = FALSE;
   }
else
   {
   //
   // Generate the new x,y position based on the counter change and
   // clip to whatever boundary (default or application imposed) has
   // been selected.
   //

   internalX = lastinternalX + move_x;
   internalY = lastinternalY + move_y;
   LimitCoordinates(video_mode,&internalX,&internalY);
   }

//
// Set up the current emulated position for next time through
// this function.
//

lastinternalX = internalX;
lastinternalY = internalY;

//
// set up the return x,y values.
//

*x = internalX;
*y = internalY;
}

//=============================================================================
// Function which hooks into the base mechanism for dealing with int 33h and
// catches the function (AX=0xf) when the application tries to set the default
// mickey to pixel ratio.
//=============================================================================

void host_m2p_ratio(word *a, word *b, word *CX, word *DX)
{
m2pX = *(short *)CX;
m2pY = *(short *)DX;
}


//=============================================================================
//
//  Function - WarpSystem Pointer
//  Purpose  - Allows movement vectors to be calculated from the movement of
//             the operating system pointer. This function will not let the
//             the system pointer move out of the client area. This, plus the
//             warping mechanism ensures that the emulated pointer can move
//             forever in any given direction.
//
//  Returns  - TRUE if the system pointer has moved, FALSE if not.
//
//
//
//  Author   - Andrew Watson.
//  Date     - 19-Mar-1994.
//
//=============================================================================

BOOL WarpSystemPointer(IS16 *move_x,IS16 *move_y)
{
POINT pt;

//
// Is the Console window in the same place or changed
// Update the client rect data accordingly
//

HasConsoleClientRectChanged();

//
// Get the current position of the system pointer
//

GetCursorPos(&pt);


//
// How far has the system pointer moved since the last call.
//

*move_x = (IS16)(pt.x - pLast.x);
*move_y = (IS16)(pt.y - pLast.y);

//
// Do a fast exit if no movement has been determined.
//

if(*move_x || *move_y)
   {

   //
   // The system mouse pointer has moved.
   // See if the pointer has reached the client area boundary(s)
   //

   if(pt.y <= WarpBorderRect.top || pt.y >= WarpBorderRect.bottom ||
      pt.x >= WarpBorderRect.right || pt.x <= WarpBorderRect.left)
      {
      //
      // if the boundary(s) was/were met, warp the pointer to the
      // client area centre.
      //

      SetCursorPos((int)pMiddle.x,(int)pMiddle.y);

      //
      // The current position is now the centre of the client rectangle.
      // Save this as the counter delta start point for next time.
      //

      pLast = pMiddle;
      }
   else
      {
      //
      // There wasn't a warp.
      // Update the last known position data for next time through.
      //

      pLast = pt;
      }
   //
   // The cursor has to moved as determined from the previous and current
   // system pointer positions.
   //

   return TRUE;
   }
//
// No movement, so return appropriately.
//

return FALSE;
}

//==============================================================================
// Function to detect if the Console window has moved/resized. If it has, this
// function updates the WarpBorderRect and the pMiddle structures to reflect
// this.
//
// Returns TRUE if moved/resized, FALSE if not.
//==============================================================================

BOOL HasConsoleClientRectChanged(void)
{
RECT tR;

//
// If console client rectangle has changed, reset the mouse clipping
// else nothing to do!
//
VDMConsoleOperation(VDM_CLIENT_RECT,&tR);

if (tR.top != WarpClientRect.top ||
    tR.bottom != WarpClientRect.bottom ||
    tR.right != WarpClientRect.right ||
    tR.left != WarpClientRect.left)
  {
   CToS(&tR);

#ifdef MONITOR
   //
   // Is the warp region an Icon in fullscreen graphics?
   // Note: An icon has a client rect of 36 x 36 pixels.
   //

   if((tR.right - tR.left) == 36 && (tR.bottom - tR.top) == 36)
      {
      //
      // Make the warp region the same size as the selected buffer.
      // The warp rectangle is thus originated about the top, left
      // hand corner of the screen.
      //

      tR.top = 0;
      tR.bottom = mouse_buffer_height;
      tR.left = 0;
      tR.right = mouse_buffer_width;
      CToS(&tR);
      }
#endif    //MONITOR

   //
   // Clip the pointer to the new client rectangle, and retrive
   // the new clipping borders.
   //
   ClipCursor(&tR);
   GetClipCursor(&WarpBorderRect);

   //
   // Note: LowerRight clip point is exclusive, UpperLeft point is inclusive
   //
   WarpBorderRect.right--;
   WarpBorderRect.bottom--;



   //
   // determine the middle point in the new client rectangle
   //

   pMiddle.x = ((WarpBorderRect.right - WarpBorderRect.left)>>1)
                +WarpBorderRect.left;
   pMiddle.y = ((WarpBorderRect.bottom - WarpBorderRect.top)>>1)
                +WarpBorderRect.top;
   return TRUE;
   }

return FALSE;
}

//==============================================================================
// Focus sensing routines for the pointer clipping system. Focus events come
// via the main event loop where the following two modules are called. If
// the application is using int33hf11, this is detected, and on focus gain or
// loss, the routines clip or unclip the pointer to the console window.
//==============================================================================

void MouseInFocus(void)
{
MouseAttachMenuItem(sc.ActiveOutputBufferHandle);

//
// only do when app. uses int33hf11
//

if(!bPointerOff)
   return;
MovePointerToWindowCentre();

//
// Lose system pointer image again
//

ShowConsoleCursor(sc.ActiveOutputBufferHandle, FALSE);
}

void MouseOutOfFocus(void)
{
//
// only do when app. uses int33hf11
//

if(!bPointerOff)
   {
   MouseDetachMenuItem(FALSE);
   return;
   }

//
// Clip the pointer to the whole world (but leave its mother alone)
//

ClipCursor(NULL);

//
// Re-enable system pointer image
//

ShowConsoleCursor(sc.ActiveOutputBufferHandle, TRUE);
}

/* system memu active, stop cursor clipping */
void MouseSystemMenuON (void)
{
    if (bPointerOff)
        ClipCursor(NULL);
}
/* system menu off, restore clipping */
void MouseSystemMenuOFF(void)
{
    if (bPointerOff)
        ClipCursor(&WarpBorderRect);
}
void ResetMouseOnBlock(void)
{
host_ica_lock();

os_pointer_data.x=0;
os_pointer_data.y=0;

host_ica_unlock();
}
#ifdef X86GFX

//============================================================================
// Function which is called from the 32 bit side (x86 only) when there is
// a transition from fullscreen text to windowed text. The function restores
// the background to the last mouse pointer position. This stops a pointer
// block from remaining in the image, corrupting the display when the system
// pointer is being used.
//
// This function looks into the 16 bit driver's space and points to 4, 16 bit
// words of data from it, viz:
//
//   dw   offset of pointer into video buffer.
//   dw   unused.
//   dw   image data to be restored.
//   dw      flag = 0 if the background is stored
//
// Note: that during a fullscreen switch, 16 bit code cannot be executed,
// thus the patching of the buffer is done here.
//============================================================================

void CleanUpMousePointer()
{
half_word vm;
#ifdef JAPAN
half_word columns;
word       saved_ac_offset;
IMPORT  sys_addr DosvVramPtr;
#endif // JAPAN

//
// Only execute this routine fully if in TEXT mode
//

sas_load(0x449,&vm); // Get the current video mode according to the B.D.A.
#ifdef JAPAN
if (!is_us_mode() && saved_ac_flag_sysaddr != 0){
    if (vm != 0x72 && sas_w_at_no_check(saved_ac_flag_sysaddr) == 0) {
        columns =  sas_hw_at_no_check(effective_addr(0x40, 0x4A));
        columns <<= (vm == 0x73) ? 2 : 1;
        saved_ac_offset = sas_w_at_no_check(effective_addr(0x40, 0x4E)) +
                          ((word)old_y >> 3) * (word)columns +
                          ((word)old_x >> ( (vm == 0x73) ? 1 : 2)) ;
        sas_storew((sys_addr)saved_ac_offset + (sys_addr)DosvVramPtr,
                   sas_w_at_no_check(saved_ac_sysaddr));
    }
    sas_storew(saved_ac_flag_sysaddr, 1);
    return;
}
#endif // JAPAN
if (vm > Max_Standard_Mode) {
    vm = DEFAULT_VIDEO_MODE;
}
if(TextOrGraphicsModeLUT[(int)vm] != TEXT_MODE)
   return;

//
// If there is a backround stored for the text pointer when it was
// in fullscreen land, then restore it to the place it came from
// when windowed.
//

if(bFullscTextBkgrndSaved)
   {
   sas_storew(old_text_addr,text_ptr_bkgrnd);

   //
   // No background saved now.
   //

   bFullscTextBkgrndSaved = FALSE;
   }
}

#endif //X86GFX

//===========================================================================
// Function to display the text cursor image for fullscreen text mode.
// INPUT: x,y pointer virtual cartesian coordinates for text screen buffer.
// Note: the Y coordinates are received in the sequence 0, 8, 16, 24, 32, ...
// since a virtual text cell is 8 virtual pixels square.
//===========================================================================


void FullscTextPtr(int x,int y)
{
#ifdef X86GFX
sys_addr text_addr;
word     current_display_page;

//
// Work out the offset to the current video display page.
// Grovel around the B.D.A. to find out where the page starts.
//

sas_loadw(effective_addr(0x40,0x4e),&current_display_page);
x = (int)((DWORD)x & 0xFFFFFFF8);
y = (int)((DWORD)y & 0xFFFFFFF8);

//
// save the character cell behind the next pointer
// Note: The text cell offset calculated below is based on
// the following concepts:
//    The virtual character cell size is 8 x 8 virtual pixels.
//    The input data to this function is in virtual pixels.
//    There are 80 text cells in a row = 80 (CHAR:ATTR) words.
//    The >>3<<1 on the x value ensures that the location
//    in the buffer to be modified occurs on a word boundary to
//    get the masking correct!
//

x &= 0xfffc; // remove the top to prevent funny shifts.
x >>= 2;     // get the word address for the current row
y &= 0xffff; // work out the total number of locations for all the y rows
y *= 20;     //

//
// Generate the address in the display buffer at which the pointer
// should be drawn.
//

text_addr = effective_addr(0xb800,(word)(current_display_page + x + y)); // assemble the cell address

//
// only restore the background if there is a background to restore!
//

if(bFullscTextBkgrndSaved)
   {
   sas_storew(old_text_addr,text_ptr_bkgrnd);
   }

//
// Load up the background from the new address
//

sas_loadw(text_addr,&text_ptr_bkgrnd);      // read from that place
bFullscTextBkgrndSaved=TRUE;

//
// Write the pointer to the video buffer.
// Use some standard masks and forget what the app wants to
// do cos that really isn't important and it's slow plus not
// very many apps want to change the text pointer shape anyway.
//

sas_storew(text_addr,(word)((text_ptr_bkgrnd & 0x77ff) ^ 0x7700));

//
// save the static variables to be used next time through the routine
//

old_text_addr=text_addr;

#endif // X86GFX
}

//==============================================================================
// Function to get the maximum and minimum possible virtual pixel locations
// in X as requested by the application through int 33h function 7.
//==============================================================================

void host_x_range(word *blah, word *blah2,word *CX,word *DX)
{
confine.bF7 = TRUE;
confine.xmin = *CX;
confine.xmax = *DX;
VirtualScrCtrLUTx[DEFAULT_VIDEO_MODE] = (*CX + *DX) / 2;

//
// Force a mouse interrupt to make it happen.
//

  LazyMouseInterrupt();
}

//==============================================================================
// Function to get the maximum and minimum possible virtual pixel locations
// in Y as requested by the application through int 33h function 8.
//==============================================================================

void host_y_range(word *blah, word *blah2,word *CX,word *DX)
{
confine.bF8 = TRUE;
confine.ymin = *CX;
confine.ymax = *DX;
VirtualScrCtrLUTy[DEFAULT_VIDEO_MODE] = (*CX + *DX) / 2;

//
// Force a mouse interrupt to make it happen.
//

   LazyMouseInterrupt();
}



/*
 *  LazyMouseInterrupt -
 *
 */
void LazyMouseInterrupt(void)
{
    host_ica_lock();
    if (!bMseEoiPending && !bSuspendMouseInterrupts) {
        if (MseIntLazyCount)
            MseIntLazyCount--;
        bMseEoiPending = TRUE;
        ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,1);
        HostIdleNoActivity();
        }
    else if (!MseIntLazyCount) {
        MseIntLazyCount++;
        }
    host_ica_unlock();
}


/* SuspendMouseInterrupts
 *
 *  Prevents Mouse Interrupts from occuring until
 *  ResumeMouseInterrupts is called
 *
 */
void SuspendMouseInterrupts(void)
{
    host_ica_lock();
    bSuspendMouseInterrupts = TRUE;
    host_ica_unlock();
}


/*
 * ResumeMouseInterrupts
 *
 */
void ResumeMouseInterrupts(void)
{
    host_ica_lock();
    bSuspendMouseInterrupts = FALSE;

    if (!bMseEoiPending &&
        (MseIntLazyCount || MoreMouseEvents()) )
      {
        if (MseIntLazyCount)
            MseIntLazyCount--;
        bMseEoiPending   = TRUE;
        host_DelayHwInterrupt(9,  // AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT
                              1,  // count
                              10000  // Delay
                              );
        HostIdleNoActivity();
        }

    host_ica_unlock();
}



/*
 *  DoMouseInterrupt, assumes we are holding the ica lock
 *
 */
void DoMouseInterrupt(void)
{

   if (bMseEoiPending || bSuspendMouseInterrupts) {
       MseIntLazyCount++;
       return;
       }

   if (MseIntLazyCount)
       MseIntLazyCount--;
   bMseEoiPending   = TRUE;
   ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,1);
   HostIdleNoActivity();
}


/*
 * MouseEoiHook, assumes we are holding the ica lock
 *
 */
VOID MouseEoiHook(int IrqLine, int CallCount)
{

    if (CallCount < 0) {         // interrupts were cancelled
        MseIntLazyCount = 0;
        FlushMouseEvents();
        bMseEoiPending = FALSE;
        return;
        }

    if (!bSuspendMouseInterrupts &&
        (MseIntLazyCount || MoreMouseEvents()))
      {
       if (MseIntLazyCount)
           MseIntLazyCount--;
       bMseEoiPending = TRUE;
       host_DelayHwInterrupt(9,  // AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT
                             1,  // count
                             10000 // Delay usecs
                             );
       HostIdleNoActivity();
       }
    else {
       bMseEoiPending = FALSE;
       }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_mem.c ===
/*[
 *
 *  Name:	   nt_mem.c
 *
 *  Derived From:   (original)
 *
 *  Author:         Jerry Sexton
 *
 *  Created On:     7 December 1994
 *
 *  Coding Stds:    2.4
 *
 *  Purpose:        This module implements the memory management functions
 *                  required for 486 NT.
 *
 *  Include File:   nt_mem.h
 *
 *  Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
]*/

#ifdef CPU_40_STYLE

#if defined(DBG)
//#define DEBUG_MEM YES_PLEASE
//#define DEBUG_MEM_DUMP 1
#endif

/* Need all of the following to include nt.h and windows.h in the same file. */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "insignia.h"
#include "host_def.h"

#include <string.h>
#include <stdlib.h>

#include "nt_mem.h"
#include "debug.h"
#include "sas.h"

/* Make local symbols visible if debugging. */
#ifdef DEBUG_MEM
#define LOCAL

GLOBAL VOID DumpAllocationHeaders IFN1();

#endif /* DEBUG_MEM */

/* Macros and typedefs. */

/* Entry in header table describing sections of memory. */
typedef struct _SECTION_HEADER
{
    struct _SECTION_HEADER   *prev;     /* Previous header in linked list. */
    IU8                       flags;    /* Is header valid/allocated? */
    IU8                      *address;  /* Address of corresponding section. */
    IU32                      size;     /* Size of corresponding section. */
    struct _SECTION_HEADER   *next;     /* Next header in linked list. */
} SECTION_HEADER;

/* Possible values for 'flags' field of SECTION_HEADER structure. */
#define HDR_VALID_FLAG  0x1     /* Header points to the beginning of a chunk
                                   or free section. */
#define HDR_ALLOC_FLAG	0x2	/* Header points to an allocated chunk. */
#define HDR_COMMITTED_FLAG 0x4	/* Header points to committed chunk, not moveable */
#define HDR_REMAP_FLAG	0x8	/* chunk is remapped by "AddVirtualMemory" */

#define HDR_VALID_ALLOC (HDR_VALID_FLAG|HDR_ALLOC_FLAG)
                                /* Header points to a section that is valid
                                   and allocated. */

#define SECTION_IS_FREE(ptr)    (!((ptr)->flags & HDR_ALLOC_FLAG))
                                /* Is a section's allocated flag set? */

#define SECTION_IS_UNCOMMITTED(ptr)    (!((ptr)->flags & HDR_COMMITTED_FLAG))
                                /* Is a section's committed flag set? */

/* Enumerated type to pass to header management functions. */
typedef enum
{
    SECT_ALLOC,
    SECT_FREE
} SECT_TYPE;

#define ONE_K           (1<<10)         /* Speaks for itself. */
#define ONE_MEG         (1<<20)         /* Ditto. */
#define PAGE_SIZE       (4 * ONE_K)     /* Intel memory page granularity. */
#define PAGE_MASK       (PAGE_SIZE - 1) /* Mask used in rounding to boundary. */
#define PAGE_SHIFT	12		/* Amount to shift by to get page. */

// The following two defines have been replace with MaxIntelMemorySize and
//MaxIntelMemorySize/PAGE_SIZE
//#define MAX_XMS_SIZE	 (128 * ONE_MEG) /* Maximum memory size. */
//#define MAX_HEADER_SIZE (MAX_XMS_SIZE / PAGE_SIZE)

#define A20_WRAP_SIZE   (0xfff0)        /* Size of A20 wrap area beyond 1M. */

/* Convert header table entries to addresses. */
#define HEADER_TO_ADDRESS(header)   \
    (intelMem + (((header) - headerTable) << PAGE_SHIFT))

/* Convert addresses to header table entries. */
#define ADDRESS_TO_HEADER(address)   \
    (headerTable + (((address) - intelMem) >> PAGE_SHIFT))

/* Local variables. */
LOCAL IBOOL              memInit = FALSE;
                                        /* Is memory system initialised? */
LOCAL IU8               *intelMem;      /* Pointer to intel memory block. */
LOCAL SECTION_HEADER    *headerTable;   /* Table of memory section headers. */
LOCAL IU32               totalFree;     /* Total amount of free memory. */
LOCAL IU32		 commitShift;	/* Shift to get commitment granularity */
LOCAL int		 ZapValue;	/* Value to set allocated memory to */
LOCAL IU32       WOWforceIncrAlloc = 0; /* Force increasing linear address */
LOCAL SECTION_HEADER  *lastAllocPtr = NULL; /* Last chunk allocated. */

/* Prototypes for local functions. */
LOCAL SECTION_HEADER *addHeaderEntry IPT5(
    SECTION_HEADER *, prevHeader,
    SECTION_HEADER *, nextHeader,
    SECT_TYPE, allocFree,
    IU8 *, intelAddr,
    IU32, size);
LOCAL IBOOL deleteHeaderEntry IPT1(
    SECTION_HEADER *, header);
LOCAL void exclusiveHeaderPages IPT5(
    IHPE, tableAddress,
    IHPE, prev,
    IHPE, next,
    IHP *, allocAddr,
    IU32 *, allocSize);
LOCAL void exclusiveChunkPages IPT4(
    SECTION_HEADER *, chunkHeader,
    IHP *, allocAddr,
    IU32 *, allocSize,
    BOOL, Commit);
LOCAL void exclusiveAllocPages IPT6(
    IHPE, address,
    IU32, size,
    IHPE, prevAllocLastAddr,
    IHPE, nextAllocFirstAddr,
    IHP *, allocAddr,
    IU32 *, allocSize);

/* Global Functions. */

/*(
============================== InitIntelMemory =================================
PURPOSE:
        This function reserves the entire Intel address space, committing the
        first 1 meg and leaving the rest to be committed as and when required
        when new chunks are allocated.
INPUT:
        None.
OUTPUT:
        Return value - pointer to beginning of intel memory.
================================================================================
)*/
GLOBAL IU8 *InitIntelMemory IFN1(IU32, MaxIntelMemorySize)
{
    SYSTEM_INFO  SystemInfo;        /* Passed to GetSystemInfo API. */
    DWORD   tabSize;                /* Max. size of header table in bytes. */
    IS32    commitGran;		    /* Commitment granularity. */
    IU32    temp,		    /* Used in computing commitShift. */
            initialCommitSize;      /* Size of real mode area to commit. */
    SECTION_HEADER  *entryPtr;      /* Header entry for real mode area. */

#ifdef DEBUG_MEM
    printf("NTVDM:InitIntelMemory(%lx [%dK])\n",
	   MaxIntelMemorySize, MaxIntelMemorySize/ONE_K);
#endif

    /*
     * Setup the value to initalise allocated memory with
     */
    {
	char *env;

	if((env = getenv("CPU_INITIALISE_MEMORY")) != 0)
	    ZapValue = strtol(env, 0, 16);
	else
	    ZapValue = 0xf4;	   /* HLT instruction */

    }

    /*
     * Find out machine's commitment granularity, and store it as a number of
     * bits to shift an address right to give the allocation page it is in.
     * This assumes the allocation granularity is a power of two so complain
     * if it isn't.
     */
    GetSystemInfo(&SystemInfo);
    commitGran = (IS32) SystemInfo.dwPageSize;
    if ((-commitGran & commitGran) != commitGran)
    {
	always_trace1("Commitment granularity %#x not a power of two",
		      commitGran);
        return((IU8 *) NULL);
    }
#ifdef DEBUG_MEM
    printf("NTVDM:Commitment granularity is %lx\n", commitGran);
#endif
    commitShift = 0;
    for (temp = commitGran; temp > 1; temp >>= 1)
	commitShift++;

    /* Reserve the entire memory space. */
    intelMem = (IU8 *) VirtualAlloc((LPVOID) NULL,
				    (DWORD) MaxIntelMemorySize,
                                    (DWORD) MEM_RESERVE,
                                    (DWORD) PAGE_READWRITE);
    if (!intelMem)
    {
	always_trace1("Failed to reserve %dM of memory", MaxIntelMemorySize >> 20);
        return((IU8 *) NULL);
    }

    /*
     * Allocate the bottom 1 megabyte plus the 20-bit wrap area. Round this
     * to an Intel page boundary as this is the granularity of this system.
     */
    initialCommitSize = (ONE_MEG + A20_WRAP_SIZE + PAGE_MASK) &
                        (IU32) ~PAGE_MASK;
    if (VirtualAlloc((LPVOID) intelMem,
                     (DWORD) initialCommitSize,
                     (DWORD) MEM_COMMIT,
                     (DWORD) PAGE_READWRITE) == NULL)
    {
	always_trace0("Could not commit real mode area");
	VirtualFree (intelMem, 0, MEM_RELEASE);    /* Free Intel memory */
        return((IU8 *) NULL);
    }

    /* Reserve enough space for the entire header table. */
    tabSize = (MaxIntelMemorySize/PAGE_SIZE) * sizeof(SECTION_HEADER);
    headerTable = (SECTION_HEADER *) VirtualAlloc((LPVOID) NULL,
                                                  tabSize,
                                                  (DWORD) MEM_RESERVE,
						  (DWORD) PAGE_READWRITE);

    if (!headerTable)
    {
	always_trace0("Failed to reserve header table");
	VirtualFree (intelMem, 0, MEM_RELEASE);    /* Free Intel memory */
        return((IU8 *) NULL);
    }

    /*
     * Initialise linked list with pointers to initial 1M and remaining free
     * space and store initial size of free space.
     */
    entryPtr = addHeaderEntry((SECTION_HEADER *) NULL, (SECTION_HEADER *) NULL,
			      SECT_ALLOC, intelMem, initialCommitSize);

    entryPtr->flags |= HDR_COMMITTED_FLAG;
    totalFree = MaxIntelMemorySize - initialCommitSize;

    (void) addHeaderEntry(entryPtr, (SECTION_HEADER *) NULL, SECT_FREE,
                          intelMem + initialCommitSize, totalFree);

    /* Return the address of the start of memory. */
    memInit = TRUE;
    return(intelMem);
}

/*(
============================== FreeIntelMemory =================================
PURPOSE:
	This function frees the entire Intel address space
INPUT:
        None.
OUTPUT:
	None.
================================================================================
)*/

GLOBAL	VOID FreeIntelMemory IFN0()
{
#ifdef DEBUG_MEM
    printf("NTVDM:FreeIntelMemory\n");
#endif

    /* Free Intel memory */
    VirtualFree (intelMem, 0, MEM_RELEASE);

    /* Free allocation control structure */
    VirtualFree (headerTable, 0, MEM_RELEASE);
}

/*(
============================ SetWOWforceIncrAlloc ===============================
PURPOSE:
    When TRUE is passed, this function sets the WOWforceIncrAlloc variable to
    the current thread ID. This will force VdmAllocateVirtualMemory to allocate
    blocks of memory with ever increasing linear address's for this thread only.
    When FALSE is passed, WOWforceIncrAlloc is cleared and the default
    allocation scheme is used. This function is called by WOW based on an app
    compatibility flag at start task time and end task time. Power Builder 4
    depends on this. This is not a general solution for multiple threads. Since
    the problem we're trying to work around occurs at load time, the allocation
    strategy is applied to the most recent thread only. This might not work if
    multiple instances of the app are started at the same time.

INPUT:
    None.
OUTPUT:
    None.
================================================================================
)*/

GLOBAL  VOID SetWOWforceIncrAlloc IFN1(IBOOL, iEnable)
{
    if (iEnable) {
        WOWforceIncrAlloc = GetCurrentThreadId();
    }
    else {
        WOWforceIncrAlloc = 0;
    }
#ifdef DEBUG_MEM
    printf("NTVDM:SetWOWforceIncrAlloc, WOWforceIncrAlloc: %X\n", WOWforceIncrAlloc);
#endif
}


/*(
========================= VdmAllocateVirtualMemory =============================
PURPOSE:
        This interface will allocate the specified number of bytes of virtual
        memory, returning the Intel linear address in the variable pointed to
        by the Address parameter.  The Intel linear address will be page
        aligned (this is important).  In the event that the memory is
        allocated, STATUS_SUCCESS will be returned.  In the event of failure,
        an appropriate NTSTATUS code will be returned.  (In the event that
        there is a failure in the cpu for which there is not an appropriate
        code, STATUS_UNSUCCESSFUL can be returned.  I just want to have an
        opportunity to get more information.)
INPUT:
        Size            - size of memory chunk required in bytes (must be a
			  multiple of 4K).

	Commit		- Commit virtual memory ?
OUTPUT:
	Address 	- INTEL linear address of allocated chunk.
        Return value    - STATUS_SUCCESS, if the memory is allocated, or an
                          appropriate NTSTATUS code if not (if there is no
                          appropriate code STATUS_UNSUCCESSFUL is returned).
================================================================================
)*/
GLOBAL NTSTATUS VdmAllocateVirtualMemory IFN3(PULONG, INTELAddress,
					      ULONG, Size,
					      BOOL, Commit)
{
    SECTION_HEADER  *headerPtr,
                    *newHeader;
    IHP     retAddr,
            commitAddr;
    IU32    commitSize;

#ifdef DEBUG_MEM
    printf("NTVDM:VdmAllocateVirtualMemory(%lx [%dK],%s)\n",
	   Size, Size/ONE_K, Commit ? "COMMIT" : "DONOT_COMMIT");
#endif

    /* Make sure memory system is initialised. */
    assert0(memInit, "Called VdmAllocateVirtualMemory before initialisation");

    /* Round Size up to a multiple of 4K. */

    if (Size & PAGE_MASK)
	Size = (Size + PAGE_MASK) & (~PAGE_MASK);


    /* Search for a chunk of the required size. If WOWforceIncrAlloc is our */
    /* current thread ID and lastAllocPtr is intialized, force returned     */
    /* chunks to have ever increasing linear address's.                     */
    if ((WOWforceIncrAlloc != 0) && lastAllocPtr
                             && (GetCurrentThreadId() == WOWforceIncrAlloc)) {
#ifdef DEBUG_MEM
    printf("\nNTVDM:VdmAllocateVirtualMemory, using increasing linear address strategy.\n");
#endif
        headerPtr = lastAllocPtr;
    } else {
        headerPtr = &headerTable[0];
    }
    while (headerPtr != NULL)
    {
        if (SECTION_IS_FREE(headerPtr) && (headerPtr->size >= Size))
            break;
        headerPtr = headerPtr->next;
    }

    /* Return failure if there is no chunk of the required size. */
    if (headerPtr == NULL)
        return(STATUS_NO_MEMORY);

    /* Mark the header as an allocated chunk */
    headerPtr->flags |= HDR_ALLOC_FLAG;
    lastAllocPtr = headerPtr;

    /* Add committed status to header. */
    if(Commit)
	headerPtr->flags |= HDR_COMMITTED_FLAG;
    else
	headerPtr->flags &= ~HDR_COMMITTED_FLAG;

    /* Create a new header if there is any space left below the new chunk. */
    if (headerPtr->size > Size)
    {
        newHeader = addHeaderEntry(headerPtr,
                                   headerPtr->next,
                                   SECT_FREE,
                                   headerPtr->address + Size,
                                   headerPtr->size - Size);
        headerPtr->size = Size;
    }

    /* Commit any pages that are unique to this chunk. */
    exclusiveChunkPages(headerPtr, &commitAddr, &commitSize, TRUE);
    if (commitSize && Commit)
    {
        retAddr = VirtualAlloc((LPVOID) commitAddr,
                               (DWORD) commitSize,
                               (DWORD) MEM_COMMIT,
			       (DWORD) PAGE_READWRITE);

        if (retAddr != commitAddr)
        {
            always_trace2("Could not commit %dK at addr %#x",
                          commitSize / ONE_K, commitAddr);
            return(STATUS_NOT_COMMITTED);
        }
    }

    /*
     * Success, so update total free space store and return the address of
     * the new chunk to the caller.
     */
    totalFree -= Size;
    *INTELAddress = ((ULONG) (IHPE) headerPtr->address) - (ULONG) intelMem;

#ifdef DEBUG_MEM
    printf(" => alloc %lxh, commit %lxh\n",
        ((ULONG) (IHPE)headerPtr->address) - (ULONG)intelMem,
        ((ULONG) (IHPE)commitAddr) - (ULONG)intelMem);

#ifdef DEBUG_MEM_DUMP
    DumpAllocationHeaders("after allocate");
#endif
#endif

    return(STATUS_SUCCESS);
}

/*(
========================== VdmCommitVirtualMemory =============================
PURPOSE:
	Commit memory within a previously allocated chunk
INPUT:
	Address     Intel linear address of memory to commit
	Size	    Size of memory to commit
OUTPUT:
        Return value    - STATUS_SUCCESS, if the memory is allocated, or an
			  appropriate NTSTATUS code if not.
===============================================================================
)*/

GLOBAL NTSTATUS VdmCommitVirtualMemory IFN2(ULONG, INTELAddress,
					     ULONG, Size)
{
    IHP     retAddr;

#ifdef DEBUG_MEM
    printf("NTVDM:VdmCommitVirtualMemory(%lxh,%lxh)\n",INTELAddress, Size);
#endif

    retAddr = VirtualAlloc((LPVOID) (intelMem + INTELAddress),
			   (DWORD) Size,
			   (DWORD) MEM_COMMIT,
			   (DWORD) PAGE_READWRITE);

    if(retAddr != (intelMem + INTELAddress))
    {
	always_trace2("Could not commit %dK at addr %#x",
		      Size / ONE_K, INTELAddress);

	return(STATUS_NOT_COMMITTED);
    }

    return(STATUS_SUCCESS);
}

/*(
======================== VdmDeCommitVirtualMemory =============================
PURPOSE:
	Decommit memory within a previously allocated chunk
INPUT:
	Address     Intel linear address of memory to decommit
	Size	    Size of memory to commit
OUTPUT:
        Return value    - STATUS_SUCCESS, if the memory is allocated, or an
			  appropriate NTSTATUS code if not.
===============================================================================
)*/

GLOBAL NTSTATUS VdmDeCommitVirtualMemory IFN2(ULONG, INTELAddress,
					     ULONG, Size)
{
#ifdef DEBUG_MEM
    printf("NTVDM:VdmDeCommitVirtualMemory(%lxh,%lxh)\n",INTELAddress, Size);
#endif


    sas_overwrite_memory(INTELAddress, Size);
	if (!VirtualFree((LPVOID) (intelMem + INTELAddress),
			 (DWORD) Size,
                         (DWORD) MEM_DECOMMIT))
        {
            always_trace2("Could not decommit %dK at addr %#x",
			  Size / ONE_K, INTELAddress);

	    return(STATUS_UNSUCCESSFUL);
        }

    return(STATUS_SUCCESS);
}

/*(
============================ VdmFreeVirtualMemory ==============================
PURPOSE:
        This interface will free the allocation at the specified Intel linear
        address.  The above notes on return value apply.
INPUT:
	INTELAddress	- INTEL address to be freed.
OUTPUT:
        Return value    - STATUS_SUCCESS, if the memory is allocated, or an
                          appropriate NTSTATUS code if not (if there is no
                          appropriate code STATUS_UNSUCCESSFUL is returned).
================================================================================
)*/
GLOBAL NTSTATUS VdmFreeVirtualMemory IFN1(ULONG, INTELAddress)
{
    SECTION_HEADER  *headerPtr;
    IU32    size,
            decommitSize;
    IHP     decommitAddr;
    ULONG   Address;


    /* Make sure memory system is initialised. */
    assert0(memInit, "Called VdmFreeVirtualMemory before initialisation");

#ifdef DEBUG_MEM
    printf("NTVDM:VdmFreeVirtualMemory(%lxh)\n",INTELAddress);
#endif

    /* Calculate chunk address */
    Address = INTELAddress + (ULONG)intelMem;

    /* Get header table entry for address. */
    headerPtr = ADDRESS_TO_HEADER((IU8 *) Address);

    /*
     * Check address is correctly aligned and at the top of an allocated
     * chunk.
     */
    if ((Address & PAGE_MASK) ||
        ((headerPtr->flags & HDR_VALID_ALLOC) != HDR_VALID_ALLOC))
    {
        always_trace0("Tried to free invalid address");
        return(STATUS_MEMORY_NOT_ALLOCATED);
    }

    /* Don't allow freeing of bottom 1 Meg. */
    if (headerPtr == &headerTable[0])
    {
        always_trace0("Tried to free real mode area");
        return(STATUS_UNSUCCESSFUL);
    }

    /* DON'T free if still mapped to another area of host memory by
	 * VdmAddVirtualMemory() - ie the PhysRecStructs are in a munged
	 * state. Free can get called before Remove, and Remove will
	 * unflag it and call here later.
     */
	if (headerPtr->flags & HDR_REMAP_FLAG)
	{
        always_trace0("Tried to free remapped area");
        return(STATUS_SUCCESS);
    }


    /* Save the size of the chunk before decommitting it. */
    size = headerPtr->size;

    /* Tell the CPU that the contents of the memory are no longer valid. */
    sas_overwrite_memory(INTELAddress, size);

    /* Decommit any memory that is unique to this chunk. */
    exclusiveChunkPages(headerPtr, &decommitAddr, &decommitSize, FALSE);
    if (decommitSize)
    {
        if (!VirtualFree((LPVOID) decommitAddr,
                         (DWORD) decommitSize,
                         (DWORD) MEM_DECOMMIT))
        {
            always_trace2("Could not decommit %dK at addr %#x",
                          decommitSize / ONE_K, decommitAddr);
            return(STATUS_UNABLE_TO_DECOMMIT_VM);
        }
    }

    /*
     * If chunk is adjacent to a free section absorb this chunk into it.
     * Start with next chunk so we don't trash current one before we are
     * finished with it.
     */
    if (headerPtr->next && SECTION_IS_FREE(headerPtr->next))
    {
        headerPtr->size += headerPtr->next->size;
        deleteHeaderEntry(headerPtr->next);
    }

    /* Absorb into previous section if that is free. */
    if (headerPtr->prev && SECTION_IS_FREE(headerPtr->prev))
    {
        headerPtr->prev->size += headerPtr->size;
        deleteHeaderEntry(headerPtr);
    }
    else
    {

        /* Otherwise just mark this chunk as free. */
        headerPtr->flags &= (IU32) ~HDR_ALLOC_FLAG;
    }

    /* Success, so update total free space store and return. */
    totalFree += size;


#ifdef DEBUG_MEM
#ifdef DEBUG_MEM_DUMP
    DumpAllocationHeaders("after free");
#endif
#endif

    return(STATUS_SUCCESS);
}

/*(
========================== VdmQueryFreeVirtualMemory ===========================
PURPOSE:
        This interface returns information about free memory.  The total number
        of allocatable free bytes is returned in the variable pointed to by
        FreeBytes. LargestFreeBlock returns the size of the largest contiguous
        block that can be allocated at the present time.  This value is
        potentially all of the available virtual memory. It may change over
        time due to other activities in the system.  The above notes on return
        value apply.
INPUT:
        None.
OUTPUT:
        FreeBytes           - the total number of allocatable free bytes.
        LargestFreeBlock    - the size of the largest contiguous block that can
                              be allocated at the present time.
        Return value        - STATUS_SUCCESS, if the memory is allocated, or an
                              appropriate NTSTATUS code if not (if there is no
                              appropriate code STATUS_UNSUCCESSFUL is returned).
================================================================================
)*/
GLOBAL NTSTATUS VdmQueryFreeVirtualMemory IFN2(PULONG, FreeBytes,
                                               PULONG, LargestFreeBlock)
{
    IU32    maxFree = 0;        /* Local storage for maximum. */
    SECTION_HEADER  *headerPtr; /* Pointer for searching through linked list. */

    /* Make sure memory system is initialised. */
    assert0(memInit, "Called VdmQueryFreeVirtualMemory before initialisation");

    /*
     * Use a linear search through the linked list to find the largest
     * contiguous free space. (This information could be updated as chunks are
     * allocated and freed but do it this way for now.)
     */

    for(headerPtr = &headerTable[0] ;
	headerPtr != NULL ;
	headerPtr = headerPtr->next)
    {
        if (SECTION_IS_FREE(headerPtr) && (headerPtr->size > maxFree))
            maxFree = headerPtr->size;
    }

    *FreeBytes = (ULONG) totalFree;
    *LargestFreeBlock = (ULONG) maxFree;

#ifdef DEBUG_MEM
    printf("NTVDM:VdmQueryFreeVirtualMemory() Total %lx [%dK], Largest %lx[%dK]\n",
	    *FreeBytes, *FreeBytes/ONE_K, *LargestFreeBlock, *LargestFreeBlock/ONE_K);
#endif

    return(STATUS_SUCCESS);
}

/*(
========================== VdmReallocateVirtualMemory ==========================
PURPOSE:
        This interface will reallocate the block of memory at the specified
        Intel linear address.  The size of the new block is specified by
        NewSize.  The new address is returned in the variable pointed to by
        NewAddress.  The new address must be page aligned (this is important).
        If the new size is smaller than the old size, the new address must be
        the same as the old address (this is also important).  The original
        data from the reallocated memory must be preserved to
        min(old size, new size). The state of any data beyond NewSize is
        indeterminate.
INPUT:
	INTELOriginalAddress - INTEL address of the chunk to be reallocated.
	NewSize 	     - size in bytes the chunk needs to be changed to.
OUTPUT:
	INTELNewAddress	 - new INTEL address of the chunk.
================================================================================
)*/
GLOBAL NTSTATUS VdmReallocateVirtualMemory IFN3(ULONG, INTELOriginalAddress,
						PULONG, INTELNewAddress,
                                                ULONG, NewSize)
{
    SECTION_HEADER  *headerPtr;
    IBOOL   nextSectIsFree;
    IU32    oldSize,
            maxSize;
    ULONG   newAddr;
    NTSTATUS	status;
    ULONG   OriginalAddress;


#ifdef DEBUG_MEM
    printf("NTVDM:VdmReallocateVirtualMemory(%lx [%dK] at %lx)\n",
	   NewSize, NewSize/ONE_K, INTELOriginalAddress);
#endif

    /* Round NewSize up to a multiple of 4K. */
    if (NewSize & PAGE_MASK)
	NewSize = (NewSize + PAGE_MASK) & (~PAGE_MASK);

    /* Calculate chunk address */
    OriginalAddress = INTELOriginalAddress + (ULONG)intelMem;

    /* Make sure memory system is initialised. */
    assert0(memInit, "Called VdmReallocateVirtualMemory before initialisation");

    /* Get header table entry for address. */
    headerPtr = ADDRESS_TO_HEADER((IU8 *) OriginalAddress);


    /* Unable to reallocate sparsely commit chunk */
    if(!(headerPtr->flags & HDR_COMMITTED_FLAG))
    {
	always_trace0("Tried to reallocate sparsely committed chunk");
        return(STATUS_MEMORY_NOT_ALLOCATED);
    }


    /*
     * Check address is correctly aligned and at the top of an allocated
     * chunk.
     */
    if ((OriginalAddress & PAGE_MASK) ||
        ((headerPtr->flags & HDR_VALID_ALLOC) != HDR_VALID_ALLOC))
    {
        always_trace0("Tried to reallocate invalid address");
        return(STATUS_MEMORY_NOT_ALLOCATED);
    }

    /* If size is the same there is nothing to do. */
    if (NewSize == headerPtr->size)
    {
        always_trace0("New size equals old size in VdmReallocateVirtualMemory");
        *INTELNewAddress = INTELOriginalAddress;
        return(STATUS_SUCCESS);
    }

    /* Don't allow reallocation of bottom 1 Meg. */
    if (headerPtr == &headerTable[0])
    {
        always_trace0("Tried to reallocate real mode area");
        return(STATUS_UNSUCCESSFUL);
    }

    /* ... or if still mapped to another area of host memory by
	 * VdmAddVirtualMemory() - ouch!
     */
	if (headerPtr->flags & HDR_REMAP_FLAG)
	{
        always_trace0("Tried to reallocate remapped area");
        return(STATUS_UNSUCCESSFUL);
    }

    /* Save old size for later. */
    oldSize = headerPtr->size;

    /* Work out whether the chunk needs to be moved. */
    maxSize = headerPtr->size;
    if (headerPtr->next && SECTION_IS_FREE(headerPtr->next))
    {
        maxSize += headerPtr->next->size;
        nextSectIsFree = TRUE;
    }
    else
    {
        nextSectIsFree = FALSE;
    }
    if (NewSize > maxSize)
    {

        /* Chunk must move, so allocate a new one. */
	status = VdmAllocateVirtualMemory(&newAddr, NewSize, TRUE);
        if (status != STATUS_SUCCESS)
            return(status);

        /* Copy old chunk. */
        memcpy((void *) (newAddr + intelMem), (void *) OriginalAddress,
                (size_t) oldSize);

        /* Free old chunk. */
        sas_overwrite_memory(INTELOriginalAddress, oldSize);
        status = VdmFreeVirtualMemory(INTELOriginalAddress);
        if (status != STATUS_SUCCESS)
            return(status);

        /* Inform caller of new address. */
	*INTELNewAddress = newAddr;
    }
    else
    {
        IHP commitAddr;
        IU32 commitSize;

        /* Adjust size of current chunk. */
        headerPtr->size = NewSize;

        /* Remove old pointer to free space if there is one. */
        if (nextSectIsFree)
            deleteHeaderEntry(headerPtr->next);

        /* Add new pointer to free space if one is required. */
        if (NewSize < maxSize)
        {
            (void) addHeaderEntry(headerPtr,
                                  headerPtr->next,
                                  SECT_FREE,
				  (IU8 *) (OriginalAddress + NewSize),
                                  maxSize - NewSize);
        }

        /* If this chunk is committed, commit the memory now covered by it */
        /* in case its size has increased, or decommit the freed up memory */
        if (headerPtr->flags & HDR_COMMITTED_FLAG)
        {
            if (oldSize < NewSize) {
                exclusiveChunkPages(headerPtr, &commitAddr, &commitSize, TRUE);
                if (commitSize)
                    (void) VirtualAlloc((LPVOID) commitAddr,
                                    (DWORD) commitSize,
                                    (DWORD) MEM_COMMIT,
                                    (DWORD) PAGE_READWRITE);
            } else {
                /* Chunk has shrunk, so free up excess */
                exclusiveChunkPages(headerPtr->next, &commitAddr, &commitSize, FALSE);
                if (commitSize)
                    (void) VirtualFree((LPVOID) commitAddr,
                                    (DWORD) commitSize,
                                    (DWORD) MEM_DECOMMIT);
            }
        }

        /* Inform caller address has not changed. */
	*INTELNewAddress = OriginalAddress - (ULONG)intelMem;

        /* Update total free space store. */
        totalFree += NewSize - oldSize;
    }

#ifdef DEBUG_MEM
    printf("to %lx\n", *INTELNewAddress);
#ifdef DEBUG_MEM_DUMP
    DumpAllocationHeaders("after realloc");
#endif
#endif
    /* Success. */
    return(STATUS_SUCCESS);
}

/*(
============================ VdmAddVirtualMemory ===============================
PURPOSE:
 In investigating the things we need to support with the 386, I've come
 across an interesting one called dib.drv. Support for this involves calling
 CreateDibSection, which returns a pointer to a DIB. The applications then
 edit the bits in the dib directly, as well as operating on it using GDI
 calls. At least that's my understanding. In view of this, and the potential
 for people to create other api with similar properties, it appears that we
 need to be able to notify the cpu that a particular region of memory needs
 to be added to the intel address space.

 This interface adds virtual memory allocated by the system to the intel
 address space.  The host linear address of the block to be added is
 specified by HostAddress.  The pages at this address have already been
 allocated and initialized.  The CPU should not modify the contents of these
 pages, except as part of executing emulated code.  The Intel linear address
 may be specified by IntelAddress. If IntelAddress is non-NULL, it specifies
 the Intel address that the memory should be added at. If IntelAddress is
 NULL, the CPU may select the Intel address the memory is at.  In all events,
 upon return from VdmAddVirtualMemory, IntelAddress will contain the Intel
 address of the block of memory.  If the function cannot be performed, and
 appropriate NTSTATUS code should be returned.

 / The ability to specify Intel Address may be unecessary.  I included it for
 completeness /
INPUT:
    HostAddress     - the host linear address of the block to be added.
    Size            - the size of the block in bytes.
OUTPUT:
    IntelAddress    - the intel address the block is mapped to.
================================================================================
)*/

extern void VdmSetPhysRecStructs (ULONG, ULONG, ULONG);
GLOBAL NTSTATUS VdmAddVirtualMemory IFN3(ULONG, HostAddress,
                                         ULONG, Size,
                                         PULONG, IntelAddress)
{
    IU32 alignfix;

#ifdef DEBUG_MEM
    printf("NTVDM:VdmAddVirtualMemory (%lx [%dK]) at %lx)\n",
	   Size, Size/ONE_K, HostAddress);
#endif

    /* Make sure memory system is initialised. */
    assert0(memInit, "Called VdmAddVirtualMemory before initialisation");

    /* Calculate shift required to DWORD align HostAddress */
    if ((alignfix = HostAddress & 0x3) != 0) {
        Size += alignfix;
        HostAddress -= alignfix;
    }

    /* Round Size up to a multiple of 4K. */

    if (Size & PAGE_MASK)
	Size = (Size + PAGE_MASK) & (~PAGE_MASK);

    /* step 1 - reserve the intel address space */

    if (VdmAllocateVirtualMemory(IntelAddress,Size,FALSE) != STATUS_SUCCESS)
        return (STATUS_NO_MEMORY);

    /* step 2 - flush the caches */

    sas_overwrite_memory(*IntelAddress, Size);

    /* step 3 - replace the PhysicalPageREC.translation entries */

    VdmSetPhysRecStructs(HostAddress, *IntelAddress, Size);
    ADDRESS_TO_HEADER(*IntelAddress+intelMem)->flags |= HDR_REMAP_FLAG;

    /* adjust IntelAddress if HostAddress not DWORD aligned */

    *IntelAddress += alignfix;

#ifdef DEBUG_MEM
#ifdef DEBUG_MEM_DUMP
    DumpAllocationHeaders("after Add");
#endif
    printf("NTVDM:VdmAddVirtualMemory => *IntelAddress=%lx\n", *IntelAddress);
#endif

    return(STATUS_SUCCESS);
}

/*(
========================== VdmRemoveVirtualMemory ==============================
PURPOSE:
        This interface undoes an address mapping that was performed using
        VdmAddVirtualMemory.
INPUT:
        IntelAddress    - address of block to be removed.
================================================================================
)*/
GLOBAL NTSTATUS VdmRemoveVirtualMemory IFN1(ULONG, IntelAddress)
{
    SECTION_HEADER * headerPtr;
    ULONG   HostAddress,Size;
    NTSTATUS status;

#ifdef DEBUG_MEM
    printf("NTVDM:VdmRemoveVirtualMemory at %lx)\n", IntelAddress);
#ifdef DEBUG_MEM_DUMP
    DumpAllocationHeaders("before remove");
#endif
#endif

    /* Make sure memory system is initialised. */
    assert0(memInit, "Called VdmRemoveVirtualMemory before initialisation");

    /* Make sure IntelAddress is page aligned */
    IntelAddress &= ~PAGE_MASK;

    HostAddress = IntelAddress + (ULONG)intelMem;

    /* Get header table entry for address. */
    headerPtr = ADDRESS_TO_HEADER((IU8 *) HostAddress);

	Size = headerPtr->size;

    /* step 1 - flush the caches */

    sas_overwrite_memory(IntelAddress, Size);

    /* step 2 - reset the PhysicalPageREC.translation entries */

#ifdef DEBUG_MEM
    if (Size==0) {
        printf("NTVDM:VdmRemoveVirtualMemory WARNING, Size==0\n");
    }
#endif
    VdmSetPhysRecStructs(HostAddress, IntelAddress, Size);
    ADDRESS_TO_HEADER(IntelAddress+intelMem)->flags &= ~HDR_REMAP_FLAG;

    /* step 3 - free the reserved intel address space */

#ifdef DEBUG_MEM
#ifdef DEBUG_MEM_DUMP
        DumpAllocationHeaders("after remove (now calling free)");
#endif
#endif
    return VdmFreeVirtualMemory(IntelAddress);
}

/* Local Functions. */

/*
=============================== addHeaderEntry =================================
PURPOSE:
        Add an entry in the header table, corresponding to 'intelAddr'. The
        entry  will sit between 'prevHeader' and 'nextHeader' in the linked
        list. If 'prevHeader' is NULL, the new entry will be the first in the
        list. If 'nextHeader' is NULL, the new entry will be the last in the
        list. The 'allocFree' parameter states whether the section is to be
        marked as allocated or free. The 'size' parameter gives the new
        section's size. Returns a pointer to the new header on success, NULL
        on failure.
INPUT:
        prevHeader  - previous header in linked list - may be NULL if the new
                      header is to be the first in the list.
        nextHeader  - next header in linked list - may be NULL if the new
                      header is to be the last in the list.
        allocFree   - is the new header to be marked as allocated or free?
        intelAddr   - address of the new entry.
        size        - size of the new section in bytes.
OUTPUT:
        return val  - pointer to new section or NULL if there is a problem.
================================================================================
 */
LOCAL SECTION_HEADER *addHeaderEntry IFN5(SECTION_HEADER *, prevHeader,
                                          SECTION_HEADER *, nextHeader,
                                          SECT_TYPE, allocFree,
                                          IU8 *, intelAddr,
                                          IU32, size)
{
    SECTION_HEADER  *newHeader = ADDRESS_TO_HEADER(intelAddr);
                                    /* New header table entry. */
    IHP      retAddr,
             commitAddr;
    IU32     commitSize;

#ifndef PROD
    if (prevHeader)
        assert0(newHeader > prevHeader, "prevHeader invalid");
    if (nextHeader)
        assert0(newHeader < nextHeader, "nextHeader invalid");
#endif /* !PROD */

    /* Commit and zero table header entries if necessary. */
    exclusiveHeaderPages((IHPE) newHeader, (IHPE) prevHeader,
                         (IHPE) nextHeader, &commitAddr, &commitSize);
    if (commitSize)
    {
        retAddr = VirtualAlloc((LPVOID) commitAddr,
                               (DWORD) commitSize,
                               (DWORD) MEM_COMMIT,
			       (DWORD) PAGE_READWRITE);

#ifdef DEBUG_MEM
    if(retAddr != commitAddr)
	{
	    printf("V.Allocate failed (%xh) [%lxh :%xh]\n",GetLastError(),commitAddr,commitSize);
	}
#endif


        if (retAddr == commitAddr)
	    memset((void *) commitAddr, ZapValue, (size_t) commitSize);
        else
            return((SECTION_HEADER *) NULL);
    }

    /* Fill in header's fields. */
    newHeader->flags = HDR_VALID_FLAG;
    if (allocFree == SECT_ALLOC)
        newHeader->flags |= HDR_ALLOC_FLAG;
    newHeader->address = intelAddr;
    newHeader->size = size;

    /* Add it to linked list. */
    if (prevHeader)
        prevHeader->next = newHeader;
    if (nextHeader)
        nextHeader->prev = newHeader;
    newHeader->prev = prevHeader;
    newHeader->next = nextHeader;

    /* Success. */
    return(newHeader);
}

/*
=========================== deleteHeaderEntry ==================================
PURPOSE:
        Delete an entry in the header table and remove it from the linked list.
        If this entry is in an allocation page on its own, decommit the whole
        page, otherwise zero the entry. Return TRUE on success, FALSE on
        failure.
INPUT:
        header      - pointer to entry to be removed.
OUTPUT:
        return val  - TRUE on success, FALSE on failure.
================================================================================
 */
LOCAL IBOOL deleteHeaderEntry IFN1(SECTION_HEADER *, header)
{
    IHP     decommitAddr;
    IU32    decommitSize;

    /* If trying to delete the last allocated chunk, invalidate lastAllocPtr. */
    if (header == lastAllocPtr) {
        lastAllocPtr = NULL;
    }

    /* Find out which pages can be decommitted after this header is freed. */
    exclusiveHeaderPages((IHPE) header, (IHPE) header->prev,
                         (IHPE) header->next, &decommitAddr, &decommitSize);

    /* Remove header from linked list. */
    if (header->prev)
        header->prev->next = header->next;
    if (header->next)
        header->next->prev = header->prev;

    if (decommitSize)
    {

        /* Decommit any allocation pages exclusively covered by 'header'. */
        if (!VirtualFree((LPVOID) decommitAddr,
                         (DWORD) decommitSize,
                         (DWORD) MEM_DECOMMIT))
        {
            always_trace2("Could not decommit %dK at addr %#x",
                          decommitSize / ONE_K, decommitAddr);
            return(FALSE);
        }
    }
    else
    {

        /* Zero header's fields. */
        header->prev = (SECTION_HEADER *) NULL;
        header->flags = 0;
        header->address = 0;
        header->size = 0;
        header->next = (SECTION_HEADER *) NULL;
    }
}

/*
========================== exclusiveHeaderPages ================================
PURPOSE:
        Find the allocation pages EXCLUSIVELY covered by the table entry
        pointed to by 'header'. The previous and next headers in the table
        are pointed to by 'prev' and 'next', which may be NULL if there is
        no corresponding table entry. The address of the first page exclusive
        to the entry is returned in 'allocAddr', the size in bytes of exclusive
        pages is returned in 'allocSize'. If 'allocSize' is zero 'allocAddr'
        is undefined.
INPUT:
        tableAddress    - address of table entry about to be used or removed.
        prevAddress     - address of previous entry in list.
        nextAddress     - address of next entry in list.
OUTPUT:
        allocAddr       - pointer to first byte that needs to be
                          committed/decommitted (undefined if allocSize is 0).
        allocSize       - size in bytes that needs to be committed/decommitted.
================================================================================
 */
LOCAL void exclusiveHeaderPages IFN5(IHPE, tableAddress,
                                     IHPE, prevAddress,
                                     IHPE, nextAddress,
                                     IHP *, allocAddr,
                                     IU32 *, allocSize)
{
    IHPE    prevHeaderLastAddr,
            nextHeaderFirstAddr;

    /*
     * Find out which allocation pages are exclusively covered by the table
     * entry pointed to by 'header'.
     */
    if (prevAddress)
        prevHeaderLastAddr = prevAddress + sizeof(SECTION_HEADER) - 1;
    else
        prevHeaderLastAddr = (IHPE) 0;
    nextHeaderFirstAddr = nextAddress;
    exclusiveAllocPages(tableAddress,
                        (IU32) sizeof(SECTION_HEADER),
                        prevHeaderLastAddr,
                        nextHeaderFirstAddr,
                        allocAddr,
                        allocSize);
}

/*
=========================== exclusiveChunkPages ================================
PURPOSE:
        Return any allocation pages EXCLUSIVELY covered by the section of
        memory pointed to by 'chunkHeader'. The 'allocAddr' parameter points
        at the variable in which to store the address the first allocation
        page so covered. The 'allocSize' parameter points at the variable in
        which to store the size in bytes of these these pages. This routine
        calls 'exclusiveAllocPages' which returns zero in 'allocSize' if there
        are no exclusive pages, 'allocAddr' being undefined. The same is
        therefore true of this routine.
        If we are committing, we must commit any (potentially) uncommitted
        pages. If uncommitting, we must not uncommit any pages that are alloced,
        as they may be committed also.
INPUT:
        chunkHeader - The header table entry pointing at the section of memory
                      that may need committing/decommitting.
OUTPUT:
        allocAddr   - pointer to first byte that needs to be
                      committed/decommitted (undefined if allocSize is 0).
        allocSize   - size in bytes that needs to be committed/decommitted.
        Commit      - are we going to commit (true) or decommit this header.
================================================================================
 */
LOCAL void exclusiveChunkPages IFN4(SECTION_HEADER *, chunkHeader,
                                    IHP *, allocAddr,
                                    IU32 *, allocSize,
                                    BOOL, Commit)
{
    IHPE    prevChunkLastAddr,      /* Last page previous chunk touches. */
            nextChunkFirstAddr;     /* First page next chunk touches. */
    SECTION_HEADER  *prevHeader,    /* Pointer to previous allocated chunk. */
                    *nextHeader;    /* Pointer to next allocated chunk. */

    /* Find previous allocated chunk. */
    prevHeader = chunkHeader->prev;
    while ((prevHeader != NULL) &&
     (Commit?SECTION_IS_UNCOMMITTED(prevHeader):SECTION_IS_FREE(prevHeader)))
        prevHeader = prevHeader->prev;

    /* Work out end address of previous chunk. */
    if (prevHeader)
        prevChunkLastAddr = (IHPE) prevHeader->address + prevHeader->size - 1;
    else
        prevChunkLastAddr = (IHPE) 0;

    /* Find next allocated chunk. */
    nextHeader = chunkHeader->next;
    while ((nextHeader != NULL) &&
     (Commit?SECTION_IS_UNCOMMITTED(nextHeader):SECTION_IS_FREE(nextHeader)))
        nextHeader = nextHeader->next;

    /* Work out start address of next chunk. */
    if (nextHeader)
        nextChunkFirstAddr = (IHPE) nextHeader->address;
    else
        nextChunkFirstAddr = (IHPE) 0;

    /*
     * Find the address range of pages that need to be committed and pass them
     * straight up to the caller.
     */
    exclusiveAllocPages((IHPE) chunkHeader->address,
                        chunkHeader->size,
                        prevChunkLastAddr,
                        nextChunkFirstAddr,
                        allocAddr,
                        allocSize);
#ifdef DEBUG_MEM
    printf("NTVDM:Exclusive range to %s %lx+%lx is %lx+%lx\n",
    Commit ? "COMMIT" : "DECOMMIT", chunkHeader->address,chunkHeader->size,
    *allocAddr, *allocSize);
#endif
}

/*
============================= exclusiveAllocPages ==============================
PURPOSE:
        For a given memory range, find out which allocation pages need to be
        committed in order for memory accesses to be allowed across the entire
        range. To do this we need to know the address and size of the memory
        range. These are passed in 'address' and 'size'. We also need to know
        the addresses of the previous and next allocated memory ranges to find
        out which allocation pages are already committed. This information is
        passed to the function in 'prevAllocLastAddr' and 'nextAllocFirstAddr'.
        If there is no previous or next chunk, 'prevAllocLastAddr' or
        'nextAllocFirstAddr' is zero. The address and size that need to be
        committed are returned in 'commitAddr' and 'commitSize'. Note that if
        'commitSize' is zero, no memory needs to be committed and 'commitAddr'
        is undefined.
INPUT:
        address             - address of object being checked.
        size                - size of object being checked.
        prevAllocLastAddr   - address of last byte of previous allocated
                              object (or zero if there is none).
        nextAllocFirstAddr  - address of first byte of next allocated object
                              (or zero if there is none).
OUTPUT:
        allocAddr           - pointer to first byte that needs to be
                              committed/decommitted (undefined if allocSize
                              is 0).
        allocSize           - size in bytes that needs to be
                              committed/decommitted.
================================================================================
 */
LOCAL void exclusiveAllocPages IFN6(IHPE, address,
                                    IU32, size,
                                    IHPE, prevAllocLastAddr,
                                    IHPE, nextAllocFirstAddr,
                                    IHP *, allocAddr,
                                    IU32 *, allocSize)
{
    IU32    prevAllocLastPage,      /* Last page previous chunk touches. */
            currentAllocFirstPage,  /* First page current chunk touches. */
            currentAllocLastPage,   /* Last page current chunk touches. */
            nextAllocFirstPage,     /* First page next chunk touches. */
            firstPage,              /* First page that needs committing. */
            lastPage;               /* Last page that needs committing. */

#ifndef PROD

    /* Check for sensible parameters. */
    if (prevAllocLastAddr)
        assert0(address > prevAllocLastAddr, "address out of range");
    if (nextAllocFirstAddr)
        assert0(address < nextAllocFirstAddr, "address out of range");
#endif /* !PROD */

    /*
     * Work out first and last pages of new memory block that need to be
     * committed.
     */
    currentAllocFirstPage = address >> commitShift;
    currentAllocLastPage = (address + size - 1) >> commitShift;
    firstPage = currentAllocFirstPage;

/* Fix horrid nano lookahead bug, but leaves memory leak ?
 * Also insufficient anyway in general case
 */
#ifdef PIG
    lastPage = currentAllocLastPage+1;
#else
    lastPage = currentAllocLastPage;
#endif

    /*
     * Now check to see if first or last pages of this allocation are already
     * committed by adjacent allocations.
     */
    if (prevAllocLastAddr)
    {

        /* See if first page of current allocation is already committed. */
	prevAllocLastPage = prevAllocLastAddr >> commitShift;
        if (prevAllocLastPage == currentAllocFirstPage)
            firstPage++;
    }
    if (nextAllocFirstAddr)
    {

        /* See if last page of current chunk is already committed. */
	nextAllocFirstPage = nextAllocFirstAddr >> commitShift;
        if (nextAllocFirstPage == currentAllocLastPage)
            lastPage--;
    }

    /*
     * If first page is less than or equal to last page we have some pages to
     * allocate. Return the addrees and size to caller (zero size if nothing
     * do.
     */
    if (firstPage <= lastPage)
    {
	*allocAddr = (void *) (firstPage << commitShift);
	*allocSize = (lastPage - firstPage + 1) << commitShift;
    }
    else
        *allocSize = 0;
}


#ifdef DEBUG_MEM


/*
=========================== Dump Header Linked List ===========================
PURPOSE:
	Dump the headers linked list controlling allocated blocks


INPUT:	    None
OUTPUT:     Via printf

================================================================================
*/

GLOBAL VOID DumpAllocationHeaders IFN1(char*, where)
{

    SECTION_HEADER  *headerPtr; /* Pointer for searching through linked list. */

    /* Dump headers */
    printf("NTVDM: Dump Allocation Headers %s\n", where);
    printf("ptr        address   status size     (k)     commit\n");

    for(headerPtr = &headerTable[0] ;
	headerPtr != NULL ;
	headerPtr = headerPtr->next)
    {
	printf("%08lxh: %08lxh [%s] %08lxh (%05dK)%s%s\n",
               headerPtr,
	       headerPtr->address - intelMem,
	       SECTION_IS_FREE(headerPtr) ? "FREE" : "USED",
	       headerPtr->size, headerPtr->size / ONE_K,
	       headerPtr->flags & HDR_COMMITTED_FLAG ? " COMMITTED" : "",
	       headerPtr->flags & HDR_REMAP_FLAG ? " REMAPPED" : "");
    }

    printf("\n");
}


#endif DEBUG_MEM


#endif /* CPU_40_STYLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_nls.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <windows.h>
#include "host_def.h"
#include "insignia.h"
/*[
	Name:		nt_nls.c
	Derived From:	X_nls.c (Justin Koprowski)
	Author: 	Jerry Sexton
	Created On:	8th August 1991
	Purpose:
		This modules contains strings that are required for the
		.SoftPC file and the user interface.  In addition it also
		contains a routine, host_nls_get_msg,  for retrieving strings
		from the appropriate array, for ports that do not have native
		language support.

The following tables and routines are defined:
	1. config_message
	2. uis_message
	3. host_nls_get_msg

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

/* Global include files */
#include <stdio.h>
#include <string.h>
#include "xt.h"
#include "error.h"
#include "host_rrr.h"
#include "host_nls.h"
#include "nt_uis.h"

char szDoomMsg[MAX_PATH]="";
char szSysErrMsg[MAX_PATH]="";
#ifdef X86GFX
wchar_t wszFrozenString[32];
#endif

/* Use Unicode to work properly with NT's MUI technology */
wchar_t wszHideMouseMenuStr[64];
wchar_t wszDisplayMouseMenuStr[64];



/****************************************************************************
	Function:		host_nls_get_message()
	Purpose: 		Returns the required string from the
				resource file.
	Return Status:		None.
	Description:		This routine is supplied with a message
				number which falls in the following ranges:
					0-1000:     base error messages
					1001-2000:  host error message
******************************************************************************/

VOID
host_nls_get_msg(
     int message_number,
     CHAR *message_buffer,
     int buf_len
     )
/* int	message_number,		 	Number of SoftPC message.
 *	buf_len;		 	The maximum length of message, i.e.
 *				 	the size of message_buffer
 * char	*message_buffer;	 	Pointer to a buffer into which the
 * 				 	message is to be written
 */
{
    if (!LoadString(GetModuleHandle(NULL),
                    message_number,
                    message_buffer,
                    buf_len))
      {
       strncpy(message_buffer, szDoomMsg, buf_len);
       message_buffer[buf_len-1] = '\0';
       }
}

void nls_init(void)
{

    if (!LoadString(GetModuleHandle(NULL),
                    EHS_SYSTEM_ERROR,
                    szSysErrMsg,
                    sizeof(szSysErrMsg)/sizeof(CHAR)
                    )
         ||
        !FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL,
                       ERROR_NOT_ENOUGH_MEMORY,
                       0,
                       szDoomMsg,
                       sizeof(szDoomMsg)/sizeof(CHAR),
                       NULL
		       )
#ifdef X86GFX
	 ||
	!LoadStringW(GetModuleHandle(NULL),
		     IDS_BURRRR,
		     wszFrozenString,
		     sizeof(wszFrozenString)/sizeof(wchar_t)
		     )
#endif
	 ||
	!LoadStringW(GetModuleHandle(NULL),
		     SM_HIDE_MOUSE,
		     wszHideMouseMenuStr,
		     sizeof(wszHideMouseMenuStr)/sizeof(wchar_t)
		     )
	 ||
	!LoadStringW(GetModuleHandle(NULL),
		     SM_DISPLAY_MOUSE,
		     wszDisplayMouseMenuStr,
		     sizeof(wszDisplayMouseMenuStr)/sizeof(wchar_t)
		     ))
           {
            RaiseException((DWORD)STATUS_INSUFFICIENT_RESOURCES,
                           EXCEPTION_NONCONTINUABLE,
                           0,
                           NULL
                           );
	    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_ntfun.c ===
#include <nt.h>
#include <ntrtl.h>
#include <ntddser.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include "insignia.h"
#include "trace.h"
#include "host_trc.h"
#include "debug.h"
#include "nt_com.h"
#include "nt_reset.h"


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Defines */

#define SETUPLASTERROR(NtStatus) SetLastError(RtlNtStatusToDosError(NtStatus))

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::: Magic xoff ioctl and associated functions ::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


typedef struct IoStatusElement
{
    struct IoStatusElement *NxtStatusBlock;        //Ptr to next status block
    IO_STATUS_BLOCK ioStatusBlock;
} IOSTATUSLIST, *PIOSTATUSLIST ;


int SendXOFFIoctl(

HANDLE FileHandle,          // Handle of comms port to send xoff ioctl to
HANDLE Event,               // Event to signal completion of ioctl on
int Timeout,                // Ioctl timeout
int Count,                  // Ioctl RX character count value
int XoffChar,               // XOFF character
void *StatusElem)           // Ptr to IO status block element
{
    int exitcode;
    NTSTATUS rtn;               // Return code from IOCTL
    SERIAL_XOFF_COUNTER ioctl;  // XOFF IOCTL

    /*................................................... Setup XOFF ioctl */

    ioctl.Timeout = Timeout;            // IOCTL timeout in milliseconds
    ioctl.Counter = (LONG) Count;       // RX count
    ioctl.XoffChar = (UCHAR) XoffChar;  // XOFF character

    /*............................................. issue magic xoff ioctl */

    if(!NT_SUCCESS(rtn = NtDeviceIoControlFile(FileHandle, Event, NULL, NULL,
                                &(((PIOSTATUSLIST) StatusElem)->ioStatusBlock),
                                IOCTL_SERIAL_XOFF_COUNTER,
                                (PVOID) &ioctl, sizeof(ioctl), NULL, 0)))
    {
        // Should display an error here
        fprintf(trace_file, "NtDeviceIoControlFile failed %x\n",rtn);
        exitcode = FALSE;
    }
    else
        exitcode = TRUE;

    return(exitcode);
}

/*:::::::::::::::::::::::::::::::::::::::::::::: Allocate IO status element */

void *AllocStatusElement()
{
    void *new;

    /*:::::::::::::::::::::::::::::: Allocate space for new io status block */

    if((new = calloc(1,sizeof(IOSTATUSLIST))) == NULL)
    {
        // Allocation error do something about it
     ;
    }
    else
        ((PIOSTATUSLIST) new)->ioStatusBlock.Status = -1;

    return(new);
}

/*:::::::::::::::::::::::::::::::::::: Add new iostatusblock to linked list */

void *AddNewIOStatusBlockToList(void **firstBlock, void **lastBlock, void *new)
{

    /*:::::::::::::::::::::::::::::::::::::::: Add new block to linked list */

    if(*lastBlock)
        ((PIOSTATUSLIST)*lastBlock)->NxtStatusBlock = (PIOSTATUSLIST) new;

    /*:::::::::::::::::: Update first and last linked list element pointers */

    if(!*firstBlock) *firstBlock = new;  // First item in list

    *lastBlock = new;                    // Update last item pointer

    return((void *) new);
}

/*:::::::::::::::::::::::::: Remove completed XOFF ioctl's from linked list */

int RemoveCompletedIOCTLs(void **firstBlock, void **lastBlock)
{
    PIOSTATUSLIST remove, nxt = (PIOSTATUSLIST) *firstBlock;

    /*::::::::::::::::::::::::: Scan linked list removing completed ioctl's */

    while(nxt && nxt->ioStatusBlock.Status != -1)
    {
        /*......................... IOCTL completed, remove io status block */

        remove = nxt;               // Element to remove
        nxt = nxt->NxtStatusBlock;  // Next element to process

#ifndef PROD
        switch(remove->ioStatusBlock.Status)
	{
	    case STATUS_SUCCESS:
		sub_note_trace0(HOST_COM_VERBOSE,"XOFF (counter)\n");
		break;

	    case STATUS_SERIAL_MORE_WRITES:
		sub_note_trace0(HOST_COM_VERBOSE,"XOFF (more writes)\n");
		break;

	    case STATUS_SERIAL_COUNTER_TIMEOUT:
		sub_note_trace0(HOST_COM_VERBOSE,"XOFF (timeout)\n");
		break;

	    default:
		sub_note_trace0(HOST_COM_VERBOSE,"XOFF (unknown)\n");
		break;
        }
#endif

        free(remove);               // Deallocate element
    }

    /*::::::::::::::::::::::::::::::: Update first and last element pointers */

    if(!nxt)
    {
        // List empty reset first/last pointers
        *firstBlock = *lastBlock = NULL;
    }
    else
    {
        // Setup new first pointer
        *firstBlock = (void *) nxt;
    }


    // Returns true if there are still outstanding XOFF ioctl's
    return(nxt ? TRUE : FALSE);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


int FastSetUpComms(

HANDLE FileHandle,          // Handle of comms port to send xoff ioctl to
HANDLE Event,               // Event to signal completion of ioctl on
int InputQueueSize,
int OutputQueueSize)
{
    NTSTATUS rtn;
    SERIAL_QUEUE_SIZE ioctl;
    IO_STATUS_BLOCK ioStatusBlock;

    /*........................................................ Setup ioctl */

    ioctl.InSize = InputQueueSize;
    ioctl.OutSize = OutputQueueSize;

    /*............................................. issue magic xoff ioctl */

    if(!NT_SUCCESS(rtn = NtDeviceIoControlFile(FileHandle, Event, NULL, NULL,
				&ioStatusBlock,
				IOCTL_SERIAL_SET_QUEUE_SIZE,
                                (PVOID) &ioctl, sizeof(ioctl), NULL, 0)))
    {
	// Should display an error here
#ifndef PROD
	fprintf(trace_file, "%s (%d) ",__FILE__,__LINE__);
	fprintf(trace_file, "NtDeviceIoControlFile failed %x\n",rtn);
#endif
	return(FALSE);
    }

    /*......................................... Wait for IOCTL to complete */

    if(rtn == STATUS_PENDING)
        NtWaitForSingleObject(Event, FALSE, NULL);

    /*............................................ Check completion status */

#ifndef PROD
    if(ioStatusBlock.Status != STATUS_SUCCESS)
	fprintf(trace_file, "FastSetupComm failed (%x)\n",ioStatusBlock.Status);
#endif

    return(ioStatusBlock.Status == STATUS_SUCCESS ? TRUE : FALSE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::: Fast track SetCommMask call ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int FastSetCommMask(

HANDLE FileHandle,	    // Handle of comms port to send ioctl to
HANDLE Event,		    // Event to signal completion of ioctl on
ULONG  CommMask)
{
    NTSTATUS rtn;
    IO_STATUS_BLOCK ioStatusBlock;

    /*.......................................... issue set comm mask ioctl */

    if(!NT_SUCCESS(rtn = NtDeviceIoControlFile(FileHandle, Event, NULL, NULL,
				&ioStatusBlock,
				IOCTL_SERIAL_SET_WAIT_MASK,
				(PVOID) &CommMask, sizeof(CommMask), NULL, 0)))
    {
	// Should display an error here
#ifndef PROD
	fprintf(trace_file, "%s (%d) ",__FILE__,__LINE__);
	fprintf(trace_file, "NtDeviceIoControlFile failed %x\n",rtn);
#endif
	return(FALSE);
    }

    /*......................................... Wait for IOCTL to complete */

    if(rtn == STATUS_PENDING)
        NtWaitForSingleObject(Event, FALSE, NULL);

    /*............................................ Check completion status */

#ifndef PROD
    if(ioStatusBlock.Status != STATUS_SUCCESS)
	fprintf(trace_file,"FastSetCommMask failed (%x)\n",ioStatusBlock.Status);
#endif

    return(ioStatusBlock.Status == STATUS_SUCCESS ? TRUE : FALSE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::: Fast track GetCommModemStatus call ::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

int FastGetCommModemStatus(

HANDLE FileHandle,	    // Handle of comms port to send ioctl to
HANDLE Event,		    // Event to signal completion of ioctl on
PULONG ModemStatus)
{
    NTSTATUS rtn;
    IO_STATUS_BLOCK ioStatusBlock;

    /*.......................................... issue set comm mask ioctl */

    if(!NT_SUCCESS(rtn = NtDeviceIoControlFile(FileHandle, Event, NULL, NULL,
				&ioStatusBlock,
				IOCTL_SERIAL_GET_MODEMSTATUS,
				NULL, 0,
				(PVOID) ModemStatus, sizeof(ModemStatus))))
    {
	// Should display an error here
#ifndef PROD
	fprintf(trace_file, "%s (%d) ",__FILE__,__LINE__);
	fprintf(trace_file, "NtDeviceIoControlFile failed %x\n",rtn);
#endif
	return(FALSE);
    }

    /*......................................... Wait for IOCTL to complete */

    if(rtn == STATUS_PENDING)
        NtWaitForSingleObject(Event, FALSE, NULL);

    /*............................................ Check completion status */

#ifndef PROD
    if(ioStatusBlock.Status != STATUS_SUCCESS)
	fprintf(trace_file,"GetCommModemStatus failed (%x)\n",ioStatusBlock.Status);
#endif

    return(ioStatusBlock.Status == STATUS_SUCCESS ? TRUE : FALSE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::: Wait for a wakeup call from the CPU thread or serial driver :::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

//WARNING : This function can only be called from one thread within a process


BOOL FastWaitCommsOrCpuEvent(
HANDLE FileHandle,		//File handle or communications port
PHANDLE CommsCPUWaitEvents,	//Table or CPU thread and comms wait events
int CommsEventInx,		//Index in above table to comms event
PULONG EvtMask,			//Return Comms completion mask there
PULONG SignalledObj)
{
    NTSTATUS rtn;
    static IO_STATUS_BLOCK ioStatusBlock;
    static BOOL WaitCommEventOutStanding = FALSE;

    /*................................................ Is this a init call */

    if(FileHandle == NULL)
    {
	WaitCommEventOutStanding = FALSE;
	return(TRUE);		//Init successful
    }

    /*......................... Do we need to issue a new WaitComm ioctl ? */

    if(!WaitCommEventOutStanding)
    {

	/*...................................... Issue WaitCommEvent ioctl */

	if(!NT_SUCCESS(rtn = NtDeviceIoControlFile(FileHandle,
                                CommsCPUWaitEvents[CommsEventInx],
                                NULL,
                                NULL,
                                &ioStatusBlock,
				IOCTL_SERIAL_WAIT_ON_MASK,
                                NULL,
                                0,
                                EvtMask,
                                sizeof(ULONG))) )
	{
	    // Should display an error here
#ifndef PROD
	    fprintf(trace_file, "%s (%d) ",__FILE__,__LINE__);
	    fprintf(trace_file, "NtDeviceIoControlFile failed %x\n",rtn);
#endif
	    SETUPLASTERROR(rtn);
	    return(FALSE);
	}
	else
	    WaitCommEventOutStanding = TRUE;
    }
    else
	rtn = STATUS_PENDING;	 // Already pending WaitCommEvent ioctl

    /*.......................... Wait for communication or CPU thread event */

    if(rtn == STATUS_PENDING)
    {
        *SignalledObj = NtWaitForMultipleObjects(2,
                                                 CommsCPUWaitEvents,
                                                 WaitAny,
                                                 FALSE,
                                                 NULL
                                                 );

	/*........... Did wait complete because of a communications event ? */

	if(*SignalledObj == (ULONG)CommsEventInx)
	{
	    // Get result from WaitCommEvent ioctl

	    WaitCommEventOutStanding = FALSE;
	    if(ioStatusBlock.Status != STATUS_SUCCESS)
	    {
		SETUPLASTERROR(ioStatusBlock.Status);
		return(FALSE);
	    }
	}
    }
    else
    {
	//WaitCommEvent completed instantly
	*SignalledObj = CommsEventInx;
	WaitCommEventOutStanding = FALSE;
    }

    return(TRUE);
}



/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::: Turn on MSR,LSR, RX streaming mode :::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


BOOL EnableMSRLSRRXmode(

HANDLE FileHandle,	    // Handle of comms port to send ioctl to
HANDLE Event,		    // Event to signal completion of ioctl on
unsigned char EscapeChar)
{
    NTSTATUS rtn;
    IO_STATUS_BLOCK ioStatusBlock;

    /*........................................................ issue ioctl */

    if(!NT_SUCCESS(rtn = NtDeviceIoControlFile(FileHandle, Event, NULL, NULL,
				&ioStatusBlock,
				IOCTL_SERIAL_LSRMST_INSERT,
				&EscapeChar, sizeof(unsigned char),NULL,0)))
    {
#ifndef PROD
	fprintf(trace_file, "%s (%d) ",__FILE__,__LINE__);
	fprintf(trace_file, "NtDeviceIoControlFile failed %x\n",rtn);
#endif
	return(FALSE);
    }

    /*......................................... Wait for IOCTL to complete */

    if (rtn == STATUS_PENDING)
        NtWaitForSingleObject(Event, FALSE, NULL);


    /*............................................ Check completion status */

#ifndef PROD
    if(ioStatusBlock.Status != STATUS_SUCCESS)
	fprintf(trace_file,"IOCTL_SERIAL_LSRMST_INSERT ioctl failed (%x)\n",
		ioStatusBlock.Status);
#endif

    return(ioStatusBlock.Status == STATUS_SUCCESS ? TRUE : FALSE);
}


/* Function to set a new baudrate for the comm device.
 *  Input: FileHandle -- file handle to the comm device
 *	   BaudRate   -- new baudrate to be set for the comm device
 *  output: TRUE if the function succeed
 *	   FALSE if the function failed
**/


BOOL FastCommSetBaudRate(HANDLE FileHandle, int BaudRate)
{
    NTSTATUS	Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE	SyncEvent;
    SERIAL_BAUD_RATE	LocalBaud;

    SyncEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (SyncEvent == NULL)
	return FALSE;

    LocalBaud.BaudRate = (ULONG)BaudRate;

    Status = NtDeviceIoControlFile(FileHandle,
				   SyncEvent,
				   NULL,
				   NULL,
				   &IoStatusBlock,
				   IOCTL_SERIAL_SET_BAUD_RATE,
				   &LocalBaud,
				   sizeof(LocalBaud),
				   NULL,
				   0
				   );
    if (Status == STATUS_PENDING)
	NtWaitForSingleObject(SyncEvent, FALSE, NULL);
    CloseHandle(SyncEvent);
    return(NT_SUCCESS(Status) && NT_SUCCESS(IoStatusBlock.Status));
}

/* Function to set the new line control to the given comm device
 *  Input: FileHanlde -- file handle to the comm device
 *	   StopBits  -- new Stopbits
 *	   Parity	  -- new parity
 *	   DataBits  -- new databits
 *   Output:
 *	TRUE if the function succeed.
 *	FALSE if the function failed.
**/
BOOL FastCommSetLineControl(HANDLE FileHandle, UCHAR StopBits, UCHAR Parity,
			    UCHAR DataBits)
{
    NTSTATUS	Status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE	SyncEvent;
    SERIAL_LINE_CONTROL	LocalLC;


    /* make sure Windows and NT has the same definiation  because
     * the caller only deal with WINDOWS value	while we will be returning
     * NT values(NO_PARITY, STOP_BIT_1 and etc).
     */
    ASSERT(NOPARITY == NO_PARITY && ODDPARITY == ODD_PARITY &&
	   EVENPARITY == EVEN_PARITY && MARKPARITY == MARK_PARITY &&
	   SPACEPARITY == SPACE_PARITY);
    ASSERT(ONESTOPBIT == STOP_BIT_1 && ONE5STOPBITS == STOP_BITS_1_5 &&
	   TWOSTOPBITS == STOP_BITS_2);

    /* Create an event to wait for the NT call */
    SyncEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (SyncEvent == NULL)
	return FALSE;

    LocalLC.StopBits = StopBits;
    LocalLC.Parity = Parity;
    LocalLC.WordLength = DataBits;

    Status = NtDeviceIoControlFile(FileHandle,
				   SyncEvent,
				   NULL,
				   NULL,
				   &IoStatusBlock,
				   IOCTL_SERIAL_SET_LINE_CONTROL,
				   &LocalLC,
				   sizeof(LocalLC),
				   NULL,
				   0
				   );
    if (Status == STATUS_PENDING)
	NtWaitForSingleObject(SyncEvent, FALSE, NULL);

    CloseHandle(SyncEvent);
    return(NT_SUCCESS(Status) && NT_SUCCESS(IoStatusBlock.Status));
}

/* Function to retrieve the given comm device current line control setting
 * Input: FileHandle -- file handle to the comm device
 *	  StopBits, Parity and DataBits are pointers to the placeholders
 *	  to receive Stop bits, Parity and Data bits repectively.
 *  Output:
 *	TRUE if the function succeed
 *	FALSE if the function failed.
**/

BOOL FastCommGetLineControl(HANDLE FileHandle, UCHAR *StopBits, UCHAR *Parity,
			    UCHAR *DataBits)
{
    NTSTATUS	Status;
    SERIAL_LINE_CONTROL LocalLC;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE  SyncEvent;

    /* make sure Windows and NT has the same definiation  because
     * the parameters we received from the caller are WINDOWS value
     * while we will be calling NT API using NT values
     */
    ASSERT(NOPARITY == NO_PARITY && ODDPARITY == ODD_PARITY &&
	   EVENPARITY == EVEN_PARITY && MARKPARITY == MARK_PARITY &&
	   SPACEPARITY == SPACE_PARITY);
    ASSERT(ONESTOPBIT == STOP_BIT_1 && ONE5STOPBITS == STOP_BITS_1_5 &&
	   TWOSTOPBITS == STOP_BITS_2);

    ASSERT(StopBits != NULL && Parity != NULL && DataBits != NULL);

    SyncEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (SyncEvent == NULL)
	return FALSE;
    Status = NtDeviceIoControlFile(FileHandle,
				   SyncEvent,
				   NULL,
				   NULL,
				   &IoStatusBlock,
				   IOCTL_SERIAL_GET_LINE_CONTROL,
				   NULL,
				   0,
				   &LocalLC,
				   sizeof(LocalLC)
				   );
    if (Status == STATUS_PENDING)
	NtWaitForSingleObject(SyncEvent, FALSE, NULL);

    CloseHandle(SyncEvent);

    if ( NT_SUCCESS(Status) && NT_SUCCESS(IoStatusBlock.Status)) {
	*StopBits = LocalLC.StopBits;
	*Parity = LocalLC.Parity;
	*DataBits = LocalLC.WordLength;
	return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_pif.c ===
/*================================================================

nt_pif.c

Code to read the relevant data fields from a Windows Program
Information File for use with the SoftPC / NT configuration
system.

Andrew Watson    31/1/92
This line causes this file to be build with a checkin of NT_PIF.H

================================================================*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "insignia.h"
#include "host_def.h"

#include <pif.h>
#include "nt_pif.h"
#include "nt_reset.h"
#include <oemuni.h>
#include "error.h"

 //
 // holds config.sys and autoexec name from pif file
 // if none specifed, then NULL.
 //
static char *pchConfigFile=NULL;
static char *pchAutoexecFile=NULL;

VOID GetPIFConfigFiles(BOOL bConfig, char *pchFileName, BOOL bFreMem);

DWORD dwWNTPifFlags;
UCHAR WNTPifFgPr = 100;
UCHAR WNTPifBgPr = 100;

char achConfigNT[]  ="config.nt";
char achAutoexecNT[]="autoexec.nt";
#ifdef JAPAN
char achConfigUS[] = "config.us";
unsigned short fSBCSMode = 0;
#endif // JAPAN

/*  GetPIFConfigFile
 *
 *  Copies PIF file specified name of config.sys\autoexec.bat
 *  to be used if none specified then uses
 *  "WindowsDir\config.nt" or "WindowsDir\autoexec.nt"
 *
 *  ENTRY: BOOLEAN bConfig  - TRUE  retrieve config.sys
 *                            FALSE retrieve autoexec.bat
 *
 *         char *pchFile - destination for path\file name
 *
 *         BOOLEAN bFreMem  - TRUE  keep allocate buffer
 *                            FALSE free allocate buffer
 *
 *  The input buffer must be at least MAX_PATH + 8.3 BaseName in len
 *
 *  This routine cannot fail, but it may return a bad file name!
 */

VOID GetPIFConfigFiles(BOOL bConfig, char *pchFileName, BOOL bFreMem)
{
   DWORD dw;
   char  **ppch;

   ppch = bConfig ? &pchConfigFile : &pchAutoexecFile;
   if (!*ppch)
      {
       memcpy (pchFileName, pszSystem32Path, ulSystem32PathLen);
       pchFileName[ulSystem32PathLen] = '\\';
#ifdef JAPAN
       memcpy ( pchFileName + ulSystem32PathLen + 1,
                bConfig ? (fSBCSMode ? achConfigUS : achConfigNT) : achAutoexecNT,
                (bConfig ? (fSBCSMode ? strlen(achConfigUS) : strlen(achConfigNT)) : strlen(achAutoexecNT))+1);
#else // !JAPAN
       memcpy(  pchFileName + ulSystem32PathLen + 1,
                bConfig ? achConfigNT : achAutoexecNT,
                (bConfig ? strlen(achConfigNT) : strlen(achAutoexecNT))+1);
#endif // !JAPAN
       }
   else {
       dw = ExpandEnvironmentStringsOem(*ppch, pchFileName, MAX_PATH+12);
       if (!dw || dw > MAX_PATH+12) {
           *pchFileName = '\0';
           }
       // Free buffer only when asked
       if (!bFreMem) {
         free(*ppch);
         *ppch = NULL;
       }

       }
}


void SetPifDefaults(PIF_DATA *);

/*===============================================================

Function:   GetPIFData()

Purpose:    This function gets the PIF data from the PIF file 
            associated with the executable that SoftPC is trying
            to run.

Input:      FullyQualified PifFileName,
            if none supplied _default.pif will be used

Output:     A structure containing data that config needs.

Returns:    TRUE if the data has been gleaned successfully, FALSE
            if not.

================================================================*/

BOOL GetPIFData(PIF_DATA * pd, char *PifName)
{
    DWORD dw;
    CHAR  achDef[]="\\_default.pif";
    PIFEXTHEADER        exthdr;
    PIFOLD286STR        pif286;
    PIF386EXT           ext386;
    PIF286EXT30         ext286;
    PIFWNTEXT           extWNT;
    WORD      IdleSensitivity = (WORD)-1;

    HFILE      filehandle;
    char                pathBuff[MAX_PATH*2];
    BOOL                bGot386;
    int     index;
    char    *CmdLine;
#ifdef JAPAN
    PIFAXEXT      extAX;
    BOOL    bGotNTConfigAutoexec;
#endif // JAPAN

     CmdLine = NULL;
     dwWNTPifFlags = 0;
#ifdef JAPAN
     bGotNTConfigAutoexec = FALSE;
#endif // JAPAN

     //
     // set the defaults in case of error or in case we can't find
     // all of the pif settings information now for easy error exit
     //
    SetPifDefaults(pd);

        // if no PifName, use %windir%\_default.pif
    if (!*PifName) {
        dw = GetWindowsDirectory(pathBuff, sizeof(pathBuff) - sizeof(achDef));
        if (dw && dw <= sizeof(pathBuff) - sizeof(achDef)) {
            strcat(pathBuff, achDef);
            if (GetFileAttributes(pathBuff) != (DWORD)-1) {
                PifName = pathBuff;
                }
            }
        }

        // if _default.pif isn't there, try again with non-virtualized (TS)
        // %windir%\_default.pif
    if (!*PifName) {
        dw = GetSystemWindowsDirectory(pathBuff, sizeof(pathBuff) - sizeof(achDef));
        if (!dw || dw > sizeof(pathBuff) - sizeof(achDef)) {
            return FALSE;            // give it up... use default settings
            }
        strcat(pathBuff, achDef);
        PifName = pathBuff;
        }


/*================================================================
Open the file whose name was passed as a parameter to GetPIFData()
and if an invalid handle to the file is returned (-1), then quit.
The file specified is opened for reading only.
================================================================*/

if((filehandle=_lopen(PifName,OF_READ)) == (HFILE) -1)
   {
   /* must be an invalid handle ! */
   return FALSE;
   }


/*================================================================
Get the main block of data from the PIF file.
================================================================*/

/* Read in the main block of file data into the structure */
if(_llseek(filehandle,0,0) == -1)
   {
   _lclose(filehandle);
   return FALSE;
   }
if(_lread(filehandle,(LPSTR)&pif286,sizeof(pif286)) == -1)
   {
   _lclose(filehandle);
   return FALSE;
   }

/*==============================================================
Go to the PIF extension signature area and try to read the 
header in. 
==============================================================*/
   
if (_lread(filehandle,(LPSTR)&exthdr,sizeof(exthdr)) == -1)
   {
   _lclose(filehandle);
   return FALSE;
   }

      // do we have any extended headers ?
if (!strcmp(exthdr.extsig, STDHDRSIG))
   {
   bGot386 = FALSE;
   while (exthdr.extnxthdrfloff != LASTHEADER)
       {
              //
              // move to next extended header and read it in
              //
         if (_llseek(filehandle,exthdr.extnxthdrfloff,0) == -1)
           {
            _lclose(filehandle);
            return FALSE;
            }
         if (_lread(filehandle,(LPSTR)&exthdr,sizeof(exthdr)) == -1)
            {
            _lclose(filehandle);
            return FALSE;
            }

              //
              // Get 286 extensions, note that 386 extensions take precedence
              //
         if (!strcmp(exthdr.extsig, W286HDRSIG) && !bGot386)
           {
             if(_llseek(filehandle, exthdr.extfileoffset, 0) == -1  ||
                _lread(filehandle,(LPSTR)&ext286,sizeof(ext286)) == -1)
                {
                _lclose(filehandle);
                return FALSE;
                }
             pd->xmsdes =ext286.PfMaxXmsK;
             pd->xmsreq =ext286.PfMinXmsK;
             pd->reskey =ext286.PfW286Flags & 3;
             pd->reskey |= (ext286.PfW286Flags << 2) & 0x70;
             }
              //
              // Get 386 extensions
              //
         else if (!strcmp(exthdr.extsig, W386HDRSIG))
           {
             if(_llseek(filehandle, exthdr.extfileoffset, 0) == -1  ||
                _lread(filehandle,(LPSTR)&ext386,sizeof(ext386)) == -1)
                {
                _lclose(filehandle);
                return FALSE;
                }
             bGot386 = TRUE;
             pd->emsdes=ext386.PfMaxEMMK;
             pd->emsreq=ext386.PfMinEMMK;
             pd->xmsdes=ext386.PfMaxXmsK;
             pd->xmsreq=ext386.PfMinXmsK;


             //
             // If we don't have a valid idle sensitivity slider bar settings use the
             // value from 386 extensions.
             //
             if (IdleSensitivity > 100) {
                 if (ext386.PfFPriority < 100) {
                     WNTPifFgPr = (UCHAR)ext386.PfFPriority;   // Foreground priority
                     }
                 if (ext386.PfBPriority < 50) {
                     WNTPifBgPr = (UCHAR)ext386.PfBPriority;        // Background priority
                     WNTPifBgPr <<= 1;                           // set def 50 to 100
                     }

                  pd->idledetect = (char)((ext386.PfW386Flags >> 12) & 1);
                  }

             pd->reskey = (char)((ext386.PfW386Flags >> 5) & 0x7f); // bits 5 - 11 are reskeys
             pd->menuclose = (char)(ext386.PfW386Flags & 1);        // bottom bit sensitive
             pd->ShortScan = ext386.PfHotKeyScan;    // scan code of shortcut key
             pd->ShortMod = ext386.PfHotKeyShVal;    // modifier code of shortcut key
             pd->fullorwin  = (WORD)((ext386.PfW386Flags & fFullScreen) >> 3);
             bPifFastPaste = (ext386.PfW386Flags & fINT16Paste) != 0;
             CmdLine = ext386.params;
             }
                  //
                  // Get Windows Nt extensions
                  //
         else if (!strcmp(exthdr.extsig, WNTEXTSIG))
            {
             if(_llseek(filehandle, exthdr.extfileoffset, 0) == -1 ||
                _lread(filehandle,(LPSTR)&extWNT, sizeof(extWNT)) == -1)
                {
                _lclose(filehandle);
                return FALSE;
                }

             dwWNTPifFlags = extWNT.dwWNTFlags;
             pd->SubSysId = (char) (dwWNTPifFlags & NTPIF_SUBSYSMASK);

        /* take autoexec.nt and config.nt from .pif file
      only if we are running on a new console or it is from
      forcedos/wow
        */
        if (!pd->IgnoreConfigAutoexec)
      {
#ifdef JAPAN
      // if we got private config and autoexec
      // from nt extention, ignore win31j extention
      bGotNTConfigAutoexec = TRUE;
      fSBCSMode = 0;
#endif // JAPAN
      pchConfigFile = ch_malloc(PIFDEFPATHSIZE);
      extWNT.achConfigFile[PIFDEFPATHSIZE-1] = '\0';
      if (pchConfigFile) {
          strncpy(pchConfigFile, extWNT.achConfigFile, PIFDEFPATHSIZE);
          pchConfigFile[PIFDEFPATHSIZE - 1] = '\0';
          }

      pchAutoexecFile = ch_malloc(PIFDEFPATHSIZE);
      extWNT.achAutoexecFile[PIFDEFPATHSIZE-1] = '\0';
      if (pchAutoexecFile) {
          strncpy(pchAutoexecFile, extWNT.achAutoexecFile,PIFDEFPATHSIZE);
          pchAutoexecFile[PIFDEFPATHSIZE - 1] = '\0';
          }
      }
             }

                  //
                  // Get Window 4.0 enhanced pif. Right now we only care about the
                  // idle sensitivity slider bar because its not beiong mapped into
                  // the 386 idle\polling stuff. For next release we need to integrate
                  // this section better.
                  //
         else if (!strcmp(exthdr.extsig, WENHHDRSIG40)) {
             WENHPIF40 wenhpif40;

             if(_llseek(filehandle, exthdr.extfileoffset, 0) == -1  ||
                _lread(filehandle,(LPSTR)&wenhpif40,sizeof(wenhpif40)) == -1)
                {
                _lclose(filehandle);
                return FALSE;
                }


             //
             // On current systems user is not able to manipulate
             //    ext386.PfFPriority,
             //    ext386.PfBPriority,
             //    ext386.PfW386Flags fPollingDetect.
             //
             // Instead the idle sensitivity slider bar is used, and overrides 386ext
             // idle settings.
             //

             if (wenhpif40.tskProp.wIdleSensitivity <= 100) {
                 IdleSensitivity =  wenhpif40.tskProp.wIdleSensitivity;

                 // Sensitivity default is 50, scale to default ntvdm idle detection.
                 WNTPifBgPr = WNTPifFgPr = (100 - IdleSensitivity) << 1;

                 // Idle detection on or off.
                 if (IdleSensitivity > 0) {
                     pd->idledetect = 1;
                     }
                 }
             }


#ifdef   JAPAN
     // only read in win31j extention if
     // (1). we are running in a new console
     // (2). no private config/autoexec was given in the pif
     else if (!bGotNTConfigAutoexec &&
         !pd->IgnoreWIN31JExtention &&
         !strcmp(exthdr.extsig, AXEXTHDRSIG))
        {
        if(_llseek(filehandle, exthdr.extfileoffset, 0) == -1 ||
      _lread(filehandle,(LPSTR)&extAX, PIFAXEXTSIZE) == -1)
                {
                _lclose(filehandle);
                return FALSE;
                }

      fSBCSMode = extAX.fSBCSMode;
#ifdef JAPAN_DBG
                DbgPrint( "NTVDM: GetPIFData: fsSBCSMode = %d\n", fSBCSMode );
#endif
        }
#endif // JAPAN
         }  // while !lastheader

   /* pif file handling strategies on NT:
   (1). application was launched from a new created console
   Take everything from the pif file.

   (2). application was launched from an existing console
   if (ForceDos pif file)
       take everything
   else
       only take softpc stuff and ignore every name strings in the
       pif file such as
       * wintitle
       * startup directory
       * optional parameters
       * startup file
       * autoexec.nt
       * config.nt  and

       some softpc setting:

       * close on exit.
       * full screen and windowed mode

   Every name strings in a pif file is in OEM character set.

   */

   if (DosSessionId ||
       (pfdata.AppHasPIFFile && pd->SubSysId == SUBSYS_DOS))
   {
        if (pif286.name[0] && !pd->IgnoreTitleInPIF) {
       /* grab wintitle from the pif file. Note that the title
          in the pif file is not a NULL terminated string. It always
          starts from a non-white character then the real
          title(can have white characters between words) and finally
          append with SPACE characters. The total length is 30 characters.
       */
       for (index = 29; index >= 0; index-- )
                if (pif286.name[index] != ' ')
          break;
            if (index >= 0 && (pd->WinTitle = ch_malloc(MAX_PATH + 1))) {
                RtlMoveMemory(pd->WinTitle, pif286.name, index + 1);
      pd->WinTitle[index + 1] = '\0';
       }
   }
   if (pif286.defpath[0] && !pd->IgnoreStartDirInPIF &&
       (pd->StartDir = ch_malloc(MAX_PATH + 1))) {
       strncpy(pd->StartDir, pif286.defpath, MAX_PATH + 1);
       pd->StartDir[MAX_PATH] = '\0';
       }

   if (!pd->IgnoreCmdLineInPIF) {
       CmdLine = (CmdLine) ? CmdLine : pif286.params;
       if (CmdLine && *CmdLine && (pd->CmdLine = ch_malloc(MAX_PATH + 1))) {
           strncpy(pd->CmdLine, CmdLine, MAX_PATH + 1);
           pd->CmdLine[MAX_PATH] = '\0';
           }
       }

   if (DosSessionId)
            pd->CloseOnExit = (pif286.MSflags & 0x10) ? 1 : 0;

   /* if the app has a pif file, grab the program name.
      This can be discarded if it turns out the application itself
      is not a pif file.
   */
   if (pd->AppHasPIFFile) {
       pd->StartFile = ch_malloc(MAX_PATH + 1);
       if (pd->StartFile) {
           strncpy(pd->StartFile, pif286.startfile,MAX_PATH + 1);
           pd->StartFile[MAX_PATH] = '\0';
           }
       }
   }
 }

_lclose(filehandle);
return TRUE;

}



/*===============================================================
Function to set up the default options for memory state.
The default options are defined in nt_pif.h
===============================================================*/

void SetPifDefaults(PIF_DATA *pd)
{
     pd->memreq = DEFAULTMEMREQ;
     pd->memdes = DEFAULTMEMDES;
     pd->emsreq = DEFAULTEMSREQ;
     pd->emsdes = DEFAULTEMSLMT;
     pd->xmsreq = DEFAULTXMSREQ;
     pd->xmsdes = DEFAULTXMSLMT;
     pd->graphicsortext = DEFAULTVIDMEM;
     pd->fullorwin      = DEFAULTDISPUS;
     pd->menuclose = 1;
     pd->idledetect = 1;
     pd->ShortMod = 0;                       // No shortcut keys
     pd->ShortScan = 0;
     pd->reskey = 0;                         // No reserve keys
     pd->CloseOnExit = 1;
     pd->WinTitle = NULL;
     pd->CmdLine = NULL;
     pd->StartFile = NULL;
     pd->StartDir = NULL;
     pd->SubSysId = SUBSYS_DEFAULT;
}

/*
 * Allocate NumBytes memory and exit cleanly on failure.
 */
void *ch_malloc(unsigned int NumBytes)
{

    unsigned char *p = NULL;

    while ((p = malloc(NumBytes)) == NULL) {
   if(RcMessageBox(EG_MALLOC_FAILURE, "", "",
          RMB_ABORT | RMB_RETRY | RMB_IGNORE |
          RMB_ICON_STOP) == RMB_IGNORE)
       break;
    }
    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_msscs.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdmapi.h>
#include <vdm.h>
#include "insignia.h"
#include "host_def.h"
#include "conapi.h"
#include "ctype.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include <io.h>
#include <fcntl.h>

#include "xt.h"
#include CpuH
#include "error.h"
#include "sas.h"
#include "ios.h"
#include "umb.h"
#include "gvi.h"
#include "sim32.h"
#include "bios.h"

#include "nt_eoi.h"
#include "nt_uis.h"
#include "nt_event.h"
#include "nt_graph.h"
#include "nt_event.h"
#include "nt_reset.h"
#include "config.h"
#include "sndblst.h"
#include <nt_vdd.h>   // DO NOT USE vddsvc.h
#include <nt_vddp.h>
#include <host_emm.h>
#include "emm.h"
#include <demexp.h>
#include <vint.h>
#include "xmsexp.h"
#include "dbgexp.h"
#include "cmdsvc.h"

PMEM_HOOK_DATA MemHookHead = NULL;
PVDD_USER_HANDLERS UserHookHead= NULL;

extern VOID DpmiEnableIntHooks (VOID);
extern DWORD TlsDirectError;
extern VOID FloppyTerminatePDB(USHORT PDB);
extern VOID FdiskTerminatePDB(USHORT PDB);

// internal function prototypes
VOID SetupInstallableVDD (VOID);
void AddSystemFiles(void);

void scs_init(int argc, char **argv)
{
    BOOL IsFirst;

    IsFirst = GetNextVDMCommand(NULL);
    if (IsFirst)  {
        AddSystemFiles();
        }

    // Initialize SCS

    CMDInit ();

    // Initialize DOSEm

    DemInit ();

    // Initialize XMS

    if(!XMSInit ()) {
        host_error(EG_OWNUP, ERR_QUIT, "NTVDM:XMSInit fails");
        TerminateVDM();
    }

    // Initialize DBG

    if(!DBGInit ()) {
#ifndef PROD
        printf("NTVDM:DBGInit fails\n");
        HostDebugBreak();
#endif
        TerminateVDM();
    }

    //
    // have dpmi do the interrupt dispatching
    //
    DpmiEnableIntHooks();
}

//
// This routine contains the Dos Emulation initialisation code, called from
// main(). We currently do not support container files.
//

extern boolean lim_page_frame_init(PLIM_CONFIG_DATA);


InitialiseDosEmulation(int argc, char **argv)
{
    HANDLE   hFile;
    DWORD    FileSize;
    DWORD    BytesRead;
    DWORD    dw;
    ULONG    fVirtualInt, fTemp;
    host_addr  pDOSAddr;
    CHAR  buffer[MAX_PATH*2];
#ifdef LIM
    LIM_CONFIG_DATA lim_config_data;
#endif
#ifdef FE_SB
    LANGID   LcId = GetSystemDefaultLangID();
#endif

    //
    // first order of bussiness, initialize virtual interrupt flag in
    // dos arena. this has to be done here before it gets changed
    // by reading in ntio.sys
    //

    sas_loads((ULONG)FIXED_NTVDMSTATE_LINEAR,
              (PCHAR)&fVirtualInt,
              FIXED_NTVDMSTATE_SIZE
              );
#ifndef i386
    fVirtualInt |=  MIPS_BIT_MASK;
#else
    fVirtualInt &=  ~MIPS_BIT_MASK;
#endif
    fVirtualInt &= ~VDM_BREAK_DEBUGGER;
    sas_storedw((ULONG)FIXED_NTVDMSTATE_LINEAR,fVirtualInt);

    io_init();

    //
    //  Allocate per thread local storage.
    //  Currently we only need to store one DWORD, so we
    //  don't need any per thread memory.
    //
    TlsDirectError = TlsAlloc();
#ifndef PROD
    if (TlsDirectError == 0xFFFFFFFF)
        printf("NTVDM: TlsDirectError==0xFFFFFFFF GLE=%ld\n", GetLastError);
#endif


    // SetupInstallableVDD ();

    /*................................................... Execute reset */
    reset();

    SetupInstallableVDD ();

    //
    // Initialize internal SoundBlaster VDD after the intallable VDDs
    //

    SbInitialize ();

    /* reserve lim block after all vdd are installed.
       the pif file settings tell us if it is necessary to
       reserve the block
    */

#ifdef LIM
    /* initialize lim page frames after all vdd are installed.
       the pif file settings tell us if it is necessary to
       reserve the block.
    */
    if (get_lim_configuration_data(&lim_config_data))
        lim_page_frame_init(&lim_config_data);

#endif

     scs_init(argc, argv);           // Initialise single command shell

     //
     // Routines called in scs_init may have added bits to the vdmstate flags.
     // read it in so we can preserve the state
     //

     sas_loads((ULONG)FIXED_NTVDMSTATE_LINEAR,
              (PCHAR)&fTemp,
              FIXED_NTVDMSTATE_SIZE
              );

     fVirtualInt |= fTemp;

     /*................................................. Load DOSEM code */

     memcpy(buffer, pszSystem32Path, ulSystem32PathLen);

#ifdef FE_SB
        switch (LcId) {
            case MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT):
                memcpy (buffer+ulSystem32PathLen, NTIO_411, strlen(NTIO_411) + 1);
                break;
            case MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT):
                memcpy (buffer+ulSystem32PathLen, NTIO_412, strlen(NTIO_412) + 1);
                break;
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL):
                memcpy (buffer+ulSystem32PathLen, NTIO_404, strlen(NTIO_404) + 1);
                break;
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED):
            case MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_HONGKONG):
                memcpy (buffer+ulSystem32PathLen, NTIO_804, strlen(NTIO_804) + 1);
                break;
            default:
                memcpy (buffer+ulSystem32PathLen, NTIO_409, strlen(NTIO_409) + 1);
                break;
        }
#else
     memcpy(buffer+ulSystem32PathLen, NTIO_409, strlen(NTIO_409) + 1);
#endif

     hFile = CreateFile(buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

     if (hFile == INVALID_HANDLE_VALUE ||
         !(FileSize = GetFileSize(hFile, &BytesRead)) ||
         BytesRead )
        {
#ifndef PROD
         printf("NTVDM:Fatal Error, Invalid file or missing - %s\n",buffer);
#endif
         host_error(EG_SYS_MISSING_FILE, ERR_QUIT, buffer);
         if (hFile != INVALID_HANDLE_VALUE) {
             CloseHandle(hFile);
             }
         return (-1);
         }


     pDOSAddr = get_byte_addr(((NTIO_LOAD_SEGMENT<<4)+NTIO_LOAD_OFFSET));

     if (!ReadFile(hFile, pDOSAddr, FileSize, &BytesRead, NULL) ||
         FileSize != BytesRead)
        {

#ifndef PROD
          printf("NTVDM:Fatal Error, Read file error - %s\n",buffer);
#endif
          host_error(EG_SYS_MISSING_FILE, ERR_QUIT, buffer);
          CloseHandle(hFile);
          return (-1);
          }

     CloseHandle(hFile);

        // oops ... restore the virtual interrupt state,
        // which we just overwrote in the file read, and reset.
     sas_storedw((ULONG)FIXED_NTVDMSTATE_LINEAR, fVirtualInt);

     setCS(NTIO_LOAD_SEGMENT);
     setIP(NTIO_LOAD_OFFSET);        // Start CPU at DosEm initialisation entry point


        //
        // Ensure that WOW VDM runs at NORMAL priorty
        //
    if (VDMForWOW) {
        SetPriorityClass (NtCurrentProcess(), NORMAL_PRIORITY_CLASS);
        }

        //
        // Don't allow dos vdm to run at realtime
        //
    else if (GetPriorityClass(NtCurrentProcess()) == REALTIME_PRIORITY_CLASS)
      {
        SetPriorityClass(NtCurrentProcess(), HIGH_PRIORITY_CLASS);
        }


    return 0;
}


/*
 *   AddSystemFiles
 *
 *   If the system file IBMDOS.SYS|MSDOS.SYS doesn't exist
 *   in the root of c: create zero len MSDOS.SYS
 *
 *   If the system file IO.SYS does not exist create
 *   a zero len IO.SYS
 *
 *   This hack is put in especially for the Brief 3.1 install
 *   program which looks for the system files, and if they are
 *   not found screws up the config.sys file.
 *
 */
void AddSystemFiles(void)
{
   HANDLE hFile, hFind;
   WIN32_FIND_DATA wfd;
   char *pchIOSYS    ="C:\\IO.SYS";
   char *pchMSDOSSYS ="C:\\MSDOS.SYS";


   hFind = FindFirstFile(pchMSDOSSYS, &wfd);
   if (hFind == INVALID_HANDLE_VALUE) {
       hFind = FindFirstFile("C:\\IBMDOS.SYS", &wfd);
       }

   if (hFind != INVALID_HANDLE_VALUE) {
       FindClose(hFind);
       }
   else {
       hFile = CreateFile(pchMSDOSSYS,
                          0,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          CREATE_NEW,
                          FILE_ATTRIBUTE_HIDDEN |
                          FILE_ATTRIBUTE_SYSTEM |
                          FILE_ATTRIBUTE_READONLY,
                          0);
       if (hFile != INVALID_HANDLE_VALUE) { // not much we can do if fails
           CloseHandle(hFile);
           }

       }

   hFind = FindFirstFile(pchIOSYS, &wfd);
   if (hFind == INVALID_HANDLE_VALUE) {
       hFind = FindFirstFile("C:\\IBMBIO.SYS", &wfd);
       }

   if (hFind != INVALID_HANDLE_VALUE) {
       FindClose(hFind);
       }
   else {
       hFile = CreateFile(pchIOSYS,
                          0,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          CREATE_NEW,
                          FILE_ATTRIBUTE_HIDDEN |
                          FILE_ATTRIBUTE_SYSTEM |
                          FILE_ATTRIBUTE_READONLY,
                          0);
       if (hFile != INVALID_HANDLE_VALUE) { // not much we can do if fails
           CloseHandle(hFile);
           }

       }
}


#ifdef LIM
/* parse EMM= line in config.nt to collect EMM parameters. The EMM line has
 * the following syntax:
 * EMM=[a=altregs][b=segment][i=segment1-segment2][x=segment1-segment2] [RAM]
 * where "a=altregs" specifies how many alternative mapping register set
 *       "b=segment" specifies the backfill starting segment address.
 *       "RAM" indicates that the system should only allocate 64KB from
 *       UMB to use as EMM page frame.
 *       "i=segment1 - segment2" specifies a particular range of
 *       address that the system should include as EMM page frame
 *       "x=segment1 - segment2" specifies a particular range of
 *       address that the system should NOT use as page frame.
 *
 *  input: pointer to LIM_PARAMS
 *  output: LIM_PARAMS is filled with data
 *
 */

#define IS_EOL_CHAR(c)      (c == '\n' || c == '\r' || c == '\0')
#define SKIP_WHITE_CHARS(size, ptr)     while (size && isspace(*ptr)) \
                                        { ptr++; size--; }

#define TOINT(c)            ((c >= '0' && c <= '9') ? (c - '0') : \
                             ((c >= 'A' && c <= 'F') ? (c - 'A' + 10) : \
                              ((c >= 'a' && c <= 'f') ? (c - 'a' + 10) : 0) \
                             )\
                            )


extern void GetPIFConfigFiles(int, char *, int);

boolean init_lim_configuration_data(PLIM_CONFIG_DATA lim_data)
{
    char config_sys_pathname[MAX_PATH+13];
    HANDLE  handle;
    DWORD   file_size, bytes_read, size;
    char    *buffer, *ptr;
    short   lim_size, base_segment, total_altreg_sets;
    boolean ram_flag_found, reserve_umb_status, parsing_error;
    sys_addr    page_frame;
    int     i;


    /* initialize some default values */
    base_segment = 0x4000;
    total_altreg_sets = 8;
    ram_flag_found = FALSE;

    parsing_error = FALSE;

    /* if we can not find config.nt, we can not go on. */

    GetPIFConfigFiles(TRUE, config_sys_pathname, TRUE);

    if (*config_sys_pathname == '\0')
        return FALSE;

    handle = CreateFile(config_sys_pathname,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
    if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

    file_size = GetFileSize(handle, NULL);
    if (file_size == 0 || file_size == 0xFFFFFFFF) {
        CloseHandle(handle);
        return FALSE;
    }
    buffer = malloc(file_size);
    if (buffer == NULL) {
        CloseHandle(handle);
        host_error(EG_MALLOC_FAILURE, ERR_QUIT, "");
        return FALSE;
    }
    if (!ReadFile(handle, buffer, file_size, &bytes_read, NULL) ||
        bytes_read != file_size)
    {
        CloseHandle(handle);
        free(buffer);
        return FALSE;
    }
    CloseHandle(handle);

    ptr = buffer;

    while(file_size) {
        /* skip leading white characters on each line */
        SKIP_WHITE_CHARS(file_size, ptr);
        /* nothing meaningful in the file, break */
        if (!file_size)
            break;
        /* looking for EMM */
        if (file_size < 3 || toupper(ptr[0]) != 'E' ||
            toupper(ptr[1]) != 'M' || toupper(ptr[2]) != 'M')
        {
            /* we don't want this line, skip it by looking for the first EOL
             * char in the line
             */
            do {
                file_size--;
                ptr++;
            } while(file_size && !IS_EOL_CHAR(*ptr));

            /* either there are nothing left in the file  or we have EOL
             * char(s) in the line, loop through to skip all consecutive
             * EOL char(s)
             */
            while(file_size && IS_EOL_CHAR(*ptr)) {
                file_size--;
                ptr++;
            }
        }
        else {
            /* got "EMM", looking for '=' */
            file_size -= 3;
            ptr += 3;
            SKIP_WHITE_CHARS(file_size, ptr);
            if (!file_size || *ptr != '=')
                parsing_error = TRUE;
            else {
                file_size--;
                ptr++;
                SKIP_WHITE_CHARS(file_size, ptr);
                /* "EMM=" is a valid EMM command line */
            }
            break;
        }
    }
    /* we have three possibilities here:
     * (1). we found pasring error while we were looking for "EMM="
     * (2). no "EMM=" line was found
     * (3). "EMM=" was found and ptr points to the first nonwhite
     *      char after '='.
     */
    while (file_size && !parsing_error && !IS_EOL_CHAR(*ptr)) {
        SKIP_WHITE_CHARS(file_size, ptr);
        switch (*ptr) {
            case 'a':
            case 'A':

                /* no white chars allowed between 'a' and its
                 * parameter
                 */
                if (!(--file_size) || *(++ptr) != '='){
                    parsing_error = TRUE;
                    break;
                }
                file_size--;
                ptr++;
                /* about to parsing 'a=' switch, reset the preset value to 0 */
                total_altreg_sets = 0;

                while(file_size && isdigit(*ptr)) {
                    total_altreg_sets = total_altreg_sets * 10 + (*ptr - '0');
                    file_size--;
                    ptr++;
                    if (total_altreg_sets > 255) {
                        parsing_error = TRUE;
                        break;
                    }
                }
                if (!total_altreg_sets || total_altreg_sets > 255)
                    parsing_error = TRUE;
                break;

            case 'b':
            case 'B':
                /* no white chars allowed between 'b' and its
                 * parameter
                 */
                if (!(--file_size) || *(++ptr) != '='){
                    parsing_error = TRUE;
                    break;
                }
                file_size--;
                ptr++;
                base_segment = 0;
                while(file_size && isxdigit(*ptr)) {
                    base_segment = (base_segment << 4) + TOINT(*ptr);
                    file_size--;
                    ptr++;
                    if (base_segment > 0x4000) {
                        parsing_error = TRUE;
                        break;
                    }
                }
                /*  x01000 <= base_segment <= 0x4000 */

                if (base_segment >= 0x1000 && base_segment <= 0x4000)
                    /* round down the segment to  EMM_PAGE_SIZE boundary */
                    base_segment = (short)(((((ULONG)base_segment * 16) / EMM_PAGE_SIZE)
                                     * EMM_PAGE_SIZE) / 16);
                else
                    parsing_error = TRUE;
                break;

            case 'r':
            case 'R':
                if (file_size >= 3 &&
                    (ptr[1] == 'a' || ptr[1] == 'A') &&
                    (ptr[2] == 'm' || ptr[2] == 'M'))
                {
                    file_size -= 3;
                    ptr += 3;
                    ram_flag_found = TRUE;
                    break;
                }
                /* fall through if it is not RAM */

            default:
                parsing_error = TRUE;
                break;
        } /* switch */

    } /* while */

    free(buffer);
    if (parsing_error) {
        host_error(EG_BAD_EMM_LINE, ERR_QUIT, "");
        /* reset parameters because the emm command line is not reliable */
        base_segment = 0x4000;
        total_altreg_sets = 8;
        ram_flag_found = FALSE;
    }

    /* we got here if (1). no parsing error or (2). user opted to ignore
     * the parsing error
     */

    lim_data->total_altreg_sets = total_altreg_sets;

    lim_data->backfill = (640 * 1024) - (base_segment * 16);

    lim_data->base_segment = base_segment;
    lim_data->use_all_umb = !ram_flag_found;

#ifdef EMM_DEBUG
    printf("base segment=%x, backfill =%lx; altreg sets=%d\n",
           base_segment, lim_data->backfill, total_altreg_sets);
#endif

    return TRUE;
}

unsigned short get_lim_page_frames(USHORT * page_table,
                                   PLIM_CONFIG_DATA lim_data
                                   )
{

    USHORT  total_phys_pages, base_segment, i;
    BOOL reserve_umb_status;
    ULONG page_frame, size;

    /* we search for the primary EMM page frame first from 0xE0000.
     * if we can not find it there, then look for anywhere in UMB area.
     * if the primary EMM page frame is found, and RAM is not specified,
     * collect every possible page frame in the UMB.
     * if RAM has been specified, only allocate the primary page frame.
     */
    total_phys_pages = 0;
    base_segment = lim_data->base_segment;
    reserve_umb_status = FALSE;

    /* specificaly ask for 0xE0000 */
    page_frame = 0xE0000;
    /* primary page frames are always EMM_PAGE_SIZE * 4 */
    size = EMM_PAGE_SIZE * 4;
    reserve_umb_status = ReserveUMB(UMB_OWNER_EMM, (PVOID *)&page_frame, &size);
    /* if failed to find the primary page frame at 0xE0000, search for anywhere
     * available in the UMB area
     */
    if (!reserve_umb_status) {
        page_frame = 0;
        size  = 0x10000;
        reserve_umb_status = ReserveUMB(UMB_OWNER_EMM, (PVOID *)&page_frame, &size);
    }
    if (!reserve_umb_status) {
#ifdef EMM_DEBUG
        printf("couldn't find primary page frame\n");
#endif
        return FALSE;
    }
    page_table[0] = (short)(page_frame / 16);
    page_table[1] = (short)((page_frame + 1 * EMM_PAGE_SIZE) / 16);
    page_table[2] = (short)((page_frame + 2 * EMM_PAGE_SIZE) / 16);
    page_table[3] = (short)((page_frame + 3 * EMM_PAGE_SIZE) / 16);


    total_phys_pages = 4;

    /* now add back fill page frames */
    for (i = (USHORT)(lim_data->backfill / EMM_PAGE_SIZE); i != 0 ; i--) {
        page_table[total_phys_pages++] = base_segment;
        base_segment += EMM_PAGE_SIZE / 16;
    }

    /* RAM is not specified in the command line, grab every possible
     * page frame from UMB
     */
    if (lim_data->use_all_umb) {
        while (TRUE) {
            page_frame = 0;
            size = EMM_PAGE_SIZE;
            if (ReserveUMB(UMB_OWNER_EMM, (PVOID *)&page_frame, &size))
               page_table[total_phys_pages++] = (short)(page_frame / 16);
            else
                break;
        }
    }

#ifdef EMM_DEBUG
    printf("page frames:\n");
    for (i = 0; i < total_phys_pages; i++)
        printf("page number %d, segment %x\n",i, page_table[i]);
#endif
    return total_phys_pages;
}
#endif  /* LIM */


VOID SetupInstallableVDD (VOID)
{
HANDLE hVDD;
HKEY   VDDKey;
CHAR   szClass [MAX_CLASS_LEN];
DWORD  dwClassLen = MAX_CLASS_LEN;
DWORD  nKeys,cbMaxKey,cbMaxClass,nValues=0,cbMaxValueName,cbMaxValueData,dwSec;
DWORD  dwType;
PCHAR  pszName,pszValue;
FILETIME ft;
PCHAR  pKeyName = "SYSTEM\\CurrentControlSet\\Control\\VirtualDeviceDrivers";

    if (RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                       pKeyName,
                       0,
                       KEY_QUERY_VALUE,
                       &VDDKey
                     ) != ERROR_SUCCESS){
        RcErrorDialogBox(ED_REGVDD, pKeyName, NULL);
        return;
    }

    pszName = "VDD";

        // get size of VDD value
    if (RegQueryInfoKey (VDDKey,
                         (LPTSTR)szClass,
                         &dwClassLen,
                         NULL,
                         &nKeys,
                         &cbMaxKey,
                         &cbMaxClass,
                         &nValues,
                         &cbMaxValueName,
                         &cbMaxValueData,
                         &dwSec,
                         &ft
                        ) != ERROR_SUCCESS) {
        RcErrorDialogBox(ED_REGVDD, pKeyName, pszName);
        RegCloseKey (VDDKey);
        return;
    }


        // alloc temp memory for the VDD value (multi-string)
    if ((pszValue = (PCHAR) malloc (cbMaxValueData)) == NULL) {
        RcErrorDialogBox(ED_MEMORYVDD, pKeyName, pszName);
        RegCloseKey (VDDKey);
        return;
    }


         // finally get the VDD value (multi-string)
    if (RegQueryValueEx (VDDKey,
                         (LPTSTR)pszName,
                         NULL,
                         &dwType,
                         (LPBYTE)pszValue,
                         &cbMaxValueData
                        ) != ERROR_SUCCESS || dwType != REG_MULTI_SZ) {
        RcErrorDialogBox(ED_REGVDD, pKeyName, pszName);
        RegCloseKey (VDDKey);
        free (pszValue);
        return;
    }

    pszName = pszValue;

    while (*pszValue) {
        if ((hVDD = SafeLoadLibrary(pszValue)) == NULL){
            RcErrorDialogBox(ED_LOADVDD, pszValue, NULL);
        }
        pszValue =(PCHAR)strchr (pszValue,'\0') + 1;
    }

    RegCloseKey (VDDKey);
    free (pszName);
    return;
}

/*** VDDInstallMemoryHook - This service is provided for VDDs to hook the
 *                          Memory Mapped IO addresses they are resposible
 *                          for.
 *
 * INPUT:
 *      hVDD    : VDD Handle
 *      addr    : Starting linear address
 *      count   : Number of bytes
 *      MemoryHandler : VDD handler for the memory addresses
 *
 *
 * OUTPUT
 *      SUCCESS : Returns TRUE
 *      FAILURE : Returns FALSE
 *                GetLastError has the extended error information.
 *
 * NOTES
 *      1. The first one to hook an address will get the control. There
 *         is no concept of chaining the hooks. VDD should grab the
 *         memory range in its initialization routine. After all
 *         the VDDs are loaded, EMM will eat up all the remaining
 *         memory ranges for UMB support.
 *
 *      2. Memory handler will be called with the address on which the
 *         page fault occured. It wont say whether it was a read operation
 *         or write operation or what were the operand value. If a VDD
 *         is interested in such information it has to get the CS:IP and
 *         decode the instruction.
 *
 *      3. On returning from the hook handler it will be assumed that
 *         the page fault was handled and the return will go back to the
 *         VDM.
 *
 *      4. Installing a hook on a memory range will result in the
 *         consumption of memory based upon page boundaries. The Starting
 *         address is rounded down, and the count is rounded up to the
 *         next page boundary. The VDD's memory hook handler will be
 *         invoked for all addreses within the page(s) hooked. The page(s)
 *         will be set aside as mapped reserved sections, and will no
 *         longer be available for use by NTVDM or other VDDs. The VDD is
 *         permitted to manipulate the memory (commit, free, etc) as needed.
 *
 *      5. After calling the MemoryHandler, NTVDM will return to the
 *         faulting cs:ip in the 16bit app. If the VDD does'nt want
 *         that to happen it should adjust cs:ip appropriatly by using
 *         setCS and setIP.
 */

BOOL VDDInstallMemoryHook (
     HANDLE hVDD,
     PVOID pStart,
     DWORD count,
     PVDD_MEMORY_HANDLER MemoryHandler
    )
{
PMEM_HOOK_DATA pmh = MemHookHead,pmhNew,pmhLast=NULL;

    DWORD dwStart;


    if (count == 0 || pStart == (PVOID)NULL || count > 0x20000) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
       // round addr down to next page boundary
       // round count up to next page boundary
    dwStart = (DWORD)pStart & ~(HOST_PAGE_SIZE-1);
    count  += (DWORD)pStart - dwStart;
    count   = (count + HOST_PAGE_SIZE - 1) & ~(HOST_PAGE_SIZE-1);

    if (dwStart < 0xC0000) {
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
        }

    while (pmh) {
        // the requested block can never be overlapped with any other
        // existing blocks
        if(dwStart >= pmh->StartAddr + pmh->Count ||
           dwStart + count <= pmh->StartAddr){
            pmhLast = pmh;
            pmh = pmh->next;
            continue;
        }

        // failure case
        SetLastError (ERROR_ACCESS_DENIED);
        return FALSE;
    }
    if ((pmhNew = (PMEM_HOOK_DATA) malloc (sizeof(MEM_HOOK_DATA))) == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
    // the request block is not overlapped with existing blocks,
    // request the UMB managing function to allocate the block
    if (!ReserveUMB(UMB_OWNER_VDD, (PVOID *)&dwStart, &count)) {
        free(pmhNew);
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }
    // now set up  the new node to get to know it
    pmhNew->Count = count;
    pmhNew->StartAddr = dwStart;
    pmhNew->hvdd = hVDD;
    pmhNew->MemHandler = MemoryHandler;
    pmhNew->next = NULL;

    // Check if the record is to be added in the begining
    if (MemHookHead == NULL || pmhLast == NULL) {
        MemHookHead = pmhNew;
        return TRUE;
    }

    pmhLast->next = pmhNew;
    return TRUE;
}

/*** VDDDeInstallMemoryHook - This service is provided for VDDs to unhook the
 *                            Memory Mapped IO addresses.
 *
 * INPUT:
 *      hVDD    : VDD Handle
 *      addr    : Starting linear address
 *      count   : Number of addresses
 *
 * OUTPUT
 *      None
 *
 * NOTES
 *      1. On Deinstalling a hook, the memory range becomes invalid.
 *         VDM's access of this memory range will cause a page fault.
 *
 */

BOOL VDDDeInstallMemoryHook (
     HANDLE hVDD,
     PVOID pStart,
     DWORD count
    )
{
PMEM_HOOK_DATA pmh = MemHookHead,pmhLast=NULL;

    DWORD dwStart;

    if (count == 0 || pStart == (PVOID)NULL || count > 0x20000) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

       // round addr down to next page boundary
       // round count up to next page boundary
    dwStart = (DWORD)pStart & ~(HOST_PAGE_SIZE-1);
    count  += (DWORD)pStart - dwStart;
    count   = (count + HOST_PAGE_SIZE - 1) & ~(HOST_PAGE_SIZE-1);
    while (pmh) {
        if (pmh->hvdd == hVDD &&
            pmh->StartAddr == dwStart &&
            pmh->Count == count ) {
            if (pmhLast)
                pmhLast->next = pmh->next;
            else
                MemHookHead = pmh->next;

            // free the UMB for other purpose.
            // Note that VDDs may have committed memory for their memory
            // hook and forgot to decommit the memory before calling
            // this function. If that is the case, the ReleaseUMB will take
            // care of this. It is because we want to maintain a single
            // version of VDD support routines while move platform depedend
            // routines into the other module.
            if (ReleaseUMB(UMB_OWNER_VDD,(PVOID)dwStart, count)) {
               // free the node.
               free(pmh);
               return TRUE;
            }
            else {
                printf("Failed to release VDD memory\n");
            }
        }
        pmhLast = pmh;
        pmh = pmh->next;
    }
    SetLastError (ERROR_INVALID_PARAMETER);
    return FALSE;
}



BOOL
VDDAllocMem(
HANDLE  hVDD,
PVOID   pStart,
DWORD   count
)
{
    PMEM_HOOK_DATA  pmh = MemHookHead;
    DWORD dwStart;

    if (count == 0 || pStart == (PVOID)NULL || count > 0x20000) {
        SetLastError(ERROR_INVALID_ADDRESS);
        return FALSE;
    }
    // round addr down to next page boundary
    // round count up to next page boundary
    dwStart = (DWORD)pStart & ~(HOST_PAGE_SIZE-1);
    count  += (DWORD)pStart - dwStart;
    count   = (count + HOST_PAGE_SIZE - 1) & ~(HOST_PAGE_SIZE-1);

    while(pmh) {
        if (pmh->hvdd == hVDD &&
            pmh->StartAddr <= dwStart &&
            pmh->StartAddr + pmh->Count >= dwStart + count)
            return(VDDCommitUMB((PVOID)dwStart, count));
        pmh = pmh->next;
    }
    SetLastError(ERROR_INVALID_ADDRESS);
    return FALSE;
}


BOOL
VDDFreeMem(
HANDLE  hVDD,
PVOID   pStart,
DWORD   count
)
{
    PMEM_HOOK_DATA  pmh = MemHookHead;
    DWORD dwStart;


    if (count == 0 || pStart == (PVOID)NULL || count > 0x20000) {
        SetLastError(ERROR_INVALID_ADDRESS);
        return FALSE;
    }
    // round addr down to next page boundary
    // round count up to next page boundary
    dwStart = (DWORD)pStart & ~(HOST_PAGE_SIZE-1);
    count  += (DWORD)pStart - dwStart;
    count   = (count + HOST_PAGE_SIZE - 1) & ~(HOST_PAGE_SIZE-1);

    while(pmh) {
        if (pmh->hvdd == hVDD &&
            pmh->StartAddr <= dwStart &&
            pmh->StartAddr + pmh->Count >= dwStart + count)
            return(VDDDeCommitUMB((PVOID)dwStart, count));
        pmh = pmh->next;
    }
    SetLastError(ERROR_INVALID_ADDRESS);
    return FALSE;
}


        // Will publish the following two functions someday.
        // Please change ntvdm.def, nt_vdd.h and nt_umb.c
        // if you remove the #if 0
BOOL
VDDIncludeMem(
HANDLE  hVDD,
PVOID   pStart,
DWORD   count
)
{
    DWORD   dwStart;

    if (count == 0 || pStart == NULL){
        SetLastError(ERROR_INVALID_ADDRESS);
        return FALSE;
    }
       // round addr down to next page boundary
       // round count up to next page boundary
    dwStart = (DWORD)pStart & ~(HOST_PAGE_SIZE-1);
    count  += (DWORD)pStart - dwStart;
    count   = (count + HOST_PAGE_SIZE - 1) & ~(HOST_PAGE_SIZE-1);
    return(ReserveUMB(UMB_OWNER_NONE, (PVOID *) &dwStart, &count));
}

BOOL
VDDExcludeMem(
HANDLE  hVDD,
PVOID   pStart,
DWORD   count
)
{

    DWORD dwStart;

    if (count == 0 || pStart == NULL) {
        SetLastError(ERROR_INVALID_ADDRESS);
        return FALSE;
    }
       // round addr down to next page boundary
       // round count up to next page boundary
    dwStart = (DWORD)pStart & ~(HOST_PAGE_SIZE-1);
    count  += (DWORD)pStart - dwStart;
    count   = (count + HOST_PAGE_SIZE - 1) & ~(HOST_PAGE_SIZE-1);
    return(ReserveUMB(UMB_OWNER_ROM, (PVOID *) &dwStart, &count));
}



VOID
VDDTerminateVDM()
{
    TerminateVDM();
}

VOID DispatchPageFault (
     ULONG FaultAddr,
     ULONG RWMode
     )
{
PMEM_HOOK_DATA pmh = MemHookHead;

    // dispatch intel linear address always
    FaultAddr -= (ULONG)Sim32GetVDMPointer(0, 0, FALSE);
    // Find the VDD and its handler which is to be called for this fault
    while (pmh) {
        if (pmh->StartAddr <= FaultAddr &&
            FaultAddr <= (pmh->StartAddr + pmh->Count)) {

            // Call the VDD's memory hook handler
            (*pmh->MemHandler) ((PVOID)FaultAddr, RWMode);
            return;
        }
        else {
            pmh = pmh->next;
            continue;
        }
    }

    // A page fault occured on an address for which we could'nt find a
    // VDD. Raise the exception.
    RaiseException ((DWORD)STATUS_ACCESS_VIOLATION,
                    EXCEPTION_NONCONTINUABLE,
                    0,
                    NULL);

}


/**
 *
 * Input - TRUE  means redirection is effective
 *         FALSE means no redirection
 *
 * This routine will get called after every GetNextVDMCommand i.e.
 * on every DOS app that a user runs from the prompt. I think
 * you can safely ignore this callout for WOW.
 *
 **/
void nt_std_handle_notification (BOOL fIsRedirection)
{
    /*
    ** Set global so we know when redirection is active.
    */

    stdoutRedirected = fIsRedirection;

#ifdef X86GFX

    if( !fIsRedirection && sc.ScreenState==FULLSCREEN )
    {
        half_word mode = 3,
                  lines = 0;

        //
        // WORD 6 and other apps cause this code path to be followed
        // on application startup. now if line==0, SelectMouseBuffer
        // causes a 640 x 200 buffer to be selected. This is not
        // correct if the app is in a 43 or 50 text line mode.
        // Therefore, since the BIOS data area location 40:84 holds
        // the number of rows - 1 at this point (if the app uses int 10h
        // function 11 to change mode) then pick up the correct value
        // from here. Andy!

        if(sc.ModeType == TEXT)
        {
           sas_load(0x484,&lines);

           //
           // The value is pulled from the BIOS data area.
           // This is one less than the number of rows. So
           // increment to give SelectMouseBuffer what it
           // expects. Let this function do the necessary
           // handling of non 25, 43 and 50 values.
           //

           lines++;
        }

        SelectMouseBuffer(mode, lines);
    }
#endif //X86GFX
}

/*** VDDInstallUserHook
 *
 *  This service is provided for VDDs to hook callback events.
 *  These callback events include, PDB (DOS Process) creation, PDB
 *  termination, VDM block and VDM resume. Whenever DOS creates (
 *  for example int21/exec) or terminates (for example int21/exit)
 *  a 16bit process VDD could get a notification for that. A VDM in
 *  which a DOS app runs, is attached to the console window in which
 *  the DOS app is running. VDM gets created when first DOS binary
 *  runs in that console. When that DOS binary terminates, VDM stays
 *  with the console window and waits for the next DOS binary to be
 *  launched. When VDM is waiting for this next DOS binary all its
 *  components including VDDs should block. For this purpose, VDDs
 *  could hook VDM Block and Resume events. On Block event VDDs
 *  should block all their worker threads and cleanup any other
 *  operation they might have started. On resume they can restart
 *  worker threads.
 *
 *    INPUT:
 *      hVDD    :        VDD Handle
 *      Ucr_handler:     handle on creating function    (OPTIONAL)
 *          Entry - 16bit DOS PDB
 *          EXIT  - None
 *      Uterm_handler:   handle on terminating function (OPTIONAL)
 *          Entry - 16bit DOS PDB
 *          EXIT  - None
 *      Ublock_handler:  handle on block (of ntvdm) function (OPTIONAL)
 *          Entry - None
 *          EXIT  - None
 *      Uresume_handler: handle on resume (of ntvdm) function (OPTIONAL)
 *          Entry - None
 *          EXIT  - None
 *
 *    OUTPUT
 *      SUCCESS : Returns TRUE
 *      FAILURE : Returns FALSE
 *                GetLastError has the extended error information.
 *
 *    NOTES:
 *      If hvdd in not valid it will return ERROR_INVALID_PARAMETER.
 *      VDD can provide whatever event hook they may choose. Not providing
 *      any handler has no effect. There are lots of requests in DOS world
 *      for which there is no explicit Close operation. For instance
 *      printing via int17h. A VDD supporting printing will never be able to
 *      detect when to flush the int17 characters, if its spolling them.
 *      But with the help of PDB create/terminate the VDD can achieve it.
 */

BOOL VDDInstallUserHook (
     HANDLE             hVDD,
     PFNVDD_UCREATE     Ucr_Handler,
     PFNVDD_UTERMINATE  Uterm_Handler,
     PFNVDD_UBLOCK      Ublock_handler,
     PFNVDD_URESUME     Uresume_handler
)
{
    PVDD_USER_HANDLERS puh = UserHookHead;
    PVDD_USER_HANDLERS puhNew;


    if (!hVDD)  {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((puhNew = (PVDD_USER_HANDLERS) malloc (sizeof(VDD_USER_HANDLERS))) == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    // now set up  the new node to get to know it
    puhNew->hvdd = hVDD;
    puhNew->ucr_handler = Ucr_Handler;
    puhNew->uterm_handler = Uterm_Handler;
    puhNew->ublock_handler = Ublock_handler;
    puhNew->uresume_handler = Uresume_handler;

    // Check if the record is to be added in the begining
    if (UserHookHead == NULL) {
        puhNew->next = NULL;
        UserHookHead = puhNew;
        return TRUE;
    }

    puhNew->next = UserHookHead;
    UserHookHead = puhNew;
    return TRUE;
}

/*** VDDDeInstallUserHook
 *
 *   This service is provided for VDDs to unhook callback events.
 *
 *    INPUT:
 *      hVDD    : VDD Handle
 *
 *    OUTPUT
 *      SUCCESS : Returns TRUE
 *      FAILURE : Returns FALSE
 *                GetLastError has the extended error information.
 *
 *    NOTES
 *      This service will deinstall all the events hooked earlier
 *      using VDDInstallUserHook.
 */

BOOL VDDDeInstallUserHook (
     HANDLE hVDD)
{

    PVDD_USER_HANDLERS puh = UserHookHead;
    PVDD_USER_HANDLERS puhLast = NULL;


    if (!hVDD) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    while (puh) {
        if (puh->hvdd == hVDD) {

            if (puhLast)
                puhLast->next = puh->next;
            else
                UserHookHead = puh->next;

            free(puh);
            return TRUE;
        }
        puhLast = puh;
        puh = puh->next;
    }

    SetLastError (ERROR_INVALID_PARAMETER);
    return FALSE;
}

/*** VDDTerminateUserHook - This service is provided for VDDs to hook
 *                            for callback services
 *
 * INPUT:
 *      USHORT DosPDB
 *
 * OUTPUT
 *      None
 *
 */

VOID VDDTerminateUserHook(USHORT DosPDB)
{

    PVDD_USER_HANDLERS puh = UserHookHead;

    while(puh) {
        if(puh->uterm_handler)
            (puh->uterm_handler)(DosPDB);
        puh = puh->next;
    }
    return;
}

/*** VDDCreateUserHook - This service is provided for VDDs to hook
 *                            for callback services
 *
 * INPUT:
 *      USHORT DosPDB
 *
 * OUTPUT
 *      None
 *
 */

VOID VDDCreateUserHook(USHORT DosPDB)
{

    PVDD_USER_HANDLERS puh = UserHookHead;

    while(puh) {
        if(puh->ucr_handler)
            (puh->ucr_handler)(DosPDB);
        puh = puh->next;
    }
    return;
}

/*** VDDBlockUserHook - This service is provided for VDDs to hook
 *                            for callback services
 *
 * INPUT:
 *      None
 *
 * OUTPUT
 *      None
 *
 */

VOID VDDBlockUserHook(VOID)
{

    PVDD_USER_HANDLERS puh = UserHookHead;

    while(puh) {
        if(puh->ublock_handler)
            (puh->ublock_handler)();
        puh = puh->next;
    }
    return;
}

/*** VDDResumeUserHook - This service is provided for VDDs to hook
 *                            for callback services
 *
 * INPUT:
 *      None
 *
 * OUTPUT
 *      None
 *
 */

VOID VDDResumeUserHook(VOID)
{

    PVDD_USER_HANDLERS puh = UserHookHead;

    while(puh) {
        if(puh->uresume_handler)
            (puh->uresume_handler)();
        puh = puh->next;
    }
    return;
}

/*** VDDSimulate16
 *
 *   This service causes the simulation of intel instructions to start.
 *
 *   INPUT
 *      None
 *
 *   OUTPUT
 *      None
 *
 *   NOTES
 *      This service is similar to VDDSimulateInterrupt except that
 *      it does'nt require a hardware interrupt to be supported by the
 *      16bit stub device driver. This service allows VDD to execute
 *      a routine in its 16bit driver and come back when its done, kind
 *      of a far call. Before calling VDDSimulate16, VDD should preserve
 *      all the 16bit registers which its routine might destroy. Minimally
 *      it should at least preserve cs and ip. Then it should set the
 *      cs and ip for the 16bit routine. VDD could also use registers
 *      like ax,bx.. to pass parametrs to its 16bit routines. At the
 *      end of the 16bit routine VDDUnSimulate16 macro should be used
 *      which will send the control back to the VDD just after the
 *      call VDDSimulate16. Note very carefully that this simulation
 *      to 16bit is synchronous, i.e. VDD gets blocked in VDDSimulate16
 *      and only comes back when stub-driver does a VDDUnSimulate16.
 *      Here is an example:
 *
 *      vdd:
 *          SaveCS = getCS();
 *          SaveIP = getIP();
 *          SaveAX = getAX();
 *          setCS (16BitRoutineCS);
 *          setIP (16BitRoutineIP);
 *          setAX (DO_X_OPERATION);
 *          VDDSimulate16 ();
 *          setCS (SavwCS);
 *          setIP (SaveIP);
 *          setAX (SaveAX);
 *          ..
 *          ..
 *
 *      Stub Driver: (Initialization part)
 *
 *          RegisterModule              ; Loads VDD
 *          push cs
 *          pop  ax
 *          mov  bx, offset Simulate16
 *          DispatchCall                ; Passes the address of worker
 *                                      ; routine to VDD in ax:bx.
 *
 *      Stub Driver (Run Time)
 *
 *      Simulate16:
 *          ..
 *          ..                          ; do the operation index passed in ax
 *
 *          VDDUnSimulate16
 *
 */

VOID VDDSimulate16(VOID)
{
     cpu_simulate();
}

VOID HostTerminatePDB(USHORT PDB)
{
    FloppyTerminatePDB(PDB);
    FdiskTerminatePDB(PDB);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_munge.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Win32 mungeing routines.
 *
 * Description	: This module contains the functions required to produce
 *		  destination compatible pixel patterns from SoftPC video
 *		  memory.
 *
 * Author	: Jerry Sexton (based on X_munge.c)
 *
 * Notes	:
 *
 */

#include <windows.h>
#include "insignia.h"
#include "host_def.h"

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "egagraph.h"
#include <conapi.h>
#include "nt_graph.h"

/*(
========================= ega_colour_hi_munge =============================

PURPOSE:	Munge interleaved EGA plane data to bitmap form using lookup tables.
INPUT:		(unsigned char *) plane0_ptr - ptr to plane0 data
		(int) width - # of groups of 4 bytes on the line
		(unsigned int *) dest_ptr - ptr to output buffer
		(unsigned int *) lut0_ptr - munging luts
		(int) height - # of scanlines to output (1 or 2)
		(int) line_offset - distance to next scanline
OUTPUT:		A nice bitmap in dest_ptr

===========================================================================
)*/

GLOBAL	VOID
ega_colour_hi_munge(unsigned char *plane0_ptr, int width,
		    unsigned int *dest_ptr, unsigned int *lut0_ptr,
		    int height, int line_offset)
{
	unsigned int	*lut1_ptr = lut0_ptr + LUT_OFFSET;
	unsigned int	*lut2_ptr = lut1_ptr + LUT_OFFSET;
	unsigned int	*lut3_ptr = lut2_ptr + LUT_OFFSET;
	FAST unsigned int	hi_res;
	FAST unsigned int	lo_res;
	FAST unsigned int	*l_ptr;
	FAST half_word		*data;

	/* make sure we get the line offset in ints not bytes */
	line_offset /= sizeof(int);
	data = (half_word *) plane0_ptr;

	/* convert each input byte in turn */
	if (get_plane_mask() == 0xf) /* all planes enabled */
	{
	    for ( ; width > 0; width--)
	    {
		/* Get 8 bytes (2 longs) of output data from 1 byte of plane 0
		** data
		*/

		l_ptr = &lut0_ptr [*data++ << 1];
		hi_res = *l_ptr++;
		lo_res = *l_ptr;

		/* Or in the output data from plane 1 */
		l_ptr = &lut1_ptr [*data++ << 1];
		hi_res |= *l_ptr++;
		lo_res |= *l_ptr;

		/* Or in the output data from plane 2 */
		l_ptr = &lut2_ptr [*data++ << 1];
		hi_res |= *l_ptr++;
		lo_res |= *l_ptr;

		/* Or in the output data from plane 3 */
		l_ptr = &lut3_ptr [*data++ << 1];
		hi_res |= *l_ptr++;
		lo_res |= *l_ptr;

		/* Output the data to the buffer */
		if (height == 2)
		{
			/* scanline doubling */
			*(dest_ptr + line_offset) = hi_res;
			*dest_ptr++ = hi_res;
			*(dest_ptr + line_offset) = lo_res;
			*dest_ptr++ = lo_res;
		}
		else
		{
			/* not scanline doubling */
			*dest_ptr++ = hi_res;
			*dest_ptr++ = lo_res;
		}
	    }
	}
	else
	{
	    for ( ; width > 0; width--)
	    {
		/* Get 8 bytes (2 longs) of output data from 1 byte of plane 0
		** data
		*/

		if (get_plane_mask() & 1)
		{
		    l_ptr = &lut0_ptr [*data++ << 1];
		    hi_res = *l_ptr++;
		    lo_res = *l_ptr;
		}
		else
		{
		    hi_res = 0;
		    lo_res = 0;
		    data++;
		}

		/* Conditionally Or in the output data from plane 1 */
		if (get_plane_mask() & 2)
		{
		    l_ptr = &lut1_ptr [*data++ << 1];
		    hi_res |= *l_ptr++;
		    lo_res |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Conditionally Or in the output data from plane 2 */
		if (get_plane_mask() & 4)
		{
		    l_ptr = &lut2_ptr [*data++ << 1];
		    hi_res |= *l_ptr++;
		    lo_res |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Conditionally Or in the output data from plane 3 */
		if (get_plane_mask() & 8)
		{
		    l_ptr = &lut3_ptr [*data++ << 1];
		    hi_res |= *l_ptr++;
		    lo_res |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Output the data to the buffer */
		if (height == 2)
		{
			/* scanline doubling */
			*(dest_ptr + line_offset) = hi_res;
			*dest_ptr++ = hi_res;
			*(dest_ptr + line_offset) = lo_res;
			*dest_ptr++ = lo_res;
		}
		else
		{
			/* not scanline doubling */
			*dest_ptr++ = hi_res;
			*dest_ptr++ = lo_res;
		}
	    }
	}
}	/* ega_colour_hi_munge */

#ifdef	BIGWIN
/*(
========================= ega_colour_hi_munge_big ===========================

PURPOSE:	Munge interleaved EGA plane data to bitmap data for big windows.
INPUT:		(unsigned char *) plane0_ptr - ptr to EGA plane 0 data
		(int) width - number of bytes to convert
		(unsigned int *) dest_ptr - output buffer ptr
		(unsigned int *) lut0_ptr - ptr to luts
		(int) height - # of scanlines to output (1 or 3)
		(int) line_offset - distance to next scanline
OUTPUT:		A nice bitmap in the output buffer

=============================================================================
)*/

GLOBAL	VOID
ega_colour_hi_munge_big(unsigned char *plane0_ptr, int width,
			unsigned int *dest_ptr, unsigned int *lut0_ptr,
			int height, int line_offset)
{
	unsigned int	*lut1_ptr = lut0_ptr + BIG_LUT_OFFSET;
	unsigned int	*lut2_ptr = lut1_ptr + BIG_LUT_OFFSET;
	unsigned int	*lut3_ptr = lut2_ptr + BIG_LUT_OFFSET;
	FAST unsigned int	hi_res;
	FAST unsigned int	med_res;
	FAST unsigned int	lo_res;
	FAST unsigned int	*l_ptr;
	FAST half_word		*data;

	/* make sure we get the line offset in ints not bytes */
	line_offset /= sizeof(int);
	data = (half_word *) plane0_ptr;

	if (get_plane_mask() == 0xf)
	{
	    for ( ; width > 0; width--)
	    {
		/* From one byte of input data in plane 0, get 12 bytes
		** of output data.
		*/

		l_ptr = &lut0_ptr [*data++ * 3];
		hi_res = *l_ptr++;
		med_res = *l_ptr++;
		lo_res = *l_ptr;

		/* Or in the stuff from plane 1 */
		l_ptr = &lut1_ptr [*data++ * 3];
		hi_res |= *l_ptr++;
		med_res |= *l_ptr++;
		lo_res |= *l_ptr;

		/* Or in the stuff from plane 2 */
		l_ptr = &lut2_ptr [*data++ * 3];
		hi_res |= *l_ptr++;
		med_res |= *l_ptr++;
		lo_res |= *l_ptr;

		/* Or in the stuff from plane 3 */
		l_ptr = &lut3_ptr [*data++ * 3];
		hi_res |= *l_ptr++;
		med_res |= *l_ptr++;
		lo_res |= *l_ptr;

		/* Output the munged data */
		if (height == 3)
		{
			/* triple the scanlines */
			*(dest_ptr + 2*line_offset) = hi_res;
			*(dest_ptr + line_offset) = hi_res;
			*dest_ptr++ = hi_res;
			*(dest_ptr + 2*line_offset) = med_res;
			*(dest_ptr + line_offset) = med_res;
			*dest_ptr++ = med_res;
			*(dest_ptr + 2*line_offset) = lo_res;
			*(dest_ptr + line_offset) = lo_res;
			*dest_ptr++ = lo_res;
		}
		else
		{
			/* just one scanline */
			*dest_ptr++ = hi_res;
			*dest_ptr++ = med_res;
			*dest_ptr++ = lo_res;
		}
	    }
	}
	else
	{
	    for ( ; width > 0; width--)
	    {
		/* From one byte of input data in plane 0, get 12 bytes
		** of output data.
		*/

		if (get_plane_mask() & 1)
		{
		    l_ptr = &lut0_ptr [*data++ * 3];
		    hi_res = *l_ptr++;
		    med_res = *l_ptr++;
		    lo_res = *l_ptr;
		}
		else
		{
		    data++;
		    hi_res = 0;
		    med_res = 0;
		    lo_res = 0;
		}

		/* Or in the stuff from plane 1 */
		if (get_plane_mask() & 2)
		{
		    l_ptr = &lut1_ptr [*data++ * 3];
		    hi_res |= *l_ptr++;
		    med_res |= *l_ptr++;
		    lo_res |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Or in the stuff from plane 2 */
		if (get_plane_mask() & 4)
		{
		    l_ptr = &lut2_ptr [*data++ * 3];
		    hi_res |= *l_ptr++;
		    med_res |= *l_ptr++;
		    lo_res |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Or in the stuff from plane 3 */
		if (get_plane_mask() & 8)
		{
		    l_ptr = &lut3_ptr [*data++ * 3];
		    hi_res |= *l_ptr++;
		    med_res |= *l_ptr++;
		    lo_res |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Output the munged data */
		    if (height == 3)
		    {
			/* triple the scanlines */
			*(dest_ptr + 2*line_offset) = hi_res;
			*(dest_ptr + line_offset) = hi_res;
			*dest_ptr++ = hi_res;
			*(dest_ptr + 2*line_offset) = med_res;
			*(dest_ptr + line_offset) = med_res;
			*dest_ptr++ = med_res;
			*(dest_ptr + 2*line_offset) = lo_res;
			*(dest_ptr + line_offset) = lo_res;
			*dest_ptr++ = lo_res;
		    }
		    else
		    {
			/* just one scanline */
			*dest_ptr++ = hi_res;
			*dest_ptr++ = med_res;
			*dest_ptr++ = lo_res;
		    }
	    }
	}
}	/* ega_colour_hi_munge_big */

/*(
========================= ega_colour_hi_munge_huge ========================

PURPOSE:	Munge interleaved EGA plane data to bitmap form using lookup tables.
INPUT:		(unsigned char *) plane0_ptr - ptr to plane0 data
		(int) width - # of bytes on the line
		(unsigned int *) dest_ptr - ptr to output buffer
		(unsigned int *) lut0_ptr - munging luts
		(int) height - # of scanlines to output (1 or 2)
		(int) line_offset - distance to next scanline
OUTPUT:		A nice X image in dest_ptr

===========================================================================
)*/

GLOBAL	VOID
ega_colour_hi_munge_huge(unsigned char *plane0_ptr, int width,
			 unsigned int *dest_ptr, unsigned int *lut0_ptr,
			 int height, int line_offset)
{
	unsigned int	*lut1_ptr = lut0_ptr + HUGE_LUT_OFFSET;
	unsigned int	*lut2_ptr = lut1_ptr + HUGE_LUT_OFFSET;
	unsigned int	*lut3_ptr = lut2_ptr + HUGE_LUT_OFFSET;
	FAST unsigned int	res4;
	FAST unsigned int	res3;
	FAST unsigned int	res2;
	FAST unsigned int	res1;
	FAST unsigned int	*l_ptr;
	FAST half_word		*data;

	/* make sure we get the line offset in ints not bytes */
	line_offset /= sizeof(int);
	data = (half_word *) plane0_ptr;

	/* convert each input byte in turn */
	if (get_plane_mask() == 0xf)
	{
	    for ( ; width > 0; width--)
	    {
		/* Get 16 bytes of output data from 1 byte of plane 0
		** data
		*/

		l_ptr = &lut0_ptr [*data++ << 2];
		res4 = *l_ptr++;
		res3 = *l_ptr++;
		res2 = *l_ptr++;
		res1 = *l_ptr;

		/* Or in the output data from plane 1 */
		l_ptr = &lut1_ptr [*data++ << 2];
		res4 |= *l_ptr++;
		res3 |= *l_ptr++;
		res2 |= *l_ptr++;
		res1 |= *l_ptr;

		/* Or in the output data from plane 2 */
		l_ptr = &lut2_ptr [*data++ << 2];
		res4 |= *l_ptr++;
		res3 |= *l_ptr++;
		res2 |= *l_ptr++;
		res1 |= *l_ptr;

		/* Or in the output data from plane 3 */
		l_ptr = &lut3_ptr [*data++ << 2];
		res4 |= *l_ptr++;
		res3 |= *l_ptr++;
		res2 |= *l_ptr++;
		res1 |= *l_ptr;

		/* Output the data to the buffer */
		if (height == 4)
		{
			/* scanline doubling */
			*(dest_ptr + 3*line_offset) = res4;
			*(dest_ptr + 2*line_offset) = res4;
			*(dest_ptr + line_offset) = res4;
			*dest_ptr++ = res4;
			*(dest_ptr + 3*line_offset) = res3;
			*(dest_ptr + 2*line_offset) = res3;
			*(dest_ptr + line_offset) = res3;
			*dest_ptr++ = res3;
			*(dest_ptr + 3*line_offset) = res2;
			*(dest_ptr + 2*line_offset) = res2;
			*(dest_ptr + line_offset) = res2;
			*dest_ptr++ = res2;
			*(dest_ptr + 3*line_offset) = res1;
			*(dest_ptr + 2*line_offset) = res1;
			*(dest_ptr + line_offset) = res1;
			*dest_ptr++ = res1;
		}
		else
		{
			/* not scanline doubling */
			*dest_ptr++ = res4;
			*dest_ptr++ = res3;
			*dest_ptr++ = res2;
			*dest_ptr++ = res1;
		}
	    }
	}
	else
	{
	    for ( ; width > 0; width--)
	    {
		/* Get 16 bytes of output data from 1 byte of plane 0
		** data
		*/

		if (get_plane_mask() & 1)
		{
		    l_ptr = &lut0_ptr [*data++ << 2];
		    res4 = *l_ptr++;
		    res3 = *l_ptr++;
		    res2 = *l_ptr++;
		    res1 = *l_ptr;
		}
		else
		{
		    res4 = 0;
		    res3 = 0;
		    res2 = 0;
		    res1 = 0;
		    data++;
		}

		/* Or in the output data from plane 1 */
		if (get_plane_mask() & 2)
		{
		    l_ptr = &lut1_ptr [*data++ << 2];
		    res4 |= *l_ptr++;
		    res3 |= *l_ptr++;
		    res2 |= *l_ptr++;
		    res1 |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Or in the output data from plane 2 */
		if (get_plane_mask() & 4)
		{
		    l_ptr = &lut2_ptr [*data++ << 2];
		    res4 |= *l_ptr++;
		    res3 |= *l_ptr++;
		    res2 |= *l_ptr++;
		    res1 |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Or in the output data from plane 3 */
		if (get_plane_mask() & 8)
		{
		    l_ptr = &lut3_ptr [*data++ << 2];
		    res4 |= *l_ptr++;
		    res3 |= *l_ptr++;
		    res2 |= *l_ptr++;
		    res1 |= *l_ptr;
		}
		else
		{
		    data++;
		}

		/* Output the data to the buffer */
		    if (height == 4)
		    {
			/* scanline doubling */
			*(dest_ptr + 3*line_offset) = res4;
			*(dest_ptr + 2*line_offset) = res4;
			*(dest_ptr + line_offset) = res4;
			*dest_ptr++ = res4;
			*(dest_ptr + 3*line_offset) = res3;
			*(dest_ptr + 2*line_offset) = res3;
			*(dest_ptr + line_offset) = res3;
			*dest_ptr++ = res3;
			*(dest_ptr + 3*line_offset) = res2;
			*(dest_ptr + 2*line_offset) = res2;
			*(dest_ptr + line_offset) = res2;
			*dest_ptr++ = res2;
			*(dest_ptr + 3*line_offset) = res1;
			*(dest_ptr + 2*line_offset) = res1;
			*(dest_ptr + line_offset) = res1;
			*dest_ptr++ = res1;
		    }
		    else
		    {
			/* not scanline doubling */
			*dest_ptr++ = res4;
			*dest_ptr++ = res3;
			*dest_ptr++ = res2;
			*dest_ptr++ = res1;
		    }
	    }
	}
}	/* ega_colour_hi_munge_huge */
#endif	/* BIGWIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_rez.c ===
#include "insignia.h"
#include "host_def.h"

/*                      INSIGNIA MODULE SPECIFICATION
                        -----------------------------

FILE NAME       : nt_rez.c
MODULE NAME     : nt CMOS read/write routines

        THIS PROGRAM SOURCE FILE IS SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF ITS OPERATION MAY
        ONLY BE DISCLOSED TO PERSONS EMPLOYED BY THE CUSTOMER WHO
        REQUIRE A KNOWLEDGE OF THE  SOFTWARE  CODING TO CARRY OUT
        THEIR JOB. DISCLOSURE TO ANY OTHER PERSON MUST HAVE PRIOR
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER        :
DATE            :

PURPOSE         :



The Following Routines are defined:
                1. host_read_resource
                2. host_write_resource (REMOVED FOR .NET SERVER)

=========================================================================

AMENDMENTS      :

=========================================================================
*/


#include <stdio.h>
#include <io.h>
#include <sys\types.h>
#include <fcntl.h>
#include <sys\stat.h>

#include "xt.h"
#include "error.h"
#include "spcfile.h"
#include "timer.h"


/*
 * Allow a suitable default for the CMOS file name.
 */

//#ifndef CMOS_FILE_NAME
//#define CMOS_FILE_NAME "cmos.ram"
//#endif

long host_read_resource(int type, char *name, byte *addr, int maxsize, int display_error)
/* int type;                     Unused */
/* char *name;                   Name of resource */
/* byte *addr;                   Address to read data into */
/* int maxsize;                  Max size that should be read */
/* int display_error;            Flag to control error message output */
{

        int file_fd;
        long size=0;
        char full_path[MAXPATHLEN];
        extern char *host_find_file(char *name, char *path, int disp_err);

        type = 0; // To stop unreferenced formal parameter errors

#ifdef DELTA            //STF - make change to 8.3 compatible name
        if (strcmp(name, ".spcprofile") == 0)
            name = "profile.spc";
#endif

        file_fd = _open(host_find_file (name, full_path, display_error), O_RDONLY|O_BINARY);

        if (file_fd != -1)      /* Opened successfully */       {
                /* seek to end to get size */
                size = _lseek (file_fd, 0L, 2);

                /* Check if the size is valid         */
                /* Seek back to start before reading! */

                if (size > maxsize || 0 > _lseek (file_fd, 0L, 0))  {
                    /* Don't forget to close the handle */
                    _close (file_fd);
                    return(0);
                }

                size=_read(file_fd,addr,size);
                _close(file_fd);
        }

        return (size);
}



#if 0

// The following host_write_resource has been removed for .NET SERVER.
// The function was called only for the CMOS resource for which we
// wrote our own code instead of using soft pc.

/********************************************************/

void host_write_resource(type,name,addr,size)
int type;               /* Unused */
char *name;             /* Name of resource */
byte *addr;             /* Address of data to write */
long size;              /* Quantity of data to write */
{
        int file_fd;
        char full_path[MAXPATHLEN];
        char *hff_ret;
        extern char *host_find_file(char *name, char *path, int disp_err);

        type = 0; // To stop unreferenced formal parameter errors

        host_block_timer ();

#ifdef DELTA            //STF - make change to 8.3 compatible name
        if (strcmp(name, ".spcprofile") == 0)
            name = "profile.spc";
#endif

        hff_ret = host_find_file (name,full_path,SILENT);

        if (hff_ret != NULL)
        {
                file_fd = _open (hff_ret,O_WRONLY);

                if (file_fd != -1)
                {
                        _write (file_fd, addr, size);
                        _close (file_fd);
                }
                else
                {

#ifndef HUNTER
                        host_error (EG_REZ_UPDATE,ERR_CONT,name);
#endif

                        /* Continuing => try to create a new file */
                        file_fd = _open(name,O_RDWR|O_CREAT,S_IREAD|S_IWRITE);

                        if (file_fd != -1)
                        {
                                _write (file_fd, addr, size);
                                _close (file_fd);
                        }

#ifndef HUNTER
                        else
                        {
                                /* Tell the user we cannot update */
                                host_error (EG_NO_REZ_UPDATE, ERR_CONT, CMOS_FILE_NAME);
                        }
#endif

                }
        }
        else
        {
                /* host find file has failed and we have
                 * reached this point with no error panels
                 */

#ifndef HUNTER
                host_error (EG_REZ_UPDATE,(ERR_QUIT|ERR_CONT),name);
#endif

                /* Continuing => try to create a new file */
                file_fd = _open(name,O_RDWR|O_CREAT,S_IREAD|S_IWRITE);

                if (file_fd != -1)
                {
                        _write (file_fd, addr, size);
                        _close (file_fd);
                }

#ifndef HUNTER
                else
                {
                        /* Tell the user we cannot update */
                        host_error (EG_NO_REZ_UPDATE, ERR_CONT,
                                    CMOS_FILE_NAME);
                }
#endif

        }

        host_release_timer ();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_rflop.c ===
/*
 * Name:       nt_flop.c
 * Derived From:  DEC begat M88K begat NeXT finally begat Generic.
 * Author:        Jason Proctor
 * Created On:    Nov 8 1990
 * Sccs ID:    10/13/92 @(#)nt_flop.c  1.9
 * Purpose:    nt real floppy server.
 *
 * (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 * Notes:
 *    Updated for 3.0 base by Jerry Richemont.
 *    Further updated by Ian Reid to support two floppy
 *    drives.  Support is compile time dependant on the
 *    standard SoftPC defines.
 *
 *    This implementation requires that you provide a
 * host_rflop_drive_type() function which knows what kind of drive(s)
 * your machine has; ie returns GFI_DRIVE_TYPE_xxxx.
 */

/********************************************************/

/* INCLUDES */

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntdddisk.h"
#include "windows.h"

#include "insignia.h"
#include "host_def.h"


#include <stdio.h>
#include <errno.h>
#include <sys\types.h>

#include "xt.h"
#include CpuH
#include "trace.h"
#include "error.h"
#include "fla.h"
#include "dma.h"
#include "config.h"
#include "debug.h"
#include "lock.h"
#include "timer.h"
#include "floppy.h"
#include "cmos.h"
#include "gfi.h"

#include "nt_uis.h"
#include "nt_reset.h"
#include "nt_fdisk.h"
/********************************************************/

/* DEFINES */

#ifdef min
#undef min
#endif
#define min(a,b)  (a > b ? b : a)

#define PC_MAX_DRIVE_TYPES              2
#define PC_MAX_DENSITY_TYPES            2
#define PC_MAX_FLOPPY_TYPES       (PC_MAX_DRIVE_TYPES * PC_MAX_DENSITY_TYPES)

#define PC_HEADS_PER_DISKETTE    2
#define PC_N_VALUE         2
#define PC_BYTES_PER_SECTOR      512

/* disk buffer size, in bytes */
// KEEP SYNC WITH MAX_DISKIO_SIZE defined in nt_fdisk.c
#define BS_DISK_BUFFER_SIZE      0x9000

/* double stepping factor */
#define  DOUBLE_STEP_FACTOR      1

/* density types */
#define  DENSITY_LOW       0
#define  DENSITY_HIGH         1
#define DENSITY_EXTENDED      2
#define DENSITY_UNKNOWN       100
/* motor states */
#define MOTOR_OFF       0
#define MOTOR_ON        1

#ifndef PROD
#define BREAK_ON_AND     0x01
#define BREAK_ON_OR      0x02
#define BREAK_ON_XOR     0x03

UTINY break_cylinder = 0xff;
UTINY break_head = 0xff;
UTINY break_sector = 0xff;
#endif

#ifndef PROD
DWORD rflop_dbg = 0;

#define RFLOP_READ   0x01
#define RFLOP_WRITE  0x02
#define RFLOP_FORMAT 0x04
#define RFLOP_SEEK   0x08
#define RFLOP_READID 0x10
#define RFLOP_RESET  0x20
#define RFLOP_SPECIFY   0x40
#define RFLOP_READTRACK 0x80
#define RFLOP_RECAL  0x100
#define RFLOP_SENSEDRV  0x200
#define RFLOP_RATE   0x1000
#define RFLOP_CHANGE 0x2000
#define RFLOP_DRIVE_ON  0x4000
#define RFLOP_DRIVE_OFF 0x8000
#define RFLOP_OPEN   0x10000
#define RFLOP_CLOSE  0x20000
#define RFLOP_GUESS_MEDIA 0x40000

#define RFLOP_BREAK  0x80000000

#endif

/********************************************************/

/* TYPEDEFS */

struct flop_struct
{
   int trks_per_disk;
   int secs_per_trk;
};

/*
 * This structure contains all the drive specific information.  That is
 * status which is unique to each drive, and must therefore be maintained
 * on a per drive basis.
 */
typedef struct floppy_info
{
   HANDLE      diskette_fd;

/*
 * drive_type  - the highest density format which this drive supports,
 *      e.g. GFI_DRIVE_TYPE_144, GFI_DRIVE_TYPE_288
 * flop_type   - the basic drive type, expressed as the lowest density
 *      possible for this format. For 5.25" disks this is
 *      GFI_DRIVE_TYPE_360, for 3.5" it is GFI_DRIVE_TYPE_720.
 */
   USHORT      drive_type;
   USHORT      flop_type;
   USHORT      last_seek;
   USHORT      last_head_seek;
/*
 * Change line state.
 * This is a heuristic to try to fake up the correct change line behaviour
 * without having a change line. The state of the change line is returned
 * as CHANGED unless the diskette motor has been continuously ON since the
 * last reset.
 */
   BOOLEAN     change_line_state;
   BOOLEAN     auto_locked;
   USHORT      owner_pdb;
   SHORT       motor_state;
   SHORT       media_density;
   USHORT      max_track;

   USHORT      secs_per_trk;
   USHORT      trks_per_disk;
   DWORD    align_factor;
   UTINY    idle_counter;
        UTINY           C;
   UTINY    H;
   UTINY    R;
   UTINY    N;
   char     device_name[MAX_PATH];  /* device name */
} FL, *FLP;

#define FLOPPY_IDLE_PERIOD  0xFF


/* parameter passed from main thread to FDC thread */
typedef struct _FDC_PARMS{
FDC_CMD_BLOCK  * command_block;
FDC_RESULT_BLOCK * result_block;
USHORT      owner_pdb;
BOOLEAN     auto_lock;

} FDC_PARMS, *PFDC_PARMS;


/********************************************************/


/* routines used internally */

/* routines called via vector table: all the prototypes are in gfi.h
** so everybody matches. If you want to use this file to base a
** host floppy module on, you know that all the functions that must
** be declared properly for gfi to work will be.
**                                                    GM.
 */
ULONG nt_floppy_read (UTINY drive, ULONG Offset, ULONG Size, PBYTE Buffer);
ULONG nt_floppy_write (UTINY drive, ULONG Offset, ULONG Size, PBYTE Buffer);
BOOL nt_floppy_verify (UTINY drive, ULONG Offset, ULONG Size);
MEDIA_TYPE nt_floppy_get_media_type(BYTE drive, WORD cylinders, WORD sectors, WORD heads);
BOOL nt_floppy_format (UTINY drive, WORD Cylinder, WORD Head, MEDIA_TYPE media);
BOOL nt_floppy_close (UTINY drive);
BOOL nt_floppy_media_check (UTINY drive);
BOOL dismount_drive(FLP flp);


#ifndef PROD
VOID nt_rflop_break(VOID);
#endif

void fdc_command_completed (BYTE drive, BYTE fdc_command);
void fdc_thread (PFDC_PARMS fdc_parms);

BOOL nt_gfi_rdiskette_init IPT1( UTINY, drive );
VOID nt_gfi_rdiskette_term IPT1( FLP, flp );
SHORT nt_rflop_drive_on IPT1( UTINY, drive );
SHORT nt_rflop_drive_off IPT1( UTINY, drive );
SHORT nt_rflop_change IPT1( UTINY, drive );
SHORT nt_rflop_drive_type IPT1( UTINY, drive );
SHORT nt_rflop_rate IPT2( UTINY, drive, half_word, rate);
SHORT nt_rflop_reset IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
SHORT nt_rflop_command IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res);
HANDLE nt_rdiskette_open_drive IPT1 ( UTINY, drive );
SHORT guess_media_density IPT1 (UTINY, drive);
VOID set_floppy_parms     IPT1 (FLP, flp);
BOOL dos_compatible
   IPT5 (FLP, flp, UTINY, cyl, UTINY, hd, UTINY, sec, UTINY, n);
int dos_offset
   IPT4 (FLP, flp, UTINY, cyl, UTINY, hd, UTINY, sec);
VOID update_chrn(FLP flp, UTINY mt, UTINY eot, UTINY sector_count);
HANDLE get_drive_handle (UTINY drive, USHORT pdb, BOOL auto_lock);
SHORT fdc_read_write ( FDC_CMD_BLOCK * ip, FDC_RESULT_BLOCK * res);
VOID floppy_close_down(USHORT, BOOL);
VOID HostFloppyReset(VOID);
VOID FloppyTerminatePDB(USHORT);
int  DiskOpenRetry(CHAR);

extern USHORT * pusCurrentPDB;

#ifdef EJECT_FLOPPY
GLOBAL void host_floppy_eject IFN1(UTINY, drive)
#endif


/********************************************************/

/* STATIC GLOBALS */


FL floppy_data[MAX_FLOPPY];

 struct flop_struct floppy_tksc [6] =
{
   {0, 0},     /* GFI_DRIVE_TYPE_NULL */
   {40, 9}, /* GFI_DRIVE_TYPE_360  */
   {80, 15},   /* GFI_DRIVE_TYPE_12   */
   {80, 9}, /* GFI_DRIVE_TYPE_720  */
   {80, 18},   /* GFI_DRIVE_TYPE_144  */
   {80, 36} /* GFI_DRIVE_TYPE_288  */
};
// table used to convert GFI diskette type to NT diskette type
static MEDIA_TYPE media_table[GFI_DRIVE_TYPE_MAX] = {
          Unknown,
          F5_360_512,
          F5_1Pt2_512,
          F3_720_512,
          F3_1Pt44_512,
          F3_2Pt88_512
      };

SHORT density_state;
BOOL  density_changed = TRUE;
UTINY last_drive = 0xff;
BOOL  fdc_reset = FALSE;
HANDLE   fdc_thread_handle = NULL;
extern UTINY number_of_floppy;
FDC_PARMS   fdc_parms;
ULONG floppy_open_count = 0;



/*
 * Debugging info only, for non-prod cases
 */
#ifndef PROD
 CHAR *cmd_name [] =
{
   "Invalid command (00)",    /* 00 */
   "Invalid command (01)",    /* 01 */
   "Read a Track",         /* 02 */
   "Specify",        /* 03 */
   "Sense Drive Status",      /* 04 */
   "Write Data",        /* 05 */
   "Read Data",         /* 06 */
   "Recalibrate",       /* 07 */
   "Sense Interrupt Status",  /* 08 */
   "Write Deleted Data",      /* 09 */
   "Read ID",        /* 0A */
   "Invalid Command (0B)",    /* 0B */
   "Read Deleted Data",    /* 0C */
   "Format a Track",    /* 0D */
   "Invalid Command (0E)",    /* 0E */
   "Seek",           /* 0F */
   "Invalid Command (10)",    /* 10 */
   "Scan Equal",        /* 11 */
   "Invalid Command (12)",    /* 12 */
   "Invalid Command (13)",    /* 13 */
   "Invalid Command (14)",    /* 14 */
   "Invalid Command (15)",    /* 15 */
   "Invalid Command (16)",    /* 16 */
   "Invalid Command (17)",    /* 17 */
   "Invalid Command (18)",    /* 18 */
   "Scan Low or Equal",    /* 19 */
   "Invalid Command (1A)",    /* 1A */
   "Invalid Command (1B)",    /* 1B */
   "Invalid Command (1C)",    /* 1C */
   "Scan High or Equal",      /* 1D */
   "Invalid Command (1E)",    /* 1E */
   "Invalid Command (1F)",    /* 1F */
};
#endif   /* PROD */

char  dump_buf[256];


/* the disk buffer, there is only one, even though there may be two
 * drives.  Should be O.K. as floppy disk accesses will be single
 * threaded.
 */
 UTINY *disk_buffer;

/* Report any errors in open_diskette() */
 int last_error = C_CONFIG_OP_OK;

/********************************************************/

/* GLOBAL FUNCTIONS */

/*   These functions called by config/UIF/startup now form the only
** interface between SoftPC and a floppy module. XXX_active() will
** turn the floppy emmulation in the module on by loading the global
** gfi_function_table[] with pointers to appropriate  functions
** defined in this module.
**     The floppy supported here is turned off by asking the empty floppy
** module to turn itself on in its place.
**
**     This makes a nice orthogonal interface which keeps everything save
** the three control functions   (private). The functions that are put
** in the table are defined only in gfi.h as typedefs so they are easy to
** get right.
**
**    This enabling/disabling via the gfi_function_table[] does not
** take place instead of any host ioctls/opens/closes etc that are needed
** to actually open or close the device, it forms the interface for SoftPC.
**
**    Really, this approach is a small tidy up of the way things are
** already done; existing host floppy code will require very small changes.
**
**    GM
*/

/********************************************************/

/* Turn the floppy on and off. Off means release the driver so another
** process can use it.
*/

GLOBAL SHORT
host_gfi_rdiskette_active IFN3(UTINY, hostID, BOOL, active, CHAR *, err)
{
   UTINY drive    = hostID - C_FLOPPY_A_DEVICE;
   FLP flp  = &floppy_data[drive];

   if(active)
   {
      if (!nt_gfi_rdiskette_init(drive))
      {
        /* Device is not a valid floppy */

         return( C_CONFIG_NOT_VALID );
      }
      return(C_CONFIG_OP_OK);
   }
   else
   {
#ifdef  EJECT_FLOPPY
      host_floppy_eject(drive);
#endif  /* EJECT_FLOPPY */
      nt_gfi_rdiskette_term(flp);   /*  shutdown process */
      gfi_empty_active(hostID,TRUE,err);  /* Tell gfi 'empty' is now active */
      return(C_CONFIG_OP_OK);
   }
}

/********************************************************/


/*   Validate the floppy device name passed from the config system.
** Empty string is valid; it means 'no floppy'. Otherwise return OK is
** the name is 'probably' a valid device. It cannot be opened at this
** stage because if there is no floppy in the drive, the open will fail.
**
**    GM.
*/

GLOBAL SHORT
host_gfi_rdiskette_valid IFN3(UTINY,hostID,ConfigValues *,vals,CHAR *,err)
{
#ifndef NTVDM
   UTINY           cmos_byte;
   UTINY drive    = hostID - C_FLOPPY_A_DEVICE;
   FLP flp  = &floppy_data[drive];

   if(!strcmp(vals->string,""))
      return(C_CONFIG_OP_OK);

   strcpy(flp->device_name, host_expand_environment_vars(vals->string));

   if(!host_validate_pathname(flp->device_name))
   {
      strcpy(err, host_strerror(errno));
      flp->device_name[0] = '\0';
      return( EG_MISSING_FILE );
   }
   if(!host_file_is_char_dev(flp->device_name))
   {
      flp->device_name[0] = '\0';
      return( EG_NOT_CHAR_DEV );
   }

   /* Check the CMOS RAM values */
   cmos_read_byte(CMOS_DISKETTE, &cmos_byte);
   if (drive == 0)
      cmos_byte >>= 4;

   cmos_byte &= 0xf;       /* compare nibble value only */
   flp->drive_type = host_rflop_drive_type(drive);
   if (cmos_byte != flp->drive_type)
      vals->rebootReqd = TRUE;
#endif
   return(C_CONFIG_OP_OK);
}

/********************************************************/

GLOBAL VOID
host_gfi_rdiskette_change IFN2(UTINY, hostID, BOOL, apply)
{
#ifndef NTVDM
   FLP flp = &floppy_data[hostID - C_FLOPPY_A_DEVICE];

   if (apply)
   {
      nt_gfi_rdiskette_term(flp);
   }
#endif
}

/********************************************************/

#ifdef EJECT_FLOPPY
GLOBAL void host_floppy_eject IFN1(UTINY, drive)
{
   CHAR           *ebuf;
   FLP             flp = &floppy_data[drive];
   BOOL            device_was_closed = FALSE;

   /* open the device */
   if (flp->diskette_fd == INVALID_HANDLE_VALUE)
   {
      device_was_closed = TRUE;
      (void) nt_rdiskette_open_drive(drive);
   }

   /* Do the ioctl, put your ioctl here

   if (ioctl(flp->diskette_fd, SMFDEJECT) < 0)
   {
      ebuf = host_strerror(errno);
      assert1(NO, "host_eject_floppy: %s", ebuf);
   }*/

   /* Close the device if it wasn't open */

   if (device_was_closed)
   {
      nt_gfi_rdiskette_term(flp);
   }
   else
   {
      /* Line change ONLY if device was actively open */
      flp->change_line_state = TRUE;
   }
}

#endif                          /* EJECT_FLOPPY */


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::: FLOPPY heart beat call ::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
GLOBAL void host_flpy_heart_beat(void)
{

    UTINY drive;
    FLP   flp;

    if (pFDAccess && *pFDAccess) {
   if (floppy_open_count) {
       for (drive = 0; drive < number_of_floppy; drive++) {
      flp = & floppy_data[drive];
      if (flp->diskette_fd != INVALID_HANDLE_VALUE &&
          --flp->idle_counter == 0) {
          nt_floppy_close(drive);

      }
      }

   }
   if (number_of_fdisk != 0)
       fdisk_heart_beat();
    }
}




/********************************************************/

/* initialise GFI function table */
BOOL nt_gfi_rdiskette_init IFN1(UTINY, drive)
{
   FLP flp;
   DISK_GEOMETRY  disk_geometry[20];
   ULONG media_types;
   CHAR DeviceName[] = "\\\\.\\A:";
   NTSTATUS    status;
   IO_STATUS_BLOCK io_status_block;
   FILE_ALIGNMENT_INFORMATION align_info;

   flp = &floppy_data[drive];
   flp->diskette_fd = INVALID_HANDLE_VALUE;

   DeviceName[4] += drive;
   strcpy(flp->device_name, (const char *)DeviceName);
   /*
   * Initialise the floppy on the required drive:
   *
   *      0  - Drive A,  1  - Drive B
   */

   flp->drive_type = GFI_DRIVE_TYPE_NULL;
   /* open the device */
   if ((flp->diskette_fd = nt_rdiskette_open_drive (drive)) == NULL) {
       return FALSE;
   }
   // get alignment factor
   status = NtQueryInformationFile(flp->diskette_fd,
               &io_status_block,
               &align_info,
               sizeof(FILE_ALIGNMENT_INFORMATION),
               FileAlignmentInformation
               );
   if (!NT_SUCCESS(status)) {
       nt_gfi_rdiskette_term(flp);
       return(FALSE);
   }
   flp->align_factor = align_info.AlignmentRequirement;
   if (flp->align_factor > max_align_factor)
       max_align_factor = flp->align_factor;


   // enumerate possible supported media for this drive
   // to figure out the drive type.
   status = NtDeviceIoControlFile(flp->diskette_fd,
                   NULL,
                   NULL,
                   NULL,
                   &io_status_block,
                   IOCTL_DISK_GET_MEDIA_TYPES,
                   NULL,
                   0L,
                   (PVOID)disk_geometry,
                   sizeof(disk_geometry)
                   );
    if (!NT_SUCCESS(status)) {
       nt_gfi_rdiskette_term(flp);
       return FALSE;
   }
   nt_gfi_rdiskette_term(flp);
   media_types = io_status_block.Information / sizeof(DISK_GEOMETRY);

   for (; media_types != 0; media_types--) {
      switch (disk_geometry[media_types - 1].MediaType) {
          case F5_360_512:
             if (flp->drive_type != GFI_DRIVE_TYPE_12)
            flp->drive_type = GFI_DRIVE_TYPE_360;
             break;
          case F5_1Pt2_512:
             flp->drive_type = GFI_DRIVE_TYPE_12;
             break;
          case F3_720_512:
             if (flp->drive_type != GFI_DRIVE_TYPE_144 &&
            flp->drive_type != GFI_DRIVE_TYPE_288)
            flp->drive_type = GFI_DRIVE_TYPE_720;
             break;
          case F3_1Pt44_512:
             if (flp->drive_type != GFI_DRIVE_TYPE_288)
            flp->drive_type = GFI_DRIVE_TYPE_144;
             break;
          case F3_2Pt88_512:
             flp->drive_type = GFI_DRIVE_TYPE_288;
             break;
      }
   }
   if (flp->drive_type == GFI_DRIVE_TYPE_NULL)
       return FALSE;
   /* configure its vectors here */
   gfi_function_table[drive].command_fn   = nt_rflop_command;
   gfi_function_table[drive].drive_on_fn  = nt_rflop_drive_on;
   gfi_function_table[drive].drive_off_fn = nt_rflop_drive_off;
   gfi_function_table[drive].reset_fn     = nt_rflop_reset;
   gfi_function_table[drive].high_fn      = nt_rflop_rate;
   gfi_function_table[drive].drive_type_fn= nt_rflop_drive_type;
   gfi_function_table[drive].change_fn    = nt_rflop_change;
   flp->C = flp->H = 0;
   flp->R = 1;
   flp->N = PC_N_VALUE;
   flp->auto_locked = FALSE;
   flp->owner_pdb = 0;
   return TRUE;
}

/********************************************************/

/* reset GFI function table */
/* currently drive is ignored */
VOID nt_gfi_rdiskette_term IFN1(FLP, flp)
{

   // NtOpenFile returns NULL if we can not open a handle
   // while win32 OpenFile/CreateFile returns INVALID_HANDLE_VALUE
   // if failed to open/create the file.
   if (flp->diskette_fd != NULL)
   {
//    host_clear_lock(flp->diskette_fd);
      NtClose(flp->diskette_fd);
      flp->diskette_fd = INVALID_HANDLE_VALUE;
   }
}

/********************************************************/

/* open the floppy device file */
HANDLE nt_rdiskette_open_drive IFN1(UTINY, drive)
{

    CHAR NtDeviceName[] = "\\DosDevices\\A:";
    PUNICODE_STRING Unicode;
    ANSI_STRING DeviceNameA;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES   FloppyObj;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE  fd;

    NtDeviceName[12] += drive;

    RtlInitAnsiString( &DeviceNameA, NtDeviceName);

    Unicode = &NtCurrentTeb()->StaticUnicodeString;

    Status = RtlAnsiStringToUnicodeString(Unicode,
                 &DeviceNameA,
                 FALSE
                 );
    if ( !NT_SUCCESS(Status) )
   return NULL;


    InitializeObjectAttributes(
                &FloppyObj,
                Unicode,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );
    Status = NtOpenFile(
         &fd,
         (ACCESS_MASK) FILE_READ_ATTRIBUTES | SYNCHRONIZE,
         &FloppyObj,
         &IoStatusBlock,
         FILE_SHARE_READ | FILE_SHARE_WRITE,
         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
         );

    if (!NT_SUCCESS(Status))
   return NULL;
    else
   return fd;

}


ULONG nt_floppy_read(BYTE drive, ULONG Offset, ULONG Size, PBYTE Buffer)
{
    HANDLE  fd;
    LARGE_INTEGER large_integer;

    fd = get_drive_handle(drive, *pusCurrentPDB, FALSE);

    if (fd == INVALID_HANDLE_VALUE)
   return 0;
    large_integer.LowPart = Offset;
    large_integer.HighPart = 0;
    return(disk_read(fd, &large_integer, Size, Buffer));
}


ULONG nt_floppy_write(BYTE drive, ULONG Offset, ULONG Size, PBYTE Buffer)
{
    HANDLE  fd;
    LARGE_INTEGER large_integer;
    ULONG   size_returned;

    fd = get_drive_handle(drive, *pusCurrentPDB, TRUE);
    if (fd == INVALID_HANDLE_VALUE)
   return 0;

    large_integer.LowPart = Offset;
    large_integer.HighPart = 0;
    size_returned = disk_write(fd, &large_integer, Size, Buffer);
    return (size_returned);
}

BOOL nt_floppy_format(BYTE drive, WORD Cylinder, WORD Head, MEDIA_TYPE Media)
{
    FORMAT_PARAMETERS fmt;
    WORD    bad_track;
    ULONG   size_returned;
    HANDLE  fd;
    BOOL    result;

    result = FALSE;
    fmt.MediaType = Media;
    fmt.StartHeadNumber = fmt.EndHeadNumber = Head;
    fmt.StartCylinderNumber = fmt.EndCylinderNumber = Cylinder;
    fd = get_drive_handle(drive, *pusCurrentPDB,TRUE);
    if (fd == INVALID_HANDLE_VALUE)
   return FALSE;
    result = DeviceIoControl(fd,
              IOCTL_DISK_FORMAT_TRACKS,
              (PVOID) &fmt,
              sizeof(fmt),
              &bad_track,
              sizeof(bad_track),
              &size_returned,
              NULL
              );
    return result;
}

// for floppy, the ioctl call DISK_VERIFY doesn't work
// we have to use read for verification
BOOL nt_floppy_verify(BYTE drive, DWORD Offset, DWORD Size)
{
    HANDLE  fd;
    LARGE_INTEGER   large_integer;

    fd = get_drive_handle(drive, *pusCurrentPDB, FALSE);
    if (fd != INVALID_HANDLE_VALUE) {
   large_integer.LowPart = Offset;
   large_integer.HighPart = 0;
   return(disk_verify(fd,
            &large_integer,
            Size
            ));
    }
    else
   return FALSE;
}

int DiskOpenRetry(char chDrive)
{
    char    FormatString[32];
    char    DriveLetter[32];

    if (!LoadString(GetModuleHandle(NULL), ED_DRIVENUM,
          FormatString,sizeof(FormatString)) )
   {
   strcpy(FormatString,"Drive %c: ");
   }
    sprintf(DriveLetter, FormatString, chDrive);
    return(RcMessageBox(ED_LOCKDRIVE, DriveLetter, NULL,
           RMB_ABORT | RMB_RETRY | RMB_IGNORE | RMB_ICON_BANG
           ));
}


HANDLE get_drive_handle(UTINY drive, USHORT pdb, BOOL auto_lock)
{
    FLP     flp;
    DWORD   share_access;


    flp = &floppy_data[drive];
    // assign new alignment factor  and grab the buffer
    cur_align_factor = flp->align_factor;
    if ((disk_buffer = get_aligned_disk_buffer()) == NULL)
   return (INVALID_HANDLE_VALUE);


    if (flp->diskette_fd != INVALID_HANDLE_VALUE &&
   (fdc_reset || (auto_lock && !flp->auto_locked) ||
    flp->owner_pdb != pdb))
   {
   nt_floppy_close(drive);
   fdc_reset = FALSE;
    }
    share_access = auto_lock ? FILE_SHARE_READ :
                FILE_SHARE_READ | FILE_SHARE_WRITE;
    while(flp->diskette_fd == INVALID_HANDLE_VALUE) {
   flp->diskette_fd = CreateFile ((const char *)flp->device_name,
                      GENERIC_READ | GENERIC_WRITE,
                      share_access,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      0
                      );
   if (flp->diskette_fd != INVALID_HANDLE_VALUE) {
       floppy_open_count++;
       flp->auto_locked = auto_lock ? TRUE : FALSE;
       flp->owner_pdb = pdb;
       (*(pFDAccess))++;
       break;
   }
   if (auto_lock && GetLastError() == ERROR_SHARING_VIOLATION &&
       DiskOpenRetry((char)(drive + (UTINY)'A')) == RMB_RETRY)
      continue;
   else
       break;

    }
    flp->idle_counter = FLOPPY_IDLE_PERIOD;
    return (flp->diskette_fd);
}



VOID HostFloppyReset(VOID)
{
    FloppyTerminatePDB((USHORT)0);
}

VOID FloppyTerminatePDB(USHORT PDB)
{
    UTINY drive;
    FLP   flp;

    if (floppy_open_count) {
   for (drive = 0; drive < number_of_floppy; drive++) {
       flp = &floppy_data[drive];
       if (flp->diskette_fd != INVALID_HANDLE_VALUE &&
      (PDB == 0 || flp->owner_pdb == PDB))
      nt_floppy_close(drive);
   }

    }
}

BOOL nt_floppy_close(UTINY drive)
{
    FLP flp;
    flp = &floppy_data[drive];

#ifndef PROD
    if (rflop_dbg & RFLOP_CLOSE)
   sprintf(dump_buf, "Close drive %C: handle\n", drive + 'A');
   OutputDebugString(dump_buf);
#endif

    if (flp->diskette_fd != INVALID_HANDLE_VALUE) {
   CloseHandle(flp->diskette_fd);
   flp->diskette_fd = INVALID_HANDLE_VALUE;
   (*(pFDAccess))--;
   flp->auto_locked = FALSE;
   flp->owner_pdb = 0;
   floppy_open_count--;
    }
    density_changed = TRUE;
    return TRUE;
}


MEDIA_TYPE
nt_floppy_get_media_type
(
BYTE  drive,
WORD  cylinders,
WORD  sectors,
WORD  heads
)
{
    FLP  flp;
    USHORT      index;

    flp = &floppy_data[drive];
    if (heads == 2){
        index = flp->drive_type;
   switch (index) {
       case GFI_DRIVE_TYPE_12:
          if (cylinders == floppy_tksc[index].trks_per_disk &&
         sectors == floppy_tksc[index].secs_per_trk)
         break;
          index = GFI_DRIVE_TYPE_360;

       case GFI_DRIVE_TYPE_360:
          if (cylinders != floppy_tksc[index].trks_per_disk ||
         sectors != floppy_tksc[index].secs_per_trk)
         index = GFI_DRIVE_TYPE_NULL;
          break;

       case GFI_DRIVE_TYPE_288:
          if (cylinders == floppy_tksc[index].trks_per_disk &&
         sectors == floppy_tksc[index].secs_per_trk)
         break;
          index = GFI_DRIVE_TYPE_144;

       case GFI_DRIVE_TYPE_144:
          if (cylinders == floppy_tksc[index].trks_per_disk &&
         sectors == floppy_tksc[index].secs_per_trk)
         break;
          index = GFI_DRIVE_TYPE_720;

       case GFI_DRIVE_TYPE_720:
          if (cylinders == floppy_tksc[index].trks_per_disk &&
         sectors == floppy_tksc[index].secs_per_trk)
         break;
       default:
      index = GFI_DRIVE_TYPE_NULL;
   }
    }
    else
   index = GFI_DRIVE_TYPE_NULL;
    return(media_table[index]);

}

BOOL nt_floppy_media_check (UTINY drive)
{
    FLP    flp;
    ULONG  size_returned;

    flp = &floppy_data[drive];
    if (flp->diskette_fd == INVALID_HANDLE_VALUE)
   return FALSE;
    return(DeviceIoControl(flp->diskette_fd,
            IOCTL_DISK_CHECK_VERIFY,
            NULL,
            0,
            NULL,
            0,
            &size_returned,
            NULL
            ));
}

/********************************************************/

/* perform an FDC command */
 SHORT
nt_rflop_command
     IFN2(FDC_CMD_BLOCK *, command_block, FDC_RESULT_BLOCK *,result_block)
{
        UTINY   drive;
   FLP flp;
   BOOL failed = FALSE;
   UTINY C, H, N, S, D;
        DWORD   fdc_thread_id;
   BYTE  fdc_command;
   BOOL  auto_lock;


   note_trace1 (GFI_VERBOSE, "FDC: %s command",
      cmd_name [get_type_cmd (command_block)]);

   drive = get_type_drive(command_block);

   flp = &floppy_data[drive];
   flp->idle_counter = FLOPPY_IDLE_PERIOD;

   /* Clear result status registers */
   put_r0_ST0 (result_block, 0);
   put_r0_ST1 (result_block, 0);
   put_r0_ST2 (result_block, 0);

   fdc_command = get_type_cmd(command_block);
        /* for those commands which need a valid floppy be inserted
      we may have to create an independent thread to perform
      the real operation if there is currenly no media
      in the drive. The reason of this independent thread is that
      the FDC is always in its execution phase even though there is
      not media in the drive. As soon as you insert a media(bad or
      good), it then performs its operation, terminates the phase,
      raises interrupt and enters result phase. Some applications just
      do a read id and  then wait the interrupt to occur no matter how
      long the user will take to insert a media. To do this I broke up
      the fdc_command routine so that both main and the fdc thread can
      use the same code. There is not a good point that we can close the
      thread handle as soon as it terminated. Therefore, we close the
      handle on next fdc command
   */
   if (fdc_thread_handle != NULL) {
       CloseHandle(fdc_thread_handle);
       fdc_thread_handle = NULL;
   }

   if ( (auto_lock = (fdc_command == FDC_WRITE_DATA || fdc_command == FDC_FORMAT_TRACK)) ||
        fdc_command == FDC_READ_DATA ||
        fdc_command == FDC_READ_ID ||
        fdc_command == FDC_READ_TRACK) {
       // this might fail due to media changed and from FDC point of
       // view, media change is meaningless. Therefore, we close the
       // handle to the drive and reopen it so that the file system
       // will mount  a new volume for us. Then we check the the
       // media again. If it still fails, we are sure that there is
       // no media in the drive so we go ahead to create a thread.
       if (!nt_floppy_media_check(drive)) {
      nt_floppy_close(drive);
      get_drive_handle(drive, *pusCurrentPDB, auto_lock);
      if (!nt_floppy_media_check(drive)) {
          fdc_parms.auto_lock = auto_lock ? TRUE : FALSE;
          fdc_parms.command_block = command_block;
          fdc_parms.result_block = result_block;
          fdc_parms.owner_pdb = *pusCurrentPDB;
          fdc_thread_handle = CreateThread(NULL,
                  0,
                  (LPTHREAD_START_ROUTINE)fdc_thread,
                  (PVOID)&fdc_parms,
                  0,
                  &fdc_thread_id
                                           );
         return FAILURE;
      }
      else { // media changed
          fdc_read_write(command_block, result_block);
          return SUCCESS;
      }

       }
       else {
      fdc_read_write(command_block, result_block);
      return SUCCESS;
       }
   }

   /* get disk bumpf */
   C = get_c0_cyl (command_block);
   H = get_c0_hd (command_block);
   S = get_c0_sector (command_block);
   N = get_c0_N (command_block);

   /* block timer to prevent interrupted system calls */
   host_block_timer ();

   switch (get_type_cmd (command_block))
   {

   case FDC_SPECIFY:
#ifndef PROD
      if (rflop_dbg & RFLOP_SPECIFY) {
          OutputDebugString("Specify\n");
          if (rflop_dbg & RFLOP_BREAK)
         nt_rflop_break();
      }
#endif
      break;


   case FDC_SENSE_DRIVE_STATUS:

#ifndef PROD
      if (rflop_dbg & RFLOP_SENSEDRV)
          OutputDebugString("Sense Drive Status\n");
#endif
      D = get_c7_drive (command_block);
      put_r2_ST3_fault (result_block,0);
      put_r2_ST3_ready (result_block,1);
      put_r2_ST3_track_0 (result_block,(flp->last_head_seek == 0?1:0));
      put_r2_ST3_two_sided (result_block,1);
      put_r2_ST3_head_address (result_block,0);
      put_r2_ST3_unit (result_block,D);
      break;

   /* RECALIBRATE and SEEK do not really return any results */
   /* However, we return results here which are used by gfi.c */
   /* to construct the results for any following SenseInterruptStatus command */
   case FDC_RECALIBRATE:

#ifndef PROD
      if (rflop_dbg & RFLOP_RECAL)
          OutputDebugString("Recalibrate\n");
#endif
      D = get_c5_drive (command_block);
      put_r3_ST0 (result_block,0);
      put_r1_ST0_int_code (result_block,0);
      put_r1_ST0_seek_end (result_block,1);
      put_r1_ST0_unit (result_block,D);
      put_r3_PCN (result_block,0);
      flp->last_seek = flp->last_head_seek = 0;
      flp->C = 0;
      break;
         
   case FDC_SEEK:

      D = get_c8_drive (command_block);
      C = get_c8_new_cyl (command_block);

#ifndef PROD
      if (rflop_dbg & RFLOP_SEEK) {
          sprintf(dump_buf, "Seek: D C = %d %d \n", D, C);
          OutputDebugString(dump_buf);
          if (rflop_dbg & RFLOP_BREAK)
         nt_rflop_break();
      }
#endif

      put_r3_ST0(result_block,0);
      put_r1_ST0_head_address(result_block,1);
      put_r1_ST0_seek_end(result_block,1);
      put_r1_ST0_int_code(result_block,0);
      put_r1_ST0_unit(result_block,D);
      put_r3_PCN(result_block,C);
      flp->last_seek =  C;
      flp->last_head_seek = min(flp->last_seek,flp->max_track);
      flp->C = C;
      break;
      
   default:

#ifndef     PROD
      sprintf(dump_buf, "Receive unsupported command: command = %d\n",
           get_type_cmd(command_block));
      OutputDebugString(dump_buf);
#endif

      put_r0_ST0 (result_block, 0);
      put_r1_ST0_int_code (result_block, 2);

      note_trace1 (GFI_VERBOSE,"FDC: Unimplemented command, type %d",
            get_type_cmd (command_block));
   }


#ifndef PROD
   if (io_verbose & GFI_VERBOSE) {
      fprintf(trace_file,
          "FDC: results %02x %02x %02x %02x %02x %02x %02x\n\n",
          result_block[0], result_block[1], result_block[2],
          result_block[3], result_block[4], result_block[5],
          result_block[6]);
   }
#endif /* !PROD */

   host_release_timer ();

   return SUCCESS;
}

/********************************************************/

/* turn the motor on */
SHORT
nt_rflop_drive_on IFN1(UTINY, drive)
{
   FLP flp = &floppy_data[drive];

   note_trace0 (GFI_VERBOSE, "FDC: Drive on command");
#ifndef PROD
   if (rflop_dbg & RFLOP_DRIVE_ON) {
       sprintf(dump_buf, "drive on: drive = %d\n", drive);
       OutputDebugString(dump_buf);
       if (rflop_dbg & RFLOP_BREAK)
      nt_rflop_break();
   }
#endif

   if (drive >= number_of_floppy)
   {
      note_trace1 (GFI_VERBOSE,
         "FDC: Invalid drive %d accessed", drive);

      return (FAILURE);
   }

   flp->motor_state = MOTOR_ON;

   return (SUCCESS);
}

/********************************************************/

/* turn the motor off */
SHORT
nt_rflop_drive_off IFN1(UTINY, drive)
{
   FLP flp = &floppy_data[drive];
   note_trace0 (GFI_VERBOSE, "FDC: Drive off command");
#ifndef PROD
   if (rflop_dbg & RFLOP_DRIVE_OFF) {
       sprintf(dump_buf, "drive off: drive = %d\n", drive);
       OutputDebugString(dump_buf);
       if (rflop_dbg & RFLOP_BREAK)
      nt_rflop_break();
   }
#endif

   if (drive >= number_of_floppy)
   {
      note_trace1 (GFI_VERBOSE,
         "FDC: Invalid drive %d accessed", drive);

      return (FAILURE);
   }

   flp->motor_state = MOTOR_OFF;

   /* I believe the line below makes booting off of low density
    * diskettes problematical, particularly after restarts.
    * Make your own mind up, the DEC code does it, the Sparc
    * doesn't (as at 11/9/92)
// we have no reason to do so in NT. As far as change line concerned,
// the file system will tell us "media has been changed" when we ask
// it to do some real work.
// flp->change_line_state = TRUE;
    */

   return (SUCCESS);
}

/********************************************************/

/* set the data transfer rate
 * This controls the "density" of the floppy: the rate MUST
 * match the actual media density for the disk controller to
 * be able to read the sectors.
 */
SHORT
nt_rflop_rate IFN2(UTINY, drive, half_word, rate)
{
    short   new_density;
// basically, "set rate applied to every drive since we have
// only one FDC(and mutiple drive).

#if 0
   FLP flp = &floppy_data[drive];

   switch (rate)
   {
      /* 2.88M high-density floppies */
      case DCR_RATE_1000:

         flp->density_state = DENSITY_EXTENDED;
         set_floppy_parms (flp);
         break;

      /* 1.2M or 1.44M high-density floppies */
      case DCR_RATE_500:

         flp->density_state = DENSITY_HIGH;
         set_floppy_parms (flp);
         break;

      /* 360K or 720K low-density floppies */
      case DCR_RATE_250:
      case DCR_RATE_300:

         flp->density_state = DENSITY_LOW;
         set_floppy_parms (flp);
         break;

      /* crapola density passed */
      default:

         return FAILURE;
   }
   note_trace2 (GFI_VERBOSE, "FDC: Set rate %0x => density %d",
      rate, flp->density_state);
   /* read floppy's boot sector */
   /* to determine the real density */
// guess_media_density (drive);
#endif
#ifndef PROD
   if (rflop_dbg & RFLOP_RATE) {
       sprintf(dump_buf, "set rate: rate = %d\n", rate);
       OutputDebugString(dump_buf);
       if (rflop_dbg & RFLOP_BREAK)
      nt_rflop_break();
   }
#endif

    switch (rate) {
   case DCR_RATE_1000:
      new_density = DENSITY_EXTENDED;
      break;
   case DCR_RATE_500:
      new_density = DENSITY_HIGH;
      break;
   case DCR_RATE_300:
   case DCR_RATE_250:
      new_density = DENSITY_LOW;
      break;
   default:
      return FAILURE;

    }
    if (new_density != density_state) {
   density_state = new_density;
   density_changed = TRUE;
    }
    return SUCCESS;
}


/********************************************************/

/* return the state of the change line */
SHORT
nt_rflop_change IFN1(UTINY, drive)
{
   FLP flp = &floppy_data[drive];
   note_trace1 (GFI_VERBOSE, "FDC: change_line %c",
      flp->change_line_state? 'T':'F');

   // if fla has been reset or the current change line is on(no media),
   // close the drive and reopen it. This is done because
   // nt_floppy_media_check(IOCTL_DISK_CHECK_VERIFY) will continue
   // to report media change even the users have a new disketter inserted.
   //
   if (fdc_reset || flp->change_line_state) {
       fdc_reset = FALSE;
       nt_floppy_close(drive);
   }
   get_drive_handle(drive, *pusCurrentPDB, FALSE);
   flp->change_line_state = !nt_floppy_media_check(drive);

#ifndef PROD
   if (rflop_dbg & RFLOP_CHANGE) {
       sprintf(dump_buf, "Check Change Line: line = %d\n", flp->change_line_state);
       OutputDebugString(dump_buf);
       if (rflop_dbg & RFLOP_BREAK)
      nt_rflop_break();
   }
#endif

   return(flp->change_line_state);
}

/********************************************************/

/* return the type of the drive */
SHORT
nt_rflop_drive_type IFN1(UTINY, drive)
{
   FLP flp = &floppy_data[drive];


/* setup base media type depending on drive type */
// I don't understand why we have to do this stuff every time.
   switch (flp->drive_type)
   {
      /* 5.25" drives */
      case GFI_DRIVE_TYPE_360:
      case GFI_DRIVE_TYPE_12:

         flp->flop_type = GFI_DRIVE_TYPE_360;
         break;

      /* 3.5" drives */
      case GFI_DRIVE_TYPE_720:
      case GFI_DRIVE_TYPE_144:
      case GFI_DRIVE_TYPE_288:

         flp->flop_type = GFI_DRIVE_TYPE_720;
         break;

      default:
         break;
   }

   set_floppy_parms(flp);
   note_trace2 (GFI_VERBOSE, "FDC: flop_type %d density %d",
      flp->flop_type, flp->drive_type - flp->flop_type);

   return (flp->drive_type);
}

/********************************************************/

/* close and reopen the device */
SHORT
nt_rflop_reset IFN2(FDC_RESULT_BLOCK *, result_block, UTINY, drive)
{
   FLP flp = &floppy_data[drive];

   note_trace0 (GFI_VERBOSE, "FDC: Reset command");

#ifndef  PROD
   if (rflop_dbg & RFLOP_RESET) {
       OutputDebugString("reset\n");
       if (rflop_dbg & RFLOP_BREAK)
      nt_rflop_break();
   }
#endif
   /* clear change line */
   flp->change_line_state = FALSE;
   fdc_reset = TRUE;

   if (fdc_thread_handle) {  // signal thread to exit
       CloseHandle(fdc_thread_handle);
       fdc_thread_handle = NULL;
   }
        return (SUCCESS);
}


// this is the independent thread which performs FDC operation.
// this thread is not created from the beginning, instead, it was
// created on demand.
void fdc_thread(PFDC_PARMS fdc_parms)
{
    BYTE    drive, fdc_command;
    FDC_CMD_BLOCK *  command_block;
    BOOL     auto_lock;
    USHORT      pdb;
    command_block  = fdc_parms->command_block;
    auto_lock = fdc_parms->auto_lock;
    pdb = fdc_parms->owner_pdb;
    drive = get_type_drive(command_block);
    fdc_command = get_type_cmd(command_block);
    while (TRUE) {
   // if there is media inserted, perform the operation
   // and enter result phase.
   if (get_drive_handle(drive, pdb, auto_lock) != INVALID_HANDLE_VALUE &&
       nt_floppy_media_check(drive)) {
       // force the file system to remount the volume
       nt_floppy_close(drive);
       // and then perform the operation
       fdc_read_write (command_block, fdc_parms->result_block);
       // raise an interrupt
       fdc_command_completed(drive, fdc_command);
       break;
   }
   // if reset happen, quit
   if (fdc_thread_handle == NULL)
       break;
    }
}

SHORT
fdc_read_write (
FDC_CMD_BLOCK * command_block,
FDC_RESULT_BLOCK * result_block
)
{

   USHORT transfer_count; /* Surely counts cannot be negative?  GM  */
   FLP flp;
   BOOL failed = FALSE;
   UTINY C, H, N, S, D, drive, fdc_command;
   USHORT dma_size;
   ULONG transfer_size;
   ULONG transferred_size;
   long transfer_start;
   sys_addr dma_address;

   drive = get_type_drive(command_block);
   fdc_command = get_type_cmd(command_block);

   /* get disk bumpf */
   C = get_c0_cyl (command_block);
   H = get_c0_hd (command_block);
   S = get_c0_sector (command_block);
   N = get_c0_N (command_block);

   flp = &floppy_data[drive];
   /* block timer to prevent interrupted system calls */
   host_block_timer ();
   if (fdc_command != FDC_FORMAT_TRACK) {
       if ((density_changed || drive != last_drive) &&
      guess_media_density(drive) != DENSITY_UNKNOWN) {
      set_floppy_parms(flp);
      density_changed = FALSE;
      last_drive = drive;
       }
       if (density_state != flp->media_density) {
      put_r0_ST0 (result_block, 0x40);
      put_r0_ST1 (result_block, 0);
      put_r1_ST1_no_address_mark (result_block,1);
      put_r0_ST2 (result_block, 0);
#ifndef PROD
      sprintf(dump_buf, "density mismatch: %d <-> %d\n", density_state,
         flp->media_density);
      OutputDebugString(dump_buf);
#endif
      goto fdc_read_write_exit;
       }
   }


   /*
    * Do common setup processing, if read or write
    */
   if (fdc_command == FDC_READ_DATA ||
       fdc_command == FDC_WRITE_DATA) {
       /*
        * Find out how much gunk to transfer
        */
       dma_enquire (DMA_DISKETTE_CHANNEL, &dma_address, &dma_size);
       transfer_size = dma_size + 1;
#ifndef PROD
       if (transfer_size > BS_DISK_BUFFER_SIZE)
      always_trace2("FDC: transfer size ( %d ) greater than disk buffer size %d\n", transfer_size, BS_DISK_BUFFER_SIZE);
#endif   /* PROD */
       /* check params passed are DOS compatible */
       if (! dos_compatible (flp, C, H, S, N) ||
      density_state != flp->media_density) {
          sprintf(dump_buf, "Incompatible DOS diskette, C H R N = %d %d %d %d\n",
             C, H, S, N);
          OutputDebugString(dump_buf);
// do not pop up this annoy message because some applications are simply
// "probing" the diskette. We just fail the call.
//    host_direct_access_error((ULONG) NOSUPPORT_FLOPPY);
#ifndef PROD

      if (!dos_compatible (flp, C, H, S, N)) {
         note_trace0 (GFI_VERBOSE,
                 "Refused: not DOS compatible");
      }
      if (density_state != flp->media_density) {
         note_trace0 (GFI_VERBOSE,
                 "Refused: density mismatch");
      }
#endif /* !PROD */
      /* Sector not found or wrong size */
      put_r0_ST0 (result_block,0x40);
      put_r0_ST1 (result_block,0);
      if (density_state != flp->media_density) {
         put_r1_ST1_no_address_mark (result_block,1);
      } else {
         put_r1_ST1_no_data (result_block,1);
      }
      put_r0_ST2 (result_block,0);
      goto fdc_read_write_exit;
       }
       /* work out start position on floppy and sector count */
       transfer_start = dos_offset (flp, C, H, S);
            transfer_count = (USHORT)(transfer_size / PC_BYTES_PER_SECTOR);
#ifndef PROD
       if (rflop_dbg & (RFLOP_READ | RFLOP_WRITE)) {
       sprintf(dump_buf, "Read/Write Sector: start offset = 0x%lx\n",
           transfer_start);
       OutputDebugString(dump_buf);
       sprintf(dump_buf, "Read/Write Sector: size = 0x%x bytes\n", transfer_size);
       OutputDebugString(dump_buf);
       }
#endif

   }

   switch (fdc_command)
   {
   case FDC_READ_DATA:
#ifndef PROD
      if (rflop_dbg & RFLOP_READ) {
          sprintf(dump_buf, "Read Sectors: C H R N = %d %d %d %d\n",
              C, H, S, N);
          OutputDebugString(dump_buf);
          if (rflop_dbg & RFLOP_BREAK)
         nt_rflop_break();
      }
#endif

      if (!failed) {
          transferred_size = nt_floppy_read(drive,
                        transfer_start,
                        transfer_size,
                        disk_buffer
                        );
          if (transferred_size != transfer_size) {
         last_error = GetLastError();
         sprintf(dump_buf, "Read Error, code = %lx\n", last_error);
         OutputDebugString(dump_buf);
         failed = TRUE;
          }
          else {
         dma_request (DMA_DISKETTE_CHANNEL,
                 (char *)disk_buffer, (USHORT)transfer_size);
          }
      }

      if (failed){
         put_r0_ST0 (result_block, 0x40);
         put_r0_ST1 (result_block, 0);
         put_r1_ST1_no_data (result_block, 1);
         put_r0_ST2 (result_block, 0);
      }
      else {
         put_r0_ST0 (result_block, 0x04);
         put_r0_ST1 (result_block, 0);
         put_r0_ST2 (result_block, 0);
         put_r1_ST0_unit (result_block, drive);
         put_r1_ST0_head_address(result_block, H);
      }

      flp->C = C;
      flp->H = H;
      flp->R = S;
      flp->N = N;
      update_chrn (flp,
                             (UTINY)(get_c0_MT(command_block)),
                             (UTINY)(get_c0_EOT(command_block)),
                             (UTINY)transfer_count
                             );
      /* What should these really be? */
      put_r0_cyl (result_block, flp->C);
      put_r0_head (result_block, flp->H);
      put_r0_sector (result_block, flp->R);
      put_r0_N (result_block, flp->N);
      break;

   case FDC_WRITE_DATA:
#ifndef PROD
      if (rflop_dbg & RFLOP_WRITE) {
          sprintf(dump_buf, "Write Sectors: C H R N = %d %d %d %d\n",
              C, H, S, N);
          OutputDebugString(dump_buf);
          if (rflop_dbg & RFLOP_BREAK)
         nt_rflop_break();
      }
#endif
      if (!failed) {
          /* copy from Intel space */
          dma_request (DMA_DISKETTE_CHANNEL, (char *) disk_buffer,
             (USHORT)transfer_size);
          transferred_size = nt_floppy_write(drive,
                         transfer_start,
                         transfer_size,
                         disk_buffer
                         );
          if (transferred_size != transfer_size) {
         last_error = GetLastError();
         sprintf(dump_buf, "Write Error, code = %lx\n", last_error);
         OutputDebugString(dump_buf);
         failed = TRUE;
          }
      }

      /* Clear down result bytes */
      put_r0_ST0 (result_block, 0);
      put_r0_ST1 (result_block, 0);
      put_r0_ST2 (result_block, 0);

      if (failed)
      {
         put_r1_ST0_int_code (result_block, 1);

         /* make sure we get the correct error for EROFS */
         if (last_error == ERROR_WRITE_PROTECT)
            put_r1_ST1_write_protected (result_block, 1);
         else
            put_r1_ST1_no_data (result_block, 1);
      }
      else
      {
         put_r1_ST0_head_address (result_block, H);
         put_r1_ST0_unit(result_block, drive);
      }

      flp->C = C;
      flp->H = H;
      flp->R = S;
      flp->N = N;

      update_chrn (flp,
                             (UTINY)(get_c1_MT(command_block)),
                             (UTINY)(get_c1_EOT(command_block)),
              (UTINY)transfer_count
              );
      put_r0_cyl (result_block, flp->C);
      put_r0_head (result_block, flp->H);
      put_r0_sector (result_block, flp->R);
      put_r0_N (result_block, flp->N);
      break;

   case FDC_READ_TRACK:
#ifndef PROD
      if (rflop_dbg & RFLOP_READTRACK) {
          OutputDebugString("Read Tracks\n");
          if (rflop_dbg & RFLOP_BREAK)
         nt_rflop_break();
      }
#endif

      break;

   case FDC_FORMAT_TRACK:

      dma_enquire (DMA_DISKETTE_CHANNEL, &dma_address, &dma_size);
      transfer_size = dma_size + 1;
                /* copy from Intel space */
      dma_request (DMA_DISKETTE_CHANNEL, (char *) disk_buffer,
              (USHORT)transfer_size);

      D = get_c8_drive(command_block);
      H = get_c8_head(command_block);
      flp = &floppy_data[D];
#ifndef PROD
      if (rflop_dbg & RFLOP_FORMAT) {
          sprintf(dump_buf, "Format Track: C H Media = %d %d %d \n",
               flp->last_seek, H, flp->flop_type + density_state);
          OutputDebugString(dump_buf);
          if (rflop_dbg & RFLOP_BREAK)
         nt_rflop_break();
      }
#endif
      if (!nt_floppy_format(D,
                  flp->last_seek,
                  H,
                  media_table[flp->flop_type + density_state]
                  )) {
          last_error = GetLastError();
          sprintf(dump_buf, "Format Error, code = %lx\n", last_error);
          OutputDebugString(dump_buf);
          failed = TRUE;
      }
      if (!failed) {
          put_r0_ST0 (result_block, 0);
          put_r0_ST1 (result_block, 0);
          put_r0_ST2 (result_block, 0);
          // C H R N are meaningless on formatting
      }
      else {
          put_r0_ST0 (result_block, 0x40);
          put_r1_ST0_head_address (result_block, H);
          put_r1_ST0_unit(result_block, D);
          put_r0_ST1 (result_block, 0);
          if (last_error == ERROR_WRITE_PROTECT) {
         put_r1_ST1_write_protected (result_block, 1);
          }
          put_r0_ST2 (result_block, 0);
      }
      break;

   case FDC_READ_ID:

      H = get_c4_head(command_block);
      /* check if cylinder number massaging required */
      if ((flp->flop_type + density_state) == GFI_DRIVE_TYPE_360)
      {
                        /* 5.25" low density, 40 tracks */
                        C = (UTINY) (flp->last_seek / 2);
                        put_c0_cyl (result_block, C);

      }
      else
      {
                        /* no massage required, 80 tracks */
                        C = (UTINY)flp->last_seek;
                        put_r0_cyl (result_block, C);

      }
      if (flp->C < flp->trks_per_disk) {
          put_r1_ST0_unit(result_block, drive);
          put_r1_ST0_head_address(result_block, H);
          put_r0_head (result_block, H);
          put_r0_sector (result_block, flp->R);
          put_r0_N (result_block, flp->N);
          C = flp->C;
          put_r0_cyl(result_block, flp->C);
      }
      else
          C = flp->trks_per_disk - 1;

      put_r0_cyl(result_block, C);
#ifndef PROD
      if (rflop_dbg & RFLOP_READID) {
          sprintf(dump_buf, "Read ID: C H R N = %d %d %d %d\n",
              C, H, flp->R, flp->N);
          OutputDebugString(dump_buf);
          if (rflop_dbg & RFLOP_BREAK)
         nt_rflop_break();
      }
#endif
   }

   if (failed)
       density_changed = TRUE;
fdc_read_write_exit:

    return SUCCESS;

}
/********************************************************/

/* INTERNALLY USED FUNCTIONS */

/* In order to read the data on the floppy, the floppy controller must
 * be set to the same density (rate) as was used to write the data.
 * A mismatch in densities will cause read failures, and DOS uses these
 * failures as a way to probe the diskette for the correct density.
 *
 * To emulate the floppy controller correctly, we must somehow
 * guess the density of the media and produce fake "read failures" if the
 * controller density doesn't match the media density.
 *
 * On the assumption that the operating system has already done this,
 * and that we are looking at a DOS floppy, nt_flop.c can read the
 * "total number of sectors" value from the boot sector and guess
 * the density accordingly. There should be no need for this function
 * if you have fairly direct access to the disk controller.
 */
 int probelist[] = { 720-1, 1440-1, 2400-1, 2880-1, 5760-1, 0-1};

 SHORT
guess_media_density IFN1(UTINY, drive)
{
   int total_sectors;
        int *probe;
   FLP flp;
   ULONG transferred_size;

   flp = &floppy_data[drive];
   transferred_size = nt_floppy_read(drive,
                 0L,
                 PC_BYTES_PER_SECTOR,
                 (PBYTE) disk_buffer
                 );

   if (transferred_size != PC_BYTES_PER_SECTOR) {
       last_error = GetLastError();
       OutputDebugString("Unknown Media\n");
       /* assume that the disk is unformatted */
       return(flp->media_density = DENSITY_UNKNOWN);/* impossible value */
   }


   /* check for a DOS boot block
    *
    * AccessPC has shown that 0x55, 0xaa is not the only magic
    * number in use, and it might be better to check the total_sectors
    * number itself for a valid size. This algorithm is safe, but may
    * do unnecessary disk reads if an different magic number is used.
    */

   /* the AA, 55 signature sometime doesn't work at all, It should
      be done as DOS */

   if ((disk_buffer[0] == 0x69 || disk_buffer[0] == 0xE9 ||
        (disk_buffer[0] == 0xEB && disk_buffer[2] == 0x90)) &&
        (disk_buffer[21] & 0xF0) == 0xF0 ) {
      /* read total number of sectors, and thus deduce density
       */
      total_sectors = disk_buffer [20] * 256 + disk_buffer [19];
   } else {
      note_trace2 (GFI_VERBOSE,
         "not a DOS boot block: magic = %02x %02x",
         disk_buffer[510], disk_buffer[511]);

      /* probe disk by reading last sectors for each size
       * (in order) until the read fails.
       */
      total_sectors = 0;
      for (probe=probelist; *probe != 0; probe++) {
          transferred_size = nt_floppy_read(drive,
                        (*probe)*PC_BYTES_PER_SECTOR,
                        PC_BYTES_PER_SECTOR,
                        disk_buffer
                        );
          if (transferred_size != PC_BYTES_PER_SECTOR)
            break;   /* out of the for loop */
           total_sectors = (*probe) + 1;
      }
   }

   switch (total_sectors)
   {
   case 0:
      note_trace0( GFI_VERBOSE, "total_sectors = 0 - unformatted");
      flp->media_density = DENSITY_UNKNOWN;  /* impossible value */
      break;
      
   case 720:   
   case 1440:  
      flp->media_density = DENSITY_LOW;
      break;   

   case 2400:  
   case 2880:  
      flp->media_density = DENSITY_HIGH;
      break;   

   case 5760:  
      flp->media_density = DENSITY_EXTENDED;
      break;   

   default:
      note_trace1 (GFI_VERBOSE,
         "total sectors = %d? Assume high density",
         total_sectors);
      flp->media_density = DENSITY_HIGH;
      break;
   }

#ifndef PROD
   note_trace1 (GFI_VERBOSE, "guess_media_density %d",
      flp->media_density);
   if (flp->media_density != density_state) {
      note_trace0 (GFI_VERBOSE,
         "media & controller densities are incompatible!\n");
   }
#endif /* !PROD */
   return(flp->media_density);
}

/********************************************************/

/*
 * dos_offset() calculates the offset in bytes of the required sector
 * from the start of the nt virtual disk file for a given track
 * and sector. This maps the floppy data onto the nt file in an
 * interleaved format with the data for each head adjacent for a
 * given cylinder.
 */

int
dos_offset IFN4(FLP, flp, UTINY, cyl, UTINY, hd, UTINY, sec)
{
   int ret;

   ret = (((cyl * PC_HEADS_PER_DISKETTE * flp->secs_per_trk)
      + (hd * flp->secs_per_trk)
      + (sec - 1)) * PC_BYTES_PER_SECTOR) ;

   note_trace1(GFI_VERBOSE, "Dos offset %d", ret);
   return (ret);
}

/********************************************************/

/*
 * dos_compatible() returns TRUE if the command block's
 * cylinder/head/sector is DOS-compatible
 */

BOOL
dos_compatible IFN5(FLP, flp, UTINY, cyl, UTINY, hd, UTINY, sec, UTINY, n)
{
   BOOL ret;

   ret = ((hd <= PC_HEADS_PER_DISKETTE)
      && (cyl < flp->trks_per_disk)
      && (sec <= flp->secs_per_trk)
      && (n == PC_N_VALUE));

   return (ret);
}

/********************************************************/

VOID
set_floppy_parms IFN1(FLP, flp)
{
   int index = flp->flop_type + density_state;

   flp->secs_per_trk = (IU16)
      floppy_tksc [index].secs_per_trk;

   flp->trks_per_disk = (IU16)
      floppy_tksc [index].trks_per_disk;

   flp->max_track = flp->trks_per_disk - 1;
   note_trace2(GFI_VERBOSE, "set_floppy_parms: secs_per_trk %d, trks_per_disk %d", flp->secs_per_trk, flp->trks_per_disk);

}

/********************************************************/


#ifndef PROD
VOID nt_rflop_break(VOID)
{
}

#endif

VOID update_chrn (
FLP   flp,
UTINY mt,
UTINY eot,
UTINY sector_count
)
{
    UTINY new_sector;

#ifndef PROD
    if (flp->C == break_cylinder &&
   flp->H == break_head &&
   flp->R == break_sector)
   nt_rflop_break();
#endif

    new_sector = flp->R + sector_count - 1;
    if (new_sector > eot && mt != 0) {
   flp->H = 1;
   new_sector >>= 1;
    }
    flp->R =  (new_sector == eot) ? 1 : new_sector + 1;

    if (mt != 0 && new_sector == eot) {
   if(flp->H == 1)
       flp->C++;
   flp->H ^= 1;
    }
    else {
   if (new_sector == eot)
       flp->C++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_reset.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title                : NT reset functions
 *
 * Description  : This function is called by the standard reset function to
 * set up any specific devices used by the Sun4 implementation.
 *
 * Author               : SoftPC team
 *
 * Notes                :
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <vdmapi.h>
#include "insignia.h"
#include "host_def.h"

#ifdef X86GFX
#include <ntddvdeo.h>
#endif

#include <sys\types.h>
#include "xt.h"
#include "sas.h"
#include "bios.h"
#include "keyboard.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "gvi.h"
#include "mouse_io.h"
#include "error.h"
#include "config.h"
#include "host.h"
#include "timer.h"
#include "idetect.h"
#include CpuH
#include "debug.h"
#include <stdio.h>
#include <stdlib.h>
#include <conapi.h>
#include "nt_timer.h"
#include "nt_graph.h"
#include "ntcheese.h"
#include "nt_uis.h"
#include "nt_com.h"
#include "nt_reset.h"
#include "nt_event.h"
#include "nt_fulsc.h"
#include "nt_eoi.h"
#include "video.h"
#include "nt_thred.h"
#include "nt_sb.h"
#include "ckmalloc.h"

VOID DeleteConfigFiles(VOID);  // from command.lib
void ShowStartGlass (DWORD);   // private user api

extern VIDEOFUNCS nt_video_funcs;
extern KEYBDFUNCS nt_keybd_funcs;
extern HOSTMOUSEFUNCS the_mouse_funcs;

#ifndef MONITOR
extern WORD BWVKey;
extern char achES[];
#endif

#ifdef MONITOR
extern VOID AddTempIVTFixups(VOID);
#endif

extern IU8 lcifo[];

/*
 * Exported Data
 */
GLOBAL BOOL VDMForWOW = FALSE;
GLOBAL BOOL fSeparateWow = FALSE;  // TRUE if CREATE_SEPARATE_WOW_VDM flag
GLOBAL HANDLE MainThread;
GLOBAL ULONG DosSessionId = 0;
GLOBAL ULONG WowSessionId = 0;
GLOBAL UINT VdmExitCode = 0xFF;
GLOBAL BOOL StreamIoSwitchOn = TRUE;
GLOBAL PCHAR pszSystem32Path = NULL;
GLOBAL ULONG ulSystem32PathLen = 0; // Does not include '\0'.
LOCAL  PCWSTR pcwSystem32 = NULL;

/*
 *
 * ============================================================================
 * External functions
 * ===========================================================================
 * =
 */

void
host_reset()
{

#ifdef X86GFX
    InitDetect();
#endif

    if (host_stream_io_enabled) {
        sc.ScreenState = STREAM_IO;
        ConsoleInitialised = TRUE;
    }
    else {

        ConsoleInit();
        MouseAttachMenuItem(sc.ActiveOutputBufferHandle);
        /*::::::::::::::::::::::::::::::::::::::::::::::::: Enable idle detect */
    }

#ifdef MONITOR
    /* Borrow the end of this routine to add temp code that hooks certain
     * Ints back to the VDM and not into the native BIOS. These will only
     * be active for the DOSEM initialisation ie until keyboard.sys can
     * come along and do it properly. We must do this though as some real
     * BIOS' can hang on certain initialisation functions. eg Dec 486/50
     * will hang on printer init as it is waiting for a responce from a
     * 'private' port.
     */
    AddTempIVTFixups();
#endif  /* MONITOR */


    //
    // Let the heartbeat thread run and release the ica lock,
    // on x86 needed now, for fullscreen switch notification.
    //
    ResumeThread(ThreadInfo.HeartBeat.Handle);

#ifdef MONITOR
    WaitIcaLockFullyInitialized();
#endif

    host_ica_unlock();

#ifdef  HUNTER
    IDLE_ctl(FALSE);    /* makes Trapper too slow */
#else   /* ! ( HUNTER ) */
    if (sc.ScreenState == FULLSCREEN)   // initialised in ConsoleInit()
        IDLE_ctl(FALSE);
    else
        IDLE_ctl(TRUE);         // can't idle detect fullscreen

    host_idle_init();           // host sleep event creation
#endif  /* HUNTER */

}

/*++

Routine Description:

    This function load a known system32 library (no path searched)

Arguments:

    pcwsBaseNameW is something like L"KERNEL32.DLL"

Return Value:

    A handle to be used with UnloadSystem32Library, NULL if failure.

--*/



HANDLE
LoadSystem32Library(
    PCWSTR pcwsBaseNameW
    )
{
    HANDLE          h;
    UNICODE_STRING  UnicodeBaseName;

    RtlInitUnicodeString(&UnicodeBaseName, pcwsBaseNameW);

    if (NT_SUCCESS( LdrLoadDll( pcwSystem32, NULL, &UnicodeBaseName, &h))) {
        return(h);
    } else {
        return(NULL);
    }
}

/*
 * =========================================================================
 *
 * FUNCTION             : host_applInit
 *
 * PURPOSE              : Sets up the keyboard, lpt and error panels.
 *
 * RETURNED STATUS      : None.
 *
 * DESCRIPTION  : Called from main.c.  The keyboard and other GWI pointer
 *                sets are initialised here. The command line arguments are
 *                parsed for those flags that need processing early (ie before
 *                config() is called).
 *
 * =======================================================================
 */
#define  HOUR_BOOST_FOR_WOW 20*1000     // 20 seconds

void  host_applInit(int argc,char *argv[])
{
    char            *psz;
    int             temp_argc = argc;
    char            **temp_argv = argv;
    ULONG           SessionId = 0;
    ULONG           ProcessInformation = 0;
    UNICODE_STRING  us;
    ANSI_STRING     as;


    working_video_funcs = &nt_video_funcs;
    working_keybd_funcs = &nt_keybd_funcs;
    working_mouse_funcs = &the_mouse_funcs;

    //
    // We used to have a check for the -f flag to prevent the user/hacker
    // from running NTVDM at the command line. This has now been replaced
    // by the somewhat safer following check. Note that if we are not on
    // greater then XP, the check will fail and the default will exit.
    //

    NtQueryInformationProcess(
        GetCurrentProcess(),
        ProcessWx86Information,
        &ProcessInformation,
        sizeof(ProcessInformation),
        NULL
    );

    if (ProcessInformation == 0) {
        ExitProcess (0);
    }

    // Figure out the system directory size.
    ulSystem32PathLen = GetSystemDirectory(NULL, 0);
    if (ulSystem32PathLen == 0) {
        host_error(EG_OWNUP, ERR_QUIT, "NTVDM:System32 fails");
        TerminateVDM();
    }

    check_malloc(pszSystem32Path, ulSystem32PathLen+1, CHAR);

    // Warning: we do need to refresh ulSystem32PathLen since kernel
    // actually return one extra byte on the NULL, 0 call.
    ulSystem32PathLen = GetSystemDirectory(pszSystem32Path, ulSystem32PathLen+1);
    if (ulSystem32PathLen == 0) {
        host_error(EG_OWNUP, ERR_QUIT, "NTVDM:System32 fails (2)");
        TerminateVDM();
    }

    RtlInitAnsiString(&as, pszSystem32Path);
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&us, &as, TRUE))) {
        host_error(EG_OWNUP, ERR_QUIT, "NTVDM:System32 fails (3)");
        TerminateVDM();
    }

    pcwSystem32 = us.Buffer;

// Check if the VDM Is for WOW
// Check is for new console session
    while (--temp_argc > 0) {
        psz = *++temp_argv;
        if (*psz == '-' || *psz == '/') {
            psz++;

#ifndef MONITOR
            //
            // Check for windowed graphics resize
            //
            if (*psz == 'E') {
               int i;

               i = strlen(achES);
               if (!strncmp(psz, achES, i) && strlen(psz) == (size_t)i+2) {
                   psz += i;
                   BWVKey = (WORD)strtoul(psz, NULL, 16);
                   if (BWVKey > 0xFE)
                       BWVKey = 0;
               }
            }
            else
#endif
            if(tolower(*psz) == 'w') {

               VDMForWOW = TRUE;
               ++psz;
               if (tolower(*psz) == 's') { // VadimB: New code
                  fSeparateWow = TRUE;
               }
            }
            else if (*psz == 'o'){
               StreamIoSwitchOn = FALSE;
            }
            else if (*psz++ == 'i' && *psz) {
               SessionId = strtoul(psz, NULL, 16);
            }

        }
    }

    // determine whether the id is for dos or for wow

    if (0 != SessionId) {
       if (VDMForWOW && !fSeparateWow) {
          WowSessionId = SessionId;
       }
       else {
          DosSessionId = SessionId;
       }
    }

    // If VDM Is for WOW keep showing the glass
    if (VDMForWOW) {
       ShowStartGlass (HOUR_BOOST_FOR_WOW);
       StreamIoSwitchOn = FALSE;
    }
    else if (StreamIoSwitchOn)
            enable_stream_io();

    /*
     * Get a handle to the main thread so it can be suspended during
     * hand-shaking.
     */
    DuplicateHandle(GetCurrentProcess(),
                    GetCurrentThread(),
                    GetCurrentProcess(),
                    &MainThread,
                    (DWORD) 0,
                    FALSE,
                    (DWORD) DUPLICATE_SAME_ACCESS);

    InitializeIcaLock();
    host_ica_lock();

    init_host_uis();    /* console setup */
    nt_start_event_thread();      /* Start event processing thread */
}


/*
 * =========================================================================
 *
 * FUNCTION             : host_applClose
 *
 * PURPOSE              : The last chance to close down.
 *
 * RETURNED STATUS      : None.
 *
 * DESCRIPTION  : Called from main.c.
 *
 *
 * =======================================================================
 */

void
host_applClose(void)
{
  nt_remove_event_thread();
  InitSound(FALSE);
  SbCloseDevices();
  TerminateHeartBeat();

  GfxCloseDown();             // ensure video section destroyed
#ifdef X86GFX
  if (sc.ScreenBufHandle)
      CloseHandle(sc.ScreenBufHandle);
#endif // X86GFX



  host_lpt_close_all();       /* Close all open printer ports */
  host_com_close_all();       /* Close all open comms ports */
  MouseDetachMenuItem(TRUE);  /* Force the menu item away on quit */

  DeleteConfigFiles();    // make sure temp config files are deleted
}




/*::::::::::::::::::::::::::::::::::::::::::::::::::: Closedown the VDM */


/*
 * host_terminate
 *
 * This function does not return it exits
 * Most of softpc has been shutdown by the time this
 * code is reached, as host_applClose has already been
 * invoked.
 *
 */
void host_terminate(void)
{

#ifdef HUNTER
    if (TrapperDump != (HANDLE) -1)
        CloseHandle(TrapperDump);
#endif /* HUNTER */

    if(VDMForWOW)
        ExitVDM(VDMForWOW,(ULONG)-1);     // Kill everything for WOW VDM
    else
        ExitVDM(FALSE,0);

    ExitProcess(VdmExitCode);
}



/*  TerminateVDM - used by host to initiate shutdown
 *
 *  Request to start shutting down
 *
 */
VOID TerminateVDM(void)
{

    /*
     *  Do base sepcific cleanup thru terminate().
     *  NOTE: terminate will call host_applClose and host_terminate
     *        after doing base cleanup
     */
    terminate();
}





#ifdef NOTUSEDNOTUSED
void
manager_files_init()
{

        assert0(NO,"manager_files_init stubbed\n");
}


#ifndef PROD
/*
 * =========================================================================
 *
 * FUNCTION             : host_symb_debug_init
 *
 * PURPOSE              : Does nothing
 *
 * RETURNED STATUS      : None.
 *
 * DESCRIPTION  : Called from main.c.
 *
 *
 * =======================================================================
 */

void
host_symb_debug_init IFN1(char *, name)
{
}
#endif                          /* nPROD */


void
host_supply_dfa_filename IFN1(char *, filename)

{
}

static BOOL bool_dummy_func() {}
static SHORT short_dummy_func() {}
static VOID void_dummy_func() {}


ERRORFUNCS dummy_error_funcs =
{

        short_dummy_func,
        short_dummy_func,
        short_dummy_func

};

KEYBDFUNCS dummy_keybd_funcs =
{

        void_dummy_func,
        void_dummy_func,
        void_dummy_func,
        void_dummy_func,
        void_dummy_func,
        void_dummy_func

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sas.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Sun4 SAS initialization
 *
 * Description	: Initialize the host side of sas.
 *
 * Author	: A. Guthrie
 *
 * Notes	: None
 */

static char SccsID[]="@(#)sun4_sas.c	1.3 5/7/91 Copyright Insignia Solutions Ltd.";

#include <sys/types.h>
#include "xt.h"
#include "sas.h"
#include "debug.h"

LOCAL    UTINY *reserve_for_M = NULL;

//
// Temporary pointer to the start of M.
//

#ifdef SUN_VA
GLOBAL   UTINY *M;
IMPORT   UTINY *self_modify;
#endif

#ifdef HOST_SAS

#undef sas_load
#undef sas_loadw
#undef sas_store
#undef sas_storew
#undef sas_fills
#undef sas_fillsw
#undef sas_hw_at
#undef sas_w_at
#undef sas_dw_at
#undef sas_loads
#undef sas_stores
#undef sas_move_bytes_forward
#undef sas_move_words_forward
#undef sas_move_bytes_backward
#undef sas_move_words_backward
#undef get_byte_addr
#undef inc_M_ptr
#undef M_get_dw_ptr

IMPORT	VOID	sas_load();
IMPORT	VOID	sas_store();
#ifdef SUN_VA
IMPORT	VOID	sas_loadw_swap();
IMPORT	VOID	sas_storew_swap();
#else
IMPORT	VOID	sas_loadw();
IMPORT	VOID	sas_storew();
#endif
IMPORT	VOID	sas_fills();
IMPORT	VOID	sas_fillsw();
IMPORT	half_word	sas_hw_at();
IMPORT	word	sas_w_at();
IMPORT	double_word	sas_dw_at();
IMPORT	VOID	sas_loads();
IMPORT	VOID	sas_stores();
IMPORT	VOID	sas_move_bytes_forward();
IMPORT	VOID	sas_move_words_forward();
IMPORT	VOID	sas_move_bytes_backward();
IMPORT	VOID	sas_move_words_backward();
IMPORT	host_addr Start_of_M_area;

LOCAL	host_addr	forward_get_addr(addr)
host_addr	addr;
{
	return( (host_addr)((long)Start_of_M_area + (long)addr));
}

LOCAL	host_addr	forward_inc_M_ptr(p, off)
host_addr	p;
host_addr	off;
{
	return( (host_addr)((long)p + (long)off) );
}

GLOBAL    SAS_FUNCTIONS host_sas_funcs =
{
	sas_load,
#ifdef SUN_VA
	sas_loadw_swap,
#else
	sas_loadw,
#endif
	sas_store,
#ifdef SUN_VA
	sas_storew_swap,
#else
	sas_storew,
#endif
	sas_fills,
	sas_fillsw,
	sas_hw_at,
	sas_w_at,
	sas_dw_at,
	sas_loads,
	sas_stores,
	sas_move_bytes_forward,
	sas_move_words_forward,
	sas_move_bytes_backward,
	sas_move_words_backward,
	forward_get_addr,
	forward_inc_M_ptr,
	forward_get_addr,
};

#endif /* HOST_SAS */

/*
	Host_sas_init: allocate intel memory space
*/

#define SIXTY_FOUR_K (1024*64) /* For scratch buffer */

//UTINY *host_sas_init(size)
//sys_addr size;
//{
//    return(NULL);
//}

#ifdef SUN_VA
/* This is temporary until removed from sdos.o */
UTINY *host_as_init()
{
	assert0(NO,"host_as_init is defunct - call can be removed");
	return( 0 );
}
#endif /* SUN_VA */

//UTINY *host_sas_term()
//{
//    if(reserve_for_M) free(reserve_for_M);
//
//    return(reserve_for_M = NULL);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sbdsp.c ===
/***************************************************************************
*
*    dsp.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*
***************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
#include "ios.h"
#include "ica.h"
#include "xt.h"
#include "dma.h"
#include "nt_eoi.h"
#include "sim32.h"
#include "nt_vdd.h"
#include "sndblst.h"
#include "nt_sb.h"

/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

BYTE            IdentByte;              // used with DSP_CARD_IDENTIFY
BYTE            ReservedRegister;       // used with DSP_LOAD_RES_REG and DSP_READ_RES_REG
ULONG           PageSize = 0;           // size of pages for VirtualAlloc
RTL_CRITICAL_SECTION  DspLock;

#define LockDsp()    RtlEnterCriticalSection(&DspLock)
#define UnlockDsp()  RtlLeaveCriticalSection(&DspLock)

//
// Event Globals
//

HANDLE          DspWaveSem;          // used by app to indicate data to write
HANDLE          ThreadStarted;          // signalled when thread starts running
HANDLE          ThreadFinished;         // signalled when thread exits
HANDLE          DspResetEvent;
HANDLE          DspResetDone;
HANDLE          DspWavePlayed;

//
// Wave globals
//

UINT            WaveOutDevice;          // device identifier for open and close devices
HWAVEOUT        HWaveOut = NULL;        // the current open wave output device
PCMWAVEFORMAT   WaveFormat = { { WAVE_FORMAT_PCM, 1, 0, 0, 1}, 8};
DWORD           TimeConstant = 0xA6;    // one byte format
DWORD           SBBlockSize = 0x7ff;    // Block size set by apps, always size of transfer-1
DWORD           SBPlaySize;

WAVEHDR         *WaveHdrs;              // pointer to allocated wave headers
ULONG           *WaveBlockSizes;
ULONG           BurstSize;

BOOL            bDspActive = FALSE;     // dsp thread currently active
BOOL            bDspPaused = FALSE;     // dsp paused
BOOL            SbAnswerDMAPosition = FALSE;
BOOL            bWriteBurstStarted = FALSE;

//
// To keep track of the waveout volume changes.  So we can restore the volume
// when closing the waveout device.
//

DWORD           OriginalWaveVol;
DWORD           PreviousWaveVol;

//
// bExitThread - terminate DSP DMA thread. This responses to REAL reset cmd.  TO
//               terminate DSP DMA thread, the bDspReset flag should also be set.
// bDspReset - Indicates Dsp reset cmd is received.  In case that reset is used to
//             exit high speed mode the bExitThread will not be set.
//
BOOL            bExitDMAThread= FALSE;  // Exit DSP DMA thread flag
BOOL            bDspReset = FALSE;
BOOL            bExitAuto = FALSE;
BOOL            bHighSpeedMode = FALSE; // Are we in High Speed transfer mode?

ULONG           DspNextRead;
ULONG           DspNextWrite;
PUCHAR          DspBuffer;
ULONG           DspBufferTotalBursts;
ULONG           DspBufferSize;

//
// The following variables maintain the real sound WaveOutPosition while playing
// a SBBlockSize samples.  It gets reset on every SBBlockSize sample.
//

ULONG           StartingWaveOutPos, PreviousWaveOutPos, NextWaveOutPos;
USHORT          StartingDmaAddr, StartingDmaCount;

//
// records # of dma queries made by app while playing a SBBlockSize samples.
// it helps up figuring out how much, on average, the sample played between
// dam queries.
//

ULONG           DspNumberDmaQueries;
ULONG           DspVirtualInc, DspVirtualIncx;

//
// Determine how much samples can be ignored per SBBlockSize samples.
//

ULONG           EndingDmaValue;

//
// DMA globals to speed up dma update
//

VDD_DMA_INFO DmaInfo;

DMA_ADAPT    *pDmaAdp;
DMA_CNTRL    *pDcp;
WORD         Chan;

#define COMPUTE_INTERRUPT_DELAY(sb)   (1000 * (sb + 1) / WaveFormat.wf.nAvgBytesPerSec + 1)

typedef enum {
    Auto,
    Single,
    None
} DSP_MODE;

DSP_MODE DspMode;

//
//
// DSP State Machines
//

//
// Reset State Machine
//

enum {
    ResetNotStarted = 1,
    Reset1Written
}
ResetState = ResetNotStarted; // state of current reset

//
// Write State Machine
//

enum {
    WriteCommand = 1, // Initial state and after reset
    CardIdent,
    TableMunge,
    LoadResReg,
    SetTimeConstant,
    BlockSizeFirstByte,
    BlockSizeSecondByte,
    BlockSizeFirstByteWrite,
    BlockSizeSecondByteWrite,
    BlockSizeFirstByteRead,
    BlockSizeSecondByteRead,
    MidiOutPoll
}
DSPWriteState = WriteCommand; // state of current command/data being written

//
// Read State Machine
//

enum {
    NothingToRead = 1, // initial state and after reset
    Reset,
    FirstVersionByte,
    SecondVersionByte,
    ReadIdent,
    ReadResReg
}
DSPReadState = NothingToRead; // state of current command/data being read

//
// Wave function prototypes
//

BOOL
OpenWaveDevice(
    DWORD
    );

VOID
ResetWaveDevice(
    VOID
    );

VOID
CloseWaveDevice(
    VOID
    );

BOOL
TestWaveFormat(
    DWORD sampleRate
    );

BOOL
SetWaveFormat(
    VOID
    );

VOID
WaitOnWaveOutIdle(
    VOID
    );

VOID
PrepareHeaders(
    VOID
    );

VOID
UnprepareHeaders(
    VOID
    );

VOID
PauseDMA(
    VOID
    );

VOID
ContinueDMA(
    VOID
    );

ULONG
GetDMATransferAddress(
    VOID
    );

BOOL
QueryDMA(
    PVDD_DMA_INFO pDmaInfo
    );

BOOL
SetDMACountAddr(
    PVDD_DMA_INFO pDmaInfo
    );

VOID
SetDMAStatus(
    PVDD_DMA_INFO pDmaInfo,
    BOOL requesting,
    BOOL tc
    );

VOID
DmaDataToDsp(
    DSP_MODE mode
    );

BOOL
StartDspDmaThread(
    DSP_MODE mode
    );

VOID
StopDspDmaThread(
    BOOL wait
    );

DWORD WINAPI
DspThreadEntry(
    LPVOID context
    );

VOID
ExitAutoMode(
    VOID
    );

BOOL
GetWaveOutPosition(
    PULONG pPos
    );

BOOL
GenerateHdrs(
    ULONG BlockSize
    )

/*++

Routine Description:

    This function allocates memory for DspBuffer and header.  It also free
    allocated memory.  This routine is caled when we need to resize the Dspbuffer .

Arguments:

    BlockSize - the Size of the DspBuffer

Return Value:

    Success or failure.

--*/

{
    BYTE *pDataInit;
    ULONG i;

    //
    // Align the blocksize on Page boundary
    //

    BlockSize = (( BlockSize + PageSize - 1) / PageSize) * PageSize;
    dprintf2(("Genereate Header size %x", BlockSize));

    //
    // Free allocated buffers, if any
    //

    if (DspBuffer) {
        VirtualFree(DspBuffer, 0, MEM_RELEASE);
    }
    if (WaveHdrs) {
        VirtualFree(WaveHdrs,  0, MEM_RELEASE);
    }
    if (WaveBlockSizes) {
        VirtualFree(WaveBlockSizes,  0, MEM_RELEASE);
    }

    //
    // malloc DspBuffer and determine total number of bursts supported
    // by the buffer.
    //

    DspBuffer = (UCHAR *) VirtualAlloc(NULL,
                                       BlockSize,
                                       MEM_RESERVE | MEM_COMMIT,
                                       PAGE_READWRITE);
    if (DspBuffer == NULL) {
        dprintf1(("Unable to allocate DspBuffer memory"));
        return FALSE;
    }

    DspBufferTotalBursts = BlockSize / BurstSize;

    //
    // malloc WaveHdrs
    //

    WaveHdrs = (WAVEHDR *) VirtualAlloc(NULL,
                                        DspBufferTotalBursts * sizeof(WAVEHDR),
                                        MEM_RESERVE | MEM_COMMIT,
                                        PAGE_READWRITE);
    if (WaveHdrs == NULL) {
        dprintf1(("Unable to allocate WaveHdr memory"));
        VirtualFree(DspBuffer, 0, MEM_RELEASE);
        DspBuffer = NULL;
        return FALSE;
    }

    WaveBlockSizes = (ULONG *) VirtualAlloc(NULL,
                                            DspBufferTotalBursts * sizeof(ULONG),
                                            MEM_RESERVE | MEM_COMMIT,
                                            PAGE_READWRITE);
    if (WaveBlockSizes == NULL) {
        dprintf1(("Unable to allocate WaveBlockSize  memory"));
        VirtualFree(DspBuffer, 0, MEM_RELEASE);
        VirtualFree(WaveHdrs,  0, MEM_RELEASE);
        DspBuffer = NULL;
        WaveHdrs = NULL;
        return FALSE;
    }

    //
    // Initialize WaveHdrs
    //

    pDataInit = DspBuffer;
    for (i = 0; i < DspBufferTotalBursts; i++) {
        WaveHdrs[i].dwBufferLength = BurstSize;
        WaveHdrs[i].lpData =  pDataInit;
        WaveHdrs[i].dwFlags = 0;        // Must be zero to call PrepareHeader
        WaveHdrs[i].dwLoops = 0;
        WaveHdrs[i].dwUser  = 0;
        pDataInit = (BYTE *) ((ULONG)pDataInit + BurstSize);
    }

    DspBufferSize = BlockSize;
    DspNextRead = DspBufferTotalBursts - 1;
    DspNextWrite = 0;

    return TRUE;
}

BOOL
PrepareWaveInitialization(
    VOID
    )

/*++

Routine Description:

    This function initializes the required resources for playing wave music.
    It does not actually initialize the wave out device.

Arguments:

    None.

Return Value:

    Success or failure.

--*/

{
    BYTE *pDataInit;
    ULONG i;
    SYSTEM_INFO SystemInfo;

    if (PageSize == 0) {
        GetSystemInfo(&SystemInfo);
        PageSize = SystemInfo.dwPageSize;
        InitializeCriticalSection(&DspLock);

        //
        // Initialize DMA globals
        //

        pDmaAdp  = dmaGetAdaptor();
        pDcp     = &pDmaAdp->controller[dma_physical_controller(SbDmaChannel)];
        Chan     = dma_physical_channel(SbDmaChannel);
    }

    //
    // Allocate WaveOut resources
    //

    BurstSize = AUTO_BLOCK_SIZE;
    if (GenerateHdrs(MAX_WAVE_BYTES)) {

        //
        // create wave synchronization events
        //

        DspWaveSem = CreateSemaphore(NULL, 0, 100, NULL);
        ThreadStarted = CreateEvent(NULL, FALSE, FALSE, NULL);
        ThreadFinished = CreateEvent(NULL, FALSE, FALSE, NULL);
        DspResetEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        DspResetDone = CreateEvent(NULL, FALSE, FALSE, NULL);
        DspWavePlayed = CreateEvent(NULL, FALSE, FALSE, NULL);
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
CleanUpWave(
    VOID
    )

/*++

Routine Description:

    This function cleans up the dsp process.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // stop any active threads
    //

    bDspReset = TRUE;
    bExitDMAThread = TRUE;
    ResetDSP();

    //
    // close synchronization events
    //

    CloseHandle(DspWaveSem);
    CloseHandle(ThreadStarted);
    CloseHandle(ThreadFinished);
    CloseHandle(DspResetEvent);
    CloseHandle(DspResetDone);
    CloseHandle(DspWavePlayed);

    //
    // Release memory resources
    //

    VirtualFree(DspBuffer, 0, MEM_RELEASE);
    VirtualFree(WaveBlockSizes, 0, MEM_RELEASE);
    VirtualFree(WaveHdrs,  0, MEM_RELEASE);
    WaveHdrs = NULL;
    WaveBlockSizes = NULL;
    DspBuffer = NULL;
}

VOID
DspReadStatus(
    BYTE * data
    )

/*++

Routine Description:

    This function determines the status based on the read state machine and
    returns either Ready or Busy.

Arguments:

    data - supplies a pointer to a byte to receive the status.

Return Value:

    None.

--*/

{
    //
    // See if we think there is something to read
    //

    *data = DSPReadState != NothingToRead ? 0xFF : 0x7F;
}

VOID
DspReadData(
    BYTE * data
    )

/*++

Routine Description:

    This function returns the desired data based on the read state machine and
    updates the read state machine.

Arguments:

    data - supplies a pointer to a byte to receive the data.

Return Value:

    None.

--*/

{
    switch (DSPReadState) {
    case NothingToRead:
        *data = 0xFF;
        break;

    case Reset:
        *data = 0xAA;
        DSPReadState = NothingToRead;
        dprintf0(("rd Reset"));
        break;

    case FirstVersionByte:
        *data = (BYTE)(SB_VERSION / 256);
        DSPReadState = SecondVersionByte;
        dprintf0(("rd 1st Version"));
        break;

    case SecondVersionByte:
        *data = (BYTE)(SB_VERSION % 256);
        DSPReadState = NothingToRead;
        dprintf0(("rd 2nd Version"));
        break;

    case ReadIdent:
        *data = ~IdentByte;
        DSPReadState = NothingToRead;
        dprintf0(("rd Id"));
        break;

    case ReadResReg:
        *data = ReservedRegister;
        DSPReadState = NothingToRead;
        dprintf0(("rd RsvdReg"));
        break;

    default:
        dprintf1(("Unrecognized read state"));
    }

}

VOID
DspResetWrite(
    BYTE data
    )

/*++

Routine Description:

    This function resets the sound blaster.  If reset was received
    in HighSpeed mode, the reset is used to exit high speed mode.

Arguments:

    data - supplies data to control how the reset should be done.

Return Value:

    None.

--*/

{
    if (data == 1) {
        ResetState = Reset1Written;
    } else if (ResetState == Reset1Written && data == 0) {
        ResetState = ResetNotStarted;
        bDspReset = TRUE;

        //
        // Some games reset DSP on every single cycle out.
        //

        if (!bHighSpeedMode) {
            bExitDMAThread = TRUE;
        }
        ResetAll(); // OK - reset everything
    }
}

VOID
DspWrite(
    BYTE data
    )

/*++

Routine Description:

    This function handles apps write data to dsp write port.

Arguments:

    data - supplies data to write to dsp write port.

Return Value:

    None.

--*/

{
    static DWORD blockSize;

    switch (DSPWriteState) {
    case WriteCommand:
        dprintf0(("wt CMD"));
        WriteCommandByte(data);
        break;

    case MidiOutPoll:
        dprintf0(("wt MIDI Byte"));
        BufferMidi(data);
        DSPWriteState = WriteCommand;
        break;

    case CardIdent:
        dprintf0(("wt ID"));
        IdentByte = data;
        DSPReadState = ReadIdent;
        DSPWriteState = WriteCommand;
        break;

    case TableMunge:
        dprintf0(("wt TblMunge"));
        TableMunger(data);
        DSPWriteState = WriteCommand;
        break;

    case LoadResReg:
        dprintf0(("wt RsvReg"));
        ReservedRegister = data;
        DSPWriteState = WriteCommand;
        break;

    case SetTimeConstant:
        dprintf0(("wr TmCnst"));
        TimeConstant =  (DWORD)data;
        dprintf2(("Time constant is %X", TimeConstant));
        dprintf2(("Set sampling rate %d", GetSamplingRate()));
        DSPWriteState = WriteCommand;
        break;

    case BlockSizeFirstByte:
        dprintf0(("wt 1st Blksize"));
        blockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByte;
        break;

    case BlockSizeSecondByte:
        dprintf0(("wt 2nd Blksize"));
        SBBlockSize = blockSize + (((DWORD)data) << 8);

        DSPWriteState = WriteCommand;
        dprintf2(("Block size = 0x%x", SBBlockSize));
        break;

    case BlockSizeFirstByteWrite:
        dprintf0(("wt 1st Blksize single"));
        blockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByteWrite;
        break;

    case BlockSizeSecondByteWrite:
        dprintf0(("wt 2nd Blksize single"));
        SBBlockSize = blockSize + (((DWORD)data) << 8);

        DSPWriteState = WriteCommand;
        dprintf2(("Block size = 0x%x, Single Cycle starting", SBBlockSize));
        if (SBBlockSize <= 0x10) {

            //
            // this is a hack to convince some apps a sb exists
            //

            if (SBBlockSize > 0) {
                VDD_DMA_INFO dmaInfo;

                QueryDMA(&dmaInfo);
                dmaInfo.count -= (WORD)(SBBlockSize + 1);
                dmaInfo.addr += (WORD)(SBBlockSize + 1);

                SetDMACountAddr(&dmaInfo);

                if (dmaInfo.count == 0xffff) {
                    SetDMAStatus(&dmaInfo, TRUE, TRUE);
                }
            }
            GenerateInterrupt(2);  // 2ms to play the 0x10 bytes data
            break;
        }
        DisplaySbMode(DISPLAY_SINGLE);
        StartDspDmaThread(Single);
        break;

    case BlockSizeFirstByteRead:
        dprintf0(("wt 1st IN Blksize"));
        blockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByteRead;
        break;

    case BlockSizeSecondByteRead:
        dprintf0(("wt 2nd IN Blksize"));
        SBBlockSize = blockSize + (((DWORD)data) << 8);

        DSPWriteState = WriteCommand;
        dprintf2(("IN Blksize set to 0x%x", SBBlockSize));
        // this is a hack to convince some apps a sb exists
        if (SBBlockSize <= 0x10) {
            ULONG dMAPhysicalAddress;

            if ((dMAPhysicalAddress=GetDMATransferAddress()) != -1L) {
                *(PUCHAR)dMAPhysicalAddress = 0x80;
            }
            GenerateInterrupt(2);
        }
        // NOt implemented
        break;

    case MIDI_READ_POLL:
    case MIDI_READ_INTERRUPT:
    case MIDI_READ_TIMESTAMP_POLL:
    case MIDI_READ_TIMESTAMP_INTERRUPT:
        //
        // These commands we will never return anything for since
        // we have nothing to get MIDI data from.  We simply
        // accept the command, but never respond - as if there
        // were no MIDI hardware connected to a real SB.
        // Since we never respond, we don't have to handle
        // the interrupt or timestamp versions differently.
        //
        dprintf2(("Cmd-Midi non UART read"));
        break;

    case MIDI_READ_POLL_WRITE_POLL_UART:
    case MIDI_READ_INTERRUPT_WRITE_POLL_UART:
    case MIDI_READ_TIMESTAMP_INTERRUPT_WRITE_POLL_UART:
        dprintf2(("Cmd-Midi UART I/O xxx"));
        break;

    case MIDI_WRITE_POLL:
        // Specifies that next byte will be a Midi out data
        dprintf2(("Cmd-MIDI out poll"));
        DSPWriteState = MidiOutPoll;
        break;

    default:
        dprintf1(("Unrecognized DSP write state %x", DSPWriteState));
    }
}

VOID
WriteCommandByte(
    BYTE command
    )

/*++

Routine Description:

    This function handles command sent to DSP. Mainly, it dispatches to
    its worker functions.

Arguments:

    command - supplies command.

Return Value:

    None.

--*/

{
    switch (command) {
    case DSP_GET_VERSION:
        dprintf2(("Cmd-GetVer"));
        DSPReadState = FirstVersionByte;
        break;

    case DSP_CARD_IDENTIFY:
        dprintf2(("Cmd-Id"));
        DSPWriteState = CardIdent;
        break;

    case DSP_TABLE_MUNGE:
        dprintf2(("Cmd-Table Munge"));
        DSPWriteState = TableMunge;
        break;

    case DSP_LOAD_RES_REG:
        dprintf2(("Cmd-Wt Res Reg"));
        DSPWriteState = LoadResReg;
        break;

    case DSP_READ_RES_REG:
        dprintf2(("Cmd-Rd Res Reg"));
        DSPReadState = ReadResReg;
        break;

    case DSP_GENERATE_INT:
        dprintf2(("Cmd-GenerateInterrupt"));
        GenerateInterrupt(1);
        break;

    case DSP_SPEAKER_ON:
        dprintf2(("Cmd-Speaker ON"));
        SetSpeaker(TRUE);
        break;

    case DSP_SPEAKER_OFF:
        dprintf2(("Cmd-Speaker OFF"));
        SetSpeaker(FALSE);
        break;

    case DSP_SET_SAMPLE_RATE:
        dprintf2(("Cmd-Set Sample Rate"));
        DSPWriteState = SetTimeConstant;
        break;

    case DSP_SET_BLOCK_SIZE:
        dprintf2(("Cmd-Set Block Size"));
        DSPWriteState =  BlockSizeFirstByte;
        break;

    case DSP_PAUSE_DMA:
        dprintf2(("Cmd-Pause DMA"));
        PauseDMA();
        break;

    case DSP_CONTINUE_DMA:
        dprintf2(("Cmd - Continue DMA"));
        ContinueDMA();
        break;

    case DSP_STOP_AUTO:
        dprintf2(("Cmd- Exit Auto-Init"));
        bExitAuto = TRUE;
        //ExitAutoMode();
        break;

    case DSP_WRITE:
        dprintf2(("Cmd- DSP OUT"));
        DSPWriteState = BlockSizeFirstByteWrite;
        break;

    case DSP_WRITE_HS:
        dprintf2(("Cmd- DSP HS OUT"));
        bHighSpeedMode = TRUE;
        DisplaySbMode(DISPLAY_HS_SINGLE);
        StartDspDmaThread(Single);
        break;

    case DSP_WRITE_AUTO:
        dprintf2(("Cmd-DSP OUT Auto"));
        if (SBBlockSize <= 0x10) {

            //
            // this is a hack to convince some apps a sb exists
            //

            if (SBBlockSize > 0) {
                VDD_DMA_INFO dmaInfo;

                QueryDMA(&dmaInfo);
                dmaInfo.count -= (WORD)(SBBlockSize + 1);
                dmaInfo.addr += (WORD)(SBBlockSize + 1);

                SetDMACountAddr(&dmaInfo);

                if (dmaInfo.count == 0xffff) {
                    SetDMAStatus(&dmaInfo, TRUE, TRUE);
                }
            }
            GenerateInterrupt(2);  // 2ms to play the 0x10 bytes
            break;
        }
        DisplaySbMode(DISPLAY_AUTO);
        StartDspDmaThread(Auto);
        break;

    case DSP_WRITE_HS_AUTO:
        dprintf2(("Cmd-DSP HS OUT AUTO"));
        bHighSpeedMode = TRUE;
        DisplaySbMode(DISPLAY_HS_AUTO);
        StartDspDmaThread(Auto);
        break;

    case DSP_READ:
        dprintf2(("Cmd- DSP IN - non Auto"));
        DSPWriteState = BlockSizeFirstByteRead;
        break;

    default:
        dprintf2(("Unrecognized DSP command %2X", command));
    }
}

VOID
ResetDSP(
    VOID
    )

/*++

Routine Description:

    This function handles DSP reset command. It resets
    threads/globals/events/state-machines to initial state.

Arguments:

    command - supplies command.

Return Value:

    None.

--*/

{
    //
    // Wait till DSP thread recognize the reset command
    //

    if (bDspActive) {
        SetEvent(DspResetEvent);
        if (bExitDMAThread) {
            //ReleaseSemaphore(DspWaveSem, 1, NULL); // Let go dsp thread
            WaitForSingleObject(DspResetDone, INFINITE);
        }
    }

    if (bExitDMAThread) {

        //
        // if this is a real RESET command, not just reset to exit HighSpeed mode
        //

        //
        // Stop any active DMA threads.  Need to wait till the thread exit.
        //

        StopDspDmaThread(TRUE);

        //
        // Set events and globals to initial state
        //

        CloseHandle(DspWaveSem);
        DspWaveSem=CreateSemaphore(NULL, 0, 100, NULL);
        ResetEvent(ThreadStarted);
        ResetEvent(ThreadFinished);
        ResetEvent(DspResetEvent);

        HWaveOut = NULL;
        TimeConstant = 0xA6;   //(256 - 1000000/11025)
        WaveFormat.wf.nSamplesPerSec = 0;
        WaveFormat.wf.nAvgBytesPerSec = 0;

        bDspActive = FALSE;
        bExitDMAThread= FALSE;
    }

    DspMode = None;
    SBBlockSize = 0x7ff;
    DspNextRead = DspBufferTotalBursts - 1;
    DspNextWrite = 0;
    bDspPaused = FALSE;
    bDspReset = FALSE;
    ResetEvent(DspResetDone);
    ResetEvent(DspWavePlayed);
    NextWaveOutPos = 0;

    //
    // Reset state machines
    //

    DSPReadState = Reset;
    DSPWriteState = WriteCommand;

    //
    // To start accept command again.
    //

    SbAnswerDMAPosition = FALSE;
    bHighSpeedMode = FALSE;
}

VOID
TableMunger(
    BYTE data
    )

/*++

Routine Description:

    This function munges (changes) a jump table in apps code,
    Algorithm from sbvirt.asm in MMSNDSYS.

Arguments:

    data - supplies data.

Return Value:

    None.

--*/

{
    static BYTE TableMungeData;
    static BOOL TableMungeFirstByte = TRUE; // munging first or second byte
    BYTE comp, dataCopy;
    VDD_DMA_INFO dMAInfo;
    ULONG dMAPhysicalAddress;

    if (TableMungeFirstByte) {
        dprintf3(("Munging first byte"));
        dataCopy = data;
        dataCopy = dataCopy & 0x06;
        dataCopy = dataCopy << 1;
        if (data & 0x10) {
            comp = 0x40;
        } else {
            comp = 0x20;
        }
        comp = comp - dataCopy;
        data = data + comp;
        TableMungeData = data;

        // Update memory (code table) with munged data
        dprintf3(("Writing first byte"));
        if ((dMAPhysicalAddress=GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get dma address"));
            return;
        }
        CopyMemory((PVOID)dMAPhysicalAddress, &data, 1);

        // Update virtual DMA status
        QueryDMA(&dMAInfo);
        dMAInfo.count = dMAInfo.count - 1;
        dMAInfo.addr = dMAInfo.addr + 1;
        SetDMACountAddr(&dMAInfo);
        TableMungeFirstByte = FALSE;
    } else {
        dprintf3(("Munging second byte"));
        data = data ^ 0xA5;
        data = data + TableMungeData;
        TableMungeData = data;

        // Update memory (code table) with munged data
        dprintf3(("Writing second byte"));
        if ((dMAPhysicalAddress=GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get dma address"));
            return;
        }
        CopyMemory((PVOID)dMAPhysicalAddress, &data, 1);

        // Update virtual DMA status
        QueryDMA(&dMAInfo);
        dMAInfo.count = dMAInfo.count - 1;
        dMAInfo.addr = dMAInfo.addr + 1;
        SetDMACountAddr(&dMAInfo);
        if (dMAInfo.count==0xFFFF) {
            SetDMAStatus(&dMAInfo, FALSE, TRUE);
        }
        TableMungeFirstByte = TRUE;
    }
}

DWORD
GetSamplingRate(
    VOID
    )

/*++

Routine Description:

    This function gets sampling rate from time constant.
    Sampling rate = 1000000 / (256 - Time constant)

Arguments:

    None.

Return Value:

    Sampling rate.

--*/

{
    DWORD samplingRate;

    if (TimeConstant == 0) {
        TimeConstant = 1;
    }
    if (TimeConstant > 0xea) {
        TimeConstant = 0xea;
    }

    switch (TimeConstant) {

    //
    // Now we set all time constants that set sample rates that
    // are just above and just below the standard sample rates
    // to the standard rates.  This will prevent unnecessary
    // sample rate conversions/searches.
    //

    //
    // All of these can be interpreted as "8000"
    //

    case 0x82: // 7936 Hz
    case 0x83: // 8000
    case 0x84: // 8065 Hz
        samplingRate = 8000;
        break;

    //
    // Both of these can be interpreted as "11025"
    //

    case 0xA5: // 10989
    case 0xA6: // 11111 Hz
        samplingRate = 11025;
        break;

    //
    // Both of these can be interpreted as "22050"
    //

    case 0xD2: // 21739 Hz
    case 0xD3: // 22222 Hz
        samplingRate = 22050;
        break;

    //
    // Both of these can be interpreted as "44100"
    //

    case 0xE9: // 43478 Hz
    case 0xEA: // 45454 Hz
        samplingRate = 44100;
        break;

    //
    // A very non standard rate is desired.  So give them what they
    // asked for.
    //

    default:
        samplingRate = 1000000 / (256 - TimeConstant);
        break;
    }
    return samplingRate;
}

VOID
GenerateInterrupt(
    ULONG delay
    )

/*++

Routine Description:

    This function generates device interrupt on dma channel SM_INTERRUPT
    on ICA_MASTER device.  The interrupt will be dispatched before the control
    returns to the emulation thread.

Arguments:

    delay - specifies the delay to generate delayed interrupt.

Return Value:

    None.

--*/

{
    //
    // Generate an interrupt on the master controller
    //

    if (delay == 0) {
        dprintf2(("Generating interrupt"));
        ica_hw_interrupt(ICA_MASTER, SbInterrupt, 1);
    } else {
        dprintf2(("Generating interrupt with %x ms delay", delay));
        host_DelayHwInterrupt(SbInterrupt, 1, delay * 1000);
    }
}

VOID
AutoInitEoiHook(
    int IrqLine,
    int CallCount
    )

/*++

Routine Description:

    THis function is the callback function when application EOI SB_INTERRUPT line.
    This routine is ONLY used for auto-init mode. Note we try to do the Dam transfer
    in apps' context to better sync up the sound with apps.

Arguments:

    IrqLine - the irq line for the EOI command

    CallCout - not use

Return Value:

    None.

--*/

{
    if (SetWaveFormat()) {

        //
        // If wave format changed, we need to unprepare headers, close the
        // current wave device and reopen a new one.
        //

        dprintf2(("auto init CHANGING Wave Out device"));
        CloseWaveDevice();
        if (HWaveOut == NULL) {
            OpenWaveDevice((DWORD)0);
            PrepareHeaders();
        }
    }

    if (bDspPaused == FALSE) {
        DmaDataToDsp(Auto);
    }
}

VOID
DmaDataToDsp(
    DSP_MODE Mode
    )

/*++

Routine Description:

    This function transfers app's wave data from DMA buffer to our internal
    wave buffer.

Arguments:

    Mode - specifies the dsp mode for the transfer.

Return Value:

    None.

--*/

{
    LONG i, bursts, lastBurstSize;
    DWORD dmaPhysicalStart;       // the starting address for this transfer
    DWORD dmaCurrentPosition;     // where we are currently reading from
    ULONG intIndex;               // the size of the DMA memory-1
    UCHAR mask;

    //
    // If Auto-init mode, check for reset to exit HS auto-init mode or real reset.
    // Since in Auto-init mode, we most likely are in reader context.
    //

    if (DspMode == Auto) {
        if (bDspReset) {
            return;
        }
    }

    LockDsp();
    QueryDMA(&DmaInfo);
    StartingDmaAddr = DmaInfo.addr;
    StartingDmaCount = DmaInfo.count;
    if (StartingDmaCount < SBBlockSize) {
        SBPlaySize = StartingDmaCount;
    } else {
        SBPlaySize = SBBlockSize;
    }
    if (SBPlaySize > 0xff) {
        SbAnswerDMAPosition = TRUE;
    }
    UnlockDsp();

    //
    // Remember the dma state to update dma controller addr and count later
    //

    mask = 1 << SbDmaChannel;
    if (DmaInfo.count == 0xFFFF || DmaInfo.count == 0 || (DmaInfo.mask & mask)) {

        //
        // Nothing to do.
        //
        return;
    }

    dprintf2(("Wt: xfer DMA data to DspBuffer"));

    //
    // convert DMA addr from 20 bit address to physical addr
    //

    i = (((DWORD)DmaInfo.page) << (12 + 16)) + DmaInfo.addr;
    if ((dmaPhysicalStart = (ULONG)Sim32pGetVDMPointer(i, 0)) == -1L) {
        dprintf1(("Unable to get transfer address"));
        return;
    }

    dprintf3(("Wt: DMA Virtual= %4X, Physical= %4X, size= %4X BlkSize = %4x",
              DmaInfo.addr, dmaPhysicalStart, DmaInfo.count, SBBlockSize));

    dmaCurrentPosition = dmaPhysicalStart;

    //
    // Determine # of bursts in the DMA data block
    //

    bursts = (SBPlaySize + 1) / BurstSize;
    if (lastBurstSize = (SBPlaySize + 1) % BurstSize) {
        bursts++;
    }
    WaveBlockSizes[DspNextWrite] = SBPlaySize; // Remember the block size

    if (WaveHdrs[DspNextWrite].dwFlags & WHDR_INQUEUE) {

        //
        // we have use all the wave headers.
        // This is a rare case, we will simply reset the WaveOut device.
        // NOTE, this should never happen.  But, I have seen case(s) that one
        // or two blocks in the middle of DspBuffer have the WHDR_INQUEUE bit
        // set.  This could be because apps pause DMA before the previous wave
        // data is played and restart dsp with new wave data.
        // If we are not running out of header, we will reset it until we have
        // to such that the sound can be played longer.
        //

        ResetWaveDevice();
        //if (WaveHdrs[DspNextWrite].dwFlags & WHDR_INQUEUE) _asm { int 3}
    }

    //
    // Copy the BlockSize data from DMA buffer to DspBuffer.
    //

    for (i = 0; i < bursts; i++) {

        dprintf2(("Write: Current burst Block at %x", DspNextWrite));

        //
        // copy the current burst to dspbuffer.  If this is the last burst
        // only copy the size needed.
        //

        if (i == bursts - 1) {
            RtlCopyMemory(DspBuffer + DspNextWrite * BurstSize,
                          (CONST VOID *)dmaCurrentPosition,
                          lastBurstSize ? lastBurstSize : BurstSize);
        } else {
            RtlCopyMemory(DspBuffer + DspNextWrite * BurstSize,
                          (CONST VOID *)dmaCurrentPosition,
                          BurstSize);
            dmaCurrentPosition += BurstSize;
        }

        DspNextWrite++;
        DspNextWrite %= DspBufferTotalBursts;
        ReleaseSemaphore(DspWaveSem, 1, NULL); // Let go dsp thread

    }


    //
    // Give reader thread a break except when the blocksize is small.
    //

    if (SBPlaySize >= 0x1ff) {

        Sleep(0);
    }

}

VOID
SetSpeaker(
    BOOL On
    )

/*++

Routine Description:

    This function sets the speaker on or off.

Arguments:

    On - supplies a boolean value to specify speaker state.

Return Value:

    None.

--*/

{
    if (HWaveOut) {
        if (On) {
            if (PreviousWaveVol == 0) {
                SetWaveOutVolume((DWORD)0xffffffffUL);
            }
        } else {
            SetWaveOutVolume((DWORD)0x00000000UL);
        }
    }
    return;
}

VOID
PauseDMA(
    VOID
    )

/*++

Routine Description:

    This function pauses single-cycle or Auto-Init DMA.

    Note, we don't support PauseDMA and ContinueDMA just for PAUSE.
    We expect apps PauseDMA, StartSingleCycle and optionally ContinueDMA.

Arguments:

    None.

Return Value:

    None

--*/

{
    ULONG position;

    bDspPaused = TRUE;

    if (DspMode == Single && SbAnswerDMAPosition) {
        if (GetWaveOutPosition(&position)) {
            position -= StartingWaveOutPos;
            position = SBPlaySize + 1 - position;
            if (position > BurstSize / 2) {
                Sleep(0);
            }
        }
    }
}

VOID
ContinueDMA(
    VOID
    )

/*++

Routine Description:

    This function continues paused single-cycle or Auto-Init DMA.

    Note, we don't support PauseDMA and ContinueDMA just for PAUSE.
    We expect apps PauseDMA, StartSingleCycle and optionally ContinueDMA.

Arguments:

    None.

Return Value:

    None.

--*/

{
    bDspPaused = FALSE;
    Sleep(0);
}

BOOL
FindWaveDevice(
    VOID
    )

/*++

Routine Description:

    This function finds a suitable wave output device.

Arguments:

    None.

Return Value:

    TRUE - if device is found.
    FALSE - no device is found.

--*/

{
    UINT numDev;
    UINT device;
    WAVEOUTCAPS wc;

    numDev = GetNumDevsProc();

    for (device = 0; device < numDev; device++) {
        if (MMSYSERR_NOERROR == GetDevCapsProc(device, &wc, sizeof(wc))) {

            //
            // Need 11025 and 44100 for device
            //

            if ((wc.dwFormats & (WAVE_FORMAT_1M08 | WAVE_FORMAT_4M08)) ==
                (WAVE_FORMAT_1M08 | WAVE_FORMAT_4M08)) {
                WaveOutDevice = device;
                return (TRUE);
            }
        }
    }

    dprintf1(("Wave device not found"));
    return (FALSE);
}

BOOL
OpenWaveDevice(
    DWORD CallbackFunction
    )

/*++

Routine Description:

    This function opens wave device and starts synchronization thread.

Arguments:

    CallbackFunction - specifies the callback function

Return Value:

    TRUE - if success otherwise FALSE.

--*/

{
    UINT rc;
    HANDLE tHandle;
    if (CallbackFunction) {
        rc = OpenProc(&HWaveOut, (UINT)WaveOutDevice, (LPWAVEFORMATEX)
                      &WaveFormat, CallbackFunction, 0, CALLBACK_FUNCTION);
    } else {
        rc = OpenProc(&HWaveOut, (UINT)WaveOutDevice, (LPWAVEFORMATEX)
                      &WaveFormat, 0, 0, CALLBACK_NULL);
    }

    if (rc != MMSYSERR_NOERROR) {
        dprintf1(("Failed to open wave device - code %d", rc));
        return (FALSE);
    } else {

        //
        // Remember the original waveout volume setting.
        // Note we don't care if the device supports it.  If it does not
        // all the setvolume calls will fail and we won't change it anyway.
        //

        GetVolumeProc(HWaveOut, &OriginalWaveVol);
        PreviousWaveVol = OriginalWaveVol;
    }
    NextWaveOutPos = 0;
    return (TRUE);
}

VOID
SetWaveOutVolume(
    DWORD Volume
    )

/*++

Routine Description:

    This function sets WaveOut volume

Arguments:

    Volume - specifies the volume scale

Return Value:

    None.

--*/

{
    DWORD currentVol;

    if (HWaveOut) {
        if (GetVolumeProc(HWaveOut, &currentVol)) {
            if (currentVol != PreviousWaveVol) {
                //
                // SOmeone changed the volume besides NTVDM
                //

                OriginalWaveVol = currentVol;
            }
            PreviousWaveVol = Volume;
            SetVolumeProc(HWaveOut, Volume);
        }
    }
}

VOID
ResetWaveDevice(
    VOID
    )

/*++

Routine Description:

    This function resets wave device.

Arguments:

    None.

Return Value:

    None.

--*/

{

    dprintf3(("Resetting wave device"));
    if (HWaveOut) {
        if (MMSYSERR_NOERROR != ResetProc(HWaveOut)) {
            dprintf1(("Unable to reset wave out device"));
        }
    }
}

VOID
CloseWaveDevice(
    VOID
    )

/*++

Routine Description:

    This function shuts down and closes wave device.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD currentVol;

    //
    // wait till the MM driver is done with the device and then unprepare
    // the prepared headers and close it.
    //

    if (HWaveOut) {

        dprintf2(("Closing wave device"));

        if (GetVolumeProc(HWaveOut, &currentVol)) {
            if (currentVol == PreviousWaveVol) {
                //
                // If we are the last one changed, volume restore it.
                // otherwise leave it alone.
                //
                SetVolumeProc(HWaveOut, OriginalWaveVol);
            }
        }
        WaitOnWaveOutIdle();
        UnprepareHeaders();
        ResetWaveDevice();

        if (MMSYSERR_NOERROR != CloseProc(HWaveOut)) {
            dprintf1(("Unable to close wave out device"));
        } else {
            HWaveOut = NULL;
        }
    }
}

BOOL
TestWaveFormat(
    DWORD sampleRate
    )

/*++

Routine Description:

    This function tests if current wave device supports the sample rate.

Arguments:

    SampleRate - supplies sample rate to be tested.

Return Value:

    TRUE if current wave device supports sample rate, otherwise FALSE.

--*/

{
    PCMWAVEFORMAT format;

    format = WaveFormat;
    format.wf.nSamplesPerSec = sampleRate;
    format.wf.nAvgBytesPerSec = sampleRate;

    return (MMSYSERR_NOERROR == OpenProc(NULL, (UINT)WaveOutDevice,
                                         (LPWAVEFORMATEX) &format,
                                         0, 0, WAVE_FORMAT_QUERY));
}

BOOL
SetWaveFormat(
    VOID
    )

/*++

Routine Description:

    This function makes sure we've got a device that matches the current
    sampling rate. Returns TRUE if device does NOT support current sampling
    rate and wave format has changed, otherwise returns FALSE

Arguments:

    None.

Return Value:

    TRUE if device does NOT support current sampling rate and wave format
    has changed, otherwise returns FALSE

--*/

{
    DWORD sampleRate;
    DWORD testValue;
    UINT i = 0;

    if (TimeConstant != 0xFFFF) {

        //
        // time constant has been reset since last checked
        //

        sampleRate = GetSamplingRate();
        dprintf2(("Requested sample rate is %d", sampleRate));

        if (sampleRate != WaveFormat.wf.nSamplesPerSec) {  // format has changed
            if (!TestWaveFormat(sampleRate)) {
                dprintf3(("Finding closest wave format"));

                //
                // find some format that works and is close to requested
                //

                for (i=0; i<50000; i++) {
                    testValue = sampleRate-i;
                    if (TestWaveFormat(testValue)) {
                        sampleRate = testValue;
                        break;
                    }
                    testValue = sampleRate+i;
                    if (TestWaveFormat(testValue)) {
                        sampleRate = testValue;
                        break;
                    }
                }
                if (sampleRate!=testValue) {
                    dprintf1(("Unable to find suitable wave format"));
                    return (FALSE);
                }
            }

            //
            // Set the new format if it's changed
            //

            if (sampleRate != WaveFormat.wf.nSamplesPerSec) {
                dprintf2(("Setting %d samples per second", sampleRate));
                WaveFormat.wf.nSamplesPerSec = sampleRate;
                WaveFormat.wf.nAvgBytesPerSec = sampleRate;
                TimeConstant = 0xFFFF;
                return (TRUE);
            }
        }
    }

    TimeConstant = 0xFFFF;
    return (FALSE);
}

BOOL
SetDMACountAddr(
    PVDD_DMA_INFO pDmaInfo
    )

/*++

Routine Description:

    This function updates DMA controller Count and Addr fields.

Arguments:

    DmaInfo - supplies a pointer to a DMA info structure

Return Value:

    TRUE - success.
    FALSE - failure

--*/
{
    pDcp->current_address[Chan][1] = (half_word)HIBYTE(pDmaInfo->addr);
    pDcp->current_address[Chan][0] = (half_word)LOBYTE(pDmaInfo->addr);
    pDcp->current_count[Chan][1] = (half_word)HIBYTE(pDmaInfo->count);
    pDcp->current_count[Chan][0] = (half_word)LOBYTE(pDmaInfo->count);

    //
    // If DMA count is 0xffff and autoinit is enabled, we need to
    // reload the count and address.
    //

    if ((pDcp->current_count[Chan][1] == (half_word) 0xff) &&
        (pDcp->current_count[Chan][0] == (half_word) 0xff)) {

        if (pDcp->mode[Chan].bits.auto_init != 0) {
            pDcp->current_count[Chan][0] = pDcp->base_count[Chan][0];
            pDcp->current_count[Chan][1] = pDcp->base_count[Chan][1];

            pDcp->current_address[Chan][0] = pDcp->base_address[Chan][0];
            pDcp->current_address[Chan][1] = pDcp->base_address[Chan][1];
        }
    }

    return TRUE;
}

BOOL
QueryDMA(
    PVDD_DMA_INFO DmaInfo
    )

/*++

Routine Description:

    This function retrieves virtual DMA states and returns DmaInfo.

Arguments:

    DmaInfo - supplies a pointer to a structure to receive DMA information.

Return Value:

    TRUE - success.
    FALSE - failure

--*/

{
    DmaInfo->addr  = ((WORD)pDcp->current_address[Chan][1] << 8)
                     | (WORD)pDcp->current_address[Chan][0];

    DmaInfo->count = ((WORD)pDcp->current_count[Chan][1] << 8)
                     | (WORD)pDcp->current_count[Chan][0];

    DmaInfo->page   = (WORD) pDmaAdp->pages.page[SbDmaChannel];
    DmaInfo->status = (BYTE) pDcp->status.all;
    DmaInfo->mode   = (BYTE) pDcp->mode[Chan].all;
    DmaInfo->mask   = (BYTE) pDcp->mask;

    dprintf3(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
              DmaInfo->addr, DmaInfo->count, DmaInfo->page, DmaInfo->status,
              DmaInfo->mode, DmaInfo->mask));
    return (TRUE);
}

ULONG
GetDMATransferAddress(
    VOID
    )

/*++

Routine Description:

    This function retrieves and translates a virtual DMA addr to its physical addr.

Arguments:

    None.

Return Value:

    Get DMA transfer address.
    Returns transfer address or -1 on failure.

--*/

{
    ULONG address;
    VDD_DMA_INFO dmaInfo;

    //
    // convert from 20 bit address to 32 bit address
    //

    address = (pDcp->current_address[Chan][1] << 8) | pDcp->current_address[Chan][0];
    address += ((DWORD)pDmaAdp->pages.page[SbDmaChannel]) << (12 + 16);
    address = (ULONG)Sim32pGetVDMPointer(address, 0);

    dprintf3(("Physical Transfer address = %8X", (DWORD)address));
    return (address);
}

VOID
SetDMAStatus(
    PVDD_DMA_INFO DmaInfo,
    BOOL requesting,
    BOOL tc
    )

/*++

Routine Description:

    Update the virtual DMA terminal count and request status.
    Terminal count (tc) is set when DMA count loops to 0xFFFF.
    Request status is set when DMA has data to transfer
    (ignored in auto-init DMA).

Arguments:

    DmaInfo - supplies the dam information

    Requesting - sepcifies if the REQUEST flag should be set.

    tc - specifies if the TC flag should be set

Return Value:

    None.

--*/

{

    if (requesting) {
        DmaInfo->status |= (0x10 << SbDmaChannel); // Requesting
        dprintf3(("DMA set as requesting"));
    } else {
        DmaInfo->status &= ~(0x10 << SbDmaChannel); // Not Requesting
        dprintf3(("DMA set as not requesting"));
    }

    if (tc) {
        DmaInfo->status |= (1 << SbDmaChannel); // tc reached
        dprintf3(("DMA set as terminal count reached"));
    } else {
        DmaInfo->status &= ~(1 << SbDmaChannel); // tc not reached
        dprintf3(("DMA set as terminal count not reached"));
    }
    pDcp->status.all = (BYTE) DmaInfo->status;
}

BOOL
GetWaveOutPosition(
    PULONG pPos
    )
/*++

Routine Description:

    This function calls MM low level api to get the current wave out play back
    position.

Arguments:

    pPos - supplies a point to a ULONG to receive the play back position

Return Value:

    TRUE - success.  Otherwise failed.

--*/

{
    MMTIME mmTime;

    mmTime.wType = TIME_SAMPLES;

    if (MMSYSERR_NOERROR == GetPositionProc(HWaveOut, &mmTime, sizeof(MMTIME))) {
        *pPos = mmTime.u.sample;
        return (TRUE);
    }
    dprintf1(("Get Waveout position failed\n"));
    return (FALSE);
}

VOID
SbGetDMAPosition(
    VOID
    )

/*++

Routine Description:

    This function is the handler for the SB DMA position IO read instruction.  It
    maintains s real waveout position by calling MM api to get the current play back
    position.  It also maintains a virtual waveout position to simulate sound playing
    position in case real sound is not played or too slow.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG position;     // real sound played position
    ULONG offset;       // the amount of sound really played
    ULONG virtOffset;   // the amount of sound virtually/expectedly played

    if (HWaveOut && SbAnswerDMAPosition) {
        while (!bWriteBurstStarted) {
            Sleep(0);
        }
        LockDsp();
        dprintf3(("SbGetDMAPosition"));
        DspNumberDmaQueries++;

        //
        // SbAnswerDMAPosition may change to FALSE after LockDsp()
        //
        if (SbAnswerDMAPosition == FALSE) {
            UnlockDsp();
            return;
        }
        if (SBPlaySize < 0x400) {

            //
            // If block size is smal, do not call GetWaveOutPosition and
            // do not update PreviousWaveOutPos .
            //

            offset = DmaInfo.addr + DspVirtualInc - StartingDmaAddr;
            if (offset < SBPlaySize) {
                DmaInfo.addr += (USHORT)DspVirtualInc;
                DmaInfo.count -= (USHORT)DspVirtualInc;
            } else {
                DmaInfo.addr = (USHORT)StartingDmaAddr + (USHORT)SBPlaySize - 8;
                DmaInfo.count = (USHORT)0xfff7;
            }
            if (offset >= (SBPlaySize * 3 / 4)) {
                Sleep(0);
            }
            dprintf3(("virt addr = %x, count = %x", DmaInfo.addr, DmaInfo.count));
            SetDMACountAddr(&DmaInfo);
            UnlockDsp();
            return;
        }
#if 1
        if (DspMode == Single) {
            PreviousWaveOutPos++;
        }

        offset = DmaInfo.addr - StartingDmaAddr + DspVirtualInc;

        //
        // The algorithm used here is weird but it seems to work.
        // We will come back and revise it later.
        //

        //
        // Virtual sound is approaching to the end.  Slow down
        //

        if (offset >= (SBPlaySize - 0x50)) {
            //Sleep(0);
            DspVirtualInc = 2;
        }

        //
        // Put a limit so we don't overflow the virtual sound position
        //

        if (offset >= SBPlaySize - 0x8) {
            //Sleep(0);
            offset = SBPlaySize - 0x8;
        }

        if (DspVirtualIncx > 0xc0) {
            Sleep(0);
        }
        if (DspVirtualIncx > 0x80) {
            Sleep(0);
#if DESCENT
        } else {
            DspVirtualInc -= 0x5;
            if (DspVirtualInc > 0xf0000000) {           // don't overdone it
                DspVirtualIncx -= 0x8;
                if (DspVirtualIncx > 0xf0000000) {
                    DspVirtualInc = 1;
                } else {
                    DspVirtualInc = DspVirtualIncx;
                }
            }
#endif
        }
        Sleep(0);
#endif
#if 0
    if (SBPlaySize > 0x800) {
        Sleep(0);
    }
        PreviousWaveOutPos++;
        offset = DmaInfo.addr + DspVirtualInc - StartingDmaAddr;
        if (offset < (SBPlaySize / 2)) {
            DmaInfo.addr += (USHORT)DspVirtualInc;
            DmaInfo.count -= (USHORT)DspVirtualInc;
            dprintf3(("virt addr = %x, count = %x", DmaInfo.addr, DmaInfo.count));
            SetDMACountAddr(&DmaInfo);
            //if (offset > (SBPlaySize / 2)) {
            //    Sleep(0);
            //}
        } else if (offset > (SBPlaySize - 0x20)) {
              //Sleep(0);
              DmaInfo.addr = StartingDmaAddr + (USHORT)(SBPlaySize - 0x8);
              DmaInfo.count = StartingDmaCount - (USHORT)(SBPlaySize - 0x8);
              dprintf3(("virt addr = %x, count = %x", DmaInfo.addr, DmaInfo.count));
              SetDMACountAddr(&DmaInfo);
              Sleep(0);
              Sleep(0);
        } else {
            //Sleep(0);
            DmaInfo.addr = StartingDmaAddr + (USHORT)offset;
            DmaInfo.count = StartingDmaCount - (USHORT)offset;
            dprintf3(("virt addr = %x, count = %x", DmaInfo.addr, DmaInfo.count));
            SetDMACountAddr(&DmaInfo);
            Sleep(0);
            Sleep(0);
        }
        UnlockDsp();
        Sleep(0);
        return;
#endif
        dprintf2(("voffset = %x inc = %x\n", offset, DspVirtualInc));

        //
        // Now update the dma controller with our emulation/real position
        //

        DmaInfo.addr = StartingDmaAddr + (USHORT)offset;
        DmaInfo.count = StartingDmaCount - (USHORT)offset;

        SetDMACountAddr(&DmaInfo);
        dprintf3(("INB: AFT Cnt= %x, Addr= %x\n", DmaInfo.count, DmaInfo.addr));

        UnlockDsp();

    }
}

VOID
WaitOnWaveOutIdle(
    VOID
    )
{
    ULONG LastBytesPlayedValue = 0;
    ULONG PhysicalBytesPlayed;

    //
    // Allow the device to finish playing current sounds before nuking buffers
    //

    while (GetWaveOutPosition(&PhysicalBytesPlayed)) {
        if (LastBytesPlayedValue == PhysicalBytesPlayed) {
            break;  // no sounds are playing
        }
        LastBytesPlayedValue = PhysicalBytesPlayed;
        Sleep(1);
    }
}

BOOL
WriteBurst(
    ULONG WriteSize
    )

/*++

Routine Description:

    This function sends a bust of wave data to the multimedia device and
    updates DMA controller accordingly.

Arguments:

    WriteSize - supplies the number of bytes to write to Wave device

Return Value:

    return value of WriteProc MM interface.

--*/

{
    MMRESULT mmResult;
    PWAVEHDR header = &WaveHdrs[DspNextRead];

    dprintf2(("read: write burst at block %x", DspNextRead));


    //
    // Send the data to MM Waveout device
    //

    header->dwBufferLength = WriteSize;
    mmResult = WriteProc(HWaveOut, header, sizeof(WAVEHDR));
    return (mmResult == MMSYSERR_NOERROR);
}

VOID
DspProcessBlock(
    DSP_MODE Mode
    )

/*++

Routine Description:

    This function processes a single block of data as defined by the SB block
    transfer size.

Arguments:

    PreviousHeader - specifies the index of previous header

    TotalNumberOfHeaders - specifies the total number of header prepared.

    BlockSIze - specifies the DSP block transfer size

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG size;
    LONG leftToPlay;
    USHORT dmaVirtualStart;       // what the app thinks the addr is for this transfer
    ULONG dmaSize;                // the size of the DMA memory-1

    DspNextRead = (DspNextRead + 1) % DspBufferTotalBursts;
    leftToPlay = WaveBlockSizes[DspNextRead] + 1;

    //
    // Set up playing position so apps can keep track of the progress.
    // For auto-init, we try not to reset wave out device.  But it is possible
    // that when we get waveout position, the whole wave samples are not completely
    // played.  The StartingWaveOutPos will not be the real starting postion
    // for the new samples.  So, we have code to compute what supposed to be.
    //

    if (DspMode == Single) {
        ResetWaveDevice();
        GetWaveOutPosition(&StartingWaveOutPos);
    } else { // auto-init
        if (NextWaveOutPos == 0) {   // NextWaveOutPos == 0 indicates resetting postion
            ResetWaveDevice();
            GetWaveOutPosition(&StartingWaveOutPos);
        } else {
            StartingWaveOutPos = NextWaveOutPos;
        }
        NextWaveOutPos = StartingWaveOutPos + leftToPlay;
    }

    PreviousWaveOutPos = StartingWaveOutPos;
    if (NextWaveOutPos > 0xfff00000) {

        //
        // if sound position wrapped, reset device and position.
        //

        NextWaveOutPos = 0;
    }

    //
    // Compute virtual incr between dma queries.  It is based on the number of queries
    // made by app while playing previous SBBlocksize samples.
    //

    if (DspNumberDmaQueries == 0) {
        DspVirtualInc = leftToPlay >> 4;
    } else {
        DspVirtualInc = leftToPlay / DspNumberDmaQueries;
        if (leftToPlay > 0x400) {

            //
            // Try to limit the virtual incr such that it won't be too small and too big.
            // Note, the incr is dynamic.  It will be adjusted based on real sound playing
            // rate.
            //

            if (DspVirtualInc < 5) {
                DspVirtualInc = 5;
            } else if (DspVirtualInc > 0x200) {
                DspVirtualInc = 0x200;
            }
        } else {

            //
            // For small block, we will not do any real sound position queries.  So, the
            // virtual incr is totally based on the data we got from playing last block samples.
            //

            if (DspVirtualInc > ((ULONG)leftToPlay / 4)) {
                DspVirtualInc = (ULONG)leftToPlay / 4;
            }
        }
    }

    DspVirtualIncx = DspVirtualInc;     // remember the original virtual incr in case we
                                        // need to fall back to original value.

    dprintf3(("NoQ = %x, Inc = %x\n", DspNumberDmaQueries, DspVirtualInc));
    DspNumberDmaQueries = 0;            // Reset number queries for current block.

    //
    // Now we are ready to queue samples to mm drivers.
    //

    while (leftToPlay > 0) {

        if (leftToPlay < (LONG)BurstSize) {
            size = leftToPlay;
            leftToPlay = 0;
        } else {
            size = BurstSize;
            leftToPlay -= (LONG)BurstSize;
        }

        //
        // if not reset, Queue next buffer.
        // Note, we don't return immediately if bDspReset == TRUE.
        // We just don't queue the data to MM driver.  So we can sync up
        // the DspNextRead with DspNextWrite and DspWaveSem.
        //

        if (!bDspReset) {
            WriteBurst(size);
        }

        if (leftToPlay) {
            DspNextRead = (DspNextRead + 1) % DspBufferTotalBursts;
            WaitForSingleObject(DspWaveSem, INFINITE);
        }
    }
    if (!bDspReset) {
        bWriteBurstStarted = TRUE;
    }
    return;
}

VOID
PrepareHeaders(
    VOID
    )

/*++

Routine Description:

    This function calls HWaveOut device to prepare headers.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

    dprintf3(("Prepare Headers"));

    for (i = 0; i < DspBufferTotalBursts; i++) {
        PrepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
    }
}

VOID
UnprepareHeaders(
    VOID
    )

/*++

Routine Description:

    This function calls HWaveOut device to unprepare headers.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

    dprintf3(("Unprepare Headers"));

    for (i = 0; i < DspBufferTotalBursts; i++) {
        while (WAVERR_STILLPLAYING ==
                   UnprepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR))) {
            Sleep(1);
        }
        WaveHdrs[i].dwFlags = 0;        // Must be zero to call PrepareHeader
        WaveHdrs[i].dwUser  = 0;
    }
}

BOOL
StartDspDmaThread(
    DSP_MODE Mode
    )

/*++

Routine Description:

    This function starts DSP single-cycle or Auto-Init DMA transfer

Arguments:

    Mode - specifies Single-Cycle or Auto-Init mode

Return Value:

    TRUE - starts successfully.
    FALSE - otherwise

--*/

{
    HANDLE tHandle; // handle to single thread
    DWORD id;
    ULONG i;

    bWriteBurstStarted = FALSE;

    if (!bDspActive) {
        if (!(tHandle = CreateThread(NULL, 0, DspThreadEntry, NULL,
                                     CREATE_SUSPENDED, &id))) {

            dprintf1(("Create Dsp DMA thread failed code %d", GetLastError()));
            return (FALSE);

        } else {
            //
            // set synchronization events to a known state
            //
            bDspActive = TRUE;
            bExitAuto = FALSE;
            DspNextRead = DspBufferTotalBursts - 1;
            DspNextWrite = 0;

            CloseHandle(DspWaveSem);
            DspWaveSem=CreateSemaphore(NULL, 0, 100, NULL);
            if(!SetThreadPriority(tHandle, THREAD_PRIORITY_HIGHEST)) {
                dprintf1(("Unable to set thread priority"));
            }
            ResumeThread(tHandle);
            CloseHandle(tHandle);
            WaitForSingleObject(ThreadStarted, INFINITE);
        }
    }

    //
    // If the new requested BlockSize is bigger than our allocated buffer,
    // resize our buffer. Note, we need to wait till the MM driver is done
    // with the buffer and then resize it.
    // Also the DspBuffer should be at least one BurstSize greater than the
    // SBBlockSize + 1 to make sure waitfor header event won't deadlock.
    //

    if ((SBBlockSize + 1) > (DspBufferSize - BurstSize)) {
        if (HWaveOut) {
            WaitOnWaveOutIdle();
            UnprepareHeaders();
        }
        GenerateHdrs(SBBlockSize + BurstSize + 1);
        if (HWaveOut) {
            PrepareHeaders();
        }
    }
    if (Mode == Auto) {

        //
        // Close and open wave out device only if necessary.  Because, some apps
        // use DmaPause to pauseDma and resume dma by do auto-init dsp out.
        //

        if (HWaveOut == NULL || TimeConstant != 0xffff) {

            //
            // We need to close the current WaveOut device and reopen a new one.
            //

            CloseWaveDevice();

            SetWaveFormat();
            OpenWaveDevice((DWORD)0);

            //
            // call WaveOut device to Prepare WaveHdrs
            //

            PrepareHeaders();

            //
            // Next register for IRET hook on the ISR so we can get
            // notification to process next block of data
            //

            RegisterEOIHook(SbInterrupt, AutoInitEoiHook);
            //ica_iret_hook_control(ICA_MASTER, SbInterrupt, TRUE);
        }

        DspMode = Auto;

    } else {
        if (DspMode == Auto) {
            ExitAutoMode();
        }
        DspMode = Single;
    }
    bDspPaused = FALSE;
    DmaDataToDsp(DspMode);
    return (TRUE);
}

VOID
StopDspDmaThread(
    BOOL wait
    )

/*++

Routine Description:

    This function stops DSP DMA thread. Should always be called with TRUE,
    except if process exiting as wait causes deadlock.

Arguments:

    Wait - specifies if we should wait for the thread exit.

Return Value:

    None.

--*/

{

    if (bDspActive) {
        dprintf2(("Stopping DSP DMA thread"));

        ReleaseSemaphore(DspWaveSem, 1, NULL);
        if (wait) {
            dprintf3(("Waiting for thread to exit"));
            WaitForSingleObject(ThreadFinished, INFINITE);
            dprintf3(("thread has exited"));
        }
    }
}

DWORD WINAPI
DspThreadEntry(
    LPVOID context
    )

/*++

Routine Description:

    This function handles DSP single-cycle or Auto-Init DMA transfer

Arguments:

    context - specifies init context.  Not used.

Return Value:

    always returns 0

--*/

{
    BOOL WaveFormatChanged;
    ULONG i, offset;
    HANDLE handles[2];
    HANDLE handle;
    DWORD rc, interruptDelay = INFINITE, position;
    ULONG loopCount = 0;

    bDspActive = TRUE;
    SetEvent(ThreadStarted);

    //
    // Wait for ANY of the following events
    //

    handles[0] = DspWaveSem;
    handles[1] = DspResetEvent;

    while (!bExitDMAThread) {

        //
        // Wait until app wants to transfer more data
        //

        dprintf2(("Rd: Waiting for wave semaphore with Delay = %x", interruptDelay));

        rc = WaitForMultipleObjects(2, handles, FALSE, interruptDelay);
        if (rc == WAIT_TIMEOUT) {
            //
            // Block of sound played
            //

            LockDsp();

            if (PreviousWaveOutPos != StartingWaveOutPos) {

                //
                // Interrupt delay expires.
                // Make sure we are not too far out of sync with real sound playback
                // And we only do this if the app is watching the dma count
                //

                if (GetWaveOutPosition(&position)) {
                    if (position < StartingWaveOutPos) {
                        dprintf1(("rd:sound pos is backward"));
                        position = StartingWaveOutPos; // resync
                    }
                    offset = position - StartingWaveOutPos;
                    offset = SBPlaySize + 1 - offset;
                    dprintf2(("rd: Samples left %x, pos = %x, spos = %x\n", offset, position, StartingWaveOutPos));
                    if (offset > EndingDmaValue) {
                        interruptDelay = COMPUTE_INTERRUPT_DELAY(offset);
                        dprintf2(("rd: more interrupt delay %x ...\n", interruptDelay));
                        loopCount++;
                        if (loopCount < 10) {
                            UnlockDsp();
                            continue;
                        } else {
                            NextWaveOutPos = 0;     // force reset waveout device
                        }
                    } else {
#if 0
                        //
                        // If app is monitoring DMA progress, give it a chance
                        // to get close end of block DMA count
                        //

                        if (DmaInfo.count != StartingDmaCount) {
                            DmaInfo.count = (WORD)(StartingDmaCount - SBPlaySize + 8);
                            DmaInfo.addr  = (WORD)(StartingDmaAddr + SBPlaySize - 8);
                            SetDMACountAddr(&DmaInfo);
                            SbAnswerDMAPosition = FALSE;
                            UnlockDsp();
                            Sleep(0);
                            LockDsp();
                            dprintf3(("Reader Thread2"));
                        }
#endif
                    }
                }
            }


            //
            // Update DMA controller and generate interrupt.
            //

            loopCount = 0;
            DmaInfo.count = (WORD)(StartingDmaCount - (SBPlaySize + 1));
            DmaInfo.addr  = (WORD)(StartingDmaAddr + SBPlaySize + 1);
            SetDMACountAddr(&DmaInfo);
            if (DmaInfo.count == 0xffff) {
                SetDMAStatus(&DmaInfo, TRUE, TRUE);
            }
            if (!bExitAuto) {
                GenerateInterrupt(0);
            }
            SbAnswerDMAPosition = FALSE;    // Ordering is important
            bWriteBurstStarted = FALSE;
            UnlockDsp();

            dprintf3(("rd: Dma Position = %4X, count = %4X", DmaInfo.addr,
                      DmaInfo.count));
            interruptDelay = INFINITE;
            continue;
        }

        interruptDelay = INFINITE;
        if (bDspReset) {        // Dsp reset event
            if (DspMode == Auto) {
                ExitAutoMode();
            }
            continue;
        }

        dprintf2(("Rd: Wave semaphore received"));

        if (DspMode == Single) {

            WaveFormatChanged = SetWaveFormat();

            //
            // If wave format changed, we need to unprepare headers, close the
            // current wave device and reopen a new one.
            //

            if (WaveFormatChanged) {

                dprintf2(("Single-Cycle CHANGING Wave Out device"));
                CloseWaveDevice();
            }

            if (HWaveOut == NULL) {
                OpenWaveDevice((DWORD)0);
                PrepareHeaders();
            }

            //
            // Send the block of data to MM driver
            //

            DspProcessBlock(Single);

            //
            // Once we are done with a block transfer, we automatically exit the
            // HighSpeed mode no matter the transfer was aborted or completed.
            //

            EndingDmaValue = 0x4;
            bHighSpeedMode = FALSE;

            interruptDelay = COMPUTE_INTERRUPT_DELAY(SBPlaySize);

        } else { // Auto-Init mode
            ULONG size;;

            DspProcessBlock(Auto);
            if (bExitAuto) {
                ExitAutoMode();
            }
            EndingDmaValue = 0x20;

            size = SBPlaySize;
            if (SBPlaySize < 0x400) {
                size += SBPlaySize / 8;
            } else if (SBPlaySize > 0x1800) {
                size -= BurstSize;
            }
            interruptDelay = COMPUTE_INTERRUPT_DELAY(size);
            //if (interruptDelay < 0x10) {
            //    interruptDelay = 0x10;
            //}
        } // Single / Auto

        dprintf2(("Interrupt Delay = %x\n", interruptDelay));
    }  // while !bExitThread

    SetEvent(DspResetDone);

    //
    // Clean up Waveout device and headers if necessary
    //

    CloseWaveDevice();

    bDspActive = FALSE;
    SetEvent(ThreadFinished);
    RemoveEOIHook(SbInterrupt, AutoInitEoiHook);
    dprintf2(("Dsp DMA thread is exiting"));
    return (0);
}

VOID
ExitAutoMode (
     void
     )

/*++

Routine Description:

    This function exits DSP auto-init mode

Arguments:

    None.

Return Value:

    None.

--*/

{
    DspMode = None;
    if (bExitAuto) {
        bExitAuto = FALSE;
        dprintf2(("ExitAuto CMD detected in Auto Mode"));
    } else {
        dprintf2(("SingleCycle detected in Auto Mode"));
    }

    //
    // Wait till MM driver finishes playing queued bursts. Then close
    // the waveout device
    //

    RemoveEOIHook(SbInterrupt, AutoInitEoiHook);
    //ica_iret_hook_control(ICA_MASTER, SbInterrupt, FALSE);
    NextWaveOutPos = 0;
    dprintf2(("Auto-Init block done"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sb.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "host_def.h"
#include "insignia.h"
#include "ios.h"

#include "sndblst.h"
#include "nt_sb.h"
#include "nt_reset.h"
#include <stdio.h>
#include <softpc.h>

//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
//

SETVOLUMEPROC            SetVolumeProc;
GETVOLUMEPROC            GetVolumeProc;
GETNUMDEVSPROC           GetNumDevsProc;
GETDEVCAPSPROC           GetDevCapsProc;
OPENPROC                 OpenProc;
PAUSEPROC                PauseProc;
RESTARTPROC              RestartProc;
RESETPROC                ResetProc;
CLOSEPROC                CloseProc;
GETPOSITIONPROC          GetPositionProc;
WRITEPROC                WriteProc;
PREPAREHEADERPROC        PrepareHeaderProc;
UNPREPAREHEADERPROC      UnprepareHeaderProc;

SETMIDIVOLUMEPROC        SetMidiVolumeProc;
GETMIDIVOLUMEPROC        GetMidiVolumeProc;
MIDIGETNUMDEVSPROC       MidiGetNumDevsProc;
MIDIGETDEVCAPSPROC       MidiGetDevCapsProc;
MIDIOPENPROC             MidiOpenProc;
MIDIRESETPROC            MidiResetProc;
MIDICLOSEPROC            MidiCloseProc;
MIDILONGMSGPROC          MidiLongMsgProc;
MIDISHORTMSGPROC         MidiShortMsgProc;
MIDIPREPAREHEADERPROC    MidiPrepareHeaderProc;
MIDIUNPREPAREHEADERPROC  MidiUnprepareHeaderProc;

//
// Misc. globals
//

BOOL bSBAttached;
BOOL bDevicesActive = FALSE;    // Are MM sound devices initialized?
HINSTANCE hWinmm;               // module handle to winmm.dll
WORD BasePort, MpuBasePort;     // Where the card is mapped, ie the base I/O address
WORD MixerBasePort;
WORD MpuMode = MPU_INTELLIGENT_MODE;
USHORT SbInterrupt;
USHORT SbDmaChannel;
UCHAR MpuInData = 0xFF;

//
// Forward references
//

BOOL InitializeIoAddresses(void);
BOOL InstallIoHook(void);
VOID DeInstallIoHook(void);
VOID VsbByteIn(WORD port, BYTE * data);
VOID VsbByteOut(WORD port, BYTE data);
BOOL LoadWinmm(VOID);
BOOL InitDevices(VOID);

BOOL
SbInitialize(
    void
    )

/*++

Routine Description:

    This function performs SB initialization by installing I/O port and handler hooks.

Arguments:

    None.

Return Value:

    TRUE -  Initialization successful.
    FALSE - Otherwise.

--*/

{

    bSBAttached = FALSE;

    //
    // No sound blaster for wow
    //

    if (VDMForWOW) {
        return FALSE;
    }

    //
    // Get Io addresses and hook them
    //

    if (InitializeIoAddresses() == FALSE) {
        return FALSE;
    }
    if (!InstallIoHook()) {
        dprintf1(("*** failed to install IO Hooks!!!"));
        return FALSE;
    }

    //
    // Prepare MM API addresses
    //

    if (!LoadWinmm()) {
        DeInstallIoHook();
        return FALSE;
    }

    bSBAttached = TRUE;
    return TRUE;

}

void
SbTerminate(
    void
    )

/*++

Routine Description:

    This function performs SB cleanup.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (bSBAttached) {
        SbCloseDevices();
        DeInstallIoHook();
        UnloadSystem32Library(hWinmm);
    }
    bSBAttached = FALSE;
}

BOOL
InitializeIoAddresses(
    VOID
    )

/*++

Routine Description:

    This function reads environment variables to initialize IO addresses for
    DSP, MIXER, MIDI and ADLIB.  For the IO addresses which are not specified
    in the environment variable, we will use our default values.

Arguments:

    None.

Return Value:

    TRUE - initialization success.
    FALSE - failed.

--*/

{
    //
    // The SB is initialized before the env. variables are processed.
    // So, here we simply use the default value.
    //

    BasePort = 0x220;
    MpuBasePort = MPU401_DATA_PORT;
    SbInterrupt = VSB_INTERRUPT;
    SbDmaChannel = VSB_DMA_CHANNEL;

    return TRUE;
}

BOOL
LoadWinmm(
    VOID
    )

/*++

Routine Description:

    This function dynamically loads the "waveOutxxx" entry points. This
    is done because there is code in WINMM which does certain things in a
    WOW vdm. If we do static links, then winmm may get loaded way before
    WOW32, in which case it can't do the things it should.

Arguments:

    None.

Return Value:

    TRUE -  successful.
    FALSE - Otherwise.

--*/

{

    //
    // Load the Winmm.dll and grab all the desired function addresses.
    //

    if (!(hWinmm = LoadSystem32Library(L"WINMM.DLL"))) {
        return FALSE;
    }

    SetVolumeProc = (SETVOLUMEPROC) GetProcAddress(hWinmm, "waveOutSetVolume");
    GetVolumeProc = (GETVOLUMEPROC) GetProcAddress(hWinmm, "waveOutGetVolume");
    GetNumDevsProc = (GETNUMDEVSPROC) GetProcAddress(hWinmm, "waveOutGetNumDevs");
    GetDevCapsProc = (GETDEVCAPSPROC) GetProcAddress(hWinmm, "waveOutGetDevCapsA");
    OpenProc = (OPENPROC) GetProcAddress(hWinmm, "waveOutOpen");
    PauseProc = (PAUSEPROC) GetProcAddress(hWinmm, "waveOutPause");
    RestartProc = (RESTARTPROC) GetProcAddress(hWinmm, "waveOutRestart");
    ResetProc = (RESETPROC) GetProcAddress(hWinmm, "waveOutReset");
    CloseProc = (CLOSEPROC) GetProcAddress(hWinmm, "waveOutClose");
    GetPositionProc = (GETPOSITIONPROC) GetProcAddress(hWinmm, "waveOutGetPosition");
    WriteProc = (WRITEPROC) GetProcAddress(hWinmm, "waveOutWrite");
    PrepareHeaderProc = (PREPAREHEADERPROC) GetProcAddress(hWinmm, "waveOutPrepareHeader");
    UnprepareHeaderProc = (UNPREPAREHEADERPROC) GetProcAddress(hWinmm, "waveOutUnprepareHeader");

    SetMidiVolumeProc = (SETMIDIVOLUMEPROC) GetProcAddress(hWinmm, "midiOutSetVolume");
    GetMidiVolumeProc = (GETMIDIVOLUMEPROC) GetProcAddress(hWinmm, "midiOutGetVolume");
    MidiGetNumDevsProc = (MIDIGETNUMDEVSPROC) GetProcAddress(hWinmm, "midiOutGetNumDevs");
    MidiGetDevCapsProc = (MIDIGETDEVCAPSPROC) GetProcAddress(hWinmm, "midiOutGetDevCapsA");
    MidiOpenProc = (MIDIOPENPROC) GetProcAddress(hWinmm, "midiOutOpen");
    MidiResetProc = (MIDIRESETPROC) GetProcAddress(hWinmm, "midiOutReset");
    MidiCloseProc = (MIDICLOSEPROC) GetProcAddress(hWinmm, "midiOutClose");
    MidiLongMsgProc = (MIDILONGMSGPROC) GetProcAddress(hWinmm, "midiOutLongMsg");
    MidiShortMsgProc = (MIDISHORTMSGPROC) GetProcAddress(hWinmm, "midiOutShortMsg");
    MidiPrepareHeaderProc = (MIDIPREPAREHEADERPROC) GetProcAddress(hWinmm, "midiOutPrepareHeader");
    MidiUnprepareHeaderProc = (MIDIUNPREPAREHEADERPROC) GetProcAddress(hWinmm, "midiOutUnprepareHeader");

    //
    // Check to see if everyone is OK
    //

    if (SetVolumeProc && GetVolumeProc && GetNumDevsProc && GetDevCapsProc && OpenProc && ResetProc &&
        CloseProc && GetPositionProc && WriteProc && PrepareHeaderProc && SetMidiVolumeProc &&
        UnprepareHeaderProc && MidiGetNumDevsProc && MidiGetDevCapsProc && MidiOpenProc &&
        MidiResetProc && MidiCloseProc && MidiLongMsgProc && MidiShortMsgProc &&
        MidiPrepareHeaderProc && MidiUnprepareHeaderProc && GetMidiVolumeProc) {

        return TRUE;
    } else {
        dprintf1(("Can not get all the MM api entries"));
        return FALSE;
    }
}

BOOL
InitDevices(
    VOID
    )

/*++

Routine Description:

    This function tries to get handles to the waveout and FM devices.

Arguments:

    None.

Return Value:

    TRUE -  successful.
    FALSE - Otherwise.

--*/

{
    VDM_PM_CLI_DATA cliData;

    cliData.Control = PM_CLI_CONTROL_ENABLE;
    NtVdmControl(VdmPMCliControl, &cliData);

    if (!PrepareWaveInitialization()) {
        return FALSE;
    }
    if (!FindWaveDevice()) {
        return FALSE;
    }

    if (!InitializeMidi()) {
        //
        // Disconnect the IO port hooks for MIDI ports
        //

        if (MpuBasePort != 0) {
            DisconnectPorts(MpuBasePort, MpuBasePort + 1);
            MpuBasePort = 0;
        }
        dprintf1(("Unable to Initialize MIDI resources"));
    }

    bDevicesActive = TRUE;

    OpenFMDevice();
    return TRUE;
}

VOID
SbCloseDevices(
    VOID
    )

/*++

Routine Description:

    This function performs cleanup work to prepare to exit.

Arguments:

    None.

Return Value:

    None.

--*/

{
    VDM_PM_CLI_DATA cliData;

    cliData.Control = PM_CLI_CONTROL_DISABLE;
    NtVdmControl(VdmPMCliControl, &cliData);

    if (bDevicesActive) {
        DetachMidi();
        CloseFMDevice();
        CleanUpWave();
        bDevicesActive = FALSE;
    }
}

BOOL
ConnectPorts (
    WORD FirstPort,
    WORD LastPort
    )

/*++

Routine Description:

    This function connects io port range [FirstPort, LastPort] to ntvdm for IO port
    trapping.

Arguments:

    FirstPort - Supplies the first port in the range to be connected

    LastPort - Supplies the last port in the range to be connected

Return Value:

    TRUE - if all the ports in the range connected successfully.
    FALSE - if ANY one of the ports failed to connect.  Note Once connection
            failed, all the previous connected ports in the specified range
             are disconnected.

--*/

{
    WORD i;

    for (i = FirstPort; i <= LastPort; i++) {
        if (!io_connect_port(i, SNDBLST_ADAPTER, IO_READ_WRITE)) {

            //
            // If connection fails, revert the connection we have done earlier
            //

            DisconnectPorts(FirstPort, i - 1);
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
InstallIoHook(
    VOID
    )

/*++

Routine Description:

    This function hooks I/O ports with I/O handlers for our sound blaster device.

Arguments:

    None.

Return Value:

    TRUE - if all the ports and handlers hooked successfully.
    FALSE - if ANY one of the ports failed to connect.

--*/

{
    WORD i;
    BOOL rc;

    rc = FALSE;

    //
    // First hook our I/O handlers.
    //

    io_define_inb(SNDBLST_ADAPTER,  VsbByteIn);
    io_define_outb(SNDBLST_ADAPTER, VsbByteOut);

    //
    // try connect dsp base port
    //


    if (!ConnectPorts(BasePort + 0x4, BasePort + 0x6)) {
        return FALSE;
    }
    if (!ConnectPorts(BasePort + 0x8, BasePort + 0xA)) {
        DisconnectPorts(BasePort + 0x4, BasePort + 0x6);
        return FALSE;
    }
    if (!ConnectPorts(BasePort + 0xC, BasePort + 0xC)) {
        DisconnectPorts(BasePort + 0x4, BasePort + 0x6);
        DisconnectPorts(BasePort + 0x8, BasePort + 0xA);
        return FALSE;
    }
    if (!ConnectPorts(BasePort + 0xE, BasePort + 0xE)) {
        DisconnectPorts(BasePort + 0x4, BasePort + 0x6);
        DisconnectPorts(BasePort + 0x8, BasePort + 0xA);
        DisconnectPorts(BasePort + 0xC, BasePort + 0xC);
        return FALSE;
    }
    if (!ConnectPorts(0x388, 0x389)) {
        DisconnectPorts(BasePort + 0x4, BasePort + 0x6);
        DisconnectPorts(BasePort + 0x8, BasePort + 0xA);
        DisconnectPorts(BasePort + 0xC, BasePort + 0xC);
        DisconnectPorts(BasePort + 0xE, BasePort + 0xE);
        return FALSE;
    }

    //
    // Try connect to MPU 401 ports.  It is OK if failed.
    //

    if (MpuBasePort != 0 && !ConnectPorts(MpuBasePort, MpuBasePort + 0x1)) {
        MpuBasePort = 0;
    }
    return TRUE;
}

VOID
DeInstallIoHook(
    VOID
    )

/*++

Routine Description:

    This function unhooks I/O ports that we connected during initialization.
    It is called when ntvdm is being terminated.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DisconnectPorts(BasePort + 0x4, BasePort + 0x6);
    DisconnectPorts(BasePort + 0x8, BasePort + 0xA);
    DisconnectPorts(BasePort + 0xC, BasePort + 0xC);
    DisconnectPorts(BasePort + 0xE, BasePort + 0xE);
    DisconnectPorts(0x388, 0x389);
    if (MpuBasePort != 0) {
        DisconnectPorts(MpuBasePort, MpuBasePort + 1);
    }
}

VOID
VsbByteIn(
    WORD port,
    BYTE * data
    )

/*++

Routine Description:

    Gets called when the application reads from port.
    Returns results to application in data.

Arguments:

    port - the trapped I/O port address.

    data - Supplies the address of byte buffer to return data read from specified port.

Return Value:

    None.

--*/

{
    //
    // as if we fail simulate nothing at the port
    //

    *data = 0xFF;

    //
    // make sure we are linked in with winmm
    //

    if (!bDevicesActive) {
        if (!InitDevices()) {
            // no wave device, forget it
            return;
        }
    }

    switch (port - BasePort) {
    case READ_STATUS:
        DspReadStatus(data);
        dprintf0(("r-RdSta %x", *data));
        break;

    case READ_DATA:
        DspReadData(data);
        dprintf0(("r-RdDt %x", *data));
        break;

    case WRITE_STATUS:

        //
        // If we are in High Speed DMA mode, DSP will not accept any
        // command/data.  So, in this case, we return not-ready.
        //
        if (bHighSpeedMode) {
            *data = 0xFF;
        } else {
            *data = 0x7F;
        }
        dprintf0(("r-WtSta %x", *data));
        break;

    case MIXER_ADDRESS:
        // apps sometimes read from this port??
        break;

    case MIXER_DATA:
        MixerDataRead(data);
        break;

    case 0x8:
        // remap to ADLIB_STATUS_PORT
        port = ADLIB_STATUS_PORT;
        break;
    }

    switch(port) {
    case MPU401_DATA_PORT:
    case ALT_MPU401_DATA_PORT:
        //
        // Don't support MIDI read.  Except that we support MPU reset in this case
        // we return 0xFE to indicate MPU is present
        //

        *data = MpuInData;
        MpuInData = 0xFF;
        dprintf0(("r-MPU RdDt %x", *data));
        break;

    case MPU401_COMMAND_PORT:
    case ALT_MPU401_COMMAND_PORT:

        //
        // always return data ready for reading and ready for command/data
        //
        if (MpuInData != 0xFF) {
            *data = 0x00;
        } else {
            *data = 0x80;
        }
        dprintf0(("r-MPU RdSt %x", *data));
        break;

    case ADLIB_STATUS_PORT:
        FMStatusRead(data);
        break;
    }

    dprintf4(("Read  %4X, <= %2X", port, *data));
}

VOID
VsbByteOut(
    WORD port,
    BYTE data
    )

/*++

Routine Description:

    Gets called when the application writes data to port.

Arguments:

    port - the trapped I/O port address.

    data - Supplies the data to be written to the specified port.

Return Value:

    None.

--*/

{
    //
    // make sure we are linked in with winmm
    //
    if (!bDevicesActive) {
        if (!InitDevices()) {
            // no wave device, forget it
            return;
        }
    }

    dprintf4(("Write %4X, => %2X", port, data));

    switch (port - BasePort) {
    case RESET_PORT:
        dprintf0(("w-Reset %x", data));
        DspResetWrite(data);
        break;

    case WRITE_PORT:
        //
        // The DSP accepts command/data only when it is NOT in High Speed
        // DMA mode.
        //
        if (!bHighSpeedMode) {
            dprintf0(("w-wt %x", data));
            DspWrite(data);
        }
        break;

    case MIXER_ADDRESS:
        DisplaySbMode(DISPLAY_MIXER);
        MixerAddrWrite(data);
        break;

    case MIXER_DATA:
        MixerDataWrite(data);
        break;

    case 0x8:
        // remap to ADLIB_REGISTER_SELECT_PORT
        port = ADLIB_REGISTER_SELECT_PORT;
        break;

    case 0x9:
        // remap to ADLIB_DATA_PORT
        port = ADLIB_DATA_PORT;
        break;
    }

    switch(port) {
    case MPU401_DATA_PORT:
    case ALT_MPU401_DATA_PORT:

        dprintf0(("w-MPU wtDt %x", data));
        switch (MpuMode) {
        case MPU_UART_MODE:
            if (HMidiOut) {
                BufferMidi(data);
            }
            break;

        case MPU_INTELLIGENT_MODE:
            dprintf1(("App sending MPU data when in INTELLIGENT mode!  Data dumped!"));
            break;

        default:
            dprintf1(("Invalid MPU mode!"));
            break;
        }
        break;

    case MPU401_COMMAND_PORT:
    case ALT_MPU401_COMMAND_PORT:

        DisplaySbMode(DISPLAY_MIDI);

        dprintf0(("r-MPU wtCmd %x", data));

        if (data == MPU_RESET || data == MPU_PASSTHROUGH_MODE) {
            MpuInData = 0xFE;
        }

        switch (MpuMode) {
        case MPU_UART_MODE:
            switch (data) {
            case MPU_RESET:
                dprintf2(("App Reseting MPU while in UART mode, switching to intelligent mode."));
                MpuMode=MPU_INTELLIGENT_MODE;
                if (HMidiOut) {
                    CloseMidiDevice(); // HMidiOut will be set to NULL
                }
                dprintf2(("MPU Reset done."));
                break;

            default:
               // While in UART mode all the other commands are ignored.
               break;
            }
            break;

        case MPU_INTELLIGENT_MODE:
            switch (data) {
            case MPU_RESET:
                // Does nothing here.  While app read data port, we will return 0xfe.
                dprintf2(("Reseting MPU while in intelligent mode."));
                break;

            case MPU_PASSTHROUGH_MODE:
                DisplaySbMode(DISPLAY_MIDI);
                dprintf2(("Switching MPU to UART (dumb) mode."));

                if (!HMidiOut) {
                    OpenMidiDevice(0);
                }
                MpuMode = MPU_UART_MODE;
                break;

            default:
                // We don't recognize any other commands.
                dprintf2(("Unknown MPU401 command 0x%x sent while in intelligent mode!", data));
                break;
            }
            break;

        default:
            dprintf1(("Invalid MPU mode!"));
            break;
        }
        break;

    case ADLIB_REGISTER_SELECT_PORT:
        DisplaySbMode(DISPLAY_ADLIB);
        FMRegisterSelect(data);
        break;

    case ADLIB_DATA_PORT:
        FMDataWrite(data);
        break;
    }
}

VOID
ResetAll(
    VOID
    )

/*++

Routine Description:

    This function resets all devices.

Arguments:

    None.

Return Value:

    None.

--*/

{
    dprintf2(("Resetting"));
    //ResetMidiDevice();
    ResetFM();
    ResetMixer();

    //
    // Close WaveOut device after we finish reset mixer.
    //
    ResetDSP();
}

VOID
SbReinitialize(
    PCHAR Buffer,
    DWORD CmdLen
    )

/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{
    DWORD  i;
    USHORT tmp;
    WORD basePort, mpuBasePort;

    if (VDMForWOW || Buffer == NULL || CmdLen == 0) {
        return;
    }

    basePort = BasePort;
    mpuBasePort = MpuBasePort;
    i = 0;
    while (i < CmdLen && Buffer[i] != 0) {

        //
        // Skip leading spaces if any
        //

        while (Buffer[i] == ' ') {
            i++;
            if (i >= CmdLen || Buffer[i] == 0) {
                goto exit;
            }
        }
        tmp = 0;
        switch (Buffer[i]) {
        case 'A':
        case 'a':
            if (sscanf(&Buffer[++i], "%x", &tmp) == 1) {
                basePort = tmp;
            }
            break;
        case 'D':
        case 'd':
            if (sscanf(&Buffer[++i], "%x", &tmp) == 1) {
                SbDmaChannel = tmp;
            }
            break;
        case 'I':
        case 'i':
            if (sscanf(&Buffer[++i], "%x", &tmp) == 1) {
                SbInterrupt = tmp;
            }
            break;
        case 'P':
        case 'p':
            if (sscanf(&Buffer[++i], "%x", &tmp) == 1) {
                mpuBasePort = tmp;
            }
            break;
        default:
            break;
        }

        //
        // Move to next field
        //

        while ((i < CmdLen) && (Buffer[i] != 0) && (Buffer[i] != ' ')) {
            i++;
        }
    }
exit:
    dprintf2(("Base %x, DMA %x, INT %x, MPU %x",
               basePort, SbDmaChannel, SbInterrupt, mpuBasePort));
    if (basePort == 0) {
        SbTerminate();
    } else if (basePort != BasePort || mpuBasePort != MpuBasePort) {
        if (bSBAttached) {
            SbCloseDevices();
            DeInstallIoHook();
            BasePort = basePort;
            MpuBasePort = mpuBasePort;
            if (!InstallIoHook()) {
                UnloadSystem32Library(hWinmm);
                bSBAttached = FALSE;
            }
        }
    }
}
//
// Debugging stuff
//

//#if DBG

int DebugLevel = 2;
int DebugCount = 0;

#define DEBUG_START 0

void DbgOut(LPSTR lpszFormat, ...)

/*++

Routine Description:

    This function Generates debug output in printf type format.

Arguments:

    lpszFormat - supplies a pointer to a printf type format string.

    ... - other parameters for the format string.

Return Value:

    None.

--*/

{
    char buf[256];
    char buf2[300] = "VSB: ";
    va_list va;

    if (!IsDebuggerPresent() || (++DebugCount < DEBUG_START)) {
        return;
    }

    va_start(va, lpszFormat);
    wvsprintfA(buf, lpszFormat, va);
    va_end(va);

    strcat(buf2, buf);
    strcat(buf2, "\r\n");
    OutputDebugStringA(buf2);

}

//#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sbfm.c ===
/***************************************************************************
*
*    nt_sbfm.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "host_def.h"
#include "insignia.h"

#include "sndblst.h"
#include "nt_sb.h"
#include <softpc.h>

BOOL FMPortWrite(void);

/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

HMIDIOUT HFM = NULL;     // current open FM device.  If no zero, it means we
                         // successfully open the FM synth device and apps
                         // have the direct IO to adlib port.

BYTE AdlibRegister = 0x00; // register currently selected
int Position = 0; // position in PortData array
SYNTH_DATA PortData[BATCH_SIZE]; // batched data to be written to OPL2 device
BOOL Timer1Started = FALSE; // if a timer interrupts then it's stopped
BOOL Timer2Started = FALSE; // if a timer interrupts then it's stopped
BYTE Status = 0x06; // or 0x00, see sb programming book page xi


/****************************************************************************
*
*    FM device routines
*
****************************************************************************/

VOID
ResetFM(
    VOID
    )
{
    AdlibRegister = 0x00; // register currently selected
    Position = 0;
    Timer1Started = FALSE;
    Timer2Started = FALSE;
    Status = 0x06;
}

VOID
FMStatusRead(
    BYTE *data
    )
{
#if 0 // This should work but doesn't (ReadFile fails)
        // Are we expecting a state change ?

        if (Timer1Started || Timer2Started) {
             // Read the status port from the driver - this is how the
             // driver interprets read.
             // Well, actually don't because the WSS driver doesn't work!

            if (!ReadFile(HFM, &Status, 1, &bytesRead, NULL)) {
#if DBG
                FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (char *) &lpMsgBuf, 0, NULL);
                dprintf1(("FM read port failed: %d bytes of data read, error message: %s",
                            bytesRead, lpMsgBuf));
                LocalFree( lpMsgBuf ); // Free the buffer.
#endif DBG
                break;
            }
            else {
                 // Look for state change

                if (Status & 0x40) {
                     Timer1Started = FALSE;
                     dprintf2(("Timer 1 finished"));
            }

                if (Status & 0x20) {
                    Timer2Started = FALSE;
                    dprintf2(("Timer 2 finished"));
            }
            }
        }
#endif
        *data = Status;
}

VOID
FMRegisterSelect(
    BYTE data
    )
{
    AdlibRegister = data;
}

VOID
FMDataWrite(
    BYTE data
    )
{
    if(AdlibRegister==AD_NEW) {
        data &=0xFE; // don't enter opl3 mode
    }

    // put data in PortData array
    if(Position <= BATCH_SIZE-2) {
        PortData[Position].IoPort = ADLIB_REGISTER_SELECT_PORT;
        PortData[Position].PortData = AdlibRegister;
        PortData[Position + 1].IoPort = ADLIB_DATA_PORT;
        PortData[Position + 1].PortData = data;
        Position += 2;
    } else {
        dprintf1(("Attempting to write beyond end of PortData array"));
    }

    if (Position == BATCH_SIZE ||
        AdlibRegister>=0xB0 && AdlibRegister<=0xBD ||
        AdlibRegister == AD_MASK) {
        // PortData full or note-on/off command or changing status
        if (!FMPortWrite()) {
            dprintf1(("Failed to write to device!"));
        } else {
            // Work out what status change may have occurred
            if (AdlibRegister == AD_MASK) {
                // Look for RST and starting timers
                if (data & 0x80) {
                    Status = 0x00; // reset both timers
            }

                // We ignore starting of timers if their interrupt
                // flag is set because the timer status will have to
                // be set again to make the status for this timer change

                if ((data & 1) && !(Status & 0x40)) {
                    dprintf2(("Timer 1 started"));
#if 0
                    Timer1Started = TRUE;
#else
                    Status |= 0xC0; // simulate immediate expiry of timer1
#endif
                } else {
                    Timer1Started = FALSE;
                }

                if ((data & 2) && !(Status & 0x20)) {
                    dprintf2(("Timer 2 started"));
#if 0
                    Timer2Started = TRUE;
#else
                    Status |= 0xA0; // simulate immediate expiry of timer2
#endif
                    Timer2Started = TRUE;
                } else {
                    Timer2Started = FALSE;
                }
           }
        }
    }
}


/***************************************************************************/

/*
*    Sends FM data to the card.
*    Returns TRUE on success.
*/

BOOL
FMPortWrite(
    VOID
    )
{
    DWORD bytesWritten = 0;
    LPVOID lpMsgBuf;

    dprintf4(("Writing %d bytes of data to port",
    Position * sizeof(PortData[0])));
    if (!WriteFile(HFM, &PortData, Position * sizeof(PortData[0]),
       &bytesWritten, NULL)) {
#if DBG
       FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
         FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char *) &lpMsgBuf,
           0, NULL);

       dprintf1(("FM write failed: %d bytes of data written, error message: %s",
         bytesWritten, lpMsgBuf));
       LocalFree( lpMsgBuf ); // Free the buffer.
#endif //DBG
       return FALSE;
    }
    Position = 0;
    return TRUE;
}

BOOL
FindFMSynthDevice(
    PUINT FMDevice
    )

/*++

Routine Description:

    This function finds a FM synth output device.

Arguments:

    FMDevice - supplies a pointer to a variable to receive the FMDevice number.

Return Value:

    TRUE - if device is found.
    FALSE - no device is found.

--*/

{
    UINT numDev;
    UINT device;
    MIDIOUTCAPS mc;

    numDev = MidiGetNumDevsProc();

    for (device = 0; device < numDev; device++) {
        if (MMSYSERR_NOERROR == MidiGetDevCapsProc(device, &mc, sizeof(mc))) {

            //
            // Need FM Synth device
            //

            if (mc.wTechnology == MOD_FMSYNTH) {
                *FMDevice = device;
                return (TRUE);
            }
        }
    }

    dprintf1(("FM Synth device not found"));
    return (FALSE);
}

BOOL
OpenFMDevice(
    VOID
    )

/*++

Routine Description:

    This function opens FM synth device.

Arguments:

    None.

Return Value:

    TRUE - if success otherwise FALSE.

--*/

{
    UINT rc;
    UINT FMDevice;
    VDM_ADLIB_DATA ServiceData;
    NTSTATUS status;

    ServiceData.VirtualPortStart = BasePort + 0x8;
    ServiceData.VirtualPortEnd =   BasePort + 0x9;
    ServiceData.PhysicalPortStart = ADLIB_STATUS_PORT;
    ServiceData.PhysicalPortEnd =   ADLIB_DATA_PORT;

    HFM = NULL;
    if (FindFMSynthDevice(&FMDevice)) {
        rc = MidiOpenProc(&HFM, FMDevice, 0, 0, CALLBACK_NULL);
        if (rc != MMSYSERR_NOERROR) {
            dprintf1(("Failed to open FM Synth device - code %d", rc));
            HFM = NULL;    // just to make sure
        } else {

            //
            // Call kernel to let app have unlimited access to the ports
            //

            ServiceData.Action =  ADLIB_DIRECT_IO;
            status = NtVdmControl(VdmAdlibEmulation, &ServiceData);
            if (!NT_SUCCESS(status)) {
                MidiCloseProc(HFM);
                HFM = NULL;
            } else {
                MixerSetMidiVolume(0x8);        // set to default volume
            }
        }
    }
    if (HFM == NULL) {
        ServiceData.Action =  ADLIB_KERNEL_EMULATION;
        status = NtVdmControl(VdmAdlibEmulation, &ServiceData);
        if (NT_SUCCESS(status)) {
            dprintf2(("Kernel mode emulation for Adlib"));
        } else {
            ServiceData.Action =  ADLIB_USER_EMULATION;
            NtVdmControl(VdmAdlibEmulation, &ServiceData);
        }
    }

    return (TRUE);
}

VOID
CloseFMDevice(
    VOID
    )
/*++

Routine Description:

    This function close FM synth device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    VDM_ADLIB_DATA ServiceData;

    dprintf2(("Closing FM device"));

    if (HFM) {
        MidiResetProc(HFM);
        MidiCloseProc(HFM);
        HFM = NULL;
    }

    ServiceData.Action =  ADLIB_USER_EMULATION;
    ServiceData.VirtualPortStart = BasePort + 0x8;
    ServiceData.VirtualPortEnd =   BasePort + 0x9;
    ServiceData.PhysicalPortStart = ADLIB_STATUS_PORT;
    ServiceData.PhysicalPortEnd =    ADLIB_DATA_PORT;
    NtVdmControl(VdmAdlibEmulation, &ServiceData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sbmxr.c ===
/***************************************************************************
*
*    nt_sbmixer.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*
***************************************************************************/

#include "insignia.h"
#include "host_def.h"
#include "ios.h"

#include <windows.h>
#include "sndblst.h"
#include "nt_sb.h"

void MixerSetMasterVolume(BYTE level);
void MixerSetVoiceVolume(BYTE level);
void MixerSetMidiVolume(BYTE level);

//
// Mixer globals
//

struct {
    BYTE MasterVolume;     // current master volume
    BYTE FMVolume;         // current volume of fm device
    BYTE CDVolume;         // current volume of cd
    BYTE VoiceVolume;      // current volume of wave device
} MixerSettings;

//
// Mixer State Machine
//

enum {
    MixerReset = 1,        // initial state and after reset
    MixerMasterVolume,
    MixerFMVolume,
    MixerCDVolume,
    MixerVoiceVolume
} MixerState = MixerReset; // state of current command/data being set

VOID
MixerDataRead(
    BYTE * data
    )

/*++

Routine Description:

    This function handles reading back of preselected volume level.

Arguments:

    data - supplies the address to receive the level data

Return Value:

    None.

--*/

{
    switch(MixerState) {
    case MixerReset:
        ResetMixer();
        break;

    case MixerMasterVolume:
        *data = MixerSettings.MasterVolume;
        break;

    case MixerFMVolume:
        *data = MixerSettings.FMVolume;
        break;

    case MixerCDVolume:
        *data = MixerSettings.CDVolume;
        break;

    case MixerVoiceVolume:
        *data = MixerSettings.VoiceVolume;
        break;
    }
}

VOID
MixerAddrWrite(
    BYTE data
    )

/*++

Routine Description:

    This function handles setting register index to the addr register.

Arguments:

    data - register index

Return Value:

    None.

--*/

{
    switch(data) {
    case MIXER_RESET:
        MixerState = MixerReset;
        break;

    case MIXER_MASTER_VOLUME:
        MixerState = MixerMasterVolume;
        break;

    case MIXER_FM_VOLUME:
        MixerState = MixerFMVolume;
        break;

    case MIXER_CD_VOLUME:
        MixerState = MixerCDVolume;
        break;

    case MIXER_VOICE_VOLUME:
        MixerState = MixerVoiceVolume;
        break;
    }
}

VOID
MixerDataWrite(
    BYTE data
    )

/*++

Routine Description:

    This function sets mixer volume

Arguments:

    data - specifies the level of reset index register

Return Value:

    None.

--*/

{
    switch(MixerState) {
    case MixerReset:
        ResetMixer();
        break;

    case MixerMasterVolume:
        MixerSetMasterVolume(data);
        break;

    case MixerFMVolume:
        MixerSetMidiVolume(data);
        break;

    case MixerCDVolume:
        MixerSettings.CDVolume = data;
        break;

    case MixerVoiceVolume:
        MixerSetVoiceVolume(data);
        break;
    }
}

VOID
ResetMixer(
    VOID
    )

/*++

Routine Description:

    This function resets mixer to its default states.

Arguments:

    None.

Return Value:

    None

--*/

{
    MixerSetMasterVolume(0x08);
    MixerSetMidiVolume(0x08);
    MixerSettings.CDVolume = 0x00; // set to level 0
    MixerSetVoiceVolume(0x04);

    MixerState = MixerReset;
}

VOID
MixerSetMasterVolume(
    BYTE level
    )

/*++

Routine Description:

    This function sets master volume level.

Arguments:

    level - only bit 1, 2, 3

Return Value:

    None.

--*/

{
    ULONG volume = 0;

    MixerSettings.MasterVolume = level;
    if (HWaveOut) {
        level = level >> 1;
        level = level & 0x07;

        volume = level*0x2000 - 1;          // 0x10000/8
        volume = volume + (volume << 16);   // Both speaker
        SetVolumeProc(HWaveOut, volume);    // ????
    }
}

VOID
MixerSetVoiceVolume(
    BYTE level
    )

/*++

Routine Description:

    This function sets mixer volume of wave out device.

Arguments:

    level - wave out volume level. (only bit 1 and 2)

Return Value:

    None.

--*/

{
    ULONG volume = 0;

    MixerSettings.VoiceVolume = level;

    //
    // Don't let apps set voice volume.  At least not through MM WaveOut
    // device.  Because On mixer reset, the voice volume will be set to zero.
    // It will set WaveOut volume to zero.
    //

    if (HWaveOut) {
        level = level >> 1;
        level = level & 0x03;

        volume = level*0x4000 - 1;          // 0x10000/4
        volume = volume + (volume << 16);   // Both speaker
        SetVolumeProc(HWaveOut, volume);
    }
}

VOID
MixerSetMidiVolume(
    BYTE level
    )

/*++

Routine Description:

    This function sets mixer volume of FM/MIDI out device.

Arguments:

    level - wave out volume level. (only bit 1 and 2)

Return Value:

    None.

--*/

{
    ULONG volume = 0;
    HANDLE hMidi;

    MixerSettings.FMVolume = level;
    if (HFM || HMidiOut) {
        level = level >> 1;
        level = level & 0x07;

        volume = level*0x2000 - 1;        // 0x10000/8
        volume = volume + (volume << 16); // set both speaker
        if (HFM) {
            SetMidiVolumeProc(HFM, volume);
        }
        if (HMidiOut) {
            SetMidiVolumeProc(HMidiOut, volume);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sbmid.c ===
#include "insignia.h"
#include "host_def.h"
#include <windows.h>
#include "sndblst.h"
#include "nt_sb.h"

#if REPORT_SB_MODE
USHORT  DisplayFlags = 0xffff;
#endif

#define MIDI_BUFFER_SIZE 0x1000
#define MESSAGE_HEADERS 4
#define MESSAGE_CHUNK_SIZE (256+128)
#define MIDI_BUFFER_FULL_THRESHOLD (256 - sizeof(MIDIHDR))
#define MESSAGE_BUFFER_SIZE (MESSAGE_CHUNK_SIZE * MESSAGE_HEADERS)
#define Align(addr) (addr = (addr + Alignment) & ~Alignment)
#define ToBufferIndex(i) (i = i % MIDI_BUFFER_SIZE)
#define ToBufferAddr(i) (i + (ULONG)MidiBuffer);

UCHAR *MidiBuffer;

UCHAR *MessageBuffer;
PMIDIHDR MidiHdrs[MESSAGE_HEADERS];

HMIDIOUT HMidiOut;
LONG NextData,LastData;
LONG BytesLeft;
LONG NextCopyPosition = 0;
LONG LastCommand;
LONG LastCommandLength = 1;
LONG RunningStatus;
ULONG Alignment;
BOOL MidiInitialized = FALSE;

DWORD OriginalMidiVol;
DWORD PreviousMidiVol;

typedef struct {
    //ULONG Time;
    ULONG Length;
} CMDHDR;

void
SendMidiRequest(
    void
    );

//
// We define NextData==LastData to mean that the buffer
// is empty.  This means that we can only load MIDI_BUFFER_SIZE-1
// bytes into our buffer - since we use modulo operations to
// determine actual buffer addresses.
//


BOOL
OpenMidiDevice(
    HANDLE CallbackEvent
    )

/*++

Routine Description:

    This function opens MIDI device.

Arguments:

    CallbackEvent - specifies the callback Event

Return Value:

    TRUE - if success otherwise FALSE.

--*/

{
   UINT rc,i;

   for (i = 0 ; i < MESSAGE_HEADERS; i++) {
       MidiHdrs[i] = (MIDIHDR *) (MessageBuffer + i *  MESSAGE_CHUNK_SIZE);
       MidiHdrs[i]->lpData = (LPSTR)((ULONG)MidiHdrs[i] + sizeof(MIDIHDR));
       MidiHdrs[i]->dwBufferLength = MESSAGE_CHUNK_SIZE - sizeof(MIDIHDR);
       MidiHdrs[i]->dwUser = 0;
       MidiHdrs[i]->dwFlags = 0;
   }

   if (CallbackEvent) {
      rc = MidiOpenProc(&HMidiOut, (UINT)MIDIMAPPER, (DWORD)CallbackEvent, 0, CALLBACK_EVENT);
   } else {
      rc = MidiOpenProc(&HMidiOut, (UINT)MIDIMAPPER, 0, 0, CALLBACK_NULL);
   }

   if (rc != MMSYSERR_NOERROR) {
      dprintf1(("Failed to open MIDI device - code %d", rc));
      return FALSE;
   }
   if (HMidiOut) {
       for (i = 0 ; i < MESSAGE_HEADERS; i++) {
           if (MMSYSERR_NOERROR != MidiPrepareHeaderProc(HMidiOut, MidiHdrs[i], sizeof(MIDIHDR))) {
               dprintf1(("Prepare MIDI hdr failed"));
               MidiCloseProc(HMidiOut);
               HMidiOut = NULL;
               return FALSE;
           }
       }
       GetMidiVolumeProc(HMidiOut, &OriginalMidiVol);
       PreviousMidiVol = OriginalMidiVol;
   }
   return TRUE;
}

VOID
SetMidiOutVolume(
    DWORD Volume
    )

/*++

Routine Description:

    This function sets MidiOut volume

Arguments:

    Volume - specifies the volume scale

Return Value:

    None.

--*/

{
    DWORD currentVol;

    if (HMidiOut) {
        if (GetMidiVolumeProc(HMidiOut, &currentVol)) {
            if (currentVol != PreviousMidiVol) {
                //
                // SOmeone changed the volume besides NTVDM
                //

                OriginalMidiVol = currentVol;
            }
            PreviousMidiVol = Volume;
            SetMidiVolumeProc(HMidiOut, Volume);
        }
    }
}

VOID
ResetMidiDevice(
    VOID
    )

/*++

Routine Description:

    This function resets MIDI device.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

    dprintf2(("Resetting MIDI device"));
    if (HMidiOut) {

        //
        // Make sure all the headers are done playing
        //

        i = 0;
        while (i < MESSAGE_HEADERS) {
            if (MidiHdrs[i]->dwFlags & MHDR_INQUEUE) {
                Sleep(5000);
            } else {
                i++;
            }
        }

        //
        // Now reset the MIDI out device
        //

        if (MMSYSERR_NOERROR != MidiResetProc(HMidiOut)) {
            dprintf1(("Unable to reset MIDI out device"));
        }
    }
    dprintf2(("MIDI device reset"));
}

VOID
CloseMidiDevice(
    VOID
    )

/*++

Routine Description:

    This function shuts down and closes MIDI device.

Arguments:

    None.

Return Value:

    None.

--*/

{
   ULONG i;
   DWORD currentVol;

   dprintf2(("Closing MIDI device"));

   if (MidiInitialized) {
       ResetMidiDevice();
   }

   if (HMidiOut) {

       if (GetMidiVolumeProc(HMidiOut, &currentVol)) {
           if (currentVol == PreviousMidiVol) {
               //
               // If we are the last one changed volume restore it
               // otherwise leave it alone.
               //
               SetMidiVolumeProc(HMidiOut, OriginalMidiVol);
           }
       }

       for (i = 0 ; i < MESSAGE_HEADERS; i++) {
           if (MMSYSERR_NOERROR != MidiUnprepareHeaderProc(HMidiOut, MidiHdrs[i], sizeof(MIDIHDR))) {
               dprintf1(("Unprepare MIDI hdr failed"));
           }
       }
       if (MMSYSERR_NOERROR != MidiCloseProc(HMidiOut)) {
          dprintf1(("Unable to close MIDI out device"));
       }
       HMidiOut = NULL;
   }
   dprintf2(("Midi Closed"));
}

BOOL
InitializeMidi(
    VOID
    )

/*++

Routine Description:

    This function opens MIDI out device, initializes MIDI headers and global variables.

Arguments:

    None.

Return Value:

    None.

--*/

{

    LONG i;
    BOOL rc = FALSE;
    DWORD id;

    //
    // malloc MidiBuffer and MessageBuffer
    //

    MidiBuffer = (UCHAR *) VirtualAlloc(NULL,
                                        MIDI_BUFFER_SIZE,
                                        MEM_RESERVE | MEM_COMMIT,
                                        PAGE_READWRITE);
    if (MidiBuffer == NULL) {
        dprintf1(("Unable to allocate MidiBuffer memory"));
        return rc;
    }

    MessageBuffer = (UCHAR *) VirtualAlloc(NULL,
                                        MESSAGE_BUFFER_SIZE,
                                        MEM_RESERVE | MEM_COMMIT,
                                        PAGE_READWRITE);
    if (MessageBuffer == NULL) {
        dprintf1(("Unable to allocate MessageBuffer memory"));
        VirtualFree(MidiBuffer, 0, MEM_RELEASE);
        return rc;
    }

    //
    // Open MIDI device
    //

    OpenMidiDevice(0);

    if (HMidiOut) {

        NextData = LastData = 0;
        BytesLeft = 0;
        LastCommand=0;
        LastCommandLength = 1;
        RunningStatus = 0;
        NextCopyPosition = 0;
        Alignment = sizeof(CMDHDR) + 4 - 1;
        MidiInitialized = TRUE;

        rc = TRUE;
    }

    if (!rc) {
        if (MidiBuffer) {
            VirtualFree(MidiBuffer, 0, MEM_RELEASE);
            MidiBuffer = NULL;
        }
        if (MessageBuffer) {
            VirtualFree(MessageBuffer, 0, MEM_RELEASE);
            MessageBuffer = NULL;
        }
        CloseMidiDevice();
    }
    return rc;
}

VOID
BufferMidi(
    BYTE data
    )

/*++

Routine Description:

    This function receives MIDI command/data.  Make sure that while we are loading
    a command that we track the midi state correctly.  In other words, handle system
    realtime messages and system common messages correctly.  Also handle cases when
    bytes get dropped out of commands.

Arguments:

    data - supplies a byte as data or command.

Return Value:

    None.

--*/

{
    LONG i;
    CMDHDR *header;
    LONG endPtr;

    if (BytesLeft) {
        if (data >= 0xf8) {

            //
            // This is a system realtime message, we have received it in
            // the middle of a command.  This should only happen if the
            // app wants it to have the same time stamp as the current
            // command.

            // We handle this differently depending on whether we
            // get the realtime message inside a system exclusive
            // message or not.  If it is NOT inside system exclusive,
            // then we reorder this to be the current command and
            // send the current command as the next chunk.

            // If it IS inside a system exclusive, then we terminate
            // the current chunk, add a new chunk for the realtime
            // message, and then quit - since the running status
            // will resume the system exclusive message on the next
            // chunk.

            if (RunningStatus == 0xf0) {  // We are in a sysex message.

                dprintf3(("Realtime system message inside a sysex message!"));

                //
                // In this case, we truncate sysex.  Set the length to the current
                // received data length.
                //

                header = (CMDHDR*)ToBufferAddr(LastCommand);
                header->Length -= BytesLeft;
                BytesLeft = 0;

                //
                // Now we are ready to do normal processing.  That
                // will put this realtime message in as the next
                // command without affecting running status, and the
                // byte following will continue as a sysex - because
                // of the running status.
                //
            } else {
                dprintf3(("Realtime system message inside a non sysex message!"));
                dprintf3(("Creating a new message."));

                //
                // Now copy the old chunk into the next slot.  Note
                // that we do this from back to front so that it works
                // regardless of the size of the current chunk.
                //

                endPtr = NextData + Alignment + 1 + sizeof(CMDHDR) + 1;
                i = NextData;
                NextData = endPtr;
                ToBufferIndex(NextData);
                while (i != LastCommand) {
                    endPtr--; i--;
                    ToBufferIndex(endPtr);
                    ToBufferIndex(i);
                    MidiBuffer[endPtr] = MidiBuffer[i];
                }

                //
                // Now update the first chunk size and data with the
                // realtime message size and data.
                //

                header = (CMDHDR *) ToBufferAddr(i);
                header->Length = 1;
                i += sizeof(CMDHDR);
                ToBufferIndex(i);
                MidiBuffer[i] = data;

                //
                // Now update the LastCommand and NextData pointers to
                // point to the correct spots in the new chunk.
                //

                LastCommand += sizeof(CMDHDR) + 1;
                Align(LastCommand);
                ToBufferIndex(LastCommand);

                // Really we should check if we need to queue stuff
                // down - since if we repeatedly get these embedded
                // realtime commands before this command completes
                // we could exhaust our buffer space without ever
                // sending down a new block of commands.  For now
                // we don't do that.

                return;

            }
        } else if (data >= 0xf0) {

            if (RunningStatus == 0xf0 && data == 0xf7) {
                dprintf3(("Sysex stop!"));

                //
                // Add the 0xf7 to the end of the sysex command.
                //

                MidiBuffer[NextData] = data;
                NextData++;
                ToBufferIndex(NextData);
                BytesLeft--;

                //
                // Now update the count of the command so it is correct.
                //

                header = (CMDHDR*)ToBufferAddr(LastCommand);
                header->Length -= BytesLeft;

                //
                // Now update our running status and BytesLeft for the
                // completed sysex command.
                //

                RunningStatus = 0;
                BytesLeft = 0;

                goto SendDownAChunk;  // Jump to command complete processing.

            } else {

                //
                // This is a system common message.  It cancels any running
                // status.  Note that the previous command should have
                // completed.
                //

                dprintf3(("Got a system common message before previous command completed!"));
                dprintf3(("Truncating previous command!"));

                //
                // In this case, we truncate the previously started command.
                //

                header = (CMDHDR*)ToBufferAddr(LastCommand);
                header->Length -= BytesLeft;
                BytesLeft=0;
            }

        } else if (data >= 0x80) {

            //
            // This is a new command that we have received EARLY.  Before
            // the previous command completed.

            dprintf1(("Got a new command before previous command completed!"));
            dprintf1(("Truncating previous command!"));

            //
            // In this case, we truncate the previously started command.
            //

            header = (CMDHDR*)ToBufferAddr(LastCommand);
            header->Length -= BytesLeft;
            BytesLeft = 0;

        }
    }

    if (BytesLeft == 0) {

        //
        // We are starting a new MIDI command.
        //


        //
        // Now calculate the length of the incomming command based
        // on its status byte or on the running status.  Also,
        // track the running status.
        //

        if (data >= 0xf8) {

            //
            // This is a system realtime message.  It is 1 byte long.
            // It does NOT affect running status!
            //
            BytesLeft = 1;

        } else if (data >= 0xf0) {

            //
            // This is a system common message. It cancels any running status.
            //

            RunningStatus = 0;
            LastCommandLength = 0;

            switch (data) {

                case 0xf0: // System Exclusive message
                    dprintf3(("Sysex start!"));
                    BytesLeft = 128;
                    RunningStatus = data;
                    LastCommandLength = BytesLeft;
                    break;

                case 0xf1:
                case 0xf3:
                    BytesLeft=2;
                    break;

                case 0xf2:
                    BytesLeft=3;
                    break;

                case 0xf4:
                case 0xf5:
                    dprintf1(("Received undefined system common message 0x%x!",data));

                    //
                    // Fall through to other 1 byte system common
                    // messages.
                    //

                default:
                    BytesLeft = 1;
            }

        } else if (data >= 0x80) {

            //
            // This is the start of a standard midi command.
            // Track the running status.
            //

            RunningStatus = data;

            if (data < 0xc0 || data > 0xdf) {
                BytesLeft=3;
            } else {
                BytesLeft=2;
            }
            LastCommandLength = BytesLeft;

        } else {

            //
            // This should be the start of a new command.
            // We better have a valid running status.
            //

            if (RunningStatus) {
                dprintf3(("Using running status 0x%x!", RunningStatus));
                BytesLeft = LastCommandLength - 1;

            } else {
                // No valid running status, so we drop these bits
                // on the floor.
                dprintf1(("Received data 0x%x without running status.  Dropping!", data));
                return;
            }

        }

        //
        // Remember where the last (newest) command starts.
        //

        Align(NextData);
        ToBufferIndex(NextData);

        LastCommand = NextData;

        header = (CMDHDR *)ToBufferAddr(NextData);
        header->Length = BytesLeft;

        NextData += sizeof(CMDHDR);
        ToBufferIndex(NextData);

    }

    //
    // Now save the data and update the indeces
    // and counts.

    MidiBuffer[NextData] = data;
    NextData++;
    ToBufferIndex(NextData);
    BytesLeft--;

    //
    // Now try to queue down the next chunk of midi data.
    // We can when the current midi command is complete, the
    // previous buffer queued down has completed and we have
    // "enough" (25ms) data queued up in our buffer.
    //
SendDownAChunk:

    if (BytesLeft == 0) {

        //
        // We have just completed loading a command.
        //

        SendMidiRequest();
    }
    return;
}

DWORD
MidiCopyMessages (
    PUCHAR Buffer
    )

/*++

Routine Description:

    This function copies MIDI data from MIDI buffer to Message Buffer.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CMDHDR *header;
    ULONG totalLength = 0, length;

    dprintf3(("Midi: copy messages"));
    while (NextCopyPosition != LastCommand) {
        header = (CMDHDR *)ToBufferAddr(NextCopyPosition);
        length = header->Length;

        //
        // perform copy from MidiBuffer to message buffer
        // take care of the wrapping condition
        //

        NextCopyPosition += sizeof(CMDHDR);
        ToBufferIndex(NextCopyPosition);
        totalLength += length;
        while (length != 0) {
            *Buffer++ = MidiBuffer[NextCopyPosition++];
            length--;
            ToBufferIndex(NextCopyPosition);
        }

        //
        // Leave NextCopyPosition at the beginning of next command
        //

        Align(NextCopyPosition);
        ToBufferIndex(NextCopyPosition);

        //
        // Don't overflow our message buffer
        //

        if (totalLength >= MIDI_BUFFER_FULL_THRESHOLD) {
            break;
        }
    }
    return totalLength;
}

VOID
SendMidiRequest(
    VOID
    )

/*++

Routine Description:

    This function calls MidiOut API to send midi request.

Arguments:

    None.

Return Value:

    always returns 0

--*/

{
    ULONG i, length;
    CMDHDR *header;
    DWORD midiData, *pData;

    if (HMidiOut) {

        while (NextCopyPosition != LastCommand) {

            header = (CMDHDR *)ToBufferAddr(NextCopyPosition);
            length = header->Length;

            if (length <= 3) {

                //
                // if we can handle the midi request with short message,
                // don't bother with long message.
                //

                pData = (DWORD *)((PUCHAR)header + sizeof(CMDHDR));
                midiData = *pData;
                MidiShortMsgProc(HMidiOut, midiData);
                NextCopyPosition += sizeof(CMDHDR) + 4;

                //
                // Leave NextCopyPosition at the beginning of next command
                //

                Align(NextCopyPosition);
                ToBufferIndex(NextCopyPosition);
            } else {

                //
                // check if there is any available MIDI header for us to send the data down.
                //

                for (i = 0; i < MESSAGE_HEADERS; i++) {
                    if (!(MidiHdrs[i]->dwFlags & MHDR_INQUEUE)) {
                        break;
                    }
                }
                if (i == MESSAGE_HEADERS) {
                    dprintf2(("midi: No Midi header available"));
                    return;
                }

                //
                // Copy MIDI messages from MidiBuffer to the buffer in MidiHeader
                //

                dprintf3(("Midi data received"));
                MidiHdrs[i]->dwBytesRecorded = MidiCopyMessages(MidiHdrs[i]->lpData);

                //
                // Send the MIDI header to MIDI driver
                //

                dprintf2(("send MIDI data to driver %x",MidiHdrs[i]->dwBytesRecorded ));
                MidiLongMsgProc(HMidiOut, MidiHdrs[i], sizeof(MIDIHDR));
                break;
            }
        }
    }
}

VOID
DetachMidi(
    VOID
    )

/*++

Routine Description:

    This function cleans up the MIDI process to prepare to exit.

Arguments:

    None.

Return Value:

    None.

--*/

{
    dprintf2(("Detach MIDI"));

    if (MidiInitialized) {

        //
        // Free allocated memory
        //

        CloseMidiDevice();
        VirtualFree(MidiBuffer, 0, MEM_RELEASE);
        VirtualFree(MessageBuffer, 0, MEM_RELEASE);

        MidiInitialized = FALSE;
    }
}

#if REPORT_SB_MODE
void
DisplaySbMode(
    USHORT Mode
    )
{
    if (IsDebuggerPresent && (DisplayFlags & Mode)) {
        switch(Mode){
            case DISPLAY_SINGLE:
                DbgOut("VSB: SINGLE CYCLE mode\n");
                break;
            case DISPLAY_HS_SINGLE:
                DbgOut("VSB: HIGH SPEED SINGLE CYCLE mode\n");
                break;
            case DISPLAY_AUTO:
                DbgOut("VSB: AUTO-INIT mode\n");
                break;
            case DISPLAY_HS_AUTO:
                DbgOut("VSB: HIGH SPEED AUTO-INIT mode\n");
                break;
            case DISPLAY_MIDI:
                DbgOut("VSB: MIDI mode\n");
                break;
            case DISPLAY_MIXER:
                DbgOut("VSB: MIXER mode\n");
                break;
            case DISPLAY_ADLIB:
                DbgOut("VSB: ADLIB/FM mode\n");
                break;
        }
        DisplayFlags = 0xffff & ~Mode;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sound.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddbeep.h>
#include <windows.h>
#include "insignia.h"
#include "host_def.h"
/*
 * VPC-XT Revision 2.0
 *
 * Title        : sg_sound.c
 *
 * Description  : This module provides functions to control sound.  The
 *                functions are defined:
 *
 *                host_ring_bell(duration)
 *                host_alarm(duration)
 *                host_timer2_waveform(delay,lowclocks,hiclocks,lohi,repeat)
 *                host_enable_timer2_sound()
 *                host_disable_timer2_sound()
 *
 * Author       :
 *
 * Notes        :
 */

#include "xt.h"
#include "config.h"
#include "debug.h"
#include "error.h"
#include <stdio.h>
#include "trace.h"
#include "video.h"
#include "debug.h"
#if defined(NEC_98)
#include "gvi.h"
#include "sas.h"
#include "ios.h"
#include "bios.h"
#define TIMER_CLOCK_DENOM_10    2457600
#define TIMER_CLOCK_DENOM_8     1996800
static DWORD frequency;
static BOOL NEC98_beep_on=FALSE;
#endif // NEC_98

RTL_CRITICAL_SECTION SoundLock;
#define LOCK_SOUND() RtlEnterCriticalSection(&SoundLock)
#define UNLOCK_SOUND() RtlLeaveCriticalSection(&SoundLock)

IMPORT ULONG GetPerfCounter(VOID);

ULONG FreqT2    = 0;
BOOL  PpiState  = FALSE;
BOOL  T2State   = FALSE;
ULONG LastPpi   = 0;
ULONG FreqPpi   = 0;
ULONG ET2TicCount=0;
ULONG PpiCounting  = 0;

HANDLE hBeepDevice = 0;
ULONG BeepCloseCount = 0;
ULONG BeepLastFreq = 0;
ULONG BeepLastDuration = 0;


// human frequency audible sound range
#define AUDIBLE_MIN 10
#define AUDIBLE_MAX 20000
#define CLICK       100

VOID LazyBeep(ULONG Freq, ULONG Duration);
void PulsePpi(void);

/*============================================================================

        host_alarm - ring bell irrespective of configuration (used on keyboard
        buffer overflow for example).

=============================================================================*/

void host_alarm(duration)
long int duration;
{
    MessageBeep(MB_OK);
}

/*========================================================================

        host_ring_bell - ring bell if configured (used by video on output
        of ^G, for example).

=========================================================================*/

void host_ring_bell(duration)
long int duration;
{
if( host_runtime_inquire(C_SOUND_ON))
   {
   host_alarm(duration);
   }
}


 /*  assumes caller holds ica lock */

VOID InitSound( BOOL bInit)
{
    if (bInit) {
        RtlInitializeCriticalSection(&SoundLock);
    } else {
        if( NtCurrentPeb()->SessionId == 0 ) {
            LOCK_SOUND();
            LazyBeep(0L, 0L);
            if (hBeepDevice && hBeepDevice != INVALID_HANDLE_VALUE) {
                CloseHandle(hBeepDevice);
                hBeepDevice = 0;
                }
            UNLOCK_SOUND();
            return;
        }
    }
}


HANDLE OpenBeepDevice(void)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    HANDLE hBeep;

    if (NtCurrentPeb()->SessionId != 0) {
        return( INVALID_HANDLE_VALUE );
    }

    RtlInitUnicodeString( &NameString, DD_BEEP_DEVICE_NAME_U );
    InitializeObjectAttributes( &ObjectAttributes,
                                &NameString,
                                0,
                                NULL,
                                NULL
                                );

    Status = NtCreateFile( &hBeep,
                           FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatus,
                           NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           (PVOID) NULL,
                           0
                           );

    if (!NT_SUCCESS( Status )) {
#ifndef PROD
        printf("NTVDM: OpenBeepDevice Status=%lx\n",Status);
#endif
        hBeep = INVALID_HANDLE_VALUE;
        }


    return hBeep;
}




/*
 * LazyBeep -
 * Calls Beep Device Driver asynchronously
 *
 * Acceptable parameters are:
 *   (Freq,Dur)            Action
 *   (0,0)               - stop sound
 *   (nonzero, INFINITE) - play a freq
 *
 * not multithreaded safe
 *
 */
VOID LazyBeep(ULONG Freq, ULONG Duration)
{
  IO_STATUS_BLOCK     IoStatus;
  BEEP_SET_PARAMETERS bps;

  if (Freq != BeepLastFreq || Duration != BeepLastDuration) {
      bps.Frequency = Freq;
      bps.Duration  = Duration;

         //
         // If the duration is < 10 ms, then we assume sound is being
         // off so remember the state as 0,0 so that we won't turn it
         // off again.
         //
      if (Duration < 10) {
         BeepLastFreq = 0;
         BeepLastDuration = 0;
         }
      else {
         BeepLastFreq      = Freq;
         BeepLastDuration  = Duration;
         }

      if (NtCurrentPeb()->SessionId != 0) {
          Beep( Freq, Duration );
      } else {
          if (!hBeepDevice) {
              hBeepDevice = OpenBeepDevice();
              }

          if (hBeepDevice == INVALID_HANDLE_VALUE) {
              return;
              }

          NtDeviceIoControlFile( hBeepDevice,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatus,
                                 IOCTL_BEEP_SET,
                                 &bps,
                                 sizeof(bps),
                                 NULL,
                                 0
                                 );

          BeepCloseCount = 1000;
      }
      }


}





/*
 *  PlaySound
 */
void PlaySound(BOOL bPulsedPpi)
{
  if (PpiState && T2State && FreqT2) {
      LazyBeep(FreqT2, INFINITE);
      }
  else if (FreqPpi > AUDIBLE_MIN) {
      LazyBeep(FreqPpi,INFINITE);
      }
  else if (bPulsedPpi && PpiCounting) {
      LazyBeep(CLICK,1);
      }
  else {
      LazyBeep(0,0);
      }
}




/*
 *  host_timer2_waveform - output specified sound waveform
 *  assumes caller holds ica lock (see base\timer.c)
 */
void host_timer2_waveform(int delay,
                          ULONG loclocks,
                          ULONG hiclocks,
                          int lohi,
                          int repeat)
{
    ULONG ul;

    LOCK_SOUND();
    if (loclocks == INFINITE || hiclocks == INFINITE) {
        FreqT2 = 0;
        }
    else {
        ul  = loclocks + hiclocks;
        if (!ul)
            ul++;
        FreqT2 = 1193180/ul;

        if (FreqT2 >= AUDIBLE_MAX) {
            hiclocks = INFINITE;
            FreqT2 = 0;
            }
        else if (FreqT2 <= AUDIBLE_MIN) {
            loclocks = INFINITE;
            FreqT2 = 0;
            }
        }

    PlaySound(FALSE);
    UNLOCK_SOUND();
}



/*
 *  Updates the hosts Ppi sound state
 */
void HostPpiState(BYTE PortValue)
{
   BOOL   bPpi;

   LOCK_SOUND();

   T2State = PortValue & 1 ? TRUE: FALSE;
   bPpi = PortValue & 2 ? TRUE: FALSE;

   if (bPpi != PpiState) {
       PpiState = bPpi;
       if (PpiState) {
          PulsePpi();
          }

       PlaySound(PpiState);
   }

   UNLOCK_SOUND();
}




void PulsePpi(void)
{
    static ULONG PpiTicStart=0;
    static ULONG PpiCycles  =0;
    ULONG  ul,Elapsed;
    ULONG  PrevTicCount;


    PrevTicCount = ET2TicCount;
    ET2TicCount = GetTickCount();
    Elapsed = ET2TicCount > PrevTicCount
                  ? ET2TicCount - PrevTicCount
                  : 0xFFFFFFFF - ET2TicCount + PrevTicCount;

    if (Elapsed > 200) {
        if (PpiCounting) {
            PpiCounting = 0;
            LastPpi     = 0;
            FreqPpi     = 0;
            }
        return;
        }


    if (!PpiCounting) {
        PpiCounting  = GetPerfCounter();
        PpiCycles    = 0;
        LastPpi      = 0;
        FreqPpi      = 0;
        PpiTicStart  = ET2TicCount;
        return;
        }

    if (PpiTicStart + 200 >= ET2TicCount) {
        PpiCycles++;
        return;
        }


    ul = GetPerfCounter();
    Elapsed = ul >= PpiCounting
               ? ul - PpiCounting
               : 0xFFFFFFFF - PpiCounting + ul;
    if (!Elapsed)   // insurance!
        Elapsed++;
    PpiCounting = ul;
    PpiTicStart = ET2TicCount;

    /*
     *  Calculate the new avergae Ppi, rounding off to keep
     *  signal from wavering.
     */
    ul = (10000 * PpiCycles)/Elapsed;
    if ((ul & 0x0f) > 7)
        ul += 0x10;
    ul &= ~0x0f;
    ul += 0x10;   // fudge factor

    if (!LastPpi)
        LastPpi = ul;
    if (!FreqPpi)
        FreqPpi = LastPpi;

    /*
     * New Average Ppi is derived from previous AveragePpi,
     * plus last Ppi sample count plus current Ppi sample
     * count to get a frequency which has minimal variation
     * and at the same time responsive to change in the
     * apps pulse rate.
     */
    FreqPpi = ((FreqPpi << 2) + LastPpi + ul)/6;
    if ((FreqPpi & 0x0f) > 7)
        FreqPpi += 0x10;
    FreqPpi &= ~0x0f;

    LastPpi = ul;
    PpiCycles = 0;

}



/*============================================================

Function:       PlayContinuousTone()
Called by:      The SoftPC timer.

==============================================================*/

void PlayContinuousTone(void)
{
   ULONG Elapsed;

   LOCK_SOUND();

   if (PpiCounting) {
       Elapsed = GetTickCount();
       Elapsed = Elapsed > ET2TicCount ? Elapsed - ET2TicCount
                             : 0xFFFFFFFF - ET2TicCount + Elapsed;
       if (Elapsed > 200) {
           PpiCounting = 0;
           LastPpi     = 0;
           FreqPpi     = 0;
           }
       }

   PlaySound(FALSE);

   if (NtCurrentPeb()->SessionId == 0) {
       if (!BeepLastFreq && !BeepLastDuration &&
           BeepCloseCount && !--BeepCloseCount)
         {
           if (hBeepDevice && hBeepDevice != INVALID_HANDLE_VALUE) {
               CloseHandle(hBeepDevice);
               hBeepDevice = 0;
               }
           }
   }

   UNLOCK_SOUND();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_sec.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include "insignia.h"
#include "host_def.h"
#include "wchar.h"
#include "stdio.h"

#include "ntstatus.h"
#include <ntddvdeo.h>

#include "nt_fulsc.h"
#include "nt_det.h"
#include "nt_thred.h"
#include "nt_eoi.h"
#include "host_rrr.h"
#include "nt_uis.h"

/*
 * ==========================================================================
 *      Name:           nt_sec.c
 *      Author:         Jerry Sexton
 *      Derived From:
 *      Created On:     5th February 1992
 *      Purpose:        This module contains the function CreateVideoSection
 *                      which creates and maps a section which is used to
 *                      save and restore video hardware data. It can't be in
 *                      nt_fulsc.c because files that include nt.h can't
 *                      include windows.h as well.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 *
 *      03-May-1994 Jonle
 *      videosection creation has been moved to consrv for security
 *      removed all dead code associated with section maintenance
 *
 * ==========================================================================
 */

extern void VdmTrapcHandler(void);
IMPORT int DisplayErrorTerm(int, DWORD, char *, int);
#if defined(NEC_98)
IMPORT BOOL independvsync;
LOCAL HANDLE VRAMSectionHandle = NULL;
LOCAL BYTE ActiveBank = 0;
LOCAL HANDLE GVRAMSectionHandle = NULL;
VOID host_NEC98_vram_free();
VOID host_NEC98_vram_change(BYTE byte);
VOID NEC98_vram_change(BYTE byte);
IMPORT BOOL HIRESO_MODE;
LOCAL HANDLE HWstateSectionHandle = NULL;
#endif // NEC_98

/***************************************************************************
 * Function:                                                               *
 *      LoseRegenMemory                                                    *
 *                                                                         *
 * Description:                                                            *
 *      Lose the memory that will be remapped as vga regen. NOTE: need to  *
 *      make this 'if fullscreen' only.                                    *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID LoseRegenMemory(VOID)
{
#if defined(NEC_98)
    int a;
    ULONG len;
    NTSTATUS status;

#ifdef VSYNC
    if (HIRESO_MODE) {
        a = 0xE0000;
        len = 0x4000;
    } else {
        a = 0xA0000;
        len = independvsync ? 0x5000 : 0x4000;
    }

    status = NtFreeVirtualMemory(
                                (HANDLE)GetCurrentProcess(),
                                (PVOID *)&a,
                                &len,
                                MEM_RELEASE);
    if (!NT_SUCCESS(status))
        DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
#else
    if (HIRESO_MODE) {
        a = 0xE0000;
        len = 0x5000;
    } else {
        a = 0xA0000;
        len = 0x8000;
    }

    status = NtFreeVirtualMemory(
                                (HANDLE)GetCurrentProcess(),
                                (PVOID *)&a,
                                &len,
                                MEM_RELEASE);
    if (!NT_SUCCESS(status))
        DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
#endif

    host_NEC98_vram_free();

#else  // !NEC_98
    int a = 0xa0000;
    ULONG len = 0x20000;
    NTSTATUS status;

    status = NtFreeVirtualMemory(
                                (HANDLE)GetCurrentProcess(),
                                (PVOID *)&a,
                                &len,
                                MEM_RELEASE);
    if (!NT_SUCCESS(status))
        DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
#endif // !NEC_98
}


/***************************************************************************
 * Function:                                                               *
 *      RegainRegenMemory                                                  *
 *                                                                         *
 * Description:                                                            *
 *      When we switch back from fullscreen to windowed, the real regen    *
 *      memory is removed and we are left with a gap. We have to put some  *
 *      memory back into that gap before continuing windowed.              *
 *                                                                         *
 * Parameters:                                                             *
 *      None.                                                              *
 *                                                                         *
 * Return value:                                                           *
 *      VOID                                                               *
 *                                                                         *
 ***************************************************************************/
GLOBAL VOID RegainRegenMemory(VOID)
{
#if defined(NEC_98)
    int regen;
    ULONG len;
    HANDLE processHandle;
    NTSTATUS status;

#ifdef VSYNC
    if (HIRESO_MODE) {
        regen = 0xE0000;
        len = 0x4000;
    } else {
        regen = 0xA0000;
        len = independvsync ? 0x5000 : 0x4000;
    }

    if (!(processHandle = NtCurrentProcess()))
        DisplayErrorTerm(EHS_FUNC_FAILED,(DWORD)processHandle,__FILE__,__LINE__);

    status = NtAllocateVirtualMemory(
                                processHandle,
                                (PVOID *) &regen,
                                0,
                                &len,
                                MEM_COMMIT | MEM_RESERVE,
                                PAGE_EXECUTE_READWRITE);
    if (! NT_SUCCESS(status) )
        DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
#else
    if (HIRESO_MODE) {
        regen = 0xE0000;
        len = 0x5000;
    } else {
        regen = 0xA0000;
        len = 0x8000;
    }

    if (!(processHandle = NtCurrentProcess()))
        DisplayErrorTerm(EHS_FUNC_FAILED,(DWORD)processHandle,__FILE__,__LINE__);

    status = NtAllocateVirtualMemory(
                                processHandle,
                                (PVOID *) &regen,
                                0,
                                &len,
                                MEM_COMMIT | MEM_RESERVE,
                                PAGE_EXECUTE_READWRITE);
    if (! NT_SUCCESS(status) )
        DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
#endif

    NEC98_vram_change(ActiveBank);

#else  // !NEC_98
    int regen = 0xa0000;
    ULONG len = 0x20000;
    HANDLE processHandle;
    NTSTATUS status;

    if (!(processHandle = NtCurrentProcess()))
        DisplayErrorTerm(EHS_FUNC_FAILED,(DWORD)processHandle,__FILE__,__LINE__);

    status = NtAllocateVirtualMemory(
                                processHandle,
                                (PVOID *) &regen,
                                0,
                                &len,
                                MEM_COMMIT | MEM_RESERVE,
                                PAGE_EXECUTE_READWRITE);
    if (! NT_SUCCESS(status) )
        DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
#endif // !NEC_98
}


#ifdef X86GFX

extern RTL_CRITICAL_SECTION IcaLock;
extern LARGE_INTEGER IcaLockTimeout;
extern HANDLE hWowIdleEvent, hMainThreadSuspended;

/*****************************************************************************
 * Function:                                                                 *
 *      GetROMsMapped                                                        *
 *                                                                           *
 * Description:                                                              *
 *      Calls NT to get the ROMS of the host machine mapped into place in    *
 *      emulated memory. The bottom page (4k) of PC memory is copied into    *
 *      the bottom of emulated memory to provide the correct IVT & bios data *
 *      area setup for the mapped bios. (Which will have been initialised).  *
 *                                                                           *
 * Parameters:                                                               *
 *      None                                                                 *
 *                                                                           *
 * Return Value:                                                             *
 *      None - fails internally on NT error.                                 *
 *                                                                           *
 *****************************************************************************/
GLOBAL VOID GetROMsMapped(VOID)
{
    NTSTATUS status;
    VDMICAUSERDATA IcaUserData;
    VDM_INITIALIZE_DATA InitializeData;

    IcaUserData.pIcaLock         = &IcaLock;
    IcaUserData.pIcaMaster       = &VirtualIca[0];
    IcaUserData.pIcaSlave        = &VirtualIca[1];
    IcaUserData.pDelayIrq        = &DelayIrqLine;
    IcaUserData.pUndelayIrq      = &UndelayIrqLine;
    IcaUserData.pDelayIret       = &iretHookActive;
    IcaUserData.pIretHooked      = &iretHookMask;
    IcaUserData.pAddrIretBopTable  = &AddrIretBopTable;
    IcaUserData.phWowIdleEvent     = &hWowIdleEvent;
    IcaUserData.pIcaTimeout      = &IcaLockTimeout;
    IcaUserData.phMainThreadSuspended = &hMainThreadSuspended;

    InitializeData.TrapcHandler  = (PVOID)VdmTrapcHandler;
    InitializeData.IcaUserData   = &IcaUserData;

    status = NtVdmControl(VdmInitialize, &InitializeData);
    if (!NT_SUCCESS(status))
        DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);

}
#endif //X86GFX
#if defined(NEC_98)

PVOID host_NEC98_vram_init()
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   GVRAMAttr;
    LARGE_INTEGER       SectionSize;
    PVOID               BaseAddress;
    PVOID               VRAMAddress;
    ULONG               ViewSize;
    LARGE_INTEGER       SectionOffset;

    InitializeObjectAttributes(&GVRAMAttr,
                               NULL,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    SectionSize.HighPart = 0L;
    SectionSize.LowPart = HIRESO_MODE ? 0x80000 : 0x40000;

    Status = NtCreateSection(&GVRAMSectionHandle,
                             SECTION_MAP_WRITE|SECTION_MAP_EXECUTE,
                             &GVRAMAttr,
                             &SectionSize,
                             PAGE_EXECUTE_READWRITE,
                             SEC_COMMIT,
                             NULL
                            );

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    BaseAddress = (PVOID)NULL;
    ViewSize = 0;
    SectionOffset.HighPart = 0;
    SectionOffset.LowPart = 0;

    Status = NtMapViewOfSection(GVRAMSectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                0,
                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_EXECUTE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    VRAMAddress = BaseAddress;

    if (HIRESO_MODE) {
        BaseAddress = 0xC0000;
        ViewSize = 0x20000;
    } else {
        BaseAddress = 0xA8000;
        ViewSize = 0x18000;
    }

    Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                 &BaseAddress,
                                 &ViewSize,
                                 MEM_RELEASE
                                 );

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    if (!HIRESO_MODE) {
        BaseAddress = 0xE0000;
        ViewSize = 0x8000;
        Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                 &BaseAddress,
                                 &ViewSize,
                                 MEM_RELEASE
                                 );

        if (!NT_SUCCESS(Status)) {
            DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
        }

        NEC98_vram_change(0);

    } else {
        BaseAddress = (PVOID)0xC0000;
        ViewSize = 0x20000;
        SectionOffset.HighPart = 0;
        SectionOffset.LowPart = 0;

        Status = NtMapViewOfSection(GVRAMSectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                ViewSize,
                                &SectionOffset,
                                &ViewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE
                                );

        if (!NT_SUCCESS(Status)) {
            DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
        }
    }

    return(VRAMAddress);
}

VOID host_NEC98_vram_change (BYTE bank)
{
        host_NEC98_vram_free();
        NEC98_vram_change(bank);
}

VOID NEC98_vram_change (BYTE bank)
{
    PVOID               BaseAddress;
    ULONG               ViewSize;
    LARGE_INTEGER       SectionOffset;
    NTSTATUS            Status;

    BaseAddress = (PVOID)0xA8000;
    ViewSize = 0x18000;
    SectionOffset.HighPart = 0;

    if(bank == 0){
        SectionOffset.LowPart = 0x08000;
    } else {
        SectionOffset.LowPart = 0x28000;
    }

    Status = NtMapViewOfSection(GVRAMSectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                ViewSize,
                                &SectionOffset,
                                &ViewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    BaseAddress = (PVOID)0xE0000;
    ViewSize = 0x8000;
    SectionOffset.HighPart = 0;

    if(bank == 0){
        SectionOffset.LowPart = 0x00000;
    } else {
        SectionOffset.LowPart = 0x20000;
    }

    Status = NtMapViewOfSection(GVRAMSectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                ViewSize,
                                &SectionOffset,
                                &ViewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    ActiveBank = bank;

}

VOID host_NEC98_vram_free()
{
    PVOID       BaseAddress;
    NTSTATUS    Status;

    BaseAddress = 0xA8000;

    Status = NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    BaseAddress = 0xE0000;

    Status = NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }
}

GLOBAL PVOID *NEC98_HWstate_alloc(void)
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   HWstateAttr;
    LARGE_INTEGER       SectionSize;
    PVOID               *BaseAddress;
    ULONG               ViewSize, size;
    LARGE_INTEGER       SectionOffset;

    InitializeObjectAttributes(&HWstateAttr,
                               NULL,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    SectionSize.HighPart = 0L;
    SectionSize.LowPart = 0x90000;

    Status = NtCreateSection(&HWstateSectionHandle,
//                             SECTION_MAP_WRITE|SECTION_MAP_EXECUTE,
                             SECTION_MAP_WRITE,
                             &HWstateAttr,
                             &SectionSize,
//                             PAGE_EXECUTE_READWRITE,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL
                            );

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    BaseAddress = NULL;
    ViewSize = 0;

    Status = NtMapViewOfSection(HWstateSectionHandle,
                                NtCurrentProcess(),
                                (PVOID *)&BaseAddress,
                                0,

                                //0,
                                0x90000L,

                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0,
//                                PAGE_EXECUTE_READWRITE
                                PAGE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }
/*
    size = 0x90000L;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                            (PVOID *)&BaseAddress, //????
//                                            BaseAddress, //????
                                            0,
                                            &size,
                                            MEM_COMMIT | MEM_TOP_DOWN,
                                            PAGE_READWRITE);
    if (!NT_SUCCESS(Status))
        if (Status != STATUS_ALREADY_COMMITTED)
            DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
*/
    return BaseAddress;

}


GLOBAL VOID NEC98_HWstate_free(PVOID BaseAddress)
{

    NTSTATUS    Status;
    ULONG ViewSize = 0x90000L;

    if (HWstateSectionHandle == NULL)
        return;

    Status = NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);

    if (!NT_SUCCESS(Status)) {
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
    }

    Status = NtClose(HWstateSectionHandle);
    if (!NT_SUCCESS(Status))
        DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);

    HWstateSectionHandle = NULL;

/*
        Status = NtFreeVirtualMemory(NtCurrentProcess(),
                                 BaseAddress,
                                 &ViewSize,
                                 MEM_RELEASE
                                 );
        if (!NT_SUCCESS(Status)) {
            DisplayErrorTerm(EHS_FUNC_FAILED,Status,__FILE__,__LINE__);
        }
*/
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_smenu.c ===
#include <windows.h>
#include <conapi.h>
#include "insignia.h"
#include "xt.h"
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include "nt_graph.h"
#include "nt_smenu.h"

/*================================================================
Shared data.
================================================================*/
BOOL bKillFlag = FALSE; /* shared with nt_input so the application can be */
                        /* terminated in the input thread */

/*================================================================
Function prototypes.
================================================================*/

void nt_settings_menu();
BOOL FAR PASCAL DosDlgProc(HWND hDlg,WORD mess,LONG wParam,LONG lParam);

/*================================================================
Global data for this file only.
================================================================*/

static HANDLE InstHandle;

/*================================================================
The code starts here.
================================================================*/

void nt_settings_menu()
{
InstHandle=GetModuleHandle(NULL);
if(DialogBox(InstHandle,"DosBox",NULL,(FARPROC)DosDlgProc) == -1)
   DbgPrint("DialogBox() failed\n");
}

BOOL FAR PASCAL DosDlgProc(HWND hDlg,WORD mess,LONG wParam,LONG lParam)
{
int nItem;

switch(mess)
   {
   case WM_INITDIALOG:
      return TRUE;
   case WM_COMMAND:
      {
      switch(wParam)
         {
         case IDD_TERMINATE:
            {
            EndDialog(hDlg,0);
	    nItem=MessageBox(hDlg,"WARNING!!!!\n"
                                  "Termination is a last resort. You\n"
                                  "should end applications by using the\n"
                                  "application's quit or exit command",
                                  "Termination",
                                   MB_OKCANCEL | MB_ICONSTOP | 
                                   MB_DEFBUTTON2 | MB_SYSTEMMODAL);
            if(nItem==IDOK)
               {
               DbgPrint("Close down the application\n");
               bKillFlag = TRUE;
               }
            }
	 break;
         case IDD_DGBOX:
            {
            }
         break;
         case IDD_FULLSCREEN:
            {
            }
         break;
         case IDOK:
         case IDCANCEL:
            EndDialog(hDlg,0);
         }
      return TRUE;
      }
   break;
   }
return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_term.c ===
#include <windows.h>
#include <vdmapi.h>
#include "host_def.h"
#include "insignia.h"

/*
 * ==========================================================================
 *	Name:		nt_term.c
 *	Author:		Simon Frost
 *	Derived From:
 *	Created On:	7th May 1992
 *	Purpose:	This code moved from stubs.c and split to support
 *			the tidy up code and the actual exit code.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 * ==========================================================================
 */

#include <conapi.h>
#include "xt.h"
#include "nt_graph.h"
#ifdef HUNTER
#include "nt_hunt.h"
#endif /* HUNTER */
#include "ntcheese.h"


IMPORT VOID DeleteConfigFiles(VOID); // from command.lib

/*::::::::::::::::::::::::::::::::::::::::: Do host cleanup before exiting */
/*:::::::::::::::: Also called from reset() if VDM 'rebooted' */

void host_term_cleanup()
{
    GfxCloseDown();	// ensure video section destroyed
#ifdef X86GFX
    if (sc.ScreenBufHandle)	//dont want to leave console in graphics mode
	    CloseHandle(sc.ScreenBufHandle);
#endif // X86GFX

    /*:::::::::::::::::::::::::::::::::: Close open printer and comms ports */

    host_lpt_close_all();	/* Close all open printer ports */
    host_com_close_all();	/* Close all open comms ports */
    MouseDetachMenuItem(TRUE);  /* Force the menu item away on quit */

    DeleteConfigFiles();    // make sure temp config files are deleted

}

/*::::::::::::::::::::::::::::::::::::::::::::::::::: Closedown the VDM */
void host_terminate()
{

    host_term_cleanup();
#ifdef HUNTER
    if (TrapperDump != (HANDLE) -1)
	CloseHandle(TrapperDump);
#endif /* HUNTER */

    if(VDMForWOW)
	ExitVDM(VDMForWOW,(ULONG)-1);	  // Kill everything for WOW VDM
    else
	ExitVDM(FALSE,0);

    ExitProcess(0);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Terminate VDM */

VOID TerminateVDM(void)
{

    /*
     *  Do base sepcific cleanup thru terminate().
     *  NOTE: terminate will call host_terminate to do host
     *        specific cleanup
     */

    terminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_thred.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nt_thred.c

Abstract:

    Contains entry points for thread creation and destruction.  These
    entry points only need to be used for threads that will execute in
    application mode.

Author:

    Dave Hastings (daveh) 17-Apr-1992

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <excpt.h>
#include <stdlib.h>
#include <vdm.h>
#include "nt_timer.h"
#include "monregs.h"

typedef struct _ThreadStartUpParameters {
        LPTHREAD_START_ROUTINE lpStartAddress;
        LPVOID                 lpParameter;
} THREADSTARTUPPARAMETERS, *PTHREADSTARTUPPARAMETERS;

VOID cpu_createthread(HANDLE Thread, PVDM_TIB VdmTib);
DWORD ThreadStartupRoutine(PVOID pv);


HANDLE
WINAPI
host_CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
/*++

Routine Description:

    This routine creates a thread that will later be used to execute
    16 bit application instructions.  The parameters and end results
    are the same as the Win 32 CreateThread function.  This function
    allows the IEU to take appropriate action on thread creation.

Arguments:

    lpThreadAttributes -- Supplies the security attributes for the thread
    dwStackSize -- Supplies the size fo the threads stack
    lpStartAddress -- Supplies the starting address for the thread
    lpParameter -- Supplies a parameter to the thread
    dwCreationFlags -- Supplies flags that control the creation of the thread
    lpThreadId -- Returns the Id of the thread

Return Value:

    A handle to the thread if successful,
    0 otherwise.

--*/
{
    HANDLE Thread;
    PTHREADSTARTUPPARAMETERS ptsp;

    ptsp = (PTHREADSTARTUPPARAMETERS) malloc(sizeof(THREADSTARTUPPARAMETERS));
    if (!ptsp) {
        return 0;
        }

    ptsp->lpStartAddress = lpStartAddress;
    ptsp->lpParameter    = lpParameter;

    Thread = CreateThread(
        lpThreadAttributes,
        dwStackSize,
        ThreadStartupRoutine,
        ptsp,
        CREATE_SUSPENDED,
        lpThreadId
        );

    if (Thread) {
        PVDM_TIB VdmTib;

        VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
/****************************** STF ********************************/
#if defined(CCPU) || defined(PIG)
        ccpu386newthread();
#endif
/****************************** STF ********************************/
#ifdef MONITOR
        cpu_createthread(Thread, VdmTib);
#endif
        if (!(dwCreationFlags & CREATE_SUSPENDED))
            ResumeThread(Thread);

    } else {
        free(ptsp);
    }

    return Thread;
}


DWORD ThreadStartupRoutine(PVOID pv)
{
   PTHREADSTARTUPPARAMETERS ptsp=pv;
   THREADSTARTUPPARAMETERS  tsp;
   DWORD dwRet = (DWORD)-1;

   try {
       tsp = *ptsp;
       free(ptsp);
       dwRet = tsp.lpStartAddress(tsp.lpParameter);
   } except(VdmUnhandledExceptionFilter(GetExceptionInformation())) {
       ;  // we shouldn't arrive here
   }

   return dwRet;
}


VOID
WINAPI
host_ExitThread(
    DWORD dwExitCode
    )
/*++

Routine Description:

    This routine exits a thread.  It allows the IEU to take appropriate
    acction on thread terminiation.  This routine only needs to be called
    for threads have been created with host_CreateThread

Arguments:

    dwExitCode -- Supplies the exit code for the thread.

Return Value:

    None.

--*/
{
/****************************** STF ********************************/
#if defined(CCPU) || defined(PIG)
    ccpu386exitthread();
#endif
/****************************** STF ********************************/
#ifdef MONITOR
    cpu_exitthread();
#endif
    ExitThread(dwExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_timer.c ===
/*                      INSIGNIA MODULE SPECIFICATION
                        -----------------------------


        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.

DOCUMENT                :

RELATED DOCS            :

DESIGNER                : Dave Bartlett

REVISION HISTORY        :
First version           : 20 May 1991           Dave Bartlett

SUBMODULE NAME          : nt_timer

SOURCE FILE NAME        : nt_timer.c

PURPOSE                 : To provide the source of timing information
                          for the Win32 SoftPC, so that actions which
                          need to be taken at regular intervals may be
                          correctly scheduled.
*/


/*
[1.INTERMODULE INTERFACE SPECIFICATION]

[1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]

        INCLUDE FILE : nt_time.h

[1.1    INTERMODULE EXPORTS]

        PROCEDURES() :  int nt_timer_init()
                        int nt_timer_setup()
                        int nt_timer_shutdown()
                        int nt_timer_event()

-------------------------------------------------------------------------
[1.2 DATATYPES FOR [1.1]

        STRUCTURES/TYPEDEFS/ENUMS:

-------------------------------------------------------------------------
[1.3 INTERMODULE IMPORTS]

        PROCEDURES() :  do_key_repeats()                        (module keyboard)

-------------------------------------------------------------------------
=========================================================================
PROCEDURE                 :     int nt_timer_init()

PURPOSE           :     To initialise the host timing subsystem

PARAMETERS        :     none

GLOBALS           :     none

RETURNED VALUE    :     0  => failure
                          :     ~0 => success

DESCRIPTION       :     This function initialises the timing subsystem

ERROR INDICATIONS :     return value

ERROR RECOVERY    :     Timing subsystem has not been initialised
=========================================================================
PROCEDURE                 :     int nt_timer_setup()

PURPOSE           :     To start the host timing subsystem

PARAMETERS        :     none

GLOBALS           :     none

RETURNED VALUE    :     0  => failure
                          :     ~0 => success

DESCRIPTION       :     This function starts the timing subsystem

ERROR INDICATIONS :     return value

ERROR RECOVERY    :     Timing subsystem has not been started
=========================================================================
PROCEDURE                 :     int nt_timer_shutdown()

PURPOSE           :     To stop the host timing subsystem

PARAMETERS        :     none

GLOBALS           :     none

RETURNED VALUE    :     0  => failure
                          :     ~0 => success

DESCRIPTION       :     This function stops the timing subsystem

ERROR INDICATIONS :     return value

ERROR RECOVERY    :     Timing subsystem has not been stopped
=========================================================================
PROCEDURE                 :     int nt_timer_event()

PURPOSE           :     To indicate to the timing subsystem that a timer
                                event may now take place, and to cause any time-based
                                activities to occur.

PARAMETERS        :     none

GLOBALS           :     none

DESCRIPTION       :     All functions implementing time-based functions
                                are called if their turn has arrived.

ERROR INDICATIONS :     none

ERROR RECOVERY    :     errors are ignored
/*=======================================================================
[3.INTERMODULE INTERFACE DECLARATIONS]
========================================================================*/

/* [3.1 INTERMODULE IMPORTS] */

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "insignia.h"
#include "host_def.h"

#include <stdio.h>
#include <sys/types.h>
#include <signal.h>
#include <time.h>
#include <excpt.h>

#include "xt.h"
#include CpuH
#include "bios.h"
#include "sas.h"
#include "timer.h"
#include "tmstrobe.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "timeval.h"
#include "timestmp.h"
#include "host_rrr.h"
#include "error.h"
#include "quick_ev.h"
#include "nt_timer.h"
#include "nt_uis.h"
#include "idetect.h"

#include "debug.h"
#ifndef PROD
    #include "trace.h"
    #include "host_trc.h"
#endif

#include "ica.h"
#include "nt_uis.h"
#include "nt_thred.h"
#include "nt_com.h"
#include <ntddvdeo.h>
#include "conapi.h"
#include "nt_fulsc.h"
#include "nt_graph.h"
#include "nt_det.h"
#include "nt_reset.h"
#include "nt_pif.h"
#include "nt_eoi.h"
#include "nt_event.h"

/*::::::::::::::::::::::::::::::::::::::::::::::::::::: INTERMODULE EXPORTS */

IMPORT void ReinitIdealTime(struct host_timeval *);
THREAD_DATA ThreadInfo;
CRITICAL_SECTION TimerTickCS;
CRITICAL_SECTION HBSuspendCS;


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Local Declarations */

DWORD Win32_host_timer(void);
NTSTATUS DelayHeartBeat(LONG Delay);
VOID  host_init_bda_timer(void);
GLOBAL void  rtc_init IFN0();
VOID InitPerfCounter(VOID);
DWORD HeartBeatThread(PVOID pv);
void CreepAdjust(LARGE_INTEGER DiffTime);
void DemHeartBeat(void);

#ifndef MONITOR
void quick_tick_recalibrate(void);
#endif

void rtc_init(void);
void RtcTick(struct host_timeval *time);

/*::::::::::::::::::::::::::::::::::::::::::::::: INTERNAL DATA DEFINITIONS */

//
// Perfcounter frequency calculation constants
//
LARGE_INTEGER ulFreqHusec;
LARGE_INTEGER ulFreqSec;


//
// Events for resuming\suspending heartbeat
//
HANDLE hHBResumeEvent;
HANDLE hHBSuspendEvent;

//
// HeartBeat TimeStamps in usec
//
LARGE_INTEGER CurrHeartBeat;
LARGE_INTEGER TimerEventUSec;
LARGE_INTEGER CumUSec;
LARGE_INTEGER CreepUSec;
LARGE_INTEGER CreepTicCount;

int    HeartBeatResumes=0;
BOOL   bDoingTicInterrupt=FALSE;
BOOL   bUpdateRtc;

#if defined (MONITOR) && defined (X86GFX)
HANDLE SuspendEventObjects[3];
#endif
extern PVOID  CurrentMonitorTeb;   // thread that is currently executing instructions.



/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::: NT timer initialise ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void host_timer_init(void)
{

    ThreadInfo.HeartBeat.Handle = CreateThread(
                                              NULL,
                                              8192,
                                              HeartBeatThread,
                                              NULL,
                                              CREATE_SUSPENDED,
                                              &ThreadInfo.HeartBeat.ID
                                              );

    if (!ThreadInfo.HeartBeat.Handle) {
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
        TerminateVDM();
    }

    InitSound(TRUE);

    return;
}

/*
 *  TimerInit
 *
 *  Some of the timerinit stuff was split off, because it needs to be
 *  done before any chance of calling vdm error popups.
 *  Until I understand why creating the heartbeat thread very early
 *  causes a console-ntvdm deadlock, the functions should remain split
 *
 */
void TimerInit(void)
{

    if (!(hHBResumeEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
        TerminateVDM();
    }

    if (!(hHBSuspendEvent = CreateEvent(NULL, FALSE, TRUE, NULL))) {
        DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
        TerminateVDM();
    }

    InitializeCriticalSection(&TimerTickCS);
    InitializeCriticalSection(&HBSuspendCS);

    InitPerfCounter();

}


/*
 *  HeartBeat Termination
 *
 */
void TerminateHeartBeat(void)
{
    NtAlertThread(ThreadInfo.HeartBeat.Handle);
    if (ThreadInfo.HeartBeat.ID != GetCurrentThreadId())
        WaitForSingleObjectEx(ThreadInfo.HeartBeat.Handle, 10000, TRUE);
    CloseHandle(ThreadInfo.HeartBeat.Handle);
    ThreadInfo.HeartBeat.Handle = NULL;
    ThreadInfo.HeartBeat.ID = 0;
    return;
}


//
//  Initialized by base, initialize frequencies for perf counter
//
VOID InitPerfCounter(VOID)
{
    LARGE_INTEGER li, liFreq;


    NtQueryPerformanceCounter(&li, &liFreq);

    ulFreqSec.QuadPart = liFreq.QuadPart;
    ulFreqHusec.QuadPart = liFreq.QuadPart / 10000;

}






//
// returns perf counter in 100's usecs (0.1 millisec)
//
//
ULONG GetPerfCounter(VOID)
{
    LARGE_INTEGER li;

    NtQueryPerformanceCounter(&li, NULL);
    li.QuadPart /= ulFreqHusec.QuadPart;
    return (li.LowPart);
}



//
// returns perf counter in usec
//
//
void GetPerfCounterUsecs(struct host_timeval *time, PLARGE_INTEGER pliTime)
{
    LARGE_INTEGER liSecs;
    LARGE_INTEGER liUsecs;
    LARGE_INTEGER liFreq;

    // get time in secs and usecs
    NtQueryPerformanceCounter(&liFreq, NULL);
    liSecs.QuadPart = liFreq.QuadPart / ulFreqSec.QuadPart;
    liUsecs.QuadPart =  liFreq.QuadPart % ulFreqSec.QuadPart;
    liUsecs.QuadPart =  (liUsecs.QuadPart * 1000000) / ulFreqSec.QuadPart;

    // fill in time if specified
    if (time) {
        time->tv_usec = liUsecs.LowPart;
        time->tv_sec  = liSecs.LowPart;
    }

    // fill in pliTime if specified
    if (pliTime) {
        pliTime->QuadPart = liUsecs.QuadPart + liSecs.QuadPart * 1000000;
    }
    return;
}



/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::: Timer Event Code :::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::;::::::::::::::::*/
void host_timer_event()
{
    if (!VDMForWOW) {
        unsigned char FgBgPriority;

#ifdef X86GFX
        /* Do console calls related to fullscreen switching. */
        CheckForFullscreenSwitch();

#endif /* X86GFX */

        host_graphics_tick();               // video graphics stuff


#ifndef X86GFX
        /* Are there any screen scale events to process. */
        GetScaleEvent();
#endif

        IDLE_tick();                        // IDLE accounting

        /*
         * We can't detect idling on all apps (eg Multiplan). For these apps
         * a PIF setting for 'Foreground Priority' of < 100% is recomended.
         * Where this happens, we idle for the 'unwanted' portion of a tick
         * period.
         */
        FgBgPriority  = sc.Focus ? WNTPifFgPr : WNTPifBgPr;
        if (FgBgPriority < 100)
            PrioWaitIfIdle(FgBgPriority);
    }

#ifndef MONITOR
    quick_tick_recalibrate();
#endif



#ifdef YODA
    CheckForYodaEvents();
#endif

    host_com_heart_beat();              //  com  device

    host_lpt_heart_beat();              //  printer devuce

    host_flpy_heart_beat();             //  direct floppy device

    DemHeartBeat();

    time_strobe();                      // time/date etc. (NOT time ticks)

    PlayContinuousTone();               // sound emulation
}


/*
 * Called to set up the Bios Data area time update vars.
 * and the heart beat's counters
 */
VOID host_init_bda_timer(void)
{
    SYSTEMTIME TimeDate;
    ULONG      Ticks;
    struct host_timeval time;


    CreepTicCount.QuadPart = NtGetTickCount();
    GetPerfCounterUsecs(&time, &CumUSec);
    GetLocalTime(&TimeDate);

    Ticks = (ULONG)TimeDate.wHour * 65543 +
            (ULONG)TimeDate.wMinute * 1092 +
            (ULONG)TimeDate.wSecond * 18 ;

    if (TimeDate.wHour)
        Ticks += (ULONG)TimeDate.wHour/3;
    if (TimeDate.wMinute)
        Ticks += (ULONG)(TimeDate.wMinute*4)/10;
    if (TimeDate.wSecond)
        Ticks += (ULONG)TimeDate.wSecond/5;
    if (TimeDate.wMilliseconds)
        Ticks += ((ULONG)TimeDate.wMilliseconds)/54;

    Ticks++;  // fudge factor!

    CreepUSec = CumUSec;
    TimerEventUSec.QuadPart = CumUSec.QuadPart + SYSTEM_TICK_INTV;
    ReinitIdealTime(&time);


    /*
     * BUGBUG with sas strange errors when writing from non cpu thread
     *
     *     sas_storew(TIMER_LOW, BDA & 0xffff);
     *     sas_storew(TIMER_HIGH, (BDA >> 16) & 0xffff);
     *     sas_store(TIMER_OVFL,  0x01);
     */
    * (word *)(Start_of_M_area + TIMER_HIGH)      = (word)(Ticks >> 16);
    * (word *)(Start_of_M_area + TIMER_LOW)       = (word)Ticks;
    * (half_word *)(Start_of_M_area + TIMER_OVFL) = (half_word)0;


    // reset the Real Time Clock
    rtc_init();

#ifndef MONITOR
    q_event_init();
#endif

}



/*   host_GetSysTime, replacement for the base function
 *
 *
 *   This routine does not return the system's time of day.
 *   Uses the NT performance counter to obtain time stamping
 *   information for the base to use. The resolution is microsecs.
 *
 *   Returns nothing, fills in time structure
 *
 */
void host_GetSysTime(struct host_timeval *time)
{
    LARGE_INTEGER liTime;

    // Don't call kernel unless we have to.
    if (bDoingTicInterrupt) {
        liTime = RtlExtendedLargeIntegerDivide(
                                              CurrHeartBeat,
                                              1000000,
                                              &time->tv_usec);
        time->tv_sec = liTime.LowPart;
    }
    else {
        GetPerfCounterUsecs(time, NULL);
    }
}


/*   host_TimeStamp
 *
 *   This routine does not return the system's time of day.
 *   Uses the NT performance counter to obtain time stamping
 *   information for the base to use. Returns LARGE_INTEGER
 *   with time since boot in usecs.
 *
 */
void host_TimeStamp(PLARGE_INTEGER pliTime)
{
    host_ica_lock();

    if (bDoingTicInterrupt) {
        *pliTime = CurrHeartBeat;
    }
    else {
        GetPerfCounterUsecs(NULL, pliTime);
    }

    host_ica_unlock();
}








/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::: Win32 timer function entry point :::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

DWORD HeartBeatThread(PVOID pv)
{
    DWORD dwRet = (DWORD)-1;

    try {

#ifdef MONITOR
        //
        // On x86 we have to force the creation of the critsect lock semaphore
        // When the heartbeat thread start running the cpu thread holds the
        // ica lock forcing contention (and creation). See ConsoleInit.
        //
        host_ica_lock();   // take ica lock to force creation of critsect
#endif


        //
        // Set our priority above normal, and wait for signal to
        // start heartbeat pulses.
        //
        // For Wow we raise to time critical because wow apps can
        // easily invoke a tight client-csr-server bound loop with
        // boosted priority starving the heartbeat thread. Winbench 311
        // shows this problem when doing polylines test.
        //
        SetThreadPriority(ThreadInfo.HeartBeat.Handle,
                          !(dwWNTPifFlags & COMPAT_TIMERTIC)
                          ? THREAD_PRIORITY_TIME_CRITICAL
                          : THREAD_PRIORITY_HIGHEST
                         );

#ifdef X86GFX
        SuspendEventObjects[0] = hHBSuspendEvent;

        /* Get the switching event handle. */
        if (!VDMForWOW) {
            SuspendEventObjects[1] = hStartHardwareEvent;
            SuspendEventObjects[2] = hErrorHardwareEvent;
        }
        else {
            SuspendEventObjects[1] = INVALID_HANDLE_VALUE;
            SuspendEventObjects[2] = INVALID_HANDLE_VALUE;
        }
#endif

#ifdef MONITOR
        host_ica_unlock();
#endif

        dwRet = Win32_host_timer();

    }
    except(VdmUnhandledExceptionFilter(GetExceptionInformation())) {
        ;  // we shouldn't arrive here
    }

    return dwRet;
}


#ifdef PIG
int TimerCount = 20;
#endif /* PIG */


#if _MSC_FULL_VER >= 13008827
    #pragma warning(push)
    #pragma warning(disable:4715)                   // Not all control paths return (due to infinite loop)
#endif

DWORD Win32_host_timer(void)
{
    NTSTATUS      status;
#ifdef PIG
    int           count = 0;
#endif /* PIG */
    LONG          DelayPeriod;
    LARGE_INTEGER DiffTime;
    LARGE_INTEGER SystemTickIntv;
    LARGE_INTEGER SecIntv;
    LARGE_INTEGER CreepIntv;

    struct host_timeval time;

    DelayPeriod = 50000;
    SystemTickIntv.QuadPart  = SYSTEM_TICK_INTV;
    SecIntv.QuadPart  = SYSTEM_TICK_INTV*18;
    CreepIntv.QuadPart  = Int32x32To64(SYSTEM_TICK_INTV, 1200);   // >1 hr


    /* Start timing loop. */
    while (1) {
        status = DelayHeartBeat(DelayPeriod);
        if (!status) {   // reinitialize counters
            host_ica_lock();
            host_init_bda_timer();
            DelayPeriod = SYSTEM_TICK_INTV - 6000;
            host_ica_unlock();
            continue;
        }

        host_ica_lock();
        bDoingTicInterrupt = TRUE;
        /*
         *  Get the current perf counter time, We ignore wrap
         *  since it only happens every few hundred years.
         */
        GetPerfCounterUsecs(&time, &CurrHeartBeat);


        /*
         *  Increment the cumulative counter
         */
        CumUSec.QuadPart = CumUSec.QuadPart + SYSTEM_TICK_INTV;

        /*
         * if we have passed the creep interval, Adjust the cumulative
         * counter for drift between perfcounter and tic counter.
         */
        DiffTime.QuadPart = CurrHeartBeat.QuadPart - CreepUSec.QuadPart;
        if (DiffTime.QuadPart > CreepIntv.QuadPart) {
            CreepAdjust(DiffTime);
        }

        /*
         *  Calculate Next Delay Period, based on how far
         *  behind we are. ie CurrTime - CumTime.
         */

        DiffTime.QuadPart = CurrHeartBeat.QuadPart - CumUSec.QuadPart;

        if (DiffTime.QuadPart > SecIntv.QuadPart)
        {
            DelayPeriod = 13000;
        }
        else if (DiffTime.QuadPart >= SystemTickIntv.QuadPart)
        {
            DelayPeriod = SYSTEM_TICK_INTV/3;
        }
        else if (DiffTime.QuadPart >= Int32x32To64(SYSTEM_TICK_INTV, -1))
        {
            DiffTime.QuadPart = SystemTickIntv.QuadPart - DiffTime.QuadPart/2;
            DelayPeriod = DiffTime.LowPart;
        }
        else {
            DelayPeriod = SYSTEM_TICK_INTV * 2;
        }


        /*
         * Update the VirtualTimerHardware
         */
#ifdef PIG
        if (++count >= TimerCount)
        {
            time_tick();
            count = 0;
        }
#else
        time_tick();
#endif /* PIG */


        /*
         *  Update the Real Time Clock
         */
        RtcTick(&time);

        bDoingTicInterrupt = FALSE;
        host_ica_unlock();


        /*  Timer Event should occur around 18 times per sec
         *  The count doesn't have to be all that accurate, so we
         *  don't try to make up for lost events, and we do this last
         *  to give a chance for hw interrupts to get thru first.
         */
        if (TimerEventUSec.QuadPart <= CurrHeartBeat.QuadPart) {
            TimerEventUSec.QuadPart = CurrHeartBeat.QuadPart + SYSTEM_TICK_INTV;
            cpu_interrupt(CPU_TIMER_TICK, 0);
            WOWIdle(TRUE);
        }
    }

    return (1);
}

#if _MSC_FULL_VER >= 13008827
    #pragma warning(pop)
#endif


/*
 *  DelayHeartBeat
 *
 *  waits the Delay as required by caller
 *  while also checking for the following:
 *   - suspend\resume events
 *   - screen switching event (x86 graphics)
 *
 *   entry : delay time in micro secs
 *   exit  : TRUE - reinit counters
 */

NTSTATUS DelayHeartBeat(LONG Delay)
{
    NTSTATUS status;
    LARGE_INTEGER liDelay;

    liDelay.QuadPart  = Int32x32To64(Delay, -10);

#ifdef MONITOR

    RewaitSuspend:
    status = NtWaitForMultipleObjects(VDMForWOW ? 1 : 3,
                                      SuspendEventObjects,
                                      WaitAny,
                                      TRUE,
                                      &liDelay);

    // delay time has expired
    if (status == STATUS_TIMEOUT) {
        return status;
    }

    #ifdef X86GFX

    //
    // status == 2 signals a screen switch error event.
    // It will be handled at the end of this routine. That is ErrorExit().
    //
    if (status == 1) {

        //
        // hStartHardwareEvnet - screen switch event
        //
        DoHandShake();
        liDelay.QuadPart = -10;
        goto RewaitSuspend;
    } else if (status == 2) {

        //
        // status == 2 signals a screen switch error event.
        // If the main thread is in the cmdGetNextCmd state, we will ignore the
        // error. Because the app is closed and we will register console again
        // at nt_resume_event_thread.  Otherwise the error will be handled at
        // the end of this routine.  It is ErrorExit();
        //
        if (sc.Registered == FALSE) {
            goto RewaitSuspend;
        }
    }
    #endif

    // suspend event
    if (!status) {
        SuspendEventObjects[0] = hHBResumeEvent;
        ica_hw_interrupt_cancel(ICA_MASTER,CPU_TIMER_INT);
        host_DelayHwInterrupt(CPU_TIMER_INT, 0, 0xFFFFFFFF);

        RewaitResume:
        status = NtWaitForMultipleObjects(VDMForWOW ? 1 : 3,
                                          SuspendEventObjects,
                                          WaitAny,
                                          TRUE,
                                          NULL);

        // resume event
        if (!status) {
            SuspendEventObjects[0] = hHBSuspendEvent;
            return status;
        }


    #ifdef X86GFX
        if (status == 1) {

            //
            // hStartHardwareEvnet - screen switch event
            //
            DoHandShake();
            goto RewaitResume;
        } else if (status == 2) {

            //
            // status == 2 signals a screen switch error event.
            // If the main thread is in the cmdGetNextCmd state, we will ignore the
            // error. Because the app is closed and we will register console again
            // at nt_resume_event_thread.  Otherwise the error will be handled at
            // the end of this routine.  It is ErrorExit();
            //

            if (sc.Registered == FALSE) {
                goto RewaitResume;
            }
        }
    #endif
    }

#else          // ndef MONITOR
//
// On Risc platforms we only have to deal with the
// HeartBeat Resume\Suspend objects so things are much simpler
//

    status = NtWaitForSingleObject(hHBSuspendEvent,
                                   TRUE,
                                   &liDelay);

    if (status == STATUS_TIMEOUT) {
        return status;
    }

    if (status == STATUS_SUCCESS) {  // suspend event
        status = NtWaitForSingleObject(hHBResumeEvent, TRUE, NULL);
        if (status == STATUS_SUCCESS) {
            return status;
        }
    }

#endif

    // alerted to die
    if (status == STATUS_ALERTED) {
        ExitThread(0);
    }


    // Must be an error, announce it to the world
    DisplayErrorTerm(EHS_FUNC_FAILED, status,__FILE__,__LINE__);
    TerminateVDM();
    return status;
}

/*
 *  CreepAdjust
 *
 *  Adjusts the perfcounter cum time stamp for drift from system time of
 *  day (Kernel Tick Count)
 */
void CreepAdjust(LARGE_INTEGER DiffTime)
{
    LARGE_INTEGER DiffTicCount;
    ULONG         ulTicCount;

    // Calculate the elapsed ticcount in usecs
    ulTicCount = NtGetTickCount();
    DiffTicCount.LowPart  = ulTicCount;
    DiffTicCount.HighPart = CreepTicCount.HighPart;
    if (DiffTicCount.LowPart < CreepTicCount.LowPart) {
        DiffTicCount.HighPart++;
    }
    DiffTicCount.QuadPart = DiffTicCount.QuadPart - CreepTicCount.QuadPart;
    DiffTicCount = RtlExtendedIntegerMultiply(DiffTicCount, 1000);

    // Adjust the CumUsec perfcounter time by the diff
    // between tick count and perfcounter.
    DiffTicCount.QuadPart = DiffTicCount.QuadPart - DiffTime.QuadPart;
    CumUSec.QuadPart = CumUSec.QuadPart - DiffTicCount.QuadPart;

    // Reset the Creep Time stamps
    CreepTicCount.QuadPart = ulTicCount;
    CreepUSec     = CurrHeartBeat;
}


/*  SuspendTimerThread\ResumeTimerThread
 *
 *  functions to supsend\resume the heartbeat thread
 *  - used by ntvdm when dos apps exit
 *  - used by wow when only wowexec is running
 *  - used by wow for tasks requiring timer tics\BDA tic count updates
 *
 *  These two functions keep an internal suspend counter, to manage
 *  wows multiple tasks, some which require tics, some don't. As long
 *  as one task requires tics\bda updates, we will deliver them for all
 *  tasks.
 *
 */


/*  SuspendTimerThread
 *
 *  Blocks the timer thread on an event
 *  Increments internal suspend count
 *
 *  This function will NOT wait until the heartbeat is safely blocked
 *  before returning.
 *
 *  entry: void
 *  exit:  void
 *
 */
GLOBAL VOID SuspendTimerThread(VOID)
{
    RtlEnterCriticalSection(&HBSuspendCS);

    if (!--HeartBeatResumes) {
        SetEvent(hHBSuspendEvent);
    }

    RtlLeaveCriticalSection(&HBSuspendCS);
}



/*  ResumeTimerThread
 *
 *  restarts the heart beat thread, by setting event
 *  decrements internal suspend count
 *
 *  entry: void
 *  exit:  void
 *
 */
GLOBAL VOID ResumeTimerThread(VOID)
{
    RtlEnterCriticalSection(&HBSuspendCS);

    if (!HeartBeatResumes++) {
        SetEvent(hHBResumeEvent);
    }

    RtlLeaveCriticalSection(&HBSuspendCS);
}



/*
 *  This function handles all of the toplevel
 *  exceptions for all ntvdm threads which are known.
 *  This includes the event thread, heartbeat thread, comms thread,
 *  and all application threads (those which use host_CreateThread()).
 *
 *  Threads which are not covered are those created by unknown Vdds.
 *
 *  If the UnHandleExecptionFilter api returns EXECEPTION_EXECUTE_HANDLER
 *  the process will be terminated and this routine will not return.
 *
 */
LONG
VdmUnhandledExceptionFilter(
                           struct _EXCEPTION_POINTERS *ExceptionInfo
                           )
{
    LONG lRet;

    SuspendTimerThread();

#ifdef X86GFX
    if (!VDMForWOW && ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION) {

        //
        // If console unregistering ntvdm causes us GP fault.  We will finish
        // the handshake and let timer thread to signal the handshake error.
        // if we hit the error unrelated to FS handshake, then we still need
        // to complete the handshake and signal the error after the handshake
        // is completed.
        //

        if (HandshakeInProgress) {
            if (CurrentMonitorTeb != NtCurrentTeb()) {
                CheckScreenSwitchRequest(hConsoleSuspended);
            } else {
                CheckScreenSwitchRequest(hMainThreadSuspended);
            }
        } else {

            //
            // hErrorHardwareEvent is signaled and timer thread did not catch it
            //

            lRet = WaitForSingleObject(hErrorHardwareEvent, 0);
            if (!lRet) {
                SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
                ErrorExit();
            }
        }
    }
#endif

    lRet = UnhandledExceptionFilter(ExceptionInfo);

    if (lRet == EXCEPTION_EXECUTE_HANDLER) {
        NtTerminateProcess(NtCurrentProcess(),
                           ExceptionInfo->ExceptionRecord->ExceptionCode
                          );
    }

    ResumeTimerThread();
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_umb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    UMB.C

Abstract:

    UMB management functions for NT MVDM

Author:

    William Hsieh  (williamh) Created 21-Sept-1992

[Environment:]

    User Mode, running in the context of MVDM

[Notes:]

    optional-notes

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"              // for romdump
#include "nturtl.h"
#include "windows.h"
#include "host_def.h"
#include "insignia.h"
#include "stdlib.h"
#include "xt.h"
#include CpuH
#include "error.h"
#include "sas.h"
#include "ios.h"
#include "umb.h"

#include <nt_vdd.h>
#include <nt_vddp.h>
#include <emm.h>

PUMBNODE
SpliceUMB(
PUMBNODE    UMB,
DWORD	    dwBase,
DWORD	    Size,
WORD	    Owner
);

BOOL
VDDReserveUMB(
DWORD	    dwBase,
DWORD	    Size,
PUMBNODE    UMB
);
VOID
xmsReleaseUMBNotify(
PVOID	    Address,
DWORD	    Size
);
PUMBNODE    UMBList;

HANDLE	    UMBSectionHandle;

#if defined(NEC_98)
extern  BOOL    HIRESO_MODE;
extern  sys_addr host_check_rs232cex();
#endif // NEC_98

// This function allocate a address space from the UMB area.
// Depends on the requester, this function changes the given address
// space reservation/commitment and ownership states of the block.
// From the very beginning, InitUMBList reserves every possible UMB and
// each unused UMB has owner of UMB_OWNER_NONE or UMB_OWNER_ROM.
// An UMB_OWNER_NONE block is freed and can be claimed by anybody;
// An UMB_OWNER_ROM is mapped to system ROM area and nobody can
// claim it except UMB_OWNER_NONE which includes the ROM UMB as
// usual UMB so that its address space can be used for other purpose.
// This exception was added for VDDs(trusted requesters) only.
// An UMB_OWNER_RAM block is reserved and committed. Nobody can claim
// it except UMB_OWNER_XMS(and UMB_OWNER_XMS can only claim UMB_OWNER_RAM).
// An UMB_OWNER_EMM block is simply reserved.
// An UMB_OWNER_XMS block is reserved, committed and under XMS	control.
// An UMB_OWNER_VDD block is claimed by a VDD via VDDInstallMemoryHook.
// VDD block got special treatment because memory are committed to and
// decommitted from within the block dynamycally, depends on how the
// VDD wants to manipulate it.
//
// WARNING: The given Size and Address must on system page boundary.
//
BOOL
ReserveUMB(
WORD	Owner,
PVOID	*Address,
DWORD	*Size
)
{

#ifdef MONITOR
    NTSTATUS    Status;
#endif

    PUMBNODE	UMB;
    LARGE_INTEGER SectionOffset;

    DWORD dwBase;

    dwBase = (DWORD)*Address;

    // get the UMB list header
    UMB = UMBList;
    SectionOffset.HighPart = 0;

    switch (Owner) {
	case UMB_OWNER_RAM:
	// commit memory to every free UMB in the list
	// this is the only case which works on multiple blocks
	    while (UMB != NULL) {
		if (UMB->Owner == UMB_OWNER_NONE) {
#ifndef	MONITOR
		    // Is this necessary?
		    sas_connect_memory(UMB->Base, UMB->Base + UMB->Size - 1, SAS_RAM);

#else
		    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
						     (PVOID *)&UMB->Base,
						     0,
						     &UMB->Size,
						     MEM_COMMIT,
						     UMB_PAGE_PROTECTION
						     );
		    if (!NT_SUCCESS(Status)) {
			SetLastError(ERROR_OUTOFMEMORY);
			return FALSE;
		    }
#endif
		    UMB->Owner = UMB_OWNER_RAM;
		}
		UMB = UMB->Next;
	    }
	    break;

	case UMB_OWNER_EMM:

	    while (UMB != NULL) {
		if (UMB->Owner == UMB_OWNER_NONE &&
		    UMB->Size >= *Size &&
		    (dwBase == 0 || (dwBase >= UMB->Base &&
				     (dwBase + *Size) <= UMB->Base + UMB->Size))
		    )
		    break;
		UMB = UMB->Next;
	    }
	    if (UMB == NULL) {
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	    }
	    if (dwBase == 0)
		dwBase = UMB->Base;

	    // the found block may be too big for the request
	    // we have to splice the block if that is the case
	    UMB = SpliceUMB(UMB, dwBase, *Size, UMB_OWNER_EMM);
	    // if failed to do something, simple fail
	    if (UMB == NULL) {
		return FALSE;
	    }
#ifdef MONITOR
	    SectionOffset.HighPart = 0;
	    SectionOffset.LowPart = UMB->Base - UMB_BASE_ADDRESS;
	    Status = NtMapViewOfSection(UMBSectionHandle,
					NtCurrentProcess(),
					(PVOID *) &UMB->Base,
					0,
					0,
					&SectionOffset,
					&UMB->Size,
					ViewUnmap,
					MEM_DOS_LIM,
					UMB_PAGE_PROTECTION
					);
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
#endif
	    // return the block address
	    *Address = (PVOID)UMB->Base;
	    break;

	case UMB_OWNER_XMS:
	    // search UMB_OWNER_RAM and claim the ownership
	    while (UMB != NULL && UMB->Owner != UMB_OWNER_RAM) {
		UMB = UMB->Next;
	    }
	    if (UMB == NULL) {
		// don't set last error here
		return FALSE;
	    }
	    else {
		UMB->Owner = UMB_OWNER_XMS;
		*Address = (PVOID)UMB->Base;
		*Size = UMB->Size;
	    }
	    break;

	case UMB_OWNER_VDD:
	    return(VDDReserveUMB(dwBase, *Size, UMB));

// VDDExcludeMem and VDDIncludeMem support cases
	case UMB_OWNER_NONE:
	//call to change a rom block to a free UMB block
	//the given address and size must exactly match

#ifndef	MONITOR
	    // on MIPS, rom blocks are BIOS and VIDEO. No reason to change it
	    return FALSE;
#else
	    while(UMB != NULL && (UMB->Owner != UMB_OWNER_ROM ||
				  UMB->Base !=	dwBase ||
				  UMB->Size != *Size)) {
		UMB = UMB->Next;
	    }
	    if (UMB == NULL) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
	    // unmap the rom first. Kernel map it into a unknown section
	    Status = NtUnmapViewOfSection(NtCurrentProcess(),
					  (PVOID)UMB->Base
					  );
	    if (NT_SUCCESS(Status)) {
		*Address = (PVOID)UMB->Base;
		SectionOffset.LowPart = UMB->Base - UMB_BASE_ADDRESS;
		*Size = UMB->Size;
		// map the address into our section(reserved)
		Status = NtMapViewOfSection(UMBSectionHandle,
					    NtCurrentProcess(),
					    Address,
					    0,
					    0,
					    &SectionOffset,
					    Size,
					    ViewUnmap,
					    MEM_DOS_LIM,
					    UMB_PAGE_PROTECTION
					    );
		if (!NT_SUCCESS(Status)) {
		    SetLastError(ERROR_ACCESS_DENIED);
		    return FALSE;
		}
		UMB->Owner = UMB_OWNER_NONE;
	    }
	    break;
#endif

	case UMB_OWNER_ROM:
	// case to excluede a UMB
	    while (UMB != NULL && (UMB->Owner != UMB_OWNER_NONE ||
				   UMB->Base > dwBase + *Size ||
				   UMB->Base + UMB->Size < dwBase + *Size)) {
		UMB = UMB->Next;
	    }
	    if (UMB == NULL) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
	    UMB = SpliceUMB(UMB, dwBase, *Size, UMB_OWNER_ROM);
	    if (UMB == NULL) {
		return FALSE;
	    }
#ifdef	MONITOR

	    // reserve and commit the block
	    SectionOffset.LowPart = UMB->Base - UMB_BASE_ADDRESS;
	    Status = NtMapViewOfSection(UMBSectionHandle,
					NtCurrentProcess(),
					(PVOID *)&UMB->Base,
					0,
					UMB->Size,
					&SectionOffset,
					&UMB->Size,
					ViewUnmap,
					MEM_DOS_LIM,
					UMB_PAGE_PROTECTION
					);
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
#endif
	    UMB->Owner = UMB_OWNER_ROM;
	    break;


	default:
	    SetLastError(ERROR_INVALID_ADDRESS);
	    return FALSE;
    }
    return TRUE;
}

// This function reclaims the given UMB.
// Note that every reclaimed UMB is set to UMB_OWNER_RAM, reserved and
// committed. After the call, the UMB can be claimed by XMS driver.
// A VDD will find that it can not reserve an UMB second time. This is
// because we have to put the address space into committed states so
// that we won't get access violation and crach VDM(remember we are
// simulating  DOS machine, a machine where applications can do whatever
// they want).

BOOL
ReleaseUMB(
WORD	Owner,
PVOID	Address,
DWORD	Size
)
{

#ifdef MONITOR
    USHORT      Count;
    NTSTATUS    Status;
#endif

    PUMBNODE    UMB;
    LARGE_INTEGER   SectionOffset;
    DWORD       SizeView, dwBase;



    dwBase = (DWORD)Address;

    UMB = UMBList;
    // size, address and owner must match before releasing
    while (UMB != NULL && (UMB->Owner != Owner ||
			   dwBase != UMB->Base ||
			   Size != UMB->Size)) {
	UMB = UMB->Next;
    }
    if (UMB == NULL) {
	SetLastError(ERROR_INVALID_ADDRESS);
	return FALSE;
    }
    SizeView = UMB->Size;
    SectionOffset.HighPart = 0;
    SectionOffset.LowPart = dwBase - UMB_BASE_ADDRESS;

    switch (Owner) {
	case UMB_OWNER_EMM:
#ifndef	MONITOR
	    sas_connect_memory(UMB->Base, UMB->Base + UMB->Size - 1, SAS_RAM);
#else
	    //commit the meory block
	    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
					     (PVOID *) &dwBase,
					     0,
					     &SizeView,
					     MEM_COMMIT,
					     UMB_PAGE_PROTECTION
					     );
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	    }
#endif
	    UMB->Owner = UMB_OWNER_RAM;
	    xmsReleaseUMBNotify((PVOID)UMB->Base, UMB->Size);
	    break;

	case UMB_OWNER_VDD:
#ifndef	MONITOR
	    sas_connect_memory(dwBase, dwBase + Size - 1, SAS_RAM);
#else
            Count = (USHORT)(SizeView / HOST_PAGE_SIZE);
	    SizeView = HOST_PAGE_SIZE;
	    // unmap every page
	    for (; Count > 0; Count--, dwBase += HOST_PAGE_SIZE) {
		Status = NtUnmapViewOfSection(NtCurrentProcess(),
					      (PVOID)dwBase
					      );
		if (!NT_SUCCESS(Status)) {
		    SetLastError(ERROR_ACCESS_DENIED);
		    return FALSE;
		}
	    }
	    SectionOffset.LowPart = UMB->Base - UMB_BASE_ADDRESS;
	    dwBase = UMB->Base;
	    SizeView = UMB->Size;
	    // reserve and commit the meory(the entire block)
	    Status = NtMapViewOfSection(UMBSectionHandle,
					NtCurrentProcess(),
					(PVOID *) &dwBase,
					0,
					SizeView,
					&SectionOffset,
					&SizeView,
					ViewUnmap,
					MEM_DOS_LIM,
					UMB_PAGE_PROTECTION
					);
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
#endif
	    UMB->Owner = UMB_OWNER_RAM;
	    xmsReleaseUMBNotify((PVOID)UMB->Base, UMB->Size);
	    break;

	default:
	    SetLastError(ERROR_INVALID_ADDRESS);
	    return FALSE;
    }
    return TRUE;

}
// This function commit memory to the specific address space
// for VDD.
BOOL
VDDCommitUMB(
PVOID	Address,
DWORD	Size
)
{

#ifdef MONITOR
    NTSTATUS    Status;
    DWORD   Mask, SizeView;
    USHORT  Count;
    LARGE_INTEGER   SectionOffset;
#endif

    PUMBNODE    UMB;
    DWORD   dwBase;

    UMB = UMBList;

    dwBase = (DWORD)Address;
    while(UMB != NULL && (UMB->Owner != UMB_OWNER_VDD ||
			  UMB->Base + UMB->Size < dwBase + Size ||
			  UMB->Base > dwBase + Size)) {
	UMB = UMB->Next;
    }

    if (UMB == NULL){
	SetLastError(ERROR_INVALID_ADDRESS);
	return FALSE;
    }
#ifndef	MONITOR
    sas_connect_memory(dwBase, dwBase + Size - 1, SAS_RAM);
#else
    Mask = 1 << ((dwBase - UMB->Base) / HOST_PAGE_SIZE);
    SizeView =	HOST_PAGE_SIZE;
    Count = (USHORT)(Size / HOST_PAGE_SIZE);
    SectionOffset.HighPart = 0;
    SectionOffset.LowPart = dwBase - UMB_BASE_ADDRESS;

    for (; Count > 0; Count--, Mask <<= 1) {
	// Commit memory if didn't do this before
	if ((UMB->Mask & Mask) == 0) {
	    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
					     (PVOID *)&dwBase,
					     0,
					     &SizeView,
					     MEM_COMMIT,
					     UMB_PAGE_PROTECTION
					     );
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	    }
	    UMB->Mask |= Mask;
	}
	else {
	    // the section has memory for it,
	    // first unmap it and then map it with correct commit size
	    Status = NtUnmapViewOfSection(NtCurrentProcess(),
					   (PVOID)dwBase
					   );
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
	    Status = NtMapViewOfSection(UMBSectionHandle,
					NtCurrentProcess(),
					(PVOID *)&dwBase,
					0,
					HOST_PAGE_SIZE,
					&SectionOffset,
					&SizeView,
					ViewUnmap,
					MEM_DOS_LIM,
					UMB_PAGE_PROTECTION
					);
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	    }
	}
	SectionOffset.LowPart += HOST_PAGE_SIZE;
	dwBase += HOST_PAGE_SIZE;
    }
#endif

    return TRUE;
}
// This function decommit memory from the specific address space
// WARNING: We can never really decommit the memory. We just
// change the address space states from committed to reserve so
// that VDD will get page fault.
BOOL
VDDDeCommitUMB(
PVOID	Address,
DWORD	Size
)
{
#ifdef MONITOR
    NTSTATUS Status;
    DWORD    PageSize, PageMask;
    USHORT   PageCount;
    LARGE_INTEGER SectionOffset;

#endif

    PUMBNODE UMB;
    DWORD   dwBase;



    dwBase = (DWORD)Address;
    UMB = UMBList;
    while(UMB != NULL && (UMB->Owner != UMB_OWNER_VDD ||
			  UMB->Base + UMB->Size < dwBase + Size ||
			  UMB->Base > dwBase + Size)) {
	UMB = UMB->Next;
    }

    if (UMB == NULL) {
	SetLastError(ERROR_INVALID_ADDRESS);
	return FALSE;
    }
#ifndef	MONITOR
    sas_connect_memory(dwBase, dwBase + Size - 1, SAS_VDD);
#else
    PageSize = HOST_PAGE_SIZE;
    PageCount = (USHORT)(Size / HOST_PAGE_SIZE);
    PageMask = 1 <<  ((dwBase - UMB->Base) / HOST_PAGE_SIZE);
    SectionOffset.HighPart = 0;
    SectionOffset.LowPart = dwBase - UMB->Base;
    for (; PageCount > 0; PageCount--, PageMask <<= 1) {
	if ((UMB->Mask & PageMask) != 0) {
	    // this page has memory committed, unmap it first
	    Status = NtUnmapViewOfSection(NtCurrentProcess(),
					  (PVOID)dwBase
					  );
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
	    // finally make a view for the page without commitment
	    Status= NtMapViewOfSection(UMBSectionHandle,
				   NtCurrentProcess(),
				   (PVOID *) &dwBase,
				   0,
				   0,
				   &SectionOffset,
				   &PageSize,
				   ViewUnmap,
				   MEM_DOS_LIM,
				   PAGE_EXECUTE_READWRITE
				   );
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
	}
	SectionOffset.LowPart += HOST_PAGE_SIZE;
	dwBase += HOST_PAGE_SIZE;
    }
#endif

     return TRUE;
}

VOID UMBNotify(
unsigned char code
)
{
    return;
}

// This function release the reserved EMM memory space to the caller
// After the call is made, the address space is FREE and the caller
// has to map the space immediately so that it won't be used by
// the system for storage allocation.
BOOL
GetUMBForEMM(VOID)
{
#ifdef MONITOR
    PUMBNODE	UMB;
    NTSTATUS	Status;
    UMB = UMBList;

    while (UMB!= NULL) {
	if (UMB->Owner == UMB_OWNER_EMM) {
	    Status = NtUnmapViewOfSection(NtCurrentProcess(),
					  (PVOID)UMB->Base
					  );
	    if (!NT_SUCCESS(Status)) {
		SetLastError(ERROR_ACCESS_DENIED);
		return FALSE;
	    }
	}
	UMB = UMB->Next;
    }
#endif
    return TRUE;
}
// This function reserves an address space for VDD
// Here we map a view of section for each page within the requested
// block. This was done because the VDD may want to allocate/deallocate
// physical memory page by page.
BOOL
VDDReserveUMB(
DWORD	dwBase,
DWORD	Size,
PUMBNODE  UMB
)
{

#ifdef MONITOR
    USHORT	Count;
    LARGE_INTEGER   SectionOffset;
    DWORD	SizeView;
    NTSTATUS    Status;
#endif

    while (UMB != NULL) {
	if (UMB->Owner == UMB_OWNER_NONE &&
	    UMB->Base <= dwBase &&
	    UMB->Base + UMB->Size >= dwBase + Size)

	    break;
	else
	    UMB = UMB->Next;
    }
    if (UMB == NULL){
	SetLastError(ERROR_INVALID_ADDRESS);
	return FALSE;
    }
    UMB = SpliceUMB(UMB, dwBase, Size, UMB_OWNER_VDD);
    if (UMB == NULL) {
	return FALSE;
    }
#ifndef	MONITOR
    sas_connect_memory(dwBase, dwBase + Size - 1, SAS_VDD);
#else
    Count = (USHORT)(Size / HOST_PAGE_SIZE);
    SizeView = HOST_PAGE_SIZE;
    SectionOffset.HighPart = 0;
    SectionOffset.LowPart = dwBase - UMB_BASE_ADDRESS;
    // map a view for each page. This is done becuase VDDs may commit
    // and decommit memory for/from their memory hook and the system
    // has 64KB alignment restriction for virtual memory APIs.
    for (; Count > 0; Count--, dwBase += HOST_PAGE_SIZE,
		      SectionOffset.LowPart += HOST_PAGE_SIZE) {
	Status = NtMapViewOfSection(UMBSectionHandle,
				    NtCurrentProcess(),
				    (PVOID *)&dwBase,
				    0,
				    0,
				    &SectionOffset,
				    &SizeView,
				    ViewUnmap,
				    MEM_DOS_LIM,
				    UMB_PAGE_PROTECTION
				    );
	if (!NT_SUCCESS(Status)) {
	    return FALSE;
	}
    }
#endif
    return TRUE;
}

// This helper function splice the given block into multiple
// sublocks(max, 3) and reserves each newly created subblock

PUMBNODE
SpliceUMB(
PUMBNODE    UMB,
DWORD	    dwBase,
DWORD	    Size,
WORD	    Owner
)
{
#ifdef MONITOR
    DWORD    SizeView;
    NTSTATUS Status;
    LARGE_INTEGER SectionOffset;
#endif

    DWORD SizeBefore, SizeAfter;
    PUMBNODE	UMBBefore, UMBAfter;



    SizeBefore = dwBase - UMB->Base;
    SizeAfter = UMB->Size - Size - SizeBefore;
    UMBBefore = UMB;
    if (SizeAfter > 0) {
	// allocate new node(s) before we unmap the block
	UMBAfter =  (PUMBNODE) malloc(sizeof(UMBNODE));
	if (UMBAfter == NULL) {
	    SetLastError(ERROR_OUTOFMEMORY);
	    return NULL;
	}
	UMBAfter->Size = SizeAfter;
	UMBAfter->Base = dwBase + Size;
	UMBAfter->Owner = UMB_OWNER_NONE;
	UMBAfter->Next = UMB->Next;
	UMB->Next = UMBAfter;
	UMB->Size -= SizeAfter;
    }

    if (SizeBefore > 0) {
	UMBBefore = (PUMBNODE) malloc(sizeof(UMBNODE));
	if (UMBBefore == NULL) {
	    SetLastError(ERROR_OUTOFMEMORY);
	    return NULL;
	}

	UMBBefore->Size = Size;
	UMBBefore->Base = dwBase;
	UMBBefore->Owner = Owner;
	UMBBefore->Next = UMB->Next;
	UMB->Next = UMBBefore;
	UMB->Size = SizeBefore;
	UMB->Owner = UMB_OWNER_NONE;
    }
    else {
	UMB->Owner = Owner;
    }

#ifdef MONITOR
    // unmap the entire block because we gona map a view for each subblock
    Status = NtUnmapViewOfSection(NtCurrentProcess(),
				  (PVOID)UMB->Base
				  );
    if (!NT_SUCCESS(Status)) {
	SetLastError(ERROR_ACCESS_DENIED);
	return NULL;
    }
    SectionOffset.HighPart = 0;

    if (SizeBefore > 0) {
	SizeView = UMB->Size;
	dwBase = UMB->Base;
	SectionOffset.LowPart = dwBase - UMB_BASE_ADDRESS;
	Status = NtMapViewOfSection(UMBSectionHandle,
				    NtCurrentProcess(),
				    (PVOID *) &dwBase,
				    0,
				    0,
				    &SectionOffset,
				    &SizeView,
				    ViewUnmap,
				    MEM_DOS_LIM,
				    UMB_PAGE_PROTECTION
				    );
	if (!NT_SUCCESS(Status)) {
	    SetLastError(ERROR_ACCESS_DENIED);
	    return NULL;
	}
    }
    if (SizeAfter > 0){
	dwBase = UMBAfter->Base;
	SectionOffset.LowPart = dwBase - UMB_BASE_ADDRESS;
	SizeView = UMBAfter->Size;
	Status = NtMapViewOfSection(UMBSectionHandle,
				    NtCurrentProcess(),
				    (PVOID *)&dwBase,
				    0,
				    0,
				    &SectionOffset,
				    &SizeView,
				    ViewUnmap,
				    MEM_DOS_LIM,
				    UMB_PAGE_PROTECTION
				    );
	if (!NT_SUCCESS(Status)) {
	    SetLastError(ERROR_ACCESS_DENIED);
	    return NULL;
	}
    }
#endif
    return UMBBefore;
}

// This function initialize UMB list. Every block in the UMA
// area are chained together in a single list
// Each node in the list is either UMB_OWNER_NONE or UMB_OWNER_ROM.
#ifndef	MONITOR
BOOL
InitUMBList(VOID)
{
    PUMBNODE   UMB, UMBNew;
    static DWORD ROMs[] = { EGA_ROM_START, EGA_ROM_END,
				 BIOS_START, 0x100000
			       };
    DWORD CurAddress;
    USHORT  Index;

    UMBList = NULL;

    CurAddress = UMB_BASE_ADDRESS;
    Index  = 0;
    while (CurAddress < UMB_BASE_ADDRESS + UMB_MAX_OFFSET) {
	UMBNew = (PUMBNODE) malloc(sizeof(UMBNODE));
	if (UMBNew == NULL) {
	    SetLastError(ERROR_OUTOFMEMORY);
	    return FALSE;
	}
	UMBNew->Base = CurAddress;
	if (CurAddress == ROMs[Index]) {
	    UMBNew->Owner = UMB_OWNER_ROM;
	    UMBNew->Size = ROMs[Index + 1] - CurAddress;
	    Index += 2;
	}
	else {
	    UMBNew->Owner = UMB_OWNER_NONE;
	    UMBNew->Size  = ROMs[Index] - CurAddress;
	}
	CurAddress += UMBNew->Size;
	if (UMBList == NULL) {
	    UMBList = UMBNew;
	}
	else {
	    UMB->Next = UMBNew;
	}
	UMBNew->Next = NULL;
	UMB = UMBNew;

    }
}

#else
// this is for X86 environment
BOOL
InitUMBList(VOID)

{
    OBJECT_ATTRIBUTES	UMBObjAttr;
    LARGE_INTEGER	UMBSecSize;
    NTSTATUS		Status;
    DWORD		CurAddress, RomAddress, RomSize;
    PUMBNODE		UMB, UMBNew;
    USHORT		Index;

#ifndef NEC_98
    UNICODE_STRING WorkString;
    UCHAR KeyValueBuffer[KEY_VALUE_BUFFER_SIZE];
    HANDLE RegistryHandle;
    ULONG ResultLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PCM_FULL_RESOURCE_DESCRIPTOR        ResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     PartialResourceDescriptor;
#endif // !NEC_98
    PCM_ROM_BLOCK   BiosBlock;

#if defined(NEC_98)
//  DWORD    ROMN[] = { 0xE0000, 0x08000, 0xE8000, 0x18000 };
    DWORD    ROMN[6];
    DWORD    ROMH[] = { 0xF0000, 0x10000 };
    DWORD    UmbBaseAddress;
    DWORD    rs232cex_rom_addr;

//  if( getenv("UMB") == NULL)
//      return FALSE;
#else  // !NEC_98

#ifdef ARCX86
    CM_ROM_BLOCK RomBlock[2];

    if (UseEmulationROM) {
        RomBlock[0].Address = EGA_ROM_START;
        RomBlock[0].Size = 0x8000;
        RomBlock[1].Address = BIOS_START;
        RomBlock[1].Size = 0x100000 - BIOS_START;
        Index = 2;
        BiosBlock = RomBlock;
    } else {
#endif /* ARCX86 */

    RtlInitUnicodeString(
        &WorkString,
        L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM"
        );

    //
    // Set up and open KeyPath
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = NtOpenKey(
                &RegistryHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(Status)) {
#if DBG
       DbgPrint("InitUMBList: can't open \\Registry\\Machine\\Hardware\\Description\\System\n");
#endif
	return FALSE;
    }

    //
    // Get the data for the rom information
    //

    RtlInitUnicodeString(
        &WorkString,
        CONFIG_DATA_STRING
        );

    Status = NtQueryValueKey(
        RegistryHandle,
        &WorkString,
        KeyValueFullInformation,
        (PKEY_VALUE_FULL_INFORMATION)KeyValueBuffer,
        KEY_VALUE_BUFFER_SIZE,
        &ResultLength
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("InitUMBList: Got nothing from Configuration Data\n");
#endif
        NtClose(RegistryHandle);
	return FALSE;
    }

    // Locate registry data for this key
    ResourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)((PUCHAR)KeyValueBuffer
                   + ((PKEY_VALUE_FULL_INFORMATION)KeyValueBuffer)->DataOffset);

    // Verify data returned is large enough to contaim partial resource
    // descriptor.
    if ((((PKEY_VALUE_FULL_INFORMATION)KeyValueBuffer)->DataLength <
                                        sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) ||
                            (ResourceDescriptor->PartialResourceList.Count < 2))
    {
        Index = 0;
    } else {
        PartialResourceDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) (
                    (PUCHAR)ResourceDescriptor + sizeof(CM_FULL_RESOURCE_DESCRIPTOR)
                    + ResourceDescriptor->PartialResourceList.PartialDescriptors[0].u.DeviceSpecificData.DataSize);


        //Verify that there is a 2nd partial resource descriptor, and that it is
        //large enough to contain a ROM block description
        if (((PKEY_VALUE_FULL_INFORMATION)KeyValueBuffer)->DataLength <
                            ((PUCHAR)PartialResourceDescriptor -
                            (PUCHAR)ResourceDescriptor +
                            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                            sizeof(CM_ROM_BLOCK)))
        {
            NtClose(RegistryHandle);
	    return FALSE;
        }

        //get pointer to the first rom desciption
        BiosBlock = (PCM_ROM_BLOCK)((PUCHAR)PartialResourceDescriptor +
                                            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));
        // how many rom blocks we have
        Index = (USHORT) (PartialResourceDescriptor->u.DeviceSpecificData.DataSize /
                          sizeof(CM_ROM_BLOCK));

    }
#ifdef ARCX86
    }
#endif /* ARCX86 */
#endif // !NEC_98

    InitializeObjectAttributes(&UMBObjAttr,
			       NULL,
			       OBJ_CASE_INSENSITIVE,
			       NULL,
			       NULL
			      );

#if defined(NEC_98)
    if(HIRESO_MODE){
        UMBSecSize.LowPart = 0x1B000;
        BiosBlock = ROMH;
        UmbBaseAddress = 0xE5000;
        Index = 1;
    } else {
        UMBSecSize.LowPart = 0x40000;
        BiosBlock = ROMN;
        rs232cex_rom_addr = host_check_rs232cex();
        if(rs232cex_rom_addr) {
            ROMN[0] = rs232cex_rom_addr;
            ROMN[1] = 0x04000;
            ROMN[2] = 0xE0000;
            ROMN[3] = 0x08000;
            ROMN[4] = 0xE8000;
            ROMN[5] = 0x18000;
            Index = 3;
        } else {
            ROMN[0] = 0xE0000;
            ROMN[1] = 0x08000;
            ROMN[2] = 0xE8000;
            ROMN[3] = 0x18000;
            Index = 2;
        }
        UmbBaseAddress = 0xC0000;
    };
#else  // !NEC_98

    UMBSecSize.LowPart = UMB_MAX_OFFSET;
#endif // !NEC_98
    UMBSecSize.HighPart = 0;

    // create a section for the UMB area. Note that the section
    // includes ROM blocks. This was done because we will allow
    // VDDs to put ROM blocks into UMB free list for other users.
    Status = NtCreateSection(&UMBSectionHandle,
			     SECTION_MAP_WRITE|SECTION_MAP_EXECUTE,
			     &UMBObjAttr,
			     &UMBSecSize,
			     UMB_PAGE_PROTECTION,
			     SEC_RESERVE,
			     NULL
			    );

    if (!NT_SUCCESS(Status)) {
#if DBG
	DbgPrint("UMB:Unable to create UMB section, Status = %lx\n",
		 Status);
#endif
	return(FALSE);
    }

    // Now we go through the whole 256KB area to create a list for
    // each UMB(including ROM blocks)

    // This global variable points to the first node in the list
    UMBList = NULL;
#if defined(NEC_98)
    CurAddress = UmbBaseAddress;
#else  // !NEC_98
    CurAddress = UMB_BASE_ADDRESS;
#endif // !NEC_98

    while (Index > 0) {
	// round down address to the previous page boundary
	RomAddress = BiosBlock->Address & ~(HOST_PAGE_SIZE - 1);
	// round up the size to next page boundary
	RomSize = (BiosBlock->Size +
		   BiosBlock->Address - RomAddress +
		   HOST_PAGE_SIZE - 1
		   ) & ~(HOST_PAGE_SIZE - 1);
	// combine two blocks together if they overlap in page
	if (Index > 1 && (RomAddress + RomSize) > BiosBlock[1].Address) {
	    BiosBlock[1].Size += BiosBlock[1].Address - BiosBlock->Address;
	    BiosBlock[1].Address = BiosBlock->Address;
	    BiosBlock++;
	    Index--;
	    continue;
	}


	if (CurAddress == RomAddress) {
	    UMBNew = CreateNewUMBNode(CurAddress, RomSize, UMB_OWNER_ROM);
	    if (UMBNew == NULL)
		return FALSE;
	    CurAddress += RomSize;
	    BiosBlock++;
	    Index--;
	}
	else {
	    // make sure the block is in UMB area
	    if (RomAddress > CurAddress &&
		RomAddress <= UMB_BASE_ADDRESS + UMB_MAX_OFFSET){

		UMBNew = CreateNewUMBNode(CurAddress,
					  RomAddress - CurAddress,
					  UMB_OWNER_NONE
					  );
		if (UMBNew == NULL)
		    return FALSE;
		CurAddress = RomAddress;
	    }
	    // this block is not in UMB area, discard it
	    else {
		BiosBlock++;
		Index--;
		continue;
	    }
	}
	if (UMBList == NULL)
	    UMBList = UMBNew;
	else
	    UMB->Next = UMBNew;

	UMB = UMBNew;
    }
#if defined(NEC_98)
    if (CurAddress < 0x100000) {
        UMBNew = CreateNewUMBNode(CurAddress, 0x100000 - CurAddress, UMB_OWNER_NONE );
#else  // !NEC_98
    if (CurAddress < UMB_BASE_ADDRESS + UMB_MAX_OFFSET) {

	UMBNew = CreateNewUMBNode(CurAddress,
				  UMB_BASE_ADDRESS + UMB_MAX_OFFSET - CurAddress,
				  UMB_OWNER_NONE
				  );
#endif // !NEC_98
	if (UMBNew == NULL)
	    return FALSE;
	if (UMBList == NULL)
	    UMBList = UMBNew;
	else
	    UMB->Next = UMBNew;
    }
    return TRUE;
}

// create a new node for the new UMB block
// map the given address space to the UMB section if
// the umb is a RAM(owner = NONE)

PUMBNODE CreateNewUMBNode
(
DWORD	BaseAddress,
DWORD	Size,
WORD	Owner
)
{
    PUMBNODE	UMBNew;
    LARGE_INTEGER SectionOffset;
    NTSTATUS	Status;
#if defined(NEC_98)
    DWORD       UmbBaseAddress;

    if(HIRESO_MODE){
        UmbBaseAddress = 0xE5000;
    } else {
        UmbBaseAddress = 0xC0000;
    };
#endif // NEC_98

    if ((UMBNew = (PUMBNODE) malloc(sizeof(UMBNODE))) != NULL) {
	UMBNew->Base = BaseAddress;
	UMBNew->Size = Size;
	UMBNew->Mask = 0;
	UMBNew->Owner = Owner;
	UMBNew->Next = NULL;

	if (Owner == UMB_OWNER_NONE) {
#if defined(NEC_98)
            Status = NtFreeVirtualMemory(
                                NtCurrentProcess(),
                                &BaseAddress,
                                &Size,
                                MEM_RELEASE);

            if (!NT_SUCCESS(Status)) {
#if DBG
                DbgPrint("InitUMBList failed to FreeVirtualMemory, Status = %lx\n",Status);
#endif
                free(UMBNew);
                UMBNew = NULL;
                return UMBNew;
            }
#endif // NEC_98
	    SectionOffset.HighPart = 0;
#if defined(NEC_98)
            SectionOffset.LowPart = BaseAddress - UmbBaseAddress;
#else  // !NEC_98
	    SectionOffset.LowPart = BaseAddress - UMB_BASE_ADDRESS;
#endif // !NEC_98
	    Status = NtMapViewOfSection(UMBSectionHandle,
					NtCurrentProcess(),
					(PVOID *)&BaseAddress,
					0,		      //zero bits
					0,		      // commit size
					&SectionOffset,       // section offset
					&Size,		      // view size
					ViewUnmap,
					MEM_DOS_LIM,	      //
					UMB_PAGE_PROTECTION
					);

	    if (!NT_SUCCESS(Status)) {
#if DBG
		DbgPrint("InitUMBList failed to map, Status = %lx\n",
			 Status);
#endif
		free(UMBNew);
		UMBNew = NULL;
	    }
	}

    }
    return UMBNew;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_vdd.c ===
/********************************************************/
/*
 *      nt_vdd.c        -       NT support for VDD DLLs
 *
 *      Ade Brownlow
 *
 *      19/11/91
 *
 */

#include "windows.h"
#include "insignia.h"
#include "host_def.h"

#include <stdio.h>

#include "xt.h"
#include CpuH
#include "sas.h"
#include "error.h"
#include "config.h"

#include "ios.h"
#include "dma.h"
#include "nt_vdd.h"
#include "nt_vddp.h"
#include "nt_uis.h"


#ifdef ANSI

/* MS bop grabbing stuff */
GLOBAL half_word get_MS_bop_index (void *);
GLOBAL void free_MS_bop_index (half_word);
GLOBAL void ms_bop (void);
LOCAL void ms_not_a_bop (void);

/* IO slot grabbers */
GLOBAL half_word io_get_spare_slot (void);
GLOBAL void io_release_spare_slot (half_word);
#else
/* MS bop grabbing stuff */
GLOBAL half_word get_MS_bop_index ();
GLOBAL void free_MS_bop_index ();
GLOBAL void ms_bop ();
LOCAL void ms_not_a_bop ();

/* IO slot grabbers */
GLOBAL half_word io_get_spare_slot ();
GLOBAL void io_release_spare_slot ();
#endif

extern void illegal_bop(void);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::: Local data structures */

#define MAX_SLOTS (10)

LOCAL void (*MS_bop_tab[MAX_SLOTS])();          /* MS bop table */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Microsoft BOP vectoring code references MS_bop_tab above and calls function
 * as directed by AH */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL void ms_bop ()               /* called from MS_bop_5 ie bop 0x55 */
{
    half_word ah = getAH();                   /* get the value in AH */

    /*........................................Valid then call the MS function */

    if(ah >= MAX_SLOTS || MS_bop_tab[ah] == NULL)
        ms_not_a_bop();
    else
        (*MS_bop_tab[ah])();
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::: Dummy for unset AH values - stops us zipping into hyperspace :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

LOCAL void ms_not_a_bop()
{
#ifndef PROD
    printf ("AH=%x, This is not a valid value for an MS BOP\n", getAH());
    illegal_bop();
#ifdef YODA
    force_yoda ();
#endif
#endif
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Give an index to our table which can be used for the passed function :::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL half_word get_ms_bop_index (void (*func)())
{
    register half_word index;

    for(index = 0; index < MAX_SLOTS; index++)
    {
        if(MS_bop_tab[index] == NULL)
        {
            MS_bop_tab[index] = func;
            break;
        }
    }

    return (index == MAX_SLOTS ? (half_word) 0xff : index);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::: free the bop index passed :::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

GLOBAL void free_MS_bop_index IFN1(half_word, index)
{
    MS_bop_tab[index] = NULL;
}


/*
 * ==========================================================================
 * Imports
 * ==========================================================================
 */
IMPORT VOID host_ica_lock(), host_ica_unlock();

/********************************************************/
/* IO stuff */


    // VddAdapter Table (Adapter X hVdd table)
    // there is only one adapter per VDD
HANDLE VddAdapter[NUMBER_SPARE_ADAPTERS];

#define MAX_IRQ_LINE 15
// Bugbug need to initialize this cleanly
HANDLE IrqLines[MAX_IRQ_LINE+1] = {(HANDLE)1, (HANDLE)1, (HANDLE)1, (HANDLE)1,
                                   (HANDLE)1, (HANDLE)1, (HANDLE)1, (HANDLE)1,
                                   (HANDLE)1, (HANDLE)1, (HANDLE)1, (HANDLE)0,
                                   (HANDLE)0, (HANDLE)1, (HANDLE)1, (HANDLE)0};


/* GetVddAdapter
 *
 * Retrieves the current adapter number for the Vdd
 * If none is assigned, then one is assigned
 *
 * entry: HANDLE hVdd     - handle forthe vdd
 * exit : WORD   wAdaptor - Assigned Adaptor Num
 *                          (Zero for failure)
 * WinLastError Codes:
 *
 *        ERROR_ALREADY_EXISTS - Adaptor already exists for the Vdd
 *        ERROR_OUTOFMEMORY    - No adaptor slots available
 *
 */
WORD GetVddAdapter(HANDLE hVdd)
{
   WORD w;

     //
     // search VddAdapter table to see if adapter already assigned
     //
   for (w = 0; w < NUMBER_SPARE_ADAPTERS; w++)
      {
        if (VddAdapter[w] == hVdd) {
            SetLastError(ERROR_ALREADY_EXISTS);
            return 0;
            }
        }

     //
     // assume not assigned, so look for first available slot
     //
   for (w = 0; w < NUMBER_SPARE_ADAPTERS; w++)
      {
        if (VddAdapter[w] == 0) {
            VddAdapter[w] = hVdd;
            return (w + SPARE_ADAPTER1);
            }
        }

   // none found return error
   SetLastError(ERROR_OUTOFMEMORY);
   return 0;
}



/* FreeVddAdapter
 *
 * Frees the current adaptor for the specified VDD
 *
 * entry:  HANDLE hVdd
 * exit:   WORD   AdaptorNumber that was freed,
 *                Zero for not found
 *
 */
WORD FreeVddAdapter(HANDLE hVdd)
{
   WORD w;

     //
     // search VddAdapter table by hVdd for adaptor
     // and mark it as available
     //
   w = NUMBER_SPARE_ADAPTERS;
   while (w--)
      {
        if (VddAdapter[w] == hVdd) {
            VddAdapter[w] = 0;
            return w;
            }
        }

   return 0;
}

#ifndef NEC_98
#ifdef MONITOR
extern BOOLEAN MonitorVddConnectPrinter(WORD Adapter, HANDLE hVdd, BOOLEAN Connect);
#endif /* MONITOR */
#endif // !NEC98

/*** VDDInstallIOHook - This service is provided for VDDs to hook the
 *                      IO ports they are responsible for.
 *
 * INPUT:
 *      hVDD      ; VDD Handle
 *      cPortRange; Number of VDD_IO_PORTRANGE structures
 *      pPortRange; Pointer to array of VDD_IO_PORTRANGE
 *      IOhandler : VDD handler for the ports.
 *
 * OUTPUT
 *      SUCCESS : Returns TRUE
 *      FAILURE : Returns FALSE
 *                GetLastError has the extended error information.
 *
 * NOTES:
 *      1. The first one to hook a port will get control. Subsequent
 *         requests will be failed. There is no concept of chaining
 *         the hooks.
 *
 *      2. IOHandler must atleast provide a byte read and a byte write
 *         handler. Others can be NULL.
 *
 *      3. If word or string handlers are not provided, their effect
 *         will be emulated using byte handlers.
 *
 *      4. VDDs should not hook DMA ports. NTVDM manages it for all
 *         the clients and services are provided to perform DMA
 *         operations and to access and modify DMA data.
 *
 *      5. VDDs should not hook video ports as well. Such a hooking
 *         will succeed but there is no gurantee that the IO handler will
 *         get called.
 *
 *      6. Each Vdd is allowed to install only one set of IO hooks
 *         at a time.
 *
 *      7. Extended Error codes:
 *
 *         ERROR_ACCESS_DENIED   - One of the requested ports is already hooked
 *         ERROR_ALREADY_EXISTS  - Vdd already has active IO port handlers
 *         ERROR_OUTOFMEMORY     - Insufficient resources for additional VDD
 *                                 Port handler set.
 *         ERROR_INVALID_ADDRESS - One of the IO port handlers has an invalid
 *                                 address.
 */
BOOL VDDInstallIOHook (
     HANDLE            hVdd,
     WORD              cPortRange,
     PVDD_IO_PORTRANGE pPortRange,
     PVDD_IO_HANDLERS  pIOFn)
{
   WORD              w, i;
   WORD              wAdapter;
   PVDD_IO_PORTRANGE pPRange;
#ifdef MONITOR
   WORD              lptAdapter = 0;
#endif


      // check parameters
      // the inb and outb handlers must be valid
      // the rest must be either NULL or valid
      //
   if (IsBadCodePtr((FARPROC)pIOFn->inb_handler) ||
       IsBadCodePtr((FARPROC)pIOFn->outb_handler))
     {
       SetLastError(ERROR_INVALID_ADDRESS);
       return FALSE;
       }

   if ((pIOFn->inw_handler   && IsBadCodePtr((FARPROC)pIOFn->inw_handler))  ||
       (pIOFn->insb_handler  && IsBadCodePtr((FARPROC)pIOFn->insb_handler)) ||
       (pIOFn->insw_handler  && IsBadCodePtr((FARPROC)pIOFn->insw_handler)) ||
       (pIOFn->outw_handler  && IsBadCodePtr((FARPROC)pIOFn->outw_handler)) ||
       (pIOFn->outsb_handler && IsBadCodePtr((FARPROC)pIOFn->outsb_handler))||
       (pIOFn->outsw_handler && IsBadCodePtr((FARPROC)pIOFn->outsw_handler))  )
     {
       SetLastError(ERROR_INVALID_ADDRESS);
       return FALSE;
       }

     // Get an adapter
   wAdapter = GetVddAdapter(hVdd);
   if (!wAdapter) {
       return FALSE;
       }

     // register io handlers for this adapter
   io_define_in_routines((half_word)wAdapter,
                         pIOFn->inb_handler,
                         pIOFn->inw_handler,
                         pIOFn->insb_handler,
                         pIOFn->insw_handler);

   io_define_out_routines((half_word)wAdapter,
                          pIOFn->outb_handler,
                          pIOFn->outw_handler,
                          pIOFn->outsb_handler,
                          pIOFn->outsw_handler);

     // register ports for this adapter\vdd
   i = cPortRange;
   pPRange = pPortRange;
   while (i) {
          for (w = pPRange->First; w <= pPRange->Last; w++)
            {
#ifdef MONITOR
            // watch out for lpt ports
            // note that the vdd must hook every port assoicated with
            // the lpt. Just imanging that the vdd traps the control
            // port while leaves the rest for softpc-- we are going
            // to mess up badly and so does the vdd.
            // QUESTION: How can we enforece this????
              if (w >= LPT1_PORT_START && w < LPT1_PORT_END)
                lptAdapter |= 1;
#ifndef NEC_98
              else if (w >= LPT2_PORT_START && w < LPT2_PORT_END)
                lptAdapter |= 2;
              else if (w >= LPT3_PORT_START && w < LPT3_PORT_END)
                lptAdapter |= 4;
#endif // !NEC_98
#endif
              if (!io_connect_port(w, (half_word)wAdapter, IO_READ_WRITE))
                 {
                  // if one of the port connects failed
                  // undo the connects that succeeded and ret error
                  i = w;
                  while (pPortRange < pPRange)  {
                     for (w = pPortRange->First; w <= pPortRange->Last; w++)
                       {
                         io_disconnect_port(w, (half_word)wAdapter);
                         }
                     pPortRange++;
                     }

                   for (w = pPortRange->First; w < i; w++)
                     {
                       io_disconnect_port(w, (half_word)wAdapter);
                       }

                   FreeVddAdapter(hVdd);

                   SetLastError(ERROR_ACCESS_DENIED);
                   return FALSE;
                  }
              }
          pPRange++;
          i--;
          }

#ifndef NEC_98
#ifdef MONITOR
// i/o ports are hooked successfully, stop printer status port
// kernel emulation if the they are in the hooked range
      if (lptAdapter & 1)
        MonitorVddConnectPrinter(0, hVdd, TRUE);
      if (lptAdapter & 2)
        MonitorVddConnectPrinter(1, hVdd, TRUE);
      if (lptAdapter & 4)
        MonitorVddConnectPrinter(2, hVdd, TRUE);
#endif /* MONITOR */
#endif // !NEC_98
   return TRUE;
}



/*** VDDDeInstallIOHook - This service is provided for VDDs to unhook the
 *                        IO ports they have hooked.
 *
 * INPUT:
 *      hVDD    : VDD Handle
 *
 * OUTPUT
 *      None
 *
 * NOTES
 *
 *      1. On Deinstalling a hook, the defult hook is placed back on
 *         those ports. Default hook  returns 0xff on reading
 *         and ignores the write operations.
 *
 */
VOID VDDDeInstallIOHook (
     HANDLE            hVdd,
     WORD              cPortRange,
     PVDD_IO_PORTRANGE pPortRange)
{
    WORD w;
    WORD wAdapter;
#ifdef MONITOR
   WORD              lptAdapter = 0;
#endif


    wAdapter = FreeVddAdapter(hVdd);
    if (!wAdapter) {
        return;
        }


     // deregister ports for this adapter\vdd
   while (cPortRange--) {
          for (w = pPortRange->First; w <= pPortRange->Last; w++)
            {
#ifdef MONITOR
            // watch out for lpt status ports
            // note that the vdd must unhook every port assoicated with
            // the lpt. Just imanging that the vdd traps the control
            // port while leaves the rest for softpc-- we are going
            // to mess up badly and so does the vdd.
            // QUESTION: How can we enforece this????
              if (w >= LPT1_PORT_START && w < LPT1_PORT_END)
                lptAdapter |= 1;
#ifndef NEC_98
              else if (w >= LPT2_PORT_START && w < LPT2_PORT_END)
                lptAdapter |= 2;
              else if (w >= LPT3_PORT_START && w < LPT3_PORT_END)
                lptAdapter |= 4;
#endif // !NEC_98
#endif
              io_disconnect_port(w, (half_word)wAdapter);
              }
          pPortRange++;
          }

#ifndef NEC_98
#ifdef MONITOR
// i/o ports are Unhooked successfully, resume printer status port
// kernel emulation if the they are in the hooked range
      if (lptAdapter & 1)
        MonitorVddConnectPrinter(0, hVdd, FALSE);
      if (lptAdapter & 2)
        MonitorVddConnectPrinter(1, hVdd, FALSE);
      if (lptAdapter & 4)
        MonitorVddConnectPrinter(2, hVdd, FALSE);
#endif  /* MONITOR */
#endif // !NEC_98
}


/*** VDDReserveIrqLine - This service resolves contention between VDDs
 * over Irq lines.
 *
 * Parameters:
 *  hVDD    : VDD Handle
 *  IrqLine ; the specific IrqLine number to reserve, or -1 to search for
 *            a free line.
 *
 * Return Value
 *  VDDReserveIrqLine returns the IrqLine number (0-15) if successful.
 *  Otherwise, this function returns 0xFFFF and logs an error. The
 *  extended error code will be ERROR_INVALID_PARAMETER.
 *
 * Comments:
 *  The value of an IrqLine number may range from 0-15 and correspond to
 *  the irq line numbers of the virtual PICs (8259) emulated by the ntvdm
 *  subsystem. Many of the line numbers are already used by the system
 *  (e.g. for Timer, Keyboard, etc.), but there are a few free lines. VDDs
 *  can take advantage of this and use the VDDSimulateInterrupt service to
 *  reflect virtual interrupts specific to that VDD. This service provides
 *  a way to manage the contention for the free irq lines.
 *
 *  This service does not prevent VDDs that do not own a given IrqLine from
 *  calling VDDSimulateInterrupt specifying that IrqLine. So it is important
 *  to rely on this service, rather than expecting VDDSimulateInterrupt to
 *  fail, to determine that a given IrqLine is available for use.
 *
 *  This service may be called at any time. Typically, VDDs will use this
 *  service at init time, and pass the number of the reserved IrqLine to
 *  the vdm application/driver code. This code can then hook the corresponding
 *  interrupt vector (8-15, 70-77) using the DOS Set Vector function
 *  (Int 21h, func 25h) in order to handle the interrupts generated with
 *  the VDDSimulateInterrupt service.
 */
WORD VDDReserveIrqLine (
     HANDLE            hVdd,
     WORD              IrqLine)
{

    WORD ReturnValue = 0xFFFF;

    if ((!hVdd) ||
        ((IrqLine > MAX_IRQ_LINE) && (IrqLine != 0xFFFF)) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(ReturnValue);
    }

    host_ica_lock();                // acquire critical section

    if (IrqLine == 0xFFFF) {

        for (IrqLine = MAX_IRQ_LINE; IrqLine < 0xFFFF; IrqLine--) {
            if (IrqLines[IrqLine] == 0) {
                IrqLines[IrqLine] = hVdd;
                ReturnValue = IrqLine;
                break;
            }
        }

    } else if (IrqLines[IrqLine] == 0) {

        IrqLines[IrqLine] = hVdd;
        ReturnValue = IrqLine;
    }

    host_ica_unlock();

    if (ReturnValue == 0xFFFF)
        SetLastError(ERROR_INVALID_PARAMETER);

    return(ReturnValue);
}

/*** VDDReleaseIrqLine - This service releases a lock on an Irq Line
 * obtained with VDDReserveIrqLine
 *
 * Parameters:
 *  hVDD    : VDD Handle
 *  IrqLine : The specific IrqLine number (0-15) to release.
 *
 * Return Value:
 *  VDDReleaseIrqLine returns TRUE if successful.
 *  Otherwise, this function returns FALSE and logs an error. The
 *  extended error code will be ERROR_INVALID_PARAMETER.
 *
 * Comments:
 * Upon successful execution of this function, the specified IrqLine will
 * be available to other VDDs.
 *
 * This service may be called at any time.
 */
BOOL VDDReleaseIrqLine (
     HANDLE            hVdd,
     WORD              IrqLine)
{

    BOOL Status = FALSE;

    if ((!hVdd) ||
        (IrqLine > MAX_IRQ_LINE) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    }

    host_ica_lock();                // acquire critical section

    if (IrqLines[IrqLine] == hVdd) {
        IrqLines[IrqLine] = 0;
        Status = TRUE;
    }

    host_ica_unlock();

    if (!Status)
        SetLastError(ERROR_INVALID_PARAMETER);

    return(Status);
}


BOOL
HostUndefinedIo(
    WORD IoAddress
    )
/*
 * HostUndefinedIo
 *
 * Called when the client code has issued an I/O instruction to
 * an address that has the default I/O handler. Instead of just
 * ignoring it, this routine tries to dynamically load a predefined
 * VDD to handle it.
 *
 * entry:  WORD IoAddress - address of target of IN or OUT
 *
 * exit:   TRUE - a VDD was loaded to handle the I/O, the caller
 *                should retry the operation
 *         FALSE - either the address is unknown, or an attempt
 *                 to load the corresponding VDD failed earlier.
 *
 */
{
    HANDLE hVDD;
    static BOOL bTriedVSndblst = FALSE;
    BOOL bReturn = FALSE;

#if 0
    // SoundBlaster VDD is out of the project for now
    // hence this section of the code is disabled pending
    // further investigation


        if (((IoAddress > 0x210) && (IoAddress < 0x280)) ||
                   (IoAddress == 0x388) || (IoAddress == 0x389))  {
           //
           // Try the SoundBlaster VDD
           //
           if (!bTriedVSndblst) {
               bTriedVSndblst = TRUE;

               if ((hVDD = SafeLoadLibrary("VSNDBLST.DLL")) == NULL){
                   RcErrorDialogBox(ED_LOADVDD, "VSNDBLST.DLL", NULL);
               } else {
                   bReturn = TRUE;
               }
            }

        }

#endif

    return bReturn;
}


/********************************************************/
/* DMA stuff */



/*** VDDRequestDMA - This service is provided for VDDs to request a DMA
 *                   transfer.
 *
 * INPUT:
 *      hVDD     VDD Handle
 *      iChannel DMA Channel on which the operation to take place
 *      Buffer   Buffer where to or from transfer to take place
 *      length   Transfer Count (in bytes)
 *
 *               If Zero, returns the Current VDMA transfer count
 *               in bytes.
 *
 * OUTPUT
 *      DWORD    returns bytes transferred
 *               if Zero check GetLastError to determine if the
 *               call failed or succeeded
 *               GetLastError has the extended error information.
 *
 * NOTES
 *      1. This service is intended for those VDDs which do not want to
 *         carry on the DMA operation on their own. Carrying on a DMA
 *         operation involves understanding all the DMA registers and
 *         figuring out what has to be copied, from where and how much.
 *
 *      2. This service will be slower than using VDDQueryDMA/VDDSetDMA and
 *         doing the transfer on your own.
 *
 *      3. Extended Error codes:
 *
 *         ERROR_ALREADY_EXISTS  - Vdd already has active IO port handlers
 *         ERROR_OUTOFMEMORY     - Insufficient resources for additional VDD
 *                                 Port handler set.
 *         ERROR_INVALID_ADDRESS - One of the IO port handlers has an invalid
 *                                 address.
 *
 */
DWORD VDDRequestDMA (
    HANDLE hVDD,
    WORD   iChannel,
    PVOID  Buffer,
    DWORD  length )
{
    DMA_ADAPT *pDmaAdp;
    DMA_CNTRL *pDcp;
    WORD       Chan;
    WORD       Size;
    WORD       tCount;
    BOOL       bMore;


    if (iChannel > DMA_CONTROLLER_CHANNELS*DMA_ADAPTOR_CONTROLLERS) {
        SetLastError(ERROR_INVALID_ADDRESS);
        return FALSE;
        }

    pDmaAdp  = dmaGetAdaptor();
    pDcp     = &pDmaAdp->controller[dma_physical_controller(iChannel)];
    Chan     = dma_physical_channel(iChannel);
    Size     = dma_unit_size(iChannel);

    // if the controller or the channel is disabled, return 0
    if (pDcp->command.bits.controller_disable == 1 ||
       (pDcp->mask & (1 << Chan)) == 0)
        return (0);

    tCount = ((WORD)pDcp->current_count[Chan][1] << 8)
             | (WORD)pDcp->current_count[Chan][0];

    SetLastError(0);  // assume success

         // return requested transfer count (in bytes)
    if (!length)  {
         return (DWORD)Size*((DWORD)tCount + 1);
         }

    length = length/Size - 1;

    if (length > 0xFFFF) {
        length = 0xFFFF;
        }

    try {
         bMore = (BOOL) dma_request((half_word)iChannel,
                                                 Buffer,
                                    (word) length);
         }
    except(EXCEPTION_EXECUTE_HANDLER) {
         SetLastError(ERROR_INVALID_ADDRESS);
         return 0;
         }

    if (!bMore) {  // terminal count has been reached
         return ((DWORD)tCount+1) * (DWORD)Size;
         }

    tCount -= ((WORD)pDcp->current_count[Chan][1] << 8)
               | (WORD)pDcp->current_count[Chan][0];

    return ((DWORD)tCount + 1) * (DWORD)Size;
}





/*** VDDQueryDMA -   This service is provided for VDDs to collect all the DMA
 *                   data.
 *
 * INPUT:
 *      hVDD     VDD Handle
 *      iChannel DMA Channel for which to query
 *      Buffer   Buffer where information will be returned
 *
 * OUTPUT
 *      SUCCESS : Returns TRUE
 *      FAILURE : Returns FALSE
 *                GetLastError has the extended error information.
 *
 *
 * NOTES
 *      1. This service is intended for those VDD which are doing
 *         performance critical work. These VDD can do their own DMA
 *         transfers and avoid one extra buffer copying which is a
 *         overhead in using VDDRequestDMA.
 *
 *      2. VDDs should use VDDSetDMA to properly update the state of
 *         DMA after carrying on the operation.
 *
 *      3. Extended Error codes:
 *
 *         ERROR_INVALID_ADDRESS - Invalid channel
 *
 */
BOOL VDDQueryDMA (
     HANDLE        hVDD,
     WORD          iChannel,
     PVDD_DMA_INFO pDmaInfo)
{
     DMA_ADAPT *pDmaAdp;
     DMA_CNTRL *pDcp;
     WORD       Chan;


     if (iChannel > DMA_CONTROLLER_CHANNELS*DMA_ADAPTOR_CONTROLLERS) {
         SetLastError(ERROR_INVALID_ADDRESS);
         return FALSE;
         }

     pDmaAdp  = dmaGetAdaptor();
     pDcp     = &pDmaAdp->controller[dma_physical_controller(iChannel)];
     Chan     = dma_physical_channel(iChannel);


     pDmaInfo->addr  = ((WORD)pDcp->current_address[Chan][1] << 8)
                       | (WORD)pDcp->current_address[Chan][0];

     pDmaInfo->count = ((WORD)pDcp->current_count[Chan][1] << 8)
                       | (WORD)pDcp->current_count[Chan][0];

     pDmaInfo->page   = (WORD) pDmaAdp->pages.page[iChannel];
     pDmaInfo->status = (BYTE) pDcp->status.all;
     pDmaInfo->mode   = (BYTE) pDcp->mode[Chan].all;
     pDmaInfo->mask   = (BYTE) pDcp->mask;


     return TRUE;
}




/*** VDDSetDMA - This service is provided for VDDs to set the DMA data.
 *
 * INPUT:
 *      hVDD     VDD Handle
 *      iChannel DMA Channel for which to query
 *      fDMA     Bit Mask indicating which DMA data fields are to be set
 *                  VDD_DMA_ADDR
 *                  VDD_DMA_COUNT
 *                  VDD_DMA_PAGE
 *                  VDD_DMA_STATUS
 *      Buffer   Buffer with DMA data
 *
 * OUTPUT
 *      SUCCESS : Returns TRUE
 *      FAILURE : Returns FALSE
 *                GetLastError has the extended error information.
 *
 * NOTES
 *
 *      1. Extended Error codes:
 *
 *         ERROR_INVALID_ADDRESS - Invalid channel
 *
 */
BOOL VDDSetDMA (
    HANDLE hVDD,
    WORD iChannel,
    WORD fDMA,
    PVDD_DMA_INFO pDmaInfo)
{
    DMA_ADAPT *pDmaAdp;
    DMA_CNTRL *pDcp;
    WORD       Chan;


    if (iChannel > DMA_CONTROLLER_CHANNELS*DMA_ADAPTOR_CONTROLLERS) {
        SetLastError(ERROR_INVALID_ADDRESS);
        return FALSE;
        }


    pDmaAdp  = dmaGetAdaptor();
    pDcp     = &pDmaAdp->controller[dma_physical_controller(iChannel)];
    Chan     = dma_physical_channel(iChannel);

    if (fDMA & VDD_DMA_ADDR) {
        pDcp->current_address[Chan][1] = (half_word)HIBYTE(pDmaInfo->addr);
        pDcp->current_address[Chan][0] = (half_word)LOBYTE(pDmaInfo->addr);
        }

    if (fDMA & VDD_DMA_COUNT) {
        pDcp->current_count[Chan][1] = (half_word)HIBYTE(pDmaInfo->count);
        pDcp->current_count[Chan][0] = (half_word)LOBYTE(pDmaInfo->count);
        }

    if (fDMA & VDD_DMA_PAGE) {
        pDmaAdp->pages.page[iChannel] = (half_word)pDmaInfo->page;
        }

    if (fDMA & VDD_DMA_STATUS) {
        pDcp->status.all = (BYTE) pDmaInfo->status;
        }

    //
    // If DMA count is 0xffff and autoinit is enabled, we need to
    // reload the count and address.
    //

    if ((pDcp->current_count[Chan][0] == (half_word) 0xff) &&
        (pDcp->current_count[Chan][1] == (half_word) 0xff)) {

        if (pDcp->mode[Chan].bits.auto_init != 0) {
            pDcp->current_count[Chan][0] = pDcp->base_count[Chan][0];
            pDcp->current_count[Chan][1] = pDcp->base_count[Chan][1];

            pDcp->current_address[Chan][0] = pDcp->base_address[Chan][0];
            pDcp->current_address[Chan][1] = pDcp->base_address[Chan][1];
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_vdm.c ===
/********************************************************/
/*
 *      nt_vdm.c        -       VdmXXX external entry points
 *
 *      Neil Sandlin
 *
 *      19/11/91
 *
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>

#include "insignia.h"
#include "host_def.h"
#include CpuH
#include "sim32.h"
#include "time.h"
#include "timeval.h"

#include "nt_vdd.h"

unsigned short LatchAndGetTimer0Count(void);
unsigned short GetLastTimer0Count(void);
unsigned long GetTimer0InitialCount(void);
void SetNextTimer0Count(unsigned short);
double_word sim32_effective_addr_ex (word, double_word, BOOL);


VDM_ERROR_TYPE LastError = VDM_NO_ERROR;


BOOL
VdmParametersInfo(
    VDM_INFO_TYPE infotype,
    PVOID pBuffer,
    ULONG cbBufferSize
    )
{
    BOOL RetVal = FALSE;

    switch (infotype) {
    case VDM_GET_TICK_COUNT:

        if (cbBufferSize != sizeof(struct host_timeval)) {
            LastError = VDM_ERROR_INVALID_BUFFER_SIZE;
            break;
        }

        host_GetSysTime((struct host_timeval *)pBuffer);
        RetVal = TRUE;
        break;

    case VDM_GET_TIMER0_INITIAL_COUNT:
        if (cbBufferSize != sizeof(unsigned long)) {
            LastError = VDM_ERROR_INVALID_BUFFER_SIZE;
            break;
        }
        *(unsigned long *)pBuffer = GetTimer0InitialCount();
        RetVal = TRUE;
        break;

    case VDM_GET_LAST_UPDATED_TIMER0_COUNT:
        if (cbBufferSize != sizeof(unsigned short)) {
            LastError = VDM_ERROR_INVALID_BUFFER_SIZE;
            break;
        }
        *(unsigned short *)pBuffer = GetLastTimer0Count();
        RetVal = TRUE;
        break;

    case VDM_LATCH_TIMER0_COUNT:
        if (cbBufferSize != sizeof(unsigned short)) {
            LastError = VDM_ERROR_INVALID_BUFFER_SIZE;
            break;
        }
        *(unsigned short *)pBuffer = LatchAndGetTimer0Count();
        RetVal = TRUE;
        break;

//    case VDM_SET_NEXT_TIMER0_COUNT:
//        This code use to be there to handle VJOY.DLL. The
//        code has been ripe up on JonLe's authority.
//        break;

    default:
        LastError = VDM_ERROR_INVALID_FUNCTION;
    }

    return RetVal;
}


VDM_INFO_TYPE
VdmGetParametersInfoError(
    VOID
    )
{
    return LastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_vflop.c ===
#include "host_dfs.h"


#ifdef VFLOPPY
/*****************************************************************************
*	   nt_vflop.c - virtual floppy disk provision for Microsoft(tm).     *
*                                                                            *
*	   File derived from gfi_vflop.c by Henry Nash.                      *
*                                                                            *
*	   This version is written/ported for New Technology OS/2            *
*	   by Andrew Watson                                                  *
*                                                                            *
*          Modified so that only a single drive (B:) is available to prevent *
*          an accidental floppy boot.                                        *
*                                                                            *
*	   Date pending due to ignorance                                     *
*                                                                            *
*	   (c) Copyright Insignia Solutions 1991                             *
*                                                                            *
*****************************************************************************/

#include <stdio.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>

#define L_SET 0

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "trace.h"
#include "fla.h"
#include "dma.h"
#include "gfi.h"
#include "config.h"

extern boolean gain_ownership();
extern void release_ownership();

/*
 * First - description of the PC disk/diskette in standard PC-DOS format
 */

#define PC_BYTES_PER_SECTOR			512
#define PC_TRACKS_PER_DISKETTE	 		40
#define PC_HEADS_PER_DISKETTE	  		2
#define PC_SECTORS_PER_DISKETTE_TRACK   	9

/*
 * The Maximum number of sectors per diskette that the FDC will support
 */

#define PC_MAX_SECTORS_PER_DISKETTE_TRACK	12 
#define PC_MAX_BYTES_PER_SECTOR			4096



/*
 * ... and where the diskettes resides under UNIX
 */

#define BS_DISKETTE_NAME		"c:\\softpc\\pctool.A"

#define BS_DISKETTE_DOS_SID_NAME	"c:\\softpc\\dos.SID"
#define BS_DISKETTE_SID_NAME		"c:\\softpc\\pctool.SID"


/*
 * The disk buffer used for moving between memory and the UNIX file.
 * Currently this can opnly be one sector - but this could be easily
 * increased if performance dictates.
 */ 

#define BS_DISK_BUFFER_SIZE	1		/* in sectors */

half_word bs_disk_buffer[PC_MAX_BYTES_PER_SECTOR * BS_DISK_BUFFER_SIZE];

/*
 * Each virtual disk has a flag to say if the UNIX file is open
 */

static int bs_diskette_open = FALSE;

/*
 * Each virtual disk has a file descriptor
 */

static int bs_diskette_fd;

/*
 * A virtual disk is read only if the Unix protection flag dictate it.
 */

static boolean diskette_read_only;


/*
 * The structure of an entry in the Sector Mapping Table
 */

typedef struct
   {
   half_word no_of_sectors;
   half_word sector_ID[PC_MAX_SECTORS_PER_DISKETTE_TRACK];
   word bytes_per_sector;
   double_word start_position;
   }
SID_ENTRY;
		
/*
 * The table itself - an entry for each track and head combination.
 * It is filled in by the fl_read_SID() function at run time.
 */

static SID_ENTRY fl_track_index[PC_TRACKS_PER_DISKETTE][PC_HEADS_PER_DISKETTE];

/*
 * Table to convert the N format number into bytes per sector. The first
 * location is not used as N starts at 1.
 */

static word fl_sector_sizes[] = {0,256,512,1024,2048,4096} ;
static void  fl_read_SID();
static short fl_sector_check();

/*
 * Global variable for name of diskette file
 */
char   diskette_name[256];

/*
 * A macro to calculate the sector offset from the start of the UNIX virtual
 * diskette file for a given track and sector.  This uses the track mapping
 * table to find the start of the track.
 */

#define diskette_position(track, head, sector, bytes_per_sector)  \
			 (fl_track_index[track][head].start_position + \
			  ((sector - 1) * bytes_per_sector)) 

/*
 * A macro returning TRUE if the drive is empty
 */

#define drive_empty()	(strcmp(diskette_name, "empty drive")  == 0)

static char *prog_name ="gfi_vfloppy:";

static int gfi_vdiskette_command();
static int gfi_vdiskette_drive_on();
static int gfi_vdiskette_drive_off();
static int gfi_vdiskette_reset();


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */


void gfi_vdiskette_init(drive)
int drive;
{
/*
 * Allow only the use of drive B:
 *
 *      1  - Drive A
 *      1  - Drive B
 */

if(drive!=1)
   drive=1;

gfi_function_table[drive].command_fn   = gfi_vdiskette_command;
gfi_function_table[drive].drive_on_fn  = gfi_vdiskette_drive_on;
gfi_function_table[drive].drive_off_fn = gfi_vdiskette_drive_off;
gfi_function_table[drive].reset_fn     = gfi_vdiskette_reset;
}


void gfi_vdiskette_term(drive)
int drive;    /* Currently parameter is ignored */
{
if (bs_diskette_open)
   {
   release_ownership(bs_diskette_fd);
   close(bs_diskette_fd);
   bs_diskette_open = FALSE;
   }
}

void fl_int_reset()
{
/*
 * Reset function for use by the 'Change Diskette function'
 * and the standard floppy reset function.  Also called by
 * 'X_input.c' by 'new_disk()' when a new diskette is
 * selected.
 * No PC registers are modified in this function.
 *
 * Reset the virtual diskette by re-opening the file.
 *
 * First, if the file is open - close it.
 */
char dpath[MAXPATHLEN];

if (bs_diskette_open)
   {
   release_ownership(bs_diskette_fd);
   close(bs_diskette_fd);
   bs_diskette_open = FALSE;
   }
strcpy(dpath, configuration.cf_fl_dir);
strcat(dpath, "\\");
strncat(dpath, diskette_name,sizeof(dpath)-strlen(dpath));
dpath[sizeof(dpath)-1] = '\0';

bs_diskette_open   = TRUE;     /* Assume success */
diskette_read_only = FALSE;    /* Assume read/write */

bs_diskette_fd = open(dpath,O_RDWR,0);

if (bs_diskette_fd < 0)
  {
  bs_diskette_fd = open(dpath, O_RDONLY,0);
  if (bs_diskette_fd >= 0)
     diskette_read_only = TRUE;
  else
     {
     bs_diskette_open = FALSE;
     fprintf(trace_file, "%s open error: %s\n", prog_name, dpath);
     return;
     }
  }

/*
 * Now open the Sector ID file
 */

fl_read_SID(diskette_name);
}
/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

static int gfi_vdiskette_command(command_block, result_block)
FDC_CMD_BLOCK *command_block;
FDC_RESULT_BLOCK *result_block;
{
    half_word temp;
    int source_start;
    sys_addr destination_start;
    sys_addr dma_address;
    sys_addr pos;
    int transfer_count;
    int status;
    int sector_index;
    int bytes_per_sector;
    int sector_count = 0;
    word dma_size;
    half_word C, H, R, N;
    int track_info;
    int i;
    int ret_stat = SUCCESS;
    boolean failed = FALSE;

    switch(command_block->type.cmd) {
    case FDC_READ_DATA:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file,"%s Read Data Command \n", prog_name);
            dma_enquire(DMA_DISKETTE_CHANNEL, &dma_address, &dma_size);
            sector_index = fl_sector_check(command_block->c0.cyl,
                                           command_block->c0.hd,
                                           command_block->c0.sector);
            if (sector_index == -1) {
                /*
                 * Sector not found
                 */
                result_block->c0.ST0 = 0x40;
                result_block->c0.ST1 = 0x00;
                result_block->c1.ST1_no_data = 1;
                result_block->c0.ST2 = 0x00;
            }
            else {
                bytes_per_sector  = fl_sector_sizes[command_block->c0.N];
                source_start      = diskette_position(command_block->c0.cyl,
                                                      command_block->c0.hd,
                                                      sector_index,
                                                      bytes_per_sector);
                transfer_count    = (dma_size + 1) / bytes_per_sector;
    
                /*
                 * First SEEK to the start position
                 */
    
                if (lseek(bs_diskette_fd, source_start, L_SET) < 0)
                    fprintf(trace_file, "%s Seek failed\n", prog_name);
                else {
		    gain_ownership(bs_diskette_fd);
                    while(!failed && sector_count < transfer_count) {
                       /*
                        * Read sectors one by one into memory
                        * via the disk buffer
                        */
                        status = read(bs_diskette_fd,
                                      bs_disk_buffer, bytes_per_sector);
                        if (status != bytes_per_sector)
                            fprintf(trace_file, "%s Read failed\n", prog_name);
                        else
                            dma_request(DMA_DISKETTE_CHANNEL,
                                        bs_disk_buffer, bytes_per_sector);
                        sector_count++;
                    }
                }
                result_block->c0.ST0 = 0x04;
                result_block->c0.ST1 = 0x00;
                result_block->c0.ST2 = 0x00;
            }
        result_block->c0.cyl    = command_block->c0.cyl;
        result_block->c0.head   = command_block->c0.hd;
        result_block->c0.sector = ((command_block->c0.sector - 1 + transfer_count) % PC_SECTORS_PER_DISKETTE_TRACK) + 1;
        result_block->c0.N      = command_block->c0.N;
        break;

    case FDC_WRITE_DATA:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file,"%s Write Data Command \n", prog_name);	

            dma_enquire(DMA_DISKETTE_CHANNEL, &dma_address, &dma_size);
            sector_index = fl_sector_check(command_block->c0.cyl,
                                           command_block->c0.hd,
                                           command_block->c0.sector);
            bytes_per_sector  = fl_sector_sizes[command_block->c0.N];
            destination_start = diskette_position(command_block->c0.cyl,
                                                  command_block->c0.hd,
                                                  sector_index,
                                                  bytes_per_sector);
            transfer_count    = (dma_size + 1) / bytes_per_sector;

            /*
             * First SEEK to the start position
             */

            if (lseek(bs_diskette_fd, destination_start, L_SET) < 0)
                fprintf(trace_file, "%s Seek failed\n", prog_name);
            else {
		gain_ownership(bs_diskette_fd);
                while(!failed && sector_count < transfer_count) {
                    /*
                     * Write sectors one by one from memory via the disk buffer
                     */
                    dma_request(DMA_DISKETTE_CHANNEL,
                                bs_disk_buffer, bytes_per_sector);
                    status = write(bs_diskette_fd,
                                   bs_disk_buffer, bytes_per_sector);
                    if (status != bytes_per_sector) {
                        failed = TRUE;
                    }
                    sector_count++;
                }
	    }
        result_block->c0.ST0 = 0x00;    /* Clear down result bytes */
        result_block->c0.ST1 = 0x00;

        if (failed) {
            result_block->c1.ST0_int_code        = 1;
            result_block->c1.ST1_write_protected = 1;
        }
        else {
            result_block->c1.ST0_head_address = 1;
            result_block->c0.ST1              = 0x00;
        }
        result_block->c0.ST2 = 0x00;
        result_block->c0.cyl    = command_block->c0.cyl;
        result_block->c0.head   = command_block->c0.hd;
        result_block->c0.sector = ((command_block->c0.sector - 1 + transfer_count) % PC_SECTORS_PER_DISKETTE_TRACK) + 1;
        result_block->c0.N      = command_block->c0.N;
        break;

    case FDC_READ_TRACK:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file,"%s Read Track Command \n", prog_name);

        break;

    case FDC_SPECIFY:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file, "%s Specify command\n", prog_name);
        break;
            
    case FDC_RECALIBRATE:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file, "%s Recalibrate command\n", prog_name);

        result_block->c3.ST0 = 0;
        result_block->c1.ST0_int_code = 0;
        result_block->c1.ST0_seek_end = 0;
        result_block->c1.ST0_unit = command_block->c5.drive;
        result_block->c3.PCN = 0;
        break;
            
    case FDC_SENSE_DRIVE_STATUS:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file, "%s Sense Drive Status command\n", prog_name);

        result_block->c2.ST3_fault = 0;
        result_block->c2.ST3_write_protected = diskette_read_only;
        result_block->c2.ST3_ready = 1;
        result_block->c2.ST3_track_0 = 0;
        result_block->c2.ST3_two_sided = 1;
        result_block->c2.ST3_head_address = 0;
        result_block->c2.ST3_unit = command_block->c7.drive;
        break;
            
    case FDC_SEEK:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file, "%s Seek command\n", prog_name);
        result_block->c3.ST0 = 0;

        if (drive_empty()) {
            result_block->c1.ST0_int_code = 1;
            result_block->c1.ST0_seek_end = 0;
            result_block->c1.ST0_unit = command_block->c8.drive;
            ret_stat = FAILURE;
        }
        else {
            result_block->c1.ST0_int_code = 0;
            result_block->c1.ST0_seek_end = 1;
            result_block->c1.ST0_unit = command_block->c8.drive;
            result_block->c3.PCN = command_block->c8.new_cyl;
        }
        break;
            
    case FDC_FORMAT_TRACK:
        if (diskette_read_only) {
            result_block->c1.ST0_int_code        = 1;
            result_block->c1.ST1_write_protected = 1;
        }
        else {
            dma_enquire(DMA_DISKETTE_CHANNEL, &dma_address, &dma_size);
            for ( i=0; i<command_block->c3.SC; i++) {
                sas_load(dma_address++, &C);
                sas_load(dma_address++, &H);
                sas_load(dma_address++, &R);
                sas_load(dma_address++, &N);
                fprintf(trace_file,
                        "%s Format track: trk %x hd %x sector %x N_format %x\n",
                        prog_name, C, H, R, N);
            }
        }
        break;

    default:
        if (io_verbose & GFI_VERBOSE)
            fprintf(trace_file, "%s Un-implemented command, type %x\n",
                    prog_name, command_block->type.cmd);
    }

    return(ret_stat);
}


static int gfi_vdiskette_drive_on(drive)
int drive;
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        fprintf(trace_file, "%s Drive on command - drive %x\n", prog_name, drive);
#endif

    return(SUCCESS);
}

static int gfi_vdiskette_drive_off(drive)
int drive;
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        fprintf(trace_file, "%s Drive off command - drive %x\n", prog_name, drive);
#endif

    return(SUCCESS);
}


static int gfi_vdiskette_reset(result_block)
FDC_RESULT_BLOCK *result_block;
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        fprintf(trace_file, "%s Reset command\n", prog_name);
#endif

    /*
     * First reset the virtual diskette by closing and opening the file
     */

    fl_int_reset();

    /*
     * Fake up the Sense Interrupt Status result phase.  We don't know the
     * Present Cylinder No, so leave as zero.
     */

    result_block->c3.ST0 = 0;
    result_block->c3.PCN = 0;

    return(SUCCESS);
}


static short fl_sector_check(track, head, sector)
half_word track;
half_word head;
half_word sector;
{
    /*
     * Check the sector ID's in the mapping table for this track and head.
     * Return -1 if the sector is not found, else the sector index with
     * respect to the start of the track.
     */  

    int i = 0;
    int found = FALSE;

    while (i < fl_track_index[track][head].no_of_sectors && !found)
    {    
        if (fl_track_index[track][head].sector_ID[i] == sector)
            found = TRUE;
        else
            i++;
    }    
 
    if (found)
        return(i + 1);          /* sectors start at 1 */
    else 
        return(-1);
}
 

static void fl_read_SID(sidname)
char *sidname;
{
    /*
     * Attempt to read the sector ID file.  If found load the
     * information into the track mapping table, else load in
     * the standard DOS format.
     */

    FILE *fptr = NULL;
    double_word cur_position = 0;
    int track, head, no_of_sectors, N_format, sector_ID;
    char buf[80];
    char sector_nos[80];
    char rest[80];
    int i;
    char sidpath[MAXPATHLEN];


    if (fptr == NULL)
    {
        fptr = fopen(BS_DISKETTE_DOS_SID_NAME, "r");
	if (fptr == NULL)
	{
	    printf("Can't open standard DOS sector ID file - %s\n", BS_DISKETTE_DOS_SID_NAME);
	    return;
        }
    }

    while(fgets(buf,80,fptr) != NULL)
    {
        if (buf[0] != '#')
        {
	    sscanf(buf, "%d %d %d %d %[^\n]", &track, &head, &N_format,
				              &no_of_sectors, sector_nos);
	    fl_track_index[track][head].no_of_sectors = no_of_sectors;
	    fl_track_index[track][head].bytes_per_sector = fl_sector_sizes[N_format];
	    fl_track_index[track][head].start_position = cur_position;
    
	    for( i = 0; i < no_of_sectors; i++)
	    {
	        sscanf(sector_nos, "%d %[^\n]", &sector_ID, rest);
	        fl_track_index[track][head].sector_ID[i] = sector_ID;
	        strcpy(sector_nos, rest);
	    }
		
	    cur_position += (fl_track_index[track][head].bytes_per_sector * no_of_sectors);
        }
    }

    fclose(fptr);
}
#endif /* VFLOPPY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_vsync.c ===
#if defined(NEC_98)         
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "host_def.h"
#include "insignia.h"
#include "xt.h"
#include <conapi.h>
#include "sim32.h"
#include "nt_graph.h"
#include "ica.h"
#include "error.h"
#include "host_rrr.h"

#define VSYNC_THREAD_SIZE       ((DWORD) 10 * 1024)

BOOL VsyncThreadFlag;
HANDLE VsyncThreadHadle;
HANDLE RequestVsyncEvent;
#if 0
unsigned short real_vsync_interval = 0x8;
unsigned short protect_vsync_interval = 0x64;
unsigned short vsync_interval = 0x8;
#endif
BOOL fshowvsync = FALSE;
BOOL VsyncInterrupt = FALSE;
BOOL NoVsyncWait = TRUE;
unsigned short VsyncCheckCount = 0;
unsigned short VsyncCount = 2;

extern HANDLE hStartVsyncEvent;
extern HANDLE hEndVsyncEvent;
extern void TgdcStatusChange();
extern BOOL notraptgdcstatus;

VOID WaitVsync()
{
        if(sc.ScreenState != WINDOWED && !NoVsyncWait) {
            if(notraptgdcstatus) {
                _asm {
                    push        eax
wait_low:
                    in          al,60h
                    test        al,20h
                    jnz         wait_low
wait_high:
                    in          al,60h
                    test        al,20h
                    jz          wait_high

                    pop         eax
                }
            } else {
                SetEvent(hStartVsyncEvent);
                WaitForSingleObject(hEndVsyncEvent, -1);
            }
        }
#ifdef DBG
        if(fshowvsync)
                DbgPrint("NTVDM: Vsync interrupt!\n");
#endif
}

VOID VsyncProcess()
{
#if 0
        VsyncThreadFlag = TRUE;

        while(VsyncThreadFlag) {
                WaitForSingleObject(RequestVsyncEvent, -1);
                if(VsyncThreadFlag) {
                        Sleep(vsync_interval);
#ifdef DBG
                        if(fshowvsync)
                                DbgPrint("NTVDM: Call ica_hw_interrupt!\n");
#endif
                        ica_hw_interrupt(ICA_MASTER, CPU_CRTV_INT, 1);
                        Sleep(vsync_interval);
                        TgdcStatusChange();
                }
        }

        ExitThread(NULL);
#endif
}

VOID CreateVsyncThread()
{
#if 0
        DWORD   VsyncID;

        VsyncThreadHadle = CreateThread((LPSECURITY_ATTRIBUTES) NULL,
                                VSYNC_THREAD_SIZE,
                                (LPTHREAD_START_ROUTINE) VsyncProcess,
                                (LPVOID) NULL,
                                (DWORD) 0,
                                &VsyncID);

        if(!VsyncThreadHadle)
                DisplayErrorTerm(EHS_FUNC_FAILED,
                                GetLastError(),
                                 __FILE__,
                                __LINE__);

        RequestVsyncEvent = CreateEvent((LPSECURITY_ATTRIBUTES) NULL,
                                      FALSE,
                                      FALSE,
                                      NULL);

        if(!RequestVsyncEvent)
                DisplayErrorTerm(EHS_FUNC_FAILED,
                                GetLastError(),
                                 __FILE__,
                                __LINE__);
#endif
}

VOID DeleteVsyncThread()
{
#if 0
        VsyncThreadFlag = FALSE;
        SetEvent(RequestVsyncEvent);
        CloseHandle(VsyncThreadHadle);
        CloseHandle(RequestVsyncEvent);
#endif
}

VOID RequestVsync()
{
#if 0
        vsync_interval = (getMSW() & MSW_PE) ? protect_vsync_interval : real_vsync_interval;
#endif
#ifdef DBG
        if(fshowvsync)
                DbgPrint("NTVDM: Vsync Request!\n");
#endif
#if 0
        SetEvent(RequestVsyncEvent);
#else
        VsyncInterrupt = TRUE;
#endif
}

void vsync_check()
{
    if (VsyncInterrupt) {
        if(++VsyncCheckCount >= VsyncCount) {
            ica_hw_interrupt(ICA_MASTER, CPU_CRTV_INT, 1);
            VsyncInterrupt = FALSE;
            VsyncCheckCount = 0;
        }
    }
}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_unix.c ===
/*****************************************************************************
*          nt_unix.c - miscellaneous stuff that may be needed.               *
*          File derived from hp_unix.c by Philippa Watson.                   *
*                                                                            *
*          This version is written/ported for New Technology OS/2            *
*          by Andrew Watson                                                  *
*                                                                            *
*          Date pending due to ignorance                                     *
*                                                                            *
*          (c) Copyright Insignia Solutions 1991                             *
*                                                                            *
*****************************************************************************/

#include <windows.h>
#include "host_def.h"
#include "insignia.h"
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <string.h>
#include <time.h>
#include <sys\types.h>
#include "xt.h"
#include CpuH
#include "timeval.h"
#include "error.h"
#include "sas.h"
#include "spcfile.h"
#include "idetect.h"
#include "debug.h"
#include "nt_reset.h"
#include "nt_pif.h"


/*****************************************************************************
*    local #define used for stubbing out functions                           *
*****************************************************************************/

#define STUBBED 1

/****    externally visible global variable declarations                 ****/

extern  char    *_sys_errlist[];
extern  int     _sys_nerr;


/* Exported Data */
GLOBAL BOOL ExternalWaitRequest = FALSE;


/* Local Module Data */
HANDLE IdleEvent = NULL;
DWORD MainThreadId = 0;
BOOL NowWaiting = FALSE;

/*****************************************************************************
*    Function: host_get_system_error()                                       *
*    This routine processes an error returned by SoftPC.                     *
*    Returns a pointer to an error message (located in a table) that         *
*    corresponds to the error number passed as a parameter.                  *
*****************************************************************************/

LPSTR host_get_system_error(filename, line, error)
LPSTR  filename;
DWORD  line;
DWORD  error;
{
static  BYTE buf[256];

if (error > (DWORD)_sys_nerr)
   {
   sprintf(buf, "System error %d occurred in %s (line %d)",
		 error, filename, line);
   return(buf);
   }
else
   return(_sys_errlist[error]);
}


/* This section contains host side of idling system */

/*****************************************************************************
*    Function: host_idle_init()                                              *
* Create Event used in Idling Wait                                           *
*****************************************************************************/
void host_idle_init(void)
{
    if (IdleEvent != NULL)
	return;         //Called already 

    MainThreadId = GetCurrentThreadId();

    IdleEvent = CreateEvent((LPSECURITY_ATTRIBUTES) NULL, FALSE, FALSE, NULL);

#ifndef PROD
    if (IdleEvent == NULL)
	printf("NTVDM:Idlling Event creation failed. Err %d\n",GetLastError());
#endif
}

/*****************************************************************************
*    Function: WaitIfIdle()                                                  *
*  If no counter indications (video, com etc) then do short idle             *
*                                                                            *
*****************************************************************************/
void WaitIfIdle(void)
{
    DWORD idletime;

    if (IdleDisabledFromPIF) {
	return;
	}


    /*
     * If its not wow make sure the main thread also gets idled.
     */
    if (!VDMForWOW && GetCurrentThreadId() != MainThreadId)
    {
	ExternalWaitRequest = TRUE;
    }


    //
    // Check for invalid conditions
    //
    if (!IdleEvent || !IdleNoActivity) {
	Sleep(0);
	return;
	}

    NowWaiting = TRUE;
    idletime = ienabled ? 10 : 1;

    if (WaitForSingleObject(IdleEvent, idletime) == WAIT_FAILED) {
        Sleep(0);
        idletime = 0;
        }
    NowWaiting = FALSE;

#ifndef MONITOR
    if (idletime) {
        ActivityCheckAfterTimeSlice();
        }
#endif

}


/*****************************************************************************
*    Function: WakeUpNow()                                                   *
*  The paired counterpart to WaitIfIdle() - the event that was worth waiting *
*  for has arrived. Wake CPU up so it can deal with it.                      *
*****************************************************************************/
void WakeUpNow(void)
{
   HostIdleNoActivity();
}



/*  HostIdleNoActivity
 *
 *  Set Indicator that video\disk\com\lpt activity
 *  has happened and wake up sleeping CPU if appears to be sleeping.
 */
void HostIdleNoActivity(void)
{

    IdleNoActivity=0;

    if (NowWaiting)                  // critical path do inline....
	PulseEvent(IdleEvent);
}



/*****************************************************************************
*    Function: host_release_timeslice()                                     *
*****************************************************************************/
void host_release_timeslice(void)
{
    DWORD idletime;

    //
    // If there is counter idle activity no idling so return immediatly
    //
    if (!IdleNoActivity || IdleDisabledFromPIF) {
	return;
    }

    //
    // Check for invalid or unsafe conditions
    //
    if (!IdleEvent || !ienabled) {
	Sleep(0);
	return;
	}

    //
    // If pif Foreground priority is set to less than 100 on every timer
    // event PrioWaitIfIdle will do a wait, so use minimum delay here.
    //
    if (WNTPifFgPr < 100) {
        idletime = 0;
	}

    //
    // Normal idling condition, so use sig portion of 55 ms time tick
    //
    else {
        idletime = 25;
	}

    NowWaiting = TRUE;
    if (WaitForSingleObject(IdleEvent, idletime) == WAIT_FAILED) {
        idletime = 0;
	Sleep(0);
        }
    NowWaiting = FALSE;

#ifndef MONITOR
    if (idletime) {
        ActivityCheckAfterTimeSlice();
        }
#endif



}



/*****************************************************************************
*    Function: PrioWaitIfIdle(Percentage)                                    *
*  unsigned char Percentage - Percent of cpu usage desired
*  The smaller the number the bigger the delay time
*
*****************************************************************************/
void PrioWaitIfIdle(unsigned char Percentage)
{
    DWORD idletime;


    //
    // If there is counter idle activity no idling so return immediatly
    //
    if (!IdleNoActivity) {
	return;
    }

    //
    // Check for invalid conditions
    //
    if (!IdleEvent) {
	Sleep(0);
	return;
	}


    idletime = (100 - Percentage) >> 1; // percent of 55ms time tick


    //
    // If idle is disabled, we can't depend on the IdleNoActivity flag
    // or if the delay time is less than the system's time slice
    // shorten the idle so we don't oversleep
    //
    if (!ienabled)
	idletime >>= 2;

    if (idletime < 10)
	idletime >>= 1;

    if (idletime) {
	NowWaiting = TRUE;
        if (WaitForSingleObject(IdleEvent, idletime) == WAIT_FAILED) {
            idletime = 0;
	    Sleep(0);
	    }
	NowWaiting = FALSE;
	}
    else {
	Sleep(0);
        }

#ifndef MONITOR
    if (idletime) {
        ActivityCheckAfterTimeSlice();
        }
#endif

}




/*****************************************************************************
*    function: host_memset()                                                 *
*    This function does what the traditional memset standard library function*
*    does ... i.e. fills a portion of memory with the character represented  *
*    in val.                                                                 *
*    Returns nothing.                                                        *
*****************************************************************************/

void host_memset(addr, val, size)
register char * addr;
register char val;
unsigned int size;
{
memset(addr, val, size);
}



#ifdef NO_LONGER_USED
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Host-specific equivalent of the Unix function localtime().
 ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

struct host_tm *host_localtime(clock)
long *clock;
{
    SYSTEMTIME now;
    SAVED struct host_tm host_now;

    UNUSED(clock);
    GetLocalTime(&now);
    host_now.tm_sec = (int) now.wSecond;
    host_now.tm_min = (int) now.wMinute;
    host_now.tm_hour = (int) now.wHour;
    host_now.tm_mday = (int) now.wDay;
    host_now.tm_mon = (int) now.wMonth - 1;    // Unix has 0 based months,NT 1
    host_now.tm_year = (int) now.wYear;
    host_now.tm_wday = (int) now.wDayOfWeek;

    host_now.tm_yday = (int) 0;     // the base doesn't require these.
    host_now.tm_isdst = (int) 0;
    return(&host_now);
}
#endif

/*
 * Host-specific equivalent of the Unix function time().
 */

long host_time(tloc)
long *tloc;
{
    UNUSED(tloc);
    return((long) GetTickCount() / 1000 );
}

/*
 * Check that the file is a character special device.
 */
boolean host_file_is_char_dev(path)
char *path;
{
    return(FALSE);
}


/*
 * Looks for a given file name in the 'ntvdm' subdirectory of the
 * windows system directory. The full path to the first one found is returned
 * in the 'full_path' variable, and as the result of the function.
 */
char *host_find_file(char *file,char *full_path,int display_error)
{
    char buffer[MAXPATHLEN];
    WIN32_FIND_DATA match;
    HANDLE gotit;
    ULONG ulLen=strlen(file);

    if (ulLen + 1 + ulSystem32PathLen + 1 <= MAXPATHLEN)
    {
	    memcpy(buffer, pszSystem32Path, ulSystem32PathLen);
        buffer[ulSystem32PathLen] = '\\';
	    memcpy(buffer+ulSystem32PathLen+1, file, ulLen+1);

        if ((gotit = FindFirstFile(buffer, &match)) != (HANDLE)-1)
        {
	    FindClose(gotit);       // should check (BOOL) return & then ??
	    memcpy(full_path, buffer, ulSystem32PathLen + ulLen + 1 + 1);
	    return (full_path);
        }
    }

    /* Haven't managed to find the file. Oh dear... */
    switch( display_error )
    {
	case SILENT:
	    return( NULL );
	    break;

	case STANDARD:
	case CONT_AND_QUIT:
	    host_error(EG_SYS_MISSING_FILE, ERR_CONT | ERR_QUIT, file);
	    break;

	default:
	    host_error(EG_SYS_MISSING_FILE, ERR_QUIT, file);
	    break;
    }

    return (NULL);
}



//
//  this stuff needs to be removed
//
static char temp_copyright[] = "SoftPC-AT Version 3\n\r(C)Copyright Insignia Solutions Inc. 1987-1992";

static int block_level = 0;

GLOBAL void host_block_timer()
{
    if(block_level) return;
    block_level++;
}

GLOBAL void host_release_timer()
{
    block_level=0;
}
GLOBAL CHAR * host_get_years()
{
return ("1987 - 1992");
}
GLOBAL CHAR * host_get_version()
{
return("3.00");
}
GLOBAL CHAR * host_get_unpublished_version()
{
return("");
}
GLOBAL CHAR * host_get_copyright()
{
return("");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_vga.c ===
/*
 * SoftPC Revision 3.0
 *
 * Title        : Win32 VGA Graphics Module
 *
 * Description  :
 *
 *              This modules contain the Win32 specific functions required
 *              to support the VGA emulation.
 *
 * Author       : Jerry Sexton (based on X_vga.c)
 *
 * Notes        :
 *
 */

#include <windows.h>
#include "insignia.h"
#include "host_def.h"

#include "xt.h"
#include "gvi.h"
#include "gmi.h"
#include "gfx_upd.h"
#include <stdio.h>
#include "trace.h"
#include "debug.h"
#include "egagraph.h"
#include "egacpu.h"
#include "egaports.h"
#include "host_rrr.h"
#include "conapi.h"

#include "nt_graph.h"

#ifdef MONITOR
#include <ntddvdeo.h>
#include "nt_fulsc.h"
#endif /* MONITOR */

IMPORT int DisplayErrorTerm(int, DWORD, char *, int);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::: Initialise VGA hi res graphics ::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_init_vga_hi_graph()
{
    sub_note_trace0(EGA_HOST_VERBOSE, "nt_init_vga_hi_graph");

    /* Set up the number of bits per pixel for this mode. */
    sc.BitsPerPixel = VGA_BITS_PER_PIXEL;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::: Paint function (256 colour mode PC 320x200. SoftPC 640x400.):::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_graph_std(int offset, int screen_x, int screen_y,
                      int width, int height )
{
    register unsigned short *dest_ptr;
    register unsigned short *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i, temp, bpl, shorts_per_scanline;
    int max_width = sc.PC_W_Width >> 1,
        max_height = sc.PC_W_Height >> 1;
    SMALL_RECT rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_vga_graph_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );
    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_graph_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > max_height)
        height = max_height - screen_y;

    /*
     * Build up the bitmap: each PC pixel is stored in video memory as one
     * byte (i.e. 8 bits-per-pixel); each PC pixel is translated to a square
     * block of 4 host pixels.
     */
    bpl = get_bytes_per_line();
    shorts_per_scanline = SHORTS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    local_height = height;
    ref_data_ptr = &EGA_plane0123[offset];
    ref_dest_ptr = (unsigned short *) sc.ConsoleBufInfo.lpBitMap +
                   (screen_y << 1) * shorts_per_scanline + screen_x;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Build up the bitmap. */
    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        for( i = 0; i < width; i++ )
        {
            temp = *data_ptr++;
            *(dest_ptr + shorts_per_scanline) = *dest_ptr =
                                         (unsigned short)((temp << 8) | temp);
            dest_ptr++;
        }
        ref_dest_ptr += 2 * shorts_per_scanline;
        ref_data_ptr += bpl;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = screen_x << 1;
    rect.Top = screen_y << 1;
    rect.Right = rect.Left + (width << 1) - 1;
    rect.Bottom = rect.Top + (height << 1) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*Paint function (256 colour mode PC 320x200. SoftPC 640x400.) on big screen*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_graph_big(int offset, int screen_x, int screen_y,
                      int width, int height)
{
#ifdef BIGWIN
    register unsigned short *dest_ptr;
    register unsigned short *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    register int temp1;
    register int temp2;
    register int half_width;
    register int bpl;
    int shorts_per_scanline;
    int max_width = UNSCALE(sc.PC_W_Width) >> 1,
        max_height = UNSCALE(sc.PC_W_Height) >> 1;
    SMALL_RECT rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_vga_graph_big off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_med_graph_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > max_height)
        height = max_height - screen_y;

    bpl = get_bytes_per_line();
    shorts_per_scanline = SHORTS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    local_height = height;
    ref_data_ptr = &EGA_plane0123[offset];
    ref_dest_ptr = (unsigned short *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y << 1) * shorts_per_scanline +
                   SCALE(screen_x);
    half_width = width >> 1;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        for( i = 0; i < half_width; i++ )
        {
            temp1 = *data_ptr++;
            temp2 = *data_ptr++;

            *(dest_ptr + 2 * shorts_per_scanline) =
                *(dest_ptr + shorts_per_scanline) =
                *dest_ptr = (unsigned short) ((temp1 << 8) | temp1);

            *(dest_ptr + (2 * shorts_per_scanline) + 1) =
                *(dest_ptr + shorts_per_scanline + 1) =
#ifdef BIGEND
                *(dest_ptr + 1) = (unsigned short) ((temp1 << 8) | temp2);
#endif /* BIGEND */
#ifdef LITTLEND
                *(dest_ptr + 1) = (unsigned short) ((temp2 << 8) | temp1);
#endif /* LITTLEND */

            *(dest_ptr + (2 * shorts_per_scanline) + 2) =
                *(dest_ptr + shorts_per_scanline + 2) =
                *(dest_ptr + 2) = (unsigned short) ((temp2 << 8) | temp2);

            dest_ptr += 3;
        }

        ref_dest_ptr += 3 * shorts_per_scanline;
        ref_data_ptr += bpl;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 1);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE(width << 1) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*: Paint function (256 colour mode PC 320x200. SoftPC 1280x800.) on huge  :*/
/*: screen.                                                                :*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_graph_huge(int offset, int screen_x, int screen_y,
                       int width, int height)
{
#ifdef BIGWIN
    unsigned char *dest_ptr;
    unsigned char *line_ptr;
    unsigned char *ref_dest_ptr;
    unsigned char *data_ptr;
    unsigned char *ref_data_ptr;
    int local_height;
    int i;
    byte temp;
    int bpl;
    int max_width = UNSCALE(sc.PC_W_Width) >> 1,
        max_height = UNSCALE(sc.PC_W_Height) >> 1;
    SMALL_RECT rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_vga_graph_huge off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_med_graph_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > max_height)
        height = max_height - screen_y;

    bpl = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    local_height = height;
    ref_data_ptr = &EGA_plane0123[offset];
    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y << 1) * bpl +
                   SCALE(screen_x << 1);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        line_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        for(i = 0; i < width; i++)
        {
            dest_ptr = line_ptr;
            temp = *data_ptr++;

            /* line 1 */
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr = temp;

            dest_ptr = line_ptr + bpl;

            /* line 2 */
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr = temp;

            dest_ptr = line_ptr + 2 * bpl;

            /* line 3 */
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr = temp;

            dest_ptr = line_ptr + 3 * bpl;

            /* line 4 */
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr++ = temp;
            *dest_ptr = temp;

            line_ptr += 4;
        }

        ref_dest_ptr += FOUR_SCANLINES * bpl;
        ref_data_ptr += 320;
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 1);
    rect.Top = SCALE(screen_y << 1);
    rect.Right = rect.Left + SCALE(width << 1) - 1;
    rect.Bottom = rect.Top + SCALE(height << 1) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
#endif /* BIGWIN */
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*Paint function (256 colour mode PC 320x200. SoftPC 640x400.)              */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/* The data for this mode is split over all four vga planes and is interlaced
   4 way onto the screen. Hence 4 pixels horizontally for every pixel that the
   base detects. Pixels are not doubled vertically. */

void nt_vga_med_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height)
{
    ULONG       *p0,
                *ref_p0,
                *dest_ptr,
                *ref_dest_ptr,
                data;
    UTINY       data0,
                data1,
                data2,
                data3;
    int  local_height,
         i,
         longs_per_scanline;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_vga_med_graph_std off=%d x=%d y=%d width=%d height=%d\n",
                   offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* This mode doubles vertically so, multiply vertical parameters by 2. */
    screen_y <<= 1;
    height <<= 1;

    /* If the image is completely outside the display area do nothing. */
    if (((screen_x << 3) >= sc.PC_W_Width) || (screen_y >= sc.PC_W_Height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_med_graph_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (((screen_x + width) << 3) > sc.PC_W_Width)
        width = (sc.PC_W_Width >> 3) - screen_x;
    if (screen_y + height > sc.PC_W_Height)
        height = sc.PC_W_Height - screen_y;

    /* local_height is number of lines in video memory. */
    local_height = height >> 1;

    /* Get pointer to video memory. */
    ref_p0 = (ULONG *) get_regen_ptr(0, offset << 2);

    /* Get pointer to bitmap. */
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_dest_ptr = (ULONG *) sc.ConsoleBufInfo.lpBitMap +
                   screen_y * longs_per_scanline + (screen_x << 1);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Munge. */
    do
    {
        dest_ptr = ref_dest_ptr;
        p0 = ref_p0;

        for(i = 0; i < width; i++)
        {

            /*
             * Get data and output to screen buffer. NOTE little endian
             * dependent code.
             */
            data = *p0++;
            data0 = (UTINY) (data & 0xff);
            data1 = (UTINY) ((data >> 8) & 0xff);
            data2 = (UTINY) ((data >> 16) & 0xff);
            data3 = (UTINY) (data >> 24);

            *(dest_ptr + longs_per_scanline) = *dest_ptr =
                (data1 << 24) | (data1 << 16) | (data0 << 8) | data0;
            dest_ptr++;
            *(dest_ptr + longs_per_scanline) = *dest_ptr =
                (data3 << 24) | (data3 << 16) | (data2 << 8) | data2;
            dest_ptr++;
        }

        ref_dest_ptr += 2 * longs_per_scanline;
        ref_p0 += get_offset_per_line();
    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = screen_x << 3;
    rect.Top = (SHORT)screen_y;
    rect.Right = rect.Left + (width << 3) - 1;
    rect.Bottom = rect.Top + height - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*Paint function (256 colour mode PC 320x200. SoftPC 960x600.)              */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/* The data for this mode is split over all four vga planes and is interlaced
   4 way onto the screen. Hence 4 pixels horizontally for every pixel that the
   base detects. Pixels are not doubled vertically. */

void nt_vga_med_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height)
{
    ULONG       *p0,
                *ref_p0,
                *dest_ptr,
                *ref_dest_ptr,
                data;
    UTINY       data0,
                data1,
                data2,
                data3;
    int  local_height,
         i,
         longs_per_scanline,
         max_width = UNSCALE(sc.PC_W_Width) >> 3,
         max_height = UNSCALE(sc.PC_W_Height);
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_vga_med_graph_big off=%d x=%d y=%d width=%d height=%d\n",
                   offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* This mode doubles vertically so, multiply vertical parameters by 2. */
    screen_y <<= 1;
    height <<= 1;

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_med_graph_big() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > max_height)
        height = max_height - screen_y;

    /* local_height is number of lines in video memory. */
    local_height = height >> 1;

    /* Get pointer to video memory. */
    ref_p0 = (ULONG *) get_regen_ptr(0, offset << 2);

    /* Get pointer to bitmap. */
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_dest_ptr = (ULONG *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * longs_per_scanline + SCALE(screen_x << 1);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Munge. */
    do
    {
        dest_ptr = ref_dest_ptr;
        p0 = ref_p0;

        for(i = 0; i < width; i++)
        {

            /*
             * Get data and output to screen buffer. NOTE little endian
             * dependent code.
             */
            data = *p0++;
            data0 = (UTINY) (data & 0xff);
            data1 = (UTINY) ((data >> 8) & 0xff);
            data2 = (UTINY) ((data >> 16) & 0xff);
            data3 = (UTINY) (data >> 24);

            *(dest_ptr + 2 * longs_per_scanline) =
                *(dest_ptr + longs_per_scanline) =
                *dest_ptr =
                (data1 << 24) | (data0 << 16) | (data0 << 8) | data0;
            dest_ptr++;
            *(dest_ptr + 2 * longs_per_scanline) =
                *(dest_ptr + longs_per_scanline) =
                *dest_ptr =
                (data2 << 24) | (data2 << 16) | (data1 << 8) | data1;
            dest_ptr++;
            *(dest_ptr + 2 * longs_per_scanline) =
                *(dest_ptr + longs_per_scanline) =
                *dest_ptr =
                (data3 << 24) | (data3 << 16) | (data3 << 8) | data2;
            dest_ptr++;
        }

        ref_dest_ptr += 3 * longs_per_scanline;
        ref_p0 += get_offset_per_line();
    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 3);
    rect.Top = (SHORT)SCALE(screen_y);
    rect.Right = rect.Left + SCALE(width << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*Paint function (256 colour mode PC 320x200. SoftPC 1080x800.)              */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/* The data for this mode is split over all four vga planes and is interlaced
   4 way onto the screen. Hence 4 pixels horizontally for every pixel that the
   base detects. Pixels are not doubled vertically. */

void nt_vga_med_graph_huge(int offset, int screen_x, int screen_y,
                          int width, int height)
{
    ULONG       *p0,
                *ref_p0,
                *dest_ptr,
                *ref_dest_ptr,
                data;
    UTINY       data0,
                data1,
                data2,
                data3;
    int  local_height,
         i,
         longs_per_scanline,
         max_width = UNSCALE(sc.PC_W_Width) >> 3,
         max_height = UNSCALE(sc.PC_W_Height);
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_vga_med_graph_huge off=%d x=%d y=%d width=%d height=%d\n",
                   offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* This mode doubles vertically so, multiply vertical parameters by 2. */
    screen_y <<= 1;
    height <<= 1;

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_med_graph_huge() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > max_height)
        height = max_height - screen_y;

    /* local_height is number of lines in video memory. */
    local_height = height >> 1;

    /* Get pointer to video memory. */
    ref_p0 = (ULONG *) get_regen_ptr(0, offset << 2);

    /* Get pointer to bitmap. */
    longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_dest_ptr = (ULONG *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * longs_per_scanline + SCALE(screen_x << 1);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Munge. */
    do
    {
        dest_ptr = ref_dest_ptr;
        p0 = ref_p0;

        for(i = 0; i < width; i++)
        {

            /*
             * Get data and output to screen buffer. NOTE little endian
             * dependent code.
             */
            data = *p0++;
            data0 = (UTINY) (data & 0xff);
            data1 = (UTINY) ((data >> 8) & 0xff);
            data2 = (UTINY) ((data >> 16) & 0xff);
            data3 = (UTINY) (data >> 24);

            *(dest_ptr + 3 * longs_per_scanline) =
                *(dest_ptr + 2 * longs_per_scanline) =
                *(dest_ptr + longs_per_scanline) =
                *dest_ptr =
                (data0 << 24) | (data0 << 16) | (data0 << 8) | data0;
            dest_ptr++;
            *(dest_ptr + 3 * longs_per_scanline) =
                *(dest_ptr + 2 * longs_per_scanline) =
                *(dest_ptr + longs_per_scanline) =
                *dest_ptr =
                (data1 << 24) | (data1 << 16) | (data1 << 8) | data1;
            dest_ptr++;
            *(dest_ptr + 3 * longs_per_scanline) =
                *(dest_ptr + 2 * longs_per_scanline) =
                *(dest_ptr + longs_per_scanline) =
                *dest_ptr =
                (data2 << 24) | (data2 << 16) | (data2 << 8) | data2;
            dest_ptr++;
            *(dest_ptr + 3 * longs_per_scanline) =
                *(dest_ptr + 2 * longs_per_scanline) =
                *(dest_ptr + longs_per_scanline) =
                *dest_ptr =
                (data3 << 24) | (data3 << 16) | (data3 << 8) | data3;
            dest_ptr++;
        }

        ref_dest_ptr += 4 * longs_per_scanline;
        ref_p0 += get_offset_per_line();
    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 3);
    rect.Top = (SHORT)SCALE(screen_y);
    rect.Right = rect.Left + SCALE(width << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*Paint function (256 colour mode PC 320x400. SoftPC 640x400.)              */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/* The data for this mode is split over all four vga planes and is interlaced
   4 way onto the screen. Hence 4 pixels horizontally for every pixel that the
   base detects. Pixels are not doubled vertically. */

void nt_vga_hi_graph_std(int offset, int screen_x, int screen_y,
                         int width, int height)
{
    unsigned char   *p0,
                    *ref_p0,
                    *dest_ptr,
                    *ref_dest_ptr,
                     data0,
                     data1,
                     data2,
                     data3;
    int  local_height,
         i,
         bpl,
         max_width = sc.PC_W_Width >> 3;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_vga_hi_graph_std off=%d x=%d y=%d width=%d height=%d\n",
                   offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= sc.PC_W_Height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_hi_graph_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > sc.PC_W_Height)
        height = sc.PC_W_Height - screen_y;

    /* local_height is number of lines in video memory. */
    local_height = height;

    /* Get pointer to video memory. */
    ref_p0 = get_regen_ptr(0, offset << 2);

    /* Get pointer to bitmap. */
    bpl = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   screen_y * bpl + (screen_x << 3);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Munge. */
    do
    {
        dest_ptr = ref_dest_ptr;
        p0 = ref_p0;

        for(i = 0; i < width; i++)
        {
            data0 = *p0++;
            data1 = *p0++;
            data2 = *p0++;
            data3 = *p0++;

            *dest_ptr       = data0;
            *(dest_ptr + 1) = data0;
            *(dest_ptr + 2) = data1;
            *(dest_ptr + 3) = data1;
            *(dest_ptr + 4) = data2;
            *(dest_ptr + 5) = data2;
            *(dest_ptr + 6) = data3;
            *(dest_ptr + 7) = data3;
            dest_ptr += 8;
        }

        ref_dest_ptr += bpl;
        ref_p0 += 4 * get_offset_per_line();
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = screen_x << 3;
    rect.Top = (SHORT)screen_y;
    rect.Right = rect.Left + (width << 3) - 1;
    rect.Bottom = rect.Top + height - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::Paint function (256 colour mode PC 320(360)x400. SoftPC 920(1080)x600)::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_hi_graph_big(int offset, int screen_x, int screen_y,
                         int width, int height)
{
    unsigned char   *p0,
                    *ref_p0,
                    *dest_ptr,
                    *nl_dest_ptr,
                    *ref_dest_ptr,
                     data0,
                     data1,
                    data2,
                     data3;
    int  local_height,
         draw_height,
         local_screen_y,
         i,
         bpl,
         max_width = UNSCALE(sc.PC_W_Width) >> 3,
         max_height = UNSCALE(sc.PC_W_Height);
    BOOL     two_lines;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_vga_hi_graph_big off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_hi_graph_big() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > max_height)
        height = max_height - screen_y;

    /* Get pointer to video memory. */
    ref_p0 = get_regen_ptr(0, offset << 2);

    /* Get pointer to bitmap. */
    local_screen_y = SCALE(screen_y + 1) - 1;
    bpl = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   local_screen_y * bpl +
                   SCALE(screen_x << 3);

    /* Set up local parameters. */
    local_height = height;
    draw_height = 0;

    /*
     * 2 lines are output to the SoftPC screen if this is an odd line, 1 line
     * if it is even.
     */
    two_lines = screen_y & 1 ? FALSE : TRUE;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    /* Munge. */
    do
    {
        dest_ptr = ref_dest_ptr;
        p0 = ref_p0;

        for( i = 0; i < width; i++ )
        {
            data0 = *p0++;
            data1 = *p0++;
            data2 = *p0++;
            data3 = *p0++;

            *dest_ptr        = data0;
            *(dest_ptr + 1)  = data0;
            *(dest_ptr + 2)  = data0;
            *(dest_ptr + 3)  = data1;
            *(dest_ptr + 4)  = data1;
            *(dest_ptr + 5)  = data1;
            *(dest_ptr + 6)  = data2;
            *(dest_ptr + 7)  = data2;
            *(dest_ptr + 8)  = data2;
            *(dest_ptr + 9)  = data3;
            *(dest_ptr + 10) = data3;
            *(dest_ptr + 11) = data3;

            if (two_lines)
            {
                nl_dest_ptr = dest_ptr + bpl;

                *nl_dest_ptr        = data0;
                *(nl_dest_ptr + 1)  = data0;
                *(nl_dest_ptr + 2)  = data0;
                *(nl_dest_ptr + 3)  = data1;
                *(nl_dest_ptr + 4)  = data1;
                *(nl_dest_ptr + 5)  = data1;
                *(nl_dest_ptr + 6)  = data2;
                *(nl_dest_ptr + 7)  = data2;
                *(nl_dest_ptr + 8)  = data2;
                *(nl_dest_ptr + 9)  = data3;
                *(nl_dest_ptr + 10) = data3;
                *(nl_dest_ptr + 11) = data3;
            }
            dest_ptr += 12;
        }

        if (two_lines)
        {
            draw_height += 2;
            ref_dest_ptr += 2 * bpl;
        }
        else
        {
            draw_height++;
            ref_dest_ptr += bpl;
        }
        two_lines = !two_lines;

        ref_p0 += 4 * get_offset_per_line();
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 3);
    rect.Top = (SHORT)local_screen_y;
    rect.Right = rect.Left + SCALE(width << 3) - 1;
    rect.Bottom = rect.Top + draw_height - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::Paint function (256 colour mode PC 320(360)x400. SoftPC 1280(1440)x800::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_hi_graph_huge(int offset, int screen_x, int screen_y,
                          int width, int height )
{
    unsigned char   *p0,
                    *ref_p0,
                    *dest_ptr,
                    *nl_dest_ptr,
                    *ref_dest_ptr,
                     data0,
                     data1,
                     data2,
                     data3;
    int  local_height,
         i,
         bpl,
         max_width = UNSCALE(sc.PC_W_Width) >> 3,
         max_height = UNSCALE(sc.PC_W_Height);
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_vga_hi_graph_huge off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if ((screen_x >= max_width) || (screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_hi_graph_huge() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > max_width)
        width = max_width - screen_x;
    if (screen_y + height > max_height)
        height = max_height - screen_y;

    /* local_height is number of lines in video memory. */
    local_height = height;

    /* Get pointer to video memory. */
    ref_p0 = get_regen_ptr(0, offset << 2);

    /* Get pointer to bitmap. */
    bpl = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bpl +
                   SCALE(screen_x << 3);

    /* Munge. */
    do
    {
        dest_ptr = ref_dest_ptr;
        p0 = ref_p0;

        for(i = 0; i < width; i++)
        {
            data0 = *p0++;
            data1 = *p0++;
            data2 = *p0++;
            data3 = *p0++;

            nl_dest_ptr = dest_ptr + bpl;

            *dest_ptr = *nl_dest_ptr = data0;
            *(dest_ptr + 1) = *(nl_dest_ptr + 1) = data0;
            *(dest_ptr + 2) = *(nl_dest_ptr + 2) = data0;
            *(dest_ptr + 3) = *(nl_dest_ptr + 3) = data0;
            *(dest_ptr + 4) = *(nl_dest_ptr + 4) = data1;
            *(dest_ptr + 5) = *(nl_dest_ptr + 5) = data1;
            *(dest_ptr + 6) = *(nl_dest_ptr + 6) = data1;
            *(dest_ptr + 7) = *(nl_dest_ptr + 7) = data1;
            *(dest_ptr + 8) = *(nl_dest_ptr + 8) = data2;
            *(dest_ptr + 9) = *(nl_dest_ptr + 9) = data2;
            *(dest_ptr + 10) = *(nl_dest_ptr + 10) = data2;
            *(dest_ptr + 11) = *(nl_dest_ptr + 11) = data2;
            *(dest_ptr + 12) = *(nl_dest_ptr + 12) = data3;
            *(dest_ptr + 13) = *(nl_dest_ptr + 13) = data3;
            *(dest_ptr + 14) = *(nl_dest_ptr + 14) = data3;
            *(dest_ptr + 15) = *(nl_dest_ptr + 15) = data3;

            dest_ptr += 16;
        }

        ref_dest_ptr += 2 * bpl;
        ref_p0 += 4 * get_offset_per_line();
    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x << 3);
    rect.Top = (SHORT)SCALE(screen_y);
    rect.Right = rect.Left + SCALE(width << 3) - 1;
    rect.Bottom = rect.Top + SCALE(height) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::: Paint function (256 colour mode: PC 320x200. SoftPC 640x400 ::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_mono_graph_std(int offset, int screen_x, int screen_y,
                           int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
  "nt_vga_mono_graph_std off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
   offset, screen_x, screen_y, width, height);
}
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*Paint function (256 colour mode: PC 320x200. SoftPC 960x600) on big screen*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void  nt_vga_mono_graph_big(int offset, int screen_x, int screen_y,
                            int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
  "nt_vga_mono_graph_big off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
   offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*: Paint function (256 colour mode: PC 320x200. SoftPC 1280x800) on huge  :*/
/*: screen.                                                                :*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_mono_graph_huge(int offset, int screen_x, int screen_y,
                            int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_vga_mono_graph_huge off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paint function (256Col mode : PC 320(360)x400. SoftPC 640(720)x400) ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*  The data for this mode is split over all four vga planes and is interlaced
    4 way onto the screen. Hence 4 pixels horizontally for every pixel that the
    base detects. Pixels are not doubled vertically. */


void nt_vga_mono_med_graph_std(int offset, int screen_x, int screen_y,
                              int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
  "nt_vga_mono_med_graph_std off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
   offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paint function (256Col mode : PC 320(360)x400. SoftPC 920(1080)x600 ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_mono_med_graph_big(int offset, int screen_x, int screen_y,
                              int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
  "nt_vga_mono_med_graph_big off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
   offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paint function (256Col mode: PC 320(360)x400. SoftPC 1280(1440)x400 ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_mono_med_graph_huge(int offset, int screen_x, int screen_y,
                               int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_vga_mono_med_graph_huge off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height );
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paint function (256Col mode : PC 320(360)x400. SoftPC 640(720)x400) ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

/*  The data for this mode is split over all four vga planes and is interlaced
    4 way onto the screen. Hence 4 pixels horizontally for every pixel that the
    base detects. Pixels are not doubled vertically. */


void nt_vga_mono_hi_graph_std(int offset, int screen_x, int screen_y,
                              int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
  "nt_vga_mono_hi_graph_std off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
   offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paint function (256Col mode : PC 320(360)x400. SoftPC 920(1080)x600 ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_mono_hi_graph_big(int offset, int screen_x, int screen_y,
                              int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
  "nt_vga_mono_hi_graph_big off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
   offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Paint function (256Col mode: PC 320(360)x400. SoftPC 1280(1440)x400 ::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_mono_hi_graph_huge(int offset, int screen_x, int screen_y,
                               int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_vga_mono_hi_graph_huge off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height );
}

#ifdef V7VGA
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: 256 colour mode: PC 640x400, 640x480, 720x540, 800x600. :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_v7vga_hi_graph_std(int offset, int screen_x, int screen_y,
                           int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                  "nt_v7vga_hi_graph_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim Septemver 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>400 || width>640 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_std() w=%d h=%d", width, height );
        return;
    }

    local_height = height;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_data_ptr = &EGA_plane0123[offset];
    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   screen_y * bytes_per_line +
                   screen_x;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        for(i = 0; i < width; i++)
            *dest_ptr++ = *data_ptr++;

        ref_dest_ptr += bytes_per_line;
        ref_data_ptr += get_offset_per_line();
    }
    while( --local_height );

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = (SHORT)screen_x;
    rect.Top = (SHORT)screen_y;
    rect.Right = rect.Left + width - 1;
    rect.Bottom = rect.Top + height - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: 256 colour mode: PC 640x400, 640x480, 720x540, 800x600. :::::::::*/
/*:::::::: SoftPC 960x600, 960x720, 1080x810, 1200x900.            :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_v7vga_hi_graph_big(int offset, int screen_x, int screen_y,
                           int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height=0;
    register int i, temp1, temp2;
    register int half_width = width >> 1;
    int bytes_per_line;
    int local_screen_y;
    BOOL two_lines;
    SMALL_RECT rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                  "nt_v7vga_hi_graph_big off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>400 || width>640 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_big() w=%d h=%d", width, height );
        return;
    }

    /* Get pointer to data in EGA_planes. */
    ref_data_ptr = (unsigned char *) &EGA_plane0123[offset] +
                   (height - 1) * get_offset_per_line();

    /*
     * Get pointer into bitmap, which alternates 2 lines and 1 line so that,
     * memory line 0 -> bitmap 0,
     *             1 ->        2,
     *             2 ->        3,
     *             3 ->        5,
     *             4 ->        6 etc.
     * hence the local_screen_y assignment.
     */
    local_screen_y = SCALE(screen_y + 1) - 1;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   local_screen_y * bytes_per_line +
                   SCALE(screen_x);

    /* Decide whether to start with 1 or 2 scanlines. */
    two_lines = screen_y & 1 ? FALSE : TRUE;

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        for(i = 0; i < half_width; i++)
        {
            temp1 = *data_ptr++;
            temp2 = *data_ptr++;
            *dest_ptr = (unsigned char) temp1;
            *(dest_ptr+2) = (unsigned char) temp2;

            if (two_lines)
            {
                *(dest_ptr+1) = (unsigned char) temp1;
                *(dest_ptr + bytes_per_line) = (unsigned char) temp1;
                *(dest_ptr + bytes_per_line + 1) = (unsigned char) temp2;
                *(dest_ptr + bytes_per_line + 2) = (unsigned char) temp2;
            }
            else
            {
                *(dest_ptr+1) = (unsigned char) temp2;
            }
            dest_ptr+=3;

        }

        ref_data_ptr += get_offset_per_line();
        if (two_lines)
        {
            local_height += 2;
            ref_dest_ptr += 2 * bytes_per_line;
        }
        else
        {
            local_height++;
            ref_dest_ptr += bytes_per_line;
        }
        two_lines = !two_lines;
    }
    while(--height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = (SHORT)local_screen_y;
    rect.Right = rect.Left + SCALE(width) - 1;
    rect.Bottom = rect.Top + local_height - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: 256 colour mode: PC 640x400, 640x480, 720x540, 800x600. :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_v7vga_hi_graph_huge(int offset, int screen_x, int screen_y,
                            int width, int height)
{
    register unsigned char *dest_ptr;
    register unsigned char *ref_dest_ptr;
    register unsigned char *data_ptr;
    register unsigned char *ref_data_ptr;
    register int local_height;
    register int i;
    int bytes_per_line;
    SMALL_RECT rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                 "nt_v7vga_hi_graph_huge off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }
    /*
    ** Tim September 92, sanity check parameters, if they're too big
    ** it can cause a crash.
    */
    if( height>400 || width>640 ){
        assert2( NO, "VDM: nt_v7vga_hi_graph_huge() w=%d h=%d", width, height );
        return;
    }

    local_height = height;
    bytes_per_line = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
    ref_data_ptr = &EGA_plane0123[offset];
    ref_dest_ptr = (unsigned char *) sc.ConsoleBufInfo.lpBitMap +
                   SCALE(screen_y) * bytes_per_line +
                   SCALE(screen_x);

    /* Grab the mutex. */
    GrabMutex(sc.ConsoleBufInfo.hMutex);

    do
    {
        dest_ptr = ref_dest_ptr;
        data_ptr = ref_data_ptr;

        for(i = 0; i < width; i++)
        {
            *dest_ptr = *(dest_ptr + bytes_per_line) = *data_ptr;
            *(dest_ptr + 1) = *(dest_ptr + 1 + bytes_per_line) = *data_ptr++;
            dest_ptr += 2;
        }

        ref_dest_ptr -= 2 * bytes_per_line;
        ref_data_ptr += get_offset_per_line();
    }
    while(--local_height);

    /* Release the mutex. */
    RelMutex(sc.ConsoleBufInfo.hMutex);

    /* Display the new image. */
    rect.Left = SCALE(screen_x);
    rect.Top = SCALE(screen_y);
    rect.Right = rect.Left + SCALE(width) - 1;
    rect.Bottom = rect.Top + SCALE(height) - 1;

    if( sc.ScreenBufHandle )
        if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
        //DisplayErrorTerm(EHS_FUNC_FAILED,GetLastError(),__FILE__,__LINE__);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: 256 colour mode: PC 640x400, 640x480, 720x540, 800x600. :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_v7vga_mono_hi_graph_std(int offset, int screen_x, int screen_y,
                                int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_v7vga_mono_hi_graph_std off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: 256 colour mode: PC 640x400, 640x480, 720x540, 800x600. :::::::::*/
/*:::::::: SoftPC 960x600, 960x720, 1080x810, 1200x900.            :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_v7vga_mono_hi_graph_big(int offset, int screen_x, int screen_y,
                                int width, int height )
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_v7vga_mono_hi_graph_big off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height );
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::: 256 colour mode: PC 640x400, 640x480, 720x540, 800x600. :::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_v7vga_mono_hi_graph_huge(int offset, int screen_x, int screen_y,
                                 int width, int height)
{
sub_note_trace5(EGA_HOST_VERBOSE,
    "nt_v7vga_mono_hi_graph_huge off=%d x=%d y=%d width=%d height=%d - NOT SUPPORTED\n",
    offset, screen_x, screen_y, width, height);
}
#endif /* V7VGA */

#ifdef MONITOR
/* There are 2 possible formats for the standard 256 colour VGA mode. One (VGA,
 * S3, Ultra etc) has shape 1/ below, the other (ET4000, WD) has a packed
 * format more like emulation /2.
 * The Miniport sets a flag to tell use which format to use.
 *
 *  1/  uses paint routine nt_vga_frozen_std
 *      Regen Memory:   XYABJKLM
 *      Plane 0: X...J...
 *      Plane 1: Y...K...
 *      Plane 2: A...L...
 *      Plane 3: B...M...
 *      (plus a 1 byte skip every 16k).
 *
 *  2/  uses paint routine nt_vga_frozen_pack_std
 *      Regen Memory:   XYABJKLM
 *      Plane 0: XJ..
 *      Plane 1: YK..
 *      Plane 2: AL..
 *      Plane 3: BM..
 *
 */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::: Frozen paint function (256 colour mode PC 320x200. SoftPC 640x400.):::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_frozen_std(int offset, int screen_x, int screen_y,
                       int width, int height)
{
    USHORT      *dest_ptr,
                *ref_dest_ptr;
    UTINY	*plane1_ptr,
		*plane2_ptr,
		*plane3_ptr,
		*plane4_ptr;
    ULONG        width_loc,
                 mem_loc,
		 shorts_per_scanline,
		 max_width = sc.PC_W_Width >> 1,
                 max_height = sc.PC_W_Height >> 1;

    SMALL_RECT	 rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                    "nt_vga_frozen_std off=%d x=%d y=%d width=%d height=%d\n",
                    offset, screen_x, screen_y, width, height );

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if (((ULONG)screen_x >= max_width) || ((ULONG) screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > (int)max_width)
        width = max_width - screen_x;
    if ((ULONG) (screen_y + height) > max_height)
        height = max_height - screen_y;

     rect.Left = screen_x << 1;
     rect.Top = screen_y << 1;
     rect.Right = rect.Left + (width << 1) - 1;
     rect.Bottom = rect.Top + (height << 1) - 1;




    /* memory involved here liable to be suddenly removed due to fs switch */
    try
    {
        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        /*
         * Build up the bitmap: each PC pixel is stored in video memory as one
         * byte (i.e. 8 bits-per-pixel); each PC pixel is translated to a square
         * block of 4 host pixels.
         */
        shorts_per_scanline = SHORTS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
        width >>= 2;
        ref_dest_ptr = (unsigned short *) sc.ConsoleBufInfo.lpBitMap +
                       (screen_y << 1) * shorts_per_scanline + screen_x;


        /* Set up the plane pointers. */
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);
        plane3_ptr = GET_OFFSET(Plane3Offset);
        plane4_ptr = GET_OFFSET(Plane4Offset);

        /* Build up the bitmap. */
        do
        {
            dest_ptr = ref_dest_ptr;
            ref_dest_ptr += shorts_per_scanline << 1;
            mem_loc = offset;
            offset += width;
            width_loc = width;

            do
            {
                ULONG PlaneOffset;
                USHORT Tmp;

                //
                // Doubleword addressing mode...
                //
                PlaneOffset = ((mem_loc & 0x3fff) << 2) +
                              ((mem_loc++ & 0x3000) >> 12);

                Tmp = *(plane1_ptr + PlaneOffset);
                *dest_ptr =
                *(dest_ptr + shorts_per_scanline) = (Tmp << 8) | Tmp;
                dest_ptr++;

                Tmp = *(plane2_ptr + PlaneOffset);
                *dest_ptr =
                *(dest_ptr + shorts_per_scanline) = (Tmp << 8) | Tmp;
                dest_ptr++;

                Tmp = *(plane3_ptr + PlaneOffset);
                *dest_ptr =
                *(dest_ptr + shorts_per_scanline) = (Tmp << 8) | Tmp;
                dest_ptr++;

                Tmp = *(plane4_ptr + PlaneOffset);
                *dest_ptr =
                *(dest_ptr + shorts_per_scanline) = (Tmp << 8) | Tmp;
                dest_ptr++;

            } while (--width_loc);

        } while(--height);


        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        /* Display the new image. */
        if( sc.ScreenBufHandle )
            if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                    assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
    } except(EXCEPTION_EXECUTE_HANDLER)
      {
          RelMutex(sc.ConsoleBufInfo.hMutex);
          assert0(NO, "Handled fault in nt_vga_frozen_std. fs switch?");
          return;
      }
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Frozen paint function (256 colour mode packed. PC 320x200 SoftPC 640x400.)*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
void nt_vga_frozen_pack_std(int offset, int screen_x, int screen_y,
                       int width, int height)
{
    USHORT	*dest_ptr,
		*ref_dest_ptr;
    UTINY	*plane1_ptr,
		*plane2_ptr,
		*plane3_ptr,
		*plane4_ptr;
    ULONG	 local_width,
		 local_height,
		 mem_loc,
		 temp,
		 bpl,
		 shorts_per_scanline,
		 max_width = sc.PC_W_Width >> 1,
		 max_height = sc.PC_W_Height >> 1;
    SMALL_RECT	 rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                 "nt_vga_frozen_pack_std off=%d x=%d y=%d width=%d height=%d\n",
                 offset, screen_x, screen_y, width, height );
    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if (((ULONG)screen_x >= max_width) || ((ULONG) screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > (int)max_width)
        width = max_width - screen_x;
    if ((ULONG) (screen_y + height) > max_height)
        height = max_height - screen_y;

    /* memory involved here liable to be suddenly removed due to fs switch */
    try
    {
        /*
         * Build up the bitmap: each PC pixel is stored in video memory as one
         * byte (i.e. 8 bits-per-pixel); each PC pixel is translated to a square
         * block of 4 host pixels.
         */
        bpl = get_bytes_per_line() >> 2;
        shorts_per_scanline = SHORTS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
        local_height = height;
        ref_dest_ptr = (unsigned short *) sc.ConsoleBufInfo.lpBitMap +
                       (screen_y << 1) * shorts_per_scanline + screen_x;

        /* Set up the plane pointers. */
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);
        plane3_ptr = GET_OFFSET(Plane3Offset);
        plane4_ptr = GET_OFFSET(Plane4Offset);

        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        /* Build up the bitmap. */
        do
        {
            dest_ptr = ref_dest_ptr;
	    mem_loc = offset;
	    local_width = width >> 2;

	    do
            {

	        temp = *(plane1_ptr + mem_loc);
                *(dest_ptr + shorts_per_scanline) = *dest_ptr =
                                         (unsigned short)((temp << 8) | temp);
                dest_ptr++;
	        temp = *(plane2_ptr + mem_loc);
                *(dest_ptr + shorts_per_scanline) = *dest_ptr =
                                         (unsigned short)((temp << 8) | temp);
                dest_ptr++;
	        temp = *(plane3_ptr + mem_loc);
                *(dest_ptr + shorts_per_scanline) = *dest_ptr =
                                         (unsigned short)((temp << 8) | temp);
                dest_ptr++;
	        temp = *(plane4_ptr + mem_loc);
                *(dest_ptr + shorts_per_scanline) = *dest_ptr =
                                         (unsigned short)((temp << 8) | temp);
                dest_ptr++;
	        mem_loc ++;
            }
	    while (--local_width);
            ref_dest_ptr += 2 * shorts_per_scanline;
	    offset += bpl;
        }
        while(--local_height);

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        /* Display the new image. */
        rect.Left = screen_x << 1;
        rect.Top = screen_y << 1;
        rect.Right = rect.Left + (width << 1) - 1;
        rect.Bottom = rect.Top + (height << 1) - 1;

        if( sc.ScreenBufHandle )
            if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                    assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
    } except(EXCEPTION_EXECUTE_HANDLER)
      {
          assert0(NO, "Handled fault in nt_vga_frozen_std. fs switch?");
          return;
      }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Frozen paint function (256 colour mode PC 320x200. SoftPC 640x400.)      */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_med_frozen_std(int offset, int screen_x, int screen_y,
                           int width, int height)
{
    ULONG	*dest_ptr,
		*ref_dest_ptr,
		 max_width = sc.PC_W_Width >> 3,
		 max_height = sc.PC_W_Height >> 1,
		 bpl,
		 local_height,
		 local_width,
		 longs_per_scanline,
		 mem_loc;
    UTINY	 data0,
		 data1,
		 data2,
		 data3,
		*plane1_ptr,
		*plane2_ptr,
		*plane3_ptr,
		*plane4_ptr;
    SMALL_RECT   rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_vga_med_frozen_std off=%d x=%d y=%d width=%d height=%d\n",
                   offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if (((ULONG)screen_x >= max_width) || ((ULONG) screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_med_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > (int)max_width)
        width = max_width - screen_x;
    if ((ULONG) (screen_y + height) > max_height)
        height = max_height - screen_y;

    /* local_height is number of lines in video memory. */
    local_height = height;

    /* memory involved here liable to be suddenly removed due to fs switch */
    try
    {
        /* Get pointer to video memory. */
        bpl = get_bytes_per_line();
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);
        plane3_ptr = GET_OFFSET(Plane3Offset);
        plane4_ptr = GET_OFFSET(Plane4Offset);

        /* Get pointer to bitmap. */
        longs_per_scanline = LONGS_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
        ref_dest_ptr = (ULONG *) sc.ConsoleBufInfo.lpBitMap +
                   (screen_y << 1) * longs_per_scanline + (screen_x << 1);

        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        /* Munge. */
        do
        {
            dest_ptr = ref_dest_ptr;
	    mem_loc = offset;
	    local_width = width;

            do
            {

                /*
                 * Get data and output to screen buffer. NOTE little endian
                 * dependent code.
                 */
                data0 = *(plane1_ptr + mem_loc);
                data1 = *(plane2_ptr + mem_loc);
                data2 = *(plane3_ptr + mem_loc);
                data3 = *(plane4_ptr + mem_loc);

                *(dest_ptr + longs_per_scanline) = *dest_ptr =
                    (data1 << 24) | (data1 << 16) | (data0 << 8) | data0;
                dest_ptr++;
                *(dest_ptr + longs_per_scanline) = *dest_ptr =
                    (data3 << 24) | (data3 << 16) | (data2 << 8) | data2;
                dest_ptr++;
	        mem_loc++;
            }
	    while (--local_width);

            ref_dest_ptr += 2 * longs_per_scanline;
	    offset += bpl;
        }
        while(--local_height);

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        /* Display the new image. */
        rect.Left = screen_x << 3;
        rect.Top = screen_y << 1;
        rect.Right = rect.Left + (width << 3) - 1;
        rect.Bottom = rect.Top + (height << 1) - 1;

        if( sc.ScreenBufHandle )
            if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
    } except(EXCEPTION_EXECUTE_HANDLER)
      {
          assert0(NO, "Handled fault in nt_vga_med_frozen_std. fs switch?");
          return;
      }
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/* Hi-res frozen paint func (256 colour mode PC 320x400. SoftPC 640x400.)   */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

void nt_vga_hi_frozen_std(int offset, int screen_x, int screen_y,
                          int width, int height)
{
    UTINY	*dest_ptr,
		*ref_dest_ptr,
		*plane1_ptr,
		*plane2_ptr,
		*plane3_ptr,
		*plane4_ptr;
    ULONG	 local_height,
		 local_width,
		 mem_loc,
		 bytes_per_scanline,
		 bpl,
		 max_width = sc.PC_W_Width >> 3,
		 max_height = sc.PC_W_Height;
    SMALL_RECT	 rect;

    sub_note_trace5(EGA_HOST_VERBOSE,
                   "nt_vga_hi_frozen_std off=%d x=%d y=%d width=%d height=%d\n",
                   offset, screen_x, screen_y, width, height);

    /*
    ** Tim September 92, bounce call if handle to screen buffer is null.
    ** This can happen when VDM session is about to suspend, buffer has
    ** been closed, but still get a paint request.
    */
    if( sc.ScreenBufHandle == (HANDLE)NULL ){
        assert0( NO, "VDM: rejected paint request due to NULL handle" );
        return;
    }

    /* If the image is completely outside the display area do nothing. */
    if (((ULONG)screen_x >= max_width) || ((ULONG) screen_y >= max_height))
    {
        sub_note_trace2(EGA_HOST_VERBOSE,
                        "VDM: nt_vga_hi_frozen_std() x=%d y=%d",
                        screen_x, screen_y);
        return;
    }

    /*
     * If image partially overlaps display area clip it so we don't start
     * overwriting invalid pieces of memory.
     */
    if (screen_x + width > (int)max_width)
        width = max_width - screen_x;
    if ((ULONG) (screen_y + height) > max_height)
        height = max_height - screen_y;

    /* memory involved here liable to be suddenly removed due to fs switch */
    try
    {
        /* local_height is number of lines in video memory. */
        local_height = height;

        /* Get pointer to bitmap. */
        bpl = get_bytes_per_line();
        bytes_per_scanline = BYTES_PER_SCANLINE(sc.ConsoleBufInfo.lpBitMapInfo);
        ref_dest_ptr = (UTINY *) sc.ConsoleBufInfo.lpBitMap +
                       screen_y * bytes_per_scanline + (screen_x << 3);

        /* Set up the plane pointers. */
        plane1_ptr = GET_OFFSET(Plane1Offset);
        plane2_ptr = GET_OFFSET(Plane2Offset);
        plane3_ptr = GET_OFFSET(Plane3Offset);
        plane4_ptr = GET_OFFSET(Plane4Offset);

        /* Grab the mutex. */
        GrabMutex(sc.ConsoleBufInfo.hMutex);

        /* Build up the bitmap. */
        do
        {
            dest_ptr = ref_dest_ptr;
	    mem_loc = offset;
	    local_width = width;

	    do
            {
                *(dest_ptr + 1) = *dest_ptr = *(plane1_ptr + mem_loc);
                dest_ptr += 2;
                *(dest_ptr + 1) = *dest_ptr = *(plane2_ptr + mem_loc);
                dest_ptr += 2;
                *(dest_ptr + 1) = *dest_ptr = *(plane3_ptr + mem_loc);
                dest_ptr += 2;
                *(dest_ptr + 1) = *dest_ptr = *(plane4_ptr + mem_loc);
                dest_ptr += 2;
	        mem_loc++;
            }
	    while (--local_width);
            ref_dest_ptr += bytes_per_scanline;
	    offset += bpl;
        }
        while(--local_height);

        /* Release the mutex. */
        RelMutex(sc.ConsoleBufInfo.hMutex);

        /* Display the new image. */
        rect.Left = (screen_x << 3);
        rect.Top = (SHORT)screen_y;
        rect.Right = rect.Left + (width << 3) - 1;
        rect.Bottom = rect.Top + height - 1;

        if( sc.ScreenBufHandle )
            if (!InvalidateConsoleDIBits(sc.ScreenBufHandle, &rect))
                assert1( NO, "VDM: InvalidateConsoleDIBits() error:%#x",
                         GetLastError() );
    } except(EXCEPTION_EXECUTE_HANDLER)
      {
          assert0(NO, "Handled fault in nt_vga_hi_frozen_std. fs switch?");
          return;
      }
}
#endif /* MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_yoda.c ===
#include "insignia.h"
#include "host_def.h"



/*                      INSIGNIA MODULE SPECIFICATION
                        -----------------------------

MODULE NAME     : nt_yoda
FILE NAME       : nt_yoda.c

        THIS  PROGRAM SOURCE FILE IS SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF ITS OPERATION MUST
        NOT  BE DISCLOSED TO ANY  OTHER  PARTIES  WITHOUT  EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DESIGNER        : Wayne Plummer
DATE            : 21st July 1989

PURPOSE         : Provides host specific extensions to YODA


The Following External Routines are defined:
                1. host_force_yoda_extensions
                2. host_yoda_check_I_extensions
                3. host_yoda_help_extensions


=========================================================================

AMMENDMENTS     :

        Version         Date            Author          Reason

=========================================================================
*/

#ifdef YODA

/******INCLUDES**********/
#include <stdio.h>
#include "xt.h"
#include CpuH
#include "hunter.h"
#include "nt_getXX.h"

/******DEFINES***********/
#define EXPORT

/* Get the size of a table. */
#define sizeoftable(tab)	(sizeof(tab)/sizeof(tab[0]))

/* Different types of CALL instruction. */
#define CT_IMM	0
#define CT_EA	1
#define CT_REG	2

/* Mod-rm table flags. */
#define MR_BX	0x01
#define MR_BP	0x02
#define MR_SI	0x04
#define MR_DI	0x08
#define MR_D8	0x10
#define MR_D16	0x20

/* Segment defines, correspond to entries in get_seg table. */
#define NO_OVERRIDE	(-1)
#define SEG_ES		(0)
#define SEG_CS		(1)
#define SEG_SS		(2)
#define SEG_DS		(3)

/* Maximum size of the call stack. */
#define MAX_CALL_STACK	128

/******TYPEDEFS**********/

/* Effective address call type additional data. */
typedef	struct
{
    word	seg;		/* The segment of the effective address. */
    word	off;		/* The offset of the effective address. */
    sys_addr	addr;		/* 20-bit effective address. */
    IS8		seg_override;	/* Segment override if any. */
    IBOOL	disp_present;	/* Is there a displacement present? */
    word	disp;		/* The value of the displacement.*/
    IU8		modrm_index;	/* Index into mod-rm look-up tables. */
} CALL_EA_DATA;

/* Register call type additional data. */
typedef IU8 CALL_REG_DATA;      /* Index into register look-up tables. */

/* Data structure which holds call stack entries. */
typedef struct
{
    IU8		type;		/* CALL instruction type one of
					CT_IMM - immediate
					CT_EA  - effective address in mod-rm
					CT_REG - register in mod-rm. */
    word	cs;		/* Code segment of call instruction. */
    word	ip;		/* Instruction pointer of call instruction. */
    sys_addr	inst_addr;	/* 20-bit address of call instruction. */
    IU8		nbytes;		/* Length of op-code. */
    IU8		opcode[5];	/* Op-code bytes. */
    IBOOL	cfar;		/* Is it a far CALL? */
    word	seg;		/* Target segment for CALL. */
    word	off;		/* Target offset for CALL. */
    word	ss;		/* Stack segment when call is executed. */
    word	sp;		/* Stack offset when call is executed. */
    union
    {
	CALL_EA_DATA	ea;	/* EA call specific data. */
	CALL_REG_DATA	regind;	/* Register call specific data. */
    } extra;
} CALL_STACK_ENTRY;

/******IMPORTS***********/
extern struct HOST_COM host_com[];
extern struct HOST_LPT host_lpt[];
extern char *nt_fgets(char *buffer, int len, void *input_stream);
extern char *nt_gets(char *buffer);
extern int vader;

/******LOCAL FUNCTIONS********/
LOCAL int do_ecbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len);
LOCAL int do_dcbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len);
LOCAL int do_pcbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len);
LOCAL void check_stack	IPT2(word, ss, word, sp);
LOCAL int check_for_overflow	IPT0();
LOCAL void get_ea_from_modrm	IPT4(CALL_STACK_ENTRY *, cs_ptr,
				     IU8, mod,
				     IU8, rm,
				     sys_addr, op_addr);
LOCAL IS8 do_prefixes	IPT1(sys_addr *, opcode_ptr);
LOCAL int do_ntsd	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len);

/******LOCAL VARS********/

/* Table of host yoda commands. */
LOCAL struct                                                                   
{                                                                               
	char *name;
	int (*function)	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len);
	char *comment;
} host_yoda_command[] =
{
{ "ecbt", do_ecbt,	"                        - enable call-back-tracing" },
{ "dcbt", do_dcbt,	"                        - disable call-back-tracing" },
{ "pcbt", do_pcbt,	"                        - print call-back-trace" },
{ "ntsd", do_ntsd,	"                        - break to ntsd" }
};

/* Variable to enable call-back-tracing. */
LOCAL IBOOL call_back_tracing_enabled = FALSE;

/* Mod-rm byte effective address look-up table. */
LOCAL IU8 EA_table[] =
{
    MR_BX | MR_SI,
    MR_BX | MR_DI,
    MR_BP | MR_SI,
    MR_BP | MR_DI,
    MR_SI,
    MR_DI,
    MR_D16,
    MR_BX,
    MR_BX | MR_SI | MR_D8,
    MR_BX | MR_DI | MR_D8,
    MR_BP | MR_SI | MR_D8,
    MR_BP | MR_DI | MR_D8,
    MR_SI | MR_D8,
    MR_DI | MR_D8,
    MR_BP | MR_D8,
    MR_BX | MR_D8,
    MR_BX | MR_SI | MR_D16,
    MR_BX | MR_DI | MR_D16,
    MR_BP | MR_SI | MR_D16,
    MR_BP | MR_DI | MR_D16,
    MR_SI | MR_D16,
    MR_DI | MR_D16,
    MR_BP | MR_D16,
    MR_BX | MR_D16
};

/* Mod-rm byte string look-up table. */
LOCAL CHAR *EA_strings[] =
{
    "[BX + SI]",
    "[BX + DI]",
    "[BP + SI]",
    "[BP + DI]",
    "[SI]",
    "[DI]",
    "[%hX]",
    "[BX]",
    "[BX + SI + %hX]",
    "[BX + DI + %hX]",
    "[BP + SI + %hX]",
    "[BP + DI + %hX]",
    "[SI + %hX]",
    "[DI + %hX]",
    "[BP + %hX]",
    "[BX + %hX]",
    "[BX + SI + %hX]",
    "[BX + DI + %hX]",
    "[BP + SI + %hX]",
    "[BP + DI + %hX]",
    "[SI + %hX]",
    "[DI + %hX]",
    "[BP + %hX]",
    "[BX + %hX]"
};

/* Table of functions corresponding to register rm fields. */
LOCAL word (*EA_reg_func[])() =
{
    getAX,
    getCX,
    getDX,
    getBX,
    getSP,
    getBP,
    getSI,
    getDI
};

/* Table of names of register rm fields. */
LOCAL CHAR *EA_reg_strings[] =
{
    "AX",
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI"
};

/* Table of functions for getting segment values. */
LOCAL word (*get_seg[])() =
{
    getES,
    getCS,
    getSS,
    getDS
};

/* Table of segment names. */
LOCAL CHAR *seg_strings[] =
{
    "ES",
    "CS",
    "SS",
    "DS"
};

LOCAL CALL_STACK_ENTRY call_stack[MAX_CALL_STACK];
LOCAL CALL_STACK_ENTRY *call_next_free = call_stack;

/******EXPORT VARS*******/

#ifndef PROD
#ifdef HUNTER
/*============================================================

Function :   trap_command.

Purpose  :   Writes the current trapper prompt and gets the
             menu input.

input    :   a pointer to a string for the current trapper prompt
         :   a pointer to a character to hold the user input.

returns  :   nothing.

=============================================================*/

void trap_command(char *str,char *ch)
{
char inp[80];

printf("%s> ",str);
nt_fgets(inp,80,stdin);
sscanf(inp,"%c",ch);
}
#endif /* HUNTER */

/*
=========================================================================

FUNCTION        : host_force_yoda_extensions

PURPOSE         : this function is called whenever the main code of
                  YODA in the base fails to recognise an instruction
                  in order for host-specific commands to be implemented.

RETURNED STATUS :

NOTES           : on the SG port no extensions are provided.

=======================================================================
*/

GLOBAL int host_force_yoda_extensions(char *com, long cs, long ip, long len, 
					char *str)
{
#ifdef HUNTER
int  quit_menus=FALSE;   /* some functions need to return to yoda prompt*/
char c;
char menu[] = "\tTrapper [m]ain menu\n"
              "\tTrapper [e]rror menu\n"
              "\t[Q]uit\n"
              "\t? for this menu\n\n";
#endif /* HUNTER */
    int	i,
	retvalue;

#ifdef HUNTER
/* to get to this menu, the user has to type "trap" at the Yoda prompt */

if(!strcmp(com,"trap")) /* test the input string */
   {
   printf("\nYODA EXTENSIONS\n\n");
   printf("%s",menu);
   do
      {
      trap_command("trapper",&c);
      switch(c)
         {
         case 'm':
         case 'M':
            quit_menus = host_do_trapper_main_menu();
         break;

         case 'e':
         case 'E':
            quit_menus = host_do_trapper_error_menu();
         break;

         case '?':
            printf("%s",menu);
         break;

         default:
         break;
         }
      }
   while(c != 'q' && c != 'Q' && quit_menus == FALSE );

   }
else
   {
   /* unpleasing input, so return 1 and back to main Yoda stuff */
   return(1);
   }
return(0);
#endif /* HUNTER */

    /* Check to see if we have got a command in host_yoda_command. */
    retvalue = 1;
    for (i = 0; i < sizeoftable(host_yoda_command); i++)
    {
	if (strcmp(com, host_yoda_command[i].name) == 0)
	{
	    retvalue = (*host_yoda_command[i].function)(str, com, cs, ip, len);
	    break;
	}
    }
    return(retvalue);
}

#ifdef HUNTER
/*============================================================

Function :   host_do_trapper_main_menu

Purpose  :   implements the main trapper menu under Yoda.


=============================================================*/

static int host_do_trapper_main_menu()
{
int    i,quit_menus = FALSE;
char   c,str[80],yesno;
USHORT screen_no;
BOOL   compare;

char menu[] = "\t[F]ast forward...\n"
              "\t[N]ext screen\n"
              "\t[P]rev screen\n"
              "\t[S]how screen...\n"
              "\t[C]ontinue\n"
              "\t[A]bort\n"
              "\t[Q]uit\n"
              "\t? for this menu\n\n";



char continu[] = "\n\ntype 'c' at yoda prompt to continue...\n\n";


printf("\nTRAPPER MAIN MENU\n\n");
printf("%s",menu);

do
   {
   trap_command("main",&c);
   switch(c)
      {
      case 'f': /* fast forward */
      case 'F':
         {
         printf("\n\nEnter the screen number where comparisons will start: ");
         nt_fgets(str,80,stdin);
         sscanf(str,"%d",&screen_no);
         printf("\n\nSkipping screen comparisons up to screen %d\n\n",screen_no);
         bh_start_screen(screen_no);
         }
      break;

      case 'n': /* next screen */
      case 'N':
         {
         bh_next_screen();
         printf("%s",continu);
         quit_menus = TRUE;
         }
      break;

      case 'p': /* previous screen */
      case 'P':
         {
         bh_prev_screen();
         printf("%s",continu);
         quit_menus = TRUE;
         }
      break;

      case 's': /* show screen */
      case 'S':
         {
         printf("\n\nEnter the number of the screen which you want to see: ");
         nt_fgets(str,80,stdin);
         sscanf(str,"%d",&screen_no);
         printf("\n\nDo you want to compare screen %d with one from"
                "SoftPC? (y/n): ",screen_no);
         nt_fgets(str,80,stdin);
         sscanf(str,"%c",&yesno);
         if(yesno == 'y' || yesno == 'Y')
            compare = TRUE;
         else
            compare = FALSE;

         bh_show_screen(screen_no,compare);
         }
      break;

      case 'c': /* continue */
      case 'C':
         {
         bh_continue();
         printf("%s",continu);
         quit_menus = TRUE;
         }
      break;

      case 'a': /* abort */
      case 'A':
         bh_abort();
      break;

      case '?':
         printf("%s",menu);
      break;

      default:
      break;
      }
   }
while(c != 'q' && c != 'Q' && quit_menus == FALSE);
return(quit_menus); /* match found */
}

/*============================================================

Function :   host_do_trapper_error_menu

Purpose  :   implements the trapper error menu under Yoda.

returns  :   TRUE if the user has selected a trapper function
             which requires softpc to be restarted.
             FALSE otherwise.

=============================================================*/

static int host_do_trapper_error_menu()
{
int  i,quit_menus=FALSE;
char c;
char menu[] = "\t[F]lip screen\n"
              "\t[N]ext error\n"
              "\t[P]rev error\n"
              "\t[A]ll errors\n"
              "\t[C]lear errors\n"
              "\t[Q]uit menu\n"
              "\t? for this menu\n\n";


printf("\nTRAPPER ERROR MENU\n\n");
printf("%s",menu);

do
   {
   trap_command("error",&c);
   switch(c)
      {
      case 'f':
      case 'F':
         bh_flip_screen();
         printf("\n\ntype 'c' at yoda prompt to continue...\n\n");
         quit_menus = TRUE;
      break;

      case 'n':
      case 'N':
         bh_next_error();
      break;

      case 'p':
      case 'P':
         bh_prev_error();
      break;

      case 'a':
      case 'A':
         bh_all_errors();
      break;

      case 'c':
      case 'C':
         bh_wipe_errors();
      break;

      case '?':
         printf("%s",menu);
      break;

      default:
      break;
      }
   }
while(c != 'q' && c != 'Q' && quit_menus == FALSE);

if(quit_menus == TRUE)
   return(TRUE); /* need to go to the yoda prompt */
else
   return(FALSE);  /* don't need to go to the yoda prompt */
}
#endif /* HUNTER */

/*
=========================================================================

FUNCTION        : host_yoda_check_I_extensions

PURPOSE         : this function is called by the YODA check_I code
                  in order to provide host specific extensions.

RETURNED STATUS :

NOTES           : on the SG port no extensions are provided.

=======================================================================
*/

GLOBAL void host_yoda_check_I_extensions()
{
    sys_addr addr;
    word cs,
	 ip,
	 ss,
	 sp;
    IS8 seg_override;
    IU8 opcode,
	modrm,
	mod,
	n_field,
	rm,
	i;

    /* Check to see if call-back-tracing is enabled. */
    if (call_back_tracing_enabled)
    {

	/* Check to see if call on top of stack has been popped. */
	ss = getSS();
	sp = getSP();
	check_stack(ss, sp);

	/* Get current op-code. */
	cs = getCS();
	ip = getIP();
	addr = effective_addr(cs, ip);
	seg_override = do_prefixes(&addr);
	opcode = sas_hw_at_no_check(addr);

	/* Check to see if we have a call-back-trace op-code. */
	switch (opcode)
	{
	case 0x9a:

	    /* 9a =  CALLF immediate */

	    /* Check there is room for another entry in call_stack. */
	    if (check_for_overflow() == -1)
		return;

	    /* Fill the stack entry. */
	    call_next_free->type = CT_IMM;
	    call_next_free->cs = cs;
	    call_next_free->ip = ip;
	    call_next_free->inst_addr = addr;
	    call_next_free->nbytes = 5;
	    call_next_free->cfar = TRUE;
	    call_next_free->seg = sas_w_at_no_check(addr + 3);
	    call_next_free->off = sas_w_at_no_check(addr + 1);

	    /* Save state of stack. */
	    call_next_free->ss = ss;
	    call_next_free->sp = sp;

	    /* Store instruction bytes. */
	    for (i = 0; i < 5; i++)
		call_next_free->opcode[i] = sas_hw_at_no_check(addr++);

	    /* Increment top of stack. */
	    call_next_free++;
	    break;
	case 0xe8:

	    /* e8 = CALL immediate */

	    /* Check there is room for another entry in call_stack. */
	    if (check_for_overflow() == -1)
		return;

	    /* Fill the stack entry. */
	    call_next_free->type = CT_IMM;
	    call_next_free->cs = cs;
	    call_next_free->ip = ip;
	    call_next_free->inst_addr = addr;
	    call_next_free->nbytes = 3;
	    call_next_free->cfar = FALSE;
	    call_next_free->off = ip + (word) 3 + sas_w_at_no_check(addr + 1);

	    /* Save state of stack. */
	    call_next_free->ss = ss;
	    call_next_free->sp = sp;

	    /* Store instruction bytes. */
	    for (i = 0; i < 3; i++)
		call_next_free->opcode[i] = sas_hw_at_no_check(addr++);

	    /* Increment top of stack. */
	    call_next_free++;
	    break;
	case 0xff:

	    /*
	     * ff /2 = CALL
	     * ff /3 = CALLF
	     */
	    modrm = sas_hw_at_no_check(addr + 1);
	    n_field = (modrm & 0x38) >> 3;
	    if ((n_field == 2) || (n_field == 3))
	    {

		/* Check there is room for another entry in call_stack. */
		if (check_for_overflow() == -1)
		    return;

		/* Save CS:IP of call instruction. */
		call_next_free->cs = cs;
		call_next_free->ip = ip;

		/* Store opcode address and initialise byte count. */
		call_next_free->inst_addr = addr;
		call_next_free->nbytes = 2;
		
		/* n-field: 2 = near, 3 = far. */
		call_next_free->cfar = n_field & 1;

		/* If mod is 3 we have a register rm otherwise it is EA. */
		mod = (modrm & 0xc0) >> 6;
		rm = modrm & 7;
		if (mod == 3)
		{
		    if (call_next_free->cfar)
		    {

			/* Can't have a far pointer in a register. */
			printf("Invalid mod-rm byte after ff op-code.\n");
			vader = 1;
			return;
		    }
		    else
		    {

			/* Near pointer contained in register. */
			call_next_free->type = CT_REG;
			call_next_free->off =
			    sas_w_at_no_check((*EA_reg_func[rm])());
			call_next_free->extra.regind = rm;

			/* Save state of stack. */
			call_next_free->ss = ss;
			call_next_free->sp = sp;
		    }
		}
		else
		{

		    /* We have an EA type CALL. */
		    call_next_free->type = CT_EA;
		    call_next_free->extra.ea.seg_override = seg_override;

		    /* Adjust address and count for segment override. */
		    if (seg_override != NO_OVERRIDE)
		    {
			call_next_free->inst_addr--;
			call_next_free->nbytes++;
		    }

		    /* Work out EA from mod-rm. */
		    get_ea_from_modrm(call_next_free, mod, rm, addr + 2);

		    /* Get target segment and offset from EA. */
		    if (call_next_free->cfar)
		    {
			call_next_free->seg =
			    sas_w_at_no_check(call_next_free->extra.ea.addr+2);

			/* Save state of stack. */
			call_next_free->ss = ss;
			call_next_free->sp = sp;
		    }
		    else
		    {

			/* Save state of stack. */
			call_next_free->ss = ss;
			call_next_free->sp = sp;
		    }
		    call_next_free->off =
			sas_w_at_no_check(call_next_free->extra.ea.addr);
		}

		/* Fill in the op-code bytes. */
		for (i = 0, addr = call_next_free->inst_addr;
		     i < call_next_free->nbytes;
		     i++, addr++)
		{
		    call_next_free->opcode[i] = sas_hw_at_no_check(addr);
		}

		/* Increment top of stack. */
		call_next_free++;
	    }
	    break;
	default:

	    /* Not a call-back-trace opcode so do nothing. */
	    break;
	}
    }
}

/*
=========================================================================

FUNCTION        : check_stack

PURPOSE         : Checks to see if the call on the top of the stack has
		  been popped and if so removes it from the top of the
		  call stack.

RETURNED STATUS : void

NOTES           : Originally the call stack was popped on RET instructions
		  but this did not work when apps did things like POP
		  followed by JMP. It was therefore decided to check whether
		  the stack had shrunk past the point where a call's return
		  address was stored to see if that call had returned.

=======================================================================
*/
LOCAL void check_stack IFN2(word, ss, word, sp)
{
    IU32 count = 0;

    /*
     * Pop the call stack until we have a call whose return address is still
     * on the real stack.
     */
    while ((call_next_free > call_stack) &&
	   (ss == (call_next_free - 1)->ss) &&
	   (sp >= (call_next_free - 1)->sp))
    {
	call_next_free--;
	count++;
    }

    /* Complain if more than one call gets popped. */
    if (count > 1)
	printf("Call stack warning - %d calls popped at %04x:%04x\n",
	       count, getCS(), getIP());
}

/*
=========================================================================

FUNCTION        : do_prefixes

PURPOSE         : Skips over all prefix op-codes.

RETURNED STATUS : Segment override if any.

NOTES           :

=======================================================================
*/
LOCAL IS8 do_prefixes IFN1(sys_addr *, opcode_ptr)
{
    half_word opcode;
    IS8 seg_override = NO_OVERRIDE;

    /* Skip over prefix opcodes. */
    opcode = sas_hw_at_no_check(*opcode_ptr);
    while ((opcode == 0xf2) || (opcode == 0xf3) ||
	   (opcode == 0x26) || (opcode == 0x2e) ||
	   (opcode == 0x36) || (opcode == 0x3e))
    {
	switch (opcode)
	{
	case 0x26:
	    seg_override = SEG_ES;
	    break;
	case 0x2e:
	    seg_override = SEG_CS;
	    break;
	case 0x36:
	    seg_override = SEG_SS;
	    break;
	case 0x3e:
	    seg_override = SEG_DS;
	    break;
	default:

	    /* Not sure what f2 and f3 do so do this for the time being. */
	    seg_override = NO_OVERRIDE;
	    break;
	}
	opcode = sas_hw_at_no_check(++(*opcode_ptr));
    }

    /* (*opcode_ptr) now points at the opcode. */
    return(seg_override);
}

/*
=========================================================================

FUNCTION        : check_for_overflow

PURPOSE         : Checks to see if the stack has overflowed.

RETURNED STATUS : -1 on failure, 0 on success.

NOTES           :

=======================================================================
*/
LOCAL int check_for_overflow IFN0()
{
    if (call_next_free - call_stack >= MAX_CALL_STACK)
    {
	printf("Call stack overflow.\n");
	vader = 1;
	return(-1);
    }
    return(0);
}

/*
=========================================================================

FUNCTION        : get_ea_from_modrm

PURPOSE         : Takes a mod-rm byte and works out the effective
		  address and the target segment and offset.

RETURNED STATUS : void

NOTES           :

=======================================================================
*/
LOCAL void get_ea_from_modrm IFN4(CALL_STACK_ENTRY *,	cs_ptr,
				  IU8,			mod,
				  IU8,			rm,
				  sys_addr,		disp_addr)
{
    IS16 offset = 0,
	 disp;
    IS8 seg,
	seg_override = cs_ptr->extra.ea.seg_override;
    IU8	flags;

    /* Get index to table from mod-rm byte. */
    cs_ptr->extra.ea.modrm_index = (mod << 3) | rm;
    flags = EA_table[cs_ptr->extra.ea.modrm_index];

    /* Use segment override if there is one otherwise default to DS. */
    seg = (seg_override == NO_OVERRIDE) ? SEG_DS : seg_override;

    /* Add base register value if any. */
    if (flags & MR_BX)
	offset += getBX();
    else if (flags & MR_BP)
    {
	offset += getBP();
	if (seg_override == NO_OVERRIDE)
	    seg = SEG_SS;
    }

    /* Add index register value if any. */
    if (flags & MR_SI)
	offset += getSI();
    else if (flags & MR_DI)
	offset += getDI();

    /* Add displacement if any. */
    if (flags & MR_D16)
    {
	cs_ptr->nbytes += 2;
	cs_ptr->extra.ea.disp_present = TRUE;
	cs_ptr->extra.ea.disp = (IS16) sas_w_at_no_check(disp_addr);
	offset += cs_ptr->extra.ea.disp;
    }
    else if (flags & MR_D8)
    {
	cs_ptr->nbytes++;
	cs_ptr->extra.ea.disp_present = TRUE;
	cs_ptr->extra.ea.disp = (IS16) ((IS8) sas_hw_at_no_check(disp_addr));
	offset += cs_ptr->extra.ea.disp;
    }
    else
	cs_ptr->extra.ea.disp_present = FALSE;

    /* Store segment and offset of return address. */
    cs_ptr->extra.ea.seg = (*get_seg[seg])();
    cs_ptr->extra.ea.off = (word) offset;
    cs_ptr->extra.ea.addr = effective_addr(cs_ptr->extra.ea.seg,
					   cs_ptr->extra.ea.off);
}

/*
=========================================================================

FUNCTION        : host_yoda_help_extensions

PURPOSE         : this function is called whenever the user asks for
                  YODA help to describe the host specific extensions provided
                  above.

RETURNED STATUS :

NOTES           : on the SG port no extensions are provided.

=======================================================================
*/

GLOBAL int host_yoda_help_extensions()
{
    int i;

    /* Print out the command and comment fields of host_yoda_command. */
    for(i = 0; i < sizeoftable(host_yoda_command); i++)
    {
	if (host_yoda_command[i].comment == NULL)
	    continue;
	printf("%14s %s\n",
	       host_yoda_command[i].name,
	       host_yoda_command[i].comment);
    }
}

/*
=========================================================================

FUNCTION        : do_ecbt

PURPOSE         : this function enables call-back-tracing.

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_ecbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{

    /* Enable call-back-tracing if it is currently disabled. */
    if (!call_back_tracing_enabled)
    {
	printf("Call back tracing enabled.\n");
	call_back_tracing_enabled = TRUE;
    }
    return(0);
}

/*
=========================================================================

FUNCTION        : do_dcbt

PURPOSE         : this function disables call-back-tracing.

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_dcbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{

    /* Disable call-back-tracing if it is currently enabled. */
    if (call_back_tracing_enabled)
    {

	/* Disable tracing. */
	printf("Call back tracing disabled.\n");
	call_back_tracing_enabled = FALSE;

	/* Reset the stack. */
	call_next_free = call_stack;
    }
    return(0);
}

/*
=========================================================================

FUNCTION        : do_pcbt

PURPOSE         : this function prints the call-back-trace stack.

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_pcbt	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{
    IU8 *opcode,
	 i;
    CALL_STACK_ENTRY *cs_ptr;

    /* Print out the current call-back-trace stack. */
    for (cs_ptr = call_stack; cs_ptr < call_next_free; cs_ptr++)
    {

	/* Print address and op-code. */
	printf("%04X:%04X", cs_ptr->cs, cs_ptr->ip);
	opcode = cs_ptr->opcode;
	for (i = 0; i < cs_ptr->nbytes; i++)
	    printf(" %02X", *opcode++);

	/* Print mnemonic. */
	printf("\tCALL");
	if (cs_ptr->cfar)
	    printf("F");
	printf("\t");

	/* Print parameters. */
	switch (cs_ptr->type)
	{
	case CT_IMM:

	    /* Immediate. */
	    if (cs_ptr->cfar)
		printf("%04X:", cs_ptr->seg);
	    printf("%04X", cs_ptr->off);
	    break;
	case CT_EA:

	    /* Effective address. */
	    if (cs_ptr->cfar)
		printf("d");
	    printf("word ptr ");

	    /* Print override if there is one. */
	    if (cs_ptr->extra.ea.seg_override != NO_OVERRIDE)
		printf("%s:", seg_strings[cs_ptr->extra.ea.seg_override]);

	    /* Print parameters. */
	    if (cs_ptr->extra.ea.disp_present)
		printf(EA_strings[cs_ptr->extra.ea.modrm_index],
		       cs_ptr->extra.ea.disp);
	    else
		printf(EA_strings[cs_ptr->extra.ea.modrm_index]);

	    /* Print effective address. */
	    printf("\t(%04X:%04X\t",
		   cs_ptr->extra.ea.seg,
		   cs_ptr->extra.ea.off);

	    /* Print contents of effective address. */
	    if (cs_ptr->cfar)
		printf("%04X:", cs_ptr->seg);
	    printf("%04X)", cs_ptr->off);
	    break;
	case CT_REG:

	    /* Print parameter and target address. */
	    printf(EA_reg_strings[cs_ptr->extra.regind]);
	    printf("\t(%04X)", cs_ptr->off);
	    break;
	default:
	    break;
	}
	printf("\n");
    }

    /* Return success. */
    return(0);
}

GLOBAL CHAR   *host_get_287_reg_as_string IFN1(int, reg_no)
{
     double reg;
     SAVED char regstr[30];
#ifdef CPU_40_STYLE
     strcpy(regstr, "STUBBED get_287_reg");
#else
     IMPORT double get_287_reg_as_double(int);

     reg = get_287_reg_as_double(reg_no);
     sprintf(regstr, "%g", reg);
#endif /* CPU_40_STYLE */
     return(&regstr[0]);
}

/*
=========================================================================

FUNCTION        : do_ntsd

PURPOSE         : this function forces a break back to ntsd

RETURNED STATUS : 0 for success, 1 for failure

NOTES           :

=======================================================================
*/
LOCAL int do_ntsd	IPT5(char *, str, char *, com, long, cs,
			     long, ip, long, len)
{
    UNUSED(str);
    UNUSED(com);
    UNUSED(cs);
    UNUSED(ip);
    UNUSED(len);
    DebugBreak();
    return(0);
}

#endif /* ndef PROD */

#endif /* YODA */

/* This stub exported as called from main() */
void    host_set_yoda_ints()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\nt_wcom.c ===
#include <windows.h>
#include <conapi.h>
#include "ptypes32.h"
#include "insignia.h"
#include "host_def.h"

/*
 *	Author : D.A.Bartlett
 *	Purpose:
 *
 *
 *	    Handle UART I/O's under windows
 *
 *
 *
 */

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include "xt.h"
#include "rs232.h"
#include "error.h"
#include "config.h"
#include "host_com.h"
#include "host_trc.h"
#include "host_rrr.h"
#include "debug.h"
#include "idetect.h"
#include "nt_com.h"
#include "nt_graph.h"
#include "nt_uis.h"

#include <stdlib.h>
#include <string.h>
#include <stdio.h>


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Global Data */
GCHfn GetCommHandle;
GCSfn GetCommShadowMSR;


/*::::::::::::::::::::::::::::::::::::::::::::: Internal function protocols */

#ifndef NEC_98
#ifndef PROD
void DisplayPortAccessError(int PortOffset, BOOL ReadAccess, BOOL PortOpen);
#endif

BOOL SetupBaudRate(HANDLE FileHandle, DIVISOR_LATCH divisor_latch);
BOOL SetupLCRData(HANDLE FileHandle, LINE_CONTROL_REG LCR_reg);
#endif // NEC_98
BOOL SyncLineSettings(HANDLE FileHandle, DCB *pdcb,
		      DIVISOR_LATCH *divisor_latch,
		      LINE_CONTROL_REG *LCR_reg);

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: IMPORTS */


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: UART state */

#if defined(NEC_98)         
static struct ADAPTER_STATE
{
        BUFFER_REG      tx_buffer;
        BUFFER_REG      rx_buffer;
        DIVISOR_LATCH   divisor_latch;
        COMMAND8251     command_write_reg;
        MODE8251        mode_set_reg;
        MASK8251        int_mask_reg;
        STATUS8251      read_status_reg;
        SIGNAL8251      read_signal_reg;
        TIMER_MODE      timer_mode_set_reg;

} adapter_state[3];
#else  // NEC_98
static struct ADAPTER_STATE
{
	DIVISOR_LATCH divisor_latch;
        INT_ENABLE_REG int_enable_reg;
        INT_ID_REG int_id_reg;
        LINE_CONTROL_REG line_control_reg;
        MODEM_CONTROL_REG modem_control_reg;
        LINE_STATUS_REG line_status_reg;
        MODEM_STATUS_REG modem_status_reg;
        half_word scratch;      /* scratch register */

} adapter_state[NUM_SERIAL_PORTS];
#endif // NEC_98

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: WOW inb function */

#if defined(NEC_98)         
void wow_com_inb(io_addr port, half_word *value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    HANDLE FileH;
    half_word newMSR; //ADD 93.10.14

    /*........................................... Communications port open ? */

   if (GetCommHandle == NULL) {
        com_inb(port,value);
        return;
    }

   FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);

    /*.................................................... Process port read */

    switch(port)
    {
        //Process read to RX register
        case RS232_CH1_TX_RX:   // CH.1 DATA READ
        case RS232_CH2_TX_RX:   // CH.2 DATA READ
        case RS232_CH3_TX_RX:   // CH.3 DATA READ
            Invalid_port_access = TRUE;
            break;

        //Process read to STATUS register
        case RS232_CH1_STATUS:  // CH.1 READ STATUS
        case RS232_CH2_STATUS:  // CH.2 READ STATUS
        case RS232_CH3_STATUS:  // CH.3 READ STATUS

            *value = (((half_word) (*GetCommShadowMSR)((WORD)adapter) & 0x20) << 2 ) + 5 ;
// CATION !!!

            break;

        //Process read to MASK register (CH.1 only)
        case RS232_CH1_MASK:    // CH.1 READ MASK (CH.1 ONLY)
            Invalid_port_access = TRUE;
            break;

        //Process read to SIGNAL register
        case RS232_CH1_SIG:             // CH.1 READ SIGNAL
        case RS232_CH2_SIG:             // CH.2 READ SIGNAL
        case RS232_CH3_SIG:             // CH.3 READ SIGNAL

            //*value = ((half_word) (*GetCommShadowMSR)((WORD)adapter) & 0xc0) + 
            //        (((half_word) (*GetCommShadowMSR)((WORD)adapter) & 0x10) << 1);
            newMSR = ~(half_word) (*GetCommShadowMSR)((WORD)adapter);
            *value = (((newMSR & 0x80) >> 2)    
                     |((newMSR & 0x10) << 2)    
                     |((newMSR & 0x40) << 1));  // ADD 93.10.14
// CATION !!!

            break;
    }

    /*.......................................... Handle invalid port accesses */
}
#else // NEC_98
void wow_com_inb(io_addr port, half_word *value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    HANDLE FileH;


    /*........................................... Communications port open ? */

   if (GetCommHandle == NULL) {
        com_inb(port,value);
        return;
    }

   FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);
#ifndef PROD
    if( FileH== NULL)
        DisplayPortAccessError(port & 0x7, TRUE, FALSE);
#endif

    /*.................................................... Process port read */

    switch(port & 0x7)
    {
	//Process read to RX register
	case RS232_TX_RX:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
	    {
		if(SyncLineSettings(FileH,NULL,&asp->divisor_latch,&asp->line_control_reg))
		    *value = (half_word) asp->divisor_latch.byte.LSByte;
		else
		    Invalid_port_access = TRUE;
	    }
	    break;


	//Process IER read
	case RS232_IER:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
	    {
		if(SyncLineSettings(FileH,NULL,&asp->divisor_latch,&asp->line_control_reg))
		    *value = (half_word) asp->divisor_latch.byte.MSByte;
		else
		    Invalid_port_access = TRUE;
	    }
	    break;


	//Process IIR, LSR and MCR reads
	case RS232_IIR:
	case RS232_LSR:
	case RS232_MCR:

	    Invalid_port_access = TRUE;
	    break;

	case RS232_LCR:

	    if(SyncLineSettings(FileH,NULL,&asp->divisor_latch,&asp->line_control_reg))
		*value = asp->line_control_reg.all;
	    else
		Invalid_port_access = TRUE;

	    break;

	//Process MSR read
	case RS232_MSR:

            *value = (half_word) (*GetCommShadowMSR)((WORD)adapter);
	    break;

	// Process access to Scratch register
	case RS232_SCRATCH:
	    *value = asp->scratch;
	    break;
    }

    /*.......................................... Handle invalid port accesses */

#ifndef PROD
    if(Invalid_port_access)
        DisplayPortAccessError(port & 0x7, TRUE, TRUE);
#endif


}
#endif // NEC_98

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::: WOW outb function */

#if defined(NEC_98)         
void wow_com_outb(io_addr port, half_word value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    LINE_CONTROL_REG newLCR;
    HANDLE FileH;

    /*........................................... Communications port open ? */

    if (GetCommHandle == NULL) {
        com_outb(port,value);
        return;
    }

    FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);

    /*.................................................... Process port write */

    switch(port)
    {
        //Process write to TX register
        case RS232_CH1_TX_RX:   // CH.1 DATA WRITE
        case RS232_CH2_TX_RX:   // CH.2 DATA WRITE
        case RS232_CH3_TX_RX:   // CH.3 DATA WRITE
            Invalid_port_access = TRUE;
            break;

        //Process write to COMMAND/MODE register
        case RS232_CH1_CMD_MODE:        // CH.1 WRITE COMMAND/MODE
        case RS232_CH2_CMD_MODE:        // CH.2 WRITE COMMAND/MODE
        case RS232_CH3_CMD_MODE:        // CH.3 WRITE COMMAND/MODE

// CATION !!!

            break;

        //Process write to MASK register
        case RS232_CH1_MASK:            // CH.1 SET MASK
        case RS232_CH2_MASK:            // CH.2 SET MASK
        case RS232_CH3_MASK:            // CH.3 SET MASK
            Invalid_port_access = TRUE;
            break;
        //Process write to MASK(bit set) register (CH.1 only)
        case 0x37:                                      // CH.1 SET MASK
            Invalid_port_access = TRUE;
            break;
    }

    /*.......................................... Handle invalid port accesses */

}
#else  // NEC_98
void wow_com_outb(io_addr port, half_word value)
{
    int adapter = adapter_for_port(port);
    struct ADAPTER_STATE *asp = &adapter_state[adapter];
    BOOL Invalid_port_access = FALSE;
    LINE_CONTROL_REG newLCR;
    HANDLE FileH;

    /*........................................... Communications port open ? */

    if (GetCommHandle == NULL) {
        com_outb(port,value);
        return;
    }

    FileH = (HANDLE)(*GetCommHandle)((WORD)adapter);
#ifndef PROD
    if(FileH == NULL)
        DisplayPortAccessError(port & 0x7, FALSE, FALSE);
#endif

    /*.................................................... Process port write */

    switch(port & 0x7)
    {
	//Process write to TX register
	case RS232_TX_RX:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
		asp->divisor_latch.byte.LSByte= value;

	    break;

	//Process write to IER register
	case RS232_IER:

	    if(asp->line_control_reg.bits.DLAB == 0)
		Invalid_port_access = TRUE;
	    else
		asp->divisor_latch.byte.MSByte = value;

	    break;

	//Proces write to IIR, MCR, LSR amd MSR

	case RS232_IIR:
	case RS232_MCR:
	case RS232_LSR:
	case RS232_MSR:

	    Invalid_port_access = TRUE;
	    break;

	case RS232_LCR:

	    newLCR.all = value;
	    if(asp->line_control_reg.bits.DLAB == 1 && newLCR.bits.DLAB == 0)
	    {
		if(!SetupBaudRate(FileH,asp->divisor_latch))
		    Invalid_port_access = TRUE;
	    }

	    if(!Invalid_port_access && !SetupLCRData(FileH,newLCR))
		Invalid_port_access = TRUE;

	    asp->line_control_reg.all = newLCR.all;
	    break;

	//Scratch register write

	case RS232_SCRATCH:
	    asp->scratch = value;
	    break;
    }

    /*.......................................... Handle invalid port accesses */

#ifndef PROD
    if(Invalid_port_access)
        DisplayPortAccessError(port & 0x7, FALSE, TRUE);
#endif

}
#endif // NEC_98


/*:::::::::::::::: Synchronise Baud/Parity/Stop bits/Data bits with real UART */

BOOL SyncLineSettings(HANDLE FileHandle,
		      DCB *pdcb,
		      DIVISOR_LATCH *divisor_latch,
		      LINE_CONTROL_REG *LCR_reg )
{
    DCB dcb;	      //State of real UART
    register DCB *dcb_ptr;


    //Get current state of the real UART

    if(pdcb == NULL && !GetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    dcb_ptr = pdcb ? pdcb : &dcb;

#if defined(NEC_98)         
    // Convert BAUD rate to divisor latch setting
    divisor_latch->all = (unsigned short)(153600/dcb_ptr->BaudRate);
#else  // NEC_98
    // Convert BAUD rate to divisor latch setting
    divisor_latch->all = (unsigned short)(115200/dcb_ptr->BaudRate);
#endif // NEC_98

    //Setup parity value
    LCR_reg->bits.parity_enabled = PARITYENABLE_ON;       //Default parity on

    switch(dcb_ptr->Parity)
    {
	case EVENPARITY :
            LCR_reg->bits.even_parity = EVENPARITY_EVEN;
	    break;

	case NOPARITY :
            LCR_reg->bits.parity_enabled = PARITYENABLE_OFF;
	    break;

	case ODDPARITY :
            LCR_reg->bits.even_parity = EVENPARITY_ODD;
	    break;

	case SPACEPARITY:
	    LCR_reg->bits.stick_parity = PARITY_STICK;
            LCR_reg->bits.even_parity = EVENPARITY_EVEN;
	    break;

	case MARKPARITY :
	    LCR_reg->bits.stick_parity = PARITY_STICK;
            LCR_reg->bits.even_parity = EVENPARITY_ODD;
	    break;
    }

    //Setup stop bits
    LCR_reg->bits.no_of_stop_bits = dcb_ptr->StopBits == ONESTOPBIT ? 0 : 1;

    //Setup data byte size
    LCR_reg->bits.word_length = dcb_ptr->ByteSize-5;

    return(TRUE);
}


#ifndef NEC_98
/*::::::::::::::::::::::::::::::::::::::::::::::::::: Setup Line control data */

BOOL SetupLCRData(HANDLE FileHandle, LINE_CONTROL_REG LCR_reg)
{
    DCB dcb;		//State of real UART

    //Get current state of the real UART

    if(!GetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    //Setup data bits
    dcb.ByteSize = LCR_reg.bits.word_length+5;

    //Setup stop bits
    if(LCR_reg.bits.no_of_stop_bits == 0)
	dcb.StopBits = LCR_reg.bits.word_length == 0 ? ONE5STOPBITS:TWOSTOPBITS;
    else
	dcb.StopBits = ONESTOPBIT;

    //Setup parity
    if(LCR_reg.bits.parity_enabled == PARITYENABLE_ON)
    {
	if(LCR_reg.bits.stick_parity == PARITY_STICK)
	{
            dcb.Parity = LCR_reg.bits.even_parity == EVENPARITY_ODD ?
			 MARKPARITY : SPACEPARITY;

	}
	else
	{
            dcb.Parity = LCR_reg.bits.even_parity == EVENPARITY_ODD ?
		       ODDPARITY :EVENPARITY;
	}
    }
    else
	dcb.Parity = NOPARITY;

    //Sent the new line setting values to the serial driver
    if(!SetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    return(TRUE);
}

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Set up the baud rate */

BOOL SetupBaudRate(HANDLE FileHandle, DIVISOR_LATCH divisor_latch)
{
    DCB dcb;

    //Setup the baud rate

    if(!GetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    dcb.BaudRate = divisor_latch.all ? 115200/divisor_latch.all : 115200;

    if(!SetCommState(FileHandle, &dcb))
    {
	always_trace0("ntvdm : GetCommState failed on open\n");
	return(FALSE);
    }

    return(TRUE);
}


/*::::::::::::::::::::::::::::::::::::::::::::::::: Display port access error */


#ifndef PROD
/*
 *  user warnings are not needed here, return errors and let the
 *  app handle it. message boxes are also not permitted, because
 *  it can kill WOW. 20-Feb-1993 Jonle
 */
void DisplayPortAccessError(int PortOffset, BOOL ReadAccess, BOOL PortOpen)
{
    static char *PortInError;
    static char ErrorMessage[250];
    int rtn;

    // Identify port in error

    switch(PortOffset)
    {
	case RS232_TX_RX:   PortInError = ReadAccess ? "RX" : "TX" ; break;
	case RS232_IER:     PortInError = "IER" ; break;
	case RS232_IIR:     PortInError = "IIR" ; break;
	case RS232_MCR:     PortInError = "MCR" ; break;
	case RS232_LSR:     PortInError = "LSR" ; break;
	case RS232_MSR:     PortInError = "MSR" ; break;
	case RS232_LCR:     PortInError = "LCR" ; break;
	case RS232_SCRATCH: PortInError = "Scratch" ; break;
	default:	    PortInError = "Unidentified"; break;
    }

    //Construct Error message

    sprintf(ErrorMessage, "The Application attempted to %s the %s register",
	    ReadAccess ? "read" : "write", PortInError);

    if(!PortOpen)
	strcat(ErrorMessage,", however the comm port has not yet been opened");

    //Display message box
    printf("WOW Communication Port Access Error\n%s\n",ErrorMessage);
}
#endif
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\stf_conf.c ===
/*
 * SoftPC Revision 3.0
 *
 *
 * Title        : Host dependent configuration panel functions
 *
 *
 * Description  : This module forms the host dependant side of the softpc
 *                configuration system. 
 *
 *
 * Author   : Wilf Stubs
 *
 *
 * Notes        : 
 *
 */
#include "insignia.h"
#include "host_dfs.h"

#include <stdio.h>
#include <string.h>

#include "xt.h"
#include "error.h"
#include "gfi.h"
#include "gmi.h"
#include "gfx_updt.h"
#include "config.h"
#include "rs232.h"
#include "host_lpt.h"
#include "host_cpu.h"
#include "host_com.h"
#include "nt_confg.h"

/*********** Private definitions ***********************/

/*
 * Validation routines
 */

static short validate_c_drive();
static short validate_d_drive();
static short validate_com1();
static short validate_com2();
static short validate_lpt1();
static short validate_lpt2();
#if (NUM_PARALLEL_PORTS>2)
static short validate_lpt3();
#endif
static short validate_item();
static short no_validation();

/*
 * Change action routines
 */

static short c_drive_change_action();
static short d_drive_change_action();
static short no_change_action();
static short lpt1_change_action();
static short lpt2_change_action();
#if (NUM_PARALLEL_PORTS>2)
static short lpt3_change_action();
#endif
static short com1_change_action();
static short com2_change_action();
boolean pc_initiated=FALSE;
char *pc_uif_text;

boolean use_comments = TRUE;  /* Set to true if commenting required. */

#define defaults_filename "SoftPC.rez"

static char *ends[] =
{
   "st","nd","rd","th"
};

/* Table definitions for options that take one of n 'value' strings. 
 * The table is used to look up the string and find what it means
 * to the host in this option. 
 *  Look at the tables for more explanation, they're fairly self-explanatory.
 */
name_table bool_values[] =
{
 { "yes", TRUE },
 { "Yes", TRUE },
 { "YES", TRUE },
 { "no",  FALSE },
 { "No",  FALSE },
 { "NO",  FALSE },
 { NULL,  0 }
};

name_table gfx_adapter_types[] =
{
    { "HERCULES",  HERCULES },
    { "CGA",        CGA },
    { "EGA",        EGA },
    { "VGA",        VGA },
    { NULL,      0 }
};

/* The BIG one! This is a decription of each option that the config struct
 * must have, and its requirements. Used by config for all sorts of things.
 *  For a fuller explanation look in the document:
 *           'Design Proposal for the New Config System'.
 */

option_description narrative[] =
{
   {                  /*    FOR EACH OPTION... */
      "HARD_DISK_FILENAME",      /* Name */
      C_HARD_DISK1_NAME,      /* Host name for option */
      C_STRING_RECORD,     /* Option (base) primitive type */
      C_HARD_DISKS,        /* Host option commonality type */
      FALSE,            /* Option is READ_ONLY if TRUE */
      null_table,       /* Pointer to table (null if not needed) */
      TRUE,          /* TRUE if default present, FALSE if not */
      "/usr/lib/SoftPC/hard_disk",  /* Default value as a string as if in resource file */
      TRUE,          /* TRUE if changing the option requires SoftPC reset */
      TRUE,          /* TRUE if option may be setup via the UIF */
      DISK_CONFIG,         /* Panel 'type' if you have different panels */
      validate_c_drive,    /* validation function */
      c_drive_change_action      /* function to do changing actions */
   },
   {
      "HARD_DISK_FILENAME2",
      C_HARD_DISK2_NAME,
      C_STRING_RECORD,
      C_HARD_DISKS,
      FALSE,
      null_table,
      TRUE,
      "",
      TRUE,
      TRUE,
      DISK_CONFIG,
      validate_d_drive,
      d_drive_change_action
   },
   {
      "COM_PORT_1",
      C_COM1_NAME,
      C_STRING_RECORD,
      C_SINGULARITY,
      FALSE,
      null_table,
      TRUE,
      "",
      FALSE,
      FALSE,
      COMMS_CONFIG,
      validate_com1,
      com1_change_action
   },
   {
      "COM_PORT_2",
      C_COM2_NAME,
      C_STRING_RECORD,
      C_SINGULARITY,
      FALSE,
      null_table,
      TRUE,
      "",
      FALSE,
      FALSE,
      COMMS_CONFIG,
      validate_com2,
      com2_change_action
   },
   {
      "LPT_PORT_1",
      C_LPT1_NAME,
      C_STRING_RECORD,
      C_SINGULARITY,
      FALSE,
      null_table,
      TRUE,
      "",
      FALSE,
      FALSE,
      COMMS_CONFIG,
      validate_lpt1,
      lpt1_change_action
   },
   {
      "LPT_PORT_2",
      C_LPT2_NAME,
      C_STRING_RECORD,
      C_SINGULARITY,
      FALSE,
      null_table,
      TRUE,
      "",
      FALSE,
      FALSE,
      COMMS_CONFIG,
      validate_lpt2,
      lpt2_change_action
   },
   {
      "GRAPHICS_ADAPTOR",
      C_GFX_ADAPTER,
      C_NAME_RECORD,
      C_SINGULARITY,
      FALSE,
      gfx_adapter_types,
      TRUE,
      "VGA",
      TRUE,
      TRUE,
      DISPLAY_CONFIG,
      validate_item,
      no_change_action
   },
   {
      NULL,
      0,
      0,
      C_SINGULARITY,
      FALSE,
      null_table,
      FALSE,
      NULL,
      FALSE,
      FALSE,
      NON_CONFIG,
      no_validation,
      no_change_action
   }
};

/* Runtime variables */

struct
{
      boolean mouse_attached;
      boolean config_verbose;
      boolean npx_enabled;
      boolean sound_on;
      boolean com_flow_control[2];
      int floppy_state[2];
      int floppy_active_state[2];
      int floppy_capacity[2];
      int hd_cyls[2];
      boolean lptflush1;
      boolean lptflush2;
      boolean lptflush3;
      int   flushtime1;
      int   flushtime2;
      int   flushtime3;
} runtime_status;

#define NUM_OPTS ( sizeof(narrative) / sizeof( option_description) )

/*********** Imported and exported items *************/

extern char *getenv();
extern char *malloc();

/*************** Local Declarations *****************/

void host_config_error();
static char buff[MAXPATHLEN];
static char buff1[MAXPATHLEN];
boolean item_in_table();
static char home_resource[MAXPATHLEN];
static char sys_resource[MAXPATHLEN];

/*********************************************************/

short host_runtime_inquire(what)
int what;

{
      switch(what)
      {
      case C_MOUSE_ATTACHED:
         return( runtime_status.mouse_attached );
         break;

      case C_CONFIG_VERBOSE:
         return( runtime_status.config_verbose );
         break;

      case C_NPX_ENABLED:
         return( runtime_status.npx_enabled );
         break;

      case C_HD1_CYLS:
         return( runtime_status.hd_cyls[0] );
         break;

      case C_HD2_CYLS:
         return( runtime_status.hd_cyls[1] );
         break;

      case C_FLOPPY1_STATE:
         return( runtime_status.floppy_state[0] );
         break;

      case C_FLOPPY2_STATE:
         return( runtime_status.floppy_state[1] );
         break;

      case C_FLOPPY1_ACTIVE_STATE:
         return( runtime_status.floppy_active_state[0] );
         break;

      case C_FLOPPY2_ACTIVE_STATE:
         return( runtime_status.floppy_active_state[1] );
         break;

      case C_FLOPPY1_CAPACITY:
         return( runtime_status.floppy_capacity[0] );
         break;

      case C_FLOPPY_TYPE_CHANGED:
         return( runtime_status.floppy_type_changed );
         break;

      case C_FLOPPY2_CAPACITY:
         return( runtime_status.floppy_capacity[1] );
         break;

      case C_SOUND_ON:
         return( runtime_status.sound_on );
         break;

      case C_REAL_FLOPPY_ALLOC:
         return( runtime_status.floppy_state[0] == GFI_REAL_DISKETTE_SERVER ||
               runtime_status.floppy_state[1] == GFI_REAL_DISKETTE_SERVER );
         break;

      case C_REAL_OR_SLAVE:
         return( runtime_status.floppy_A_real );
         break;

      case C_SLAVE_FLOPPY_ALLOC:
         return( runtime_status.floppy_state[0] == GFI_SLAVE_SERVER );
         break;

      case C_COM1_FLOW:
         return( runtime_status.com_flow_control[0] );
         break;

      case C_COM2_FLOW:
         return( runtime_status.com_flow_control[1] );
         break;

      case C_COM3_FLOW:
         return( FALSE );
         break;

      case C_COM4_FLOW:
         return( FALSE );
         break;

      case C_LPTFLUSH1:
         return( runtime_status.lptflush1 );
         break;

      case C_LPTFLUSH2:
         return( runtime_status.lptflush2 );
         break;

      case C_LPTFLUSH3:
         return( runtime_status.lptflush3 );
         break;

      case C_FLUSHTIME1:
         return( runtime_status.flushtime1 );
         break;

      case C_FLUSHTIME2:
         return( runtime_status.flushtime2 );
         break;

      case C_FLUSHTIME3:
         return( runtime_status.flushtime3 );
         break;

      default:
         host_error(EG_OWNUP, ERR_QUIT, "host_runtime_inquire");
      }
}

void host_runtime_set(what,value)
int what;
int value;
{
       switch(what)
      {
      case C_MOUSE_ATTACHED:
         runtime_status.mouse_attached = value;
         break;

      case C_CONFIG_VERBOSE:
         runtime_status.config_verbose = value;
         break;

      case C_NPX_ENABLED:
         runtime_status.npx_enabled = value;
         break;

      case C_HD1_CYLS:
         runtime_status.hd_cyls[0] = value;
         break;

      case C_HD2_CYLS:
         runtime_status.hd_cyls[1] = value;
         break;

      case C_FLOPPY1_STATE:
         runtime_status.floppy_state[0] = value;
         break;

      case C_FLOPPY2_STATE:
         runtime_status.floppy_state[1] = value;
         break;

      case C_FLOPPY1_ACTIVE_STATE:
         runtime_status.floppy_active_state[0] = value;
         break;

      case C_FLOPPY2_ACTIVE_STATE:
         runtime_status.floppy_active_state[1] = value;
         break;

      case C_FLOPPY1_CAPACITY:
         runtime_status.floppy_capacity[0] = value;
         break;

      case C_FLOPPY2_CAPACITY:
         runtime_status.floppy_capacity[1] = value;
         break;

      case C_FLOPPY_TYPE_CHANGED:
         runtime_status.floppy_type_changed = value;
         break;

      case C_SOUND_ON:
         runtime_status.sound_on = value;
         break;

      case C_REAL_OR_SLAVE:
         runtime_status.floppy_A_real = value;
         break;

      case C_COM1_FLOW:
         runtime_status.com_flow_control[0] = value;
         break;

      case C_COM2_FLOW:
         runtime_status.com_flow_control[1] = value;
         break;

      case C_COM3_FLOW:
      case C_COM4_FLOW:
         break;

      case C_LPTFLUSH1:
         runtime_status.lptflush1 =value;
         break;

      case C_LPTFLUSH2:
         runtime_status.lptflush2 =value;
         break;

      case C_LPTFLUSH3:
         runtime_status.lptflush3 =value;
         break;

      case C_FLUSHTIME1:
         runtime_status.flushtime1 =value;
         break;

      case C_FLUSHTIME2:
         runtime_status.flushtime2 =value;
         break;

      case C_FLUSHTIME3:
         runtime_status.flushtime3 =value;
         break;

      default:
         host_error(EG_OWNUP, ERR_QUIT, "host_runtime_set");
      }
}

void host_runtime_init()
{
    config_values var;

#ifdef NPX
      host_runtime_set(C_NPX_ENABLED,TRUE);
#else
      host_runtime_set(C_NPX_ENABLED,FALSE);
#endif

#ifndef PROD
      printf("NPX is %s\n",host_runtime_inquire(C_NPX_ENABLED)? "on.":"off.");
#endif
      host_runtime_set(C_FLUSHTIME1, 5);
      host_runtime_set(C_FLUSHTIME2, 10);
      host_runtime_set(C_FLUSHTIME3, 15);
      host_runtime_set(C_MOUSE_ATTACHED,FALSE);
      host_runtime_set(C_CONFIG_VERBOSE,TRUE);
      host_runtime_set(C_SOUND_ON,FALSE);
      host_runtime_set(C_FLOPPY1_STATE,GFI_EMPTY_SERVER);
      host_runtime_set(C_FLOPPY2_STATE,GFI_EMPTY_SERVER);
      host_runtime_set(C_FLOPPY1_ACTIVE_STATE,GFI_EMPTY_SERVER);
      host_runtime_set(C_FLOPPY2_ACTIVE_STATE,GFI_EMPTY_SERVER);
      host_runtime_set(C_REAL_OR_SLAVE,FALSE);
      host_runtime_set(C_FLOPPY_TYPE_CHANGED,FALSE);
}

/*
 *  General host initialisation function. It is called only once on startup
 * from 'config()'. It does the following (at the moment):
 *
 * 1)  Makes the 'option' field of the 'config_info' struct pointed to by 'head' *    point to all the option 'rules' - that is the 'narrative' structure
 *    initialised at the start of this file.
 *
 * 2)  Counts up the option rules in 'narrative' and stores the result in the
 *    'config_info' struct.
 *
 * 3)  Return the minimum padding length necessary.
 *
 * 4)  Derive the two path:filenames for the resource file. This file may be
 *    in the user's $HOME directory or in softpc's ROOT directory. Making up
 *    these strings now saves doing it every time 'config_store()' is called.
 */
#ifdef 0
void host_get_config_info(head)
config_description *head;
{

    char *pp, *getenv();
    option_description *option_p = narrative;

    head->option = narrative;      /* Attach 'narrative' */
    head->option_count = NUM_OPTS - 1;
    head->min_pad_len = MIN_OPTION_ARG_DIST;

        /*
   * get system resource file from standard place
   */
   strcpy(sys_resource, ROOT);

   strcat(sys_resource, PATH_SEPARATOR);
   strcat(sys_resource, RESOURCE_FILENAME);
}
#endif
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::: Try and load database files ::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static boolean try_load_database()
{
    FILE *infile = NULL;
    char in_line[MAXPATHLEN];
    char *cp;
    char *home, *getenv();

    /* Keep this the same as system for the moment */

   sprintf(home_resource,"%s%s%s",ROOT,PATH_SEPARATOR,RESOURCE_FILENAME);

    /*....................................... Attempt to open resource file */

    if((infile = fopen(home_resource, "r")) == NULL)
   return(FALSE);

    /*.................................................. Read resource file */

    while (fgets(in_line, MAXPATHLEN, infile) != NULL)
    {
   /*........................................ strip control characters */

   for(cp = in_line; *cp ; cp++) if(*cp < ' ') *cp = ' ';

   add_resource_node(in_line);
    }

    /*............................. Close resource file and get out of here */

    fclose(infile);
    return TRUE;
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::: Try to load system files ::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

static boolean try_load_sys_file()
{
    FILE *infile = NULL;
    char in_line[MAXPATHLEN];
    register char *cp;

    /*................................ Attempt to open system resource file */

    if((infile = fopen(sys_resource, "r")) == NULL)
   return(FALSE);

    /*................................................. read resource file */

    while (fgets(in_line, MAXPATHLEN, infile) != NULL)
    {
       /*......................................... strip control characters */

   for(cp = in_line; *cp ; cp++)
       if(*cp < ' ') *cp = ' ';

   add_resource_node(in_line);
    }

    /*........................................ close resource file and exit */

    fclose(infile);
    return(TRUE);
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*:::::::::::::::::::::::::: Read resource file ::::::::::::::::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

short host_read_resource_file(resource_data *resource)
{
    boolean bad_home=FALSE, bad_sys=FALSE;

    /* Try open users default database failing that, open the system file. */

    if(bad_home = !try_load_database())
   bad_sys = !try_load_sys_file();

    if(bad_home && bad_sys) return(EG_ALL_RESOURCE_BAD_R);

    return(bad_home ? EG_BAD_LOCAL_RESOURCE_R : C_CONFIG_OP_OK);
}

short host_write_resource_file(resource)
resource_data *resource;
{

FILE *outfile;
line_node *node;
boolean bad_home=TRUE, bad_sys=FALSE;

 /* Try to open (for writing) a resource file in the users home directory or
    failing that, the system one. These two paths are set up once at runtime. */

 if(home_resource[0] != '\0')
      if((outfile = fopen(home_resource, "w")) != NULL)
         bad_home = FALSE;

   if(bad_home)
      if((outfile = fopen(sys_resource, "w")) == NULL)
         bad_sys = TRUE;

   if(bad_home && !bad_sys)
      return EG_ALL_RESOURCE_BAD_W;

   else 
      if(bad_home && bad_sys)
         return EG_ALL_RESOURCE_BAD_W;

   node = resource->first;
   while(node != NULL)
   {
      fputs(node->line,outfile);    
      fputc('\n',outfile);
      node = node->next;
   }
   fclose(outfile);
   return(C_CONFIG_OP_OK);

}


/* A host specific extension to config_inquire() to deal with any inquiries 
   that the base config code doesn't or shouldn't know about.                */


void host_inquire_extn(sort,identity,values)
short sort;
int identity;
config_values *values;
{
}

static char error_text[300];
static int error_locus;

host_error_query_locus(locus,text)
int *locus;
char **text;
{
        *locus = error_locus;
   *text = error_text;
}

host_error_set_locus(text, locus)
char *text;
int locus;
{
        strcpy(error_text, text);
   error_locus = locus;
}

static short no_validation(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
   return(C_CONFIG_OP_OK);
}

static short validate_c_drive(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
/* cheat on validation for moment as this will disapear */
   return(C_CONFIG_OP_OK);
}

static short validate_d_drive(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
/* cheat on validation for moment as this will disapear */
   return(C_CONFIG_OP_OK);
}

static short validate_com1(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

static short validate_com2(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

static short validate_lpt1(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

static short validate_lpt2(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

static short validate_item(value, table, buf)
config_values *value;
name_table table[];
char  *buf;
{
/* cheat on validation - no table lookup  */
   return(C_CONFIG_OP_OK);
}

boolean item_in_table(val,table)
int val;
name_table table[];
{
   int n=0;
   while(table[n].string != NULL)
      if(table[n].value == val)
         break;
      else 
         n++;
   return( table[n].string == NULL? FALSE : TRUE);
}

static short no_change_action( value, buf)
config_values  *value;
char        *buf;
{
   return( C_CONFIG_OP_OK );
}

static short c_drive_change_action( value, buf)
config_values  *value;
char        *buf;
{
   short err;

   fdisk_iodetach ();
   fdisk_physdetach(0);

    if (err = fdisk_physattach( 0, value->string))
      strcpy(buf, narrative[C_HARD_DISK1_NAME].option_name);

   fdisk_ioattach ();   

   return (err);

}

static short d_drive_change_action( value, buf)
config_values  *value;
char        *buf;
{
   short err;

   fdisk_iodetach ();
   fdisk_physdetach(1);

    if (err = fdisk_physattach( 1, value->string))
      strcpy(buf, narrative[C_HARD_DISK2_NAME].option_name);

   fdisk_ioattach ();   

   return (err);
}

static short lpt1_change_action( value, buf)
config_values  *value;
char        *buf;
{
#ifdef STUBBED
         host_lpt_close(0);
   return (host_lpt_open(0, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

static short lpt2_change_action( value, buf)
config_values  *value;
char        *buf;
{
#ifdef STUBBED
         host_lpt_close(1);
   return (host_lpt_open(1, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

static short com1_change_action( value, buf)
config_values  *value;
char        *buf;
{
#ifdef STUBBED
   host_com_close(0);
   return (host_com_open(0, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

static short com2_change_action( value, buf)
config_values  *value;
char        *buf;
{
#ifdef STUBBED
         host_com_close(1);
   return (host_com_open(1, value->string, buf));
#endif /*STUBBED*/
/* cheat on validation for moment as this will change */
   return(C_CONFIG_OP_OK);
}

/*********** Floppy and hard disk init ****************/

void host_floppy_startup(driveno)
int driveno;
{
    host_floppy_init(driveno, GFI_EMPTY_SERVER );
}

void host_hd_startup()
{
   int error;
   config_values disk1_name,disk2_name;

   /* Start by getting the C: drive up */

      fdisk_physdetach(0);
      config_inquire(C_INQUIRE_VALUE,C_HARD_DISK1_NAME,&disk1_name);
      error = fdisk_physattach(0,disk1_name.string);
      if(error)
      {
         host_error(error, ERR_CONFIG|ERR_QUIT, disk1_name.string);
      }

/* If that went ok, try for D: */

      config_inquire(C_INQUIRE_VALUE,C_HARD_DISK2_NAME,&disk2_name);
      if(!strcmp(disk2_name.string,""))
         return;                        /* No D: drive! */

      if(!strcmp(disk2_name.string,disk1_name.string))
         host_error(EG_SAME_HD_FILE, ERR_CONFIG|ERR_QUIT, disk2_name.string);

      error = fdisk_physattach(1,disk2_name.string);
      if(error)
         host_error(error, ERR_CONFIG|ERR_QUIT, disk2_name.string);

}

/* temp hack */
char *host_get_spc_home() { return("c:\\softpc"); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=src
TARGETPATH=obj
TARGETTYPE=LIBRARY

MVDM_TREE=$(PROJECT_ROOT)\mvdm
SOFTPC_TREE=$(MVDM_TREE)\softpc.new

INCLUDES=\
    $(SOFTPC_TREE)\host\inc;\
    $(SOFTPC_TREE)\base\inc;\
    $(MVDM_TREE)\vdd\h;\
    $(MVDM_TREE)\inc;\
    $(WINDOWS_INC_PATH)

W32_SB=1
SOURCES=\
    ..\sim32.c         \
    ..\cpucstbs.c      \
    ..\nt_timer.c      \
    ..\nt_ntfun.c      \
    ..\nt_msscs.c      \
    ..\nt_error.c      \
    ..\nt_cga.c        \
    ..\nt_ega.c        \
    ..\nt_vga.c        \
    ..\nt_input.c      \
    ..\nt_graph.c      \
    ..\nt_hosts.c      \
    ..\nt_sound.c      \
    ..\nt_bop.c        \
    ..\nt_com.c        \
    ..\nt_wcom.c       \
    ..\nt_rez.c        \
    ..\nt_sas.c        \
    ..\nt_fdisk.c      \
    ..\nt_unix.c       \
    ..\nt_keycd.c      \
    ..\nt_cpu.c        \
    ..\nt_lpt.c        \
    ..\nt_yoda.c       \
    ..\nt_mouse.c      \
    ..\nt_event.c      \
    ..\nt_munge.c      \
    ..\config.c        \
    ..\nt_nls.c        \
    ..\copy_fnc.c      \
    ..\nt_msscs.c      \
    ..\stubs.c         \
    ..\nt_pif.c        \
    ..\nt_fulsc.c      \
    ..\nt_emm.c        \
    ..\x86_emm.c       \
    ..\nt_eoi.c        \
    ..\nt_vdd.c        \
    ..\nt_sec.c        \
    ..\nt_thred.c      \
    ..\nt_det.c        \
    ..\nt_umb.c        \
    ..\fprt.c          \
    ..\nt_rflop.c      \
    ..\nt_inthk.c      \
    ..\nt_reset.c      \
    ..\nt_mem.c        \
    ..\nt_98grf.c      \
    ..\nt_cgw.c        \
    ..\nt_vsync.c      \
    ..\nt_vdm.c        \
    ..\nt_devs.c       \
    ..\nt_sb.c         \
    ..\nt_sbdsp.c      \
    ..\nt_sbfm.c       \
    ..\nt_sbmxr.c      \
    ..\nt_sbmid.c

ALPHA_SOURCES=..\nt_aorc.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

UMTYPE=console
SOURCES_USED=..\sources.inc

CONDITIONAL_INCLUDES=sas4gen.h         \
                     evidgen.h         \
                     gdpvar.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\sim32.c ===
/*
 *      sim32.c -       Sim32 for Microsoft NT SoftPC.
 *
 *      Ade Brownlow
 *      Wed Jun 5 91
 *
 *      %W% %G% (c) Insignia Solutions 1991
 *
 *      This module provides the Microsoft sim32 interface with the additional sas
 *      functionality and some host sas routines. We also provide cpu idling facilities.
 *
 *      This module in effect provides (along with the cpu) what Microsoft term as the IEU -
 *      see documentation.
 */

#ifdef SIM32

#ifdef CPU_40_STYLE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif /* CPU_40_STYLE */

#include <windows.h>
#include "insignia.h"
#include "host_def.h"

#include <stdlib.h>
#include <stdio.h>
#include "xt.h"
#include "sim32.h"
#include "sas.h"
#include "gmi.h"
#include "ckmalloc.h"
#include CpuH


#ifdef CPU_40_STYLE
#include "nt_mem.h"
#endif /* CPU_40_STYLE */
#include "nt_vdd.h"

/********************************************************/
/* IMPORTS & EXPORTS */

/* Sas/gmi Sim32 crossovers */
GLOBAL BOOL Sim32FlushVDMPointer (double_word, word, UTINY *, BOOL);
GLOBAL BOOL Sim32FreeVDMPointer (double_word, word, UTINY *, BOOL);
GLOBAL BOOL Sim32GetVDMMemory (double_word, word, UTINY *, BOOL);
GLOBAL BOOL Sim32SetVDMMemory (double_word, word, UTINY *, BOOL);
GLOBAL sys_addr sim32_effective_addr (double_word, BOOL);
GLOBAL sys_addr sim32_effective_addr_ex (word, double_word, BOOL);

GLOBAL UTINY *sas_alter_size(sys_addr);
GLOBAL UTINY *host_sas_init(sys_addr);
GLOBAL UTINY *host_sas_term(void);

/* Microsoft sas extensions */
GLOBAL IMEMBLOCK *sas_mem_map (void);
GLOBAL void sas_clear_map(void);

IMPORT ULONG Sas_wrap_mask;



#ifndef MONITOR
//
// Pointer to a scratch video buffer. Updated by sim32 routines
// when intel video addr is requested.

IU8 *ScratchVideoBuffer = 0;
#define VIDEO_REGEN_START   0xa0000
#define VIDEO_REGEN_END     0xbffff
#define VID_BUFF_SIZE       0x20000


#define IsVideoMemory(LinAddr) \
         ((LinAddr) >= VIDEO_REGEN_START && (LinAddr) <= VIDEO_REGEN_END)


IU8 *GetVideoMemory(ULONG iaddr)
{

   //
   // If there isn't a video scratch buffer, allocate one.
   // This will stick around until ntvdm terminates. Could be
   // optimized to free the buffer when not in use.
   //
   if (!ScratchVideoBuffer) {
       ScratchVideoBuffer = malloc(VID_BUFF_SIZE);
       if (!ScratchVideoBuffer) {
          return NULL;
          }
       }

   //
   // We could do this more efficiently, by only copying
   // minimum area needed, but then we need to keep track of
   // what to update on the flush and do ref counting.
   // Since video memory access by host code is rare
   // (only seen in demWrite\demRead so far) be simple minded.
   //
   sas_loads (VIDEO_REGEN_START,
              ScratchVideoBuffer,
              VID_BUFF_SIZE
              );

   return ScratchVideoBuffer + (iaddr - VIDEO_REGEN_START);
}


BOOL SetVideoMemory(ULONG iaddr)
{
   ULONG VideoOffset = iaddr - VIDEO_REGEN_START;

   if (!ScratchVideoBuffer) {
       return FALSE;
       }

   sas_stores(iaddr,
              ScratchVideoBuffer + VideoOffset,
              VID_BUFF_SIZE - VideoOffset
              );

  return TRUE;
}

#endif



/********************************************************/
/* MACROS */
/* macro to convert the supplied address to intel address */
#define convert_addr(a,b,c,d) \
        { \
                if ((a = sim32_effective_addr (b,c)) == (sys_addr)-1)\
                {\
                        return (d);\
                }\
        }
#define convert_addr_ex(a,b,c,d,e) \
        { \
                if ((a = sim32_effective_addr_ex (b,c,d)) == (sys_addr)-1)\
                {\
                        return (e);\
                }\
        }

/********************************************************/
/*      The actual sim32 interfaces, most of these routines can be more or less mapped directly
 *      to existing routines in sas or gmi.
 *
 *      WARNING: This routine returns a pointer into M, and
 *               WILL NOT work for backward M.
 */
UCHAR *Sim32pGetVDMPointer(ULONG addr, UCHAR pm)
{
        sys_addr iaddr;

        if (pm && (addr == 0))
	    return(NULL);

        convert_addr (iaddr, addr, pm, NULL);
//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

        if (IsVideoMemory(iaddr)) {
            return GetVideoMemory(iaddr);
            }

        return (NtGetPtrToLinAddrByte(iaddr));
}

/*
 *  See Sim32pGetVDMPointer
 *
 *  This call must be maintaned as is because it is exported for VDD's
 *  in product 1.0.
 */
UCHAR *ExpSim32GetVDMPointer IFN3(double_word, addr, double_word, size, UCHAR, pm)
{
        return Sim32pGetVDMPointer(addr, (UCHAR)pm);
}


GLOBAL BOOL Sim32FlushVDMPointer IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        sys_addr iaddr;
        convert_addr (iaddr, addr, pm, 0);

//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

#ifndef MONITOR
        if (IsVideoMemory(iaddr) && !SetVideoMemory(iaddr)) {
            return FALSE;
            }
#endif   //MONITOR


        sas_overwrite_memory(iaddr, (ULONG)size);
        return (TRUE);
}


/********************************************************/
/*      The actual sim32 interfaces, most of these routines can be more or less mapped directly
 *      to existing routines in sas or gmi.
 *
 *      WARNING: This routine returns a pointer into M, and
 *               WILL NOT work for backward M.
 */
PVOID
VdmMapFlat(
    USHORT seg,
    ULONG off,
    VDM_MODE mode
    )
{
    sys_addr iaddr;
	BOOL pm = (mode == VDM_PM);

    if (pm && (seg == 0) && (off == 0))
    return(NULL);

    convert_addr_ex (iaddr, seg, off, pm, NULL);
//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

    if (IsVideoMemory(iaddr)) {
        return GetVideoMemory(iaddr);
        }

    return (NtGetPtrToLinAddrByte(iaddr));
}

BOOL
VdmUnmapFlat(
    USHORT seg,
    ULONG off,
    PVOID buffer,
    VDM_MODE mode
    )
{
    // Just a placeholder in case we ever need it
    return TRUE;
}


BOOL
VdmFlushCache(
    USHORT seg,
    ULONG off,
    ULONG size,
    VDM_MODE mode
    )
{

    sys_addr iaddr;
    if (!size) {
        DbgBreakPoint();
        return FALSE;
    }

    convert_addr_ex (iaddr, seg, off, (mode == VDM_PM), 0);

//STF - need sas_wrap_mask with PE....iaddr &= Sas_wrap_mask;

#ifndef MONITOR
    if (IsVideoMemory(iaddr) && !SetVideoMemory(iaddr)) {
        return FALSE;
        }
#endif   //MONITOR


    //
    // Now call the emulator to inform it that memory has changed.
    //
    // Note that sas_overwrite_memory is PAGE GRANULAR, so using
    // it to flush a single LDT descriptor has a horrendous impact on
    // performance, since up to 511 other descriptors are also
    // thrown away.
    //
    // So perform an optimization here by keying off the size.
    // The dpmi code has been written to flush 1 descriptor at
    // a time, so use the sas_store functions in this case to
    // flush it.
    //

    if (size <= 8) {
        UCHAR Buffer[8];
        PUCHAR pBytes;
        USHORT i;
        //
        // Small flush - avoid sas_overwrite_memory().
        // Note that the sas_store functions optimize out calls
        // that simply replace a byte with an identical byte. So this
        // code copies out the bytes to a buffer, copies in zeroes,
        // and then copies the original bytes back in.
        //
        pBytes = NtGetPtrToLinAddrByte(iaddr);
        for (i=0; i<size; i++) {
            Buffer[i] = *pBytes++;
            sas_store(iaddr+i, 0);
        }
        sas_stores(iaddr, Buffer, size);

    } else {

        //
        // normal path - flushes PAGE GRANULAR
        //
        sas_overwrite_memory(iaddr, size);

    }

    return (TRUE);
}


GLOBAL BOOL Sim32FreeVDMPointer IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        /* we haven't allocated any new memory so always return success */
        return (TRUE);
}

GLOBAL BOOL Sim32GetVDMMemory IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        sys_addr iaddr;
        convert_addr (iaddr, addr, pm, FALSE);
        /* effectivly a sas_loads */
        sas_loads (iaddr, buff, (sys_addr)size);

        /* always return success */
        return (TRUE);
}

GLOBAL BOOL Sim32SetVDMMemory IFN4(double_word, addr, word, size, UTINY *, buff, BOOL, pm)
{
        sys_addr iaddr;
        convert_addr (iaddr, addr, pm, FALSE);
        /* effectivly a sas_stores */
        sas_stores (iaddr, buff, (sys_addr)size);

        /* always return success */
        return (TRUE);
}

/********************************************************/
/* Support routines for sim32 above */
GLOBAL sys_addr sim32_effective_addr IFN2(double_word, addr, BOOL, pm)
{
    word seg, off;
    double_word descr_addr;
    DESCR entry;

    seg = (word)(addr>>16);
    off = (word)(addr & 0xffff);

    if (pm == FALSE)
    {
	return ((double_word)seg << 4) + off;
    }
    else
    {
	if ( selector_outside_table(seg, &descr_addr) == 1 )
	{
	/*
	This should not happen, but is a check the real effective_addr
	includes. Return error -1.
	*/
#ifndef PROD
        printf("NTVDM:sim32:effective addr: Error for addr %#x (seg %#x)\n",addr, seg);
        HostDebugBreak();
#endif
            return ((sys_addr)-1);
	}
	else
	{
	    read_descriptor(descr_addr, &entry);
	    return entry.base + off;
	}
    }
}

/********************************************************/
/* Support routines for sim32 above */
GLOBAL sys_addr sim32_effective_addr_ex IFN3(word, seg, double_word, off, BOOL, pm)
{
    double_word descr_addr;
    DESCR entry;

    if (pm == FALSE) {
        return ((double_word)seg << 4) + off;
    } else {
        if ( selector_outside_table(seg, &descr_addr) == 1 ) {
            /*
            This should not happen, but is a check the real effective_addr
            includes. Return error -1.
            */
#ifndef PROD
            printf("NTVDM:sim32:effective addr: Error for addr %#x:%#x)\n", seg, off);
            HostDebugBreak();
#endif
            return ((sys_addr)-1);
        } else {
            read_descriptor(descr_addr, &entry);
            return entry.base + off;
        }
    }
}


/********************************************************/
/* Microsoft extensions to sas interface */
LOCAL IMEMBLOCK *imap_start=NULL, *imap_end=NULL;
GLOBAL IMEMBLOCK *sas_mem_map ()
{
        /* produce a memory map for the whole of intel space */
        sys_addr iaddr;
        int mem_type;

        if (imap_start)
                sas_clear_map();

        for (iaddr=0; iaddr < Length_of_M_area; iaddr++)
        {
                mem_type = sas_memory_type (iaddr);
                if (!imap_end)
                {
                        /* this is the first record */
                        check_malloc (imap_start, 1, IMEMBLOCK);
                        imap_start->Next = NULL;
                        imap_end = imap_start;
                        imap_end->Type = (IU8) mem_type;
                        imap_end->StartAddress = iaddr;
                        continue;
                }
                if (imap_end->Type != mem_type)
                {
                        /* end of a memory section & start of a new one */
                        imap_end->EndAddress = iaddr-1;
                        check_malloc (imap_end->Next, 1,IMEMBLOCK);
                        imap_end = imap_end->Next;
                        imap_end->Next = NULL;
                        imap_end->Type = (IU8) mem_type;
                        imap_end->StartAddress = iaddr;
                }
        }
        /* terminate last record */
        imap_end->EndAddress = iaddr;
        return (imap_start);
}

GLOBAL void sas_clear_map()
{
        IMEMBLOCK *p, *q;
        for (p=imap_start; p; p=q)
        {
                q=p->Next;
                free(p);
        }
        imap_start=imap_end=NULL;
}

/********************************************************/
/* Microsoft specific sas stuff (ie host sas) */

#define SIXTEENMEG 1024*1024*12

LOCAL UTINY *reserve_for_sas = NULL;

#ifndef CPU_40_STYLE

LOCAL sys_addr current_sas_size =0;		/* A local Length_of_M_area */

GLOBAL UTINY *host_sas_init IFN1(sys_addr, size)
{
	UTINY *rez;
	DWORD M_plus_type_size;

        /* allocate 16 MEG of virtual memory */
        if (!reserve_for_sas)
        {
                if (!(reserve_for_sas = (UTINY *)VirtualAlloc ((void *)NULL, SIXTEENMEG,
                        MEM_RESERVE, PAGE_READWRITE)))
                {
#ifndef PROD
                        printf ("NTVDM:Failed to reserve 16 Meg virtual memory for sas\n");
#endif
                        exit (0);
                }
        }

	/* now commit to our size */
	M_plus_type_size = size + NOWRAP_PROTECTION +
			   ((size + NOWRAP_PROTECTION) >> 12);
	rez = (UTINY *)VirtualAlloc ((void *) reserve_for_sas,
				     M_plus_type_size,
				     MEM_COMMIT,
				     PAGE_READWRITE);
	if (rez)
		Length_of_M_area = current_sas_size = size;
	return (rez);

}


GLOBAL UTINY *host_sas_term()
{
        if (!reserve_for_sas)
                return (NULL);

        /* deallocate the reserves */
        VirtualFree (reserve_for_sas, SIXTEENMEG, MEM_RELEASE);

        /* null out reserve pointer */
        reserve_for_sas = NULL;

        Length_of_M_area = current_sas_size = 0;

        return (NULL);
}

GLOBAL UTINY *sas_alter_size IFN1(sys_addr, new)
{
        UTINY *tmp;
        if (!reserve_for_sas)
        {
#ifndef PROD
                printf ("NTVDM:Sas trying to alter size before reserve setup\n");
#endif
                return (NULL);
        }

        /* if we are already at the right size return success */
        if (new == current_sas_size)
        {
                return (reserve_for_sas);
        }

        if (new > current_sas_size)
        {
                /* move to end of current commited area */
                tmp = reserve_for_sas + current_sas_size;
                if (!VirtualAlloc ((void *)tmp, (DWORD)(new - current_sas_size), MEM_COMMIT,
                        PAGE_READWRITE))
                {
                        printf ("NTVDM:Virtual Allocate for resize from %d to %d FAILED!\n",
                                current_sas_size, new);
                        return (NULL);
                }
        }
        else
        {
                /* move to the place where sas needs to end */
                tmp = reserve_for_sas + new;

                /* now decommit the unneeded memory */
                if (!VirtualFree ((void *)tmp, (DWORD)(current_sas_size - new), MEM_DECOMMIT))
                {
                        printf ("NTVDM:Virtual Allocate for resize from %d to %d FAILED!\n",
                                current_sas_size, new);
                        return (NULL);
                }
        }
        Length_of_M_area = current_sas_size = new;
        return (reserve_for_sas);
}



#else /* CPU_40_STYLE */


// Intel space allocation and deallocation control function for the A4 CPU

GLOBAL UTINY *host_sas_init IFN1(sys_addr, size)
{

    /* Initialise memory management system and allocation bottom 1M+64K */
    if(!(Start_of_M_area = InitIntelMemory(size)))
    {
	/* Initialise function failed, exit */
#ifndef PROD
       printf ("NTVDM:Failed to allocate virtual memory for sas\n");
#endif

       exit(0);
    }

    Length_of_M_area = size;
    return(Start_of_M_area);
}


GLOBAL UTINY *host_sas_term()
{
    /* Has any Intel memory been allocated ? */
    if(Start_of_M_area)
    {
	/* Free allocated intel memory and control structures */
	FreeIntelMemory();

	reserve_for_sas = NULL; 	 /* null out reserve pointer */
	Length_of_M_area = 0;
    }

    return(NULL);
}

#endif /* CPU_40_STYLE */

#endif /* SIM32 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\stubs.c ===
#include <windows.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "host_def.h"
#include "insignia.h"
#include "xt.h"
#include "debug.h"
#include "sas.h"
#include "config.h"
#include "ckmalloc.h"

#ifdef X86GFX
#include "egacpu.h"
#include "egaread.h"
#endif

#ifdef MONITOR
GLOBAL void sas_loads_to_transbuf IFN3(sys_addr, src, host_addr, dest, sys_addr, len)
{
        sas_loads (src, dest, len);
}

/* write a string into M */
GLOBAL void sas_stores_from_transbuf IFN3(sys_addr, dest, host_addr, src, sys_addr, len)
{
        sas_stores (dest, src, len);
}

GLOBAL host_addr sas_transbuf_address IFN2(sys_addr, dest_intel_addr, sys_addr, length)
{
        UNUSED (dest_intel_addr);
        return (sas_scratch_address (length));
}
#endif


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: log1p */

#ifndef MONITOR
GLOBAL double log1p(double x)
{
    return log(1+x);
}

#endif /* !MONITOR */


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: SAS wrapping stubs */

#ifdef MONITOR
GLOBAL void npx_reset()
{
    return;
}

GLOBAL void initialise_npx()
{
    return;
}

GLOBAL void sas_overwrite_memory IFN2(sys_addr, addr, int, type)
{
        UNUSED(addr);
        UNUSED(type);
}

LOCAL LONG stub_q_ev_count = 0; // holder for below

/* Monitor controlled code will call quick event code immediately so the
 * following needn't be at all accurate.
 */
void host_q_ev_set_count(LONG value)
{
    stub_q_ev_count = value;
}

LONG host_q_ev_get_count()
{
    return(stub_q_ev_count);
}

int host_calc_q_ev_inst_for_time(LONG time)
{
    return(time);
}

#ifndef CPU_40_STYLE
int host_calc_q_ev_time_for_inst(LONG inst)
{
    return(inst);
}
#endif

////// The following support the major surgery to remove unneeded video stuff

GLOBAL ULONG Gdp;
GLOBAL half_word bg_col_mask = 0x70;    // usually defined in cga.c
GLOBAL READ_STATE read_state;

ULONG sr_lookup[16] =   // Handy array to extract all 4 plane values in one go
{
#ifdef LITTLEND
        0x00000000,0x000000ff,0x0000ff00,0x0000ffff,
        0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff,
        0xff000000,0xff0000ff,0xff00ff00,0xff00ffff,
        0xffff0000,0xffff00ff,0xffffff00,0xffffffff
#endif
#ifdef BIGEND
        0x00000000,0xff000000,0x00ff0000,0xffff0000,
        0x0000ff00,0xff00ff00,0x00ffff00,0xffffff00,
        0x000000ff,0xff0000ff,0x00ff00ff,0xffff00ff,
        0x0000ffff,0xff00ffff,0x00ffffff,0xffffffff
#endif
};

GLOBAL VOID glue_b_write (UTINY *addr, ULONG val)
{
    UNUSED(addr);
    UNUSED(val);
}
GLOBAL VOID glue_w_write (UTINY *addr, ULONG val)
{
    UNUSED(addr);
    UNUSED(val);
}
GLOBAL VOID glue_b_fill (UTINY *laddr, UTINY *haddr, ULONG val)
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(val);
}
GLOBAL VOID glue_w_fill (UTINY *laddr, UTINY *haddr, ULONG val)
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(val);
}
GLOBAL VOID glue_b_move(UTINY *laddr, UTINY *haddr, UTINY *src, UTINY src_type )
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(src);
    UNUSED(src_type);
}
GLOBAL VOID glue_w_move(UTINY *laddr, UTINY *haddr, UTINY *src )
{
    UNUSED(laddr);
    UNUSED(haddr);
    UNUSED(src);
}
GLOBAL VOID glue_b_fwd_move () { }
GLOBAL VOID glue_b_bwd_move () { }
GLOBAL VOID glue_w_fwd_move () { }
GLOBAL VOID glue_w_bwd_move () { }

GLOBAL VOID _ega_gc_outb_mask(io_addr port, half_word value)
{
    UNUSED(port);
    UNUSED(value);
}

GLOBAL VOID _ega_gc_outb_mask_ff(io_addr port, half_word value)
{
    UNUSED(port);
    UNUSED(value);
}

GLOBAL VOID cga_init()
{
}

GLOBAL VOID cga_term()
{
}

GLOBAL VOID _simple_mark_lge()
{
}

GLOBAL VOID _simple_mark_sml()
{
}

GLOBAL int get_ega_switch_setting()
{
    return(0);
}

GLOBAL VOID ega_read_init()     // Do normal inits - ports will do this fully
{
    read_state.mode = 0;
    read_state.colour_compare = 0x0f;
    read_state.colour_dont_care = 0xf;
}

GLOBAL VOID ega_read_term()
{
}

GLOBAL VOID ega_read_routines_update()
{
}

GLOBAL VOID update_shift_count()
{
}

GLOBAL VOID ega_write_init()
{
}

GLOBAL VOID ega_write_term()
{
}

GLOBAL VOID ega_write_routines_update(CHANGE_TYPE reason)
{
    UNUSED(reason);
}

GLOBAL VOID set_mark_funcs()
{
}

GLOBAL ULONG setup_global_data_ptr()
{
    return(0xDefaced);
}

#if defined(NEC_98)
GLOBAL VOID setup_NEC98_globals()
{
    check_malloc(NEC98_CPU.globals, sizeof(NEC98_GLOBALS), char);
}
#else  // !NEC_98
GLOBAL VOID setup_vga_globals()
{
    check_malloc(EGA_CPU.globals, 1, VGA_GLOBALS);
}
#endif // !NEC_98

#endif  //MONITOR





/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: ASSERT CODE */


void _assert(void *exp, void *file, unsigned line)
{
    char linestr[100];

    OutputDebugString("ASSERT FAILED - ");
    OutputDebugString(exp);
    OutputDebugString("  ");
    OutputDebugString(file);

    sprintf(linestr," (%d)\n",line);
    OutputDebugString(linestr);
}

/*:::::::::::::::::::::::::::: Unix specific string functions ::::::::::::::*/

char *index(char *string, int c)
{
    return(strchr(string, c));
}

char *rindex(char *string, int c)
{
    return(strrchr(string, c));
}

/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/

host_mouse_in_use()
{
return(FALSE);
}

void redirector() {}
void reset_delta_data_structures() {}
void set_hfx_severity() {}

host_check_for_lock()
{
    assert0(NO,"host_check_for_lock stubbed\n");
    return(0);
}

host_place_lock(int dummy1)
{
    assert0(NO,"host_place_lock stubbed\n");
    return(0);
}

host_clear_lock(int fd)
{
    assert0(NO,"host_clear_lock stubbed\n");
    return(0);
}


int host_com_send_delay_done(int dummy1, int dummy2)
{
        return(0);
}
#ifndef A2CPU
delta_cpu_test_frag()
{
        assert0(NO,"delta_cpu_test_frag stubbed\n");
        return(0);
}

examine_delta_data_structs(int o, int i)
{
        assert0(NO,"examine_delta_data_structs stubbed\n");
        return(0);
}
code_gen_files_init()
{
        assert0(NO,"code_gen_files_init stubbed\n");
        return(0);
}
decode_files_init()
{
        assert0(NO,"decode_files_init stubbed\n");
        return(0);
}

#ifdef ALPHA

//
// temporary change to get Alpha CPU running
// in checked mode. Andy - 13/1/94
//

double get_287_reg_as_double(int i)
{
        extern char *GDP;
        return(*(double *)(GDP + 0x80 + i * 8));
}
#endif

#ifdef CPU_40_STYLE

GLOBAL BOOL sas_manage_xms IFN3(VOID *,start_addr, ULONG, cb, INT, a_or_f)
{
    printf("sas_manage_xms called(%lx,%lx,%lx)\n",start_addr,cb,a_or_f);
    return (TRUE);
}

#undef sas_loadw
GLOBAL void sas_loadw IFN2(sys_addr, addr, word *, val)
{
    *val = sas_w_at(addr);
}

GLOBAL void host_sigio_event IPT0()
{
}

#endif /* CPU_40_STYLE */

#ifndef GENERIC_NPX
#ifndef CPU_40_STYLE
int get_287_sp()
{
         extern char *GDP;
         return((int) (*(ULONG *)(GDP + 0x70))/8);
}
word get_287_tag_word()
{
         extern char *GDP;
         return((int) *(ULONG *)(GDP + 0x74));
}
word get_287_control_word()
{
         extern char *GDP;
         return((int) *(ULONG *)(GDP + 0x68));
}
word get_287_status_word()
{
         extern char *GDP;
        return((int) *(ULONG *)(GDP + 0x6c));
}
#endif /* CPU_40_STYLE */
#endif /* GENERIC_NPX */
#endif

int     rate_min;
int     rate_max;
int     compiling;
int     rate_delta;
int     show_stuff;
int     stat_rate;
int     compile_off[99];
int     rate_norm;
int     cut_off_level;
int     max_host_fragment_size;
int     delta_err_message[100];
int     last_destination_address;


host_flip_real_floppy_ind()
{
        assert0(NO,"host_flip_real_floppy_ind stubbed\n");
        return(0);
}

#ifndef A2CPU
int     haddr_of_src_string;
int     INTEL_STATUS;
int     R_SI;
int     R_DI;
int     R_BP;
int     R_OPA;
int     R_DEF_SS;
int     R_OPB;
int     R_SP;
int     R_DEF_DS;
int     R_AX;
int     R_BX;
int     R_CX;
int     R_DX;
int     R_IP;
int     R_ACT_CS;
int     R_ACT_SS;
int     R_OPR;
int     R_ACT_DS;
int     R_ACT_ES;
#endif
int     compile_yoda_in;
int     m_s_w;
int     trap_delay_count = 0, temp_trap_flag = 0;
int     cpui;
int     sbp;

host_EOA_hook()
{
        assert0(NO,"host_EOA_hook stubbed\n");
        return(0);
}

getsdosunit()
{
        assert0(NO,"dispatch_q_event stubbed\n");
        return(1);
}

#ifdef NOT_IN_USE
host_check_using_host_mouse()
{
        assert0(NO,"host_check_using_host_mouse stubbed\n");
        return(1);
}
host_deinstall_host_mouse()
{
        assert0(NO,"host_deinstall_host_mouse stubbed\n");
        return(1);
}
#endif

int host_timer_2_frig_factor = 20;

host_check_read_only_drive()
{
        assert0(NO,"host_check_read_only_drive stubbed\n");
        return(0);
}

host_lock_drive_and_make_writable()
{
        assert0(NO,"host_lock_drive_and_make_writable stubbed\n");
        return(1);
}

host_floppy_init()
{
        assert0(NO,"host_floppy_init stubbed\n");
        return(1);
}

SHORT validate_hfx_drive()
{
        assert0(NO,"host_lpt_valid\n");
        return C_CONFIG_OP_OK;
}

SHORT host_keymap_valid()
{
        assert0(NO,"host_keymap_valid\n");
        return C_CONFIG_OP_OK;
}

VOID host_keymap_change()
{
        assert0(NO,"host_keymap_change\n");
}

char *host_strerror(int errno)
{
    assert1(NO,"Error : host_strerror (%d)\n",errno);
    return("****** again\n");
}

int link(void)
{
return -1;
}

LOCAL ULONG   dummy()
{
        return(0);
}

GLOBAL  ULONG    (*clear_v7ptr)() = dummy;
GLOBAL  ULONG    (*paint_v7ptr)() = dummy;

GLOBAL ULONG host_speed IFN1(ULONG, temp)
{
return 10000L;
}

#ifndef MONITOR

// allows getIntelRegistersPointer to be exported bt ntvdm.def
getIntelRegistersPointer()
{
    assert0(NO,"getIntelRegistersPointer stubbed\n");
    return(0);
}

#if  0
// these two crept into WOW - they are x86 monitor'isms

word getEIP()
{
   return(c_getIP());
}

void setEIP(val)
word  val;
{
    c_setIP(val);
}
#endif

int FlatAddress[1];
int Ldt[1];
int VdmTib;
int VdmTibStruct;

void DispatchInterrupts()
{
}

#else //MONITOR

#ifndef YODA
void check_I()
{
}

void force_yoda()
{
    printf("Yoda disabled on x86\n");
}
#endif  //YODA

#endif  //MONITOR


#ifndef MONITOR

//
// davehart 9-Dec-92 HACKHACK
// Build fix -- we export cpu_createthread from ntvdm.exe,
// even though this function from v86\monitor\i386 doesn't
// exist on MIPS.
//
// If we really need to export the function, we may want to
// take the ntoskrnl.src -> obj\i386\ntoskrnl.def approach.
//

VOID
cpu_createthread(
    HANDLE Thread,
    PVDM_TIB VdmTib
    )
/*++

Routine Description:

    This routine adds a thread to the list of threads that could be executing
    in application mode.

Arguments:

    Thread -- Supplies a thread handle

    VdmContext -- Supplies a pointer to a vdm context

Return Value:

    None.

--*/
{
}

#endif // ndef MONITOR

#ifndef MONITOR
ULONG CurrentMonitorTeb;
#endif

void host_note_queue_added()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\obj.vdm\cdefine.inc ===
# Check for Checked (dev) or Free (PROD) builds.

!IF $(FREEBUILD)

SPC_VAR=-DPROD

!ELSE

!IF "$(PIG)" == ""

!IF "$(HUNTER)" == ""

SPC_VAR=

!ELSE

SPC_VAR=-DHUNTER

!ENDIF

!ELSE

SPC_VAR=-DPIG

!ENDIF

!ENDIF


SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

# Set machine specific variables. Differences are for X86 vs. RISC

!IF $(386)

!IF "$(ALT_PROJECT)" == "NEC_98"
SPC_MC_DEF=   -DMONITOR \
              -DC_VID   \
              -DX86GFX
!ELSE

SPC_MC_DEF=   -DMONITOR \
              -DC_VID   \
              -DX86GFX  \
              -DARCX86
!ENDIF

!ELSE

# not an X86.  At this point, all RISC architectures have the same defines.

!IF "$(CCPU)" == ""
CPU_DEFS=     -DCPU_40_STYLE
!ELSE
CPU_DEFS=     -DCPU_40_STYLE  -DCCPU -DC_VID
!ENDIF

SPC_MC_DEF=   $(CPU_DEFS) \
	      -DNEW_CPU \
              -DSPC386 \
              -DSIM32 \
	      -DV7VGA




#Amend include path to include CPU build system generated files
!IF $(FREEBUILD)
CPU_INCLUDES=$(SOFTPC_TREE)\host\inc\$(PROCESSOR_ARCHITECTURE)\prod
!else
CPU_INCLUDES=$(SOFTPC_TREE)\host\inc\$(PROCESSOR_ARCHITECTURE)\pig
!endif

INCLUDES=$(CPU_INCLUDES);$(INCLUDES)

!ENDIF

C_DEFINES= $(SPC_VAR) $(SPC_MC_DEF) $(C_DEFINES) -DANSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\obj.vdm\c_regs.c ===
#ifndef MONITOR

//
// temp file for Assembler CPU which provides a simple C cpu -> A cpu register
// mapping for MS libraries (DEM/WOW32/XMS) which are linked for ccpu register
// gets & sets. STF.

#include "host_def.h"
#include "insignia.h"
#include "xt.h"
#include CpuH

#ifdef A3CPU

#ifndef CCPU
half_word c_getAL()
{
    half_word xal;    //pedantic method put in to check compiler correct etc...
    xal = a3_getAL();
    return(xal);
}

half_word c_getAH()
{
    half_word xah;
    xah = a3_getAH();
    return(xah);
}

word c_getAX()
{
    word xax;
    xax = a3_getAX();
    return(xax);
}

half_word c_getBL()
{
    half_word xbl;
    xbl = a3_getBL();
    return(xbl);
}

half_word c_getBH()
{
    half_word xbh;
    xbh = a3_getBH();
    return(xbh);
}

word c_getBP()
{
    word xbp;
    xbp = a3_getBP();
    return(xbp);
}

word c_getBX()
{
    word xbx;
    xbx = a3_getBX();
    return(xbx);
}

INT c_getCF()
{
    INT xcf;

    xcf = a3_getCF();
    return(xcf);
}

half_word c_getCH()
{
    half_word xch;
    xch = a3_getCH();
    return(xch);
}

half_word c_getCL()
{
    half_word xcl;
    xcl = a3_getCL();
    return(xcl);
}

word c_getCS()
{
    word xcs;
    xcs = a3_getCS();
    return(xcs);
}

word c_getCX()
{
    word xcx;
    xcx = a3_getCX();
    return(xcx);
}

half_word c_getDH()
{
    half_word xdh;
    xdh = a3_getDH();
    return(xdh);
}

word c_getDI()
{
    word xdi;
    xdi = a3_getDI();
    return(xdi);
}

half_word c_getDL()
{
    half_word xdl;
    xdl = a3_getDL();
    return(xdl);
}

word c_getDS()
{
    word xds;
    xds  = a3_getDS();
    return(xds);
}

word c_getDX()
{
    word xdx;
    xdx = a3_getDX();
    return(xdx);
}

word c_getES()
{
    word xes;
    xes = a3_getES();
    return(xes);
}

word c_getSI()
{
    word xsi;
    xsi = a3_getSI();
    return(xsi);
}

word c_getSP()
{
    word xsp;
    xsp = a3_getSP();
    return(xsp);
}

word c_getIP()
{
    word xip;
    xip = a3_getIP();
    return(xip);
}

word c_getSS()
{
    word xss;
    xss = a3_getSS();
    return(xss);
}

word c_getGS()
{
#ifndef PROD
    printf("NO NO NO NO NO getGS - I'm not a 386\n");
#endif
    return(0);
}

word c_getFS()
{
#ifndef PROD
    printf("NO NO NO NO NO getFS - I'm not a 386\n");
#endif
    return(0);
}

word c_getAF()
{
    return(a3_getAF());
}

word c_getDF()
{
    return(a3_getDF());
}

word c_getIF()
{
    return(a3_getIF());
}

word setMSW()
{
    return(a3_p_setMSW());
}

word c_getOF()
{
    return(a3_getOF());
}

word c_getPF()
{
    return(a3_getPF());
}

word c_getSF()
{
    return(a3_getSF());
}

word c_getZF()
{
    return(a3_getZF());
}
void c_setAL(val)
half_word val;
{
    a3_setAL(val);
}

void c_setAH(val)
half_word val;
{
    a3_setAH(val);
}

void c_setAX(val)
word val;
{
    a3_setAX(val);
}

void c_setBP(val)
word val;
{
    a3_setBP(val);
}

void c_setBL(val)
half_word val;
{
    a3_setBL(val);
}

void c_setBH(val)
half_word val;
{
    a3_setBH(val);
}

void c_setBX(val)
word val;
{
    a3_setBX(val);
}

void c_setCF(val)
INT val;
{
    a3_setCF(val);
}

void c_setCH(val)
half_word val;
{
    a3_setCH(val);
}

void c_setCL(val)
half_word val;
{
    a3_setCL(val);
}

void c_setCX(val)
word val;
{
    a3_setCX(val);
}

void c_setDH(val)
half_word val;
{
    a3_setDH(val);
}

void c_setDL(val)
half_word val;
{
    a3_setDL(val);
}

void c_setDX(val)
word val;
{
    a3_setDX(val);
}

void c_setSI(val)
word val;
{
    a3_setSI(val);
}

void c_setDI(val)
word val;
{
    a3_setDI(val);
}


void c_setAF(word val)
{
    a3_setAF(val);
}

void c_setIF(word val)
{
    a3_setIF(val);
}

void c_setOF(word val)
{
    a3_setOF(val);
}

void c_setPF(word val)
{
    a3_setPF(val);
}

void c_setSF(word val)
{
    a3_setSF(val);
}

void c_setMSW(word val)
{
    a3_p_setMSW(val);
}

void c_setZF(word val)
{
    a3_setZF(val);
}

void c_setIP(word val)
{
    a3_setIP(val);
}

void c_setDF(word val)
{
    a3_setDF(val);
}
void c_setSP(val)
word val;
{
    a3_setSP(val);
}

INT c_setSS(val)
word val;
{
    return(a3_setSS(val));
}

INT c_setES(val)
word val;
{
    return(a3_setES(val));
}

INT c_setDS(val)
word val;
{
    return(a3_setDS(val));
}

INT c_setCS(val)
word val;
{
    return(a3_setCS(val));
}

INT c_setGS(val)
word val;
{
#ifndef PROD
    printf("NO NO NO NO NO setGS - I'm not a 386\n");
#endif
    return(0);
}

INT c_setFS(val)
word val;
{
#ifndef PROD
    printf("NO NO NO NO NO setFS - I'm not a 386\n");
#endif
    return(0);
}
#endif /* CCPU */


// these two crept into WOW - they are x86 monitor'isms

word getEIP()
{
   return(a3_getIP());
}

void setEIP(val)
word  val;
{
    a3_setIP(val);
}

#endif	// A3CPU
#endif  // !MONITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\suballoc\debug.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\host\src\x86_emm.c ===
/*                      INSIGNIA MODULE SPECIFICATION
                        -----------------------------

MODULE NAME     : 'Lower layer' of Expanded Memory Manager

        THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
        CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
        NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
        AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER        : Simon Frost
DATE            : March '92

PURPOSE         : NT specific code for EMS LIM rev 4.0
                implementation.

The Following Routines are defined:
                1. host_initialise_EM()
                2. host_deinitialise_EM()
                3. host_allocate_storage()
                4. host_free_storage()
                5. host_reallocate_storage()
                6. host_map_page()
                7. host_unmap_page()
                8. host_alloc_page()
                9. host_free_page()
                10. host_copy_con_to_con()
                11. host_copy_con_to_EM()
                12. host_copy_EM_to_con()
                13. host_copy_EM_to_EM()
                14. host_exchg_con_to_con()
                15. host_exchg_con_to_EM()
                16. host_exchg_EM_to_EM()
                17. host_get_access_key()

=========================================================================
*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "insignia.h"
#include "host_def.h"
#include "string.h"
#include "stdlib.h"

#ifdef LIM
#ifdef MONITOR  //x86 specific LIM functions

#include "xt.h"
#include "emm.h"
#include "sas.h"
#include "host_rrr.h"
#include "debug.h"
#include "umb.h"
#include "host_emm.h"
#include "nt_uis.h"

/*      Global Variables                */

/*      Forward Declarations            */
BOOL hold_lim_page(USHORT segment);
/* find this function in monitor/sas.c */
extern BOOL HoldEMMBackFillMemory(ULONG Address, ULONG Size);


/*      Local Variables                 */

LOCAL   UTINY *EM_pagemap_address = NULL;     /* address of start of pagemap */

/* pagemap requires 1 bit per 16K page - i.e. 8 bytes per meg   */
LOCAL UTINY EM_pagemap[8*32];

LOCAL VOID *BaseOfLIMMem = NULL;        // start of expanded memory
ULONG HolderBlockOffset;	// holder block offset

LOCAL HANDLE LIMSectionHandle;
LOCAL HANDLE processHandle = NULL;

LOCAL ULONG X86NumRoms = 0;

#define PAGE_SEG_SIZE	0x400	/* size of page expressed as segment */

#define CONFIG_DATA_STRING L"Configuration Data"
#define KEY_VALUE_BUFFER_SIZE 2048

#define EMMBASE 0xd0000
#define EMMTOP  0xe0000

#define SECTION_NAME        L"\\BaseNamedObjects\\LIMSection"
#define SECTION_NAME_LEN    sizeof(SECTION_NAME)

typedef struct _BIOS_BLOCK {
    ULONG PhysicalAddress;
    ULONG SizeInByte;
} BIOS_BLOCK;


/*
Defines are:
        EM_loads(from, to, length), copies length bytes from intel 24 bit
                address from, to host 32 bit address to
        EM_stores(to, from, length), copies length bytes from host 32 bit
                address from to intel 24 bit address to
        EM_moves(from, to, length), copies length bytes from intel 24 bit
                address from to intel 24 bit address to
        EM_memcpy(to, from, length), copies length bytes from host 32 bit
                address from to host 32 bit address to
*/


#define EM_loads(from, to, length) memcpy(to, get_byte_addr(from), length)
#define EM_stores(to, from, length) \
        RtlCopyMemory(get_byte_addr(to), from, length)
#define EM_moves(from,to,length) \
        RtlMoveMemory(get_byte_addr(to), get_byte_addr(from), length)
#define EM_memcpy(to, from, length) \
        RtlMoveMemory(to, from, length)

/*
===========================================================================

FUNCTION        : host_initialise_EM

PURPOSE         : allocates the area of memory that is used for
                expanded memory and sets up an area of memory to be used
                for the logical pagemap allocation table.


RETURNED STATUS : SUCCESS - memory allocated successfully
                  FAILURE - unable to allocate required space

DESCRIPTION     :


=========================================================================
*/
int host_initialise_EM(short size)
/*   IN short   size             size of area required in megabytes     */
{
    UTINY *pagemap_ptr;         /* temp ptr. to logical pagemap */
    int i;                              /* loop counter                 */
    NTSTATUS status;
    OBJECT_ATTRIBUTES objAttribs;
    LARGE_INTEGER secSize;
    ULONG viewSize;
    USHORT  PageSegment, Pages;
    LONG	 EM_size;

    SAVED UNICODE_STRING LIMSectionName =
    {
        SECTION_NAME_LEN,
        SECTION_NAME_LEN,
        SECTION_NAME
    };


    /* Nobody should call this function with size 0 */
    ASSERT(size != 0);

    EM_pagemap_address = &EM_pagemap[0];

    /* initialise pagemap to 0's        */

    pagemap_ptr = EM_pagemap_address;
    for(i = 0; i < 8*32; i++)
        *pagemap_ptr++ = 0;

    EM_size = ((long) size) * 0x100000;

    if (!(processHandle = NtCurrentProcess()))
    {
        assert0(NO, "host_initialise_EM: cant get process handle");
        return(FAILURE);
    }

    // create section for LIM

    /* Fill the fields of the OBJECT_ATTRIBUTES structure. */
    InitializeObjectAttributes(&objAttribs,
                            NULL, // was &LIMSectionName, but null means private
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

    /* Create the section. EMM_PAGE_SIZE for holder page */
    secSize.LowPart = EM_size + EMM_PAGE_SIZE;
    secSize.HighPart = 0;
    HolderBlockOffset = EM_size;

    // improvement - just reserve  & commit as needed...
    status = NtCreateSection(&LIMSectionHandle,
                                    SECTION_MAP_WRITE|SECTION_MAP_EXECUTE,
                                    &objAttribs,
                                    &secSize,
                                    PAGE_EXECUTE_READWRITE,
                                    SEC_COMMIT,
                                    NULL);
    if (!NT_SUCCESS(status))
    {
        assert1(NO, "host_initialise_EM: LIM section creation failed (%x)", status);
        return(FAILURE);
    }

    /* Map the section to the process' address space. */
    BaseOfLIMMem = NULL;
    viewSize = 0;

    status = NtMapViewOfSection(LIMSectionHandle,
                                       processHandle,
                                       (PVOID *) &BaseOfLIMMem,
                                       0,
                                       0,
                                       NULL,
                                       &viewSize,
                                       ViewUnmap,
                                       0,       // do we need mem_top_down??
                                       PAGE_READWRITE);
    if (!NT_SUCCESS(status))
    {
        assert1(NO, "host_initialise_EM: can't map view of LIM section (%x)", status);
        return(FAILURE);
    }

    /* acquire page frame addresss space from UMB list */
    if (!GetUMBForEMM()) {
	host_deinitialise_EM();
	return FAILURE;
    }

    /* attach page to holder so that we won't get killed if applications
     * try to touch the page frames without mapping
     */

    for (Pages = get_no_phys_pages();  Pages  ; Pages--) {
	PageSegment = get_page_seg((unsigned char)(Pages - 1));
	if (PageSegment <= 640 * 1024 / 16)
	    continue;
	if (!hold_lim_page(PageSegment))
	    return FAILURE;

    }
    return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_deinitialise_EM

PURPOSE         : frees the area of memory that was used for
                expanded memory and memory  used
                for the logical pagemap allocation table.


RETURNED STATUS : SUCCESS - memory freed successfully
                  FAILURE - error ocurred in freeing memory

DESCRIPTION     :


=========================================================================
*/
int host_deinitialise_EM()
{
    ULONG len = 0x10000;
    NTSTATUS status;

    if (BaseOfLIMMem != NULL)
    {
        if (processHandle == NULL)
        {
	    //As shutting down anyway then fail silently
            return(FAILURE);
        }

        // lose section from our memory space
        status = NtUnmapViewOfSection(processHandle, BaseOfLIMMem);
        if (!NT_SUCCESS(status))
        {
	    //As shutting down anyway then fail silently
            return(FAILURE);
        }

        status = NtClose(LIMSectionHandle);     // delete section
        if (!NT_SUCCESS(status))
        {
	    //As shutting down anyway then fail silently
            return(FAILURE);
        }

        return(SUCCESS);
    } else {
        return FAILURE;
    }
}



/*
===========================================================================

FUNCTION        : host_allocate_storage

PURPOSE         : allocates an area of memory of requested size, to be
                used as a general data storage area. The area is
                to zeros.

RETURNED STATUS : storage_ID - (in this case a pointer)
                 NULL - failure to allocate enough space.


DESCRIPTION     : returns memory initialised to zeros.
                The storage ID returned is a value used to later reference
                the storage area allocated. The macro USEBLOCK in
                "host_emm.h" is used by the manager routines to convert
                this ID into a char pointer

=========================================================================
*/
long host_allocate_storage(int no_bytes)
/*   IN  int    no_bytes                        no. of bytes required   */
{
        // should replace this (?) - dissasembling calloc seems to
        // indicate it uses win funx...
        return ((long)calloc(1, no_bytes));
}


/*
===========================================================================

FUNCTION        : host_free_storage

PURPOSE         : frees the area of memory that was used for
                data storage


RETURNED STATUS : SUCCESS - memory freed successfully
                  FAILURE - error ocurred in freeing memory

DESCRIPTION     : In this implementation storage_ID is simply a pointer


=========================================================================
*/
int host_free_storage(long storage_ID)
/*   IN  long   storage_ID                      ptr to area of memory   */
{
        if(storage_ID != (long)NULL)
                free((char *)storage_ID);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_reallocate_storage

PURPOSE         : increases the size of memory allocated, maintaining the
                contents of the original memory block


RETURNED STATUS : storage_ID - memory reallocated successfully
                  NULL - error ocurred in reallocating memory

DESCRIPTION     : In this implementation storage_ID is simply a pointer
                Note the value of storage_ID returned may or may not be the
                same as the value given

=========================================================================
*/
long host_reallocate_storage(LONG storage_ID, int size, int new_size)
/*
    IN
long    storage_ID       ptr to area of memory
int     size             original size - not used in this version
        new_size         new size required
*/
{
        return((long)realloc((char *)storage_ID, new_size));
}


/*
===========================================================================

FUNCTION        : hold_lim_page

PURPOSE         : Puts some memory in one of the LIM page gaps in 16 bit
		  memory. Ensures nothing else in the process gets that
		  via malloc.


RETURNED STATUS : TRUE - mapping OK.

DESCRIPTION     : Mapping achieved by mapping correct page from section into
                  Intel memory
=========================================================================
*/
BOOL hold_lim_page(USHORT segment)
/*   IN
int page	page (0-3) of LIM gap
*/

{
    PVOID to;
    LARGE_INTEGER sec_offset;
    ULONG viewSize;
    NTSTATUS status;

    if (BaseOfLIMMem != NULL)
    {
	to = (PVOID)effective_addr(segment, (word)0);

	sec_offset.LowPart = HolderBlockOffset;
        sec_offset.HighPart = 0;

        viewSize = EMM_PAGE_SIZE;

	status = NtMapViewOfSection(LIMSectionHandle,
                                processHandle,
                                &to,
                                0,
                                EMM_PAGE_SIZE,
                                &sec_offset,
                                &viewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE);
        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FALSE);
        }
        return(TRUE);
    }
    return(FALSE);
}


/*
===========================================================================

FUNCTION        : host_map_page

PURPOSE         : produces mapping from an Expanded Memory page to a
                page in Intel physical address space


RETURNED STATUS : SUCCESS - mapping completed succesfully
                  FAILURE - error ocurred in mapping

DESCRIPTION     : Mapping achieved by mapping correct page from section into
                  Intel memory
=========================================================================
*/
int host_map_page(SHORT EM_page_no, USHORT segment)
/*   IN
short           EM_page_no      Expanded Memory page to be mapped in
unsigned short  segment;        segment in physical address space to map into
*/

{
    PVOID to;
    int tstpage;
    LARGE_INTEGER sec_offset;
    ULONG viewSize;
    NTSTATUS status;

    note_trace2(LIM_VERBOSE,"map page %d to segment 0x%4x", EM_page_no, segment);
#ifdef EMM_DEBUG
	printf("host_map_page, segment=%x, EMpage=%x\n",
		segment, EM_page_no);
#endif

    if (BaseOfLIMMem != NULL)
    {
        to = (PVOID)effective_addr(segment, 0);

        sec_offset.LowPart = EM_page_no * EMM_PAGE_SIZE;
        sec_offset.HighPart = 0;

        viewSize = EMM_PAGE_SIZE;

        tstpage = (segment - get_base_address()) >> 10;

	/* detach from EMM page section */
        status = NtUnmapViewOfSection(processHandle, (PVOID)to);
        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FALSE);
        }

        if (processHandle == NULL)
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,0,__FILE__,__LINE__);
            return(FAILURE);
        }

	/* attach to the section */
        status = NtMapViewOfSection(LIMSectionHandle,
                                    processHandle,
                                    &to,
                                    0,
                                    EMM_PAGE_SIZE,
                                    &sec_offset,
                                    &viewSize,
                                    ViewUnmap,
                                    MEM_DOS_LIM,
                                    PAGE_EXECUTE_READWRITE
                                    );

        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FAILURE);
        }
        return(SUCCESS);
    }
    return(FAILURE);
}

/*
===========================================================================

FUNCTION        : host_unmap_page

PURPOSE         :unmaps pages from Intel physical address space to an
                Expanded Memory page

RETURNED STATUS : SUCCESS - unmapping completed succesfully
                  FAILURE - error ocurred in mapping

DESCRIPTION     : Unmapping achieved by unampping view of section from
                  Intel memory

=========================================================================
*/
int host_unmap_page(USHORT segment, SHORT EM_page_no)
/*   IN
unsigned short  segment         Segment in physical address space to unmap.
short           EM_page_no      Expanded Memory page currently mapped in
*/
{
        PVOID from;
        NTSTATUS status;
	unsigned short phys_page_no;

        note_trace2(LIM_VERBOSE,"unmap page %d from segment 0x%.4x\n",EM_page_no,segment);


        from = (PVOID)effective_addr(segment, 0);

#ifdef EMM_DEBUG
	printf("host_unmap_page, segment=%x, EMpage=%x\n",
		segment, EM_page_no);
#endif

	/* detach from the LIM section */
        status = NtUnmapViewOfSection(processHandle, from);
        if (!NT_SUCCESS(status))
        {
            DisplayErrorTerm(EHS_FUNC_FAILED,status,__FILE__,__LINE__);
            return(FAILURE);
        }

	/* hold the block to avoid AV when applications touch unmapped pages */
	if (segment < 640 * 1024 / 16) {
	    if (!HoldEMMBackFillMemory(segment * 16, EMM_PAGE_SIZE))
		return FAILURE;
	}
	else {

	    if (!hold_lim_page(segment)) {
		note_trace1(LIM_VERBOSE, "couldn't hold lim page %d",get_segment_page_no(segment));
		return FAILURE;
	    }
	}
        return(SUCCESS);
}

/*
===========================================================================

FUNCTION        : host_alloc_page

PURPOSE         : searches the pagemap looking for a free page, allocates
                that page and returns the EM page no.

RETURNED STATUS :
                  SUCCESS - Always see note below

DESCRIPTION     : Steps through the Expanded memory Pagemap looking for
                a clear bit, which indicates a free page. When found,
                sets that bit and returns the page number.
                For access purposes the pagemap is divided into long
                word(32bit) sections

NOTE            : The middle layer calling routine (alloc_page()) checks
                that all pages have not been allocated and therefore in
                this implementation the returned status will always be
                SUCCESS.
                However alloc_page still checks for a return status of
                SUCCESS, as some implementations may wish to allocate pages
                dynamically and that may fail.
=========================================================================
*/
SHORT host_alloc_page()
{
        SHORT EM_page_no;               /* page number returned         */
        LONG  *ptr;                     /* ptr to 32 bit sections in    */
                                        /* pagemap                      */
        SHORT i;                        /* index into 32 bit section    */

        ptr = (LONG *)EM_pagemap_address;
        i =0;
        EM_page_no = 0;

        while(*ptr & (MSB >> i++))
        {
                EM_page_no++;

                if(i == 32)
                /*
                 * start on next section
                 */
                {
                        ptr++;
                        i = 0;
                }
        }
        /*
         * Set bit to show that page is allocated
         */
        *ptr = *ptr | (MSB >> --i);

        return(EM_page_no);
}


/*
===========================================================================

FUNCTION        : host_free_page

PURPOSE         : marks the page indicated as being free for further
                allocation

RETURNED STATUS :
                SUCCESS - Always - see note below

DESCRIPTION     : clears the relevent bit in the pagemap.

                For access purposes the pagemap is divided into long
                word(32bit) sections.

NOTE            : The middle layer calling routine (free_page()) always
                checks for invalid page numbers so in this implementation
                the routine will always return SUCCESS.
                However free_page() still checks for a return of SUCCESS
                as other implementations may wish to use it.
=========================================================================
*/
int host_free_page(SHORT EM_page_no)
/*   IN SHORT   EM_page_no      page number to be cleared       */
{
        LONG  *ptr;                     /* ptr to 32 bit sections in    */
                                        /* pagemap                      */
        SHORT i;                        /* index into 32 bit section    */

        /*
         * Set pointer to correct 32 bit section and index to correct bit
         */

        ptr = (long *)EM_pagemap_address;
        ptr += (EM_page_no / 32);
        i = EM_page_no % 32;

        /*
         * clear bit
         */
        *ptr = *ptr & ~(MSB >> i);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_copy routines
                host_copy_con_to_con()
                host_copy_con_to_EM()
                host_copy_EM_to_con()
                host_copy_EM_to_EM()

PURPOSE         : copies between conventional and expanded memory


RETURNED STATUS :
                SUCCESS - Always - see note below

DESCRIPTION     :
                 The middle layer calling routine always checks for a
                return of SUCCESS as other implementations may
                return FAILURE.
=========================================================================
*/
int host_copy_con_to_con(int length, USHORT src_seg, USHORT src_off, USHORT dst_seg, USHORT dst_off)

/*   IN
int             length          number of bytes to copy

USHORT  src_seg         source segment address
        src_off         source offset address
        dst_seg         destination segment address
        dst_off         destination offset address
*/
{
        sys_addr from, to;      /* pointers used for copying    */

        from = effective_addr(src_seg, src_off);
        to = effective_addr(dst_seg, dst_off);

        EM_moves(from, to, length);

        return(SUCCESS);
}

int host_copy_con_to_EM(int length, USHORT src_seg, USHORT src_off, USHORT dst_page, USHORT dst_off)

/*   IN
int             length   number of bytes to copy

USHORT  src_seg         source segment address
        src_off         source offset address
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        UTINY *to;
        sys_addr from;

        from = effective_addr(src_seg, src_off);
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_loads(from, to, length);

        return(SUCCESS);
}

int host_copy_EM_to_con(int length, USHORT src_page, USHORT src_off, USHORT dst_seg, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_page        source page number
        src_off         source offset within page
        dst_seg         destination segment address
        dst_off         destination offset address
*/
{
        UTINY  *from;
        sys_addr to;

        from = (char *)BaseOfLIMMem + (src_page * EMM_PAGE_SIZE + src_off);
        to = effective_addr(dst_seg, dst_off);

        EM_stores(to, from, length);

        return(SUCCESS);
}

int host_copy_EM_to_EM(int length, USHORT src_page, USHORT src_off, USHORT dst_page, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_page        source page number
        src_off         source offset within page
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        unsigned char *from, *to;       /* pointers used for copying    */

        from = (char *)BaseOfLIMMem + src_page * EMM_PAGE_SIZE + src_off;
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_memcpy(to, from, length);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_exchange routines
                host_exchg_con_to_con()
                host_exchg_con_to_EM()
                host_exchg_EM_to_EM()

PURPOSE         : exchanges data between conventional and expanded memory


RETURNED STATUS :
                SUCCESS - Everything ok
                FAILURE - Memory allocation failure

DESCRIPTION     :

=========================================================================
*/
int host_exchg_con_to_con(int length, USHORT src_seg, USHORT src_off, USHORT dst_seg, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_seg          source segment address
        src_off          source offset address
        dst_seg          destination segment address
        dst_off          destination offset address
*/
{
        UTINY *temp, *pointer;/* pointers used for copying      */
        sys_addr to, from;

        if (length <= 64*1024)
            temp = sas_scratch_address(length);
        else
            if ((temp = (unsigned char *)host_malloc(length)) == NULL)
                return(FAILURE);

        pointer = temp;

        from = effective_addr(src_seg, src_off);
        to = effective_addr(dst_seg, dst_off);

	EM_loads(from, pointer, length);    /* source -> temp */
	EM_moves(to, from, length);	    /* dst -> source */
	EM_stores(to, pointer, length);     /* temp -> dst */

        if (length > 64*1024)
            host_free(temp);

        return(SUCCESS);
}

int host_exchg_con_to_EM(int length, USHORT src_seg, USHORT src_off, USHORT dst_page, USHORT dst_off)
/*   IN
int     length          number of bytes to copy

USHORT  src_seg         source segment address
        src_off         source offset address
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        UTINY *to, *temp, *pointer;/* pointers used for copying */
        sys_addr from;

        //STF - performance improvement: if 4k aligned & >= 4k then can use
        // (un)mapview to do exchange.

        if (length <= 64*1024)
            temp = sas_scratch_address(length);
        else
            temp = (unsigned char *)host_malloc(length);

        if (!temp)
            return(FAILURE);

        pointer = temp;

        from = effective_addr(src_seg, src_off);
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_loads(from, pointer, length);
        EM_stores(from, to, length);
        EM_memcpy(to, pointer, length);

        if (length > 64*1024)
            host_free(temp);

        return(SUCCESS);
}

int host_exchg_EM_to_EM(int length, USHORT src_page, USHORT src_off, USHORT dst_page, USHORT dst_off)
/*   IN
int     length  number of bytes to copy

USHORT  src_page        source page number
        src_off         source offset within page
        dst_page        destination page number
        dst_off         destination offset within page
*/
{
        UTINY *from, *to, *temp, *pointer; /* pointers used for copying */

        if (length <= 64*1024)
            temp = sas_scratch_address(length);
        else
            temp = (unsigned char *)host_malloc(length);
       
        if (!temp)
            return(FAILURE);

        pointer = temp;

        from = (char *)BaseOfLIMMem + src_page * EMM_PAGE_SIZE + src_off;
        to = (char *)BaseOfLIMMem + dst_page * EMM_PAGE_SIZE + dst_off;

        EM_memcpy(pointer, from, length);
        EM_memcpy(from, to, length);
        EM_memcpy(to, pointer, length);

        if (length > 64*1024)
            host_free(temp);

        return(SUCCESS);
}


/*
===========================================================================

FUNCTION        : host_get_access_key

PURPOSE         : produces a random access key for use with LIM function 30
                'Enable/Disable OS/E Function Set Functions'

RETURNED STATUS : none

DESCRIPTION     : Two 16 bit random values are required for the 'access key'
                We use the microsecond field from the get time of day routine
                to provide this.

=========================================================================
*/
void host_get_access_key(USHORT access_key[2])
/*  OUT USHORT  access_key[2]   source segment address          */
{
        // do you think we need to seed the random # gen?
        access_key[0] = rand() & 0xffff;
        access_key[1] = rand() & 0xffff;

        return;
}
#endif /* MONITOR */
#endif /* LIM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\obj.vdm\imlibdep.c ===
//
// imlibdep.c  -- Dummy C file to include in SOURCES
//                so that build.exe will build ntvdm.lib
//                import library during compile pass,
//                ensuring MP builds don't break linking
//                wow32 or VDDs before ntvdm.lib is built
//                (in the link phase).
//

#if 0                 // build doesn't pay attention to this
#include "ntvdm.src"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\rename\rename.c ===
/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Include files */

#include "windows.h"

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#define MAX_NAME_SIZE   (8)
#define MAX_EXT_SIZE    (3)

char CharRemoveList[] = "AEIOUaeiou_";

int ConvertFileName(char *NameToConvert);

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::: Main entry point */

__cdecl main(int argc, char *argv[])
{
    int index;

    /*......................................... Validate input parameters */

    if(argc < 2)
    {
        printf("Invalid usage : rename <filenames>\n");
        return(1);
    }


    for(index = 1; index < argc; index++)
        ConvertFileName(argv[index]);

    return(0);
}


/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: */

int ConvertFileName(char *NameToConvert)
{
    char *Name, *Ext, *ExtStart;
    int NameSize, ExtSize;
    char NewName[MAX_NAME_SIZE+1], NewFileName[1000];
    char *NewNamePtr;
    
    /*....................... Get the size of the file name and extension */

    for(Name = NameToConvert, NameSize = 0;
        *Name && *Name != '.';  Name++, NameSize++);

    for(ExtStart = Name, Ext = *Name == '.' ? Name+1 : Name, ExtSize = 0;
        *Ext ; Ext++, ExtSize++);

    /*................................ Validate name and extension sizes */

    if(ExtSize > MAX_EXT_SIZE) 
    {
        printf("Unable to convert '%s' to 8.3 filename\n", NameToConvert);
        return(1); 
    }


    if(NameSize <= MAX_NAME_SIZE)
    {
        /* Name does not need conversion */
        return(0);
    }

    /*................................................ Convert file name */

    NewNamePtr = &NewName[MAX_NAME_SIZE];
    *NewNamePtr-- = 0;

    do
    {
        Name--;

        if(NameSize > MAX_NAME_SIZE && strchr(CharRemoveList, *Name))
            NameSize--;         /* Remove character */
        else
            *NewNamePtr-- = *Name;
    }
    while(NewNamePtr >= NewName && Name !=  NameToConvert);

    /*............................................. Validate conversion */

    if(NameSize > MAX_NAME_SIZE) 
    {
        printf("Unable to convert '%s' to 8.3 filename\n", NameToConvert);
        return(1);
    }

    sprintf(NewFileName,"%s%s", NewNamePtr+1, ExtStart);
    printf("REN '%s' to '%s'\n", NameToConvert, NewFileName);
    rename(NameToConvert, NewFileName);

    return(0);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\obj.vdm\ntvdm.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include "insignia.h"
#include "host_def.h"
#include <stdlib.h>
#include "xt.h"
#include "error.h"
#include "host_rrr.h"
#include "host_nls.h"
#include "nt_timer.h"



void CpuEnvInit(void);

typedef struct _CpuEnvironmentVariable {
    struct _CpuEnvironmentVariable *Next;
    char *Data;
    char Name[1];
} CPUENVVAR, *PCPUENVVAR;

PCPUENVVAR CpuEnvVarListHead=NULL;

#if DBG
BOOLEAN verboseGetenv;
#endif


INT host_main(INT argc, CHAR **argv);  // located in base\support\main.c

__cdecl main(int argc, CHAR ** argv)
{
   int ret=-1;

    /*
     *  Intialize synchronization events for the timer\heartbeat
     *  so that we can always suspend the heartbeat when an exception
     *  occurs.
     */
    TimerInit();



    try {

        CpuEnvInit();

        /*
         *  Load in the default system error message, since a resource load
         *  will fail when we are out of memory, if this fails we must exit
         *  to avoid confusion.
         */
        nls_init();

        ret = host_main(argc, argv);
        }
    except(VdmUnhandledExceptionFilter(GetExceptionInformation())) {
        ;  // we shouldn't arrive here
        }

    return ret;
}






//
// The following function is placed here, so build will resolve references to
// DbgBreakPoint here, instead of NTDLL.
//

VOID
DbgBreakPoint(
    VOID
    )
/*++

Routine Description:

    This routine is a substitute for the NT DbgBreakPoint routine.
    If a user mode debugger is atached we invoke the real DbgBreakPoint()
    thru the win32 api DebugBreak.

    If no usermode debugger is attached:
       - free build no effect
       - checked build raise an acces violation to invoke the system
         hard error popup which will give user a chance to invoke
         ntsd.

Arguments:

    None.

Return Value:

    None.

--*/
{
HANDLE      MyDebugPort;
DWORD       dw;

         // are we being debugged ??
     dw = NtQueryInformationProcess(
                  NtCurrentProcess(),
                  ProcessDebugPort,
                  &MyDebugPort,
                  sizeof(MyDebugPort),
                  NULL );
     if (!NT_SUCCESS(dw) || MyDebugPort == NULL)  {
#ifndef PROD
           RaiseException(STATUS_ACCESS_VIOLATION, 0L, 0L, NULL);
#endif
           return;
          }

     DebugBreak();
}





/*
 *  Softpc env variables are mapped to the registry
 *
 *  "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\WOW\CpuEnv"
 *
 * The string values for the CpuEnv key are read at initialization
 * into the CpuEnv linked list. The Environment variables are defined
 * as string key values, where the name of the value is equivalent to
 * the Cpu Environment Variable name, and the string value is equivalent
 * to the value of the environment variable value. This allows the
 * emulator defaults to be overridden, by adding the appropriate value
 * to CpuEnv subkey. Under standard retail setup there won't normally
 * be a CpuEnv subkey, and NO cpu env variables defined to minimize
 * code\data on a standard retail system.
 *
 */



/*
 *  Adds a CpuEnv KEY_VALUE_FULL_INFORMATION to the CpuEnvList
 */
BOOLEAN
AddToCpuEnvList(
   PKEY_VALUE_FULL_INFORMATION KeyValueInfo
   )
{
   NTSTATUS Status;
   ULONG BufferSize;
   PCPUENVVAR CpuEnvVar;
   UNICODE_STRING UnicodeString;
   ANSI_STRING ValueName;
   ANSI_STRING ValueData;
   char NameBuffer[MAX_PATH+sizeof(WCHAR)];
   char DataBuffer[MAX_PATH+sizeof(WCHAR)];


   /*
    *  Convert Value Name and Data strings from unicode to ansi
    */

   ValueName.Buffer = NameBuffer;
   ValueName.MaximumLength = sizeof(NameBuffer) - sizeof(WCHAR);
   ValueName.Length        = 0;
   UnicodeString.Buffer = (PWSTR)KeyValueInfo->Name;
   UnicodeString.MaximumLength =
   UnicodeString.Length        = (USHORT)KeyValueInfo->NameLength;
   Status = RtlUnicodeStringToAnsiString(&ValueName, &UnicodeString,FALSE);
   if (!NT_SUCCESS(Status)) {
       return FALSE;
       }

   ValueData.Buffer = DataBuffer;
   ValueData.MaximumLength = sizeof(DataBuffer) - sizeof(WCHAR);
   ValueData.Length        = 0;
   UnicodeString.Buffer = (PWSTR)((PBYTE)KeyValueInfo + KeyValueInfo->DataOffset);
   UnicodeString.MaximumLength =
   UnicodeString.Length        = (USHORT)KeyValueInfo->DataLength;
   Status = RtlUnicodeStringToAnsiString(&ValueData, &UnicodeString, FALSE);
   if (!NT_SUCCESS(Status)) {
       return FALSE;
       }


   /*
    * Allocate CPUENVLIST structure, with space for the ansi strings
    */
   CpuEnvVar = malloc(sizeof(CPUENVVAR)+    // list structure size
                      ValueName.Length +    // strlen Name
                      ValueData.Length +    // strlen Data
                      1                     // Null for Data
                      );
   if (!CpuEnvVar) {
       return FALSE;
       }


   /*
    *  Copy in the ansi strings, and link it into CpuEnvVar List
    */
   memcpy(CpuEnvVar->Name, ValueName.Buffer, ValueName.Length);
   *(CpuEnvVar->Name + ValueName.Length) = '\0';
   CpuEnvVar->Data = CpuEnvVar->Name + ValueName.Length + 1;
   memcpy(CpuEnvVar->Data, ValueData.Buffer, ValueData.Length);
   *(CpuEnvVar->Data + ValueData.Length) = '\0';
   CpuEnvVar->Next = CpuEnvVarListHead;
   CpuEnvVarListHead = CpuEnvVar;

   return TRUE;
}




/*
 * Reads the CpuEnv values from the registry, into CpuEnvList
 */
void
CpuEnvInit(
   void
   )
{
    int Index;
    NTSTATUS Status;
    HANDLE CpuEnvKey = NULL;
    ULONG ResultLength;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    BYTE NameDataBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*2*sizeof(WCHAR)];




    //
    // Initialize TEB->Vdm to current version number
    //

    Index = (GetTickCount() << 16) | 0x80000000;
    Index |= sizeof(VDM_TIB) + sizeof(VDMVIRTUALICA) + sizeof(VDMICAUSERDATA);
    NtCurrentTeb()->Vdm = (PVOID)Index;

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) NameDataBuffer;

#ifndef MONITOR
/*
 *  BUGBUG temp hack code to add two env var, which aren't properly
 *  defaulted to in the risc cpu emulator
 *
 *  THIS is to be removed before SUR ship 19-Dec-1995 Jonle
 */
     {
     PWCHAR Data;

     wcscpy(KeyValueInfo->Name, L"Soft486Buffers");
     KeyValueInfo->NameLength = wcslen(KeyValueInfo->Name) * sizeof(WCHAR);
     Data = (PWCH)((PBYTE)KeyValueInfo->Name + KeyValueInfo->NameLength + sizeof(WCHAR));
     wcscpy(Data, L"511");
     KeyValueInfo->DataLength = wcslen(Data) * sizeof(WCHAR);
     KeyValueInfo->DataOffset =  (PBYTE)Data - (PBYTE)KeyValueInfo;
     AddToCpuEnvList(KeyValueInfo);

     wcscpy(KeyValueInfo->Name, L"LCIF_FILENAME");
     KeyValueInfo->NameLength = wcslen(KeyValueInfo->Name) * sizeof(WCHAR);
     Data = (PWCH)((PBYTE)KeyValueInfo->Name + KeyValueInfo->NameLength + sizeof(WCHAR));
     wcscpy(Data, L"R lcif");
     KeyValueInfo->DataLength = wcslen(Data) * sizeof(WCHAR);
     KeyValueInfo->DataOffset = (PBYTE)Data - (PBYTE)KeyValueInfo;
     AddToCpuEnvList(KeyValueInfo);
     }

#endif



    RtlInitUnicodeString(
        &UnicodeString,
        L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Wow\\CpuEnv"
        );

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE)NULL,
                               NULL
                               );

    Status = NtOpenKey(&CpuEnvKey,
                       KEY_READ,
                       &ObjectAttributes
                       );

    //
    // If there is no CpuEnv key, CpuEnvList is empty.
    //
    if (!NT_SUCCESS(Status)) {
        return;
        }

    Index = 0;
    while (TRUE) {
         Status = NtEnumerateValueKey(CpuEnvKey,
                                      Index,
                                      KeyValueFullInformation,
                                      KeyValueInfo,
                                      sizeof(NameDataBuffer),
                                      &ResultLength
                                      );

         if (!NT_SUCCESS(Status) || !AddToCpuEnvList(KeyValueInfo)) {
             break;
             }

       Index++;
       };

    NtClose(CpuEnvKey);

#if DBG
    {
    char *pEnvStr;
    pEnvStr = getenv("VERBOSE_GETENV");
    verboseGetenv = pEnvStr && !_stricmp(pEnvStr, "TRUE");
    }
#endif
}



/*
 * In order to catch all references, we define our own
 * version of the CRT getenv, which does the mapping.
 */
char * __cdecl getenv(const char *Name)
{
  PCPUENVVAR CpuEnvVar;
  char *Value = NULL;

  CpuEnvVar = CpuEnvVarListHead;
  while (CpuEnvVar) {
     if (!_stricmp(CpuEnvVar->Name, Name)) {
         Value = CpuEnvVar->Data;
         break;
         }
     CpuEnvVar = CpuEnvVar->Next;
     }

#if DBG
   if (verboseGetenv) {
       DbgPrint("getenv %s:<%s>\n", Name, Value);
       }
#endif

  return Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\roms\bios4.asm ===
;	SCCSID = @(#)uf.bios4.asm	1.10 7/3/95 Copyright Insignia Solutions Ltd.
;	Author:		J. Box	(copied from Williams xt original)
;			J. Kramskoy (added 1.disk parameter tables required for fixed disk.
;					   2.ROM BASIC entry point.
;					   3.Configuration parameters.)
;                       J. Koprowski (added two 2.88Mb Floppy table entries.)
;
;	Purpose:	
;			provides Intel AT BIOS
;
; DUE TO LIMITATIONS IN EXE2BIN, we define 
; the region 0 - 0xdfff (segment 0xf000) in file 'bios1.asm'
; and the region 0xe000 - 0xffff in this file 
;
; each file should be SEPARATELY put through
; MASM,LINK, and EXE2BIN to produce 2 binary image files
; which get loaded into the appropriate regions during
; SoftPC startup.
ORG2	MACRO	trueOffset
	ORG	trueOffset-0e000h
	ENDM

TRACE_BOP	MACRO	text
  LOCAL over_the_name
	BOP		0f8h
	jmp		SHORT over_the_name
	db		'&text&'
	db		10, 0
  over_the_name:
ENDM


	MODEL_BYTE		= 0fch
	SUB_MODEL_BYTE		= 1
	BIOS_LEVEL		= 0

; INT & BOP numbers
	BIOS_RESET 		= 0
	BIOS_PRINT_SCREEN	= 5
	BIOS_ILL_OP_INT		= 6
	BIOS_TIMER_INT		= 8
	BIOS_KB_INT 		= 9
	BIOS_DISK_INT 		= 0Dh
	BIOS_DISKETTE_INT	= 0Eh
	BIOS_VIDEO_IO		= 10h
	BIOS_EQUIPMENT		= 11h
	BIOS_MEMORY_SIZE	= 12h
	BIOS_DISK_IO 		= 13h
	BIOS_RS232_IO 		= 14h
	BIOS_CASSETTE_IO	= 15h
	BIOS_KEYBOARD_IO 	= 16h
	BIOS_PRINTER_IO		= 17h
	BIOS_ROM_BASIC		= 18h
	BIOS_BOOT_STRAP 	= 19h
	BIOS_TIME_OF_DAY	= 1Ah
	BIOS_KEYBOARD_BREAK	= 1Bh
	BIOS_USER_TIMER 	= 1Ch
	BIOS_IDLE_POLL	 	= 1Dh
	BIOS_DISKETTE_IO 	= 40h

; BOPs
	BIOS_BOOTSTRAP_1 	= 90h
	BIOS_BOOTSTRAP_2 	= 91h
	BIOS_BOOTSTRAP_3 	= 92h

	BIOS_FL_OPERATION_1 	= 0A0h
	BIOS_FL_OPERATION_2 	= 0A1h
	BIOS_FL_OPERATION_3 	= 0A2h
	BIOS_FL_RESET_2 	= 0A3h


	BIOS_MOUSE_INT1		= 0BAh
	BIOS_MOUSE_INT2		= 0BBh
	BIOS_MOUSE_IO_LANGUAGE	= 0BCh
	BIOS_MOUSE_IO_INTERRUPT	= 0BDh
	BIOS_MOUSE_VIDEO_IO	= 0BEh

	BIOS_CPU_QUIT		= 0FEh

; addresses
	DOS_SEGMENT			= 0
	DOS_OFFSET			= 7C00h

	BIOS_ROM_SEGMENT		= 0f000h
	DUMMY_INT_OFFSET		= 0FF4Bh
	
	BIOS_PASTE_OFFSET		= 0FF4Ch

	KB_INT_OFFSET			= 0E987h
	KEYBOARD_IO_OFFSET		= 0E82Eh
	RCPU_POLL_OFFSET		= 0e850h
	RCPU_NOP_OFFSET			= 0e950h
	RCPU_INT15_OFFSET		= 0e970h
	RCPU_WAIT_INT_OFFSET		= 00CE0h
	CASSETTE_IO_OFFSET		= 0F859h
	TIMER_INT_OFFSET		= 0FEA5h
	OLD_TIMER_INT_OFFSET		= 0FF00h
	ILL_OP_INT_OFFSET		= 0FF30h
	KEYBOARD_BREAK_INT_OFFSET	= 0FF35h
	PRINT_SCREEN_INT_OFFSET		= 0FF3Bh
	USER_TIMER_INT_OFFSET		= 0FF41h
	RESET_OFFSET			= 0E05Bh
	START_OFFSET			= 0FFF0h
	PRINTER_IO_OFFSET		= 0EFD2h


; useful stuff
	CR			= 0Dh
	LF			= 0Ah

; keyboard constants
; bits in kb_flag
	RIGHT_SHIFT = 1
	LEFT_SHIFT = 2
	CTL_SHIFT = 4
	ALT_SHIFT = 8
	
	

; bit in kb_flag_1
	HOLD_STATE = 8
	SCROLL_SHIFT = 10h
	NUM_SHIFT = 20h
	CAPS_SHIFT = 40h
	INS_SHIFT = 80h

; IBM scan codes
	CTL_KEY = 29
	LEFT_SHIFTKEY = 42
	RIGHT_SHIFTKEY = 54
	ALT_KEY = 56
	CAPS_KEY = 58
	NUM_KEY = 69
	SCROLL_KEY = 70
	INS_KEY = 82	

; CMOS registers
	CMOS_addr	= 070h
	CMOS_data	= 071h
	NMI_DISABLE	= 080h
	CMOS_StatusA	= NMI_DISABLE + 0Ah 
	CMOS_StatusB	= NMI_DISABLE + 0Bh
	CMOS_StatusC	= NMI_DISABLE + 0Ch
	CMOS_Shutdown	= 0Fh
; CMOS constants (bits in StatusB or StatusC)
	CMOS_PI		= 01000000b	; Periodic interrupt
	CMOS_AI		= 00100000b	; Alarm interrupt
; microseconds at 1024Hz
	CMOS_PERIOD_USECS = 976

; ICA registers
	ICA_MASTER_CMD	= 020h
	ICA_MASTER_IMR	= 021h
	ICA_SLAVE_CMD	= 0A0h
	ICA_SLAVE_IMR	= 0A1h
; and commands
	ICA_EOI		= 020h

; BIOS variables area
BIOS_VAR_SEGMENT	SEGMENT at 40h

	ORG	17h

kb_flag			DB	?	; 17
kb_flag_1		DB	?	; 18

	ORG	03fh

MOTOR_STATUS		DB	?	; 3f
MOTOR_COUNT		DB	?	; 40

	ORG	06ch
TIMER_COUNT		DD	?	; 6c
TIMER_OVFL		DB	?	; 70

	ORG	098h
rtc_user_flag		DD	?	; 98
rtc_micro_secs		DD	?	; 9c
rtc_wait_flag		DB	?	; a0

BIOS_VAR_SEGMENT	ENDS

;  Segment we jump to after booting
DOS_seg	SEGMENT at DOS_SEGMENT
	ORG DOS_OFFSET
	DOS_boot	LABEL FAR
DOS_seg	ENDS

; To keep the binary file down to a sensible size, the code segment
; is at fe00 instead of f000. Far jumps are correctly assembled by
; using a second 'fake' segment, that just contains labels, and DOES
; start at f000.
ref	SEGMENT at 0F000h
;
;	NB. the following addresses are allocated to SUN for DOS Windows 3.0.
;	They are not to be used by anyone else.
;	THIS AREA IS SUN PROPERTY - TRESPASSERS WILL BE PROSECUTED 
;	However please note that only the ranges below are reserved.
;	Bios2 gets loaded at 0xfe00, so the following does not have any real
;	effect other than to act as a warning.
; 
	ORG 0
	sunroms_1	LABEL	FAR 
	db	1024 dup (0)	; reserved
	ORG 04000h
	sunroms_2	LABEL	FAR
	db	512 dup (0)	; reserved
	ORG 05000h
	sunroms_3	LABEL	FAR
	db	512 dup (0)	; reserved
;
;	BACK TO INSIGNIA
;
	ORG		RESET_OFFSET
	reset_ref	LABEL	FAR; Must match reset
ref	ENDS

code	SEGMENT 
	ASSUME cs:code,ds:BIOS_VAR_SEGMENT
	ORG 0
copyright:
ifndef SOFTWINDOWS
	DB "4504512 SoftPC 4.00 (C)Copyright Insignia Solutions Inc. 1995"
else
	DB "4504512 SoftWindows 2 (C)Copyright Insignia Solutions Inc. 1995"
endif	; SOFTWINDOWS

include bebop.inc


	ORG	40h
	DB	00h, 01h	; rom serial number
	
	ORG 5Bh
reset	LABEL FAR	; Must match reset_ref
	BOP %BIOS_RESET
	PRINT_MESSAGES
	INT 19h


	; space to insert customer specific startup message
	ORG	80h
oem_msg:
	DB "                                                                                "
	ORG	100h
serial_number:
	DB	"(c) Insignia Inc"
	DB	15h, 3eh, 5fh, 20h
	; this is a cunning encryption, do not change at all

	ORG	150h
hfx_ifs_hdr:
	DB	0ffh, 0ffh, 0ffh, 0ffh
	DB	"HFXREDIR"
	DB	00h, 02ch
	DB	00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h
	; this is a fake IFS header to make DOS 4.01
	; happy with HFX. Do not move/alter.

;
; Special host_unsimulate BOP to enable DEC code to do an IRET to this
; location.  In this way SoftPC can crunch some Intel and DEC can use
; the same code that works on PCs, i.e. they don't need to change the IRET
; instructions.
;
	ORG 170h
pcsa:
	INT 72h
	BOP BIOS_CPU_QUIT

signatures:
	DB CR,LF
;
; signatures removed because Microsoft don't like to find Insignia credits.
;
	ORG 401h

; 23/7/93 MG WinSleuth must have the first two entries of the standard PC
;	     BIOS at the beginning of the table, otherwise it will fall
;	     over !

disktab:

; Drive Type 1

	dw	0306
	db	04
	dw	0
	dw	0128
	db	0
	db	0
	db	0,0,0
	dw	0305
	db	17
	db	0

; Drive Type 2

	dw	615
	db	4
	dw	0
	dw	300
	db	0
	db	0
	db	0,0,0
	dw	615
	db	17
	db	0

; Drive Type 3

	dw 	0	; DISK PARAMETER BLOCK for drive type 3 (Our C: drive ALWAYS)
			; (the #.of cylinders available gets patched in by fdisk_ioattach()
			;  in fdisk.c)
	db	4	; 4 heads (for now)
	db	11 dup (0)
	db	17	; 17 sectors per track
	db	0

; Drive Type 4

	dw 	0	; DISK PARAMETER BLOCK for drive type 4 (Our D: drive
			; (if configured))
	db	4	; 4 heads (for now)
	db	11 dup (0)
	db	17	; 17 sectors per track
	db	0
			; 45 unused blocks
	db	45*16 dup (0)

	ORG 06F2h
boot_strap:
	jmp boot_strap_1

	ORG 06f5h
			; CONFIGURATION PARAMETERS as defined in '86 BIOS.
			; used for cassette i/o function
conf_table:
	db	8		; length of following table
	db	0		; Pad on length above
	db	MODEL_BYTE	; system model byte
	db	SUB_MODEL_BYTE	; system model type
	db	BIOS_LEVEL	; bios revision level
	db	70h		; 80 = DMA channel 3 used by bios
	  			; 40 = cascaded interrupt level 2
	  			; 20 = real time clock available
	  			; 10 = kybd scan code hook 1Ah
	db	4 dup (0)	; reserved


	org 0700h
boot_strap_1:
	BOP BIOS_BOOT_STRAP
	INT BIOS_DISK_IO
	BOP BIOS_BOOTSTRAP_1
	INT BIOS_DISK_IO
	BOP BIOS_BOOTSTRAP_2
	INT BIOS_DISK_IO
	BOP BIOS_BOOTSTRAP_3
	JMP DOS_boot	; To MessyDOS

	ORG 0739h
rs232_io:
	BOP BIOS_RS232_IO
	IRET

	ORG2	KEYBOARD_IO_OFFSET
keyboard_io:
 	CMP AH, 1	; Is it a "test if char available" call ?
 	JZ nerd         ; if so - to the nerd
 	CMP AH, 11h	; Is it a "extended test if char available" call ?
 	JZ nerd         ; if so - to the nerd

 	BOP BIOS_KEYBOARD_IO	; call BIOS keyboard function
 	IRET		; Int return, restoring old status flags
nerd:
	BOP BIOS_KEYBOARD_IO	; call BIOS keyboard function
	RETF 2		; Return without trampling on the status flags
	

      ; loop to wait for a keyboard int - called as a  recursive CPU
	ORG2	RCPU_POLL_OFFSET
	sti
	push	ds
	mov	ax,BIOS_VAR_SEGMENT
	mov	ds,ax
kw1:	bop	%BIOS_IDLE_POLL
	mov	ax,WORD PTR DS:[1ah]	; bios kb buffer head
	cmp	ax,WORD PTR DS:[1ch]	; bios kb buffer tail
	jz	kw1
	pop	ds
	bop	%BIOS_CPU_QUIT

	ORG 087Eh
shift_keys:
	DB INS_KEY,CAPS_KEY,NUM_KEY,SCROLL_KEY
	DB ALT_KEY,CTL_KEY,LEFT_SHIFTKEY,RIGHT_SHIFTKEY; K6 
shift_masks:
	DB INS_SHIFT,CAPS_SHIFT,NUM_SHIFT,SCROLL_SHIFT
	DB ALT_SHIFT,CTL_SHIFT,LEFT_SHIFT,RIGHT_SHIFT; K7
ctl_n_table:
	DB  27,  -1,   0,  -1,  -1,  -1,  30,  -1
	DB  -1,  -1,  -1,  31,  -1, 127, 148,  17
	DB  23,   5,  18,  20,  25,  21,   9,  15
	DB  16,  27,  29,  10,  -1,   1,  19,   4
	DB   6,   7,   8,  10,  11,  12,  -1,  -1
	DB  -1,  -1,  28,  26,  24,   3,  22,   2
	DB  14,  13,  -1,  -1,  -1,  -1, 150,  -1
	DB ' ',  -1;	 K8 
ctl_f_table:
	DB  94,  95,  96,  97,  98,  99, 100, 101
	DB 102, 103,  -1,  -1, 119, 141, 132, 142
	DB 115, 143, 116, 144, 117, 145, 118, 146
	DB 147,  -1,  -1,  -1, 137, 138;	 K9 
lowercase:
	DB  27, '1', '2', '3', '4', '5', '6', '7', '8', '9'
	DB '0', '-', '=',   8,   9, 'q', 'w', 'e', 'r', 't'
	DB 'y', 'u', 'i', 'o', 'p', '[', ']',  13, -1,  'a'
	DB 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';',  39
	DB  96,  -1,  92, 'z', 'x', 'c', 'v', 'b', 'n', 'm'
	DB ',', '.', '/',  -1, '*',  -1, ' ',  -1;  K10
lc_tbl_scan:
	DB  59,  60,  61,  62,  63,  64,  65,  66,  67,  68
	DB  -1,  -1
base_case:
	DB  71,  72,  73,  -1,  75,  -1,  77,  -1,  79,  80,  81,  82,  83 
	DB  -1,  -1,  92, 133, 134;	K15

	ORG 0940h
kb_int_1:
	sti
	push	   ax
 	bop        %BIOS_KB_INT
	pop	   ax
        iret

;	intel instructions for recursive CPU to read keyboard interrupts
;	this is used something like this:
;		while(!somecondition)
;			host_simulate();
;	or
;		while((!somecondition)&&(!timout())
;			host_simulate();
;	The conditions can only be met by something (like a keyboard event)
;	in the real world being put on the event queue and being processed.
;	BUT
;	we only process events when timer ticks go off, which only happens
;	if the CPU executes for >20ms. So we sit in a loop waiting.
;	We could exit the intel code on a particular flag, but to make this
;	code less specific, we exit when the low order timer byte changes
;	(Eg a timer tick has gone off). The C calling code from the base
;	therefore
;	a) does the real checking to see if conditions are met.
;	b) doesn't need changing in a host specific manner.
;
;	We can't just sit in C code waiting for keyboard events because then
;	timer specific stuff (comms etc) wouldn't happen.
;	We can't just do a short call to the recursive CPU because
;	the API for timer ticks won't handle it well, Eg if we just say
;		NOP
;		NOP
;		BOP %BIOS_CPU_QUIT
; 	the recursive CPU doesn't execute long enough for the timer tick
;	to go off.

	ORG2	RCPU_NOP_OFFSET	; this just allows the CPU to handle an interrupt
	sti
	push ax
	push es
	mov ax,0
	mov es,ax
	mov ax,es:[46ch]	; read low order timer byte from 0x46c
L1:	cmp ax,es:[46ch]	; if its changed exit from recursive cpu
	je L1
	pop es
	pop ax
	bop	%BIOS_CPU_QUIT

	ORG2	RCPU_INT15_OFFSET	; this specifically calls INT15
	int	15h
	jmp	w1
w3:	bop	%BIOS_CPU_QUIT
w2:	jmp	w3
w1:	jmp	w2

	ORG2	KB_INT_OFFSET
	jmp	kb_int_1

	ORG 098Ah
uppercase:
	DB  27, '!', '@', '#', '$', '%', '^', '&', '*', '('
	DB ')', '_', '+',   8,   0, 'Q', 'W', 'E', 'R', 'T'
	DB 'Y', 'U', 'I', 'O', 'P', '{', '}',  13,  -1, 'A'
	DB 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"'
	DB 126,  -1, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M'
	DB '<', '>', '?',  -1,   0,  -1, ' ',  -1;	K11 
ucase_scan:
	DB  84,  85,  86,  87,  88,  89,  90,  91,  92,  93
	DB  -1,  -1
num_state:
	DB '7', '8', '9', '-', '4', '5', '6', '+', '1', '2', '3', '0', '.'
	DB  -1,  -1, 124, 135, 136;	K14

	ORG 0A87h
alt_table:
	DB 82,  79,  80,  81,  75,  76,  77,  71,  72,  73
	DB 16,  17,  18,  19,  20,  21,  22,  23,  24,  25
	DB 30,  31,  32,  33,  34,  35,  36,  37,  38,  44
	DB 45,  46,  47,  48,  49,  50	;  K30

	; definitions used in diskette BIOS
	MOTOR_WAIT =		25h
	WRONG_MEDIA = 		80h
	RS_500 = 		00h
	RS_300 = 		40h
	RS_250 = 		80h
	RS_1000 =               0C0h


	ORG 0C00h
rom_basic:
	BOP %BIOS_ROM_BASIC
	IRET

	ORG 0C49h
diskette_io:
	BOP %BIOS_DISKETTE_IO				
	RETF 2			; exit, keeping flags   

	ORG 0C50h
dr_type:
	DB	01
	DW	OFFSET md_tbl1
	DB	02 + WRONG_MEDIA
	DW	OFFSET md_tbl2
	DB	02
	DW	OFFSET md_tbl3
	DB	03
	DW	OFFSET md_tbl4
	DB	04 + WRONG_MEDIA
	DW	OFFSET md_tbl5
	DB	04
	DW	OFFSET md_tbl6
	DB      05 + WRONG_MEDIA
	DW      OFFSET md_tbl7
	DB      05 + WRONG_MEDIA
	DW      OFFSET md_tbl8
	DB      05
	DW      OFFSET md_tbl9

	ORG     0C6Bh
md_tbl1:
	; MEDIA = 40 track low data rate; DRIVE = 40 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB RS_250	; transfer rate

	ORG     0C78h
md_tbl2:
	; MEDIA = 40 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 39		; maximum track number
	DB RS_300	; transfer rate

	ORG     0C85h
md_tbl3:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 15		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 054h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_500	; transfer rate

	ORG     0C92h
md_tbl4:
	; MEDIA = 80 track low data rate; DRIVE = 80 track low data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_250	; transfer rate

	ORG     0C9Fh
md_tbl5:
	; MEDIA = 80 track low data rate; DRIVE = 80 track high data rate
	DB 0DFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 9		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_250	; transfer rate

	ORG     0CACh
md_tbl6:
	; MEDIA = 80 track high data rate; DRIVE = 80 track high data rate
	DB 0AFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 01Bh		; gap length
	DB 0FFh		; data length
	DB 06Ch		; gap length for format
	DB 0F6h		; fill byte for format
	DB 15		; head settle time/ms
	DB 8		; ie 1s motor start time
	DB 79		; maximum track number
	DB RS_500	; transfer rate

	; new for 2.88M floppies
	ORG     0CB9h
md_tbl7:
	; MEDIA = 80 track low data rate; DRIVE = 80 track ext data rate
	DB 0AFh
	DB 2            ; 2nd specify byte (guessed from 1.4)
	DB MOTOR_WAIT   ; motor wait time
	DB 2            ; ie 2 bytes/sector
	DB 9            ; sectors/track
	DB 01Bh         ; gap length
	DB 0FFh         ; data length
	DB 053h         ; gap length for format
	DB 0F6h         ; fill byte for format
	DB 15           ; head settle time/ms
	DB 8            ; ie 1s motor start time
	DB 79           ; maximum track number
	DB RS_250	; transfer rate (guessed from 1.4)

	ORG     0CC6h
md_tbl8:
	; MEDIA = 80 track high data rate; DRIVE = 80 track ext data rate
	DB 0AFh
	DB 2            ; 2nd specify byte (guessed from 1.4)
	DB MOTOR_WAIT   ; motor wait time
	DB 2            ; ie 2 bytes/sector
	DB 18           ; sectors/track
	DB 01Bh         ; gap length
	DB 0FFh         ; data length
	DB 053h         ; gap length for format
	DB 0F6h         ; fill byte for format
	DB 15           ; head settle time/ms
	DB 8            ; ie 1s motor start time
	DB 79           ; maximum track number
	DB RS_500	; transfer rate (guessed from 1.4)

	ORG     0CD3h
md_tbl9:
	; MEDIA = 80 track ext data rate; DRIVE = 80 track ext data rate
	DB 0AFh         ; 1st specify byte (guessed from 1.4)
	DB 2            ; 2nd specify byte (guessed from 1.4)
	DB MOTOR_WAIT   ; motor wait time
	DB 2            ; ie 2 bytes/sector
	DB 36           ; sectors/track
	DB 01Bh         ; gap length
	DB 0FFh         ; data length
	DB 053h         ; gap length for format
	DB 0F6h         ; fill byte for format
	DB 15           ; head settle time/ms
	DB 8            ; ie 1s motor start time
	DB 79           ; maximum track number
	DB RS_1000	; transfer rate (guessed from 1.4)

	ORG	RCPU_WAIT_INT_OFFSET
wait_int:
	PUSH	DS
	PUSH	CX
	MOV	CX, BIOS_VAR_SEGMENT
	MOV	DS, CX
	MOV	CX, 0100H ; sufficient to take multiple interrupts
wait_int_0:
	TEST	byte ptr DS:[3EH], 80h
	LOOPZ	wait_int_0
	POP	CX
	POP	DS
	BOP	%BIOS_CPU_QUIT

	ORG 0D00h
mouse_io:
	JMP hopover
	BOP %BIOS_MOUSE_IO_LANGUAGE
	RETF 8
hopover:
	BOP %BIOS_MOUSE_IO_INTERRUPT
	IRET

	ORG 0D20h
mouse_version:			; dummy, for compatibility
	DB 042h,042h,00h,00h

	ORG 0D40h
mouse_copyright:		; dummy, for compatibility
	DB "Copyright 1987 Insignia Solutions Inc"

	ORG 0D80h
mouse_video_io:
	BOP %BIOS_MOUSE_VIDEO_IO
	IRET

	ORG 0E00h
mouse_int1:
	BOP %BIOS_MOUSE_INT1
	IRET

	ORG 0E80h
mouse_int2:
	BOP %BIOS_MOUSE_INT2
	IRET

	ORG 0F57h
diskette_int:
	BOP %BIOS_DISKETTE_INT
	IRET

	ORG 0FC7h
disk_base:
	DB 0CFh		; 1st specify byte
	DB 2		; 2nd specify byte
	DB MOTOR_WAIT	; motor off wait time
	DB 2		; ie 2 bytes/sector
	DB 18		; sectors/track
	DB 02Ah		; gap length
	DB 0FFh		; data length
	DB 050h		; gap length for format
	DB 0F6h		; fill byte for format
	DB 25		; head settle time/ms
	DB 4		; ie 1/2s motor start time

	ORG2	PRINTER_IO_OFFSET
printer_io:
	BOP %BIOS_PRINTER_IO
	IRET

	ORG 1065h
video_io:
	BOP %BIOS_VIDEO_IO
	IRET

	ORG 106ch
	INT 10h		; allows video handler to be recursive
	BOP %BIOS_CPU_QUIT

	ORG 10A4h
vid_parm_setup:
	; 40*25
	DB 038h, 028h, 02Dh, 0Ah, 01Fh, 6, 019h, 01Ch,2,  7,  6,  7,0,0,0,0
	; 80*25						   
	DB 071h, 050h, 05Ah, 0Ah, 01Fh, 6, 019h, 01Ch,2,  7,  6,  7,0,0,0,0
	; graphics						      	     
	DB 038h, 028h, 02Dh, 0Ah, 07Fh, 6, 064h, 070h,2,  1,  6,  7,0,0,0,0
	; 80*25 BW							
	DB 061h, 050h, 052h, 0Fh, 019h, 6, 019h, 019h,2,0Dh,0Bh,0Ch,0,0,0,0
vid_len_setup:
	DW 2048	; 40*25 screen size
	DW 4096	; 80*25 screen size
	DW 16384; graphics
	DW 16384; graphics
vid_col_setup:
	DB  40,  40,  80 , 80,  40,  40,  80, 80	; screen columns
vid_mode_setup:
	DB 2Ch, 28h, 2Dh, 29h, 2Ah, 2Eh, 1Eh, 29h	;mode register?

	ORG 1841h
memory_size:
	BOP %BIOS_MEMORY_SIZE
	IRET

	ORG 184Dh
equipment:
	BOP %BIOS_EQUIPMENT
	IRET

;;=======================================================================
;; INT 15h	"Cassette IO" e.g. miscellaneous functions
;;

		ORG2	CASSETTE_IO_OFFSET
cassette_io:
		sti
		cmp	ah, 4fh ; Check frequent case (keyboard) first
		jne	int15_not_kb
		mov	ah, 86h	; AH = INVALID option code
int15_fail:	stc		; CF = 1, implies not OK
		retf	2


; Int 15h function 83h (other than the frequent kb enquiry)
;
int15_not_kb:	cmp	ah, 83h	; INT15_EVENT_WAIT
		je	int15_83
		cmp	ah, 86h	; INT15_WAIT
		.386
		je	int15_86
		cmp	ah, 89h	; switch to protected mode
		je	int15_89
		.286

	;; Handle other cases in tape_io.c

		or	ax, ax	; clear CF
		bop	%BIOS_CASSETTE_IO
		retf	2


; Int 15h function 83h
;
;  Change bit7 of byte at es:[bx] when cx::dx micro-seconds has passed.
;
int15_83:	cmp	al, 0
		jnz	int15_83_stop

		push	ds
		mov	ax, BIOS_VAR_SEGMENT
		mov	ds, ax		; load up DS to point to BIOS data

		test	rtc_wait_flag, 1	; Test timer-in-use ?
		jnz	int15_83_inuse

	;; Set up address of user's flag byte

		mov	word ptr ds:[rtc_user_flag], bx
		mov	word ptr ds:[rtc_user_flag+2], es

	;; Save mSec count to decrement

		mov	word ptr ds:[rtc_micro_secs], dx
		mov	word ptr ds:[rtc_micro_secs+2], cx

	;; Produce a trace message if time "large", i.e. > 1,000,000 uS

		cmp	cx, 0Fh		; 1000000. == 000F4240
		jb	int15_83_small
		TRACE_BOP	<int15/83: #cx #dx>
int15_83_small:

	;; Program the RTC to periodically interrupt at 1024Hz		

		cli

	;; Make sure PIC line for RTC is not masked

		in	al, ICA_SLAVE_IMR
		and	al, 11111110b	; RTC is slave line 0
		out	ICA_SLAVE_IMR, al

	;; Set time-of-day to 32768 Hz and periodic frequency 1024 Hz

		mov	al, CMOS_StatusA
		out	CMOS_addr, al
		mov	al, 00100110b
		out	CMOS_data, al

	;; Enable PI interrupt in CMOS

		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		or	al, 01000000b	; Enable PI interrupt
		out	CMOS_data, al

	;; Mark timer-in-use flag active

		mov	rtc_wait_flag, 1; Show wait is active

	;; All OK, return, enabling interrupts

		pop	ds
		xor	ah, ah		; AH = 0, CF = OK
		sti
		retf	2

int15_83_stop:	cli

	;; Disable PI interrupt in CMOS

		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		and	al, 10111111b	; Disable PI interrupt
		out	CMOS_data, al

	;; Clear the in-use flag, undocumented PC notes that
	;; things will go horribly wrong if this call is used
	;; at the wrong time!

		mov	rtc_wait_flag, 0

		sti
		xor	ax, ax		; and CF=0		
		retf	2

int15_83_inuse:	pop	ds
		jmp	int15_fail

;
; Int 15h function 86h
; Wait given number of uSeconds. Quick events will change
; rtc_wait_flag when done...
;
int15_86:	push	ds
		push	es
		push	bx
		mov	ax, BIOS_VAR_SEGMENT
		mov	ds, ax		; load up DS to point to BIOS data

	;; We use the INT 15/83 function to update our rtc_wait_flag
	;; when the requested number of micro-seconds has elapsed

		mov	bx, OFFSET rtc_wait_flag
		mov	ax, BIOS_VAR_SEGMENT
		mov	es, ax

		mov	ax, 8300h
		push	ax			; Push fake flags
		push	cs
		call	int15_83		; Do INT15/83
		jc	int15_86_inuse		; Wait not available


	;; Loop until rtc interrupt routine updates bit7 of
	;; our supplied user flag.

int15_wait:	test	rtc_wait_flag, 080h	; check for end of wait
		jz	int15_wait

	;; Clear the in-use flag

		mov	rtc_wait_flag, 0

	;; And return CF=0 (from test) to show completed OK

		pop	bx
		pop	es
		pop	ds
		retf	2

	;; Error exit, return with CF=1 (from jc)

int15_86_inuse:	pop	bx
		pop	es
		pop	ds
		retf	2

;
; Int 15h function 89h
; Switch to virtual (protected) mode
; See At Tech ref BIOS1 listing (11/15/85) p 5-173 and following
;
int15_89:
	BOP	%BIOS_CASSETTE_IO	           	; handles ica and a20 line
	jc	int15_89_exit				; no prot mode
	MOV	word ptr [SI+38h],0ffffh              ; seg limit
	MOV	byte ptr [SI+3ch],0fh                 ; cs seg hi
	MOV	word ptr [SI+3ah],0                   ; cs seg lo
	MOV	byte ptr [SI+3dh],10011011b           ; cpl0 code access code
	MOV	word ptr [SI+3eh],0                   ; reserved
	;LGDT   [SI+8]
	DB	0fh,1,54h,8
	;LIDT   [SI+16]
	DB	0fh,1,5ch,16
	MOV	AX,1
	;LMSW   AX
	DB	0fh,1,0f0h
	DB	0eah
; jump far to prot cs:vmode...
	DW	offset vmode+0e000h
	DW	38h
vmode:
	MOV	AX,18h
	MOV	DS,AX
	MOV	AX,20h
	MOV	ES,AX
	MOV	AX,28h
	MOV	SS,AX
	POP	BX			; get return address
	ADD	SP,4			; get rid of cs and flags
	db	6ah,30h			; push new (prot mode) cs
	PUSH    BX			; push return offset
	RETF

int15_89_exit:
	retf	2


ifndef GISP_SVGA
	ORG 1A6Eh
crt_char_gen:
	DB 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h ;  /* 0 */
	DB 07Eh, 081h, 0A5h, 081h, 0BDh, 099h, 081h, 07Eh ;  /* 1 */
	DB 07Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh, 07Eh ;  /* 2 */
	DB 06Ch, 0FEh, 0FEh, 0FEh, 07Ch, 038h, 010h, 000h ;  /* 3 */
	DB 010h, 038h, 07Ch, 0FEh, 07Ch, 038h, 010h, 000h ;  /* 4 */
	DB 038h, 07Ch, 038h, 0FEh, 0FEh, 07Ch, 038h, 07Ch ;  /* 5 */
	DB 010h, 010h, 038h, 07Ch, 0FEh, 07Ch, 038h, 07Ch ;  /* 6 */
	DB 000h, 000h, 018h, 03Ch, 03Ch, 018h, 000h, 000h ;  /* 7 */
	DB 0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh ;  /* 8 */
	DB 000h, 03Ch, 066h, 042h, 042h, 066h, 03Ch, 000h ;  /* 9 */
	DB 0FFh, 0C3h, 099h, 0BDh, 0BDh, 099h, 0C3h, 0FFh ;  /* 10 */
	DB 00Fh, 007h, 00Fh, 07Dh, 0CCh, 0CCh, 0CCh, 078h ;  /* 11 */
	DB 03Ch, 066h, 066h, 066h, 03Ch, 018h, 07Eh, 018h ;  /* 12 */
	DB 03Fh, 033h, 03Fh, 030h, 030h, 030h, 070h, 0F0h ;  /* 13 */
	DB 07Fh, 063h, 07Fh, 063h, 063h, 067h, 0E6h, 0C0h ;  /* 14 */
	DB 099h, 05Ah, 03Ch, 0E7h, 0E7h, 03Ch, 05Ah, 099h ;  /* 15 */
	DB 080h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h, 080h, 000h ;  /* 16 */
	DB 002h, 00Eh, 03Eh, 0FEh, 03Eh, 00Eh, 002h, 000h ;  /* 17 */
	DB 018h, 03Ch, 07Eh, 018h, 018h, 07Eh, 03Ch, 018h ;  /* 18 */
	DB 066h, 066h, 066h, 066h, 066h, 000h, 066h, 000h ;  /* 19 */
	DB 07Fh, 0DBh, 0DBh, 07Bh, 01Bh, 01Bh, 01Bh, 000h ;  /* 20 */
	DB 03Eh, 063h, 038h, 06Ch, 06Ch, 038h, 0CCh, 078h ;  /* 21 */
	DB 000h, 000h, 000h, 000h, 07Eh, 07Eh, 07Eh, 000h ;  /* 22 */
	DB 018h, 03Ch, 07Eh, 018h, 07Eh, 03Ch, 018h, 0FFh ;  /* 23 */
	DB 018h, 03Ch, 07Eh, 018h, 018h, 018h, 018h, 000h ;  /* 24 */
	DB 018h, 018h, 018h, 018h, 07Eh, 03Ch, 018h, 000h ;  /* 25 */
	DB 000h, 018h, 00Ch, 0FEh, 00Ch, 018h, 000h, 000h ;  /* 26 */
	DB 000h, 030h, 060h, 0FEh, 060h, 030h, 000h, 000h ;  /* 27 */
	DB 000h, 000h, 0C0h, 0C0h, 0C0h, 0FEh, 000h, 000h ;  /* 28 */
	DB 000h, 024h, 066h, 0FFh, 066h, 024h, 000h, 000h ;  /* 29 */
	DB 000h, 018h, 03Ch, 07Eh, 0FFh, 0FFh, 000h, 000h ;  /* 30 */
	DB 000h, 0FFh, 0FFh, 07Eh, 03Ch, 018h, 000h, 000h ;  /* 31 */
	DB 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h ;  /* space */
	DB 030h, 078h, 078h, 030h, 030h, 000h, 030h, 000h ;  /* ! */
	DB 06Ch, 06Ch, 06Ch, 000h, 000h, 000h, 000h, 000h ;  /* " */
	DB 06Ch, 06Ch, 0FEh, 06Ch, 0FEh, 06Ch, 06Ch, 000h ;  /* # */
	DB 030h, 07Ch, 0C0h, 078h, 00Ch, 0F8h, 030h, 000h ;  /* $ */
	DB 000h, 0C6h, 0CCh, 018h, 030h, 066h, 0C6h, 000h ;  /* % */
	DB 038h, 06Ch, 038h, 076h, 0DCh, 0CCh, 076h, 000h ;  /* & */
	DB 060h, 060h, 0C0h, 000h, 000h, 000h, 000h, 000h ;  /* ' */
	DB 018h, 030h, 060h, 060h, 060h, 030h, 018h, 000h ;  /* ( */
	DB 060h, 030h, 018h, 018h, 018h, 030h, 060h, 000h ;  /* ) */
	DB 000h, 066h, 03Ch, 0FFh, 03Ch, 066h, 000h, 000h ;  /* * */
	DB 000h, 030h, 030h, 0FCh, 030h, 030h, 000h, 000h ;  /* + */
	DB 000h, 000h, 000h, 000h, 000h, 030h, 030h, 060h ;  /* , */
	DB 000h, 000h, 000h, 0FCh, 000h, 000h, 000h, 000h ;  /* - */
	DB 000h, 000h, 000h, 000h, 000h, 030h, 030h, 000h ;  /* . */
	DB 006h, 00Ch, 018h, 030h, 060h, 0C0h, 080h, 000h ;  /* / */
	DB 07Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h, 07Ch, 000h ;  /* 0 */
	DB 030h, 070h, 030h, 030h, 030h, 030h, 0FCh, 000h ;  /* 1 */
	DB 078h, 0CCh, 00Ch, 038h, 060h, 0CCh, 0FCh, 000h ;  /* 2 */
	DB 078h, 0CCh, 00Ch, 038h, 00Ch, 0CCh, 078h, 000h ;  /* 3 */
	DB 01Ch, 03Ch, 06Ch, 0CCh, 0FEh, 00Ch, 01Eh, 000h ;  /* 4 */
	DB 0FCh, 0C0h, 0F8h, 00Ch, 00Ch, 0CCh, 078h, 000h ;  /* 5 */
	DB 038h, 060h, 0C0h, 0F8h, 0CCh, 0CCh, 078h, 000h ;  /* 6 */
	DB 0FCh, 0CCh, 00Ch, 018h, 030h, 030h, 030h, 000h ;  /* 7 */
	DB 078h, 0CCh, 0CCh, 078h, 0CCh, 0CCh, 078h, 000h ;  /* 8 */
	DB 078h, 0CCh, 0CCh, 07Ch, 00Ch, 018h, 070h, 000h ;  /* 9 */
	DB 000h, 030h, 030h, 000h, 000h, 030h, 030h, 000h ;  /* : */
	DB 000h, 030h, 030h, 000h, 000h, 030h, 030h, 060h ;  /* ; */
	DB 018h, 030h, 060h, 0C0h, 060h, 030h, 018h, 000h ;  /* < */
	DB 000h, 000h, 0FCh, 000h, 000h, 0FCh, 000h, 000h ;  /* = */
	DB 060h, 030h, 018h, 00Ch, 018h, 030h, 060h, 000h ;  /* > */
	DB 078h, 0CCh, 00Ch, 018h, 030h, 000h, 030h, 000h ;  /* ? */
	DB 07Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h, 078h, 000h ;  /* @ */
	DB 030h, 078h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 000h ;  /* A */
	DB 0FCh, 066h, 066h, 07Ch, 066h, 066h, 0FCh, 000h ;  /* B */
	DB 03Ch, 066h, 0C0h, 0C0h, 0C0h, 066h, 03Ch, 000h ;  /* C */
	DB 0F8h, 06Ch, 066h, 066h, 066h, 06Ch, 0F8h, 000h ;  /* D */
	DB 0FEh, 062h, 068h, 078h, 068h, 062h, 0FEh, 000h ;  /* E */
	DB 0FEh, 062h, 068h, 078h, 068h, 060h, 0F0h, 000h ;  /* F */
	DB 03Ch, 066h, 0C0h, 0C0h, 0CEh, 066h, 03Eh, 000h ;  /* G */
	DB 0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh, 000h ;  /* H */
	DB 078h, 030h, 030h, 030h, 030h, 030h, 078h, 000h ;  /* I */
	DB 01Eh, 00Ch, 00Ch, 00Ch, 0CCh, 0CCh, 078h, 000h ;  /* J */
	DB 0E6h, 066h, 06Ch, 078h, 06Ch, 066h, 0E6h, 000h ;  /* K */
	DB 0F0h, 060h, 060h, 060h, 062h, 066h, 0FEh, 000h ;  /* L */
	DB 0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h, 000h ;  /* M */
	DB 0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h, 000h ;  /* N */
	DB 038h, 06Ch, 0C6h, 0C6h, 0C6h, 06Ch, 038h, 000h ;  /* O */
	DB 0FCh, 066h, 066h, 07Ch, 060h, 060h, 0F0h, 000h ;  /* P */
	DB 078h, 0CCh, 0CCh, 0CCh, 0DCh, 078h, 01Ch, 000h ;  /* Q */
	DB 0FCh, 066h, 066h, 07Ch, 06Ch, 066h, 0E6h, 000h ;  /* R */
	DB 078h, 0CCh, 0E0h, 070h, 01Ch, 0CCh, 078h, 000h ;  /* S */
	DB 0FCh, 0B4h, 030h, 030h, 030h, 030h, 078h, 000h ;  /* T */
	DB 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh, 000h ;  /* U */
	DB 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 078h, 030h, 000h ;  /* V */
	DB 0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h, 000h ;  /* W */
	DB 0C6h, 0C6h, 06Ch, 038h, 038h, 06Ch, 0C6h, 000h ;  /* X */
	DB 0CCh, 0CCh, 0CCh, 078h, 030h, 030h, 078h, 000h ;  /* Y */
	DB 0FEh, 0C6h, 08Ch, 018h, 032h, 066h, 0FEh, 000h ;  /* Z */
	DB 078h, 060h, 060h, 060h, 060h, 060h, 078h, 000h ;  /* [ */
	DB 0C0h, 060h, 030h, 018h, 00Ch, 006h, 002h, 000h ;  /* \ */
	DB 078h, 018h, 018h, 018h, 018h, 018h, 078h, 000h ;  /* ] */
	DB 010h, 038h, 06Ch, 0C6h, 000h, 000h, 000h, 000h ;  /* ^ */
	DB 000h, 000h, 000h, 000h, 000h, 000h, 000h, 0FFh ;  /* _ */
	DB 030h, 030h, 018h, 000h, 000h, 000h, 000h, 000h ;  /* ` */
	DB 000h, 000h, 078h, 00Ch, 07Ch, 0CCh, 076h, 000h ;  /* a */
	DB 0E0h, 060h, 060h, 07Ch, 066h, 066h, 0DCh, 000h ;  /* b */
	DB 000h, 000h, 078h, 0CCh, 0C0h, 0CCh, 078h, 000h ;  /* c */
	DB 01Ch, 00Ch, 00Ch, 07Ch, 0CCh, 0CCh, 076h, 000h ;  /* d */
	DB 000h, 000h, 078h, 0CCh, 0FCh, 0C0h, 078h, 000h ;  /* e */
	DB 038h, 06Ch, 060h, 0F0h, 060h, 060h, 0F0h, 000h ;  /* f */
	DB 000h, 000h, 076h, 0CCh, 0CCh, 07Ch, 00Ch, 0F8h ;  /* g */
	DB 0E0h, 060h, 06Ch, 076h, 066h, 066h, 0E6h, 000h ;  /* h */
	DB 030h, 000h, 070h, 030h, 030h, 030h, 078h, 000h ;  /* i */
	DB 00Ch, 000h, 00Ch, 00Ch, 00Ch, 0CCh, 0CCh, 078h ;  /* j */
	DB 0E0h, 060h, 066h, 06Ch, 078h, 06Ch, 0E6h, 000h ;  /* k */
	DB 070h, 030h, 030h, 030h, 030h, 030h, 078h, 000h ;  /* l */
	DB 000h, 000h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h, 000h ;  /* m */
	DB 000h, 000h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh, 000h ;  /* n */
	DB 000h, 000h, 078h, 0CCh, 0CCh, 0CCh, 078h, 000h ;  /* o */
	DB 000h, 000h, 0DCh, 066h, 066h, 07Ch, 060h, 0F0h ;  /* p */
	DB 000h, 000h, 076h, 0CCh, 0CCh, 07Ch, 00Ch, 01Eh ;  /* q */
	DB 000h, 000h, 0DCh, 076h, 066h, 060h, 0F0h, 000h ;  /* r */
	DB 000h, 000h, 07Ch, 0C0h, 078h, 00Ch, 0F8h, 000h ;  /* s */
	DB 010h, 030h, 07Ch, 030h, 030h, 034h, 018h, 000h ;  /* t */
	DB 000h, 000h, 0CCh, 0CCh, 0CCh, 0CCh, 076h, 000h ;  /* u */
	DB 000h, 000h, 0CCh, 0CCh, 0CCh, 078h, 030h, 000h ;  /* v */
	DB 000h, 000h, 0C6h, 0D6h, 0FEh, 0FEh, 06Ch, 000h ;  /* w */
	DB 000h, 000h, 0C6h, 06Ch, 038h, 06Ch, 0C6h, 000h ;  /* x */
	DB 000h, 000h, 0CCh, 0CCh, 0CCh, 07Ch, 00Ch, 0F8h ;  /* y */
	DB 000h, 000h, 0FCh, 098h, 030h, 064h, 0FCh, 000h ;  /* z */
	DB 01Ch, 030h, 030h, 0E0h, 030h, 030h, 01Ch, 000h ;  /* { */
	DB 018h, 018h, 018h, 000h, 018h, 018h, 018h, 000h ;  /* | */
	DB 0E0h, 030h, 030h, 01Ch, 030h, 030h, 0E0h, 000h ;  /* } */
	DB 076h, 0DCh, 000h, 000h, 000h, 000h, 000h, 000h ;  /* ~ */
	DB 000h, 010h, 038h, 06Ch, 0C6h, 0C6h, 0FEh, 000h ;  /* Delta */
endif	; GISP_SVGA

	ORG 1E6Eh
time_of_day:
	BOP %BIOS_TIME_OF_DAY
	IRET

	ORG2	TIMER_INT_OFFSET
; The usual int8 handler modified for optimum performance.
; - stays in Intel code (no BOP)
; - keeps interrupts off when not needed
; - calls int 1c directly
;
	push	ds		; save some registers
	push	ax

	mov	ax, BIOS_VAR_SEGMENT
	mov	ds, ax

	; inc time counters
	; check for 24 hours, wrap point

	.386
	inc	dword ptr ds:[TIMER_COUNT]
	cmp	dword ptr ds:[TIMER_COUNT], 0001800b0h
	.286
	jz	i8v1

	; check for floppy motor

	dec	byte ptr ds:[MOTOR_COUNT]
	jz	i8v2		; costly outb happens 1/256 timer tics...

	; Check for dummy_int in int1c vector

	.386
	cmp	dword ptr ds:[BIOS_USER_TIMER*4], (BIOS_ROM_SEGMENT*10000h)+DUMMY_INT_OFFSET
	.286
	jnz	i8v3	

i8v0:	; send eoi

	mov	al, ICA_EOI
	out	ICA_MASTER_CMD, al

	; restore the stack and return

	pop	ax
	pop	ds
	iret

	; handle 24-hour wrap

i8v1:	.386
	mov	dword ptr ds:[TIMER_COUNT], 0
	.286
	mov	byte ptr ds:[TIMER_OVFL], 1	; 24 hour wrap, set OVFL bit

	; handle the floppy motor stuff

i8v2:	and	byte ptr ds:[MOTOR_STATUS], 0f0h
	mov	al, 0ch
	push	dx
	mov	dx, 03f2h
	out	dx, al
	jmp	i8v4		; n.b. dx already pushed

      ; Call user's timer handler (rare)

i8v3:	push	dx
i8v4:	int	BIOS_USER_TIMER
	pop	dx

	jmp	i8v0


;For old SoftPC's (that dont like 486 instructions) we put the old slow code
; in as well, and they use the BOP

	ORG2	OLD_TIMER_INT_OFFSET
	STI 	;to let timer interrupt itself.
;Save current state just like the real thing, so that
;user timer routines know exactly which registers are
;saved and which aren't.
	PUSH DS
	PUSH AX
	PUSH DX
;Now off to our code
	BOP %BIOS_TIMER_INT
	CLI 	;to prevent interrupts until the IRET.
;Non Specific End-Of-Interrupt
	MOV AL,20h
	OUT 20h,AL
;Restore saved state
	POP DX
	POP AX
	POP DS
;Any lower priority interrupts should occur before the IRET
	IRET


;; The illegal Intel instruction handler
	ORG2	ILL_OP_INT_OFFSET
	BOP	%BIOS_ILL_OP_INT
	IRET

;Software int's called from base, keyboard break, print screen, timer int
; If one of the following three ORG's are changed, then SAS.H must also be
; changed to reflect the new values.

	ORG2	KEYBOARD_BREAK_INT_OFFSET
	INT	BIOS_KEYBOARD_BREAK
	BOP	%BIOS_CPU_QUIT

	ORG2	PRINT_SCREEN_INT_OFFSET
	INT	BIOS_PRINT_SCREEN
	BOP	%BIOS_CPU_QUIT

	ORG2	USER_TIMER_INT_OFFSET
	INT	BIOS_USER_TIMER
	BOP	%BIOS_CPU_QUIT

	ORG2	DUMMY_INT_OFFSET
	IRET
	
; Called by the macintosh host to paste into the keyboard type-ahead buffer.
; Called with AH=5, CL=scan code, and CH=ascii character.

	ORG2	BIOS_PASTE_OFFSET
 	INT	BIOS_KEYBOARD_IO	; call BIOS keyboard function
	BOP	%BIOS_CPU_QUIT


;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Print screen

	ORG 1f54h
print_screen:
	STI
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	PUSH DS
	;::::::::::::::::::::::::::::::::: Setup DS to point to BIOS data area
	MOV AX,BIOS_VAR_SEGMENT
	MOV DS,AX
	;::::::::::::::::::::::::::::::: Print screen already in progress ????
	CMP BYTE PTR DS:[100H],1
	JE end_print
	;::::::::::::::::::::::::::::::::::::::::::::::: Set print screen busy
	MOV BYTE PTR DS:[100h],1
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Get video status
	MOV AH,15
	INT 10H
	MOV CH,AH	    ;No of columns
	;:::::::::::::::::::::::::::::::::: Setup no. of columns/rows to print
	MOV CL,BYTE PTR DS:[084h]   ; No. of rows to print is rows in current mode
	;::::::::::::::::::::::::::::::::::: Print line feed / carriage return
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::: Get current cursor postion
	PUSH CX
	MOV AH,3
	INT 10H
	POP CX
	;::::::::::::::::::::::::::::::::::::::::::::::::: Save cursor postion
	PUSH DX 		    ;save current cursor postion
	XOR DH,DH		    ;current row being processed
start_print_col:
	XOR DL,DL		    ;current column being processed
	;::::::::::::::::::::::::::::::::::::::::::::::: Start printing screen
start_print_row:
	;:::::::::::::::::::::::::::::::::::::::::::::::::: Set cursor postion
	PUSH DX 		    ;save current row,column
	MOV AH,2
	INT 10H
	;::::::::::::::::::::::::::::::::::: Read character at current postion
	MOV AH,8
	INT 10H
	;::::::::::::::::::::::::::::::::::::::::::::::::::::: Print character
	OR al,al
	JNZ print_char
	MOV AL,20H
print_char:
	XOR DX,DX
	XOR AH,AH
	INT 17H
	;:::::::::::::::::::::::::::::::::::::::::::: Check for printer errors
	POP DX			;Restore current row,column
	AND AH,25H
	JZ  cont2
	MOV BYTE PTR DS:[100H],0FFH
	JMP short exit_print
	;::::::::::::::::::::::::::::::::::::::::::: Move to mext print column
cont2:
	INC DL			;Inc current column
	CMP DL,CH		;Current col compared to no. of cols
	JB start_print_row
	;:::::::::::::::::::::::::::::::::::::::::: End of column, print CR/LF
	CALL print_crlf
	;:::::::::::::::::::::::::::::::::::::::::::::::::: More rows to print
	INC DH			;Inc current row
	CMP DH,CL		;Current row compared to no. of rows
	JBE start_print_col
	MOV BYTE PTR DS:[0100H],0
	;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Exit print
exit_print:
	;:::::::::::::::::::::::::::::::::::::; Restore orginal cursor postion
	POP DX
	MOV AH,2
	INT 10H
	;:::::::::::::::::::::::::::::::::::::::::::::::::::: Tidy up and exit
end_print:
	POP DS
	POP DX
	POP CX
	POP BX
	POP AX
	IRET

	;::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Print CR/LF
print_crlf:
	PUSH DX
	XOR DX,DX
	MOV AX,0DH
	INT 17H
	XOR DX,DX
	MOV AX,0AH
	INT 17H
	POP DX
	RET


	ORG2	START_OFFSET
start_addr:
	JMP reset_ref	
date:
	DB "07/03/95"

	org 01ffeh
bios_tail:
	DB MODEL_BYTE
code	ENDS
	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\roms\bios1.asm ===
;	SCCSID = @(#)uf.bios1.asm	1.16 7/3/95
;	Author:		J. Box, Jerry Kramskoy
;
;	Purpose:	
;			provides Intel BIOS for the following:
;				RTC interrupt
;				fixed disk (on dual card)
;

; C-services (through 'bop' instruction)
	BIOS_UNEXP_INT		= 	2
	BIOS_RTC_INT		=	70h
	BIOS_REDIRECT_INT	=	71h
	BIOS_D11_INT		=	72h
	BIOS_X287_INT		=	75h
	BIOS_DISK_IO		=	13h
        BIOS_MOUSE_INT1         = 	0BAh
        BIOS_MOUSE_INT2         = 	0BBh
        BIOS_MOUSE_IO_LANGUAGE  = 	0BCh
        BIOS_MOUSE_IO_INTERRUPT = 	0BDh
        BIOS_MOUSE_VIDEO_IO     = 	0BEh
	BIOS_CPU_RETURN		=	0feh
	BIOS_IRET_HOOK		=	52h

; ICA registers
	ICA_MASTER_CMD	= 020h
	ICA_MASTER_IMR	= 021h
	ICA_SLAVE_CMD	= 0A0h
	ICA_SLAVE_IMR	= 0A1h
; and commands
	ICA_EOI		= 020h

; CMOS registers
	CMOS_addr	= 070h
	CMOS_data	= 071h
	NMI_DISABLE	= 080h
	CMOS_StatusA	= NMI_DISABLE + 0Ah 
	CMOS_StatusB	= NMI_DISABLE + 0Bh
	CMOS_StatusC	= NMI_DISABLE + 0Ch
	CMOS_Shutdown	= 0Fh
; CMOS constants (bits in StatusB or StatusC)
	CMOS_PI		= 01000000b	; Periodic interrupt
	CMOS_AI		= 00100000b	; Alarm interrupt
; microseconds at 1024Hz
	CMOS_PERIOD_USECS = 976


	include bebop.inc

	; DUE TO LIMITATIONS IN EXE2BIN, we define 
	; the region 0 - 0xdfff (segment 0xf000) in this file
	; and the region 0xe000 - 0xffff in file 'bios2.asm'
	;
	; each file should be SEPARATELY put through
	; MASM,LINK, and EXE2BIN to produce 2 binary image files
	; which get loaded into the appropriate regions during
	; SoftPC startup.


	;------------------------;
	; bios data area         ;
	;------------------------;
; BIOS variables area
BIOS_VAR_SEGMENT	SEGMENT at 40h


	ORG	098h
rtc_user_flag		DD	?	; 98
rtc_micro_secs		DD	?	; 9c
rtc_wait_flag		DB	?	; a0

	ORG	8eh
hf_int_flag		db	?	; 8e

BIOS_VAR_SEGMENT	ENDS


	code	segment

		assume cs:code, ds:BIOS_VAR_SEGMENT

	;----------------------------------------------------;
	; 	D11			                     ;
	;	services unused interrupt vectors	     ;
	;						     ;
	;----------------------------------------------------;
		ORG	01BE0h
D11:		bop	BIOS_D11_INT
		iret

	;----------------------------------------------------;
	;	IRET HOOK				     ;
	;	Return control to the monitor after an ISR   ;
	;	returns to here.			     ;
	;----------------------------------------------------;
 
		ORG	01C00h
		bop	BIOS_IRET_HOOK
		iret

	;----------------------------------------------------;
	; 	re_direct		                     ;
	;	This routine fields level 9 interrupts	     ;
	;	control is passed to Master int level 2	     ;
	;----------------------------------------------------;
		ORG	01C2Fh
re_direct:	bop	BIOS_REDIRECT_INT
		int	0ah
		iret

	;----------------------------------------------------;
	; 	int_287			                     ;
	;	service X287 interrupts			     ;
	;						     ;
	;----------------------------------------------------;
		ORG	01C38h
int_287:	bop	BIOS_X287_INT
		int	02
		iret


	;----------------------------------------------------;
	; 	rtc_int			                     ;
	;	rtc interrupt handler			     ;
	;----------------------------------------------------;
		ORG	04B1Bh

rtc_int:	push	ax
		push	ds
		mov	ax, BIOS_VAR_SEGMENT
		mov	ds, ax

rtc_test_pending:

	;; Check for pending interrupt

		mov	al, CMOS_StatusC
		out	CMOS_addr, al
		in	al, CMOS_data	; reads then clears pending interrupts

	;; Mask with enabled interrupts		

		mov	ah, al			; save pending interrupts
		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		and	ah, al		

	;; Test pending, enabled interrupts (in ah) for work to do

		test	ah, (CMOS_PI+CMOS_AI)
		jnz	rtc_test_enabled

	;; Deselecting the cmos

		mov	al, CMOS_Shutdown
		out	CMOS_addr, al

	;; Send eoi to ICA

		mov	al, ICA_EOI
		out	ICA_SLAVE_CMD, al
		out	ICA_MASTER_CMD, al

	;; And return

		pop	ds
		pop	ax
		iret

rtc_test_enabled:

	;; Test for periodic interrupt triggered

		test	ah, CMOS_PI
		jz	rtc_test_alarm

	;; Decrement the microsecond count

		.386
		sub	ds:[rtc_micro_secs], CMOS_PERIOD_USECS
		.286
		jnc	rtc_test_alarm

	;; Disable PI interrupt in CMOS if count expired

		mov	al, CMOS_StatusB
		out	CMOS_addr, al
		in	al, CMOS_data		
		and	al, 10111111b	; Disable PI interrupt
		out	CMOS_data, al

	;; Update the flag byte to say time has expired

		push	es
		push	bx
		les	bx, rtc_user_flag
		or	byte ptr es:[bx], 080h
		pop	bx
		pop	es

	;; Mark timer-in-use flag in-active

		and	rtc_wait_flag, 0feh; Show wait is not active

rtc_test_alarm:

	;; Test for alarm interrupt triggered

		test	ah, CMOS_AI
		jz	rtc_test_pending

	;; Call users alarm function (first deselecting the cmos)

		mov	al, CMOS_Shutdown
		out	CMOS_addr, al
		int	04Ah

	;; Repeat in case a new interrupt occurred

		jmp	rtc_test_pending

		

	;----------------------------------------------------;
	; disk_io                       
	;	route to disk/diskette i/o service	     ;
	;----------------------------------------------------;
		org	2e86h	;(must match DISKO_OFFSET in diskbios.c)

	disk_io	proc	far
	; is this request for fixed disk or diskette?
		cmp	dl,80h
		jae	p0

	; for diskette.
		int	40h
	bye:	
		retf	2
	p0:	
		sti
	; reset? (ah = 0). reset diskette also
		or	ah,ah
		jnz	p1
		int	40h
		sub	ah,ah
		cmp	dl,81h
		ja	bye

	p1:	
	; carry out the disk service requested from 'C'.
	; those requests which expect to cause a
	; disk interrupt will 'call' wait below,
	; which returns back to 'C'. Eventually
	; 'C' returns after the bop.

		push	ds
		bop	BIOS_DISK_IO
		pop	ds
		retf	2

	disk_io	endp	
		
	;----------------------------------------------------;
	; wait					     	     ;
	;	wait for disk interrupt			     ;
	;	('called' from waitint() in diskbios.c	     ;
	;----------------------------------------------------;
		org	329fh	;(must match DISKWAIT_OFFSET in diskbios.c)
	wate	proc	
	
		sti
		clc
		mov	ax,9000h
 		int	15h
		push    ds
		push	cx
		mov	ax, 40h
		mov	ds, ax
		xor	cx, cx
not_yet:	cmp	byte ptr ds:[8eh], 0
		loopz	not_yet
		pop	cx
		pop	ds
		bop	BIOS_CPU_RETURN
	wate	endp

	;----------------------------------------------------;
	; hd_int					     ;
	;	field fixed disk controller's interrupt	     ;
	;----------------------------------------------------;
		org	33b7h	; (must match DISKISR_OFFSET in diskbios.c)

	hd_int	proc	near
		push	ds
		mov	ax,BIOS_VAR_SEGMENT
		mov	ds,ax
	; inform everybody that a fixed disk interrupt
	; occurred
		mov	hf_int_flag,0ffh

	; clear down the interrupt with the ica's

		mov	al, ICA_EOI
		out	ICA_SLAVE_CMD, al
		out	ICA_MASTER_CMD, al

		sti
		mov	ax,9100h
		int	15h
		pop	ds
		iret

	hd_int	endp

	; read bytes 0 - 3fff in from binary image
	; when accessing bios1.rom.
	; if need more than this, change value here
	; to 'n' and in sas_init(), change read of bios1.rom
	; to have transfer count of 'n'+1

				org	3fffh
	insignia_endmark	db	0

ifdef	SUN_VA
;
;       NB. the following addresses are allocated to SUN for DOS Windows 3.0.
;       They are not to be used by anyone else.
;       THIS AREA IS SUN PROPERTY - TRESPASSERS WILL BE PROSECUTED
;       However please note that only the ranges below are reserved.
;
        ORG 04000h
        sunroms_2       LABEL   FAR
        db      512 dup (0)     ; reserved
        ORG 05000h
        sunroms_3       LABEL   FAR
        db      512 dup (0)     ; reserved
endif

        ORG     06000h

        ; this is a fake IFS header to make DOS 4.01
        ; happy with HFX. Do not move/alter.
        hfx_ifs_hdr     LABEL   FAR
        DB      0ffh, 0ffh, 0ffh, 0ffh
        DB      "HFXREDIR"
        DB      00h, 02ch
        DB      00h, 00h, 00h, 00h, 00h, 00h, 00h, 00h

ifndef	GISP_SVGA

	ORG	06020h
ifndef	SUN_VA
write_teletype	proc far
	retf
write_teletype	endp

else

write_teletype	proc far
	push	ds
	push	si
	mov	si,	0f000h
	mov	ds,	si
	mov	si,	06400h
	push	ax
	mov	ah,	0eh
	push	bp
	mov	bp,	2
	push	dx
	push    bx
	mov bx, 0

start_write:
	cmp	bp,	[si]
	je	finish_write
	mov	al,	ds:[bp+si]
	inc	bp
	int	010h
	jmp	start_write

finish_write:
	mov	word ptr [si], 2
	pop	bx
	pop	dx
	pop	bp
	pop	ax
	pop	si
	pop	ds
	retf
write_teletype	endp

	ORG	06200h
; mouse_io_interrupt
mouse_io:
	JMP hopover
	BOP BIOS_MOUSE_IO_LANGUAGE
	RETF 8
hopover:
	BOP BIOS_MOUSE_IO_INTERRUPT
	IRET


	ORG	06220h
; mouse_int1
mouse_int1:
	BOP BIOS_MOUSE_INT1
	IRET

	ORG	06240h
; mouse_video_io
mouse_video_io:
	BOP BIOS_MOUSE_VIDEO_IO
	IRET

	ORG	06260h
; mouse_int2
mouse_int2:
	BOP BIOS_MOUSE_INT2
	IRET

	ORG	06280h
; mouse_version
mouse_version:			; dummy, for compatibility
	DB 042h,042h,00h,00h

	ORG	062a0h
; mouse_copyright
mouse_copyright:		; dummy, for compatibility
	DB "Copyright 1987-91 Insignia Solutions Inc"

	ORG	06400h
;	scratch pad area - this is where the messages go!

endif

endif	; GISP_SVGA

	;; To cope with Helix SoftWare "Netroom 2.20" DOS extender
	;; which only maps in pages of the BIOS that have vectors
	;; we must ensure that something points at page F6xxx
	;; else we end up with the scratch area on top of some
	;; DOS program or driver!

	ORG	06f00h	; UNEXP_INT_OFFSET
	BOP	BIOS_UNEXP_INT
	IRET

	.386
;	These are the virtualisation instructions needed for the 386.

	ORG	3000h		; BIOS_STI_OFFSET
	STI	
	BOP	0feh

	ORG	3010h		; BIOS_CLI_OFFSET
	CLI	
	BOP	0feh

	ORG	3020h		; BIOS_INB_OFFSET
	IN	al,dx 
	BOP	0feh 

	ORG	3030h		; BIOS_INW_OFFSET
	IN	ax,dx 
	BOP	0feh

	ORG	3040h		; BIOS_IND_OFFSET
	IN	eax,dx 
	BOP	0feh

	ORG	3050h		; BIOS_OUTB_OFFSET
	OUT	dx,al 
	BOP	0feh 

	ORG	3060h		; BIOS_OUTW_OFFSET
	OUT	dx,ax 
	BOP	0feh 

	ORG	3070h		; BIOS_OUTD_OFFSET
	OUT	dx,eax 
	BOP	0feh 

	ORG	3080h		; BIOS_WRTB_OFFSET
	MOV	[edx],al
	BOP	0feh 

	ORG	3090h		; BIOS_WRTW_OFFSET
	MOV	[edx],ax
	BOP	0feh 

	ORG	30a0h		; BIOS_WRTD_OFFSET
	MOV	[edx],eax
	BOP	0feh 

	ORG	30b0h		; BIOS_RDB_OFFSET
	MOV	al, [edx]
	BOP	0feh 

	ORG	30c0h		; BIOS_RDW_OFFSET
	MOV	ax, [edx]
	BOP	0feh 

	ORG	30d0h		; BIOS_RDD_OFFSET
	MOV	eax, [edx]
	BOP	0feh 

	ORG	30e0h		; BIOS_YIELD_VM_OFFSET
	MOV	AX, 1680h	; Yeild VM time slice
	INT	2fh
	BOP	0feh 

	ORG	30f0h		; BIOS_STOSB_OFFSET
	push	es
	push	ds
	pop	es
	xchg	edx,edi		; dest lin addr
	db	67h
	db	66h
	rep	stosb	
	xchg	edx,edi
	pop	es
	BOP	0feh 

	ORG	3110h		; BIOS_STOSW_OFFSET
	push	es
	push	ds
	pop	es
	xchg	edx,edi		; dest lin addr
	db	67h
	rep	stosw	
	xchg	edx,edi
	pop	es
	BOP	0feh 

	ORG	3130h		; BIOS_STOSD_OFFSET
	push	es
	push	ds
	pop	es
	xchg	edx,edi		; dest lin addr
	db	67h
	db	66h
	rep	stosw	
	xchg	edx,edi
	pop	es
	BOP	0feh 

        ORG     3200h           ; BIOS_BAD_OFFSET
        db	0c5h
	db	0c5h		; illegal instruction
	BOP	0feh

 ;; N.B. DISKWAIT_OFFSET is at "org 329fh"

	code	ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\softpc.new\obj.vdm\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ntvdm
EXEPROFILEINPUT=yes

MVDM_TREE=$(PROJECT_ROOT)\mvdm

SOFTPC_TREE=$(MVDM_TREE)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

TARGETPATH=obj
!if "$(ALT_PROJECT)" == "daytona"
PASS1_PUBLISH={$(O)\ntvdm.lib=$(SDK_LIB_PATH)\ntvdm.lib}
!endif

TARGETTYPE=PROGLIB
NOT_TERMINAL_SERVER_AWARE=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernl32p.lib \
        $(WINDOWS_LIB_PATH)\gdi32p.lib     \
        $(WINDOWS_LIB_PATH)\user32p.lib   \
        $(WINDOWS_LIB_PATH)\apphelp.lib \
        $(SDK_LIB_PATH)\ntdll.lib   \
!if !$(386)
        $(SDK_LIB_PATH)\binmode.obj  \
!endif
        $(SDK_LIB_PATH)\advapi32.lib
        
BACKGROUND_USE=1

!if "$(ALT_PROJECT)" == "daytona"
ALT_PROJECT_FE=daytona
!else
ALT_PROJECT_FE=fe
!endif
ALT_PROJECT_OBJS=daytona
ALT_PROJECT_LIBS=.

!if !$(386)
LINKER_FLAGS=$(LINKER_FLAGS) -INCLUDE:__mb_cur_max -INCLUDE:_pctype
!endif

LINKLIBS = \
    $(SOFTPC_TREE)\base\support\$(ALT_PROJECT_OBJS)\$(O)\MAIN.obj \
    $(SOFTPC_TREE)\host\src\$(ALT_PROJECT)\$(O)\FPRT.OBJ     \
    $(SOFTPC_TREE)\base\system\$(ALT_PROJECT_OBJS)\$(O)\SYSTEM.LIB    \
    $(SOFTPC_TREE)\base\bios\$(ALT_PROJECT)\$(O)\BIOS.LIB    \
    $(SOFTPC_TREE)\base\video\$(ALT_PROJECT)\$(O)\VIDEO.LIB  \
    $(SOFTPC_TREE)\base\dos\$(ALT_PROJECT_OBJS)\$(O)\DOS.LIB      \
    $(SOFTPC_TREE)\base\comms\$(ALT_PROJECT_OBJS)\$(O)\COMMS.LIB  \
    $(SOFTPC_TREE)\base\debug\$(ALT_PROJECT_OBJS)\$(O)\DEBUG.LIB  \
    $(SOFTPC_TREE)\base\support\$(ALT_PROJECT_OBJS)\$(O)\SUPPORT.LIB  \
    $(SOFTPC_TREE)\base\disks\$(ALT_PROJECT_OBJS)\$(O)\DISKS.LIB  \
    $(SOFTPC_TREE)\base\keymouse\$(ALT_PROJECT)\$(O)\KEYMOUSE.LIB \
    $(SOFTPC_TREE)\host\src\$(ALT_PROJECT)\$(O)\SRC.LIB      \
!if $(386)
    $(MVDM_TREE)\v86\monitor\$(ALT_PROJECT_OBJS)\$(O)\monitor.lib      \
!else
    $(SOFTPC_TREE)\base\dasm386\$(O)\DASM386.LIB   \
    $(CPULIBS) \
!endif
    $(MVDM_TREE)\dbg\$(ALT_PROJECT_OBJS)\$(O)\dbg.lib         \
    $(MVDM_TREE)\dos\dem\$(ALT_PROJECT)\$(O)\dem.lib         \
    $(MVDM_TREE)\suballoc\$(O)\suballoc.lib         \
    $(MVDM_TREE)\dos\command\$(ALT_PROJECT)\$(O)\command.lib         \
    $(MVDM_TREE)\oemuni\$(ALT_PROJECT_FE)\$(O)\oemuni.lib     \
    $(MVDM_TREE)\xms.486\$(ALT_PROJECT_OBJS)\$(O)\xms486.lib \
    $(MVDM_TREE)\dpmi32\$(ALT_PROJECT_FE)\$(O)\dpmi32.lib

!if $(FREEBUILD)
PD = Pd
!else
PD = Pg
!endif

# Decide whether to use assembler or C CPU.

!if "$(CCPU)" == ""
CPULIBS=$(SOFTPC_TREE)\*\libs\a4$(PD).lib
!else
CPULIBS=$(SOFTPC_TREE)\obj.vdm\$(O)\ccpu486.lib
!endif

# Since we have built objs and libs in LINKLIBS above,
# we need to wait for previous directories to complete
# before building this one.  This is because build.exe
# requires LINKLIBS to exist in pass 1 (compile).

SYNCHRONIZE_DRAIN=1

SOURCES=..\ntvdm.c  \
        ..\imlibdep.c \
        ..\resource.rc

MISCFILES=..\doswow_{BA75DD62-6D62-4FCB-89F2-BC53C0659829}.sld

!INCLUDE ..\CDEFINE.INC

UMTYPE=console

#
# base at < 256 MB (0x10000000), so that softpc code buffer
# in allocated Virtual Memory (bottom up) is within
# near jump range to ntvdm's code.
#
UMBASE=0x0f000000

DLLDEF=$(O)\ntvdm.def
SOURCES_USED=..\sources.inc

!if "$(ALT_PROJECT)" != "daytona"
LINKER_FLAGS=$(LINKER_FLAGS) /pdb:$(O)\ntvdm_$(ALT_PROJECT).pdb
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\suballoc\suballcp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    suballcp.h

Abstract:

    This is the private include file for the suballocation
    package.

Author:

    Dave Hastings (daveh) creation-date 25-Jan-1994

Revision History:


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <suballoc.h>


//
// Constants
// 

//
// Smallest chunk that will be sub allocated
// 1024 was chosen currently, because that is the
// smallest chunk XMS will allocate.
//
#define SUBALLOC_GRANULARITY        1024

//
// Assertions and macros
//

//
// Force code to be stepped through
//
#if 0
#define ASSERT_STEPTHROUGH DbgBreakPoint()
#else
#define ASSERT_STEPTHROUGH
#endif

//
// Signature macros for SUBALLOCATION
//
#if DBG
//
// signature is "SubA"
//
#define INIT_SUBALLOC_SIGNATURE(p) p->Signature = (ULONG)0x41627553
#define ASSERT_SUBALLOC(p) ASSERT((p->Signature == (ULONG)0x41627553))
#else
#define INIT_SUBALLOC_SIGNATURE(p)
#define ASSERT_SUBALLOC(p)
#endif

//
// Macro for extracting a bit from a bitfield of type char
//
#define GET_BIT_FROM_CHAR_ARRAY(p, i) \
((p[(i)/(sizeof(UCHAR) * 8)] >> ((i) % (sizeof(UCHAR) * 8))) & 1)

//
// Macro for setting a bit in a bitfield of type char
//
#define SET_BIT_IN_CHAR_ARRAY(p, i) \
(p[(i)/(sizeof(UCHAR) * 8)] |= (1 << ((i) % (sizeof(UCHAR) * 8))))

//
// Macro for clearing a bit in a bitfield of type char
//
#define CLEAR_BIT_IN_CHAR_ARRAY(p, i) \
(p[(i)/(sizeof(UCHAR) * 8)] &= ~(1 << ((i) % (sizeof(UCHAR) * 8))))

//
// Generate a sub alloc block index from an address
//
#define ADDRESS_TO_BLOCK_INDEX(p, i) \
((i - p->BaseAddress)/ SUBALLOC_GRANULARITY) 

//
// Generate an address from a block index
//
#define BLOCK_INDEX_TO_ADDRESS(p, i) \
(p->BaseAddress + (i) * SUBALLOC_GRANULARITY)

// Round the allocated size to next allocation
// granularity
//
#define ALLOC_ROUND(s) \
(s + SUBALLOC_GRANULARITY - 1) / SUBALLOC_GRANULARITY

//
// Types
//

//
// Enum for commit acctions
//

typedef enum {
    SACommit,
    SADecommit
} COMMIT_ACTION;

//
// Structure for tracking the address space.  Each chunk of 
// memory of SUBALLOC_GRANULARITY in size is represented by
// a bit.  Each chunk of memory of COMMIT_GRANULARITY is 
// represented by one bit of the array Allocated.
//
// ?? Should we add a field to indicate whether the chunk is 
//    committed?  We can always check for all allocated bits
//    zero, and use that as an indication that the chunk is 
//    not committed.
//
//
typedef struct _SubAllocation {
#if DBG
    ULONG Signature;
#endif
    PSACOMMITROUTINE CommitRoutine;
    PSACOMMITROUTINE DecommitRoutine;
    PSAMEMORYMOVEROUTINE MoveMemRoutine;
    ULONG BaseAddress;
    ULONG Size;                         // size in SUBALLOC_GRANULARITY
    ULONG FirstFree;                    // keeps block # of first free block
                                        // cuts alloc time in half
    //
    // bitfield with one bit per chunk.  Bit set indicates
    // allocated.  Bit clear indicates free.  All bits 
    // clear indicates un committed
    //
    UCHAR Allocated[1];
} SUBALLOCATIONDATA, *PSUBALLOCATIONDATA;

//
// Internal Routines
//
BOOL
CommitChunk(
    PSUBALLOCATIONDATA SubAllocation,
    ULONG StartChunk,
    ULONG Size,
    COMMIT_ACTION Action
    );

BOOL
IsBlockCommitted(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG CurrentBlock
    );

BOOL
AllocateChunkAt(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex,
    BOOLEAN CheckFree
    );
    
BOOL
FreeChunk(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990
    Dave Hastings (daveh) 24-Apr-1991

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


MAJORCOMP=v86
MINORCOMP=monitor
TARGETNAME=monitor
TARGETPATH=obj
TARGETTYPE=LIBRARY

MVDMDIR=$(PROJECT_ROOT)\mvdm

INCLUDES=\
    ..\I386;\
    $(MVDMDIR)\inc;\
    $(MVDMDIR)\softpc.new\base\inc;\
    $(MVDMDIR)\softpc.new\host\inc

SOURCES=

!IFDEF PROFILE
C_DEFINES=-DCPU_30_STYLE -DMONITOR -DPROFILE
!ELSE
!IFDEF OLDBUILD
C_DEFINES=-DCPU_30_STYLE -DMONITOR -DOLDBUILD
!ELSE
C_DEFINES=-DCPU_30_STYLE -DMONITOR
!ENDIF
!ENDIF

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\suballoc\tsa.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <suballoc.h>

typedef struct _MemTrack *PMEMTRACK;

typedef struct _MemTrack {
    PMEMTRACK Next;
    ULONG Address;
    ULONG Size;
} MEMTRACK;

VOID
SimpleTest1(
    PVOID SA
    );

VOID
SimpleTest2(
    PVOID SA
    );

VOID
SimpleTest3(
    PVOID SA
    );

VOID
SimpleTest4(
    PVOID
    );

VOID
SimpleTest5(
    PVOID
    );

VOID
SimpleTest6(
    PVOID
    );

NTSTATUS
DecommitMem(
    ULONG BaseAddress,
    ULONG Size
    );

NTSTATUS
CommitMem(
    ULONG BaseAddress,
    ULONG Size
    );

VOID
MoveMem(
    ULONG Destination,
    ULONG Source,
    ULONG Size
    );

main(argv, argc)
char **argv;
int argc;
{
    NTSTATUS Status;
    PVOID BaseAddress, SA;
    ULONG Size;
    ULONG TotalFree, LargestFree;
    ULONG i,j;
    BOOL Success;

    //
    // Allocate a region of memory for SA to manage
    //
    BaseAddress = NULL;
    Size = 15*1024*1024 - 64 * 1024;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        0,
        &Size,
        MEM_RESERVE,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
        printf("Couldn't allocate memory, %lx\n", Status);
        return(0);
    }

    //
    // Initialize the suballocation stuff
    //
    SA = SAInitialize(
        (ULONG)BaseAddress,
        Size,
        CommitMem,
        DecommitMem,
        MoveMem
        );
    if (SA == NULL) {
        printf("SAInitialize Failed\n");
    }

    //
    // Find out how much free memory we have
    //
    Success = SAQueryFree(
        SA,
        &TotalFree,
        &LargestFree
        );
        
    if (!Success) {
        printf("Could not query free\n");
        return;
    }
    //
    // Run some tests
    //
    SimpleTest1(SA);

    //
    // Allocate blocks spanning two commit blocks
    //
    SimpleTest2(SA);

    //
    // Allocate and free all of memory (twice)
    //
    SimpleTest3(SA);

    //
    // More complex alloc and free test
    //
    SimpleTest4(SA);

    //
    // Test realloc
    //
    SimpleTest5(SA);
    
    //
    // Test Queryfree
    //
    SimpleTest6(SA);
    
    //
    // Make sure we didn't leak
    //
    Success = SAQueryFree(
        SA,
        &i,
        &j
        );
        
    if (!Success){
        printf("Couldn't requery free\n");
        return;
    }
    
    if ((i != TotalFree) || (j != LargestFree)) {
        printf("We leaked\n");
    }
}

VOID
SimpleTest1(
    PVOID SA
    )
{
    ULONG Address;
    BOOL Success;

    Success = SAAllocate(
        SA,
        50,
        &Address
        );

    if (!Success) {
        printf("SimpleTest1: Failed to allocate\n");
        return;
    }

    try {
        *((PULONG)(Address + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest1: Faulted accessing memory\n");
        return;
    }

    Success = SAFree(
        SA,
        50,
        Address
        );

     if (!Success) {
        printf("SimpleTest1: Failed to free\n");
        return;
    }

    Success = TRUE;

    try {
        *((PULONG)Address + 4) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = FALSE;
    }

    if (Success) {
        printf("SimpleTest1: memory not decommited\n");
    }
}

VOID
SimpleTest2(
    PVOID SA
    )
{
    ULONG SmallAddress, LargeAddress;
    BOOL Success;

    Success = SAAllocate(
        SA,
        50,
        &SmallAddress
        );

    if (!Success) {
        printf("SimpleTest2: Could not alloc small block\n");
        return;
    }

    try {
        *((PULONG)(SmallAddress + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest2: small block not committed\n");
        return;
    }

    Success = SAAllocate(
        SA,
        COMMIT_GRANULARITY + 50,
        &LargeAddress
        );

    if (!Success) {
        printf("SimpleTest2: Could not alloc large block\n");
        return;
    }

    try {
        *((PULONG)(LargeAddress + 4)) = 1;
        *((PULONG)(LargeAddress + COMMIT_GRANULARITY)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest2: Large block not committed\n");
        return;
    }

    Success = SAFree(
        SA,
        50,
        SmallAddress
        );

    if (!Success) {
        printf("SimpleTest2: failed to free small block\n");
        return;
    }

    try {
        *((PULONG)(LargeAddress + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest2: LargeBlock decommited!!\n");
        return;
    }

    Success = SAFree(
        SA,
        COMMIT_GRANULARITY + 50,
        LargeAddress
        );

    if (!Success) {
        printf("SimpleTest2: failed to free Large block\n");
        return;
    }

    Success = FALSE;
    try {
        *((PULONG)(LargeAddress + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = TRUE;
    }

    if (!Success) {
        printf("SimpleTest2: First block not decommited\n");
    }

    Success = FALSE;
    try {
        *((PULONG)(LargeAddress + COMMIT_GRANULARITY + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Success = TRUE;
    }

    if (!Success) {
        printf("SimpleTest2: Last block not decommited\n");
    }

}

VOID
SimpleTest3(
    PVOID SA
    )
{
    ULONG BlockCount, i, Address;
    PMEMTRACK p, Head, f;
    BOOL Success;

    Head = NULL;
    BlockCount = 0;
    do {

        Success = SAAllocate(
            SA,
            3072,
            &Address
            );

        if (Success) {
            p = malloc(sizeof(MEMTRACK));
            if (p == NULL) {
                printf("SimpleTest3: malloc error\n");
                return;
            }
            p->Next = Head;
            p->Size = 3072;
            p->Address = Address;
            Head = p;
            BlockCount++;
        }
    } while (Success);

    try {
        p = Head;
        while (p != NULL) {
            *((PULONG)(p->Address + 100)) = 1;
            p = p->Next;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest3: failed first access test\n");
        return;
    }

    p = Head;
    while (p != NULL) {

        Success = SAFree(
            SA,
            3072,
            p->Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed first free test\n");
            return;
        }
        f = p;
        p = p->Next;
        free(f);
    }

    Head = NULL;

    for (i = 0; i < BlockCount; i++) {

        Success = SAAllocate(
            SA,
            3072,
            &Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed second alloc test\n");
            return;
        }

        p = malloc(sizeof(MEMTRACK));
        if (p == NULL) {
            printf("SimpleTest3: malloc error\n");
            return;
        }

        p->Next = Head;
        p->Size = 3072;
        p->Address = Address;
        Head = p;
    }

    try {
        p = Head;
        while (p != NULL) {
            *((PULONG)(p->Address + 100)) = 1;
            p = p->Next;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest3: failed second access test\n");
        return;
    }

    p = Head;
    while (p != NULL) {

        Success = SAFree(
            SA,
            3072,
            p->Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed second free test\n");
            return;
        }
        f = p;
        p = p->Next;
        free(f);
    }
}

VOID
SimpleTest4(
    PVOID SA
    )
{
    ULONG i, Address;
    PMEMTRACK p, Head, f;
    BOOL Success;

    Head = NULL;
    do {

        Success = SAAllocate(
            SA,
            3072,
            &Address
            );

        if (Success) {
            p = malloc(sizeof(MEMTRACK));
            if (p == NULL) {
                printf("SimpleTest4: malloc error\n");
                return;
            }
            p->Next = Head;
            p->Size = 3072;
            p->Address = Address;
            Head = p;
        }
    } while (Success);

    p = Head;
    p = p->Next;
    p = p->Next;

    Success = SAFree(
        SA,
        3072,
        p->Next->Address
        );

    if (!Success) {
        printf("SimpleTest4: could not free\n");
        return;
    }

    f = p->Next;
    p->Next = p->Next->Next;
    free (f);

    p = p->Next;
    p = p->Next;

    Success = SAFree(
        SA,
        3072,
        p->Next->Address
        );

    if (!Success) {
        printf("SimpleTest4: could not free\n");
        return;
    }

    f = p->Next;
    p->Next = p->Next->Next;
    free (f);

    Success = SAFree(
    	SA,
    	3072,
    	p->Next->Address
    	);
    if (!Success) {
        printf("SimpleTest4: could not free\n");
        return;
    }

    f = p->Next;
    p->Next = p->Next->Next;
    free (f);

    Success = SAAllocate(
        SA,
        3072,
        &Address
        );

    try {
        *((PULONG)(Address + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest4: failed to access\n");
        return;
    }

    if (!Success) {
        printf("SimpleTest4: could not allocate\n");
        return;
    }

    p = malloc(sizeof(MEMTRACK));
    if (!p) {
        printf("SimpleTest4: could not malloc\n");
        return;
    }

    p->Next = Head;
    p->Size = 3072;
    p->Address = Address;
    Head = p;
    
    Success = SAAllocate(
        SA,
        3072,
        &Address
        );

    try {
        *((PULONG)(Address + 4)) = 1;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        printf("SimpleTest4: failed to access\n");
        return;
    }

    if (!Success) {
        printf("SimpleTest4: could not allocate\n");
        return;
    }

    p = malloc(sizeof(MEMTRACK));
    if (!p) {
        printf("SimpleTest4: could not malloc\n");
        return;
    }

    p->Next = Head;
    p->Size = 3072;
    p->Address = Address;
    Head = p;
    
    p = Head;
    while (p != NULL) {

        Success = SAFree(
            SA,
            3072,
            p->Address
            );

        if (!Success) {
            printf("SimpleTest3: Failed second free test\n");
            return;
        }
        f = p;
        p = p->Next;
        free(f);
    }
}

VOID
SimpleTest5(
    PVOID SA
    )
{
    ULONG Address, NewAddress;
    ULONG Address1, Address2, Address3;
    ULONG Size1, Size2, Size3;
    BOOL Success;
    
    Success = SAAllocate(
        SA,
        3072,
        &Address
        );
    
    if (!Success) {
        printf("SimpleTest5: failed to allocate\n");
        return;
    }
    
    Success = SAReallocate(
        SA,
        3072,
        Address,
        3000,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5:  failed to reallocate\n");
        return;
    }
    
    if (NewAddress != Address) {
        printf("SimpleTest5: Realloc in place failed\n");
    }

    Success = SAReallocate(
        SA,
        3072,
        Address,
        200,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5:  failed to reallocate\n");
        return;
    }
    
    if (NewAddress != Address) {
        printf("SimpleTest5: Realloc in place failed\n");
        return;
    }
    
    Success = SAReallocate(
        SA,
        200,
        Address,
        6000,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }
    
    if (NewAddress != Address) {
        printf("SimpleTest5: realloc in place failed\n");
        return;
    }
    
    Success = SAAllocate(
        SA,
        1500,
        &Address
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to allocate\n");
        return;
    }
    
    Address1 = NewAddress;
    Size1 = 6000;
    Address2 = Address;
    Size2 = 1500;
    
    Success = SAReallocate(
        SA,
        Size1,
        Address1,
        3000,
        &NewAddress
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }

    if (Address1 != NewAddress) {
        printf("SimpleTest5: realloc in place failed\n");
        return;
    }
    Size1= 3000;
    
    Success = SAAllocate(
        SA,
        2000,
        &Address
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to allocate\n");
        return;
    }

    Address3 = Address;
    Size3 = 2000;
    
    Success = SAFree(
        SA,
        Size1,
        Address1
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to free\n");
        return;
    }
    
    Success = SAReallocate(
        SA,
        Size3,
        Address3,
        5000,
        &Address
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }
    
    Address3 = Address;
    Size3 = 5000;
    
    Success = SAReallocate(
        SA,
        Size3,
        Address3,
        10000,
        &Address
        );
    
    if (!Success) {
        printf("SimpleTest5: failed to reallocate\n");
        return;
    }
    Address3 = Address;
    Size3 = 10000;
    
    Success = SAFree(
        SA,
        Size2,
        Address2
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to free\n");
        return;
    }
    
    Success = SAFree(
        SA,
        Size3,
        Address3
        );
        
    if (!Success) {
        printf("SimpleTest5: failed to free\n");
        return;
    }
}

VOID
SimpleTest6(
    PVOID SA
    )
{
    ULONG LargestFree, TotalFree;
    BOOL Success;
    
    Success = SAQueryFree(
        SA,
        &TotalFree,
        &LargestFree
        );
    
}


NTSTATUS
CommitMem(
    ULONG BaseAddress,
    ULONG Size
    )
{
    NTSTATUS Status;
    PVOID Address;
    ULONG size;

    Address = (PVOID)BaseAddress;
    size = Size;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &Address,
        0L,
        &size,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (!NT_SUCCESS(Status)) {
        printf(
            "CommitMem failed to commit %lx, %lx, error %lx\n",
            Address,
            size,
            Status
            );
    }

    return Status;
}

NTSTATUS
DecommitMem(
    ULONG BaseAddress,
    ULONG Size
    )
{
    NTSTATUS Status;
    PVOID Address;
    ULONG size;

    Address = (PVOID)BaseAddress;
    size = Size;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &Address,
        &size,
        MEM_DECOMMIT
        );

    if (!NT_SUCCESS(Status)) {
        printf(
            "DecommitMem failed to decommit %lx, %lx, error %lx\n",
            Address,
            size,
            Status
            );
    }

    return Status;
}

VOID
MoveMem(
    ULONG Destination,
    ULONG Source,
    ULONG Size
    )
{
    RtlMoveMemory(
        (PVOID)Destination,
        (PVOID)Source,
        Size
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\suballoc\suballoc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    suballoc.c

Abstract:

    This module contains code for managing a paritially commited address
    space.  It handles allocation of chunks of memory smaller than the 
    commit granularity.  It commits and decommits memory as needed using
    the supplied function for committing and decommitting memory.  The 
    structures used for tracking the address space are allocated outside
    of the specified addresss space.

Author:

    Dave Hastings (daveh) creation-date 21-Jan-1994
    
Notes:

    Since this package does not actually access memory in the address space
    it is managing, it will work as well with real linear addresses or 
    "Intel Addresses" such as would be encountered with the Insignia Emulator
    on risc.

Revision History:


--*/
#include "suballcp.h"

PVOID
SAInitialize(
    ULONG BaseAddress,
    ULONG Size,
    PSACOMMITROUTINE CommitRoutine,
    PSACOMMITROUTINE DecommitRoutine,
    PSAMEMORYMOVEROUTINE MemoryMoveRoutine
    )
/*++

Routine Description:

    This function performs initialization of the sub allocation package
    for the specified addresss range.  It allocates the data structures
    necessary to track the allocations

Arguments:

    BaseAddress -- Supplies the base address of the address space to
        sub allocate.
    Size -- Supplies the size in bytes of the address space to sub allocate.
    CommitRoutine -- Supplies a pointer to the routine used to commit regions
        of the address space.

Return Value:

    If the function was successful it returns a pointer to the sub-allocation
    data structures.  Otherwise it returns NULL.
    
--*/
{
    PSUBALLOCATIONDATA SubAlloc;
    ULONG SASize;

    ASSERT_STEPTHROUGH;
    //
    // Asserts to insure that everything is as we expect it to be
    //
    ASSERT(((COMMIT_GRANULARITY % SUBALLOC_GRANULARITY) == 0));
        
    //
    // Allocate the tracking structure
    // 
    // SUBALLOCATIONDATA is declared with 1 uchar for the bitmap.
    // this is the reason for subtracting one from the total size
    // calculation.
    //
    SASize = sizeof(SUBALLOCATIONDATA) 
        + (Size / SUBALLOC_GRANULARITY) / sizeof(UCHAR) - 1;

    SubAlloc = malloc(SASize);
    
    if (SubAlloc == NULL) {
        return NULL;
    }
    
    //
    // Initialize the structure
    //
    RtlZeroMemory(SubAlloc, SASize);
    
    INIT_SUBALLOC_SIGNATURE(SubAlloc);
    SubAlloc->BaseAddress = BaseAddress;
    SubAlloc->Size = Size / SUBALLOC_GRANULARITY;
    SubAlloc->CommitRoutine = CommitRoutine;
    SubAlloc->DecommitRoutine = DecommitRoutine;
    SubAlloc->MoveMemRoutine = MemoryMoveRoutine;

    return SubAlloc;    
}

BOOL 
SAQueryFree(
    PVOID SubAllocation,
    PULONG FreeBytes,
    PULONG LargestFreeBlock
    )    
/*++

Routine Description:

    This routine returns the number of free bytes in the 
    sub allocated address space.

Arguments:
    
    SubAllocation -- Supplies the pointer returned by SAInitialize
    FreeBytes -- Returns the number of free bytes
   
Return Value:

    TRUE -- if successful, and FreeBytes contains the number of free bytes.
    FALSE otherwise
    
--*/
{
    ULONG i, FreeCount;
    PSUBALLOCATIONDATA SubAlloc;
    ULONG TempLargest, LargestBlock;
    
    ASSERT_STEPTHROUGH;
    
    //
    // Get a typed pointer
    //
    SubAlloc = SubAllocation;
    
    //
    // Make sure that we have what we think we do
    //
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Count the free chunks and find largest block
    //
    FreeCount = 0;
    LargestBlock = 0;
    i = 0;
    while (i < SubAlloc->Size) {
        
        TempLargest = 0;
        while (
            (i < SubAlloc->Size) && 
            (GET_BIT_FROM_CHAR_ARRAY(SubAlloc->Allocated, i) == 0) 
        ){
            FreeCount++;
            TempLargest++;
            i++;
        }
    
        if (TempLargest > LargestBlock) {
            LargestBlock = TempLargest;
        }
        
        //
        // Skip allocated blocks
        //
        while (
            (i < SubAlloc->Size) && 
            (GET_BIT_FROM_CHAR_ARRAY(SubAlloc->Allocated, i) == 1)
        ) {
            i++;
        }
    }
    
    *FreeBytes = FreeCount * SUBALLOC_GRANULARITY;
    *LargestFreeBlock = LargestBlock * SUBALLOC_GRANULARITY;
    return TRUE;
}

BOOL
SAAllocate(
    PVOID SubAllocation,
    ULONG Size,
    PULONG Address
    )
/*++

Routine Description:

    This function allocates a portion of the address space described by 
    SubAllocation.  If necessary, it will commit additional blocks. 
    Size is rounded up to the next higher multiple of SUBALLOC_GRANULARITY.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    Size -- Supplies the size in bytes of the region to allocate.
    Address -- Returns the address of the region allocated.

Return Value:

    TRUE if successful.  If false is returned, no address is returned.
    
Notes:

    Zero is a valid value for the returned address.

--*/
{
    ULONG AllocateSize, i, CurrentChunk;
    BOOL Done = FALSE;
    PSUBALLOCATIONDATA SubAlloc;
    BOOL Success;
    
    ASSERT_STEPTHROUGH;
    
    //
    // Get a typed pointer.  This allows us to avoid
    // casting every time we access the pointer.
    //
    SubAlloc = SubAllocation;

    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Round size and make into number of blocks
    //
    AllocateSize = ALLOC_ROUND(Size);

    //
    // Find a chunk that is free
    //
    // We need this loop in spite of the fact that we 
    // are keeping an index to the first free block.
    // We update this pointer somewhat heuristically.
    // If we allocate the first free block, we update
    // the index to point past the block we allocated.
    // We don't repeat the free scan however, so the 
    // index may actually point to an allocated block.
    //
    CurrentChunk = SubAlloc->FirstFree;
    while (CurrentChunk < SubAlloc->Size) {
        if (GET_BIT_FROM_CHAR_ARRAY(SubAlloc->Allocated, CurrentChunk) == 0) {
            SubAlloc->FirstFree = CurrentChunk;
            break;
        }
        CurrentChunk++;
    }

    //
    // Find a block that is big enough
    //
    while (!Done && (CurrentChunk < SubAlloc->Size)){
    
        //
        // Search for a contiguous block large enough
        //
        for (i = 0; i < AllocateSize; i++){
            //
            // Insure we don't walk off the end of the data structure
            //
            if ((i + CurrentChunk) >= SubAlloc->Size){
                CurrentChunk += i; // Satisfy termination condition
                break;
            }
            
            //
            // Check to see if this chunk is free
            //
            if (
                GET_BIT_FROM_CHAR_ARRAY(
                    SubAlloc->Allocated, 
                    i + CurrentChunk
                    ) 
                    == 0
            ){
                continue;
            } else {
                //
                // Chunk is not free, so advance the search
                //
                CurrentChunk += i + 1;
                break;
            }
        }
        
        //
        // Check to see if we found a chunk 
        //
        if (i == AllocateSize) {
            Done = TRUE;
        } 
    }
    
    //
    // If we found the chunk, commit it (if necessary) and mark it allocated
    //
    // N.B.  It is important to commit it first, and mark it allocated last, 
    //       because we use the allocated bits to determine if the chunk is 
    //       committed.  If all of the allocated bits are clear, the chunk 
    //       is not commited yet.
    //
    if (Done) {

        //
        // Allocate and commit the memory
        //
        Success = AllocateChunkAt(
            SubAlloc,
            AllocateSize,
            CurrentChunk,
            FALSE
            );
        
        if (!Success) {
            return FALSE;
        }
        
        *Address = BLOCK_INDEX_TO_ADDRESS(SubAlloc, CurrentChunk);

        ASSERT((SubAlloc->BaseAddress <= *Address) && 
            ((SubAlloc->BaseAddress + SubAlloc->Size * SUBALLOC_GRANULARITY)
            > *Address));
#if 0            
        {
            char Buffer[80];
            
            sprintf(Buffer, "SAAllocate: Allocating at address %lx\n", *Address);
            OutputDebugString(Buffer);
        }
#endif        
        return TRUE;
        
    } else {
        return FALSE;
    }
}

BOOL
SAFree(
    PVOID SubAllocation,
    ULONG Size,
    ULONG Address
    )
/*++

Routine Description:

    This routine frees a sub-allocated chunk of memory.  If the 
    entire commited block (or blocks) that the specified chunk
    belongs to are free, the chunks are decommitted.  Address is 
    rounded down to the next lower SUBALLOC_GRANULARITY boundary.
    size is rounded up to the next higher multiple of SUBALLOC_GRANULARITY.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    Size -- Supplies the size in bytes of the region to free.
    Address -- Supplies the address of the region to free.

Return Value:

    TRUE if successful.
    
Notes:

    It is possible to free a different size at a particular 
    address than was allocated.  This will not cause the 
    SubAllocation package any problems.

    BUGBUG decommit error handling?    
--*/
{
    PSUBALLOCATIONDATA SubAlloc;
    ULONG AllocatedSize, BaseBlock;
    
    SubAlloc = SubAllocation;
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Make sure that the space to free is really ours
    // (Entire block within range, and correctly aligned)
    if (
        (Address < SubAlloc->BaseAddress) || 
        (Address >= (SubAlloc->BaseAddress + SubAlloc->Size * SUBALLOC_GRANULARITY)) ||
        ((Address + Size) > (SubAlloc->BaseAddress + SubAlloc->Size * SUBALLOC_GRANULARITY)) ||
        (Address % SUBALLOC_GRANULARITY)
    ) {
        return FALSE;
    }
    
    //
    // Turn Address into Block #
    //
    BaseBlock = ADDRESS_TO_BLOCK_INDEX(SubAlloc, Address);
        
    //
    // Round up the size    
    //
    AllocatedSize = ALLOC_ROUND(Size);

    return FreeChunk(
        SubAlloc,
        AllocatedSize,
        BaseBlock
        );
}

BOOL
SAReallocate(
    PVOID SubAllocation,
    ULONG OriginalSize,
    ULONG OriginalAddress,
    ULONG NewSize,
    PULONG NewAddress
    )
/*++

Routine Description:

    This routine reallocates a sub allocated block of memory.
    The sizes are rounded up to the next SUBALLOC_GRANULARITY.
    The Original address is rounded down to the next SUBALLOC_GRANULARITY
    boundary.  Only min(OriginalSize, NewSize) bytes of data are copied to
    the new block.  The block changed in place if possible.
    
    The following is an enumation of the possible successful reallocs.
    
    1.  NewSize < OriginalSize
        free block tail
    2.  NewSize > OriginalSize
        a.)  Sufficient freespace at OriginalAddress + OriginalSize
                Allocate the space at the tail of the block
        b.)  Sufficient free space at OriginalAddress - size delta
                Allocate the space at the beginning of the block, and
                copy the data.
        c.)  Sufficient space elsewhere in the address space
                Allocate the space, and copy the block.
                
    If none of the above is true, the realloc fails.  The above are 
    in order of preference.

Arguments:

    SubAllocation -- Supplies the pointer returned by SAInitialize.
    OriginalSize -- Supplies the old size in bytes of the block.
    OriginalAddress -- Supplies the old address of the block.
    NewSize -- Supplies the new size in bytes of the block.
    NewAddress -- Returns the new address of the block.

Return Value:

    True if successful.  If unsucessful, no allocation is changed.
    
Notes:

    If the caller does not supply the correct original size for the block,
    some memory may be lost, and the block may be moved unnecessarily.
    
--*/
{

    ULONG OriginalSizeBlock, NewSizeBlock, OriginalIndex;
    ULONG AdditionalBlocks, Address;
    BOOL Success;
    PSUBALLOCATIONDATA SubAlloc;

    SubAlloc = SubAllocation;
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Convert Sizes and address to blocks
    //
    OriginalSizeBlock = ALLOC_ROUND(OriginalSize);
    NewSizeBlock = ALLOC_ROUND(NewSize);
    OriginalIndex = ADDRESS_TO_BLOCK_INDEX(SubAlloc, OriginalAddress);
    
    //
    // Check to see if we are changing the size of the block
    //
    // N.B.  Because we have rounded the numbers to an allocation
    //       boundary, the following test may succeed (correctly)
    //       even though OriginalSize != NewSize
    //
    if (OriginalSizeBlock == NewSizeBlock) {
        *NewAddress = OriginalAddress;
        return TRUE;
    }
    
    //
    // Check to see if the block is getting smaller
    //
    if (OriginalSizeBlock > NewSizeBlock) {
    
        //
        // Free the tail of the block
        //
        Success = FreeChunk(
            SubAlloc, 
            OriginalSizeBlock - NewSizeBlock,
            OriginalIndex + NewSizeBlock
            );
            
        if (Success) {
            *NewAddress = OriginalAddress;
            return TRUE;
        } else {
            return FALSE;
        }
    }
    
    //
    // Try to allocate the space at the end of the block
    //
    AdditionalBlocks = NewSizeBlock - OriginalSizeBlock;
    
    Success = AllocateChunkAt(
        SubAlloc,
        AdditionalBlocks,
        OriginalIndex + OriginalSizeBlock,
        TRUE
        );
        
    //
    // If there was space, return success
    //
    if (Success) {
        *NewAddress = OriginalAddress;
        return TRUE;
    }
    
    //
    // Try to allocate space at the beginning of the block
    //
    Success = AllocateChunkAt(
        SubAlloc,
        AdditionalBlocks,
        OriginalIndex - AdditionalBlocks,
        TRUE
        );
        
    if (Success) {
        //
        // Move the data
        //
        // N.B.  We can't just call RtlMoveMemory, 
        //       because we don't know the correspondence
        //       between the address space we manage, and 
        //       real linear addresses.  In addition, for
        //       risc NTVDM, some additional work may have
        //       to be done (such as flushing caches).
        //
        SubAlloc->MoveMemRoutine(
            BLOCK_INDEX_TO_ADDRESS(
                SubAlloc, 
                (OriginalIndex - AdditionalBlocks)
                ),
            OriginalAddress,
            OriginalSize
            );
            
        *NewAddress = BLOCK_INDEX_TO_ADDRESS(
            SubAlloc,
            (OriginalIndex - AdditionalBlocks)
            );
            
        return TRUE;
    }
    
    //
    // Attempt to allocate a new block
    //
    Success = SAAllocate(
        SubAlloc,
        NewSize,
        &Address
        );
        
    if (Success) {
        //
        // Move the data
        // 
        // N.B. We could copy the data, but it would
        //      require one more function pointer.
        //
        SubAlloc->MoveMemRoutine(
            Address,
            OriginalAddress,
            OriginalSize
            );
            
        SAFree(
            SubAlloc,
            OriginalSize,
            OriginalAddress
            );
            
        //
        // Indicate success
        //
        *NewAddress = Address;
        return TRUE;
    }
    
    //
    // All reallocation strategies failed.  
    //
    return FALSE;
}

BOOL
AllocateChunkAt(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex,
    BOOLEAN CheckFree
    )
/*++

Routine Description:

    This routine attempts to allocate the specified chunk
    of memory.  It first checks to make sure that it is 
    free.

Arguments:

    SubAlloc -- Supplies a pointer to the suballocation data
    Size -- Supplies the size of the chunk to allocate
    BlockIndex -- Supplies the index of the beginning of the block
        to allocate
    CheckFree -- Supplies an indication of whether to check and see
        if the memory is free.  If this routine is called from 
        SAAllocate, we know the memory is free.
        
Return Value:

    True if successful
    
--*/
{
    ULONG i;

    if (CheckFree) {
        //
        // Verify that the memory is free
        //
        for (i = 0; i < Size; i++){
            //
            // Insure we don't walk off the end of the data structure
            //
            if ((i + BlockIndex) >= SubAlloc->Size){
                break;
            }
            
            //
            // Check to see if this chunk is free
            //
            if (
                GET_BIT_FROM_CHAR_ARRAY(
                    SubAlloc->Allocated, 
                    i + BlockIndex
                    ) 
                == 0
            ){
                continue;
            } else {
                //
                // Chunk is not free
                //
                break;
            }
        }
 
        //
        // If the chunk is not free
        //   
        if (i != Size) {
            return FALSE;
        }
    }

    //
    // Commit the chunk
    //
    if (!CommitChunk(SubAlloc, BlockIndex, Size, SACommit)) {
        return FALSE;
    }
    
    //
    // Mark it as allocated
    //    
    for (i = BlockIndex; i < BlockIndex + Size; i++) {
        SET_BIT_IN_CHAR_ARRAY(SubAlloc->Allocated, i);
    }
    
    //
    // Update the pointer to the first free block
    //
    if (BlockIndex == SubAlloc->FirstFree) {
        SubAlloc->FirstFree += Size;
    }
    
    return TRUE;
}


BOOL
FreeChunk(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Size,
    ULONG BlockIndex
    )
/*++

Routine Description:

    This routine actually marks the memory as free
    and decommits it as necessary.

Arguments:

    SubAlloc -- Supplies a pointer to the suballocation data
    Size -- Supplies the size (in SUBALLOC_GRANULARITY) of the 
        region to free
    BlockIndex -- Supplies the index of the begining of the region
        (in SUBALLOC_GRANULARITY)
        
Return Value:

    TRUE if successful.

--*/
{
    SUBALLOCATIONDATA LocalSubAlloc;
    ULONG CurrentBlock;
    BOOL Success;
    
    //
    // Save a copy of the suballoc data
    //
    LocalSubAlloc = *SubAlloc;
    
    //
    // reset free pointer
    //
    if (BlockIndex < SubAlloc->FirstFree) {
        SubAlloc->FirstFree = BlockIndex;
    }
    //    
    // Mark the region as free
    //
    // N.B.  We mark the block as free before decommitting it, because
    //       the decommit code will use the allocated bits to determine which
    //       parts can be decommitted.
    //
    for (CurrentBlock = BlockIndex; 
        CurrentBlock < BlockIndex + Size; 
        CurrentBlock++
    ) {
        CLEAR_BIT_IN_CHAR_ARRAY(SubAlloc->Allocated, CurrentBlock);
    }
    
    //
    // Decommit the memory
    //
    Success = CommitChunk(SubAlloc, BlockIndex, Size, SADecommit);
    
    if (!Success) {
        *SubAlloc = LocalSubAlloc;
    }
    
    return Success;
}

BOOL
CommitChunk(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG StartChunk,
    ULONG Size,
    COMMIT_ACTION Action
    )
/*++

Routine Description:

    This routine commits a chunk of memory.  Part or all
    of the specified chunk may already be commited.

Arguments:

    SubAllocation -- Supplies a pointer to the suballocation data
    StartChunk -- Supplies the relative start of the region to be  
        committed (in SUBALLOCATION_GRANULARITY)
    Size -- Supplies the size of the chunk to be commited 
        (in SUBALLOCATION_GRANULARITY)
    
Return Value:

    TRUE -- If the block was successfully committed (or already committed)
    FALSE -- Otherwise

Notes:
    
    This routine depends on the allocated bits in SubAlloc to determine
    whether memory is committed.  When memory is to be committed, CommitBlock
    must be called before the Allocated bits are modified.  When memory is 
    decommitted, the Allocated bits must be modified before CommitBlock is
    called.
           
--*/
{
    ULONG FirstBlock, LastBlock, CurrentBlock;
    NTSTATUS Status =  STATUS_INVALID_PARAMETER;
    
    ASSERT_STEPTHROUGH;

    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Round Start down to next COMMIT_GRANULARITY and convert to block #
    //
    FirstBlock = (StartChunk * SUBALLOC_GRANULARITY) / COMMIT_GRANULARITY;
    
    //
    // Round StartChunk + size up to next COMMIT_GRANULARITY
    //
    LastBlock = ((StartChunk + Size) * SUBALLOC_GRANULARITY + 
        (COMMIT_GRANULARITY - 1)) / COMMIT_GRANULARITY;
    
    for (
        CurrentBlock = FirstBlock; 
        CurrentBlock < LastBlock; 
        CurrentBlock++
    ) {
        
        //
        // If the block is not committed, either commit it or decommit it, 
        // depending on the value of Action.
        //
        if (!IsBlockCommitted(SubAlloc, CurrentBlock)) {
            if (Action == SACommit) {
            
                Status = (SubAlloc->CommitRoutine)(
                    CurrentBlock * COMMIT_GRANULARITY + SubAlloc->BaseAddress,
                    COMMIT_GRANULARITY
                    );
                
            } else if (Action == SADecommit) {

                Status = (SubAlloc->DecommitRoutine)(
                    CurrentBlock * COMMIT_GRANULARITY + SubAlloc->BaseAddress,
                    COMMIT_GRANULARITY
                    );

            }
            if (Status != STATUS_SUCCESS) {
            //
            // Bugbug -- decommit any blocks committed here
            //
                return FALSE;
            }
        }
    }
    return TRUE;
}

BOOL
IsBlockCommitted(
    PSUBALLOCATIONDATA SubAlloc,
    ULONG Block
    )
/*++

Routine Description:

    This routine checks to see if a particular block of the
    suballocation is committed.  

Arguments:

    SubAlloc -- Supplies a pointer to the suballocation data
    Block -- Supplies the number of the block to check
    
Return Value:

    TRUE -- if the block is committed
    FALSE -- if the block is not committed

Notes:

    The return value is based on the state of the bits in the 
    suballocation data, not on information from the NT memory 
    manager.    
    
--*/
{
    BOOL Committed = FALSE;
    ULONG i;
    
    ASSERT_STEPTHROUGH;
    ASSERT_SUBALLOC(SubAlloc);
    
    //
    // Check the bits for each of the suballoc blocks in the 
    // commit block
    //
    for (i = 0; i < COMMIT_GRANULARITY / SUBALLOC_GRANULARITY; i++) {
        
        //
        // Check to see if this suballoc block is allocated
        //    
        if (
            GET_BIT_FROM_CHAR_ARRAY(
                SubAlloc->Allocated, 
                i + Block * COMMIT_GRANULARITY / SUBALLOC_GRANULARITY
                )
        ) {
            Committed = TRUE;
            break;
        }
    }
    
    return Committed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\fastpm.asm ===
title "Fast Protected Mode services"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    fastpm.asm
;
; Abstract:
;
;    This module implements a fast entry to and exit from protected mode
;
; Author:
;
;    Dave Hastings (daveh) 26-Jul-91
;
;--
.386p

include ks386.inc
include callconv.inc
include bop.inc
include vint.inc
include vdmtib.inc

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING
_TEXT   ENDS

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public _NTVDMpLockPrefixTable
_NTVDMpLockPrefixTable    label dword
        dd offset FLAT:_ntvdmlock1
        dd offset FLAT:_ntvdmlock2
        dd 0

ClientPMStack   df      ?
ClientPMEntry   df      ?

_DATA   ENDS

_TEXT   SEGMENT

; Interrupt type definitions
CPU_YODA_INT            equ 4
BIT_CPU_YODA_INT        equ 0
CPU_HW_RESET            equ 0
BIT_CPU_HW_RESET        equ 1
CPU_TIMER_TICK          equ 1
BIT_CPU_TIMER_TICK      equ 2
CPU_HW_INT              equ 3
BIT_CPU_HW_INT          equ 3

        assume DS:NOTHING
cPublicProc _VdmTrapcHandler, 0

;
; On entry, [ebx]->VdmContext
;

;
; zero higher 16bit of esp. (The Iretd in kernel trap handler puts higher 16bit
; of kernel esp back to our user mode esp even though the higher 16bit of
; TrapFrame.HardwareEsp is zeroed.
;
        and     esp, 0ffffh
;@@:

;
; Note, here we use app's stack to do the far return
;

        push    [ebx].VtVdmContext.CsSegCs
        push    [ebx].VtVdmContext.CsEip
        mov     ebx, [ebx].VtVdmContext.CsEbx
        retf

stdENDP _VdmTrapcHandler

        page    ,132
        subttl "FastEnterPm"
;++
;
;   Routine Description:
;
;       This routine is a faster way to enter 16 bit vdm protected mode.
;       Instead of making a system call, we just save the 32 bit state
;       into the VdmTib, restore the Vdm state from the VdmTib, and do
;       a far return to the application.
;
;   Arguments:
;
;       ss:sp + 4 = pointer to VdmTib
;
;   Returns:
;
;       nothing.
;
        assume DS:FLAT
cPublicProc _FastEnterPm,0

        push    ebp
        mov     ebp,esp                         ; set up stack frame

        push    ebx                             ; free up reg for pointer

        mov     ebx, KGDT_R3_TEB OR RPL_MASK
        mov     fs, ebx
        mov     ebx, fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm

        ; translate the interrupt flag to the virtual interrupt flag

        test    [ebx].VtVdmContext.CsEFlags,dword ptr EFLAGS_INTERRUPT_MASK
        jz      fe10

_ntvdmlock1:
        lock or dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_VIRTUAL_INTERRUPTS
        test    dword ptr ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_INTERRUPT_PENDING
        jz      fe20

        ; set up event info for an interrupt acknowlege

        mov     word ptr [ebx].VtEventInfo.EiEvent,VdmIntAck
        mov     word ptr [ebx].VtEventInfo.EiInstructionSize,0
        mov     word ptr [ebx].VtEventInfo.EiIntAckInfo,0

        pop     ebx
        mov     esp,ebp
        pop     ebp
        stdRET  _FastEnterPm

fe10:
_ntvdmlock2:
        lock and dword ptr ds:FIXED_NTVDMSTATE_LINEAR, NOT VDM_VIRTUAL_INTERRUPTS
fe20:
        mov     [ebx].VtMonitorContext.CsEax,eax
        mov     eax,[ebp - 4]
        mov     [ebx].VtMonitorContext.CsEbx,eax
        mov     [ebx].VtMonitorContext.CsEcx,ecx
        mov     [ebx].VtMonitorContext.CsEdx,edx
        mov     [ebx].VtMonitorContext.CsEsi,esi
        mov     [ebx].VtMonitorContext.CsEdi,edi
        mov     eax,[ebp]
        mov     [ebx].VtMonitorContext.CsEbp,eax
        mov     eax,ebp

        add     eax,8                           ; pop ebp and ret addr

        mov     [ebx].VtMonitorContext.CsEsp,eax
        mov     eax,[ebp + 4]
        mov     [ebx].VtMonitorContext.CsEip,eax
        mov     eax,cs
        mov     [ebx].VtMonitorContext.CsSegCs,eax
        mov     eax,ss
        mov     [ebx].VtMonitorContext.CsSegSs,eax
        mov     eax,ds
        mov     [ebx].VtMonitorContext.CsSegDs,eax
        mov     eax,es
        mov     [ebx].VtMonitorContext.CsSegEs,eax
        mov     eax,fs
        mov     [ebx].VtMonitorContext.CsSegFs,eax
        mov     eax,gs
        mov     [ebx].VtMonitorContext.CsSegGs,eax
        pushfd
        pop     eax
        mov     [ebx].VtMonitorContext.CsEflags,eax


        test    [ebx].VtVdmContext.CsEflags, EFLAGS_TF_MASK ; debugging?
        jz      fe_atomic                       ; no, return the robust way

;
; Beginning STACK-BASED return
;
; The following code transitions us back to client code in protect mode
; using the client's stack. This is not a good thing to do in general
; since this is not how things worked on win31. But it is necessary if
; we are setting the trap flag in the EFLAGS register in order to break
; on the correct instruction.
;
        mov     eax,[ebx].VtVdmContext.CsSegSs
        mov     es,eax
        mov     edi,[ebx].VtVdmContext.CsEsp    ; es:edi -> stack
        lar     eax,eax
        test    eax,400000h                     ; big?
        jnz     fe30

        movzx   edi,di
fe30:   mov     eax,[ebx].VtVdmContext.CsEflags
        sub     edi,4
        mov     es:[edi],eax             ; push Eflags
        mov     eax,[ebx].VtVdmContext.CsSegCs
        sub     edi,4
        mov     es:[edi],eax             ; push cs
        mov     eax,[ebx].VtVdmContext.CsEip
        sub     edi,4
        mov     es:[edi],eax             ; push ip
        sub     edi,4
        mov     eax,[ebx].VtVdmContext.CsEbp ; push ebp
        mov     es:[edi],eax

fe40:   push    es
        push    edi                     ; push ss:esp for lss esp
        mov     eax,esp                 ; save sp for pushad

        ; simulate pushad
        push    dword ptr [ebx].VtVdmContext.CsEax
        push    dword ptr [ebx].VtVdmContext.CsEcx
        push    dword ptr [ebx].VtVdmContext.CsEdx
        push    dword ptr [ebx].VtVdmContext.CsEbx
        push    eax
        push    ebp                     ; save pointer to stack frame
        push    dword ptr [ebx].VtVdmContext.CsEsi
        push    dword ptr [ebx].VtVdmContext.CsEdi

        ; push seg regs
        push    dword ptr [ebx].VtVdmContext.CsSegFs
        push    dword ptr [ebx].VtVdmContext.CsSegGs
        push    dword ptr [ebx].VtVdmContext.CsSegDs
        push    dword ptr [ebx].VtVdmContext.CsSegEs

        ; set up VDM seg regs
        pop     es
        pop     ds
        pop     gs             ; pop es,fs,gs of invalid selectors are trapped in ntoskrnl,
        pop     fs             ; and handled by setting to zero

        ; set up VDM general regs
        popad

        ; set up vdm stack
        lss esp,[ebp - 12]

        ; restore ebp
        pop     ebp

        ; return to VDM
        iretd

;
; Beginning STACK-LESS return
;
; WARNING:
; The following code does the final dispatch to the Client code.
; It uses STATIC data to hold CS, EIP, SS, ESP. THAT MAKES THIS CODE
; NON-REENTRANT. For correct operation, the rest of this code in this
; routine must execute to completion before coming back through. All
; ntvdm support code must honor this arrangement.
;
; The reason this code has this restriction is to avoid using the
; client's stack. Originally, this routine built a stack frame on the
; client stack, and IRET'd to it. This breaks some DPMI applications,
; either at a point where they have a transient condition with an invalid
; stack pointer, or because they expect unused stack space to be left
; alone by the system.
;
fe_atomic:
        mov     eax,[ebx].VtVdmContext.CsSegCs
        mov     word ptr ClientPmEntry+4, ax
        mov     eax,[ebx].VtVdmContext.CsEip
        mov     dword ptr ClientPmEntry, eax
        mov     eax,[ebx].VtVdmContext.CsSegSs
        mov     word ptr ClientPmStack+4, ax
        mov     eax,[ebx].VtVdmContext.CsEsp    ; es:edi -> stack
        mov     dword ptr ClientPmStack, eax

        mov     eax,esp                 ; save sp for pushad

        ; simulate pushad
        push    dword ptr [ebx].VtVdmContext.CsEax
        push    dword ptr [ebx].VtVdmContext.CsEcx
        push    dword ptr [ebx].VtVdmContext.CsEdx
        push    dword ptr [ebx].VtVdmContext.CsEbx
        push    eax
        push    dword ptr [ebx].VtVdmContext.CsEbp
        push    dword ptr [ebx].VtVdmContext.CsEsi
        push    dword ptr [ebx].VtVdmContext.CsEdi

        ; push seg regs
        push    dword ptr [ebx].VtVdmContext.CsSegFs
        push    dword ptr [ebx].VtVdmContext.CsSegGs
        push    dword ptr [ebx].VtVdmContext.CsSegDs
        push    dword ptr [ebx].VtVdmContext.CsSegEs

        push    dword ptr [ebx].VtVdmContext.CsEflags
        popfd

        ; set up VDM seg regs
        pop     es
        pop     ds
        pop     gs             ; pop fs,gs of invalid selectors are trapped in ntoskrnl,
        pop     fs             ; and handled by setting to zero

        ; set up VDM general regs
        popad

        lss     esp, cs:ClientPMStack
        jmp     fword ptr cs:ClientPMEntry

stdENDP _FastEnterPm

        page    ,132
        subttl "GetFastBopEntry"
;++
;
;   Routine Description:
;
;       This routine supplies the address of the routine that segmented
;       protected mode code should call to switch to flat mode.
;
;   Arguments:
;
;       esp + 4 = pointer to VdmTib->VdmContext
;
;   Returns:
;
;       nothing.
;
        assume DS:FLAT
cPublicProc _GetFastBopEntryAddress,1

        push    ebp
        mov     ebp,esp
        push    ebx
        push    eax
        mov     ebx,[ebp + 8]
        mov     [ebx].CsSegEs,cs
        mov     eax,offset FLAT:_FastLeavePm
        mov     word ptr [ebx].CsEbx,ax
        shr     eax,16
        mov     word ptr [ebx].CsEdx,ax
        pop     eax
        pop     ebx
        mov     esp,ebp
        pop     ebp
        stdRET  _GetFastBopEntryAddress

stdENDP _GetFastBopEntryAddress

        page    ,132
        subttl "FastLeavePm"
;++
;
;   Routine Description:
;
;       This routine switches from the VDM context to the monitor context.
;
;   Arguments:
;
;       none
;
;   Returns:
;
;       executing with monitor context
;
        assume DS:Nothing,ES:Nothing,SS:Nothing
ALIGN 16
cPublicProc _FastLeavePm,0
        push    ebx

        mov     bx,ds
        push    bx                              ; so push and pop size same
        mov     bx,KGDT_R3_DATA OR RPL_MASK
        mov     ds,bx
        assume  ds:FLAT

        push    fs
        mov     ebx, KGDT_R3_TEB OR RPL_MASK
        mov     fs, bx
        mov     ebx, fs:[PcTeb]
        mov     ebx, dword ptr [ebx].TeVdm
        pop     fs

        pushfd
        mov     dword ptr [ebx].VtVdmContext.CsEax,eax
        pop     eax
        mov     dword ptr [ebx].VtVdmContext.CsEFlags,eax
        pop     ax
        mov     word ptr [ebx].VtVdmContext.CsSegDs,ax
        pop     eax
        mov     dword ptr [ebx].VtVdmContext.CsEbx,eax
        mov     dword ptr [ebx].VtVdmContext.CsEcx,ecx
        mov     dword ptr [ebx].VtVdmContext.CsEdx,edx
        mov     dword ptr [ebx].VtVdmContext.CsEsi,esi
        mov     dword ptr [ebx].VtVdmContext.CsEdi,edi
        mov     dword ptr [ebx].VtVdmContext.CsEbp,ebp
        mov     word ptr [ebx].VtVdmContext.CsSegEs,es
        mov     word ptr [ebx].VtVdmContext.CsSegFs,fs
        mov     word ptr [ebx].VtVdmContext.CsSegGs,gs
        pop     eax
        mov     dword ptr [ebx].VtVdmContext.CsEip,eax
        pop     eax
        mov     word ptr [ebx].VtVdmContext.CsSegCs,ax
        mov     dword ptr [ebx].VtVdmContext.CsEsp,esp
        mov     word ptr [ebx].VtVdmContext.CsSegSs,ss

        ; switch Stacks
.errnz  (CsEsp + 4 - CsSegSS)
        lss     esp, [ebx].VtMonitorContext.CsEsp

        ; Now running on Monitor stack

        ; set up event info
        mov     word ptr [ebx].VtEventInfo.EiEvent,VdmBop
        mov     dword ptr [ebx].VtEventInfo.EiInstructionSize,BOP_SIZE
        mov     ax,[ebx].VtVdmContext.CsSegCs
        mov     es,ax
        ; BUGBUG 16 or 32 bit !!!!!
        mov     di,[ebx].VtVdmContext.CsEip
        mov     al,byte ptr es:[di]
        movzx   eax,al
        mov     [ebx].VtEventInfo.EiBopNumber,eax
        sub     di,2
        mov     word ptr [ebx].VtVdmContext.CsEip,di  ; set up bop bias

        ; set up for IRET
        push    dword ptr [ebx].VtMonitorContext.CsEFlags
        push    dword ptr [ebx].VtMonitorContext.CsSegCs
        push    dword ptr [ebx].VtMonitorContext.CsEip

        ; simulate pushad
        mov     eax,esp
        push    dword ptr [ebx].VtMonitorContext.CsEax
        push    dword ptr [ebx].VtMonitorContext.CsEcx
        push    dword ptr [ebx].VtMonitorContext.CsEdx
        push    dword ptr [ebx].VtMonitorContext.CsEbx
        push    eax
        push    dword ptr [ebx].VtMonitorContext.CsEbp
        push    dword ptr [ebx].VtMonitorContext.CsEsi
        push    dword ptr [ebx].VtMonitorContext.CsEdi

        ; push seg regs
        push    dword ptr [ebx].VtMonitorContext.CsSegFs
        push    dword ptr [ebx].VtMonitorContext.CsSegGs
        push    dword ptr [ebx].VtMonitorContext.CsSegDs
        push    dword ptr [ebx].VtMonitorContext.CsSegEs

        test    ds:FIXED_NTVDMSTATE_LINEAR,dword ptr VDM_VIRTUAL_INTERRUPTS
        jz      fl10

        or      [ebx].VtVdmContext.CsEFlags,dword ptr EFLAGS_INTERRUPT_MASK
        jmp     fl20

fl10:   and     dword ptr [ebx].VtVdmContext.CsEFlags, NOT EFLAGS_INTERRUPT_MASK
fl20:
        ; set up Monitor seg regs
        pop     es
        pop     ds
        pop     gs
        pop     fs

        ; set up Monitor general regs
        popad

        xor eax,eax                     ; indicate success

        ; clear the NT bit in EFLAGS and return with iret
        pushfd
        and     dword ptr [esp], 0ffffbfffH
        popfd
        iretd
stdENDP _FastLeavePm

_TEXT ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\monitor.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Monitor.c
Abstract:

    This module is the user mode portion of the x86 monitor

Author:

    Dave Hastings (daveh) 16 Mar 1991

Environment:

    User mode only

Revision History:
    Sudeep Bharati (sudeepb) 31-Dec-1991

    Converted all register manipulation interfaces to functions
    from macros. This is to make ntvdm an exe as well as a dll,
    and these register oriented routines are exported from ntvdm
    for WOW32 and other installable VDDs.

    Dave Hastings (daveh) 18-Apr-1992

    Split into multiple files. Track current monitor thread by
    Teb pointer.  Register initial thread.

    Sudeep Bharati (sudeepb) 22-Sep-1992

    Added Page Fault Handling For installable VDD support

--*/


#include "monitorp.h"
#include "dbgsvc.h"

//
// Internal functions
//

VOID
EventVdmIo(
    VOID
    );

VOID
EventVdmStringIo(
    VOID
    );

VOID
EventVdmMemAccess(
    VOID
    );

VOID
EventVdmIntAck(
    VOID
    );

VOID
EventVdmBop(
    VOID
    );

VOID
EventVdmError(
    VOID
    );

VOID
EventVdmIrq13(
    VOID
    );

VOID
EventVdmHandShakeAck(
    VOID
    );

VOID
CreateProfile(
    VOID
    );

VOID
StartProfile(
    VOID
    );

VOID
StopProfile(
    VOID
    );

VOID
AnalyzeProfile(
    VOID
    );

VOID
CheckScreenSwitchRequest(
    HANDLE handle
    );

// [LATER]  how do you prevent a struct from straddling a page boundary?

ULONG   IntelBase;          // base memory address
ULONG   VdmSize;            // Size of memory in VDM
ULONG   VdmDebugLevel;      // used to control debugging
PVOID  CurrentMonitorTeb;   // thread that is currently executing instructions.
ULONG InitialBreakpoint = FALSE; // if set, breakpoint at end of cpu_init
ULONG InitialVdmTibFlags = INITIAL_VDM_TIB_FLAGS; // VdmTib flags picked up from here
CONTEXT InitialContext;     // Initial context for all threads
BOOLEAN DebugContextActive = FALSE;
ULONG VdmFeatureBits = 0;   // bit to indicate special features
BOOLEAN MainThreadInMonitor = TRUE;

extern PVOID NTVDMpLockPrefixTable;
extern BOOL  HandshakeInProgress;
extern HANDLE hSuspend;
extern HANDLE hResume;
extern HANDLE hMainThreadSuspended;

extern PVOID __safe_se_handler_table[]; /* base of safe handler entry table */
extern BYTE  __safe_se_handler_count;   /* absolute symbol whose address is
                                           the count of table entries */

IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    sizeof(_load_config_used),                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    0,                          // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    (ULONG)&NTVDMpLockPrefixTable,     // LockPrefixTable, defined in FASTPM.ASM
    0, 0, 0, 0, 0, 0, 0,        // Reserved
    0,                             // & security_cookie
    (ULONG)__safe_se_handler_table,
    (ULONG)&__safe_se_handler_count
};

// Bop dispatch table

extern void (*BIOS[])();

//
// Event Dispatch table
//

VOID (*EventDispatch[VdmMaxEvent])(VOID) = {
        EventVdmIo,
        EventVdmStringIo,
        EventVdmMemAccess,
        EventVdmIntAck,
        EventVdmBop,
        EventVdmError,
        EventVdmIrq13,
        EventVdmHandShakeAck
        };

#if DBG
BOOLEAN fBreakInDebugger = FALSE;
#endif



EXPORT
VOID
cpu_init(
    )

/*++

Routine Description:

    This routine is used to prepare the IEU for instruction simulation.
    It will set the Intel registers to thier initial value, and perform
    any implementation specific initialization necessary.


Arguments:


Return Value:

    None.

--*/

{
    NTSTATUS Status;

    InitialVdmTibFlags |= RM_BIT_MASK;


    //
    // Find out if we are running with IOPL.  We call the kernel
    // rather than checking the registry ourselves, so that we can
    // insure that both the kernel and ntvdm.exe agree.  If they didn't,
    // it would result in unnecssary trapping instructions.  Whether or
    // not Vdms run with IOPL only changes on reboot
    //
    Status = NtVdmControl(VdmFeatures, &VdmFeatureBits);

#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint(
            "NTVDM: Could not find out whether to use IOPL, %lx\n",
            Status
            );
    }
#endif

    //
    // If we have fast v86 mode IF emulation set the bit that tells
    // the 16 bit IF macros they know.
    //
    if (VdmFeatureBits & V86_VIRTUAL_INT_EXTENSIONS) {
        InitialVdmTibFlags |= RI_BIT_MASK;
    }

    *pNtVDMState = InitialVdmTibFlags;

    // Switch the npx back to 80 bit mode.  Win32 apps start with
    // 64-bit precision for compatibility across platforms, but
    // DOS and Win16 apps expect 80 bit precision.
    //

    _asm fninit;

    //
    // We setup the InitialContext structure with the correct floating
    // point and debug register configuration, and cpu_createthread
    // uses this context to configure each 16-bit thread's floating
    // point and debug registers.
    //

    InitialContext.ContextFlags = CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS;

    Status = NtGetContextThread(
        NtCurrentThread(),
        &InitialContext
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NtVdm terminating : Could not get float/debug context for\n"
                 "                    initial thread, status %lx\n", Status);
        DbgBreakPoint();
#endif
        TerminateVDM();
    }


    //
    //
    // Turn OFF em bit so that dos apps will work correctly.
    //
    // On machines without 387's the floating point flag will have been
    // cleared.
    //

    InitialContext.ContextFlags = CONTEXT_FLOATING_POINT;
    InitialContext.FloatSave.Cr0NpxState &= ~0x6; // CR0_EM | CR0_MP

    //
    // Do the rest of thread initialization
    //
    cpu_createthread( NtCurrentThread(), NULL );

    InterruptInit();

    if (InitialBreakpoint) {
        DbgBreakPoint();
    }

}

EXPORT
VOID
cpu_terminate(
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    InterruptTerminate();
}

EXPORT
VOID
cpu_simulate(
    )

/*++

Routine Description:

    This routine causes the simulation of intel instructions to start.

Arguments:

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    PVDM_TIB VdmTib;
    ULONG oldIntState = VDM_VIRTUAL_INTERRUPTS;

    DBGTRACE(VDMTR_TYPE_MONITOR | MONITOR_CPU_SIMULATE, 0, 0);

    CurrentMonitorTeb = NtCurrentTeb();
    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    VdmTib->ContinueExecution = TRUE;


    VdmTib->VdmContext.ContextFlags = CONTEXT_FULL;

    while (VdmTib->ContinueExecution) {

        //ASSERT(CurrentMonitorTeb == NtCurrentTeb());
        ASSERT(InterlockedIncrement(&VdmTib->NumTasks) == 0);

        if (*pNtVDMState & VDM_INTERRUPT_PENDING) {
            DispatchInterrupts();
        }

        // translate MSW bits into EFLAGS
        if ( getMSW() & MSW_PE ) {
            if (!VDMForWOW && !getIF() && oldIntState == VDM_VIRTUAL_INTERRUPTS) {

                //
                // For PM apps, we need to set Cli time stamp if interrupts
                // are disabled and the time stamp was not set already.
                // This is because apps may use int31 to change interrupt
                // state instead of using cli.
                //

                VDM_PM_CLI_DATA cliData;

                cliData.Control = PM_CLI_CONTROL_SET;
                NtVdmControl(VdmPMCliControl, &cliData);
            }

            VdmTib->VdmContext.EFlags &= ~EFLAGS_V86_MASK;
            if (HandshakeInProgress) {
                CheckScreenSwitchRequest(hMainThreadSuspended);
            }
            MainThreadInMonitor = FALSE;

            Status = FastEnterPm();
        } else {
            VdmTib->VdmContext.EFlags |= EFLAGS_V86_MASK;
            if (HandshakeInProgress) {
                CheckScreenSwitchRequest(hMainThreadSuspended);
            }
            MainThreadInMonitor = FALSE;

            Status = NtVdmControl(VdmStartExecution,NULL);
        }

        MainThreadInMonitor = TRUE;
        if (HandshakeInProgress) {
            CheckScreenSwitchRequest(hMainThreadSuspended);
        }
        if (!NT_SUCCESS(Status)) {
#if DBG
            DbgPrint("NTVDM: Could not start execution\n");
#endif
            return;
        }

        //
        // Refresh VdmTib for the fact that wow32 thread never enters cpu_simulate
        // but returns here to handle BOP
        // Note, I think this needs only in FREE build.
        //

        CurrentMonitorTeb = NtCurrentTeb();
        VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
        if (!VDMForWOW) {
            oldIntState = getIF() ? VDM_VIRTUAL_INTERRUPTS : 0;
        }

        ASSERT(InterlockedDecrement(&VdmTib->NumTasks) < 0);

#if DBG
        if (fBreakInDebugger) {
            fBreakInDebugger = 0;
            DbgBreakPoint();
        }
#endif

        // Translate Eflags value
        ASSERT ((!((VdmTib->VdmContext.EFlags & EFLAGS_V86_MASK) &&
            (getMSW() & MSW_PE))));

        if ( VdmTib->VdmContext.EFlags & EFLAGS_V86_MASK ) {
            VdmTib->VdmContext.EFlags &= ~EFLAGS_V86_MASK;
        }

        // bugbug does cs:eip wrap cause some kind of fault?
        VdmTib->VdmContext.Eip += VdmTib->EventInfo.InstructionSize;

        if (VdmTib->EventInfo.Event >= VdmMaxEvent) {
#if DBG
            DbgPrint("NTVDM: Unknown event type\n");
            DbgBreakPoint();
#endif
            VdmTib->ContinueExecution = FALSE;
            continue;
        }
        (*EventDispatch[VdmTib->EventInfo.Event])();
    }


    // set this back to true incase we are nested
    VdmTib->ContinueExecution = TRUE;

    //
    // Restore the old Vdm tib info.  This is necessary for the for the
    // case where the application thread is suspended, and a host simulate is
    // performed from another thread
    //

    DBGTRACE(VDMTR_TYPE_MONITOR | MONITOR_CPU_UNSIMULATE, 0, 0);
}

VOID
host_unsimulate(
    )

/*++

Routine Description:

    This routine causes execution of instructions in a VDM to stop.

Arguments:


Return Value:

    None.

--*/

{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->ContinueExecution = FALSE;

}


VOID
EventVdmIo(
    VOID
    )
/*++

Routine Description:

    This function calls the appropriate io simulation routine.

Arguments:


Return Value:

    None.

--*/
{
    PVDM_TIB VdmTib;

    EnableScreenSwitch(TRUE, hMainThreadSuspended);   // only in FULLSCREEN
    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    if (VdmTib->EventInfo.IoInfo.Size == 1) {
        if (VdmTib->EventInfo.IoInfo.Read) {
            inb(VdmTib->EventInfo.IoInfo.PortNumber,(half_word *)&(VdmTib->VdmContext.Eax));
        } else {
            outb(VdmTib->EventInfo.IoInfo.PortNumber,getAL());
        }
    } else if (VdmTib->EventInfo.IoInfo.Size == 2) {
        if (VdmTib->EventInfo.IoInfo.Read) {
            inw(VdmTib->EventInfo.IoInfo.PortNumber,(word *)&(VdmTib->VdmContext.Eax));
        } else {
            outw(VdmTib->EventInfo.IoInfo.PortNumber,getAX());
        }
    }
#if DBG
    else {
    DbgPrint(
        "NtVdm: Unimplemented IO size %d\n",
        VdmTib->EventInfo.IoInfo.Size
        );
    DbgBreakPoint();
    }
#endif
    DisableScreenSwitch(hMainThreadSuspended);
}

VOID
EventVdmStringIo(
    VOID
    )
/*++

Routine Description:

    This function calls the appropriate io simulation routine.

Arguments:


Return Value:

    None.

--*/
{
   PVDMSTRINGIOINFO pvsio;
   PUSHORT pIndexRegister;
   USHORT Index;
   PVDM_TIB VdmTib;

   EnableScreenSwitch(TRUE, hMainThreadSuspended);
   VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

   // WARNING no 32 bit address support

    pvsio = &VdmTib->EventInfo.StringIoInfo;

    if (pvsio->Size == 1) {
        if (pvsio->Read) {
            insb((io_addr)pvsio->PortNumber,
                 (half_word *)Sim32GetVDMPointer(pvsio->Address, 1, ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Edi;
        } else {
            outsb((io_addr)pvsio->PortNumber,
                 (half_word *)Sim32GetVDMPointer(pvsio->Address,1,ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Esi;
        }
    } else if (pvsio->Size == 2) {
        if (pvsio->Read) {
            insw((io_addr)pvsio->PortNumber,
                 (word *)Sim32GetVDMPointer(pvsio->Address,1,ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Edi;
        } else {
            outsw((io_addr)pvsio->PortNumber,
                 (word *)Sim32GetVDMPointer(pvsio->Address,1,ISPESET),
                 (word)pvsio->Count
                 );
            pIndexRegister = (PUSHORT)&VdmTib->VdmContext.Esi;
        }
    } else {
#if DBG
         DbgPrint(
             "NtVdm: Unimplemented IO size %d\n",
             VdmTib->EventInfo.IoInfo.Size
             );
         DbgBreakPoint();
#endif
        DisableScreenSwitch(hMainThreadSuspended);
        return;
    }

    if (getDF()) {
        Index = *pIndexRegister - (USHORT)(pvsio->Count * pvsio->Size);
        }
    else {
        Index = *pIndexRegister + (USHORT)(pvsio->Count * pvsio->Size);
        }

    *pIndexRegister = Index;

    if (pvsio->Rep) {
        (USHORT)VdmTib->VdmContext.Ecx = 0;
        }

    DisableScreenSwitch(hMainThreadSuspended);
}

VOID
EventVdmIntAck(
    VOID
    )
/*++

Routine Description:

    This routine is called each time we have returned to monitor context
    to dispatch interrupts. Its function is to check for AutoEoi and call
    the ica to do a nonspecific eoi, when the ica adapter is in AEOI mode.

Arguments:


Return Value:

    None.

--*/
{
    int line;
    int adapter;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    if (VdmTib->EventInfo.IntAckInfo) {
        if (VdmTib->EventInfo.IntAckInfo & VDMINTACK_SLAVE)
            adapter = 1;
        else
            adapter = 0;
        line = -1;

        host_ica_lock();
        ica_eoi(adapter,
                &line,
                (int)(VdmTib->EventInfo.IntAckInfo & VDMINTACK_RAEOIMASK)
                );
        host_ica_unlock();
        }
}


VOID
EventVdmBop(
    VOID
    )
/*++

Routine Description:

    This routine dispatches to the appropriate bop handler

Arguments:


Return Value:

    None.

--*/
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    if (VdmTib->EventInfo.BopNumber > MAX_BOP) {
#if DBG
        DbgPrint(
            "NtVdm: Invalid BOP %lx\n",
            VdmTib->EventInfo.BopNumber
            );
#endif
         VdmTib->ContinueExecution = FALSE;
    } else {

       DBGTRACE(VDMTR_TYPE_MONITOR | MONITOR_EVENT_BOP,
                (USHORT)VdmTib->EventInfo.BopNumber,
                (ULONG)(*((UCHAR *)Sim32GetVDMPointer(
                                   (VdmTib->VdmContext.SegCs << 16) | VdmTib->VdmContext.Eip,
                                   1,
                                   ISPESET)))
                );

       (*BIOS[VdmTib->EventInfo.BopNumber])();
       CurrentMonitorTeb = NtCurrentTeb();
   }
}

VOID
EventVdmError(
    VOID
    )
/*++

Routine Description:

    This routine prints a message(debug only), and exits the vdm

Arguments:


Return Value:

    None.

--*/
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
#if DBG
    DbgPrint(
        "NtVdm: Error code %lx\n",
        VdmTib->EventInfo.ErrorStatus
        );
    DbgBreakPoint();
#endif
    TerminateVDM();
    VdmTib->ContinueExecution = FALSE;
}

VOID
EventVdmIrq13(
    VOID
    )
/*++

Routine Description:

    This routine simulates an IRQ 13 to the vdm

Arguments:


Return Value:

    None.

--*/
{
    if (!IRQ13BeingHandled) {
        IRQ13BeingHandled = TRUE;
        ica_hw_interrupt(
            ICA_SLAVE,
            5,
            1
            );
    }
}

VOID
EventVdmHandShakeAck(
    VOID
    )
/*++

Routine Description:

    This routine does nothing.

Arguments:


Return Value:

    None.

--*/
{
}

VOID
EventVdmMemAccess(
    VOID
    )
/*++

Routine Description:

    This routine will call the page fault handler routine which
    is common to both x86 and mips.

Arguments:


Return Value:

    None.

--*/
{

    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    // RWMode is 0 if read fault or 1 if write fault.

    DispatchPageFault(
        VdmTib->EventInfo.FaultInfo.FaultAddr,
        VdmTib->EventInfo.FaultInfo.RWMode
        );
    CurrentMonitorTeb = NtCurrentTeb();
}


// Get and Set routines for intel registers.

ULONG  getEAX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Eax);
}
USHORT getAX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Eax));
}
UCHAR  getAL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Eax));
}
UCHAR  getAH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Eax >> 8));
}
ULONG  getEBX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Ebx);
}
USHORT getBX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Ebx));
}
UCHAR  getBL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ebx));
}
UCHAR  getBH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ebx >> 8));
}
ULONG  getECX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Ecx);
}
USHORT getCX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Ecx));
}
UCHAR  getCL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ecx));
}
UCHAR  getCH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Ecx >> 8));
}
ULONG  getEDX (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Edx);
}
USHORT getDX  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)(VdmTib->VdmContext.Edx));
}
UCHAR  getDL  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Edx));
}
UCHAR  getDH  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((BYTE)(VdmTib->VdmContext.Edx >> 8));
}
ULONG  getESP (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Esp);
}
USHORT getSP  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Esp);
}
ULONG  getEBP (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Ebp);
}
USHORT getBP  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Ebp);
}
ULONG  getESI (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Esi);
}
USHORT getSI  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Esi);
}
ULONG  getEDI (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Edi);
}
USHORT getDI  (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Edi);
}
ULONG  getEIP (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  (VdmTib->VdmContext.Eip);
}
USHORT getIP (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.Eip);
}
USHORT getCS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegCs);
}
USHORT getSS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegSs);
}
USHORT getDS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegDs);
}
USHORT getES (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegEs);
}
USHORT getFS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegFs);
}
USHORT getGS (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->VdmContext.SegGs);
}
ULONG  getCF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_CARRY) ? 1 : 0);
}
ULONG  getPF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_PARITY) ? 1 : 0);
}
ULONG  getAF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_AUXILIARY) ? 1 : 0);
}
ULONG  getZF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_ZERO) ? 1 : 0);
}
ULONG  getSF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_SIGN) ? 1 : 0);
}
ULONG  getTF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_TRAP) ? 1 : 0);
}
ULONG  getIF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_INTERRUPT) ? 1 : 0);
}
ULONG  getDF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_DIRECTION) ? 1 : 0);
}
ULONG  getOF (VOID)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((VdmTib->VdmContext.EFlags & FLG_OVERFLOW) ? 1 : 0);
}
USHORT getMSW (VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return  ((USHORT)VdmTib->IntelMSW);
}
USHORT getSTATUS(VOID){
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return (USHORT)VdmTib->VdmContext.EFlags;
}
ULONG  getEFLAGS(VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return VdmTib->VdmContext.EFlags;
}
USHORT getFLAGS(VOID) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return (USHORT)VdmTib->VdmContext.EFlags;
}

VOID setEAX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = val;
}

VOID setAX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = (VdmTib->VdmContext.Eax & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setAH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = (VdmTib->VdmContext.Eax & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setAL  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eax = (VdmTib->VdmContext.Eax & 0xFFFFFF00) |
                            ((ULONG)val & 0x000000FF);
}

VOID setEBX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = val ;
}

VOID setBX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = (VdmTib->VdmContext.Ebx & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setBH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = (VdmTib->VdmContext.Ebx & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setBL  (UCHAR  val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebx = (VdmTib->VdmContext.Ebx & 0xFFFFFF00) |
                            ((ULONG)val & 0x000000FF);
}

VOID setECX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = val ;
}

VOID setCX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = (VdmTib->VdmContext.Ecx & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setCH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = (VdmTib->VdmContext.Ecx & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setCL  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ecx = (VdmTib->VdmContext.Ecx & 0xFFFFFF00) |
                            ((ULONG)val & 0x000000FF);
}

VOID setEDX (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = val ;
}

VOID setDX  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = (VdmTib->VdmContext.Edx & 0xFFFF0000) |
                            ((ULONG)val & 0x0000FFFF);
}

VOID setDH  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = (VdmTib->VdmContext.Edx & 0xFFFF00FF) |
                            ((ULONG)(val << 8) & 0x0000FF00);
}

VOID setDL  (UCHAR val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edx = (VdmTib->VdmContext.Edx & 0xFFFFFF00) |
                                ((ULONG)val & 0x000000FF);
}

VOID setESP (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esp = val ;
}

VOID setSP  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esp = (VdmTib->VdmContext.Esp & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setEBP (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebp = val;
}

VOID setBP  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Ebp = (VdmTib->VdmContext.Ebp & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setESI (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esi = val ;
}

VOID setSI  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Esi = (VdmTib->VdmContext.Esi & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}
VOID setEDI (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edi = val ;
}

VOID setDI  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Edi = (VdmTib->VdmContext.Edi & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setEIP (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eip = val ;
}

VOID setIP  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.Eip = (VdmTib->VdmContext.Eip & 0xFFFF0000) |
                                ((ULONG)val & 0x0000FFFF);
}

VOID setCS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegCs = (ULONG) val & 0x0000FFFF ;
}

VOID setSS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegSs = (ULONG) val & 0x0000FFFF ;
}

VOID setDS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegDs = (ULONG) val & 0x0000FFFF ;
}

VOID setES  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegEs = (ULONG) val & 0x0000FFFF ;
}

VOID setFS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegFs = (ULONG) val & 0x0000FFFF ;
}

VOID setGS  (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.SegGs = (ULONG) val & 0x0000FFFF ;
}

VOID setCF  (ULONG val)  {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_CARRY) |
                                (((ULONG)val << FLG_CARRY_BIT) & FLG_CARRY);
}

VOID setPF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_PARITY) |
                                (((ULONG)val << FLG_PARITY_BIT) & FLG_PARITY);
}

VOID setAF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_AUXILIARY) |
                                (((ULONG)val << FLG_AUXILIARY_BIT) & FLG_AUXILIARY);
}

VOID setZF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_ZERO) |
                                (((ULONG)val << FLG_ZERO_BIT) & FLG_ZERO);
}

VOID setSF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_SIGN) |
                                (((ULONG)val << FLG_SIGN_BIT) & FLG_SIGN);
}

VOID setIF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_INTERRUPT) |
                                (((ULONG)val << FLG_INTERRUPT_BIT) & FLG_INTERRUPT);
}

VOID setDF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_DIRECTION) |
                                (((ULONG)val << FLG_DIRECTION_BIT) & FLG_DIRECTION);
}

VOID setOF  (ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & ~FLG_OVERFLOW) |
                                (((ULONG)val << FLG_OVERFLOW_BIT) & FLG_OVERFLOW);
}

VOID setMSW (USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->IntelMSW = val ;
}

VOID setSTATUS(USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & 0xFFFF0000) | val;
}

VOID setEFLAGS(ULONG val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = val;
}

VOID setFLAGS(USHORT val) {
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & 0xFFFF0000) | val;
}
//
// The following is a private register function
//

ULONG getPE(){
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return((VdmTib->IntelMSW & MSW_PE) ? 1 : 0);
}


PX86CONTEXT
getIntelRegistersPointer(
    VOID
    )
/*++

Routine Description:

    Return Address on Intel Registers for WOW Fast Access

Arguments:

    None

Return Value:

    Pointer to Intel Registers x86 Context Record


--*/
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    return &(VdmTib->VdmContext);
}



BOOLEAN MonitorInitializePrinterInfo(
     WORD   Ports,
     PWORD  PortTable,
     PUCHAR State,
     PUCHAR Control,
     PUCHAR Status,
     PUCHAR HostState)
{
    UCHAR   adapter;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    ASSERT (Ports == 3);
    ASSERT (Status != NULL);

    // only do this if the structure has not been initialized -- meaning
    // the pointers can be set once.
    if (NULL == VdmTib->PrinterInfo.prt_Status) {

        VdmTib->PrinterInfo.prt_PortAddr[0] = PortTable[0];
        VdmTib->PrinterInfo.prt_PortAddr[1] = PortTable[1];
        VdmTib->PrinterInfo.prt_PortAddr[2] = PortTable[2];

        VdmTib->PrinterInfo.prt_Handle[0] =
        VdmTib->PrinterInfo.prt_Handle[1] =
        VdmTib->PrinterInfo.prt_Handle[2] = NULL;

        // default mode is kernel simulating status port read
        // mode will be changed if
        // (1). A vdd is hooking printer ports.
        // (2). Dongle mode is detected
        VdmTib->PrinterInfo.prt_Mode[0] =
        VdmTib->PrinterInfo.prt_Mode[1] =
        VdmTib->PrinterInfo.prt_Mode[2] = PRT_MODE_SIMULATE_STATUS_PORT;

        // primarily for dongle
        VdmTib->PrinterInfo.prt_BytesInBuffer[0] =
        VdmTib->PrinterInfo.prt_BytesInBuffer[1] =
        VdmTib->PrinterInfo.prt_BytesInBuffer[2] = 0;

        // primarily for simulating printer status read in kernel
        VdmTib->PrinterInfo.prt_State = State;
        VdmTib->PrinterInfo.prt_Control = Control;
        VdmTib->PrinterInfo.prt_Status = Status;
        VdmTib->PrinterInfo.prt_HostState = HostState;

        //
        // Give the kernel printer emulation an opportunity to cache the
        // pointers
        //
        if (!NT_SUCCESS(NtVdmControl(VdmPrinterInitialize,NULL))) {
           return FALSE;
        }

        return TRUE;
    } else {
            return FALSE;
    }
}

BOOLEAN MonitorEnablePrinterDirectAccess(WORD adapter, HANDLE handle, BOOLEAN Enable)
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    ASSERT(VDM_NUMBER_OF_LPT > adapter);
    if (Enable) {
        // if the adapter has been allocated by a third party VDD,
        // can't do direct io.
        if (PRT_MODE_VDD_CONNECTED != VdmTib->PrinterInfo.prt_Mode[adapter]) {
            VdmTib->PrinterInfo.prt_Mode[adapter] = PRT_MODE_DIRECT_IO;
            VdmTib->PrinterInfo.prt_Handle[adapter] = handle;
            // NtVdmControl(VdmPrinterDirectIoOpen, &adapter);
            return TRUE;
        }
        else
            return FALSE;
    }
    else {
        // disabling direct i/o. reset it back to status port simulation
        if (VdmTib->PrinterInfo.prt_Handle[adapter] == handle) {
            NtVdmControl(VdmPrinterDirectIoClose, &adapter);
            VdmTib->PrinterInfo.prt_Mode[adapter] = PRT_MODE_SIMULATE_STATUS_PORT;
            VdmTib->PrinterInfo.prt_Handle[adapter] = NULL;
            VdmTib->PrinterInfo.prt_BytesInBuffer[adapter] = 0;
            return TRUE;
        }
        else
            return FALSE;
    }
}

BOOLEAN MonitorVddConnectPrinter(WORD Adapter, HANDLE hVdd, BOOLEAN Connect)
{
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;
    if (VDM_NUMBER_OF_LPT <= Adapter)
        return FALSE;
    if (Connect) {
        VdmTib->PrinterInfo.prt_Mode[Adapter] = PRT_MODE_VDD_CONNECTED;
        VdmTib->PrinterInfo.prt_Handle[Adapter] = hVdd;
        return TRUE;
    }
    else {
        if (hVdd == VdmTib->PrinterInfo.prt_Handle[Adapter]) {
            VdmTib->PrinterInfo.prt_Mode[Adapter] = PRT_MODE_SIMULATE_STATUS_PORT;
            VdmTib->PrinterInfo.prt_Handle[Adapter] = NULL;
            return TRUE;
        }
        else return FALSE;
    }
}

BOOLEAN MonitorPrinterWriteData(WORD Adapter, BYTE Value)
{
    USHORT BytesInBuffer;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)NtCurrentTeb()->Vdm;

    ASSERT(VDM_NUMBER_OF_LPT > Adapter);
    BytesInBuffer = VdmTib->PrinterInfo.prt_BytesInBuffer[Adapter];
    VdmTib->PrinterInfo.prt_Buffer[Adapter][BytesInBuffer] = Value;
    VdmTib->PrinterInfo.prt_BytesInBuffer[Adapter]++;

    return TRUE;
}

/*  CheckScreenSwitchRequest -
 *
 *  This function checks if timer thread has asked us to stop such that it
 *  can handle the fullscreen and windowed switch.
 *  If yes, we will signal that we are stopped and wait for resume event.
 *
 */
VOID CheckScreenSwitchRequest(HANDLE handle)
{
    DWORD status;

    //
    // Check if Suspen is requested.  If yes, we will signal that we are going to
    // the wait state and wait for the resume event
    // Since 'handle' event is a manual event, it is important that
    // we check-and-wait in a loop such that timer thread will not pick up the
    // 'handle' event between the wait-for-resume and the ResetEvent(handle).
    //
    while (TRUE) {
        status = WaitForSingleObject(hSuspend, 0);
        if (status == 0) {
            SetEvent(handle);
            WaitForSingleObject(hResume, INFINITE);
            ResetEvent(handle);
        } else {

            //
            // Make sure event is reset before leaving this function
            //
            ResetEvent(handle);
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\int.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    int.c

Abstract:

    This file contains interrupt support routines for the monitor

Author:

    Dave Hastings (daveh) 18-Apr-1992

Notes:

    The code in this file split out from monitor.c (18-Apr-1992)

Revision History:

--*/

#include <monitorp.h>

#if defined(NEC_98)
VOID WaitVsync();
#endif // NEC_98

BOOL
DpmiHwIntHandler(
    ULONG IntNumber
    );

VOID
IRQ13_Eoi(
    int IrqLine,
    int CallCount
    );

#if defined(NEC_98)
VOID
IRQ13_Eoi_real(
    int IrqLine,
    int CallCount
    );
#endif // NEC_98

BOOLEAN IRQ13BeingHandled;  // true until IRQ13 eoi'ed


VOID
InterruptInit(
    VOID
)
/*++

Routine Description:

    This routine initializes the interrupt code for the monitor.

Arguments:


Return Value:

    None.

--*/
{
    BOOL Bool;



#if defined(NEC_98)
    Bool = RegisterEOIHook( 8, IRQ13_Eoi);
    Bool = RegisterEOIHook( 14, IRQ13_Eoi_real);
#else  // !NEC_98
    Bool = RegisterEOIHook( 13, IRQ13_Eoi);
#endif // !NEC_98
    if (!Bool) {
#if DBG
        DbgPrint("NtVdm : Could not register IRQ 13 Eoi handler\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }
}

VOID
InterruptTerminate(
    VOID
    )
/*++

Routine Description:

    This routine frees the resoures allocated by InterruptInit

Arguments:


Return Value:

    None.

--*/
{
}


VOID
cpu_interrupt(
    IN int Type,
    IN int Number
    )
/*++

Routine Description:

    This routine causes an interrupt of the specified type to be raised
    at the appropriate time.

Arguments:

    Type -- indicates the type of the interrupt.  One of HARDWARE, TIMER, YODA,
            or RESET

            YODA and RESET are ignored

Return Value:

    None.

Notes:

--*/
{
    NTSTATUS Status;
    HANDLE   MonitorThread;

    host_ica_lock();

    if (CurrentMonitorTeb == NtCurrentTeb() && !getIF() && (getMSW() & MSW_PE)) {
        VDM_PM_CLI_DATA cliData;

        cliData.Control = PM_CLI_CONTROL_CHECK;
        NtVdmControl(VdmPMCliControl, &cliData);
    }

    if (Type == CPU_TIMER_TICK) {

            //
            // Set the VDM State for timer tick int pending
            //
        _asm {
            mov     eax, FIXED_NTVDMSTATE_LINEAR
            lock or dword ptr [eax], VDM_INT_TIMER
        }
    } else if (Type == CPU_HW_INT) {


        if (*pNtVDMState & VDM_INT_HARDWARE) {
            goto EarlyExit;
            }

            //
            // Set the VDM State for Hardware Int pending
            //
        _asm {
            mov     eax, FIXED_NTVDMSTATE_LINEAR
            lock or dword ptr [eax], VDM_INT_HARDWARE
        }
    } else {
#if DBG
        DbgPrint("Monitor: Invalid Interrupt Type=%ld\n",Type);
#endif
        goto EarlyExit;
    }

    if (CurrentMonitorTeb != NtCurrentTeb()) {

        /*
         *  Look up the ThreadHandle and Queue and InterruptApc
         *  If no ThreadHandle found do nothing
         *
         *  The CurrentMonitorTeb may not be in the ThreadHandle\Teb list
         *  because upon task termination the the CurrentMonitorTeb variable
         *  cannot be updated until a new task is activated by the
         *  non-preemptive scheduler.
         */
        MonitorThread = ThreadLookUp(CurrentMonitorTeb);
        if (MonitorThread) {
            Status = NtVdmControl(VdmQueueInterrupt, (PVOID)MonitorThread);
            // nothing much we can do if this fails
#if DBG
            if (!NT_SUCCESS(Status) && Status != STATUS_UNSUCCESSFUL) {
                DbgPrint("NtVdmControl.VdmQueueInterrupt Status=%lx\n",Status);
            }
#endif
        }

    }

EarlyExit:

    host_ica_unlock();
}




VOID
DispatchInterrupts(
    )
/*++

Routine Description:

    This routine dispatches interrupts to their appropriate handler routine
    in priority order. The order is YODA, RESET, TIMER, HARDWARE. however
    the YODA and RESET interrupts do nothing. Hardware interrupts are not
    simulated unless the virtual interrupt enable flag is set.  Flags
    indicating which interrupts are pending appear in the pNtVDMState.


Arguments:

    None.

Return Value:

    None.

Notes:

--*/
{

    host_ica_lock();

       // If any delayed interrupts have expired
       // call the ica to restart interrupts
    if (UndelayIrqLine) {
        ica_RestartInterrupts(UndelayIrqLine);
        }


    if (*pNtVDMState & VDM_INT_TIMER) {
        *pNtVDMState &= ~VDM_INT_TIMER;
        host_ica_unlock();      // maybe don't need to unlock ? Jonle
        host_timer_event();
        host_ica_lock();
    }

    if ( getIF() && getMSW() & MSW_PE && *pNtVDMState & VDM_INT_HARDWARE) {
        //
        // Mark the vdm state as hw int dispatched. Must use the lock as
        // kernel mode DelayedIntApcRoutine changes the bit as well
        //
        _asm {
            mov  eax,FIXED_NTVDMSTATE_LINEAR
            lock and dword ptr [eax], NOT VDM_INT_HARDWARE
            }
        DispatchHwInterrupt();
    }

    host_ica_unlock();
}




VOID
DispatchHwInterrupt(
    )
/*++

Routine Description:

    This routine dispatches hardware interrupts to the vdm in Protect Mode.
    It calls the ICA to get the vector number and sets up the VDM stack
    appropriately. Real Mode interrupt dispatching has been moved to the
    kernel.

Arguments:

    None.

Return Value:

    None.

--*/
{
    int InterruptNumber;
    ULONG IretHookAddress = 0L;
    PVDM_TIB VdmTib;

    InterruptNumber = ica_intack(&IretHookAddress);
    if (InterruptNumber == -1) { // skip spurious ints
        return;
        }

    DpmiHwIntHandler(InterruptNumber);

    VdmTib = (PVDM_TIB)(NtCurrentTeb()->Vdm);
    if (IretHookAddress) {
        BOOL Frame32 = (BOOL) VdmTib->DpmiInfo.Flags;
        BOOL Stack32;
        USHORT SegSs, VdmCs;
        ULONG VdmSp, VdmEip;
        PUCHAR VdmStackPointer;
        ULONG StackOffset;

        SegSs = getSS();
        VdmStackPointer = Sim32GetVDMPointer(((ULONG)SegSs) << 16, 1, TRUE);

        //
        // Figure out how many bits of sp to use
        //

        if (Ldt[(SegSs & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
            VdmSp = getESP();
            StackOffset = 12;
        } else {
            VdmSp = getSP();
            StackOffset = 6;
        }

        (PCHAR)VdmStackPointer += VdmSp;

        //
        // BUGBUG need to add stack limit checking 15-Nov-1993 Jonle
        //
        setESP(VdmSp - StackOffset);

        //
        // Push info for Iret hook handler
        //
        VdmCs = (USHORT) ((IretHookAddress & 0xFFFF0000) >> 16);
        VdmEip = (IretHookAddress & 0xFFFF);

        if (Frame32) {
            *(PULONG)(VdmStackPointer - 4) = VdmTib->VdmContext.EFlags;
            *(PULONG)(VdmStackPointer - 8) = (ULONG) VdmCs;
            *(PULONG)(VdmStackPointer - 12) = VdmEip;
        } else {
            *(PUSHORT)(VdmStackPointer - 2) = (USHORT) VdmTib->VdmContext.EFlags;
            *(PUSHORT)(VdmStackPointer - 4) = VdmCs;
            *(PUSHORT)(VdmStackPointer - 6) = (USHORT) VdmEip;
        }
    }

#if defined(NEC_98)
        if(InterruptNumber == 0xA) {
                WaitVsync();
        }
#endif // NEC_98
}


VOID
IRQ13_Eoi(
    int IrqLine,
    int CallCount
    )
{
    UNREFERENCED_PARAMETER(IrqLine);
    UNREFERENCED_PARAMETER(CallCount);

       //
       //  if CallCount is less than Zero, then the interrupt request
       //  is being canceled.
       //
#if defined(NEC_98)
  if( getMSW() & MSW_PE ){
#endif // NEC_98
    if (CallCount < 0) {
        return;
        }

    IRQ13BeingHandled = FALSE;

#if defined(NEC_98)
  }
#endif // NEC_98
}

#if defined(NEC_98)
VOID
IRQ13_Eoi_real(
    int IrqLine,
    int CallCount
    )
{
    UNREFERENCED_PARAMETER(IrqLine);
    UNREFERENCED_PARAMETER(CallCount);

    if( !(getMSW() & MSW_PE) ){
        if (CallCount < 0) {
            return;
        }
        IRQ13BeingHandled = FALSE;
    }
}
#endif // NEC_98





VOID
MonitorEndIretHook(
    VOID
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{

    PVOID VdmStackPointer;
    PVDM_TIB VdmTib;

    VdmTib = (PVDM_TIB)(NtCurrentTeb()->Vdm);
    if (VdmTib->IntelMSW & MSW_PE) {
        BOOL Frame32 = (BOOL) VdmTib->DpmiInfo.Flags;
        ULONG FrameSize;

        if (Frame32) {
            FrameSize = 12;
        } else {
            FrameSize = 6;
        }

        VdmStackPointer = Sim32GetVDMPointer(((ULONG)getSS() << 16),2,TRUE);

        if (Ldt[(getSS() & ~0x7)/sizeof(LDT_ENTRY)].HighWord.Bits.Default_Big) {
            (PCHAR)VdmStackPointer += getESP();
            setESP(getESP() + FrameSize);
        } else {
            (PCHAR)VdmStackPointer += getSP();
            setSP((USHORT) (getSP() + FrameSize));
        }

        if (Frame32) {

            VdmTib->VdmContext.EFlags = *(PULONG)((PCHAR)VdmStackPointer + 8);
            setCS(*(PUSHORT)((PCHAR)VdmStackPointer + 4));
            VdmTib->VdmContext.Eip = *((PULONG)VdmStackPointer);

        } else {

            VdmTib->VdmContext.EFlags = (VdmTib->VdmContext.EFlags & 0xFFFF0000) |
                                        ((ULONG) *(PUSHORT)((PCHAR)VdmStackPointer + 4));
            setCS(*(PUSHORT)((PCHAR)VdmStackPointer + 2));
            VdmTib->VdmContext.Eip = (VdmTib->VdmContext.Eip & 0xFFFF0000) |
                                        ((ULONG) *(PUSHORT)((PCHAR)VdmStackPointer));

        }

    } else {

        VdmStackPointer = Sim32GetVDMPointer(((ULONG)getSS() << 16) | getSP(),2,FALSE);

        setSP((USHORT) (getSP() + 6));

        (USHORT)(VdmTib->VdmContext.EFlags) = *((PUSHORT)((PCHAR)VdmStackPointer + 4));
        setCS(*((PUSHORT)((PCHAR)VdmStackPointer + 2)));
        setIP(*((PUSHORT)VdmStackPointer));

    }


}

VOID
host_clear_hw_int()
/*++

Routine Description:

    This routine "forgets" a previously requested hardware interrupt.

Arguments:

    None.

Return Value:

    None.

--*/
{
   /*
    *  We do nothing here to save a kernel call, because the
    *  interrupt if it hasn't been intacked yet or dispatched,
    *  will produce a harmless spurious int, which is dropped
    *  in the i386 interrupt dispatching code anyhow.
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\sources.inc ===
i386_SOURCES=i386\monitor.c  \
             i386\fastpm.asm \
             i386\sas.c      \
             i386\spcstubs.c \
             i386\thread.c   \
             i386\vdpm.c     \
             i386\int.c

INCLUDES=$(INCLUDES); \
         $(WINDOWS_INC_PATH);
!IF 0
Note: to build with profiling support, add the following to the i386_sources

             i386\proflib.c \
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\sas.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Monitor.c
Abstract:

    This module is the user mode portion of the x86 monitor

Author:

    Dave Hastings (daveh) 16 Mar 1991

Environment:

    User mode only

Revision History:
    William Hsieh   10-10-1992 Added A20 wrapping support
--*/

#define VDD_INTEG 1
#include "monitorp.h"
#include <windows.h>
#include <stdio.h>
#include <malloc.h>

// Tim Nov 92.
void sas_connect_memory(
    IN sys_addr Low,
    IN sys_addr High,
    IN int Type
    );

//BUGBUGBUGBUG Include file

// from base\inc\sas.h
/* memory types for sas */
#define SAS_RAM 0
#define SAS_VIDEO 1
#define SAS_ROM 2
#define SAS_WRAP 3
#define SAS_INACCESSIBLE 4
#define SAS_MAX_TYPE    SAS_INACCESSIBLE

#define SIXTYFOURK 0x10000L
#define ONEMEGA 0x100000L

void rom_init();
void rom_checksum();
void copyROM();

USHORT get_lim_backfill_segment(void);
BOOL   HoldEMMBackFillMemory(ULONG Address, ULONG Size);

#if DBG
extern unsigned short get_emm_page_size(void);
extern unsigned short get_intel_page_size(void);
#endif

/* SYNC THESE DEFINITIONS WITH BASE\EMM.H, or sas_init will assert */
#define EMM_PAGE_SIZE           0x4000
#define INTEL_PAGE_SIZE         0x1000

typedef struct
{
    ULONG (*b_read) ();
    ULONG (*w_read) ();
    VOID (*str_read) ();
} READ_POINTERS;

// Internal Data
PMEMTYPE MemType = NULL;

// External Data
extern READ_POINTERS read_pointers;

// M variables used by video.lib

host_addr Start_of_M_area;       /* host addr (char *) of start of M */
sys_addr Length_of_M_area;       /* sys addr (long) offset of end of M */

static  HANDLE A20SectionHandle = NULL;
static BOOL A20IsON = FALSE;
static  USHORT  BackFillSegment;



EXPORT
VOID
sas_init(
    IN sys_addr Size
    )

/*++

Routine Description:

    This routine initializes the SAS module, and allocates the linear
    address space for the VDM, and loads the ROM

Arguments:

    Size - Supplies the size of the VDMs linear address space.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG ViewSize;
    PVOID BaseAddress;
    OBJECT_ATTRIBUTES   A20ObjAttr;
    LARGE_INTEGER       SectionSize;
    USHORT Pages;
    ULONG BackFillBase;


    InitializeObjectAttributes(
        &A20ObjAttr,
        NULL,
        0,
        NULL,
        NULL
        );

    SectionSize.HighPart = 0L;
    SectionSize.LowPart = 640 * 1024 + 64 * 1024;

    Status = NtCreateSection(
        &A20SectionHandle,
        SECTION_MAP_WRITE|SECTION_MAP_EXECUTE,
        &A20ObjAttr,
        &SectionSize,
        PAGE_EXECUTE_READWRITE,
        SEC_RESERVE,
        NULL
        );

    if (!NT_SUCCESS(Status)) {
        // bugbug -williamh
        // we should pop up an approiate message before we
        // terminate the vdm.
#if DBG
            DbgPrint("sas_init: can not create himem section, status = %lx\n",
                     Status);
#endif
        TerminateVDM();
    }
    VdmSize = Size;

    //
    // N.B.  We expect that process creation has reserved the first 16 MB
    //       for us already.  If not, then this won't work worth a darn

    // free the first 640KB virtual address.
    // This is done because it has been resevered before sas_init get called
    BaseAddress = (PVOID)1;
    ViewSize = 640 * 1024 - 1;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &ViewSize,
        MEM_RELEASE
        );


    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("sas_init: cannot free 1st 640k virtual address, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }

    BaseAddress =(PVOID) ONEMEGA;
    ViewSize = SIXTYFOURK;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &ViewSize,
        MEM_RELEASE
        );


    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("sas_init: can not free himem virtual address, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }

    BaseAddress = (PVOID)VDM_BASE_ADDRESS;
    ViewSize = SIXTYFOURK - (ULONG)VDM_BASE_ADDRESS;
    SectionSize.HighPart = SectionSize.LowPart = 0;

    Status = NtMapViewOfSection(
        A20SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &SectionSize,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_EXECUTE_READWRITE
        );

    if (!NT_SUCCESS(Status)){
#if DBG
        DbgPrint("sas_init: can not map view of 1st 64K, status = %ls\n",
                 Status);
#endif
        TerminateVDM();
    }
    BaseAddress = (PVOID) ONEMEGA;
    ViewSize = SIXTYFOURK;
    Status = NtMapViewOfSection(A20SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &SectionSize,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_EXECUTE_READWRITE
        );

    if (!NT_SUCCESS(Status)){
#if DBG
        DbgPrint("sas_init: can not map view of himem space, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }

    // get emm back fill segment address from softpc
    // we cut the backfill memory area into pieces in EMM_PAGE_SIZE unit.
    // this is done so that EMM manager can grab the address space
    // as EMM page frame.
    // note that if EMM is disabled, the backfill segment will be
    // (640 * 1024 / 16).

    BackFillSegment = get_lim_backfill_segment();

    ASSERT(BackFillSegment <= 640 * 1024 / 16);

    //
    // Map the rest of conventional memory
    // only map up to the emm backfill segment.
    BaseAddress = (PVOID) (64 * 1024);
    ViewSize = BackFillSegment * 16 - 64 * 1024;
    SectionSize.LowPart = 64 * 1024;
    SectionSize.HighPart = 0;
    Status = NtMapViewOfSection(A20SectionHandle,
        NtCurrentProcess(),
        &BaseAddress,
        0,
        ViewSize,
        &SectionSize,
        &ViewSize,
        ViewUnmap,
        MEM_DOS_LIM,
        PAGE_EXECUTE_READWRITE
        );
    if (!NT_SUCCESS(Status)){
#if DBG
        DbgPrint("sas_init: can not map view of himem space, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }

// if there are any backfill memory, map it to our section initially
    if (BackFillSegment < 640 * 1024 / 16) {

    /* make sure our constants are in sync with emm.h */
#if DBG
        ASSERT(EMM_PAGE_SIZE == get_emm_page_size());
        ASSERT(INTEL_PAGE_SIZE == get_intel_page_size());
#endif
        if (!HoldEMMBackFillMemory(BackFillSegment * 16,
                                   (640 * 1024) - BackFillSegment * 16)
                                  ) {

#if DBG
            DbgPrint("sas_init: can not map backfill space, status = %lx\n",
                     Status);
#endif
            TerminateVDM();
        }
    }

    //
    // Allocate ROM area
    //
    BaseAddress = (PVOID)(640 * 1024);
    ViewSize = 384 * 1024;
    Status = NtAllocateVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        0L,
        &ViewSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );
    if (!NT_SUCCESS(Status)){
#if DBG
        DbgPrint("sas_init: can not map view of himem space, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }

    A20IsON = FALSE;

    Start_of_M_area = 0;
    Length_of_M_area = VdmSize;
    sas_connect_memory(0, VdmSize + 2*SIXTYFOURK -1, SAS_RAM);
}

#if VDD_INTEG

EXPORT
VOID
sas_term(
    VOID
    )
/*++

Routine Description:

    Free memory prior to reallocing it

Arguments:

    None.

Return Value:

    None.
--*/
{
    PVOID BaseAddress;
    NTSTATUS Status;
    ULONG Size;

    BaseAddress = (PVOID)VDM_BASE_ADDRESS;
    Size = VdmSize;
    Status = NtFreeVirtualMemory(
        NtCurrentProcess(),
        &BaseAddress,
        &Size,
        MEM_DECOMMIT);

    if (!NT_SUCCESS(Status)) {
        VDprint(VDP_LEVEL_ERROR,
            ("SoftPc: NtDeCommitVirtualMemory failed !!!! Status = %lx\n",
            Status));
        VDbreak(VDB_LEVEL_ERROR);
    }
}


EXPORT
sys_addr
sas_memory_size(
    VOID
    )
/*++

Routine Description:

    This routine returns the size of Intel memory

Arguments:

    none

Return Value:

    size of intel memory

--*/
{
    return(VdmSize);
}


EXPORT
VOID
sas_connect_memory(
    IN sys_addr Low,
    IN sys_addr High,
    IN int Type
    )
/*++

Routine Description:

    This routine sets up a type record for the specified address region.
    If the specified address region was a different type, it is changed to
    the new type.

Arguments:

    Low -- the starting address of the region
    High -- the ending address of the region
    Type -- the type for the region, one of SAS_RAM, SAS_VIDEO, SAS_ROM,
        SAS_WRAP, SAS_INACCESSIBLE

Return Value:

    None.
--*/
{
    //bugbug do we handle new block contained in old block correctly?
    PMEMTYPE Current, Previous, New, Temp;

    if (!MemType) {
        MemType = (PMEMTYPE) ch_malloc(sizeof(MEMTYPE));
        if ( NULL == MemType ) {
             goto ErrorSASC;
        }

        MemType->Previous = NULL;
        MemType->Next = NULL;
        MemType->Start = Low;
        MemType->End = High;
        MemType->Type = (half_word)Type;
        return;
    }

    Current = MemType;
    while (Current && (Low > Current->Start)) {
        Previous = Current;
        Current = Current->Next;
    }

    if ((Current) && (Low == Current->Start) && (High == Current->End)) {
        Current->Type = (half_word)Type;
        return;
    }

    New = (PMEMTYPE) ch_malloc(sizeof(MEMTYPE));
    if ( NULL == New ) {
        goto ErrorSASC; 
    }

    if (!Current) {
        // Block goes at end of list

        Previous->Next = New;
        New->Previous = Previous;
        New->Start = Low;
        New->End = High;
        New->Type = (half_word)Type;
        New->Next = NULL;
    } else {
        // Block goes in front of Current

        New->Start = Low;
        New->Type = (half_word)Type;
        New->End = High;
        New->Previous = Current->Previous;
        New->Next = Current;
        Current->Previous = New;
        if (!New->Previous) {
            MemType = New;
        } else {
            New->Previous->Next = New;
        }
    }


    // Block overlaps one or more existing blocks

    if (New->Previous) {
        if (New->Previous->End > New->End) {
            // block contained in exising block
            Temp = (PMEMTYPE) ch_malloc(sizeof(MEMTYPE));
            if(NULL == Temp) {
               goto ErrorSASC;
            }
            Temp->Previous = New;
            Temp->Next = New->Next;
            New->Next = Temp;
            if (Temp->Next) {
                Temp->Next->Previous = Temp;
            }
            Temp->End = New->Previous->End;
            New->Previous->End = New->Start - 1;
            Temp->Start = New->End + 1;
            Temp->Type = New->Previous->Type;
            return;
        } else if (New->Previous->End >= New->Start){
            // block overlaps end of exising block
            New->Previous->End = New->Start - 1;
        }
    }

    // remove all blocks entirely contained in new block
    while ((New->Next) && (New->Next->End <= New->End)) {
        Temp = New->Next;
        New->Next = New->Next->Next;
        if (New->Next) {
            New->Next->Previous = New;
        }
        free(Temp);
    }

    // remove portion of next block overlapping new block
    if ((New->Next) && (New->Next->Start <= New->End)) {
        New->Next->Start = New->End + 1;
    }
    return;
ErrorSASC:
    
    RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
        RMB_ICON_BANG | RMB_ABORT);
    TerminateVDM();
}

EXPORT
half_word
sas_memory_type(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the type of memory at a specific address

Arguments:

    Address -- linear address to return type for.

Return Value:

    the type for the region, one of SAS_RAM, SAS_VIDEO, SAS_ROM,
        SAS_WRAP, SAS_INACCESSIBLE
--*/
{
    PMEMTYPE Current;

    if (Address > VdmSize) {
        return SAS_INACCESSIBLE;
    }

    Current = MemType;
    while (Current && !((Address >= Current->Start) &&
        (Address <= Current->End))) {
        Current = Current->Next;
    }
    if (!Current) {
        return SAS_INACCESSIBLE;
    }
    return Current->Type;
}



EXPORT
VOID
sas_enable_20_bit_wrapping(
    VOID
    )
/*++

Routine Description:

    This routine causes memory addresses to wrap at 1MB

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    PVOID   BaseAddress;
    ULONG   Size;
    LARGE_INTEGER SectionOffset;
    // if A20 line is off already do nothing
    if (A20IsON == FALSE){
        return;
    }
    BaseAddress = (PVOID)ONEMEGA;
    Size = SIXTYFOURK;
    Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                  BaseAddress
                                  );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("A20OFF: Unable to unmap view of section, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }
    SectionOffset.HighPart = SectionOffset.LowPart = 0;
    Status = NtMapViewOfSection(A20SectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                Size,
                                &SectionOffset,
                                &Size,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("A20OFF: Unable to map view of section, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }
    A20IsON = FALSE;
}

EXPORT
VOID
sas_disable_20_bit_wrapping(
    VOID
    )
/*++

Routine Description:

    This routine causes addressing to NOT wrap at 1MB

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS    Status;
    PVOID   BaseAddress;
    ULONG   Size;
    LARGE_INTEGER SectionOffset;

    // if A20 line is on already do nothing
    if (A20IsON == TRUE){
        return;
    }
    BaseAddress = (PVOID)ONEMEGA;
    Size = SIXTYFOURK;

    Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                  BaseAddress
                                  );


    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("A20ON: Unable to unmap view of section, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }
    SectionOffset.HighPart = 0;
    SectionOffset.LowPart = 640 * 1024;
    Status = NtMapViewOfSection(A20SectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                Size,
                                &SectionOffset,
                                &Size,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_EXECUTE_READWRITE
                                );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("A20ON: Unable to map view of section, status = %lx\n",
                 Status);
#endif
        TerminateVDM();
    }
    A20IsON = TRUE;
}



EXPORT
half_word
sas_hw_at(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the byte at the specified address

Arguments:

    Address -- address of byte to return

Return Value:

    value of byte at specified address

--*/
{
    half_word RetVal;

    if (Address > VdmSize) {
        return 0xFE;
    }

    RetVal = *((half_word *)Address);
    return RetVal;
}


EXPORT
word
sas_w_at(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the word at the specified address

Arguments:

    Address -- address of word to return

Return Value:

    value of word at specified address

--*/
{
    word RetVal;

//    DbgPrint("NtVdm : sas_w_at \n");
    if (Address > VdmSize) {
        return 0xFEFE;
    }

    RetVal = *((word *)Address);
    return RetVal;
}


EXPORT
double_word
sas_dw_at(
    IN sys_addr Address
    )
/*++

Routine Description:

    This routine returns the dword at the specified address

Arguments:

    Address -- address of dword to return

Return Value:

    value of dword at specified address

--*/
{
    double_word RetVal;

    //DbgPrint("NtVdm : sas_dw_at \n");
    RetVal = (double_word)(((ULONG)sas_w_at(Address + 2) << 16) +
        sas_w_at(Address));
    return RetVal;
}


EXPORT
VOID
sas_load(
    IN sys_addr Address,
    IN half_word *Value
    )
/*++

Routine Description:

    This routine stores the byte at the specified address in the supplied
    variable

Arguments:

    Address -- address of byte to return
    Value -- Variable to store the value in

Return Value:

    None.
--*/
{
    //DbgPrint("NtVdm : sas_load \n");
    if (Address > VdmSize) {
        *Value = 0xFE;
        return;
    }

    *Value = *((half_word *)Address);
    return;
}


EXPORT
VOID
sas_loadw(
    IN sys_addr Address,
    IN word *Value
    )
/*++

Routine Description:

    This routine stores the word at the specified address in the supplied
    variable

Arguments:

    Address -- address of word to return
    Value -- Variable to store the value in

Return Value:

    None.
--*/
{
    //DbgPrint("NtVdm : sas_loadw\n");
    if (Address > VdmSize) {
        *Value = 0xFEFE;
        return;
    }

    *Value = *((word *)Address);
    //DbgPrint("NtVdm : sas_loadw word at address %lx is %x (Not video)\n",Address,*Value);
    return;
}



EXPORT
VOID
sas_store(
    IN sys_addr Address,
    IN half_word Value
    )
/*++

Routine Description:

    This routine stores the specified byte at the specified address

Arguments:

    Address -- address of word to return
    Value -- value to store

Return Value:

    None.
--*/
{
    half_word Type;
    //DbgPrint("NtVdm : sas_store\n");
    if (Address <= VdmSize) {
        Type = sas_memory_type(Address);
        switch (Type) {
            case SAS_ROM:
                break;

            default:
                *((half_word *)Address) = Value;
                //DbgPrint("NtVdm : sas_store put byte %x at address %lx\n",Value,Address);
                break;
        }
    }
}



EXPORT
VOID
sas_storew(
    IN sys_addr Address,
    IN word Value
    )
/*++

Routine Description:

    This routine stores the specified word at the specified address

Arguments:

    Address -- address of word to return
    Value -- value to store at the specified address

Return Value:

    None.
--*/
{

    //DbgPrint("NtVdm : sas_storew\n");
    if (Address + 1 <= VdmSize) {
        switch (sas_memory_type(Address)) {

            case SAS_ROM:
                break;

            default:
                *((word *)Address) = Value;
                //DbgPrint("NtVdm : sas_storew put word %x at address %lx\n",Value,Address);
                break;
        }
    }
}



EXPORT
VOID
sas_storedw(
    IN sys_addr Address,
    IN double_word Value
    )
/*++

Routine Description:

    This routine stores the specified dword at the specified address

Arguments:

    Address -- address of word to return
    Value -- value to store at the specified address

Return Value:

    None.
--*/
{
    //_asm int 3;
    sas_storew(Address, (word)(Value & 0xFFFF));
    sas_storew(Address + 2, (word)((Value >> 16) & 0xFFFF));
}


EXPORT
VOID
sas_loads(
    IN sys_addr Source,
    IN host_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

     This routine copies the string from the specified intel address to the
     specified host address

Arguments:

    Source -- Intel address to copy from
    Destination -- host address to copy the string to
    Length -- length of the string to copy

Return Value:

    None.
--*/
{

    //DbgPrint("NtVdm : sas_loads\n");
    RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
}



EXPORT
VOID
sas_stores(
    IN sys_addr Destination,
    IN host_addr Source,
    IN sys_addr Length
    )
/*++

Routine Description:

     This routine copies the string from the specified host address to the
     specified intel address

Arguments:

    Destination -- intel address to copy the string to
    Source -- host address to copy from
    Length -- length of the string to copy

Return Value:

    None.
--*/
{

    //DbgPrint("NtVdm : sas_stores\n");
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
            break;
    }
}


EXPORT
VOID
sas_move_bytes_forward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in bytes)

Return Value:

    None.
--*/
{
    //DbgPrint("NtVdm : sas_move_bytes_forward\n");
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
            break;
    }
}



EXPORT
VOID
sas_move_words_forward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in words)

Return Value:

    None.
--*/
{
    //_asm int 3;
    Length <<= 1;
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) Destination, (PVOID) Source, Length);
            break;
    }
}



EXPORT
VOID
sas_move_bytes_backward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in bytes)

Return Value:

    None.
--*/
{
    //_asm int 3;
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) (Destination - Length + 1),
                          (PVOID) (Source - Length + 1),
                          Length);
            break;
    }
}



EXPORT
VOID
sas_move_words_backward(
    IN sys_addr Source,
    IN sys_addr Destination,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine copies one region of intel memory to another.

Arguments:

    Source -- source intel address
    Destination -- destination intel address
    Length -- length of region to copy (in words)

Return Value:

    None.
--*/
{
    //_asm int 3;
    Length <<= 1;
    switch (sas_memory_type(Destination)) {

        case SAS_ROM:
            break;

        default:
            RtlCopyMemory((PVOID) (Destination - Length + 1),
                          (PVOID) (Source - Length + 1),
                          Length);
            break;
    }
}

EXPORT
VOID
sas_fills(
    IN sys_addr Address,
    IN half_word Value,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine fills a specified region of intel memory with a byte value

Arguments:

    Address -- address to fill at
    Value -- value to fill with
    Length -- length of region to fill

Return Value:

    None.
--*/
{
    half_word Type;

    //DbgPrint("NtVdm : sas_fills\n");
    Type = sas_memory_type(Address);
    switch (Type) {

        case SAS_ROM:
            break;

        default:
            RtlFillMemory((PVOID) Address, Length, Value);
            break;
    }
}

EXPORT
VOID
sas_fillsw(
    IN sys_addr Address,
    IN word Value,
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine fills a specified region of intel memory with a word value

Arguments:

    Address -- address to fill at
    Value -- value to fill with
    Length -- length of region to fill

Return Value:

    None.
--*/
{

    word *p;
    half_word Type;

    //DbgPrint("NtVdm : sas_fillsw\n");
    Type = sas_memory_type(Address);
    switch (Type) {

        case SAS_ROM:
            break;

        default:
            p = (word *)Address;
            while (Length--) {
                *p++ = Value;
            }
            break;
    }
}

host_addr scratch = NULL;

EXPORT
host_addr
sas_scratch_address(
    IN sys_addr Length
    )
/*++

Routine Description:

    This routine supplies a scratch buffer for short term use

Arguments

    Length -- length of buffer needed

Return Value:

    None.

NOTE: Sudeepb 31-Oct-1993 Converted scratch to be allocated dynamically rather
      than as a static array.
--*/
{
    //DbgPrint("NtVdm : sas_scratch_address\n");
    if (Length > 64 * 1024) {
        return NULL;
    }

    if (scratch)
        return scratch;

    if ((scratch = (host_addr) malloc (64 * 1024)) == NULL){
        RcMessageBox(EG_MALLOC_FAILURE, NULL, NULL,
             RMB_ICON_BANG | RMB_ABORT);
        TerminateVDM();
        return NULL;
    }

    return scratch;
}

EXPORT
half_word
sas_hw_at_no_check(
    sys_addr addr
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_hw_at_no_check\n");
    //DbgPrint("NtVdm : sas_hw_at_no_check byte at %lx is %x\n",addr,*((half_word *)addr));
    return *((half_word *)addr);
}

EXPORT
word
sas_w_at_no_check(
    sys_addr addr
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_w_at_no_check\n");
    //DbgPrint("NtVdm : sas_w_at_no_check word at %lx is %x\n",addr,*((word *)addr));
    return *((word *)addr);
}
EXPORT
double_word
sas_dw_at_no_check(
    sys_addr addr
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_dw_at_no_check\n");
    //DbgPrint("NtVdm : sas_dw_at_no_check double word at %lx is %lx\n",addr,*((double_word *)addr));
    return *((double_word *)addr);
}


EXPORT
VOID
sas_store_no_check(
    sys_addr addr,
    half_word val
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_store_no_check\n");
    *((half_word *)addr) = val;
    //DbgPrint("NtVdm : sas_store_no_check stored byte %x at %lx\n",val,addr);
}

EXPORT
VOID
sas_storew_no_check(
    sys_addr addr,
    word val
    )
// bugbug comment
{
    //DbgPrint("NtVdm : sas_storew_no_check\n");
    *((word *)addr) = val;
}
EXPORT
double_word
effective_addr(
    IN word Segment,
    IN word Offset
    )
/*++

Routine Description:

    This routine maps effective_addr to Sim32GetVdmPointer

Arguments:

    Segment -- segment of address
    Offset -- offset of address

Return Value:

    Actual Intel address corresponding to the address supplied
--*/
{
    //DbgPrint("NtVdm : effective_addr\n");
    return (ULONG)Sim32GetVDMPointer(((((ULONG)Segment) << 16) | Offset), 1,
        (UCHAR) (getMSW() & MSW_PE ? TRUE : FALSE));
}

typedef enum
{
    RAM,
    VIDEO,
    ROM,
    IN_FRAGMENT,
    NEXT_FRAGMENT
} mem_type;

typedef struct
{
    VOID    (*b_write)();
    VOID    (*w_write)();
    VOID    (*b_fill)();
    VOID    (*w_fill)();
    VOID    (*b_move)();
    VOID    (*w_move)();
} MEM_HANDLERS;
#define TYPE_RANGE ((int)SAS_INACCESSIBLE)
#define write_b_write_ptrs( offset, func )  ( b_write_ptrs[(offset)] = (func) )
#define write_w_write_ptrs( offset, func )  ( w_write_ptrs[(offset)] = (func) )
#define write_b_page_ptrs( offset, func )   ( b_move_ptrs[(offset)] = b_fill_ptrs[(offset)] = (func) )
#define write_w_page_ptrs( offset, func )   ( w_move_ptrs[(offset)] = w_fill_ptrs[(offset)] = (func) )
#define init_b_write_ptrs( offset, func )   ( b_write_ptrs[(offset)] = (func) )
#define init_w_write_ptrs( offset, func )   ( w_write_ptrs[(offset)] = (func) )
#define init_b_page_ptrs( offset, func )    ( b_move_ptrs[(offset)] = b_fill_ptrs[(offset)] = (func) )
#define init_w_page_ptrs( offset, func )    ( w_move_ptrs[(offset)] = w_fill_ptrs[(offset)] = (func) )
#define read_b_write_ptrs( offset )     ( b_write_ptrs[(offset)] )
#define read_w_write_ptrs( offset )     ( w_write_ptrs[(offset)] )
#define read_b_page_ptrs( offset )      ( b_move_ptrs[(offset)] )
#define read_w_page_ptrs( offset )      ( w_move_ptrs[(offset)] )
#define read_b_move_ptrs( offset )      ( b_move_ptrs[(offset)] )
#define read_w_move_ptrs( offset )      ( w_move_ptrs[(offset)] )
#define read_b_fill_ptrs( offset )      ( b_fill_ptrs[(offset)] )
#define read_w_fill_ptrs( offset )      ( w_fill_ptrs[(offset)] )

/*
*   The main gmi data structures are defined here
*/
void (*(b_write_ptrs[TYPE_RANGE]))() ; /* byte write function */
void (*(w_write_ptrs[TYPE_RANGE]))() ; /* word write function */
void (*(b_fill_ptrs[TYPE_RANGE]))() ;  /* byte str fill func */
void (*(w_fill_ptrs[TYPE_RANGE]))() ;  /* word str fill func */
void (*(b_move_ptrs[TYPE_RANGE]))() ;  /* byte str write func */
void (*(w_move_ptrs[TYPE_RANGE]))() ;  /* word str write func */

void    gmi_define_mem(type,handlers)
mem_type type;
MEM_HANDLERS *handlers;
{
    int int_type = (int)(type);
    init_b_write_ptrs(int_type, (void(*)())(handlers->b_write));
    init_w_write_ptrs(int_type, (void(*)())(handlers->w_write));
    b_move_ptrs[int_type] = (void(*)())(handlers->b_move);
    w_move_ptrs[int_type] = (void(*)())(handlers->w_move);
    b_fill_ptrs[int_type] = (void(*)())(handlers->b_fill);
    w_fill_ptrs[int_type] = (void(*)())(handlers->w_fill);
}
#endif
BOOL sas_twenty_bit_wrapping_enabled() {
    return (!A20IsON);
}

VOID sas_part_enable_20_bit_wrapping(){
}
VOID sas_part_disable_20_bit_wrapping(){
}


/*
 * This function maps the given EMM backfill memory to DOS conventional
 * memory. The function is provided to EMM manager to put back
 * unmapped backfill memory(hold its contents while it is not mapped).
 *
 * NOTE: The very first caller will be sas_init.
 *
 * Input: ULONG BaseAddress -- the starting address, must be in INTEL page
 *                             boundary
 *        ULONG Size        -- size of the range, must be a multiple of
 *                             EMM_PAGE_SIZE.
 *
 * According to LouP, a view costs about 400 bytes of memory. This is why
 * I make these function strictly to work on EMM_PAGE_SIZE instead of 4KB.
 */


BOOL
HoldEMMBackFillMemory(ULONG BaseAddress, ULONG Size)
{
    ULONG NewBase, Pages, i;
    LARGE_INTEGER   SectionOffset;
    ULONG ViewSize;
    NTSTATUS Status = STATUS_SUCCESS;;

    /* this function can only be called if there is backfill at all */
    ASSERT(BackFillSegment < 640 * 1024 / 16);

    // size must be EMM_PAGE_SIZE multiple
    ASSERT((Size % EMM_PAGE_SIZE) == 0);

    // address must be on INTEL page boundary
    ASSERT((BaseAddress & (INTEL_PAGE_SIZE - 1)) == 0);

    for (Pages = Size / EMM_PAGE_SIZE; Pages; Pages--) {
        SectionOffset.LowPart = BaseAddress;
        SectionOffset.HighPart = 0;
        ViewSize = EMM_PAGE_SIZE;
        Status = NtMapViewOfSection(A20SectionHandle,
                                    NtCurrentProcess(),
                                    (PVOID *)&BaseAddress,
                                    0,
                                    ViewSize,
                                    &SectionOffset,
                                    &ViewSize,
                                    ViewUnmap,
                                    MEM_DOS_LIM,
                                    PAGE_EXECUTE_READWRITE
                                    );
        if (!NT_SUCCESS(Status))
            break;
        BaseAddress += EMM_PAGE_SIZE;
    }
    return (NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\monitorp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Monitorp.h

Abstract:

    This contains the function prototypes, constants, and types for
    the monitor.

Author:

    Dave Hastings (daveh) 16 Mar 1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <vint.h>
#include "bop.h"
#include "softpc.h"
//bugbug
typedef unsigned int UINT;

#include <nt_mon.h>   // for softpc base definitions
#include <nt_reset.h>
#include <monregs.h>

//extern VDM_TIB VdmTib;

#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_V86_MASK       0x00020000L
#define VDM_BASE_ADDRESS      0x00000001L


#define RPL_MASK                  3
// Types borrowed from windef.h

typedef unsigned char       BYTE;

// Memory type record

typedef struct _Memory_Type {
    struct _Memory_Type *Previous;
    struct _Memory_Type *Next;
    ULONG Start;
    ULONG End;
    half_word Type;
} MEMTYPE, *PMEMTYPE;

//  private flags

#define VDM_IDLE              0x00000001L

// external data

extern ULONG VdmFlags;
extern ULONG VdmSize;
extern LDT_ENTRY *Ldt;
extern ULONG   IntelBase;          // base memory address
extern ULONG   VdmDebugLevel;      // used to control debugging
extern ULONG   VdmSize;            // Size of memory in VDM
extern PVOID  CurrentMonitorTeb;   // thread that is currently executing instructions.
extern BOOLEAN IRQ13BeingHandled;  // true until IRQ13 eoi'ed
extern CONTEXT InitialContext;     // Initial floating point context for all threads
extern BOOLEAN DebugContextActive;

#define MAX_BOP 256
VOID reset(VOID);
VOID dummy_int(VOID);
VOID unexpected_int(VOID);
VOID illegal_bop(VOID);
VOID illegal_op_int(VOID);
VOID print_screen(VOID);
VOID time_int(VOID);
VOID keyboard_int(VOID);
VOID diskette_int(VOID);
VOID video_io(VOID);
VOID equipment(VOID);
VOID memory_size(VOID);
VOID disk_io(VOID);
VOID rs232_io(VOID);
VOID cassette_io(VOID);
VOID keyboard_io(VOID);
VOID printer_io(VOID);
VOID rom_basic(VOID);
VOID bootstrap(VOID);
VOID time_of_day(VOID);
VOID critical_region(VOID);
VOID cmd_install(VOID);
VOID cmd_load(VOID);
VOID redirector(VOID);
VOID ega_video_io(VOID);
VOID MsBop0(VOID);
VOID MsBop1(VOID);
VOID MsBop2(VOID);
VOID MsBop3(VOID);
VOID MsBop4(VOID);
VOID MsBop5(VOID);
VOID MsBop6(VOID);
VOID MsBop7(VOID);
VOID MsBop8(VOID);
VOID MsBop9(VOID);
VOID MsBopA(VOID);
VOID MsBopB(VOID);
VOID MsBopC(VOID);
VOID MsBopD(VOID);
VOID MsBopE(VOID);
VOID MsBopF(VOID);
VOID emm_init(VOID);
VOID emm_io(VOID);
VOID return_from_call(VOID);
VOID rtc_int(VOID);
VOID re_direct(VOID);
VOID D11_int(VOID);
VOID int_287(VOID);
VOID worm_init(VOID);
VOID worm_io(VOID);
VOID ps_private_1(VOID);
VOID ps_private_2(VOID);
VOID ps_private_3(VOID);
VOID ps_private_4(VOID);
VOID ps_private_5(VOID);
VOID ps_private_6(VOID);
VOID ps_private_7(VOID);
VOID ps_private_8(VOID);
VOID ps_private_9(VOID);
VOID ps_private_10(VOID);
VOID ps_private_11(VOID);
VOID ps_private_12(VOID);
VOID ps_private_13(VOID);
VOID ps_private_14(VOID);
VOID ps_private_15(VOID);
VOID bootstrap1(VOID);
VOID bootstrap2(VOID);
VOID bootstrap3(VOID);
VOID ms_windows(VOID);
VOID msw_mouse(VOID);
VOID mouse_install1(VOID);
VOID mouse_install2(VOID);
VOID mouse_int1(VOID);
VOID mouse_int2(VOID);
VOID mouse_io_language(VOID);
VOID mouse_io_interrupt(VOID);
VOID mouse_video_io(VOID);
VOID switch_to_real_mode(VOID);
VOID control_bop(VOID);
VOID diskette_io(VOID);
VOID host_unsimulate(VOID);
VOID DispatchPageFault (ULONG,ULONG);

NTSTATUS
FastEnterPm(
    );

VOID
DispatchInterrupts(
    VOID
    );

VOID
DispatchHwInterrupt(
    );

ULONG
GetInterruptHandler(
    ULONG InterruptNumber,
    BOOLEAN ProtectedMode
    );

PVOID
GetInterruptStack(
    ULONG InterruptNumber,
    PUSHORT StackSelector,
    PUSHORT StackPointer,
    BOOLEAN ProtectedMode
    );


VOID
CpuOnetimeInit(
    VOID
    );

VOID
CpuOnetimeTerm(
    VOID
    );

VOID
cpu_createthread();

VOID
cpu_exitthread();

HANDLE
ThreadLookUp(
    PVOID
    );

VOID
cpu_exit();

VOID
InterruptInit(
    VOID
    );

VOID
InterruptTerminate(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\spcstubs.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdm.h>
#include <stdio.h>
//Tim Nov 92 #include <xt.h>
#include <nt_mon.h> //Tim Nov 92, so it builds...


ULONG cpu_calc_q_ev_inst_for_time(ULONG time){
    return(time);
}

ULONG q_ev_count;

VOID cpu_q_ev_set_count(ULONG time){
    q_ev_count = time;
}
ULONG cpu_q_ev_get_count() {
    return(q_ev_count);
}

char szYodaWarn[]="NtVdm : Using Yoda on an x86 may be hazardous to your systems' health\n";

unsigned char *GDP;

int getCPL(){
    OutputDebugString(szYodaWarn);
    return(0);
}

int getEM(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getGDT_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getGDT_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getIDT_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getIDT_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getIOPL(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getLDT_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getLDT_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getLDT_SELECTOR(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getMP(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getNT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTR_BASE(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTR_LIMIT(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTR_SELECTOR(){
    OutputDebugString(szYodaWarn);
    return(0);
}
int getTS(){
    OutputDebugString(szYodaWarn);
    return(0);
}
void setPE(int dummy1){
    OutputDebugString(szYodaWarn);
}
boolean selector_outside_table(word foo, double_word *bar){
    UNREFERENCED_PARAMETER(foo);
    UNREFERENCED_PARAMETER(bar);
    OutputDebugString("NtVdm : Using Yoda on an x86 may be hazardous to your systems' health\n");
    return(0);
}

VOID
EnterIdle(){
}

VOID
LeaveIdle(){
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\hpscan\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\hpscan\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\thread.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Thread.c

Abstract:

    This file contains functions for tracking and manipulating threads

Author:

    Dave Hastings (daveh) 18-Apr-1992

Revision History:

--*/

#include <monitorp.h>
#include <malloc.h>

extern VDM_INTERRUPTHANDLER DpmiInterruptHandlers[];
extern VDM_FAULTHANDLER DpmiFaultHandlers[];

// Instantiated in vdpm.c
extern PFAMILY_TABLE *pgDpmVdmFamTbls;

//
// Local Types
//

typedef struct _MonitorThread {
    struct _MonitorThread *Previous;
    struct _MonitorThread *Next;
    PVOID Teb;
    HANDLE Thread;
    VDM_TIB VdmTib;
} MONITORTHREAD, *PMONITORTHREAD;

//
// Local Variables
//

PMONITORTHREAD ThreadList = NULL;          // List of all threads registered

VOID
InitVdmTib(
    PVDM_TIB VdmTib
    )
/*++

Routine Description:

    This routine is used to initialize the VdmTib.

Arguments:

    VdmTib - supplies a pointer to the vdm tib to be initialized

Return Value:

    None.

--*/
{
    VdmTib->IntelMSW = 0;
    VdmTib->VdmContext.SegGs = 0;
    VdmTib->VdmContext.SegFs = 0;
    VdmTib->VdmContext.SegEs = 0;
    VdmTib->VdmContext.SegDs = 0;
    VdmTib->VdmContext.SegCs = 0;
    VdmTib->VdmContext.Eip = 0xFFF0L;
    VdmTib->VdmContext.EFlags = 0x02L | EFLAGS_INTERRUPT_MASK;

    VdmTib->MonitorContext.SegDs = KGDT_R3_DATA | RPL_MASK;
    VdmTib->MonitorContext.SegEs = KGDT_R3_DATA | RPL_MASK;
    VdmTib->MonitorContext.SegGs = 0;
    VdmTib->MonitorContext.SegFs = KGDT_R3_TEB | RPL_MASK;

    VdmTib->PrinterInfo.prt_State       = NULL;
    VdmTib->PrinterInfo.prt_Control     = NULL;
    VdmTib->PrinterInfo.prt_Status      = NULL;
    VdmTib->PrinterInfo.prt_HostState   = NULL;

    ASSERT(VDM_NUMBER_OF_LPT == 3);

    VdmTib->PrinterInfo.prt_Mode[0] =
    VdmTib->PrinterInfo.prt_Mode[1] =
    VdmTib->PrinterInfo.prt_Mode[2] = PRT_MODE_NO_SIMULATION;

    VdmTib->VdmFaultTable = DpmiFaultHandlers;
    VdmTib->VdmInterruptTable = DpmiInterruptHandlers;

    VdmTib->ContinueExecution = FALSE;
    VdmTib->NumTasks = -1;
    VdmTib->Size = sizeof(VDM_TIB);
}



VOID
cpu_createthread(
    HANDLE Thread,
    PVDM_TIB VdmTib
    )
/*++

Routine Description:

    This routine adds a thread to the list of threads that could be executing
    in application mode.

Arguments:

    Thread -- Supplies a thread handle

    VdmContext -- Supplies a pointer to the VdmContext for the new thread

Return Value:

    None.

--*/
{
    PMONITORTHREAD NewThread, CurrentThread;
    THREAD_BASIC_INFORMATION ThreadInfo;
    HANDLE MonitorThreadHandle;
    NTSTATUS Status;

    //
    // Correctly initialize the floating point context for the thread
    //
    InitialContext.ContextFlags = CONTEXT_FLOATING_POINT;

    if (DebugContextActive)
        InitialContext.ContextFlags |= CONTEXT_DEBUG_REGISTERS;

    Status = NtSetContextThread(
        Thread,
        &InitialContext
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NtVdm terminating : Could not set float context for\n"
                 "                    thread handle 0x%x, status %lx\n", Thread, Status);
        DbgBreakPoint();
#endif
        TerminateVDM();
    }

    //
    // Set up a structure to keep track of the new thread
    //
    NewThread = malloc(sizeof(MONITORTHREAD));

    if (!NewThread) {
#if DBG
        DbgPrint("NTVDM: Could not allocate space for new thread\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }
    RtlZeroMemory(NewThread, sizeof(MONITORTHREAD));
    if (VdmTib == NULL) {
        InitVdmTib(&NewThread->VdmTib);
    } else {
        RtlCopyMemory(&NewThread->VdmTib, VdmTib, sizeof(VDM_TIB));
        NewThread->VdmTib.ContinueExecution = FALSE;
        NewThread->VdmTib.NumTasks = -1;
        NewThread->VdmTib.VdmContext.EFlags = 0x02L | EFLAGS_INTERRUPT_MASK;
        NewThread->VdmTib.MonitorContext.EFlags = 0x02L | EFLAGS_INTERRUPT_MASK;
    }

    // All tasks start with a ptr to the VDM global tables
    NewThread->VdmTib.pDpmFamTbls = (PFAMILY_TABLE *)pgDpmVdmFamTbls;

    //
    // Create a handle for the monitor to use
    //

    Status = NtDuplicateObject(
        NtCurrentProcess(),
        Thread,
        NtCurrentProcess(),
        &MonitorThreadHandle,
        0,
        0,
        DUPLICATE_SAME_ACCESS
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NTVDM: Could not duplicate thread handle\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }

    NewThread->Thread = MonitorThreadHandle;

    Status = NtQueryInformationThread(
        MonitorThreadHandle,
        ThreadBasicInformation,
        &ThreadInfo,
        sizeof(THREAD_BASIC_INFORMATION),
        NULL
        );

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("NTVDM: Could not get thread information\n");
        DbgBreakPoint();
#endif
        TerminateVDM();
    }

    NewThread->Teb = ThreadInfo.TebBaseAddress;
    ((PTEB)(NewThread->Teb))->Vdm = &NewThread->VdmTib;

    //
    // Insert the new thread in the list.  The list is sorted in ascending
    // order of Teb address
    //
    if (!ThreadList) {
        ThreadList = NewThread;
        NewThread->Next = NULL;
        NewThread->Previous = NULL;
        return;
    }

    CurrentThread = ThreadList;
    while ((CurrentThread->Next) && (CurrentThread->Teb < NewThread->Teb)) {
        CurrentThread = CurrentThread->Next;
    }

    if (NewThread->Teb > CurrentThread->Teb) {
        CurrentThread->Next = NewThread;
        NewThread->Previous = CurrentThread;
        NewThread->Next = NULL;
    } else {
        ASSERT((CurrentThread->Teb != NewThread->Teb));
        NewThread->Previous = CurrentThread->Previous;
        NewThread->Next = CurrentThread;
        CurrentThread->Previous = NewThread;
        if (NewThread->Previous) {
            NewThread->Previous->Next = NewThread;
        } else {
            ThreadList = NewThread;
        }
    }
}

VOID
cpu_exitthread(
    VOID
    )
/*++

Routine Description:

    This routine frees the thread tracking information, and closes the thread
    handle

Arguments:


Return Value:

    None.

--*/
{
    PVOID CurrentTeb;
    NTSTATUS Status;
    PMONITORTHREAD ThreadInfo;

    CurrentTeb = NtCurrentTeb();

    ThreadInfo = ThreadList;

    //
    // Find this thread in the list
    //
    while ((ThreadInfo) && (ThreadInfo->Teb != CurrentTeb)) {
        ThreadInfo = ThreadInfo->Next;
    }

    if (!ThreadInfo) {
#if DBG
        DbgPrint("NTVDM: Could not find thread in list\n");
        DbgBreakPoint();
#endif
        return;
    }

    //
    // Close our handle to this thread
    //
    Status = NtClose(ThreadInfo->Thread);
#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint("NTVDM: Could not close thread handle\n");
    }
#endif

    //
    // Remove this thread from the list
    //
    if (ThreadInfo->Previous) {
        ThreadInfo->Previous->Next = ThreadInfo->Next;
    } else {
        ThreadList = ThreadInfo->Next;
    }

    if (ThreadInfo->Next) {
        ThreadInfo->Next->Previous = ThreadInfo->Previous;
    }

    free(ThreadInfo);
}

HANDLE
ThreadLookUp(
    PVOID Teb
    )
/*++

Routine Description:

    This routine returns the handle for the specified thread.

Arguments:

    Teb -- Supplies the teb pointer of the thread

Return Value:

    Returns the handle of the thread, or NULL

--*/
{
    PMONITORTHREAD Thread;

    Thread = ThreadList;

    while ((Thread) && (Thread->Teb != Teb)) {
        Thread = Thread->Next;
    }

    if (Thread) {
        return Thread->Thread;
    } else {
        return NULL;
    }
}

BOOL
ThreadSetDebugContext(
    PULONG pDebugRegisters
    )
/*++

Routine Description:

    This routine sets the debug registers for all the threads that the
    monitor knows about.

Arguments:

    pDebugRegisters -- Pointer to 6 dwords containing the requested debug
                       register contents.

Return Value:

    none

--*/
{
    PMONITORTHREAD Thread;
    NTSTATUS Status = STATUS_SUCCESS;

    Thread = ThreadList;
    InitialContext.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    InitialContext.Dr0 = *pDebugRegisters++;
    InitialContext.Dr1 = *pDebugRegisters++;
    InitialContext.Dr2 = *pDebugRegisters++;
    InitialContext.Dr3 = *pDebugRegisters++;
    InitialContext.Dr6 = *pDebugRegisters++;
    InitialContext.Dr7 = *pDebugRegisters++;

    while (Thread) {

        Status = NtSetContextThread(
            Thread->Thread,
            &InitialContext
            );

        if (!NT_SUCCESS(Status))
            break;

        Thread = Thread->Next;
    }

    if (!NT_SUCCESS(Status))
        return (FALSE);
    else {
        DebugContextActive = ((InitialContext.Dr7 & 0x0f) != 0);
        return (TRUE);
    }

}

BOOL
ThreadGetDebugContext(
    PULONG pDebugRegisters
    )
/*++

Routine Description:

    This routine gets the debug registers for the current thread.

Arguments:

    pDebugRegisters -- Pointer to 6 dwords to receive the debug
                       register contents.

Return Value:

    none

--*/
{
    CONTEXT CurrentContext;
    NTSTATUS Status;

    CurrentContext.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    Status = NtGetContextThread(NtCurrentThread(), &CurrentContext);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    *pDebugRegisters++ = CurrentContext.Dr0;
    *pDebugRegisters++ = CurrentContext.Dr1;
    *pDebugRegisters++ = CurrentContext.Dr2;
    *pDebugRegisters++ = CurrentContext.Dr3;
    *pDebugRegisters++ = CurrentContext.Dr6;
    *pDebugRegisters++ = CurrentContext.Dr7;
    return (TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\vdpm.c ===
/*++
 *
 *  NTVDM v1.0
 *
 *  Copyright (c) 2002, Microsoft Corporation
 *
 *  VDPM.C
 *  NTVDM Dynamic Patch Module support
 *
 *  History:
 *  Created 22-Jan-2002 by CMJones
 *
--*/
#define _VDPM_C_
#define _DPM_COMMON_

// The _VDPM_C_ definition allows the global instantiation of gDpmVdmFamTbls[]
// and gDpmVdmModuleSets[] in NTVDM.EXE which are both defined in 
// mvdm\inc\dpmtbls.h
//
/* For the benefit of folks grepping for gDpmVdmFamTbls and gDpmVdmModuleSets:
const PFAMILY_TABLE  gDpmVdmFamTbls[]     = // See above for true story.
const PDPMMODULESETS gDpmVdmModuleSets[]  = // See above for true story.
*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlwapi.h>
#include "shimdb.h"
#include "dpmtbls.h"
#include "vshimdb.h"
#include "softpc.h"
#include "sfc.h"
#include "wowcmpat.h"

#undef _VDPM_C_
#undef _DPM_COMMON_

extern DWORD dwDosCompatFlags;

#define  MAX_DOS_FILENAME   8+3+1+1  // max dos filename (incl. '.' char) + NULL

#ifdef DBG
#define VDBGPRINT(a) DbgPrint(a)
#define VDBGPRINTANDBREAK(a)    {DbgPrint(a); DbgBreakPoint();}
#else
#define VDBGPRINT(a) 
#define VDBGPRINTANDBREAK(a)
#endif // DBG

#define VMALLOC(s) (LocalAlloc(LPTR, s))
#define VFREE(p)   (LocalFree(p))

// Global DATA
// These can't be const because they will get changed when WOW and/or DOS loads.
PFAMILY_TABLE  *pgDpmVdmFamTbls = (PFAMILY_TABLE *)gDpmVdmFamTbls;
PDPMMODULESETS *pgDpmModuleSets = (PDPMMODULESETS *)gDpmVdmModuleSets;

LPSTR  NeedToPatchSpecifiedModule(char *pszModuleName, PCMDLNPARMS pCmdLnParms);
PFLAGINFOBITS GetFlagCommandLine(PVOID pFlagInfo, DWORD dwFlag, DWORD dwFlags);
PCMDLNPARMS GetSdbCommandLineParams(LPWSTR  pwszAppFilePath, 
                                    DWORD  *dwFlags, 
                                    int    *pNumCLP);



// This function combines updates the Vdm tables with the WOW tables and sets
// the global tables.
// This will only be called when the WOWEXEC task initializes.
void BuildGlobalDpmStuffForWow(PFAMILY_TABLE  *pDpmWowFamTbls,
                               PDPMMODULESETS *pDpmWowModuleSets)
{
    // Update the task ptr to the family table array.
    DPMFAMTBLS() = pDpmWowFamTbls;
    pgDpmVdmFamTbls = pDpmWowFamTbls;

    // Change the pointer to the *process* module set array.
    pgDpmModuleSets = pDpmWowModuleSets;
}





char szAppPatch[]   = "\\AppPatch\\";
char szShimEngDll[] = "\\ShimEng.dll";

// Called if the app requires Dynamic Patch Module(s) and/or shims to be linked
// This returns void because if anything fails we can still run the app with
// the default global tables.
void InitTaskDpmSupport(int             numHookedFams,
                        PFAMILY_TABLE  *pgDpmFamTbls,
                        PCMDLNPARMS     pCmdLnParms,
                        PVOID           hSdb,
                        PVOID           pSdbQuery,
                        LPWSTR          pwszAppFilePath,
                        LPWSTR          pwszAppModuleName,
                        LPWSTR          pwszTempEnv)
{
    int                i, len, wdLen;
    int                cHookedFamilies = 0;
    int                cApi = 0;
    char              *pszDpmModuleName;
    NTSTATUS           Status;
    HMODULE            hMod;
    LPDPMINIT          lpfnInit;
    PFAMILY_TABLE      pFT;
    PFAMILY_TABLE     *pTB;
    char               szDpmModName[MAX_PATH];
    char               szShimEng[MAX_PATH];

    // allocate an array of ptrs to family tables
    pTB = (PFAMILY_TABLE *)
           VMALLOC(numHookedFams * sizeof(PFAMILY_TABLE));

    if(!pTB) {
        VDBGPRINTANDBREAK("NTVDM::InitTaskDpmSupport:VMALLOC 1 failed\n");
        goto ErrorExit;
    }

    wdLen = GetSystemWindowsDirectory(szDpmModName, MAX_PATH-1);
    strcat(szDpmModName, szAppPatch);
    wdLen += (sizeof(szAppPatch)/sizeof(char)) - 1;

    for(i = 0; i < numHookedFams; i++) {

        // see if we want this patch module for this app
        if(pszDpmModuleName = NeedToPatchSpecifiedModule(
                                      (char *)pgDpmModuleSets[i]->DpmFamilyType,
                                      pCmdLnParms)) {

            szDpmModName[wdLen] = '\0'; // set back to "c:\windows\AppPatch\"

            // Append dpm module.dll to "C:\windows\AppPatch\"
            len = strlen(pszDpmModuleName) + wdLen;
            len++;  // NULL char

            if(len > MAX_PATH) {
                goto UseGlobal;
            }
            strcat(szDpmModName, pszDpmModuleName);

            hMod = LoadLibrary(szDpmModName); 

            if(hMod == NULL) {
                VDBGPRINT("NTVDM::InitTaskDpmSupport:LoadLibrary failed");
                goto UseGlobal;
            }

            lpfnInit = (LPDPMINIT)GetProcAddress(hMod, "DpmInitFamTable"); 

            if(lpfnInit) {

                // Call the family table init function & get a ptr to the
                // hooked family table for this task.
                pFT = (lpfnInit)(pgDpmFamTbls[i], 
                                 hMod,
                                 (PVOID)hSdb,
                                 (PVOID)pSdbQuery,
                                 pwszAppFilePath,
                                 pgDpmModuleSets[i]);
                if(pFT) {
                    pTB[i] = pFT;
                    cHookedFamilies++;
                    cApi += pFT->numHookedAPIs;
                }
                // else use the global table for this family 
                else {
                    VDBGPRINT("NTVDM::InitTaskDpmSupport: Init failed");
                    goto UseGlobal;
                }
            }
            // else use the global table for this family 
            else {
                VDBGPRINT("NTVDM::InitTaskDpmSupport:GetAddr failed");

// If anything above fails just use the default global table for this family
UseGlobal:
                VDBGPRINT(" -- Using global table entry\n");

                pTB[i] = pgDpmFamTbls[i];
            }
        }

        // else this task doesn't require this family patch -- use the global 
        // table for this family
        else {
            pTB[i] = pgDpmFamTbls[i];
        }
    }

    // now patch the DPM tables into the VDM TIB for this task
    DPMFAMTBLS() = pTB;

    return;

ErrorExit:
    FreeTaskDpmSupport(pTB, numHookedFams, pgDpmFamTbls);

    return;
}





VOID FreeTaskDpmSupport(PFAMILY_TABLE  *pDpmFamTbls, 
                        int             numHookedFams, 
                        PFAMILY_TABLE  *pgDpmFamTbls)
{
    int            i;
    HMODULE        hMod;
    LPDPMDESTROY   lpfnDestroy;
    PFAMILY_TABLE  pFT;

    // if this task is using the global tables, nothing to do
    if(!pDpmFamTbls || pDpmFamTbls == pgDpmFamTbls) 
        return;

    // anything this task does from here on out gets to use the global tables
    DPMFAMTBLS() = pgDpmFamTbls;

    for(i = 0; i < numHookedFams; i++) {

        pFT  = pDpmFamTbls[i];
        hMod = pFT->hMod;

        // only free the table if it isn't the global table for this family
        if(pFT && (pFT != pgDpmFamTbls[i])) {

            // call the DPM destroy function
            lpfnDestroy = (LPDPMDESTROY)GetProcAddress(hMod, 
                                                       "DpmDestroyFamTable");
            (lpfnDestroy)(pgDpmFamTbls[i], pFT);
            FreeLibrary(hMod);
        }
    }
    VFREE(pDpmFamTbls);
}




// This takes a pszFamilyType="DPMFIO" type string and extracts the asscociated
// .dll from the DBU.XML command line parameter.
// For example:
//    pCmdLnParms->argv[0]="DPMFIO=dpmfio2.dll"
// It will return a ptr to "dpmfio2.dll" for the example above.
// See the notes for DpmFamilyType in mvdm\inc\dpmtbls.h 
LPSTR NeedToPatchSpecifiedModule(char *pszFamilyType, PCMDLNPARMS pCmdLnParms) 
{

    int    i;
    char **pArgv;
    char  *p;

    if(pCmdLnParms) {
        pArgv = pCmdLnParms->argv;

        if(pArgv && pCmdLnParms->argc > 0) {

            for(i = 0; i < pCmdLnParms->argc; i++) {

                // find the '=' char
                p = strchr(*pArgv, '=');
                if(NULL != p) {
                    // compare string up to, but not including, the '=' char
                    if(!_strnicmp(*pArgv, pszFamilyType, p-*pArgv)) {

                        // return ptr to char after the '=' char
                        return(++p);
                    }
                }
                else {
                    // The command line params for the WOWCF2_DPM_PATCHES compat
                    // flag aren't correct.
                    VDBGPRINT("NTVDM::NeedToPatchSpecifiedModule: no '=' char!\n");
                }
                pArgv++;
            }
        }
    }
    return(NULL);
}



void InitGlobalDpmTables(PFAMILY_TABLE  *pgDpmFamTbls,
                         int             numHookedFams) 
{

    int             i, j;
    PVOID           lpfn;
    HMODULE         hMod;
    PFAMILY_TABLE   pFT;


    // Build the table for each API family we hook.
    for(i = 0; i < numHookedFams; i++) {

        pFT = pgDpmFamTbls[i];
        pFT->hModShimEng = NULL;

        // For now we're assuming that the module is already loaded.  We'll
        // have to deal with dynamically loaded modules in the future.
        hMod = GetModuleHandle((pgDpmModuleSets[i])->ApiModuleName);

        pFT->hMod = hMod;

        pFT->pDpmShmTbls = NULL;
        pFT->DpmMisc     = NULL;

        if(hMod) {

            for(j = 0; j < pFT->numHookedAPIs; j++) {

                // get the *real* API address...
                lpfn = (PVOID)GetProcAddress(hMod, 
                                             (pgDpmModuleSets[i])->ApiNames[j]);

                // ...and save it in the family table, otherwise we continue to
                // use the one we statically linked in the import table(s).
                if(lpfn) {
                    pFT->pfn[j] = lpfn;
                }
            }
        }
    }
}



// Get the DOS app compat flags & the associated command line params from
// the app compat SDB.
PCMDLNPARMS InitVdmSdbInfo(LPCSTR pszAppName, DWORD *pdwFlags, int *pNumCLP)
{
    int             len;
    PCMDLNPARMS     pCmdLnParms = NULL;
    NTSTATUS        st;
    ANSI_STRING     AnsiString;
    UNICODE_STRING  UnicodeString;


    len = strlen(pszAppName);

    if((len > 0) && (len < MAX_PATH)) {

        if(RtlCreateUnicodeStringFromAsciiz(&UnicodeString, pszAppName)) {

            // Get the SDB compatibility flag command line parameters (not to be
            // confused with the DOS command line!)
            pCmdLnParms = GetSdbCommandLineParams(UnicodeString.Buffer,  
                                                  pdwFlags, 
                                                  pNumCLP);

            RtlFreeUnicodeString(&UnicodeString);
        }
    }
    return(pCmdLnParms);
}




// Gets the command line params associated with dwFlag (from WOWCOMPATFLAGS2 
// flag set).  It is parsed into argv, argc form using ';' as the delimiter.
PCMDLNPARMS GetSdbCommandLineParams(LPWSTR  pwszAppFilePath,
                                    DWORD  *dwFlags, 
                                    int    *pNumCLP)
{
    int             i, numFlags;
    BOOL            fReturn = TRUE;
    NTVDM_FLAGS     NtVdmFlags = { 0 };
    DWORD           dwMask;
    WCHAR          *pwszTempEnv   = NULL;
    WCHAR          *pwszAppModuleName;
    WCHAR           szFileNameW[MAX_DOS_FILENAME];
    PFLAGINFOBITS   pFIB = NULL;
    HSDB            hSdb = NULL;
    SDBQUERYRESULT  SdbQuery;
    WCHAR           wszCompatLayer[COMPATLAYERMAXLEN];
    APPHELP_INFO    AHInfo;
    PCMDLNPARMS     pCLP; 
    PCMDLNPARMS     pCmdLnParms = NULL;


    *pNumCLP = 0;
    pwszTempEnv = GetEnvironmentStringsW();

    if(pwszTempEnv) {

        // Strip off the path (DOS apps use the filename.exe as Module name
        // in the SDB).
        pwszAppModuleName = wcsrchr(pwszAppFilePath, L'\\');
        if(pwszAppModuleName == NULL) {
            pwszAppModuleName = pwszAppFilePath;
        }
        else {
            pwszAppModuleName++;  // advance past the '\' char
        }
        wcsncpy(szFileNameW, pwszAppModuleName, MAX_DOS_FILENAME);

        wszCompatLayer[0] = UNICODE_NULL;
        AHInfo.tiExe      = 0;

        fReturn = ApphelpGetNTVDMInfo(pwszAppFilePath,
                                      szFileNameW,
                                      pwszTempEnv,
                                      wszCompatLayer,
                                      &NtVdmFlags,
                                      &AHInfo,
                                      &hSdb,
                                      &SdbQuery);

        if(fReturn) {

            *dwFlags = NtVdmFlags.dwWOWCompatFlags2;

            // find out how many compat flags are set for this app
            numFlags = 0;
            dwMask = 0x80000000;
            while(dwMask) {
                if(dwMask & *dwFlags) {
                    numFlags++;
                }
                dwMask = dwMask >> 1;
            }

            if(numFlags) {
 
                // Alloc maximum number of CMDLNPARMS structs we *might* need.
                pCLP = (PCMDLNPARMS)VMALLOC(numFlags * sizeof(CMDLNPARMS)); 

                if(pCLP) {

                    // Get all the command line params associated with all the
                    // app compat flags associated with this app.
                    numFlags = 0;
                    dwMask = 0x80000000;
                    while(dwMask) {

                        if(dwMask & *dwFlags) {

                            // Get command line params associated with this flag
                            pFIB = GetFlagCommandLine(NtVdmFlags.pFlagsInfo,
                                                      dwMask,
                                                      *dwFlags);

                            // If there are any, save them. 
                            if(pFIB) {
                                pCLP[numFlags].argc = pFIB->dwFlagArgc;
                                pCLP[numFlags].argv = pFIB->pFlagArgv;
                                pCLP[numFlags].dwFlag = dwMask;

                                VFREE(pFIB);

                                numFlags++;
                            }
                        }
                        dwMask = dwMask >> 1;
                    }

                    // Now alloc *actual* number of CMDLNPARMS structs we need.
                    if(numFlags > 0) {
                        pCmdLnParms = 
                             (PCMDLNPARMS)VMALLOC(numFlags * sizeof(CMDLNPARMS));

                        if(pCmdLnParms) {

                            // Save everything we found in one neat package.
                            RtlCopyMemory(pCmdLnParms, 
                                          pCLP, 
                                          numFlags * sizeof(CMDLNPARMS));

                            *pNumCLP = numFlags;
                        } 
                    }

                    VFREE(pCLP);
                }
            }

            // If we need Dynamic Patch Module support for this app...
            if((*dwFlags & WOWCF2_DPM_PATCHES) && (*pNumCLP > 0)) {
        
                for(i = 0; i < *pNumCLP; i++) {

                    if(pCmdLnParms[i].dwFlag == WOWCF2_DPM_PATCHES) {
        
                        InitTaskDpmSupport(NUM_VDM_FAMILIES_HOOKED,
                                           DPMFAMTBLS(),
                                           &pCmdLnParms[i],
                                           hSdb,
                                           &SdbQuery,
                                           pwszAppFilePath,
                                           pwszAppModuleName,
                                           pwszTempEnv);
                        break;
                    }
                }
            }

            FreeEnvironmentStringsW(pwszTempEnv);

            if (hSdb != NULL) {
                SdbReleaseDatabase(hSdb);
            }

            SdbFreeFlagInfo(NtVdmFlags.pFlagsInfo);
        }
    }

    return(pCmdLnParms);
}





// Retrieves the SDB command line associated with dwFlag.  The command line is
// parsed into argv, argc form based on ';' delimiters.
PFLAGINFOBITS GetFlagCommandLine(PVOID pFlagInfo, DWORD dwFlag, DWORD dwFlags) 
{
    UNICODE_STRING uCmdLine = { 0 };
    OEM_STRING     oemCmdLine  = { 0 };
    LPWSTR         lpwCmdLine = NULL;
    LPSTR          pszTmp;
    PFLAGINFOBITS  pFlagInfoBits = NULL;
    LPSTR          pszCmdLine = NULL;
    LPSTR         *pFlagArgv = NULL;
    DWORD          dwFlagArgc;


    if(pFlagInfo == NULL || 0 == dwFlags) {
        return NULL;
    }

    if(dwFlags & dwFlag) {

        GET_WOWCOMPATFLAGS2_CMDLINE(pFlagInfo, dwFlag, &lpwCmdLine);

        // Convert to oem string
        if(lpwCmdLine) {

            RtlInitUnicodeString(&uCmdLine, lpwCmdLine);

            pszCmdLine = VMALLOC(uCmdLine.Length + 1);

            if(NULL == pszCmdLine) {
                goto GFIerror;
            }

            oemCmdLine.Buffer = pszCmdLine;
            oemCmdLine.MaximumLength = uCmdLine.Length + 1;
            oemCmdLine.Length = uCmdLine.Length/sizeof(WCHAR);
            RtlUnicodeStringToOemString(&oemCmdLine, &uCmdLine, FALSE);

            pFlagInfoBits = VMALLOC(sizeof(FLAGINFOBITS));
            if(NULL == pFlagInfoBits) {
                goto GFIerror;
            }
            pFlagInfoBits->pNextFlagInfoBits = NULL;
            pFlagInfoBits->dwFlag     = dwFlag;
            pFlagInfoBits->dwFlagType = WOWCOMPATFLAGS2;
            pFlagInfoBits->pszCmdLine = pszCmdLine;

            // Parse commandline to argv, argc format
            dwFlagArgc = 1;
            pszTmp = pszCmdLine;
            while(*pszTmp) {
                if(*pszTmp == ';') {
                    dwFlagArgc++;
                }
                pszTmp++;
            }

            pFlagInfoBits->dwFlagArgc = dwFlagArgc;
            pFlagArgv = VMALLOC(sizeof(LPSTR) * dwFlagArgc);

            if(NULL == pFlagArgv) {
                goto GFIerror;
            }

            pFlagInfoBits->pFlagArgv = pFlagArgv;
            pszTmp = pszCmdLine;
            while(*pszTmp) {
                if(*pszTmp == ';'){
                    if(pszCmdLine != pszTmp) {
                        *pFlagArgv++ = pszCmdLine;
                    }
                    else {
                        *pFlagArgv++ = NULL;
                    }
                    *pszTmp = '\0';
                    pszCmdLine = pszTmp+1;
                }
                pszTmp++;
            }
            *pFlagArgv = pszCmdLine;
        }
    }

    return pFlagInfoBits;

GFIerror:
    if(pszCmdLine) {
        VFREE(pszCmdLine);
    }
    if(pFlagInfoBits) {
        VFREE(pFlagInfoBits);
    }
    if(pFlagArgv) {
        VFREE(pFlagArgv);
    }
    return NULL;
}





VOID FreeCmdLnParmStructs(PCMDLNPARMS pCmdLnParms, int cCmdLnParmStructs)
{
    int i;


    if(pCmdLnParms) {
        for(i = 0; i < cCmdLnParmStructs; i++) {

            if(pCmdLnParms[i].argv) {

                if(pCmdLnParms[i].argv[0]) {

                    // Free the command line string
                    VFREE(pCmdLnParms[i].argv[0]);
                }

                // now free the argv array
                VFREE(pCmdLnParms[i].argv);
            }
        }

        // now free the entire command line parameters array
        VFREE(pCmdLnParms);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\v86\monitor\i386\proflib.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   proflib.c

Abstract:

    This module contains the implementation of a rudimentry user-mode
    profiler.

Usage:

    There are 4 routines, RtlInitializeProfile, RtlStartProfile,
    RtlStopProfile, and RtlAnalyzeProfile.  To initialize profiling
    invoke RtlInitializeProfile, this routine is only called once and
    goes through the address space looking for code regions of images
    and DLLs.  To start profiling call RtlStartProfile.  To stop
    profiling call RtlStopProfile.  Note that RtlStartProfile and
    RtlStopProfile can be called repeatedly to profile only key
    "hot spots", For example:
                RtlStartProfile ();
                hot spot...
                RtlStopProfile ();
                ....
                RtlStartProfile ();
                hot spot...
                RtlStopProfile ();

    To analyze the results call RtlAnalyzeProfile.  This too can
    be called repeatedly (it stops profiling during the analysis
    phase and does NOT restart profiling).  It also does not
    zero out the values after reporting.

Author:

    Lou Perazzoli (loup) 4-Oct-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
#include <stdio.h>
#include "..\..\..\..\private\ntos\dll\ldrp.h"

NTSTATUS
InitializeKernelProfile ( VOID );

#define PAGE_SIZE 4096

typedef struct _PROFILE_BLOCK {
    HANDLE Handle;
    PVOID ImageBase;  //actual base in image header
    PULONG CodeStart;
    ULONG CodeLength;
    PULONG Buffer;
    ULONG BufferSize;
    ULONG TextNumber;
    ULONG BucketSize;
    PVOID MappedImageBase;  //actual base where mapped locally.
    PSZ ImageName;
} PROFILE_BLOCK;


#define MAX_PROFILE_COUNT 50

PROFILE_BLOCK ProfileObject[MAX_PROFILE_COUNT];

ULONG NumberOfProfileObjects = 0;
PIMAGE_DEBUG_INFO KernelDebugInfo;

//
// Image name to perform kernel mode analysis upon.
//

#define IMAGE_NAME "\\SystemRoot\\ntoskrnl.exe"

//
// Define map data file if the produced data file should be
// a mapped file (currently named "kernprof.dat").
//

// #define MAP_DATA_FILE

//
// Define map as image if the image to be profiled should be mapped
// as an image rather than as data.
//

// #define MAP_AS_IMAGE

#define MAX_PROFILE_COUNT 50

extern ULONG ProfInt;

NTSTATUS
RtlInitializeProfile (
    IN BOOLEAN KernelToo
    )

/*++

Routine Description:

    This routine initializes profiling for the current process.

Arguments:

    KernelToo - Set to TRUE if kernel code should be profiled as
                well as user code.

Return Value:

    Returns the status of the last NtCreateProfile.

--*/

{

    NTSTATUS status, LocalStatus;
    HANDLE CurrentProcessHandle;
    ULONG BufferSize;
    PVOID ImageBase;
    ULONG CodeLength;
    PULONG Buffer;
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PSZ ImageName;
    PLIST_ENTRY Next;
    ULONG ExportSize, DebugSize;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    PIMAGE_DEBUG_INFO DebugInfo;
    BOOLEAN PreviousPrivState;

    //
    // Locate all the executables in the address and create a
    // seperate profile object for each one.
    //

    CurrentProcessHandle = NtCurrentProcess();

    Peb = NtCurrentPeb();

    Next = Peb->Ldr->InMemoryOrderModuleList.Flink;
    while ( Next != &Peb->Ldr->InMemoryOrderModuleList) {
        LdrDataTableEntry
            = (PLDR_DATA_TABLE_ENTRY) (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InMemoryOrderLinks));

        ImageBase = LdrDataTableEntry->DllBase;
        if ( Peb->ImageBaseAddress == ImageBase ) {
            ImageName = "TheApplication";
        } else {
            ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                               ImageBase,
                               TRUE,
                               IMAGE_DIRECTORY_ENTRY_EXPORT,
                               &ExportSize);

            ImageName =  (PSZ)((ULONG)ImageBase + ExportDirectory->Name);
        }
        if (NumberOfProfileObjects > MAX_PROFILE_COUNT) {
            break;
        }

        ProfileObject[NumberOfProfileObjects].ImageBase = ImageBase;
        ProfileObject[NumberOfProfileObjects].ImageName = ImageName;
        ProfileObject[NumberOfProfileObjects].MappedImageBase = ImageBase;

        //
        // Locate the code range and start profiling.
        //

        DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)RtlImageDirectoryEntryToData(
                    ImageBase, TRUE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);

        if (!DebugDirectory) {
            DbgPrint ("RtlInitializeProfile : No debug directory\n");
            return STATUS_INVALID_IMAGE_FORMAT;
        }

        DebugInfo = (PIMAGE_DEBUG_INFO)((ULONG)ImageBase + DebugDirectory->AddressOfRawData);

        ProfileObject[NumberOfProfileObjects].CodeStart = (PULONG)((ULONG)ImageBase + DebugInfo->RvaToFirstByteOfCode);
        CodeLength = (DebugInfo->RvaToLastByteOfCode - DebugInfo->RvaToFirstByteOfCode) - 1;
        ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;

        ProfileObject[NumberOfProfileObjects].TextNumber = 1;

        //
        // Analyze the size of the code and create a reasonably sized
        // profile object.
        //

        BufferSize = (CodeLength >> 1) + 4;
        Buffer = NULL;

        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&Buffer,
                                          0,
                                          &BufferSize,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint ("alloc VM failed %lx\n",status);
            return status;
        }


        status = RtlAdjustPrivilege(
                     SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                     TRUE,              //Enable
                     FALSE,             //not impersonating
                     &PreviousPrivState //Remember if it will need to be cleared
                     );

        if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
            DbgPrint("Enable system profile privilege failed - status 0x%lx\n",
                     status);
        }


        ProfileObject[NumberOfProfileObjects].Buffer = Buffer;
        ProfileObject[NumberOfProfileObjects].BufferSize = BufferSize;
        ProfileObject[NumberOfProfileObjects].BucketSize = 3;

        status = NtCreateProfile (
                    &ProfileObject[NumberOfProfileObjects].Handle,
                    CurrentProcessHandle,
                    ProfileObject[NumberOfProfileObjects].CodeStart,
                    CodeLength,
                    ProfileObject[NumberOfProfileObjects].BucketSize,
                    ProfileObject[NumberOfProfileObjects].Buffer ,
                    ProfileObject[NumberOfProfileObjects].BufferSize,
                    ProfileTime,
                    (KAFFINITY)-1);

        if (PreviousPrivState == FALSE) {
            LocalStatus = RtlAdjustPrivilege(
                             SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                             FALSE,             //Disable
                             FALSE,             //not impersonating
                             &PreviousPrivState //Don't care if it was already enabled
                             );
            if (!NT_SUCCESS(LocalStatus) || LocalStatus == STATUS_NOT_ALL_ASSIGNED) {
                DbgPrint("Disable system profile privilege failed - status 0x%lx\n",
                         LocalStatus);
            }
        }

        if (status != STATUS_SUCCESS) {
            DbgPrint("create profile %x failed - status %lx\n",
                   ProfileObject[NumberOfProfileObjects].ImageName,status);
            return status;
        }

        NumberOfProfileObjects += 1;

        Next = Next->Flink;
    }

    if (KernelToo) {

        if (NumberOfProfileObjects > MAX_PROFILE_COUNT) {
            return status;
        }
        status = InitializeKernelProfile();
    }
    return status;

}
NTSTATUS
InitializeKernelProfile (
    VOID
    )

/*++

Routine Description:

    This routine initializes profiling for the kernel for the
    current process.

Arguments:

    None.

Return Value:

    Returns the status of the last NtCreateProfile.

--*/

{

    //BUGBUG daveh I think that the new working set size calculation is
    //             generating the number of pages, when the api expects
    //             the number of bytes.

    STRING Name3;
    IO_STATUS_BLOCK IoStatus;
    HANDLE FileHandle, KernelSection;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID ImageBase;
    ULONG ViewSize;
    ULONG CodeLength;
    NTSTATUS status, LocalStatus;
    HANDLE CurrentProcessHandle;
    QUOTA_LIMITS QuotaLimits;
    PVOID Buffer;
    ULONG Cells;
    ULONG BucketSize;
    UNICODE_STRING Unicode;
    ULONG DebugSize;
    PVOID KernelBase;
    PIMAGE_NT_HEADERS KernelNtHeaders;
    PIMAGE_DEBUG_DIRECTORY DebugDirectory;
    BOOLEAN PreviousPrivState;

    RtlInitString (&Name3, IMAGE_NAME);
    CurrentProcessHandle = NtCurrentProcess();

    status = RtlAnsiStringToUnicodeString(&Unicode,(PANSI_STRING)&Name3,TRUE);
    ASSERT(NT_SUCCESS(status));
    InitializeObjectAttributes( &ObjectAttributes,
                                &Unicode,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //
    // Open the file as readable and executable.
    //

    status = NtOpenFile ( &FileHandle,
                          FILE_READ_DATA | FILE_EXECUTE,
                          &ObjectAttributes,
                          &IoStatus,
                          FILE_SHARE_READ,
                          0L);
    RtlFreeUnicodeString(&Unicode);

    if (!NT_SUCCESS(status)) {
        DbgPrint("open file failed status %lx\n", status);
        NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    }

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

    //
    // For normal images they would be mapped as an image, but
    // the kernel has no debug section (as yet) information, hence it
    // must be mapped as a file.
    //

    status = NtCreateSection (&KernelSection,
                              SECTION_MAP_EXECUTE,
                              &ObjectAttributes,
                              0,
                              PAGE_READONLY,
                              SEC_IMAGE,
                              FileHandle);

    if (!NT_SUCCESS(status)) {
        DbgPrint("create image section failed  status %lx\n", status);
        return(status);
    }

    ViewSize = 0;

    //
    // Map a view of the section into the address space.
    //

    KernelBase = NULL;

    status = NtMapViewOfSection (KernelSection,
                                 CurrentProcessHandle,
                                 (PVOID *)&KernelBase,
                                 0L,
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_EXECUTE);

    if (!NT_SUCCESS(status)) {
        if (status != STATUS_IMAGE_NOT_AT_BASE) {
            DbgPrint("map section status %lx base %lx size %lx\n", status,
                KernelBase, ViewSize);
        }
    }

    KernelNtHeaders = (PIMAGE_NT_HEADERS)RtlImageNtHeader(KernelBase);

    ImageBase = (PVOID)KernelNtHeaders->OptionalHeader.ImageBase;

    DebugDirectory = (PIMAGE_DEBUG_DIRECTORY)RtlImageDirectoryEntryToData(
                KernelBase, TRUE, IMAGE_DIRECTORY_ENTRY_DEBUG, &DebugSize);

    if (!DebugDirectory) {
        DbgPrint("InitializeKernelProfile : No debug directory\n");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    KernelDebugInfo = (PIMAGE_DEBUG_INFO)((ULONG)KernelBase + DebugDirectory->AddressOfRawData);
    CodeLength = (KernelDebugInfo->RvaToLastByteOfCode - KernelDebugInfo->RvaToFirstByteOfCode) -1;

    //
    // Just create a 512K byte buffer.
    //

    ViewSize = 1024 * 512;
    Buffer = NULL;

    status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&Buffer,
                                      0,
                                      &ViewSize,
                                      MEM_RESERVE | MEM_COMMIT,
                                      PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint ("alloc VM failed %lx\n",status);
        NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    }

    //
    // Calculate the bucket size for the profile.
    //

    Cells = ((CodeLength / (ViewSize >> 2)) >> 2);
    BucketSize = 2;

    while (Cells != 0) {
        Cells = Cells >> 1;
        BucketSize += 1;
    }

    ProfileObject[NumberOfProfileObjects].Buffer = Buffer;
    ProfileObject[NumberOfProfileObjects].MappedImageBase = KernelBase;
    ProfileObject[NumberOfProfileObjects].BufferSize = 1 + (CodeLength >> (BucketSize - 2));
    ProfileObject[NumberOfProfileObjects].CodeStart = (PULONG)((ULONG)ImageBase + KernelDebugInfo->RvaToFirstByteOfCode);
    ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;
    ProfileObject[NumberOfProfileObjects].TextNumber = 1;
    ProfileObject[NumberOfProfileObjects].ImageBase = ImageBase;
    ProfileObject[NumberOfProfileObjects].ImageName = "ntoskrnl";
    ProfileObject[NumberOfProfileObjects].BucketSize = BucketSize;


    //
    // Increase the working set to lock down a bigger buffer.
    //

    status = NtQueryInformationProcess (CurrentProcessHandle,
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof(QUOTA_LIMITS),
                                        NULL );

    if (!NT_SUCCESS(status)) {
        DbgPrint ("query process info failed %lx\n",status);
        NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    }

    QuotaLimits.MaximumWorkingSetSize += ViewSize / PAGE_SIZE;
    QuotaLimits.MinimumWorkingSetSize += ViewSize / PAGE_SIZE;

    status = NtSetInformationProcess (CurrentProcessHandle,
                                  ProcessQuotaLimits,
                                  &QuotaLimits,
                                  sizeof(QUOTA_LIMITS));
    if (!NT_SUCCESS(status)) {
        DbgPrint ("setting working set failed %lx\n",status);
        return status;
    }

    status = RtlAdjustPrivilege(
                 SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                 TRUE,              //Enable
                 FALSE,             //not impersonating
                 &PreviousPrivState //Remember if it will need to be cleared
                 );

    if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
        DbgPrint("Enable process profile privilege failed - status 0x%lx\n",
                 status);
    }

    status = NtCreateProfile (
                &ProfileObject[NumberOfProfileObjects].Handle,
                CurrentProcessHandle,
                ProfileObject[NumberOfProfileObjects].CodeStart,
                CodeLength,
                ProfileObject[NumberOfProfileObjects].BucketSize,
                ProfileObject[NumberOfProfileObjects].Buffer ,
                ProfileObject[NumberOfProfileObjects].BufferSize,
                ProfileTime,
                (KAFFINITY)-1);

    if (PreviousPrivState == FALSE) {
        LocalStatus = RtlAdjustPrivilege(
                         SE_PROF_SINGLE_PROCESS_PRIVILEGE,
                         FALSE,             //Disable
                         FALSE,             //not impersonating
                         &PreviousPrivState //Don't care if it was already enabled
                         );
        if (!NT_SUCCESS(LocalStatus) || LocalStatus == STATUS_NOT_ALL_ASSIGNED) {
            DbgPrint("Disable system profile privilege failed - status 0x%lx\n",
                     LocalStatus);
        }
    }

    if (status != STATUS_SUCCESS) {
        DbgPrint("create kernel profile %s failed - status %lx\n",
                   ProfileObject[NumberOfProfileObjects].ImageName,status);
    }

    NumberOfProfileObjects += 1;

    return status;
}


VOID
RtlpWriteProfileLine(
    IN HANDLE ProfileHandle,
    IN PSZ Line,
    IN int nbytes
    )
{
    IO_STATUS_BLOCK IoStatusBlock;

    NtWriteFile(
        ProfileHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        Line,
        (ULONG)nbytes,
        NULL,
        NULL
        );

}


HANDLE
RtlpOpenProfileOutputFile()
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            L"\\profile.out",
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        return NULL;
        }
    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    Status = NtCreateFile(
                &Handle,
                FILE_APPEND_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0L
                );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        return NULL;
        }

    return Handle;
}

VOID
RtlpDeleteProfileOutputFile()
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            L"\\profile.out",
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        return;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file for delete access
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)DELETE | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    //
    // Delete the file
    //
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &Disposition,
                sizeof(Disposition),
                FileDispositionInformation
                );

    NtClose(Handle);
}




NTSTATUS
RtlStartProfile (
    VOID
    )
/*++

Routine Description:

    This routine starts all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStartProfile.

--*/

{
    ULONG i;
    NTSTATUS status;
    QUOTA_LIMITS QuotaLimits;

    NtSetIntervalProfile(ProfInt,ProfileTime);
    RtlpDeleteProfileOutputFile();

    for (i = 0; i < NumberOfProfileObjects; i++) {

        status = NtStartProfile (ProfileObject[i].Handle);

        if (status == STATUS_WORKING_SET_QUOTA) {

           //
           // Increase the working set to lock down a bigger buffer.
           //

           status = NtQueryInformationProcess (NtCurrentProcess(),
                                               ProcessQuotaLimits,
                                               &QuotaLimits,
                                               sizeof(QUOTA_LIMITS),
                                               NULL );

           if (!NT_SUCCESS(status)) {
               DbgPrint ("query process info failed %lx\n",status);
               return status;

           }

           QuotaLimits.MaximumWorkingSetSize +=
                 10 * PAGE_SIZE + ProfileObject[i].BufferSize;
           QuotaLimits.MinimumWorkingSetSize +=
                 10 * PAGE_SIZE + ProfileObject[i].BufferSize;

           status = NtSetInformationProcess (NtCurrentProcess(),
                                         ProcessQuotaLimits,
                                         &QuotaLimits,
                                         sizeof(QUOTA_LIMITS));
           if (!NT_SUCCESS(status)) {
               DbgPrint ("setting working set failed %lx\n",status);
               return status;
           }
           status = NtStartProfile (ProfileObject[i].Handle);
        }

        if (status != STATUS_SUCCESS) {
            DbgPrint("start profile %s failed - status %lx\n",
                ProfileObject[i].ImageName, status);
            return status;
        }
    }
    return status;
}
NTSTATUS
RtlStopProfile (
    VOID
    )

/*++

Routine Description:

    This routine stops all profile objects which have been initialized.

Arguments:

    None.

Return Value:

    Returns the status of the last NtStopProfile.

--*/

{
    ULONG i;
    NTSTATUS status;

    for (i = 0; i < NumberOfProfileObjects; i++) {
        status = NtStopProfile (ProfileObject[i].Handle);
        if (status != STATUS_SUCCESS) {
            DbgPrint("stop profile %s failed - status %lx\n",
                   ProfileObject[i].ImageName,status);
            return status;
        }
    }
    return status;
}

NTSTATUS
RtlAnalyzeProfile (
    VOID
    )

/*++

Routine Description:

    This routine does the analysis of all the profile buffers and
    correlates hits to the appropriate symbol table.

Arguments:

    None.

Return Value:

    None.

--*/

{


    RTL_SYMBOL_INFORMATION ThisSymbol;
    RTL_SYMBOL_INFORMATION LastSymbol;
    ULONG CountAtSymbol;
    NTSTATUS Status;
    ULONG Va;
    HANDLE ProfileHandle;
    CHAR Line[512];
    int i,n;
    PULONG Buffer, BufferEnd, Counter;


    ProfileHandle = RtlpOpenProfileOutputFile();
    ASSERT(ProfileHandle);

    for (i = 0; i < NumberOfProfileObjects; i++) {
        Status = NtStopProfile (ProfileObject[i].Handle);
        }


    //
    // The new profiler
    //

    for (i = 0; i < NumberOfProfileObjects; i++)  {

        LastSymbol.Value = 0;
        CountAtSymbol = 0;

        //
        // Sum the total number of cells written.
        //

        BufferEnd = ProfileObject[i].Buffer + (
                    ProfileObject[i].BufferSize / sizeof(ULONG));
        Buffer = ProfileObject[i].Buffer;

        for ( Counter = Buffer; Counter < BufferEnd; Counter += 1 ) {
            if ( *Counter ) {

                //
                // Now we have an an address relative to the buffer
                // base.
                //

                Va = (ULONG)((PUCHAR)Counter - (PUCHAR)Buffer);
                Va = Va * ( 1 << (ProfileObject[i].BucketSize - 2));

                //
                // Add in the image base and the base of the
                // code to get the Va in the image
                //

                Va = Va + (ULONG)ProfileObject[i].CodeStart;

                Status = RtlLookupSymbolByAddress(
                            ProfileObject[i].ImageBase,
                            NULL,
                            (PVOID)Va,
                            0x4000,
                            &ThisSymbol,
                            NULL
                            );
                if ( NT_SUCCESS(Status) ) {
                    if ( LastSymbol.Value && LastSymbol.Value == ThisSymbol.Value ) {
                        CountAtSymbol += *Counter;
                    }
                    else {
                        if ( LastSymbol.Value ) {
                            if ( CountAtSymbol ) {
                                n= sprintf(Line,"%d,%s,%S\n",
                                    CountAtSymbol,
                                    ProfileObject[i].ImageName,
                                    &LastSymbol.Name
                                    );
                                RtlpWriteProfileLine(ProfileHandle,Line,n);
                            }
                        }
                        CountAtSymbol = *Counter;
                        LastSymbol = ThisSymbol;
                    }
                }
            }
        }
        if ( CountAtSymbol ) {
            n= sprintf(Line,"%d,%s,%S\n",
                CountAtSymbol,
                ProfileObject[i].ImageName,
                &LastSymbol.Name
                );
            RtlpWriteProfileLine(ProfileHandle,Line,n);
        }
    }

    for (i = 0; i < NumberOfProfileObjects; i++) {
        Buffer = ProfileObject[i].Buffer;
        RtlZeroMemory(Buffer,ProfileObject[i].BufferSize);
    }
    NtClose(ProfileHandle);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\mscdex\tsr\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\mscdex\tsr\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\hpscan\hpscan16.asm ===
.MODEL small
;*************************************************
; Filename:	hpscan16.asm
; Purpose:  Stub DOS Device Driver. Pass device 
;   "HPSCAN" requests to the VDD, hpscan32.dll.
; Environment: MSDOS, Windows NT.
; (C) Hewlett-Packard Company 1993.
;*************************************************
INCLUDE hpscan16.inc     ;private
INCLUDE isvbop.inc       ;NT DDK

SUBTTL Segment and data definitions
      ASSUME   CS:CSEG,DS:NOTHING,ES:NOTHING
CSEG  SEGMENT

;-------------------------------------------------
; Resident data area - variables needed after init
;-------------------------------------------------

;**--- Device Header, must be at offset zero ---**
SCAN_HEADER:
        dd -1         ;becomes ptr to next req hdr
        dw 0C000H     ;character, supports IOCTL
        dw offset STRAT     ;Strategy routine
        dw offset IDVR      ;Interrupt routine
DH_NAME db 'HPSCAN  '       ;char device name

;**---- Request Header addr, saved by STRAT ----**
RH_PTRA LABEL  DWORD
RH_PTRO        dw  ?   ;offset
RH_PTRS        dw  ?   ;segment

;**------------- Define Stack Space ------------**
STK_SEG  dw  ?        ;Save original stack segment
STK_PTR  dw  ?        ;Save original stack pointer
STACK    dw  200 DUP (0)     ;Local stack
TOP_STK  dw  ?        ;Top of local stack

;**--------------- VDD information -------------**
VDD_DllName      db  "HPSCAN32.DLL", 0
VDD_InitFunc     db  "VDDInit", 0
VDD_DispFunc     db  "VDDDispatch", 0
VDD_hVDD         dw  ?

;**-------------- Copyright Info ---------------**
  db '(C) Copyright Hewlett-Packard Company 1993.'
  db 'All rights reserved.'

SUBTTL Device Strategy & Interrupt entry points

;**--------------- STRAT routine ---------------**
STRAT  proc  far           ;Strategy routine
    mov  cs:RH_PTRO,bx     ;save offset address
    mov  cs:RH_PTRS,es     ;save segment address
    ret                    ;end Strategy routine
STRAT  endp

;**--------------- IDVR routine ---------------**
IDVR  proc  far     ;Interrupt routine
    push  ds        ;save all modified registers
    push  es        ;DOS has stack for 20 pushes
    push  ax
    push  bx
    push  cx
    push  dx
    push  di
    push  si
    push  bp

    mov  cs:STK_PTR,sp   ;save original stack ptr
    mov  cs:STK_SEG,ss   ;save original stack seg
    cli                  ;disable for stack ops
    mov  ax,cs           ;setup new stack ptr
    mov  ss,ax           ;setup new stack seg
    mov  sp,offset TOP_STK
    sti                  ;restore flags back
    cld                  ;all moves are forward

    les  bx,cs:RH_PTRA  ;load req hdr adr in es:bx
    mov  al,RH.RHC_CMD
    cmp  al,0           ;check for init command
    je   BOOTUP         ;command 0 = init

    xor  dx,dx          ;some other command
    mov  dl,RH.RHC_CMD  ;dx = command code
    mov  cx,RH.RHC_CNT  ;cx = count
    mov  ax,RH.RHC_SEG  ;es:bx = addr of data
    mov  bx,RH.RHC_OFF
    mov  es,ax          ;finally, load VDD handle
    mov  ax,word ptr cs:[VDD_hVDD]
    DispatchCall        ;call Dispatch in VDD
                        ;returns with status in di
EXIT:
    les  bx,cs:RH_PTRA  ;restore ES:BX
    or   di,STAT_DONE   ;add "DONE" bit to status
    mov  RH.RHC_STA,di  ;save status in requ hdr
    cli                 ;disable ints for stack op
    mov  ss,cs:STK_SEG  ;restore stack seg
    mov  sp,cs:STK_PTR  ;restore stack ptr  
    sti                 ;re-enable interrupts

    pop  bp             ;restore registers
    pop  si
    pop  di
    pop  dx
    pop  cx
    pop  bx
    pop  ax
    pop  es
    pop  ds
    ret                 ;far return
IDVR endp

;**--------- jump here for Init Command --------**
BOOTUP:
    mov  ax,offset EndDriver
    mov  RH.RHC_OFF,ax  ;address of end of driver
    mov  RH.RHC_SEG,CS  ;reference from code seg

    mov  si,offset VDD_DllName  ;load regs for VDD
    mov  di,offset VDD_InitFunc
    mov  bx,offset VDD_DispFunc
    mov  ax,ds
    mov  es,ax
    RegisterModule      ;calls the VDD
    jnc  save_hVDD      ;if NC then success
    mov  di,STAT_GF     ;set failure status
    jmp  EXIT           ;return via common exit

save_hVDD:
    mov  [VDD_hVDD],ax  ;save handle in ax
    mov  di,STAT_OK     ;load OK status
    jmp  EXIT           ;return via common exit

EndDriver db ?
CSEG    ENDS
        END  SCAN_HEADER ;REQUIRED BY EXE2BIN

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\hpscan\hpscan16.inc ===
;*************************************************
; Name:	       HPSCAN16.INC
; Description: Defines for HPSCAN16.ASM
;*************************************************

;**----------- Segment Declarations ------------**
CSEG	segment word public 'CODE'
CSEG	ends	;header segment

;**-------------- Status Values ----------------**
STAT_OK      equ  0000h     ;ok
STAT_DONE    equ  0100h     ;function complete
STAT_GF      equ  800Ch     ;general failure

RH  EQU  ES:[BX]  ;request header

;**------ Common Request Header Structure ------**
RHC     struc     ;common to all commands
        db  ?     ;length of request header
        db  ?     ;unit code of device
RHC_CMD db  ?     ;command code
RHC_STA dw  ?     ;completion status, 16-bits
        dq  ?     ;reserved for DOS
        db  ?     ;this field varies with command
RHC_OFF dw  ?     ;offset of data
RHC_SEG dw  ?     ;segment of data
RHC_CNT dw  ?     ;byte count (length) of data
RHC     ends      ;end of common portion

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\mscdex\tsr\mscdexnt.inc ===
;----------------------------- E Q U A T E S ----------------------------
DOS_SET_VECTOR  equ     25h
DOS_GET_VECTOR  equ     35h
DOS_TSR         equ     31h

MPX_INT         equ     2fh
MSCDEX_ID       equ     15h
MAX_MSCDEX_CMD  equ     10h

GET_NT_VERSION      equ     3306h
NT_MAJOR_VERSION    equ     05
NT_MINOR_VERSION    equ     50

CR                  equ     0dh
LF                  equ     0Ah

;----------------------------- M A C R O S ------------------------------
DrvHd   MACRO   name
        DD      -1
        DW      0c840h
        DW      0
        DW      0
        DB      name
        dw      0
        db      0
        db      1
        db      10 dup (0)
        ENDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\mscdex\tsr\messages\usa\messages.inc ===
Message1    db  CR,LF,'MSCDEXNT Will Run Only Under Windows NT.',CR,LF,'$'
Message2    db  CR,LF,'MSCDEXNT is already installed.',CR,LF,'$'
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\mscdex\tsr\mscdexnt.asm ===
name    mscdexnt
;
;       MSCDEXNT
;
;   Author: Neil Sandlin (neilsa)
;
;   Description:
;
;       This TSR implements the v86 mode portion of MSCDEX support under
;       NT. Basically, all this piece does is hook INT2F and watch for
;       MSCDEX calls.
;
        include bop.inc
        include mscdexnt.inc

_TEXT   segment word public 'CODE'
        assume cs:_TEXT,ds:_TEXT,es:_TEXT

;*-----------------------  TSR Code --------------------------*

DrvStrat proc   far              ; Strategy Routine
        ret
DrvStrat endp

DrvIntr proc    far                     ; INterrupt routine
        ret
DrvIntr endp

;******************************************************************************
;
;       Int2FHook
;
;
;******************************************************************************
Int2FHook  proc    near

        cmp     ah, MSCDEX_ID               ;MSCDEX?
        jnz     int2fchain                  ;no
        cmp     al, MAX_MSCDEX_CMD          ;command too high?
        ja      int2fchain                  ;yes

        ;
        ; fVDDCheck is 0 if failed, 1 if ok
        ;
        cmp     byte ptr cs:[fVDDChecked], 0
        je      vddfailed

        BOP     BOP_DEVICES
        db      SVC_DEVICES_MSCDEX
        iret                                ;svc handled, return to caller

vddfailed:
        or      al,al
        jnz     try_0b
        xor     bx,bx
        jmp     short int2f_done
try_0b:
        cmp     al,0bh
        jne     int2f_done
;; williamh - June 1 1993 - if unable to load VDD, we should tell
;;                          the caller that the drive is NOT a cd rom.
        xor     ax, ax
        mov     bx,0adadh
int2f_done:
        iret

int2fchain:
        jmp     dword ptr cs:[oldint]

Int2FHook  endp

;*-----------------------  TSR Data Area ---------------------*
oldint  dd      0

fVDDChecked DB  0       ; 0 - failed, 1 - working

        ALIGN   16
drive_header:
        DrvHd   'MSCDEX00'

        ALIGN   16
Init_Fence:
;*-------------------------- Initialization Code ----------------------*

mscdexnt proc    far

        ; at this point es,ds -> PSP
        ; SS:SP points to stack

        ; first check that we are running under NT

        mov     ax, GET_NT_VERSION
        int     21h
        cmp     bl, NT_MAJOR_VERSION
        je      cdx_chk_more
        jmp     cdx_exit

cdx_chk_more:
        cmp     bh, NT_MINOR_VERSION
        je      cdx_ver_ok
        jmp     cdx_exit

cdx_ver_ok:
        ; Now check that this TSR is'nt already installed
        mov     ah,MSCDEX_ID
        mov     al,0bh                  ; call function 0b
        int     MPX_INT                 ; int 2f

        cmp     bx,0adadh
        jne     cdx_chks_done
        jmp     cdx_exit

cdx_chks_done:

        ; free the env segment

        push    es
        push    ds
        mov     es, es:[2ch]
        mov     ah, 49h
        int     21h

        mov     ah, DOS_GET_VECTOR
        mov     al, MPX_INT             ; 2f
        int     21h                     ; get old vector
        mov     WORD PTR cs:oldint,bx   ; save old vector here
        mov     WORD PTR cs:oldint+2,es

        mov     dx, offset Int2FHook
        push    cs                      ; get current code segment
        pop     ds
        mov     ah, DOS_SET_VECTOR
        mov     al, MPX_INT             ; vector to hook
        int     21h                     ; hook that vector

        mov     dx, offset drive_header ; pass far pointer to headers cs:dx
        BOP     BOP_DEVICES
        db      SVC_DEVICES_MSCDEXINIT
        cmc
        adc     fVDDChecked, 0
;
; Compute size of TSR area
;
        pop     ds
        pop     es
        mov     dx, offset Init_Fence   ; end of fixed TSR code
        mov     cl, 4                   ; divide by 16
        shr     dx, cl
        add     dx, 16                  ; add in PSP
;
; Terminate and stay resident
;
        mov     ah, DOS_TSR             ; TSR
        mov     al, 0
        int     21h                     ; TSR

cdx_exit:
        mov     ax,4c00h                 ; Exit
        int     21h

mscdexnt endp

_TEXT   ends

InitStack       segment para stack 'STACK'

        dw      256 dup (?)

top_of_stack    equ     $

InitStack       ends

        end     mscdexnt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\adlibvdd\vdd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects


Copyright (c) 1992, 1993  Microsoft Corporation

Module Name:

    vdd.h

Abstract:

    This header file is a grossly cut down version of that which exists
    in the SYNTH driver project. I have only extracted those pieces required
    for the AdLib VDD.

Author:

    Mike Tricker (MikeTri) 27-Jan-93 (after Robin Speed (RobinSp) 20-Oct-92)

Revision History:

--*/

#define STR_ADLIB_DEVICENAME L"\\Device\\adlib.mid"

/*
 *  Stucture for passing synth data
 */

typedef struct {
    unsigned short IoPort;
    unsigned short PortData;
} SYNTH_DATA, *PSYNTH_DATA;


#define AD_MASK                         (0x004)
#define AD_NEW                          (0x105)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\adlibvdd\vdd.c ===
/****************************************************************************
 *
 *   config.c
 *
 *   Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

/*
 *  Definition of interface to kernel driver (synth.sys)
 *
 *     The kernel driver's Dos device name is assumed fixed and known
 *
 *          adlib.mid or adlib.mid0
 *
 *     The kernel driver is opened in read/write mode.
 *
 *     Writing to the driver sends a list of SYNTH_DATA structures
 *     to the driver.  The port number MUST be 0x388 or 0x389.
 *
 *
 *     Reading always reads just 1 byte - the status port.
 */

#include <windows.h>              // The VDD is just a win32 DLL
#include <vddsvc.h>               // Definition of VDD calls
#include "vdd.h"                // Common data with kernel driver
#include <stdio.h>

/*
 *  Debugging
 */

#if DBG

    int VddDebugLevel = 1;


   /***************************************************************************

    Generate debug output in printf type format

    ****************************************************************************/

    void VddDbgOut(LPSTR lpszFormat, ...)
    {
        char buf[256];
        va_list va;

        OutputDebugStringA("Ad Lib VDD: ");

        va_start(va, lpszFormat);
        vsprintf(buf, lpszFormat, va);
        va_end(va);

        OutputDebugStringA(buf);
        OutputDebugStringA("\r\n");
    }

    #define dprintf( _x_ )                          VddDbgOut _x_
    #define dprintf1( _x_ ) if (VddDebugLevel >= 1) VddDbgOut _x_
    #define dprintf2( _x_ ) if (VddDebugLevel >= 2) VddDbgOut _x_
    #define dprintf3( _x_ ) if (VddDebugLevel >= 3) VddDbgOut _x_
    #define dprintf4( _x_ ) if (VddDebugLevel >= 4) VddDbgOut _x_


#else

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif // DBG


/*
 *   Symbolic names for port addresses
 */

 #define ADLIB_DATA_PORT 0x389
 #define ADLIB_REGISTER_SELECT_PORT 0x388
 #define ADLIB_STATUS_PORT 0x388

/*
 *   Batch data to the device - for true Adlib use a size of 2
 */

 #define BATCH_SIZE 40
 int Position = 0;
 SYNTH_DATA PortData[BATCH_SIZE];


/*
 *  Internal Routines
 */

 void MyByteIn(WORD port, BYTE *data);
 void MyByteOut(WORD port, BYTE data);

/*
 *  IO handler table.
 *
 *  There's no point in providing string handlers because the chip
 *  can't respond very quickly (need gaps of at least 23 microseconds
 *  between writes).
 */

 VDD_IO_HANDLERS handlers = {
     MyByteIn,
     NULL,
     NULL,
     NULL,
     MyByteOut,
     NULL,
     NULL,
     NULL};

/*
 *  Note that we rely on the kernel driver to pretend the device is
 *  at address 388 even the driver supports it somewhere else.
 */

 VDD_IO_PORTRANGE ports[] = {
    {
       0x228,
       0x229
    },
    {
       0x388,
       0x389
    }
 };

/*
 *  Globals
 */


 //
 // Track timers.  The basic rule is that if no timer is started then
 // the only way the status register can change is via the reset bit
 // in which case we know what will happen.
 //
 // If a timer interrupts then it's 'stopped'
 //

 BOOL Timer1Started;
 BOOL Timer2Started;
 BYTE Status;

/*
 *  Current device handle
 *
 *  NULL if device is (potentially) free
 *  INVALID_HANDLE_VALUE if device was not obtainable
 */

 HANDLE DeviceHandle;

 HANDLE OpenDevice(PWSTR DeviceName)
 {
     WCHAR DosDeviceName[MAX_PATH];


    /*
     *  Make up a string suitable for opening a Dos device
     */

     wcscpy(DosDeviceName, TEXT("\\\\."));
     wcscat(DosDeviceName, DeviceName +
                           wcslen(TEXT("\\Device")));

    /*
     *  Open the device with GENERIC_READ and GENERIC_WRITE
     *  Also use FILE_SHARE_WRITE so other applications can
     *  set the device volume
     */

     return         CreateFile(DosDeviceName,
                               GENERIC_WRITE | GENERIC_READ,
                               FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL);

 }

/*
 *  Open our device is it can be opened and we haven't tried before
 *
 *  Returns FALSE if device can't be acquired.
 */

 BOOL CheckDeviceAccess(void)
 {

    /*
     *  If we don't have a handle (valid or invalid) already try
     *  opening the device
     */

     if (DeviceHandle == NULL) {

         DeviceHandle = OpenDevice(STR_ADLIB_DEVICENAME);

         if (DeviceHandle == INVALID_HANDLE_VALUE) {
             DeviceHandle = OpenDevice(STR_ADLIB_DEVICENAME L"0");
         }
         Position = 0;
     }

     return DeviceHandle != INVALID_HANDLE_VALUE;
 }

/*
 *  Map a write to a port
 *
 *  How are we going to simulate timer stuff?
 *  Answer: Allow reading of the status port.
 *
 *  This is optimized to only write when we get a data port write
 */


 void MyByteOut(WORD port, BYTE data)
 {
     //
     // Remember what register is selected
     //

     static BYTE AdlibRegister;

     //
     // Just package the stuff up and call write file
     //

     DWORD BytesWritten;

     dprintf3(("Received write to Port %4X, Data %2X", port, data));

     port = (port & 1) | ADLIB_REGISTER_SELECT_PORT;


    /*
     *  Check for special values - don't let them switch to
     *  OPL3 mode.
     */

#if 0
     if (port == ADLIB_DATA_PORT && AdlibRegister == AD_NEW) {
         data &= 0xFE;
     }
#endif


     if (port == ADLIB_REGISTER_SELECT_PORT) {
        /*
         *  Just remember which register is supposed to be selected
         *  to cut down the number of times we go to the device driver
         */

         AdlibRegister = data;
     } else {

        /*
         *  Write this one to the device
         */

         PortData[Position].IoPort = ADLIB_REGISTER_SELECT_PORT;
         PortData[Position].PortData = AdlibRegister;
         PortData[Position + 1].IoPort = port;
         PortData[Position + 1].PortData = data;

         Position += 2;

         if (Position == BATCH_SIZE ||
             AdlibRegister >= 0xA0 && AdlibRegister <= 0xBF ||
             AdlibRegister == AD_MASK) {

            /*
             *  See if we have the device
             */

             if (CheckDeviceAccess()) {

                 if (!WriteFile(DeviceHandle,
                                &PortData,
                                Position * sizeof(PortData[0]),
                                &BytesWritten,
                                NULL)) {
                     dprintf1(("Failed to write to device!"));
                 } else {
                    /*
                     *  Work out what status change may have occurred
                     */

                     if (AdlibRegister == AD_MASK) {

                        /*
                         *  Look for RST and starting timers
                         */

                         if (data & 0x80) {
                             Status = 0;
                         }

                        /*
                         *  We ignore starting of timers if their interrupt
                         *  flag is set because the timer status will have to
                         *  be set again to make the status for this timer change
                         */

                         if ((data & 1) && !(Status & 0x40)) {
                             dprintf2(("Timer 1 started"));
#if 0
                             Timer1Started = TRUE;
#else
                             Status |= 0xC0;
#endif
                         } else {
                             Timer1Started = FALSE;
                         }

                         if ((data & 2) && !(Status & 0x20)) {
                             dprintf2(("Timer 2 started"));
#if 0
                             Timer2Started = TRUE;
#else
                             Status |= 0xA0;
#endif
                             Timer2Started = TRUE;
                         } else {
                             Timer2Started = FALSE;
                         }
                     }
                 }
             }

             Position = 0;
         }
     }
 }


/*
 *  Gets called when the application reads from one of our ports.
 *  We know the device only returns interesting things in the status port.
 */

 void MyByteIn(WORD port, BYTE *data)
 {
     DWORD BytesRead;

     dprintf4(("Received read from Port %4X", port));

     port = (port & 1) | ADLIB_STATUS_PORT;

    /*
     *  If we fail simulate nothing at the port
     */

     *data = 0xFF;

    /*
     *  Say there's nothing there if we didn't get the device driver or
     *  it's not the status port
     */

     if (port != ADLIB_STATUS_PORT || !CheckDeviceAccess()) {
         return;
     }

#if 0 // WSS interrupt messed this up
    /*
     *  Are we expecting a state change ?
     */

     if (Timer1Started || Timer2Started) {

        /*
         *  Read the status port from the driver - this is how the
         *  driver interprets read.
         *  Well, actually don't because the WSS driver doesn't work!
         */

         if (!ReadFile(DeviceHandle,
                       &Status,
                       1,
                       &BytesRead,
                       NULL)) {

             dprintf1(("Failed to read from device - code %d", GetLastError()));
         } else {

            /*
             *  Look for state change
             */

             if (Status & 0x40) {
                 Timer1Started = FALSE;
                 dprintf2(("Timer 1 finished"));
             }

             if (Status & 0x20) {
                 Timer2Started = FALSE;
                 dprintf2(("Timer 2 finished"));
             }
         }
     }
#endif

     dprintf3(("Data read was %2X", Status));
     *data = Status;
 }


/*
 *  Standard DLL entry point routine.
 */

 BOOL DllEntryPoint(HINSTANCE hInstance, DWORD Reason, LPVOID Reserved)
 {
     switch (Reason) {
     case DLL_PROCESS_ATTACH:
         if (!VDDInstallIOHook(hInstance, 2, ports, &handlers)) {
             dprintf2(("Ad Lib VDD failed to load - error in VDDInstallIoHook"));
             return FALSE;
         } else {
             dprintf2(("Ad Lib VDD loaded OK"));
             return TRUE;
         }

     case DLL_PROCESS_DETACH:
         VDDDeInstallIOHook(hInstance, 2, ports);

        /*
         *  Note that  this event corresponds to FreeLibrary on our DLL,
         *  NOT termination of the process - so we can't rely on process
         *  termination to close our device handle.
         *
         */

         if (DeviceHandle) {
             CloseHandle(DeviceHandle);
             DeviceHandle = NULL;      // Redundant but neater.
         }
         return TRUE;

     default:
         return TRUE;
     }
 }



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\sample1\fax32\fax32.h ===
/* vdd.h - main include file for the VDD
 *
 */



#ifdef WIN_32
#define WIN
#define FLAT_32
#define TRUE_IF_WIN32	1
#else
#define TRUE_IF_WIN32	0
#endif

#ifdef WIN
#define _WINDOWS
#include "windows.h"
#endif



BOOL VDDInitialize(PVOID,ULONG,PCONTEXT);
VOID FAXVDDTerminateVDM(VOID);
VOID FAXVDDInit (VOID);
VOID FAXVDDDispatch (VOID);
VOID FAXVDDTerminate(USHORT usPDB);
VOID FAXVDDCreate(USHORT usPDB);
VOID FAXVDDBlock(VOID);
VOID FAXVDDResume(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\sample1\fax32\fax32.c ===
/*++
 *
 *  VDD v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  VDD.C - Sample VDD for NT-MVDM
 *
--*/
#include "fax32.h"
#include "vddsvc.h"


USHORT Sub16CS;
USHORT Sub16IP;

BOOL
VDDInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:


Arguments:

    DllHandle - Not Used

    Reason - Attach or Detach

    Context - Not Used

Return Value:

    SUCCESS - TRUE
    FAILURE - FALSE

--*/

{

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:
	// Allocate VDD's local heap if needed. Check that NT FAX driver
	// is available by opening that device.
	//....
	// Install user hook for callback service.

	if(!VDDInstallUserHook (DllHandle,&FAXVDDCreate, &FAXVDDTerminate,
		    &FAXVDDBlock, &FAXVDDResume))
	    OutputDebugString("FAX32: UserHook not installed\n");
	else
	    OutputDebugString("FAX32: UserHook installed!\n");

	// UserHook # 2
	if(!VDDInstallUserHook (DllHandle,&FAXVDDCreate, NULL,
		    NULL, &FAXVDDResume))
	    OutputDebugString("FAX32: UserHook #2 not installed\n");
	else
	    OutputDebugString("FAX32: UserHook #2 installed!\n");

	break;

    case DLL_PROCESS_DETACH:
	// Deallocate VDD's local heap if needed
	// communicate to appropriate Device driver about your departure
	//...
	// Deinstall user hook for callback service.
	if(!VDDDeInstallUserHook (DllHandle))
	    OutputDebugString("FAX32: UserHook not deinstalled\n");
	else
	    OutputDebugString("FAX32: UserHook deinstalled!\n");

        break;
    default:
        break;
    }

    return TRUE;
}

// Sample function
VOID FAXVDDTerminate(USHORT usPDB)
{
    USHORT uSaveCS, uSaveIP;

    OutputDebugString("FAX32: Terminate message\n");

    // VDDHostSimulate

    uSaveCS = getCS();
    uSaveIP = getIP();
    setCS(Sub16CS);
    setIP(Sub16IP);
    VDDSimulate16();
    setCS(uSaveCS);
    setIP(uSaveIP);

}

// Sample function
VOID FAXVDDCreate(USHORT usPDB)
{
    OutputDebugString("FAX32: Create Message\n");
}

// Sample function
VOID FAXVDDBlock(VOID)
{
    OutputDebugString("FAX32: Block Message\n");
}

// Sample function
VOID FAXVDDResume(VOID)
{
    OutputDebugString("FAX32: Resume Message\n");
}


VOID
FAXVDDTerminateVDM(
    VOID
    )
/*++

Arguments:

Return Value:

    SUCCESS - TRUE
    FAILURE - FALSE

--*/


{

    // Cleanup any resource taken for this vdm


    return;
}


VOID
FAXVDDRegisterInit(
    VOID
    )
/*++

Arguments:

Return Value:

    SUCCESS - TRUE
    FAILURE - FALSE

--*/


{
	// Save addresses for fax16
	Sub16CS = getDS();
	Sub16IP = getAX();

	OutputDebugString("FAX32: GET_ADD\n");

    // Called from the BOP manager. If VDDInitialize has done all the
    // checking and resources alloaction, just return success.

    setCF(0);
    return;
}


#define GET_A_FAX	1
#define SEND_A_FAX	2

VOID
FAXVDDDispatch(
    VOID
    )
/*++

Arguments:
    Client (DX)    = Command code
		    01 - get a message from NT device driver
		    02 - send a message through NT device driver
		    03 - address of 16 bit routine

    Client (ES:BX) = Message Buffer
    Client (CX)    = Buffer Size

Return Value:

    SUCCESS - Client Carry Clear and CX has the count transferred
    FAILURE - Client Carry Set

--*/


{
PCHAR	Buffer;
USHORT	cb;
USHORT	uCom;
BOOL	Success = TRUE; // In this sample operation always succeeds

    uCom = getDX();

    cb = getCX();
    Buffer = (PCHAR) GetVDMPointer ((ULONG)((getES() << 16)|getBX()),cb,FALSE);
    switch (uCom) {
	case GET_A_FAX:
	    // Make a DeviceIOControl or ReadFile on NT FAX driver with
	    // cb and Buffer.Then set CX if success.

	    if (Success) {
		setCX(cb);
		setCF(0);
	    }
	    else
		setCF(1);

	    break;


	case SEND_A_FAX:
	    // Make a DeviceIOControl or WriteFile on NT FAX driver with
	    // cb and Buffer.Then set CX if success.

	    if (Success) {
		setCX(cb);
		setCF(0);
	    }
	    else
		setCF(1);

	    break;
	default:
		setCF(1);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\sample2\16bits\16bits.inc ===
;---------------------------------------------------;
; Include file for 16bits sample application
; Copyright (C) 1992, Microsoft Corporation
;---------------------------------------------------;

TRUE	    equ     0FFh
FALSE	    equ     NOT(TRUE)

;
;I/O mapped I/O port equates
;
IO_PORT_FIRST		equ	790h	    ;The first I/O port addr
IO_PORT_LAST		equ	793h	    ;The last I/O port addr
IO_PORT_FIRE_DMA_SLOW	equ	IO_PORT_FIRST	;Port addr to trigger DMA
IO_PORT_FIRE_DMA_FAST	equ	IO_PORT_FIRST + 1 ;port to trigger DMA
IO_PORT_DMA		equ	IO_PORT_FIRST+2 ;port connnected to DMA channel
;
;Memory mapped I/O port equates 	    ;segment address
;
MIO_SEGMENT equ     0C000h
MIO_PORT_FIRST	    equ	    0		    ;The first port addr(offset)
MIO_PORT_LAST	    equ     07		    ;the last port addr(offset)
MIO_PORT_RANGE	    equ     MIO_PORT_LAST - MIO_PORT_FIRST + 1
MIO_PORT_FIRE_DMA   equ     MIO_PORT_FIRST  ;Port to trigger DMA
MIO_PORT_DMA	    equ     MIO_PORT_FIRST+1;port connected to DMA channel
;
;DMA equates
;
DMA_INTERRUPT	    equ	    70h + 2	    ;slave PIC, line #2(0 based)
DMA_CHANNEL	    equ	    01h		    ;DMA #1, channel #1(0 based)

DMA_PORT_BASE	    equ	00
DMA_PORT_PAGE	    equ	083h
DMA_PORT_ADDR	    equ	DMA_PORT_BASE + 2
DMA_PORT_COUNT	    equ	DMA_PORT_BASE + 3
DMA_PORT_CMD	    equ	DMA_PORT_BASE + 8
DMA_PORT_REQUEST    equ DMA_PORT_BASE + 9
DMA_PORT_SNGLE_MASK equ DMA_PORT_BASE + 10
DMA_PORT_MODE	    equ DMA_PORT_BASE + 11
DMA_PORT_FLIPFLOP   equ DMA_PORT_BASE + 12
DMA_PORT_TEMP	    equ DMA_PORT_BASE + 13
DMA_PORT_CLEARMASK  equ DMA_PORT_BASE + 14
DMA_PORT_WRTEMASK   equ DMA_PORT_BASE + 15
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\sample2\16bits\16bits.asm ===
TITLE Sample 16 Bits DOS application
;---------------------------------------------------------------;
;
    include 16bits.inc

    DOSSEG
    .MODEL SMALL

    .STACK 100h

    .DATA


DMAWriteBuffer	label	byte
	    db	    64 dup (?)
DMA_BUFFER_SIZE     equ $ - DMAWriteBuffer

DMAReadBuffer	 label	 byte
	    db	    DMA_BUFFER_SIZE dup (?)

MIOPattern  label   byte
	    db	    00, 0FFh, 0AAh, 055h
MIOPATTERN_SIZE equ	$ - MIOPattern

public	start

    .CODE
start:
    jmp     short RealStart
OldVector   label   dword
    dd	    ?
DMACompleted db     ?

RealStart:
    mov     ax,@DATA
    mov     ds,ax
    mov     es,ax
    assume  ds:@DATA, es:@DATA

;Hook interrupt(DMA terminate count notification)
    push    ds
    mov     al, DMA_INTERRUPT
    mov     ah, 35h
    int     21h
    mov     word ptr cs:OldVector, bx
    mov     word ptr cs:OldVector + 2, es
    mov     dx, offset ISRDMACompleted
    mov     ax, cs
    mov     ds, ax
    mov     al, DMA_INTERRUPT
    mov     ah, 25h
    int     21h
    pop     ds


;VDD operation.
;(1). Hook the I/O port.
;(2). Keep the port status up-to-date if a write operation is performed
;     by 16 bits application(this program).
;(3). Simulate DMA operation and generate a fake interrupt for 16bits
;     applicatiion if the DMA operation reaches its TC.
;
;
;16bits application
;(1). Output one byte to the port and then request DMA operation.
;(2). Wait for DMA operation completed.
;(3). goto step (1) if there are more data to be transferred.
;Note that the given I/O must be a R/W port.

;Here we do a DMA write operation upon I/O mapped I/O
    mov     cx, DMA_BUFFER_SIZE
    mov     si, offset DMAWriteBuffer
DMATransferLoop_Fast:
    mov     dx, IO_PORT_DMA
    mov     al, cl
    out     dx, al			;write I/O the current count
    cli
    mov     cs:DMACompleted, FALSE	;reset TC flag
    sti
;channel #1, write op, no auto init, addr inc, single transfer
    mov     al, 01000101B
    call    SetupDMAOperation
;Fire the DMA WRITE operation, this will cause VDD to gain control
;and start DMA operation.
    mov     dx, IO_PORT_FIRE_DMA_FAST
    out     dx, al
;In real world(there is a real hardware adapter), we won't do this
;idle loop, rather, we can do something useful(like, read the DMA current
;count and display the progress and so forth)provided that we can regain
;control while DMA operation is in progress(VDD spawns a new thread to
;handle DMA operation and returns to us immediately)
;
;Since we are simulating DMA operation without hardware, we always
;start the DMA operation with transfer count set to 1 byte. In reality
;this is should not be the case because it will slow down the data transfer.

WaitForDMA_Fast:
    cmp     cs:DMACompleted, TRUE
    jnz	    WaitForDMA_Fast
    inc     si
    loop    DMATransferLoop_Fast
;
;Now do a DMA read operation
    mov     cx, DMA_BUFFER_SIZE
    mov     si, offset DMAWriteBuffer
    mov     di, offset DMAReadBuffer
DMATransferLoop_Slow:
;channel #1, read op, no auto init, addr inc, single transfer
    mov     al, 01001001B
    cli
    mov     cs:DMACompleted, FALSE
    sti
    call    SetupDMAOperation
;Fire the DMA READ operation
    mov     dx, IO_PORT_FIRE_DMA_SLOW
    out     dx, al
WaitForDMA_Slow:
    cmp     cs:DMACompleted, TRUE
    jne     WaitForDMA_Slow
    mov     dx, IO_PORT_DMA
    in	    al, dx
    mov     [di], al
    inc     di				;advance our buffer
    inc     si				;and the DMA buffer
    loop    DMATransferLoop_Slow
;
;The DMAWriteBuffer and DMAReadBuffer should have the same contents.
;If they don't, it failed. ....


;Memory mapped I/O
    mov     ax, MIO_SEGMENT
    mov     es, ax
    mov     bx, MIOPATTERN_SIZE
    mov     si, offset MIOPattern

MIO_Loop:
    cld
    lodsb				;get next pattern
    mov     cx, MIO_PORT_RANGE
    mov     di, MIO_PORT_FIRST
rep stosb				;fill all I/O with the pattern
    mov     cx, MIO_PORT_RANGE
    dec     di
    std
repe	scasb				;
    je	    @F
;   call    ErrorMIO			;if any i/o failed,
@@:
    dec     bx				;next pattern
    jnz     MIO_Loop

;Before terminate, retsore everything we have touched
    push    ds
    lds     dx, cs:OldVector
    mov     al, DMA_INTERRUPT
    mov     ah, 25h
    int     21h
    pop     ds
    mov     ah, 04Ch
    int     21h

;-------------------------------------------------------;
;Setup DMA operation
;Input: ds:si = seg:offset of memeory address
;	al = DMA mode
;output: NONE
;Modified: AX, DX
;-------------------------------------------------------;
SetupDMAOperation proc
    push    cx
    mov     dx, DMA_PORT_FLIPFLOP
    out     dx, al
    mov     dx, DMA_PORT_MODE		    ;more register
    out     dx, al
    mov     ax, ds			    ;transfer address -> page:offset
    mov     cl, 4			    ;page: A16 ~ A19, offset A0 ~ A15
    rol     ax, cl
    mov     ch, al
    and     al, 0F0h
    add     ax, si
    jnc     @F
    inc     ch
@@:
    mov     dx, DMA_PORT_ADDR
    out     dx, al			    ;offset lower byte
    mov     al, ah
    out     dx, al			    ;and higher byte
    mov     dx, DMA_PORT_PAGE		    ;page register
    mov     al, ch
    and     al, 0Fh			    ;only 4 bits allowed
    out     dx, al
    mov     al, 1			    ;single transfer, one byte
    mov     dx, DMA_PORT_COUNT
    out     dx, al
    dec     al
    out     dx, al			    ;higher byte set to 0
    mov     dx, DMA_PORT_REQUEST	    ;request channel #1
    mov     al, 00000101B
    out     dx, al
    mov     dx, DMA_PORT_SNGLE_MASK	    ;start DMA transfer
    mov     al, 00000001B
    out     dx, al
    pop     cx
    ret
SetupDMAOperation endp


ISRDMACompleted proc	far
    mov     byte ptr DMACompleted, TRUE
    mov al, 20h
    out 20h, al
    out 0A0h, al
    iret
ISRDMACompleted	endp

END start
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\sample1\fax16\fax16.asm ===
name    faxdrv
    title   'FAX16 - Stub driver for Application based intercept under NT'

;
; fax16.asm: This is a very simple DOS stub device driver for NTVDM.
;	     It shows how to use application based intercept services
;	     provided by NTVDM. FAX32.dll is its DLL which will be loaded
;	     in the NTVDM process by this stub device driver.
;
;	     This driver only has meaningful code for init,read and write.
;	     Rest all command codes always succeed. We are assuming here
;	     that the 16 bit fax application for this stub device driver
;	     opens this device and just make read and write calls. The
;	     meaning of read is to get a fax message and write means
;	     send a message

_TEXT	segment byte public 'CODE'

	assume cs:_TEXT,ds:_TEXT,es:NOTHING

	org	0

	include isvbop.inc

MaxCmd	  equ	24		    ; Maximum allowed command

; VDD Command codes

OpGet	  equ	1		    ; Read a FAX
OpSend	  equ	2		    ; Send a FAX

Header: 			    ; Fax Device Header
	DD  -1
	DW  0c840h
	DW  FaxStrat
	DW  FaxIntr
	DB  'FAXDRV00'

RHPtr	DD  ?			    ; Pointer to Request Header

Dispatch:			    ; Interrupt routine command code
	DW  Init
	DW  MediaChk
	DW  BuildBPB
	DW  IoctlRd
	DW  Read
	DW  NdRead
	DW  InpStat
	DW  InpFlush
	DW  Write
	DW  WriteVfy
	DW  OutStat
	DW  OutFlush
	DW  IoctlWt
	DW  DevOpen
	DW  DevClose
	DW  RemMedia
	DW  OutBusy
	DW  Error
	DW  Error
	DW  GenIOCTL
	DW  Error
	DW  Error
	DW  Error
	DW  GetLogDev
	DW  SetLogDev

DllName   DB "FAX32.DLL",0
InitFunc  DB "FAXVDDRegisterInit",0
DispFunc  DB "FAXVDDDispatch",0

F32Mes	  DB "We are called from 32 staff", 10, 13, "$"

hVDD	  DW	?

FaxStrat    proc    far 	    ; Strategy Routine

    mov     word ptr cs:[RhPtr],bx
    mov     word ptr cs:[RhPtr+2],es
    ret

FaxStrat    endp

FaxIntr     proc    far 	    ; INterrupt routine

    push    ax			    ; Save registers
    push    bx
    push    cx
    push    dx
    push    ds
    push    es
    push    di
    push    si
    push    bp

    push    cs
    pop     ds			    ; DS = CS

    les     di,[RHPtr]		    ; ES:DI = request header

    mov     bl,es:[di+2]
    xor     bh,bh		    ; BX = command code
    cmp     bx,MaxCmd
    jle     FIntr1

    call    Error		    ; Unknown command
    jmp     FIntr2

FIntr1:
    shl     bx,1
    call    word ptr [bx+Dispatch]  ; call command routine
    les     di,[RhPtr]		    ; ES:DI = request header

FIntr2:
    or	    ax,0100h		    ; Set Done bit in the status
    mov     es:[di+3],ax	    ; Store the status

    pop     bp			    ; restore registers
    pop     si
    pop     di
    pop     es
    pop     ds
    pop     dx
    pop     cx
    pop     bx
    pop     ax

    ret


MediaChk    proc    near
    xor     ax,ax
    ret
MediaChk    endp

BuildBPB    proc    near
    xor     ax,ax
    ret
BuildBPB    endp

IoctlRd	    proc    near
    xor     ax,ax
    ret
IoctlRd	    endp

Read	    proc    near
    push    es
    push    di					; Save Request Header add

    mov     bx,word ptr es:[di+14]		; buffer offset
    mov     ax,word ptr es:[di+16]		; buffer segment
    mov     cx,word ptr es:[di+18]		; buffer length

    mov     es,ax				; es:bx is the buffer where
						; fax has to be read from
						; the NT device driver

    mov     ax,word ptr cs:[hVDD]		; VDD handle returned by
						; register module
    mov     dx,OpGet				; Read the fax command

    DispatchCall

    pop     di
    pop     es

    jnc     rOK 				; NC -> Success and CX has
						; the count read.

    call    Error				; Operation Failed
    ret

rOK:
    mov     word ptr es:[di+12],cx		; return in header how much
						; was read
    xor     ax,ax
    ret
Read	    endp

NdRead	    proc    near
    xor     ax,ax
    ret
NdRead	    endp

InpStat	    proc    near
    xor     ax,ax
    ret
InpStat	    endp

InpFlush    proc    near
    xor     ax,ax
    ret
InpFlush    endp

Write	    proc    near
    push    es
    push    di					; Save Request Header add

    mov     bx,word ptr es:[di+14]		; buffer offset
    mov     ax,word ptr es:[di+16]		; buffer segment
    mov     cx,word ptr es:[di+18]		; buffer length

    mov     es,ax				; es:bx is the FAX message	where
						; to be send by NT device
						; driver

    mov     ax,word ptr cs:[hVDD]		; VDD handle returned by
						; register module
    mov     dx,OpSend				; Send the fax command

    DispatchCall

    pop     di
    pop     es

    jnc     wOK				; NC -> Success and CX has
						; the count read.

    call    Error				; Operation Failed
    ret

wOK:
    mov     word ptr es:[di+12],cx		; return in header how much
						; was actually written
    xor     ax,ax
    ret
Write	    endp

WriteVfy    proc    near
    xor     ax,ax
    ret
WriteVfy    endp

OutStat	    proc    near
    xor     ax,ax
    ret
OutStat     endp

OutFlush    proc    near
    xor     ax,ax
    ret
OutFlush    endp

IoctlWt	    proc    near
    xor     ax,ax
    ret
IoctlWt     endp

DevOpen	    proc    near
    xor     ax,ax
    ret
DevOpen     endp

DevClose    proc    near
    xor     ax,ax
    ret
DevClose    endp

RemMedia    proc    near
    xor     ax,ax
    ret
RemMedia    endp

OutBusy	    proc    near
    xor     ax,ax
    ret
OutBusy     endp

GenIOCTL    proc    near
    xor     ax,ax
    ret
GenIOCTL    endp

GetLogDev   proc    near
    xor     ax,ax
    ret
GetLogDev   endp

SetLogDev   proc    near
    xor     ax,ax
    ret
SetLogDev   endp

Error	    proc    near
    mov     ax,8003h				; Bad Command Code
    ret
Error	    endp
;
;
; This function is a sample sub that calling from 32-bits part of VDD
;
From32Sub   proc    near

    push    cs
    pop     ds
    mov     dx, offset F32mes
    mov     ah, 09h
    int     21h
    VDDUnSimulate16
    ret

From32Sub   endp

Init	    proc    near
    push    es
    push    di					; Save Request Header add

    push    ds
    pop     es

    ; Load fax32.dll
    mov     si, offset DllName			; ds:si = fax32.dll
    mov     di, offset InitFunc                 ; es:di = init routine
    mov     bx, offset DispFunc 		; ds:bx = dispatch routine
    mov     ax, offset From32Sub		; ds:ax = From32Sub


    RegisterModule
    jnc     saveHVDD				; NC -> Success

    call    Error				; Indicate failure

    pop     di
    pop     es
    mov     byte ptr es:[di+13],0		; unit supported 0
    mov     word ptr es:[di+14],offset Header	; Unload this device
    mov     word ptr es:[di+16],cs
    mov     si, offset Header
    and	    [si+4],8FFFh			; clear bit 15 for failure
    ret

saveHVDD:
    mov     [hVDD],ax

    pop     di
    pop     es
    mov     word ptr es:[di+14],offset Init	; Free Memory address
    mov     word ptr es:[di+16],cs

    xor     ax,ax				; return success
    ret
Init	    endp

FaxIntr	    endp

_TEXT	    ends

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\sample2\vdd\vdd.h ===
/* vdd.h - main include file for the VDD
 *
 */


#include "windows.h"

// VDD services header
#include <vddsvc.h>

// private macro definitions


#define PAGE_SIZE		0x1000
/*disconnected I/O value */
#define FLOATING_IO		0xFF
#define FLOATING_MIO		0xFF

// I/O mapped I/O
#define IO_PORT_FIRST		0x790
#define IO_PORT_LAST		0x793
#define IO_PORT_FIRE_DMA_SLOW	IO_PORT_FIRST
#define IO_PORT_FIRE_DMA_FAST	IO_PORT_FIRST + 1
#define IO_PORT_DMA		IO_PORT_FIRST + 2
#define IO_PORT_RANGE		IO_PORT_LAST - IO_PORT_FIRST + 1

// memory mapped I/O
#define MIO_SEGMENT		0xC000
#define MIO_PORT_FIRST		0
#define MIO_PORT_LAST		7
#define MIO_PORT_FIRE_DMA	MIO_PORT_FIRST
#define MIO_PORT_DMA		MIO_PORT_FIRST + 1
#define MIO_PORT_RANGE		MIO_PORT_LAST - MIO_PORT_FIRST + 1
#define MIO_ADDRESS		((((ULONG)MIO_SEGMENT) << 16) | MIO_PORT_FIRST)

// DMA
#define DMA_CHANNEL		1
#define DMA_PORT_BASE		0
#define DMA_SHIFT_COUNT 	0
#define DMA_INTERRUPT_LINE	2
#define DMA_INTERRUPT_PIC	ICA_SLAVE
#define DMA_PORT_PAGE		0x83
#define DMA_PORT_ADDR		DMA_PORT_BASE + 2
#define DMA_PORT_COUNT		DMA_PORT_BASE + 3
#define DMA_PORT_CMD		DMA_PORT_BASE + 8
#define DMA_PORT_REQUEST	DMA_PORT_BASE + 9
#define DMA_PORT_SNGLE_MASK	DMA_PORT_BASE + 10
#define DMA_PORT_MODE		DMA_PORT_BASE + 11
#define DMA_PORT_FLIPFLOP	DMA_PORT_BASE + 12
#define DMA_PORT_TEMP		DMA_PORT_BASE + 13
#define DMA_PORT_CLEARMASK	DMA_PORT_BASE + 14
#define DMA_PORT_WRTEMASK	DMA_PORT_BASE + 15


/* function prototype definitions */

/* entry function of VDD */
BOOL VddDllEntry(HANDLE hVdd, DWORD dwReason, LPVOID lpReserved);

/* private functions */
VOID MyInB(WORD, PBYTE);
VOID MyOutB(WORD, BYTE);
VOID MyMIOHandler(ULONG, ULONG);
WORD FakeDD_DMARead(PBYTE, WORD);
WORD FakeDD_DMAWrite(PBYTE, WORD);
BOOLEAN SlowDMA();
BOOLEAN FastDMA();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\samples\sample2\vdd\vdd.c ===
/*++
 *
 *  VDD v1.0
 *
 *  Copyright (c) 1991, Microsoft Corporation
 *
 *  VDD.C - Sample VDD for NT-MVDM
 *
--*/

#include "vdd.h"

/** Global variables **/

    HANDLE  hVDD;		/* VDD module handle */
    HANDLE  hVddHeap;		/* VDD local heap */
    PBYTE   IOBuffer;		/* buffer to simulate I/O Read and Write */
    ULONG   MIOAddress; 	/* memory mapped I/O linear address */
    PVOID   BaseAddress;	/* memory mapped I/O virtual address */
    BOOL    IOHook;		/* true if we installed a I/O hooked */
    BOOL    MIOHook;		/* true if we installed a memory hook */
    static VDD_IO_PORTRANGE PortRange;

BOOL
VDDInitialize(
    HANDLE   hVdd,
    DWORD    dwReason,
    LPVOID   lpReserved)

/*++

Routine Description:

    The DllEntryPoint for the Vdd which handles intialization and termination

Arguments:

    hVdd   - The handle to the VDD

    Reason - flag word thatindicates why Dll Entry Point was invoked

    lpReserved - Unused

Return Value:
    BOOL bRet - if (dwReason == DLL_PROCESS_ATTACH)
                   TRUE    - Dll Intialization successful
                   FALSE   - Dll Intialization failed
                else
                   always returns TRUE
--*/

{
    int     i;
    VDD_IO_HANDLERS  IOHandlers;



/**
    keep a copy of VDD handle in global variable so the other functions
    can see it
**/
    hVDD = hVdd;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

        // Allocate VDD's local heap
        hVddHeap = HeapCreate(0, 0x1000, 0x10000);

	if (!hVddHeap) {
	    OutputDebugString("VDD: Can't create local heap");
            return FALSE;
	}

        IOBuffer = (PBYTE)HeapAlloc(hVddHeap,0,IO_PORT_RANGE);

	if (!IOBuffer)	{
	    OutputDebugString("VDD: Can't allocate IO buffer from heap");
            HeapDestroy(hVddHeap);
            return FALSE;
	}

        // communicate to appropriate Device driver about your arrival

	// Set emulated I/O to floating
        for (i = 0 ; i < IO_PORT_RANGE; i++)
	    IOBuffer[i] = FLOATING_IO;


	IOHandlers.inb_handler = MyInB;
	IOHandlers.inw_handler = NULL;
	IOHandlers.insb_handler = NULL;
	IOHandlers.insw_handler = NULL;
	IOHandlers.outb_handler = MyOutB;
	IOHandlers.outw_handler = NULL;
	IOHandlers.outsb_handler = NULL;
	IOHandlers.outsw_handler = NULL;
	PortRange.First = IO_PORT_FIRST;
	PortRange.Last = IO_PORT_LAST;

	// hook I/O mapped I/O
	IOHook = VDDInstallIOHook(hVDD, (WORD) 1, &PortRange, &IOHandlers);

	// get 32 bits linear address of memory mapped I/O
	MIOAddress = (ULONG) GetVDMPointer(MIO_ADDRESS, MIO_PORT_RANGE, 0);
	// hook memory mapped I/O
	MIOHook = VDDInstallMemoryHook(hVDD, (PVOID) MIOAddress, MIO_PORT_RANGE,
				       (PVDD_MEMORY_HANDLER)MyMIOHandler);

	BaseAddress = NULL;
	break;

    case DLL_PROCESS_DETACH:

        // communicate to appropriate Device driver about your departure
	if (IOHook)
	    VDDDeInstallIOHook(hVDD, 1, &PortRange);
	if (MIOHook) {
	    VDDDeInstallMemoryHook(hVDD, (PVOID) MIOAddress, MIO_PORT_RANGE);
	    if (BaseAddress) {
		VDDFreeMem(hVDD, BaseAddress, PAGE_SIZE);
	    }
	}

        // Deallocate VDD's local heap if needed
        HeapDestroy(hVddHeap);
        break;

    default:
        break;
    }

    return TRUE;
}


VOID
MyInB(
WORD	Port,
PBYTE	Buffer
)

{
// Simply provide the data from our buffer
    *Buffer = IOBuffer[Port - IO_PORT_FIRST];
}

VOID
MyOutB(
WORD Port,
BYTE Data
)

{
    // update our local buffer.
    // In real application, the VDD might want to call its associated
    // device driver to update the change.

    IOBuffer[Port - IO_PORT_FIRST] = (BYTE)Data;

    // If the IO port is the one to trigger DMA operation, do it
    // To demonstarte the two options in handling DMA operation, we
    // use two ports here to trigger different DMS operation schemes.

    if (Port == IO_PORT_FIRE_DMA_FAST) {
	FastDMA();
    }
    else {
	if(Port == IO_PORT_FIRE_DMA_SLOW) {
	    SlowDMA();
	 }
    }
}


VOID
MyMIOHandler(
ULONG	Address,			// faulting linear address
ULONG	RWFlags 			// 1 if write opertion, 0 if read
)
{

	// map the memory for the memory mapped I/O so that we won't
	// get page fault on our memory mapped I/O after this.
	// We may reserve the memory during  DLL_PROCESS_ATTACH (by using
	// MEM_RESERVE rather than MEM_COMMIT we did here).
	// The solution applied here is not the best solution(it is the
	// simplest solution though). A better way to handle memory mapped
	// I/O is to hook the page fault as we did here and decode the faulting
	// instruction, simulate its operation and advance 16 bits application
	// program counter(getIP and setIP).

    if (VDDAllocMem (hVDD, (LPVOID) MIOAddress, PAGE_SIZE)) {
	BaseAddress = (LPVOID)MIOAddress;
    } else {
	OutputDebugString("VDD: Can't allocate virtual memory");
    }
}


/** DMA operation support

Facts:
    - All DMA I/O ports are trapped and maintained by MVDM.
    - VDD provides necessary buffers and calls its associated device
      driver to carry out the real work(in this case, device driver
      will perform real DMA operation with the buffer provided by
      VDD as the source(DMA READ) or destination(DMA WRITE).
    -The device driver has full knowledge of which I/O port(s) are
      connectted to the DMA request channel.
Therefore, the responsibilities of VDD are:
    (1). Allocate necessary buffers
    (2). if it is a DMA write operation(data from I/O to memory)
	    - calls device driver to perform the DMA operation with
	      newly allocated memory as the target buffer for DMA operation.
	    - calls MVDM DMA support routine to transfer data from
	      local buffer to 16bits application buffer.
	    - Simulate an interrupt to the 16 bits applications to notify
	      the completion.
	 if it is a DMA read operation(data from memory to I/O)
	    - calls MVDM DMA service to copy data from 16bits application
	      to the newly allocated buffer.
	    - calls the device driver to carry out DMA operation with
	      the allocated buffer as the source of the operation.
	    - Simulate an interrupt to the 16bits application to notify
	      the completion.
The SlowDMA simulates a DMA READ operation by using VDDRequestDMA service.
The FastDMA simulates a DMA WRITE operation by using VDDQueryDMA and VDDSetDMA
services.

** NOTE **
We run the DMA in the same thread here so that before we return, there is no
way for 16 bits application to regain control. In real world, it would
be appropriate for VDDs to create a thread to do the actual DMA transfer
(interactes with device driver) so that it won't block the 16bits
application from running which will allow 16 bits application to provide
useful information to the users(the application can read DMA registers and
display the progress to the user and so forth)
**/


// This function perform DMA READ operation by using VDDRequestDMA service
BOOLEAN
SlowDMA()
{
 PBYTE DMABuffer, CurDMABuffer;
 DWORD BufferLen;
 DWORD PacketLen;

   //first find out how big the buffer we need and then allocate
   //the buffer from local heap.
   //give 0 for buffer length to ask buffer length
   //the length returned from VDDRequestDMA is the number of byte
   //the DMA operation has to carry out. If the DMA channel is a 16bits
   //the returned length will be 2 times the count value set to the
   // DMA count register.

 BufferLen = VDDRequestDMA(hVDD, DMA_CHANNEL, 0, 0);

 CurDMABuffer = DMABuffer = (PBYTE)HeapAlloc(hVddHeap, 0, BufferLen);
 if (!DMABuffer)  {
     OutputDebugString("VDD: Can't allocate heap memory for VDDRequestDMA");
     return(FALSE);
     }

   // Since this is a DMA read operation(memory -> I/O), 16bits application
   // should have provided necessary data in its local memory and the memory
   // address can be derived from DMA base address register and page register.
   // We don't want to deal with DMA register in this  DMS operation scheme,
   // therefore, we ask MVDM to copy the application data to our local buffer.
   // It may be the case that applications requested a very big data transfer,
   // 128K bytes for example, and we may not allocate enough buffer from our
   // local heap. To overcome the problem, we have to break the data transfer
   // to multiple subblocks and transfer each subblock by calling our device
   // driver. Here we assume we can get the enough buffer from local heap.
   //
   // The device driver should take care of 64k wrap problem of DMA operation.

 BufferLen = VDDRequestDMA(hVDD, DMA_CHANNEL, CurDMABuffer, BufferLen);

   // MVDM updates DMA registers on each VDDReauestDMA. Therefore, after we
   // made this call, the DMA registers maintained by MVDM have been set
   // to the states as the DMA operation has been done(and it is not yet).
   // It may be the case that the 16bits application regains control(as we
   // create a different thread to do the operation) and issues another
   // DMA operation before we(and the device driver) complete the current
   // DMA operation. Keep away from using global variables in this
   // case.

   // We have source data in our local buffer, time to ask device
   // driver to transfer the data to I/O. In case that the device driver
   // can not transfer the whole buffer in a single service call, we
   // call the device driver repeatly until we consume the entire buffer

 while( BufferLen > 0) {
    PacketLen = FakeDD_DMARead(CurDMABuffer, (WORD)BufferLen);
    CurDMABuffer += PacketLen;
    BufferLen -= PacketLen;
 }


    // DMA transfer completed; we simulate an interrupt to the 16bits
    // application. Note that the DMA I/O ports should have been set
    // accordingly by MVDM(through VDDReauestDMA).
    // A real VDD may not do thing this way(VDD has to wait for device
    // driver to finish the data transfer before returning to 16bits application
    // Instead, the VDD and its associated device driver can keep synchronized
    // by using semaphore or other events so that they can keep running in
    // parallel and when receiving a event signal(triggered by the device driver to
    // to notify completion of DMA operation) the VDD can then simulate the
    // interrupt to the 16bits application

 VDDSimulateInterrupt(DMA_INTERRUPT_PIC, DMA_INTERRUPT_LINE, 1);
 HeapFree(hVddHeap, 0, DMABuffer);
 return (TRUE);

}

   // This function simulate a DMA write(I/O to memory) operation
   // It uses VDDQueryDMA and VDDSetDMA services to gain speed

BOOLEAN
FastDMA()
{
    ULONG   DMAAddress;
    DWORD   Size;
    WORD    PacketLen;

    VDD_DMA_INFO    DMAInfo;

    // Get the current DMA registers setting
    VDDQueryDMA(hVDD, DMA_CHANNEL, &DMAInfo);

    // if the DMA channel is not 1 16bits channel, adjust the size
    Size = (DMAInfo.count << DMA_SHIFT_COUNT);

    // seg:off of the DMA transfer address
    DMAAddress = (((ULONG)DMAInfo.page) << (12 + 16))
                 + (DMAInfo.addr >> DMA_SHIFT_COUNT);

    // Get DMA transfer 32bits linear address
    DMAAddress = (ULONG) GetVDMPointer(DMAAddress, Size, 0);

    while(Size) {
	PacketLen = FakeDD_DMAWrite((PBYTE)DMAAddress, (WORD)Size);
	DMAAddress += PacketLen;
	Size -= PacketLen;
	DMAInfo.addr += PacketLen;
	DMAInfo.count -= (PacketLen >> DMA_SHIFT_COUNT);

	// We have to upate the DMA registers even though we are not done
	// the transfer yet. It is a good practice to update the DMA
	// register each time we have really transferred data so that
	// if the 16bits application regains control before DMA operation
	// totally completed, it can get the partial result states and
	// report to users.

	VDDSetDMA(hVDD, DMA_CHANNEL, VDD_DMA_ADDR | VDD_DMA_COUNT,
		  &DMAInfo);
    }

    // see note on SlowDMA
    VDDSimulateInterrupt(DMA_INTERRUPT_PIC, DMA_INTERRUPT_LINE, 1);
    return(TRUE);
}

   // This function is a fake service which should be provided by device
   // drivers in the real world. The thing we do here is to simulate
   // a DMA operation transferring data from the given buffer to
   // to the pre-defined memory mapped I/O port(DMA READ).

WORD  FakeDD_DMARead(PBYTE Buffer, WORD Size)
{
    IOBuffer[IO_PORT_DMA - IO_PORT_FIRST] = Buffer[0];
    return (1);
}

    //This function calls device driver services to start DMA operation
    //and requests the device driver to write the data to the given buffer.
    //Since we are simulating the operation, we simply fill the buffer by
    //reading the predefined I/O port

WORD FakeDD_DMAWrite(PBYTE Buffer, WORD Size)
{
    *Buffer = IOBuffer[IO_PORT_DMA - IO_PORT_FIRST];
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\fm.h ===
/***************************************************************************
*
*    fm.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

/*
*    OPL2/Adlib Ports
*/

#define ADLIB_REGISTER_SELECT_PORT 0x388 // select the register to write data
#define ADLIB_STATUS_PORT          0x388 // read to determine opl2 status
#define ADLIB_DATA_PORT            0x389 // write data port

/*
*    FM information
*/

#define AD_MASK             0x04    // adlib register used to control opl2
#define AD_NEW              0x105   // used to determine if app entering opl3 mode
#define BATCH_SIZE          40      // how much data is batched to opl2

typedef struct {                    // structure written to fm device
    unsigned short IoPort;
    unsigned short PortData;
} SYNTH_DATA, *PSYNTH_DATA;

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

void ResetFM(void);
BOOL OpenFMDevice(void);
void CloseFMDevice(void);
BOOL FMPortWrite(void);

VOID
FMDataWrite(
    BYTE data
    );

VOID
FMRegisterSelect(
    BYTE data
    );

VOID
FMStatusRead(
    BYTE *data
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\vsb.c ===
/***************************************************************************
*
*    vsb.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <dsp.h>
#include <mixer.h>
#include <fm.h>


/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
//
SETVOLUMEPROC SetVolumeProc;
GETNUMDEVSPROC GetNumDevsProc;
GETDEVCAPSPROC GetDevCapsProc;
OPENPROC OpenProc;
RESETPROC ResetProc;
CLOSEPROC CloseProc;
GETPOSITIONPROC GetPositionProc;
WRITEPROC WriteProc;
PREPAREHEADERPROC PrepareHeaderProc;
UNPREPAREHEADERPROC UnprepareHeaderProc;

BOOL bWaveOutActive = FALSE;
BOOL bWinmmLoaded = FALSE;
BOOL LoadWinmm(VOID);
BOOL InitDevices(VOID);
HINSTANCE hWinmm;

/*
 *    General globals
 */

HINSTANCE GlobalHInstance; // handle passed to dll entry point
WORD BasePort; // Where the card is mapped

/*****************************************************************************
*
*    General Functions
*
*****************************************************************************/


/*
*    DLL entry point routine.
*    Returns TRUE on success.
*/

BOOL WINAPI
DllEntryPoint(
    HINSTANCE hInstance,
    DWORD reason,
    LPVOID reserved
    )
{

    switch (reason) {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInstance);
        // save instance
        GlobalHInstance = hInstance;

        // Hook i/o ports
        if (!InstallIoHook(hInstance)) {
            dprintf1(("VDD failed to load"));
#if 0
            MessageBoxA(NULL, "Unable to load wave out device",
              "Sound Blaster VDD", MB_OK | MB_ICONEXCLAMATION);
#endif
            return FALSE;
        }

        if (!DspProcessAttach()) {
            DeInstallIoHook(hInstance);
            return FALSE;
        }

#if 0
        {
        char buf[256];
        wsprintfA(buf, "Sound blaster VDD loaded at port %3X, IRQ %d, DMA Channel %d, %s OPL2/Adlib support.",
                  BasePort, SB_INTERRUPT, SB_DMA_CHANNEL,
                  (FMActive ? "with" : "without"));
        MessageBoxA(NULL, buf, "Sound Blaster VDD", MB_OK | MB_ICONINFORMATION);
        }
#endif // DBG
        return TRUE;

    case DLL_PROCESS_DETACH:

        DspProcessDetach();
        DeInstallIoHook(hInstance);

        if (bWaveOutActive) {
            CloseFMDevice();
            SetSpeaker(TRUE);
        }

        if (bWinmmLoaded) {
            FreeLibrary(hWinmm);
        }

        return TRUE;

    default:
        return TRUE;
    }
}

/***************************************************************************/
//
// LoadWinmm()
//
// This function dynamically loads the "waveOutxxx" entry points. This
// is done because there is code in WINMM which does certain things in a
// WOW vdm. If we do static links, then winmm may get loaded way before
// WOW32, in which case it can't do the things it should.
//
BOOL
LoadWinmm(
    VOID
    )
{

    if (!(hWinmm = LoadLibrary(L"WINMM.DLL"))) {
        return FALSE;
    }

    //BUGBUG: Should check for error return from getprocaddress
    //
    SetVolumeProc = (SETVOLUMEPROC) GetProcAddress(hWinmm, "waveOutSetVolume");
    GetNumDevsProc = (GETNUMDEVSPROC) GetProcAddress(hWinmm, "waveOutGetNumDevs");
    GetDevCapsProc = (GETDEVCAPSPROC) GetProcAddress(hWinmm, "waveOutGetDevCapsW");
    OpenProc = (OPENPROC) GetProcAddress(hWinmm, "waveOutOpen");
    ResetProc = (RESETPROC) GetProcAddress(hWinmm, "waveOutReset");
    CloseProc = (CLOSEPROC) GetProcAddress(hWinmm, "waveOutClose");
    GetPositionProc = (GETPOSITIONPROC) GetProcAddress(hWinmm, "waveOutGetPosition");
    WriteProc = (WRITEPROC) GetProcAddress(hWinmm, "waveOutWrite");
    PrepareHeaderProc = (PREPAREHEADERPROC) GetProcAddress(hWinmm, "waveOutPrepareHeader");
    UnprepareHeaderProc = (UNPREPAREHEADERPROC) GetProcAddress(hWinmm, "waveOutUnprepareHeader");
    return TRUE;
}

/***************************************************************************/
//
// InitDevices()
//
// This function tries to get handles to the waveout and FM devices.
//
BOOL
InitDevices(
    VOID
    )
{
    static BOOL bTriedLoadAndFailed = FALSE;

    if (bWaveOutActive) {
        return TRUE;
    }

    if (bTriedLoadAndFailed) {
        return FALSE;
    }

    if (!bWinmmLoaded) {
        if (!LoadWinmm()) {
            bTriedLoadAndFailed = TRUE;
            return FALSE;
        }
        bWinmmLoaded = TRUE;
    }

    if (!FindWaveDevice()) {
        return FALSE;
    }
    bWaveOutActive = TRUE;
    OpenFMDevice();
    return TRUE;
}

/***************************************************************************/

/*
*    Hooks i/o ports with i/o handlers.
*    Sets BasePort and returns TRUE if successful.
*/

BOOL
InstallIoHook(
    HINSTANCE hInstance
    )
{
    int i;
    WORD ports[] = { 0x220, 0x210, 0x230, 0x240, 0x250, 0x260, 0x270 };
    VDD_IO_HANDLERS handlers = {
        VsbByteIn,
        NULL,
        NULL,
        NULL,
        VsbByteOut,
        NULL,
        NULL,
        NULL};

    // try each base port until success is achieved
    for (i = 0; i < sizeof(ports) / sizeof(ports[0]); i++ ) {
        VDD_IO_PORTRANGE PortRange[5];

        PortRange[0].First = ports[i] + 0x04;
        PortRange[0].Last = ports[i] + 0x06;

        PortRange[1].First = ports[i] + 0x08;
        PortRange[1].Last = ports[i] + 0x0A;

        PortRange[2].First = ports[i] + 0x0C;
        PortRange[2].Last = ports[i] + 0x0C;

        PortRange[3].First = ports[i] + 0x0E;
        PortRange[3].Last = ports[i] + 0x0E;

        PortRange[4].First = 0x388;
        PortRange[4].Last = 0x389;

        if (VDDInstallIOHook((HANDLE)hInstance, 5, PortRange, &handlers)) {
            dprintf2(("Device installed at %X", ports[i]));
            BasePort = ports[i];
            return TRUE;
        }
    }

    return FALSE;
}

/***************************************************************************/

/*
*    Remove our i/o hook.
*/

VOID
DeInstallIoHook(
    HINSTANCE hInstance
    )
{
    VDD_IO_PORTRANGE PortRange[5];

    PortRange[0].First = BasePort + 0x04;
    PortRange[0].Last = BasePort + 0x06;

    PortRange[1].First = BasePort + 0x08;
    PortRange[1].Last = BasePort + 0x0A;

    PortRange[2].First = BasePort + 0x0C;
    PortRange[2].Last = BasePort + 0x0C;

    PortRange[3].First = BasePort + 0x0E;
    PortRange[3].Last = BasePort + 0x0E;

    PortRange[4].First = 0x388;
    PortRange[4].Last = 0x389;

    VDDDeInstallIOHook((HANDLE)hInstance, 5, PortRange);
}


/***************************************************************************/

/*
*    Gets called when the application reads from port.
*    Returns results to application in data.
*/
VOID
VsbByteIn(
    WORD port,
    BYTE * data
    )
{
    // If we fail simulate nothing at the port
    *data = 0xFF;

    //
    // make sure we are linked in with winmm
    //
    if (!bWaveOutActive) {
        if (!InitDevices()) {
            // no wave device, forget it
            return;
        }
    }

    switch (port - BasePort) {
    case READ_STATUS:
        DspReadStatus(data);
        break;

    case READ_DATA:
        DspReadData(data);
        break;

    case WRITE_STATUS:
        // Can always write
        *data = 0x7F;
        break;

    case MIXER_ADDRESS:
        // apps sometimes read from this port??
        break;

    case MIXER_DATA:
        MixerDataRead(data);
        break;

    case 0x8:
        // remap to ADLIB_STATUS_PORT
        port = ADLIB_STATUS_PORT;
        break;
    }

    switch(port) {
    case ADLIB_STATUS_PORT:
        FMStatusRead(data);
        break;
    }

    dprintf4(("Read  %4X, <= %2X", port, *data));
}

/***************************************************************************/

/*
*    Gets called when an application writes data to port.
*/

VOID
VsbByteOut(
    WORD port,
    BYTE data
    )
{
    //
    // make sure we are linked in with winmm
    //
    if (!bWaveOutActive) {
        if (!InitDevices()) {
            // no wave device, forget it
            return;
        }
    }

    dprintf4(("Write %4X, => %2X", port, data));

    switch (port - BasePort) {
    case RESET_PORT:
        DspResetWrite(data);
        break;

    case WRITE_PORT:
        DspWrite(data);
        break;

    case MIXER_ADDRESS:
        MixerAddrWrite(data);
        break;

    case MIXER_DATA:
        MixerDataWrite(data);
        break;

    case 0x8:
        // remap to ADLIB_REGISTER_SELECT_PORT
        port = ADLIB_REGISTER_SELECT_PORT;
        break;

    case 0x9:
        // remap to ADLIB_DATA_PORT
        port = ADLIB_DATA_PORT;
        break;
    }

    switch(port) {
    case ADLIB_REGISTER_SELECT_PORT:
        FMRegisterSelect(data);
        break;

    case ADLIB_DATA_PORT:
        FMDataWrite(data);
        break;
    }
}

/***************************************************************************/

/*
*    Reset all devices
*/

VOID
ResetAll(
    VOID
    )
{
    dprintf2(("Resetting"));
    ResetDSP();
    ResetFM();
    ResetMixer();
}

/***************************************************************************/

/*
*    Debug
*/

#if DBG
int VddDebugLevel = 3;
int VddDebugCount = 0;

#define DEBUG_START 0

/*
 *    Generate debug output in printf type format.
 */

void VddDbgOut(LPSTR lpszFormat, ...)
{
    char buf[256];
    char buf2[300] = "VSBD: ";
    va_list va;

    if (++VddDebugCount < DEBUG_START) {
        return;
    }

    va_start(va, lpszFormat);
    wvsprintfA(buf, lpszFormat, va);
    va_end(va);

    strcat(buf2, buf);
    strcat(buf2, "\r\n");
    OutputDebugStringA(buf2);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\mixer.c ===
/***************************************************************************
*
*    mixer.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <mixer.h>

extern SETVOLUMEPROC SetVolumeProc;
extern HWAVEOUT HWaveOut;               // the current open wave output device

/*
 *    Mixer globals
 */

struct {
    BYTE MasterVolume; // current master volume
    BYTE FMVolume; // current volume of fm device
    BYTE CDVolume; // current volume of cd
    BYTE VoiceVolume; // current volume of wave device
}
MixerSettings;

/*
*    Mixer State Machine
*/

enum {
    MixerReset = 1, // initial state and after reset
    MixerMasterVolume,
    MixerFMVolume,
    MixerCDVolume,
    MixerVoiceVolume
  }
  MixerState = MixerReset; // state of current command/data being set


/****************************************************************************
*
*    Mixer device routines
*
****************************************************************************/

VOID
MixerDataRead(
    BYTE * data
    )
{
    switch(MixerState) {
    case MixerReset:
        ResetMixer();
        break;

    case MixerMasterVolume:
        *data = MixerSettings.MasterVolume;
        break;

    case MixerFMVolume:
        *data = MixerSettings.FMVolume;
        break;

    case MixerCDVolume:
        *data = MixerSettings.CDVolume;
        break;

    case MixerVoiceVolume:
        *data = MixerSettings.VoiceVolume;
        break;
    }
}

VOID
MixerAddrWrite(
    BYTE data
    )
{
    switch(data) {
    case MIXER_RESET:
        MixerState = MixerReset;
        break;

    case MIXER_MASTER_VOLUME:
        MixerState = MixerMasterVolume;
        break;

    case MIXER_FM_VOLUME:
        MixerState = MixerFMVolume;
        break;

    case MIXER_CD_VOLUME:
        MixerState = MixerCDVolume;
        break;

    case MIXER_VOICE_VOLUME:
        MixerState = MixerVoiceVolume;
        break;
    }
}

VOID
MixerDataWrite(
    BYTE data
    )
{
    // only voice and master volume implemented,
    // havent't found any apps using others
    switch(MixerState) {
    case MixerReset:
        ResetMixer();
        break;

    case MixerMasterVolume:
        MixerSettings.MasterVolume = data;
        MixerSetMasterVolume(data);
        break;

    case MixerFMVolume:
        MixerSettings.FMVolume = data;
        break;

    case MixerCDVolume:
        MixerSettings.CDVolume = data;
        break;

    case MixerVoiceVolume:
        MixerSettings.VoiceVolume = data;
        MixerSetVoiceVolume(data);
        break;
    }
}

/*
*    Reset the mixer to initial values.
*/

VOID
ResetMixer(
    VOID
    )
{
    MixerSettings.MasterVolume = 0x08; // set to level 4
    MixerSetMasterVolume(0x08);
    MixerSettings.FMVolume = 0x08; // set to level 4
    MixerSettings.CDVolume = 0x00; // set to level 0
    MixerSettings.VoiceVolume = 0x04; // set to level 2
    MixerSetVoiceVolume(0x04);

    MixerState = MixerReset;
}

/***************************************************************************/

/*
*    Set master volume.
*/

VOID
MixerSetMasterVolume(
    BYTE level
    )
{
    ULONG volume = 0;

    level = level >> 1;
    level = level & 0x07;

    volume = level*0x2492; // 0xFFFF/7 = 0x2492
    volume = volume + (volume<<16);
}

/***************************************************************************/

/*
*    Set volume of wave out device.
*/

VOID
MixerSetVoiceVolume(
    BYTE level
    )
{
    ULONG volume = 0;

    level = level >> 1;
    level = level & 0x03;

    volume = level*0x5555; // 0xFFFF/3 = 0x5555
    volume = volume + (volume<<16);
    SetVolumeProc(HWaveOut, volume);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\fm.c ===
/***************************************************************************
*
*    fm.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <fm.h>


/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

HANDLE HFM = NULL; // current open FM device
BOOL FMActive = FALSE; // indicates whether we have an FM device
BYTE AdlibRegister = 0x00; // register currently selected
int Position = 0; // position in PortData array
SYNTH_DATA PortData[BATCH_SIZE]; // batched data to be written to OPL2 device
BOOL Timer1Started = FALSE; // if a timer interrupts then it's stopped
BOOL Timer2Started = FALSE; // if a timer interrupts then it's stopped
BYTE Status = 0x06; // or 0x00, see sb programming book page xi


/****************************************************************************
*
*    FM device routines
*
****************************************************************************/

VOID
ResetFM(
    VOID
    )
{
    AdlibRegister = 0x00; // register currently selected
    Position = 0;
    Timer1Started = FALSE;
    Timer2Started = FALSE;
    Status = 0x06;
}

VOID
FMStatusRead(
    BYTE *data
    )
{
#if 0 // This should work but doesn't (ReadFile fails)
        // Are we expecting a state change ?

        if (Timer1Started || Timer2Started) {
             // Read the status port from the driver - this is how the
             // driver interprets read.
             // Well, actually don't because the WSS driver doesn't work!

            if (!ReadFile(HFM, &Status, 1, &bytesRead, NULL)) {
#if DBG
                FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (char *) &lpMsgBuf, 0, NULL);
                dprintf1(("FM read port failed: %d bytes of data read, error message: %s",
                            bytesRead, lpMsgBuf));
                LocalFree( lpMsgBuf ); // Free the buffer.
#endif DBG
                break;
            }
            else {
                 // Look for state change

                if (Status & 0x40) {
                     Timer1Started = FALSE;
                     dprintf2(("Timer 1 finished"));
            }

                if (Status & 0x20) {
                    Timer2Started = FALSE;
                    dprintf2(("Timer 2 finished"));
            }
            }
        }
#endif
        *data = Status;
}

VOID
FMRegisterSelect(
    BYTE data
    )
{
    AdlibRegister = data;
}

VOID
FMDataWrite(
    BYTE data
    )
{
    if(AdlibRegister==AD_NEW) {
        data &=0xFE; // don't enter opl3 mode
    }

    // put data in PortData array
    if(Position <= BATCH_SIZE-2) {
        PortData[Position].IoPort = ADLIB_REGISTER_SELECT_PORT;
        PortData[Position].PortData = AdlibRegister;
        PortData[Position + 1].IoPort = ADLIB_DATA_PORT;
        PortData[Position + 1].PortData = data;
        Position += 2;
    } else {
        dprintf1(("Attempting to write beyond end of PortData array"));
    }

    if (Position == BATCH_SIZE ||
        AdlibRegister>=0xB0 && AdlibRegister<=0xBD ||
        AdlibRegister == AD_MASK) {
        // PortData full or note-on/off command or changing status
        if (!FMPortWrite()) {
            dprintf1(("Failed to write to device!"));
        } else {
            // Work out what status change may have occurred
            if (AdlibRegister == AD_MASK) {
                // Look for RST and starting timers
                if (data & 0x80) {
                    Status = 0x00; // reset both timers
            }

                // We ignore starting of timers if their interrupt
                // flag is set because the timer status will have to
                // be set again to make the status for this timer change

                if ((data & 1) && !(Status & 0x40)) {
                    dprintf2(("Timer 1 started"));
#if 0
                    Timer1Started = TRUE;
#else
                    Status |= 0xC0; // simulate immediate expiry of timer1
#endif
                } else {
                    Timer1Started = FALSE;
                }

                if ((data & 2) && !(Status & 0x20)) {
                    dprintf2(("Timer 2 started"));
#if 0
                    Timer2Started = TRUE;
#else
                    Status |= 0xA0; // simulate immediate expiry of timer2
#endif
                    Timer2Started = TRUE;
                } else {
                    Timer2Started = FALSE;
                }
           }
        }
    }
}

/*
*    Opens opl2 device adlib.mid or adlib.mid0 as a file handle.
*    Returns TRUE on success.
*/

BOOL
OpenFMDevice(
    VOID
    )
{
    DWORD dwBytesReturned;
    LPVOID lpMsgBuf;

    // attempt to open device file adlib.mid or adlib.mid0
    HFM = CreateFile(L"\\\\.\\adlib.mid", GENERIC_READ | GENERIC_WRITE,
      FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    if (HFM == INVALID_HANDLE_VALUE) {
        HFM = CreateFile(L"\\\\.\\adlib.mid0", GENERIC_READ | GENERIC_WRITE,
          FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    }

    if (HFM == INVALID_HANDLE_VALUE) {
#if DBG
        FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char *) &lpMsgBuf, 0, NULL);
        dprintf1(("Create FM out failed, error message: %s", lpMsgBuf));
        LocalFree( lpMsgBuf ); // Free the buffer.
#endif // DBG
        return FALSE;
    }
    FMActive = TRUE;
    return TRUE;
}

/***************************************************************************/

/*
*    Closes our FM device.
*/

VOID
CloseFMDevice(
    VOID
    )
{
    dprintf2(("Closing FM device"));

    if (HFM) {
        CloseHandle(HFM);
        HFM = NULL;
        FMActive = FALSE;
    }
}

/***************************************************************************/

/*
*    Sends FM data to the card.
*    Returns TRUE on success.
*/

BOOL
FMPortWrite(
    VOID
    )
{
    DWORD bytesWritten = 0;
    LPVOID lpMsgBuf;

    if(FMActive) {
        dprintf4(("Writing %d bytes of data to port",
          Position * sizeof(PortData[0])));
        if(!WriteFile(HFM, &PortData, Position * sizeof(PortData[0]),
          &bytesWritten, NULL)) {
#if DBG
            FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
              FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char *) &lpMsgBuf,
                0, NULL);

            dprintf1(("FM write failed: %d bytes of data written, error message: %s",
              bytesWritten, lpMsgBuf));
            LocalFree( lpMsgBuf ); // Free the buffer.
#endif //DBG
             return FALSE;
        }
    }
    Position = 0;
    return TRUE;
}

/***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\dsp.h ===
/***************************************************************************
*
*    dsp.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

/*
*    DSP Ports
*/

#define RESET_PORT          0x06        // used to reset SoundBlaster
#define READ_STATUS         0x0E        // 0xFF-data to read, 0x7F-no data to read
#define READ_DATA           0x0A        // App reads data from this port
#define WRITE_STATUS        0x0C        // 0x7f-port ready, 0xFF-port not ready
#define WRITE_PORT          0x0C        // Data or command

/*
*    Only implemented commands are defined
*/

/*
*    DSP commands - miscellaneous
*/

#define DSP_GET_VERSION     0xE1    // dsp version command
#define DSP_CARD_IDENTIFY   0xE0    // byte inverter
#define DSP_TABLE_MUNGE     0xE2    // jump table munging
#define DSP_LOAD_RES_REG    0xE4    // load byte into reserved register
#define DSP_READ_RES_REG    0xE8    // read byte from reserved register
#define DSP_GENERATE_INT    0xF2    // generate an interrupt

/*
*    DSP commands - speaker
*/

#define DSP_SPEAKER_ON      0xD1    // speaker on command
#define DSP_SPEAKER_OFF     0xD3    // speaker off command

/*
*    DSP commands - DMA mode
*/

#define DSP_SET_SAMPLE_RATE 0x40    // set the sample rate (one byte format)
#define DSP_SET_BLOCK_SIZE  0x48    // set dma block size
#define DSP_PAUSE_DMA       0xD0    // pause dma
#define DSP_CONTINUE_DMA    0xD4    // continue dma
#define DSP_STOP_AUTO       0xDA    // Stop auto init dma

#define DSP_WRITE           0x14    // Start single cycle output (8-bit PCM mono)
#define DSP_WRITE_HS        0x91    // Start single cycle high-speed output (8-bit PCM mono)
#define DSP_WRITE_AUTO      0x1C    // Start auto init output (8-bit PCM mono)
#define DSP_WRITE_HS_AUTO   0x90    // Start auto init high=speed output (8-bit PCM mono)
#define DSP_READ            0x24    // Start single cycle input (not implemented)

/*
*    Performance parameters for single and auto-init DMA fine tuning
*/
#define AUTO_BLOCK_SIZE     0x100   // size of each buffer in auto
#define DEFAULT_LOOKAHEAD   0x600   // target # of bytes to queue to kernel driver
#define MAX_WAVE_BYTES      0x2000  // maximum # of bytes to queue to kernel driver
#define SINGLE_PIECES       2       // number of pieces in each single write
#define SINGLE_SLEEP_ADJ    15      // number of overhead milliseconds in single


/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

/*
*    General function prototypes
*/

BOOL DspProcessAttach(VOID);
VOID DspProcessDetach(VOID);

VOID DspReadData(BYTE * data);
VOID DspReadStatus(BYTE * data);
VOID DspResetWrite(BYTE data);
VOID DspWrite(BYTE data);

void WriteCommandByte(BYTE command);
VOID ResetDSP(VOID);
void TableMunger(BYTE data);
DWORD GetSamplingRate(void);
void GenerateInterrupt(void);
void SetSpeaker(BOOL);

/*
*    Wave function prototypes
*/

UINT FindWaveDevice(void);
BOOL OpenWaveDevice(VOID);
void ResetWaveDevice(void);
void CloseWaveDevice(void);
BOOL TestWaveFormat(DWORD sampleRate);
BOOL SetWaveFormat(void);

void PauseDMA(void);
void ContinueDMA(void);
ULONG GetDMATransferAddress(void);
void SetDMAStatus(BOOL requesting, BOOL tc);

BOOL StartAutoWave(void);
void StopAutoWave(BOOL wait);
BOOL StartSingleWave(void);
void StopSingleWave(BOOL wait);
DWORD WINAPI AutoThreadEntry(LPVOID context);
DWORD WINAPI SingleThreadEntry(LPVOID context);
DWORD WINAPI SingleSynchThreadEntry(LPVOID context);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\dsp.c ===
/***************************************************************************
*
*    dsp.c
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*
***************************************************************************/


/*****************************************************************************
*
*    #includes
*
*****************************************************************************/

#include <windows.h>              // The VDD is a win32 DLL
#include <mmsystem.h>             // Multi-media APIs
#include <vddsvc.h>               // Definition of VDD calls
#include <vsb.h>
#include <dsp.h>


/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
//
extern SETVOLUMEPROC SetVolumeProc;
extern GETNUMDEVSPROC GetNumDevsProc;
extern GETDEVCAPSPROC GetDevCapsProc;
extern OPENPROC OpenProc;
extern RESETPROC ResetProc;
extern CLOSEPROC CloseProc;
extern GETPOSITIONPROC GetPositionProc;
extern WRITEPROC WriteProc;
extern PREPAREHEADERPROC PrepareHeaderProc;
extern UNPREPAREHEADERPROC UnprepareHeaderProc;

/*
 *    General globals
 */

extern HINSTANCE GlobalHInstance; // handle passed to dll entry point
BYTE IdentByte; // used with DSP_CARD_IDENTIFY
BOOL SpeakerOn = FALSE; // TRUE when speaker is on
BYTE ReservedRegister; // used with DSP_LOAD_RES_REG and DSP_READ_RES_REG
ULONG PageSize;         // size of pages for VirtualAlloc
ULONG iHdr;             // used to index wavehdr array

/*
 *    Event Globals
 */
HANDLE SingleWaveSem; // used by app to indicate data to write
HANDLE PauseEvent; // used to restart paused single
HANDLE ThreadStarted;  // signalled when thread starts running
HANDLE ThreadFinished; // signalled when thread exits

/*
 *    Wave globals
 */

UINT WaveOutDevice; // device identifier
HWAVEOUT HWaveOut = NULL; // the current open wave output device
PCMWAVEFORMAT WaveFormat = { { WAVE_FORMAT_PCM, 1, 0, 0, 1 }, 8};
DWORD TimeConstant = (256 - 1000000/11025); // one byte format
DWORD SBBlockSize = 0x800; // Block size set by apps, always size of transfer-1
DWORD LookAheadFactor = DEFAULT_LOOKAHEAD;

VDD_DMA_INFO dMAInfo;
DWORD dMAPhysicalStart; // the starting address for this transfer
DWORD dMACurrentPosition; // where we are currently reading from
DWORD dMAVirtualStart; // what the app thinks the addr is for this transfer
ULONG dMASize; // the size of the DMA memory-1

WAVEHDR * WaveHdrs; // pointer to allocated wave headers
BYTE * WaveData; // pointer to allocated wave buffer
ULONG TotalNumberOfBursts;
ULONG BurstsPerBlock;
ULONG DesiredBytesOutstanding;
ULONG BytesOutstanding = 0;
ULONG PhysicalBytesPlayed = 0;
ULONG LastBytesPlayedValue;

BOOL bDspActive = FALSE; // dsp thread currently active, changed with interlocked
BOOL bDspPause = FALSE;  // dsp paused, changed with interlocked
BOOL bDspReset = FALSE;  // dsp stopped, changed with interlocked


enum {
    Auto,
    Single
} DspMode;

/*****************************************************************************
*
*    State Machines
*
*****************************************************************************/

/*
*    DSP Reset State Machine
*/

enum {
    ResetNotStarted = 1,
    Reset1Written
}
ResetState = ResetNotStarted; // state of current reset

/*
*    DSP Write State Machine
*/

enum {
    WriteCommand = 1, // Initial state and after reset
    CardIdent,
    TableMunge,
    LoadResReg,
    SetTimeConstant,
    BlockSizeFirstByte,
    BlockSizeSecondByte,
    BlockSizeFirstByteWrite,
    BlockSizeSecondByteWrite,
    BlockSizeFirstByteRead,
    BlockSizeSecondByteRead
}
DSPWriteState = WriteCommand; // state of current command/data being written

/*
*    DSP Read State Machine
*/

enum {
    NothingToRead = 1, // initial state and after reset
    Reset,
    FirstVersionByte,
    SecondVersionByte,
    ReadIdent,
    ReadResReg
}
DSPReadState = NothingToRead; // state of current command/data being read


/*****************************************************************************
*
*    General Functions
*
*****************************************************************************/

BOOL
DspProcessAttach(
    VOID
    )
{
    HKEY hKey;
    ULONG dwType;
    ULONG cbData;
    SYSTEM_INFO SystemInfo;

    // create synchronization events
    PauseEvent=CreateEvent(NULL, FALSE, FALSE, NULL);
    SingleWaveSem=CreateSemaphore(NULL, 1, 100, NULL);
    ThreadStarted=CreateEvent(NULL, FALSE, FALSE, NULL);
    ThreadFinished=CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            VSBD_PATH,
                            0,
                            KEY_EXECUTE, // Requesting read access.
                            &hKey)) {


        cbData = sizeof(ULONG);
        RegQueryValueEx(hKey,
                        LOOKAHEAD_VALUE,
                        NULL,
                        &dwType,
                        (LPSTR)&LookAheadFactor,
                        &cbData);

        RegCloseKey(hKey);

    }

    // Allocate memory for wave buffer
    WaveData = (BYTE *) VirtualAlloc(NULL,
                                     64*1024,
                                     MEM_RESERVE,
                                     PAGE_READWRITE);

    if(WaveData == NULL ) {
        dprintf1(("Unable to allocate memory"));
        return(FALSE);
    }

    GetSystemInfo(&SystemInfo);
    PageSize = SystemInfo.dwPageSize;
    return TRUE;
}

VOID
DspProcessDetach(
    VOID
    )
{
    // stop any active threads
    StopAutoWave(FALSE);
    StopSingleWave(FALSE);
    // close synchronization events
    CloseHandle(PauseEvent);
    CloseHandle(SingleWaveSem);
    CloseHandle(ThreadStarted);
    CloseHandle(ThreadFinished);
    VirtualFree(WaveData, 0, MEM_RELEASE);
}


/***************************************************************************/

/*
*    Gets called when the application reads from port.
*    Returns results to application in data.
*/
VOID
DspReadStatus(
    BYTE * data
    )
{
    // See if we think there is something to read
    *data = DSPReadState != NothingToRead ? 0xFF : 0x7F;
}



VOID
DspReadData(
    BYTE * data
    )
{
    switch (DSPReadState) {
    case NothingToRead:
        *data = 0xFF;
        break;

    case Reset:
        *data = 0xAA;
        DSPReadState = NothingToRead;
        break;

    case FirstVersionByte:
        *data = (BYTE)(SB_VERSION / 256);
        DSPReadState = SecondVersionByte;
        break;

    case SecondVersionByte:
        *data = (BYTE)(SB_VERSION % 256);
        DSPReadState = NothingToRead;
        break;

    case ReadIdent:
        *data = ~IdentByte;
        DSPReadState = NothingToRead;
        break;

    case ReadResReg:
        *data = ReservedRegister;
        DSPReadState = NothingToRead;
        break;

    default:
        dprintf1(("Unrecognized read state"));
    }

}

/***************************************************************************/

/*
*    Gets called when an application writes data to port.
*/

VOID
DspResetWrite(
    BYTE data
    )
{
    if (data == 1) {
        ResetState = Reset1Written;
    }
    else {
        if (ResetState == Reset1Written && data == 0) {
            ResetState = ResetNotStarted;
            ResetAll(); // OK - reset everything
        }
    }
}

VOID
DspWrite(
    BYTE data
    )
{
    DWORD ddata;

    switch (DSPWriteState) {
    case WriteCommand:
        WriteCommandByte(data);
        break;

    case CardIdent:
        IdentByte = data;
        DSPReadState = ReadIdent;
        DSPWriteState = WriteCommand;
        break;

    case TableMunge:
        TableMunger(data);
        DSPWriteState = WriteCommand;
        break;

    case LoadResReg:
        ReservedRegister = data;
        DSPWriteState = WriteCommand;
        break;

    case SetTimeConstant:
        TimeConstant =  (DWORD)data;
        dprintf3(("Time constant is %X", TimeConstant));
        dprintf3(("Set sampling rate %d", GetSamplingRate()));
        DSPWriteState = WriteCommand;
        break;

    case BlockSizeFirstByte:
        SBBlockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByte;
        break;

    case BlockSizeSecondByte:
        ddata = data;
        SBBlockSize = SBBlockSize + (ddata << 8);
        DSPWriteState = WriteCommand;
        dprintf2(("Block size set to 0x%x", SBBlockSize));
        break;

    case BlockSizeFirstByteWrite:
        SBBlockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByteWrite;
        break;

    case BlockSizeSecondByteWrite:
        ddata = data;
        SBBlockSize = SBBlockSize + (ddata << 8);
        DSPWriteState = WriteCommand;
        dprintf3(("Block size set to 0x%x", SBBlockSize));
        // this is a hack to convince some apps a sb exists
        if(SBBlockSize==0) {
            VDM_TRACE(0x6a0,0,0);
            GenerateInterrupt();
        }
        StartSingleWave();
        break;

    case BlockSizeFirstByteRead:
        SBBlockSize = (DWORD)data;
        DSPWriteState = BlockSizeSecondByteRead;
        break;

    case BlockSizeSecondByteRead:
        ddata = data;
        SBBlockSize = SBBlockSize + (ddata << 8);
        DSPWriteState = WriteCommand;
        dprintf3(("Block size set to 0x%x", SBBlockSize));
        // this is a hack to convince some apps a sb exists
        if(SBBlockSize==0) {
            ULONG dMAPhysicalAddress;
            if((dMAPhysicalAddress=GetDMATransferAddress()) != -1L) {
                *(PUCHAR)dMAPhysicalAddress = 0x80;
            }
            VDM_TRACE(0x6a0,0,0);
            GenerateInterrupt();
        }
        break;
    }
}

/***************************************************************************/

/*
*  Handles commands sent to the DSP.
*/

VOID
WriteCommandByte(
    BYTE command
    )
{
    switch (command) {
    case DSP_GET_VERSION:
        dprintf2(("Command - Get Version"));
        DSPReadState = FirstVersionByte;
        break;

    case DSP_CARD_IDENTIFY:
        dprintf2(("Command - Identify"));
        DSPWriteState = CardIdent;
        break;

    case DSP_TABLE_MUNGE:
        dprintf2(("Command - DSP Table Munge"));
        DSPWriteState = TableMunge;
        break;

    case DSP_LOAD_RES_REG:
        dprintf2(("Command - Load Res Reg"));
        DSPWriteState = LoadResReg;
        break;

    case DSP_READ_RES_REG:
        dprintf2(("Command - Read Res Reg"));
        DSPReadState = ReadResReg;
        break;

    case DSP_GENERATE_INT:
        dprintf2(("Command - Generate interrupt DMA"));
        GenerateInterrupt();
        break;

    case DSP_SPEAKER_ON:
        dprintf2(("Command - Speaker ON"));
        SetSpeaker(TRUE);
        break;

    case DSP_SPEAKER_OFF:
        dprintf2(("Command - Speaker OFF"));
        SetSpeaker(FALSE);
        break;

    case DSP_SET_SAMPLE_RATE:
        dprintf3(("Command - Set Sample Rate"));
        DSPWriteState = SetTimeConstant;
        break;

    case DSP_SET_BLOCK_SIZE:
        dprintf2(("Command - Set Block Size"));
        DSPWriteState =  BlockSizeFirstByte;
        break;

    case DSP_PAUSE_DMA:
        dprintf2(("Command - Pause DMA"));
        PauseDMA();
        break;

    case DSP_CONTINUE_DMA:
        dprintf2(("Command - Continue DMA"));
        ContinueDMA();
        break;

    case DSP_STOP_AUTO:
        dprintf2(("Command - Stop DMA"));
        StopAutoWave(TRUE);
        break;

    case DSP_WRITE:
    case DSP_WRITE_HS:
        dprintf3(("Command - Write - non Auto"));
        DSPWriteState = BlockSizeFirstByteWrite;
        break;

    case DSP_WRITE_AUTO:
    case DSP_WRITE_HS_AUTO:
        dprintf2(("Command - Write - Auto"));
        StartAutoWave();
        break;

    case DSP_READ:
        dprintf3(("Command - Read - non Auto"));
        DSPWriteState = BlockSizeFirstByteRead;
        break;

    default:
        dprintf1(("Unrecognized DSP command %2X", command));
    }
}


/*****************************************************************************
*
*    Device manipulation and control routines
*
*****************************************************************************/

/*
*    Reset threads/globals/events/state-machines to initial state.
*/

VOID
ResetDSP(
    VOID
    )
{

    // Stop any active DMA threads
    StopAutoWave(TRUE);
    StopSingleWave(TRUE);

    // Set events and globals to initial state
    ResetEvent(PauseEvent);
    CloseHandle(SingleWaveSem);
    SingleWaveSem=CreateSemaphore(NULL, 1, 100, NULL);
    ResetEvent(ThreadStarted);
    ResetEvent(ThreadFinished);

    SetSpeaker(FALSE);
    SpeakerOn = FALSE;

    HWaveOut = NULL;
    TimeConstant = (256 - 1000000/11025);
    WaveFormat.wf.nSamplesPerSec = 0;
    WaveFormat.wf.nAvgBytesPerSec = 0;
    SBBlockSize = 0x800;

    bDspActive = FALSE;
    bDspReset = FALSE;
    bDspPause = FALSE;

    // Reset state machines
    DSPReadState = Reset;
    DSPWriteState = WriteCommand;
}

/***************************************************************************/

/*
*    Munges (changes) a jump table in apps code,
*    Algorithm from sbvirt.asm in MMSNDSYS.
*/

VOID
TableMunger(
    BYTE data
    )
{
    static BYTE TableMungeData;
    static BOOL TableMungeFirstByte = TRUE; // munging first or second byte
    BYTE comp, dataCopy;
    VDD_DMA_INFO dMAInfo;
    ULONG dMAPhysicalAddress;

    if(TableMungeFirstByte) {
        dprintf2(("Munging first byte"));
        dataCopy = data;
        dataCopy = dataCopy & 0x06;
        dataCopy = dataCopy << 1;
        if(data & 0x10) {
            comp = 0x40;
        }
        else {
            comp = 0x20;
        }
        comp = comp - dataCopy;
        data = data + comp;
        TableMungeData = data;

        // Update memory (code table) with munged data
        dprintf2(("Writing first byte"));
        if((dMAPhysicalAddress=GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get dma address"));
            return;
        }
        CopyMemory((PVOID)dMAPhysicalAddress, &data, 1);

        // Update virtual DMA status
        VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
          dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
          dMAInfo.mode, dMAInfo.mask));
        dMAInfo.count = dMAInfo.count - 1;
        dMAInfo.addr = dMAInfo.addr + 1;
        VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL,
          VDD_DMA_COUNT|VDD_DMA_ADDR, &dMAInfo);
        TableMungeFirstByte = FALSE;
    }
    else {
        dprintf2(("Munging second byte"));
        data = data ^ 0xA5;
        data = data + TableMungeData;
        TableMungeData = data;

        // Update memory (code table) with munged data
        dprintf2(("Writing second byte"));
        if((dMAPhysicalAddress=GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get dma address"));
            return;
        }
        CopyMemory((PVOID)dMAPhysicalAddress, &data, 1);

        // Update virtual DMA status
        VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
        dMAInfo.count = dMAInfo.count - 1;
        dMAInfo.addr = dMAInfo.addr + 1;
        VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL,
          VDD_DMA_COUNT|VDD_DMA_ADDR, &dMAInfo);
        if(dMAInfo.count==0xFFFF) {
            SetDMAStatus(FALSE, TRUE);
        }
        TableMungeFirstByte = TRUE;
    }
}

/***************************************************************************/

/*
*    Get sampling rate from time constant.
*    Returns sampling rate.
*/

DWORD
GetSamplingRate(
    VOID
    )
{
    // Sampling rate = 1000000 / (256 - Time constant)
    return(1000000 / (256 - TimeConstant));
}

/***************************************************************************/

/*
*    Generate device interrupt on dma channel SM_INTERRUPT on ICA_MASTER device.
*/

VOID
GenerateInterrupt(
    VOID
    )
{
    // Generate an interrupt on the master controller
    dprintf3(("Generating interrupt"));
    VDM_TRACE(0x6a1,0,0);
    VDDSimulateInterrupt(ICA_MASTER, SB_INTERRUPT, 1);
}

/***************************************************************************/

/*
*    Sets the speaker on or off.
*/

VOID
SetSpeaker(
    BOOL On
    )
{
    if (HWaveOut) {
        if(On) {
            SetVolumeProc(HWaveOut, (DWORD)0x77777777UL);
            SpeakerOn = TRUE;
    }
        else {
            SetVolumeProc(HWaveOut, (DWORD)0x00000000UL);
            SpeakerOn = FALSE;
        }
    }

    return;
}


/****************************************************************************
*
*    Wave device routines
*
****************************************************************************/

/*
*    Find a suitable wave output device.
*    Returns device or NO_DEVICE_FOUND if none found.
*/

UINT
FindWaveDevice(
    VOID
    )
{
    UINT numDev;
    UINT device;
    WAVEOUTCAPS wc;

    numDev = GetNumDevsProc();

    for (device = 0; device < numDev; device++) {
        if (MMSYSERR_NOERROR == GetDevCapsProc(device, &wc, sizeof(wc))) {
            // Need 11025 and 44100 for device
            if ((wc.dwFormats & (WAVE_FORMAT_1M08 | WAVE_FORMAT_4M08)) ==
              (WAVE_FORMAT_1M08 | WAVE_FORMAT_4M08)) {
                WaveOutDevice = device;
                return TRUE;
            }
        }
    }

    dprintf1(("Wave device not found"));
    return FALSE;
}

/***************************************************************************/

/*
*    Open wave device and start synchronization thread.
*    Returns TRUE on success.
*/

BOOL
OpenWaveDevice(
    VOID
    )
{
    UINT rc;
    HANDLE tHandle;

    rc = OpenProc(&HWaveOut, (UINT)WaveOutDevice, (LPWAVEFORMATEX)
                         &WaveFormat, 0, 0, CALLBACK_NULL);

    if (rc != MMSYSERR_NOERROR) {
        dprintf1(("Failed to open wave device - code %d", rc));
        return FALSE;
    }

    BytesOutstanding = 0;
    PhysicalBytesPlayed = 0;
    return TRUE;
}

/***************************************************************************/

/*
*    Reset wave device.
*/

VOID
ResetWaveDevice(
    VOID
    )
{
    // No synchronization required

    dprintf2(("Resetting wave device"));
    if (HWaveOut) {
        if(MMSYSERR_NOERROR != ResetProc(HWaveOut)) {
            dprintf1(("Unable to reset wave out device"));
        }
    }
}

/***************************************************************************/

/*
*    Shut down and close wave device.
*/

VOID
CloseWaveDevice(
    VOID
    )
{

    dprintf2(("Closing wave device"));

    ResetWaveDevice();

    if (HWaveOut) {
        if(MMSYSERR_NOERROR != CloseProc(HWaveOut)) {
            dprintf1(("Unable to close wave out device"));
        } else {
            HWaveOut = NULL;
            dprintf2(("Wave out device closed"));
        }
    }
}

/***************************************************************************/

/*
*    Returns TRUE if current wave device supports sample rate.
*/

BOOL
TestWaveFormat(
    DWORD sampleRate
    )
{
    PCMWAVEFORMAT format;

    format = WaveFormat;
    format.wf.nSamplesPerSec = sampleRate;
    format.wf.nAvgBytesPerSec = sampleRate;

    return(MMSYSERR_NOERROR == OpenProc(NULL, (UINT)WaveOutDevice,
                                        (LPWAVEFORMATEX) &format,
                                        0, 0, WAVE_FORMAT_QUERY));
}

/***************************************************************************/

/*
*    Make sure we've got a device that matches the current sampling rate.
*    Returns TRUE if device does NOT support current sampling rate and
*    wave format has changed, otherwise returns FALSE
*/

BOOL
SetWaveFormat(
    VOID
    )
{
    DWORD sampleRate;
    DWORD testValue;
    UINT i = 0;

    if (TimeConstant != 0xFFFF) {
        // time constant has been reset since last checked
        sampleRate = GetSamplingRate();
        dprintf3(("Requested sample rate is %d", sampleRate));

        if (sampleRate != WaveFormat.wf.nSamplesPerSec) {  // format has changed
            if (!TestWaveFormat(sampleRate)) {
                 dprintf3(("Finding closest wave format"));
                 // find some format that works and is close to requested
                 for(i=0; i<50000; i++) {
                     testValue = sampleRate-i;
                     if(TestWaveFormat(testValue)) {
                         sampleRate = testValue;
                         break;
                     }
                     testValue = sampleRate+i;
                     if(TestWaveFormat(testValue)) {
                         sampleRate = testValue;
                         break;
                     }
                 }
                 if(sampleRate!=testValue) {
                     dprintf1(("Unable to find suitable wave format"));
                     return FALSE;
                 }
            }

            // Set the new format if it's changed
            if (sampleRate != WaveFormat.wf.nSamplesPerSec) {
                   dprintf2(("Setting %d samples per second", sampleRate));
                   WaveFormat.wf.nSamplesPerSec = sampleRate;
                   WaveFormat.wf.nAvgBytesPerSec = sampleRate;
                   TimeConstant = 0xFFFF;
                   return TRUE;
            }
        }
    }

    TimeConstant = 0xFFFF;
    return FALSE;
}

/***************************************************************************/

/*
*    Stops auto init DMA, or pauses single cycle DMA.
*/

VOID
PauseDMA(
    VOID
    )
{
    DWORD position = 0;
    MMTIME mmTime;

    dprintf2(("Pausing DMA"));

    switch(DspMode) {
    case Auto:
        StopAutoWave(TRUE); // simply stop auto dma
        break;

    case Single:
        ResetEvent(PauseEvent);
        InterlockedExchange(&bDspPause, 1);
    }
}

/***************************************************************************/

/*
*    Start auto init DMA, or continues single cycle DMA.
*/

VOID
ContinueDMA(
    VOID
    )
{

    switch(DspMode) {
    case Auto:
        StartAutoWave();
        break;

    case Single:
        SetEvent(PauseEvent);
    }
}

/***************************************************************************/

/*
*    Get DMA transfer address.
*    Returns transfer address or -1 on failure.
*/

ULONG
GetDMATransferAddress(
    VOID
    )
{
    ULONG address;
    VDD_DMA_INFO dMAInfo;

    if (VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo)) {
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
          dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
          dMAInfo.mode, dMAInfo.mask));

        // convert from 20 bit address to 32 bit address
        address = (((DWORD)dMAInfo.page) << (12 + 16)) + dMAInfo.addr;
        // get VDM pointer
        address = (ULONG)GetVDMPointer(address, ((DWORD)dMAInfo.count) + 1, 0);

        dprintf3(("Transfer address = %8X", (DWORD)address));

        return(address);
    }
    else {
        dprintf1(("Could not retrieve DMA Info"));
        return(ULONG)(-1L);
    }
}


/***************************************************************************/

/*
*    Update the virtual DMA terminal count and request status.
*    Terminal count (tc) is set when DMA count loops to 0xFFFF.
*    Request status is set when DMA has data to transfer
*    (ignored in auto-init DMA).
*/

VOID
SetDMAStatus(
    BOOL requesting,
    BOOL tc
    )
{
    VDD_DMA_INFO dMAInfo;

    if (VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo)) {
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
          dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
          dMAInfo.mode, dMAInfo.mask));

        if (requesting) {
            dMAInfo.status |= (0x10 << SB_DMA_CHANNEL); // Requesting
            dprintf3(("DMA set as requesting"));
        } else {
            dMAInfo.status &= ~(0x10 << SB_DMA_CHANNEL); // Not Requesting
            dprintf3(("DMA set as not requesting"));
        }

        if (tc) {
            dMAInfo.status |= (1 << SB_DMA_CHANNEL); // tc reached
            dprintf3(("DMA set as terminal count reached"));
        } else {
            dMAInfo.status &= ~(1 << SB_DMA_CHANNEL); // tc not reached
            dprintf3(("DMA set as terminal count not reached"));
        }
        VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, VDD_DMA_STATUS,
          &dMAInfo);
    }
    else {
        dprintf1(("Could not retrieve DMA Info"));
    }
}


/***************************************************************************/

/*
*    Start an auto wave.
*    Returns TRUE on success.
*/

BOOL
StartAutoWave(
    VOID
    )
{
    HANDLE tHandle;  // handle to auto thread
    VDD_DMA_INFO dMAInfo;
    ULONG i;
    DWORD id;

    dprintf2(("Starting auto wave"));
    StopSingleWave(TRUE);

    DspMode = Auto;

    // Open device
    SetWaveFormat();
    if (!OpenWaveDevice()) {
        dprintf1(("Can't open wave device", GetLastError()));
        return FALSE;
    }


    if(!(tHandle = CreateThread(NULL, 0, AutoThreadEntry, NULL,
      CREATE_SUSPENDED, &id))) {
        dprintf1(("Create auto thread failed code %d", GetLastError()));
        return FALSE;
    } else {
        if(!SetThreadPriority(tHandle, THREAD_PRIORITY_HIGHEST)) {
            dprintf1(("Unable to set auto thread priority"));
        }
    }

    ResumeThread(tHandle);
    CloseHandle(tHandle);
    WaitForSingleObject(ThreadStarted, INFINITE);

    return TRUE;
}


/***************************************************************************/

/*
*    Stop Auto thread,
*    Should always be called with TRUE,
*    except if process exiting as wait causes deadlock
*/

VOID
StopAutoWave(
    BOOL wait
    )
{
    if(bDspActive && (DspMode == Auto)) {
        dprintf2(("Stopping auto init"));
        InterlockedExchange(&bDspReset, TRUE);
        if(wait) {
            dprintf2(("Waiting for auto thread to exit"));
            WaitForSingleObject(ThreadFinished, INFINITE);
            dprintf2(("Auto thread has exited"));
        }
    }
}


/***************************************************************************/

/*
*    Start a single cycle wave.
*    Returns TRUE on success.
*/

BOOL
StartSingleWave(
    VOID
    )
{
    HANDLE tHandle; // handle to single thread
    DWORD id;
    ULONG i;

    StopAutoWave(TRUE);

    DspMode = Single;

    if(!bDspActive) {
        dprintf2(("Starting single cycle wave"));
        if(!(tHandle = CreateThread(NULL, 0, SingleThreadEntry, NULL,
                                    CREATE_SUSPENDED, &id))) {

            dprintf1(("Create single cycle thread failed code %d", GetLastError()));
            return FALSE;

        } else {
            // set synchronization events to a known state
            InterlockedExchange(&bDspActive, TRUE);
            InterlockedExchange(&bDspPause, FALSE);
            InterlockedExchange(&bDspReset, FALSE);

            CloseHandle(SingleWaveSem);
            SingleWaveSem=CreateSemaphore(NULL, 1, 100, NULL);

            if(!SetThreadPriority(tHandle, THREAD_PRIORITY_HIGHEST)) {
                dprintf1(("Unable to set thread priority"));
            }
            ResumeThread(tHandle);
            CloseHandle(tHandle);

            WaitForSingleObject(ThreadStarted, INFINITE);
            return TRUE;
        }
    } else {
        ContinueDMA(); // if app has paused dma
        ReleaseSemaphore(SingleWaveSem, 1, NULL); // new buffer to be written
        return TRUE;
    }
    Sleep(500);
}


/***************************************************************************/

/*
*    Stop single cycle thread,
*    Should always be called with TRUE,
*    except if process exiting as wait causes deadlock.
*/

VOID
StopSingleWave(
    BOOL wait
    )
{

    if(bDspActive && (DspMode == Single)) {
        dprintf2(("Stopping single wave"));
        InterlockedExchange(&bDspReset, TRUE);

        ContinueDMA(); // if app has paused DMA
        ReleaseSemaphore(SingleWaveSem, 1, NULL);

        if(wait) {
            dprintf2(("Waiting for single thread to exit"));
            WaitForSingleObject(ThreadFinished, INFINITE);
            dprintf2(("Single thread has exited"));
        }
    }
}


/***************************************************************************/

/*
 *    GetWaveOutPosition
*/

BOOL
GetWaveOutPosition(
    PULONG pPos
    )
{
    MMTIME mmTime;

    mmTime.wType = TIME_BYTES;

    if (MMSYSERR_NOERROR == GetPositionProc(HWaveOut, &mmTime, sizeof(MMTIME))) {
        VDM_TRACE(0x640, 0x640, mmTime.u.cb);
        *pPos = mmTime.u.cb;
        return TRUE;
    }
    return FALSE;
}

VOID
WaitOnWaveOutIdle(
    VOID
    )
{
    ULONG LastBytesPlayedValue = 0;
    ULONG PhysicalBytesPlayed;
    //
    // Allow the device to finish playing current sounds before nuking buffers
    //
    while(GetWaveOutPosition(&PhysicalBytesPlayed)) {
        if (LastBytesPlayedValue == PhysicalBytesPlayed) {
            break;  // no sounds are playing
        }
        LastBytesPlayedValue = PhysicalBytesPlayed;
        Sleep(1);
    }
}

/***************************************************************************/

/*
 *    WriteBurst
*/

BOOL
WriteBurst(
    WAVEHDR * WaveHdr
    )
{
    MMRESULT mmResult;

    // Copy data to current buffer
    dprintf3(("Copying data to buffer %8X from %4X", WaveHdr->lpData,
               dMACurrentPosition));

    RtlCopyMemory(WaveHdr->lpData,
                  (CONST VOID *)dMACurrentPosition,
                  WaveHdr->dwBufferLength);

    dMACurrentPosition += WaveHdr->dwBufferLength;

    // Update virtual DMA status
    dMAInfo.count = (WORD)(dMASize - (dMACurrentPosition-dMAPhysicalStart));
    dMAInfo.addr = (WORD)(dMAVirtualStart +
                   (dMACurrentPosition-dMAPhysicalStart));
    dprintf3(("Updated Dma Position = %4X, count = %4X", dMAInfo.addr,
             dMAInfo.count));

    VDDSetDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL,
              VDD_DMA_COUNT|VDD_DMA_ADDR, &dMAInfo);

    if(dMACurrentPosition >= dMAPhysicalStart+dMASize) {
        // looped in DMA buffer
        dMACurrentPosition = dMAPhysicalStart;
    }

    // Actually write the data
    VDM_TRACE(0x603, (USHORT)WaveHdr->dwBufferLength, (ULONG)WaveHdr);

    mmResult = WriteProc(HWaveOut, WaveHdr, sizeof(WAVEHDR));

    return (mmResult == MMSYSERR_NOERROR);
}

/***************************************************************************/

/*
 *  GenerateHdrs
 *      Build an array of MM wavehdrs and corresponding buffers
*/

#define AUTO TRUE
#define SINGLE FALSE
BOOL
GenerateHdrs(
    BOOL bAuto
    )
{
    static ULONG committedMemorySize = 0;
    ULONG DesiredCommit;
    ULONG BurstBufferSize;
    ULONG BlocksPerGroup = 1;
    ULONG NumberOfGroups = 1;
    ULONG BurstSize; // minimum(AUTO_BLOCK_SIZE, SBBLockSize+1)
    ULONG lastBurst = 0; // the size of the last buffer
    BYTE *pDataInit;
    ULONG i;

    if(AUTO_BLOCK_SIZE > SBBlockSize+1) { // block size is no > than SBBlockSize+1
        BurstSize = SBBlockSize+1;
    } else {
        BurstSize = AUTO_BLOCK_SIZE;
    }

    DesiredBytesOutstanding = LookAheadFactor;

    BurstsPerBlock = (SBBlockSize+1)/BurstSize;
    BurstBufferSize = BurstsPerBlock*BurstSize;

    if((lastBurst = (SBBlockSize+1)%BurstSize) > 0 ) {
        BurstsPerBlock++;
        BurstBufferSize+=lastBurst;
    }

    BlocksPerGroup = (dMASize+1)/(SBBlockSize+1);
    if ((dMASize+1)%(SBBlockSize+1)) {
        dprintf2(("Error: SB block size not an integral factor of DMA size"));
        return FALSE;
    }

    NumberOfGroups = MAX_WAVE_BYTES / (dMASize+1);
    if (!NumberOfGroups) {
        NumberOfGroups = 1;
    }

    TotalNumberOfBursts = NumberOfGroups * BlocksPerGroup * BurstsPerBlock;

    //
    // Make sure the # of wavehdrs doesn't get out of hand
    //
    while((TotalNumberOfBursts > 256) && (NumberOfGroups > 1)) {

        NumberOfGroups /= 2;
        TotalNumberOfBursts = NumberOfGroups * BlocksPerGroup * BurstsPerBlock;

    }

    BurstBufferSize *= NumberOfGroups * BlocksPerGroup;

    dprintf2(("%d groups of %d blocks of %d bursts of size %X, remainder burst=%X", NumberOfGroups, BlocksPerGroup, BurstsPerBlock, BurstSize, lastBurst));

    DesiredCommit = ((BurstBufferSize+PageSize-1)/PageSize)*PageSize;
    dprintf2(("Total burst buffer size is %X bytes, rounding to %X", BurstBufferSize, DesiredCommit));

    if (DesiredCommit > committedMemorySize) {

        if (!VirtualAlloc(WaveData+committedMemorySize,
                          DesiredCommit-committedMemorySize,
                          MEM_COMMIT,
                          PAGE_READWRITE)) {
            dprintf1(("Unable to commit memory"));
            return(FALSE);
        }

        committedMemorySize = DesiredCommit;

    } else if (DesiredCommit < committedMemorySize) {

        if (VirtualFree(WaveData+DesiredCommit,
                          committedMemorySize-DesiredCommit,
                          MEM_DECOMMIT)) {
            committedMemorySize = DesiredCommit;
        } else {
            dprintf1(("Unable to decommit memory"));
        }

    }

    // malloc autoWaveHdrs
    WaveHdrs = (WAVEHDR *) VirtualAlloc(NULL,
                                        TotalNumberOfBursts*sizeof(WAVEHDR),
                                        MEM_RESERVE | MEM_COMMIT,
                                        PAGE_READWRITE);

    if(WaveHdrs == NULL) {
        dprintf1(("Unable to allocate memory"));
        return(FALSE);
    }

    //
    // Prepare autoWaveHdrs
    //
    pDataInit = WaveData;
    for (i=0; i<TotalNumberOfBursts; i++) {
        if ((!lastBurst) || ((i+1) % BurstsPerBlock)) {
            WaveHdrs[i].dwBufferLength = BurstSize;
        } else {
            WaveHdrs[i].dwBufferLength = lastBurst;
        }
        WaveHdrs[i].lpData = pDataInit;
        WaveHdrs[i].dwFlags = 0;
        PrepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
        pDataInit = (BYTE *) ((ULONG)pDataInit + WaveHdrs[i].dwBufferLength);
        BurstBufferSize += WaveHdrs[i].dwBufferLength;
    }

    //
    // Initialize iHdr for DspProcessBlock
    //
    iHdr = TotalNumberOfBursts-1;
    return TRUE;
}

/***************************************************************************/

/*
 *  ProcessBlock
 *      Process a single block of data as defined by the SB block transfer size
*/

VOID
DspProcessBlock(
    VOID
    )
{
    ULONG i;

    // Write the data, keeping DMA status current
    for (i=0; i<BurstsPerBlock; i++) {

        //
        // Make sure we aren't getting too far ahead
        //
        if (BytesOutstanding > (PhysicalBytesPlayed + DesiredBytesOutstanding)) {

            LastBytesPlayedValue = 0;
            while(1) {
                if (!GetWaveOutPosition(&PhysicalBytesPlayed)) {
                    break;  // ERROR
                }
                if (BytesOutstanding <= (PhysicalBytesPlayed + DesiredBytesOutstanding)) {
                    break;
                }
                if (LastBytesPlayedValue == PhysicalBytesPlayed) {
                    break;  // no sounds are playing
                }
                LastBytesPlayedValue = PhysicalBytesPlayed;
                Sleep(1);
            }
        }

        //
        // Queue next buffer
        //
        iHdr = (iHdr+1)%TotalNumberOfBursts;

        VDM_TRACE(0x601, (USHORT)iHdr, TotalNumberOfBursts);
        VDM_TRACE(0x602, (USHORT)iHdr, dMACurrentPosition);

        if (WriteBurst(&WaveHdrs[iHdr])) {
            BytesOutstanding += WaveHdrs[iHdr].dwBufferLength;
            VDM_TRACE(0x604, (USHORT)iHdr, BytesOutstanding);
        } else {
            VDM_TRACE(0x684, (USHORT)iHdr, BytesOutstanding);
        }

        // Check if we should pause
        if(bDspPause) {
            dprintf3(("Waiting for paused event"));
            WaitForSingleObject(PauseEvent, INFINITE);
            dprintf3(("Paused event received"));
            InterlockedExchange(&bDspPause, 0);
        }

        // Check if we should keep going
        if(bDspReset) {
            return;
        }
    }

    // Check if we should keep going
    if(bDspReset) {
        return;
    }

    // Generate interrupt
    if(dMAInfo.count==0xFFFF) { // end of DMA buffer
        SetDMAStatus(FALSE, TRUE);
    }

    VDM_TRACE(0x6a3,0,0);
    GenerateInterrupt();

    //
    // This sleep gives the app thread some time to catch up with the interrupt.
    // Granted this is an inexact method for doing this, but it empirically
    // seems to be good enough for most apps.
    //
    Sleep(1);
    if(dMAInfo.count==0xFFFF) { // end of DMA buffer
        SetDMAStatus(FALSE, FALSE);
    }
}

/***************************************************************************/

/*
*    Auto-init DMA thread.
*/

DWORD WINAPI
AutoThreadEntry(
    LPVOID context
    )
{
    ULONG i;

    dprintf2(("Auto thread starting"));
    VDM_TRACE(0x600, 0, 0);

    bDspActive = TRUE;
    SetEvent(ThreadStarted);

    //
    // Initialize DMA information
    //
    VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
    dMAVirtualStart = dMAInfo.addr;
    dMASize = dMAInfo.count;
    if((dMAPhysicalStart=GetDMATransferAddress()) == -1L) {
        dprintf1(("Unable to get dma address"));
        return(FALSE);
    }

    dprintf2(("DMA Physical Start is %4X, DMA size is %4X", dMAPhysicalStart,
             dMASize));
    dMACurrentPosition = dMAPhysicalStart;
    SetDMAStatus(FALSE, FALSE);

    //
    // Calculate NumberOfBursts in the current run
    //
    if (!GenerateHdrs(AUTO)) {
        return FALSE;
    }

    //
    // Start looping on the buffer
    //

    while(!bDspReset) {
        DspProcessBlock();
    }

    WaitOnWaveOutIdle();
    //
    // Reset and close the device
    //
    CloseWaveDevice();

    // Clean up hdrs and events
    for(i=0; (ULONG)i<TotalNumberOfBursts; i++) {
        UnprepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
    }

    // Clean up memory
    VirtualFree(WaveHdrs, 0, MEM_RELEASE);

    bDspActive = FALSE;
    SetEvent(ThreadFinished);
    dprintf2(("Auto thread exiting"));
    return(0);
}


/***************************************************************************/

/*
*  Single cycle DMA thread.
*/

DWORD WINAPI
SingleThreadEntry(
    LPVOID context
    )
{
    ULONG LastSBBlockSize = 0;
    BOOL BlockSizeChanged; // set to TRUE if Size has changed
    BOOL WaveFormatChanged;
    BOOL HdrsInvalid = TRUE;
    ULONG i;

    dprintf2(("Single cycle thread starting"));
    bDspActive = TRUE;
    SetEvent(ThreadStarted);

    while (!bDspReset) {
        // Wait until app wants to transfer more data
        dprintf3(("Waiting for single wave semaphore"));
        WaitForSingleObject(SingleWaveSem, INFINITE);
        dprintf3(("Single wave semaphore received"));

        // Check if we should pause
        if(bDspPause) {
            dprintf3(("Waiting for paused event"));
            WaitForSingleObject(PauseEvent, INFINITE);
            dprintf3(("Paused event received"));
            InterlockedExchange(&bDspPause, 0);
        }

        // Check if we should keep going
        if(bDspReset) {
            break; // break out of loop
        }

        // Initialize for this run
        VDDQueryDMA((HANDLE)GlobalHInstance, SB_DMA_CHANNEL, &dMAInfo);
        dprintf4(("DMA Info : addr  %4X, count %4X, page %4X, status %2X, mode %2X, mask %2X",
                 dMAInfo.addr, dMAInfo.count, dMAInfo.page, dMAInfo.status,
                 dMAInfo.mode, dMAInfo.mask));
        dMAVirtualStart = dMAInfo.addr;
        dMASize = dMAInfo.count;

        if(dMAInfo.count == 0xFFFF || dMAInfo.count == 0) {
            continue; // next iteration of loop, app doesn't have data to transfer
        }

        if ((dMAPhysicalStart = GetDMATransferAddress()) == -1L) {
            dprintf1(("Unable to get transfer address"));
            continue; // next iteration of loop
        }

        dprintf3(("DMA Physical Start is %4X, DMA size is %4X",
                 dMAPhysicalStart, dMASize));
        dMACurrentPosition = dMAPhysicalStart;

        if(LastSBBlockSize != SBBlockSize) {
            LastSBBlockSize = SBBlockSize;
            BlockSizeChanged = TRUE;
        } else {
            BlockSizeChanged = FALSE;
        }

        WaveFormatChanged = SetWaveFormat();

        // If we're changing our device
        if ((WaveFormatChanged || BlockSizeChanged) && (HWaveOut != NULL)) {
            dprintf3(("Single-Cycle Parameters changed"));

            WaitOnWaveOutIdle();

            HdrsInvalid = TRUE;
            for(i=0; (ULONG)i<TotalNumberOfBursts; i++) {
                UnprepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
            }
            VirtualFree(WaveHdrs, 0, MEM_RELEASE);
            if (WaveFormatChanged) {
                CloseWaveDevice();
            }
        }

        if (HWaveOut == NULL) {
            OpenWaveDevice();
        }

        if (HdrsInvalid) {
            if (GenerateHdrs(SINGLE)) {
                HdrsInvalid = FALSE;
            } else {
                return FALSE;
            }
        }

        // show dma as requesting
        SetDMAStatus(TRUE, FALSE);

        DspProcessBlock();

    }

    WaitOnWaveOutIdle();

    //
    // Reset and close the device
    //
    CloseWaveDevice();

    // Clean up hdrs and events
    for(i=0; (ULONG)i<TotalNumberOfBursts; i++) {
        UnprepareHeaderProc(HWaveOut, &WaveHdrs[i], sizeof(WAVEHDR));
    }

    // Clean up memory
    VirtualFree(WaveHdrs, 0, MEM_RELEASE);

    bDspActive = FALSE;
    SetEvent(ThreadFinished);
    dprintf2(("Single cycle wave is exiting"));
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\mixer.h ===
/***************************************************************************
*
*    mixer.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

/*
*    Mixer Ports
*/

#define MIXER_ADDRESS       0x04        // Mixer address port
#define MIXER_DATA          0x05        // Mixer data port

/*
*    Mixer Commands
*/

#define MIXER_RESET         0x00    // reset mixer to initial state
#define MIXER_MASTER_VOLUME 0x02    // set master volume
#define MIXER_FM_VOLUME     0x06    // set opl2 volume
#define MIXER_CD_VOLUME     0x08    // set cd volume
#define MIXER_VOICE_VOLUME  0x0A    // set wave volume

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

void ResetMixer(void);
void MixerSetMasterVolume(BYTE level);
void MixerSetVoiceVolume(BYTE level);

VOID
MixerDataRead(
    BYTE *pData
    );

VOID
MixerDataWrite(
    BYTE data
    );

VOID
MixerAddrWrite(
    BYTE data
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdd\vsndblst\vsb.h ===
/***************************************************************************
*
*    vsb.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/


/*****************************************************************************
*
*    #defines
*
*****************************************************************************/

#define VSBD_PATH TEXT("System\\CurrentControlSet\\Control\\VirtualDeviceDrivers\\SoundBlaster")
#define LOOKAHEAD_VALUE TEXT("LookAhead")

/*
*    Hardware and version information
*    In DOS terms: SET BLASTER=A220 I5 D1 T3
*/

#define SB_VERSION          0x201       // SB 2.0 (DSP 2.01+)
#define SB_INTERRUPT        0x05        // Interrupt 5
#define SB_DMA_CHANNEL      0x01        // DMA Channel 1
#define NO_DEVICE_FOUND     0xFFFF      // returned if no device found

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

/*
*    General function prototypes
*/

void VddDbgOut(LPSTR lpszFormat, ...);
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD reason, LPVOID reserved);
BOOL InstallIoHook(HINSTANCE hInstance);
void DeInstallIoHook(HINSTANCE hInstance);
VOID VsbByteIn(WORD port, BYTE * data);
VOID VsbByteOut(WORD port, BYTE data);
VOID ResetAll(VOID);

/*****************************************************************************
*
*    Globals
*
*****************************************************************************/

//
// Definitions for MM api entry points. The functions will be linked
// dynamically to avoid bringing winmm.dll in before wow32.
//

typedef MMRESULT (WINAPI* SETVOLUMEPROC)(HWAVEOUT, DWORD);
typedef UINT (WINAPI* GETNUMDEVSPROC)(VOID);
typedef MMRESULT (WINAPI* GETDEVCAPSPROC)(UINT, LPWAVEOUTCAPSW, UINT);
typedef MMRESULT (WINAPI* OPENPROC)(LPHWAVEOUT, UINT, LPCWAVEFORMATEX, DWORD, DWORD, DWORD);
typedef MMRESULT (WINAPI* RESETPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* CLOSEPROC)(HWAVEOUT);
typedef MMRESULT (WINAPI* GETPOSITIONPROC)(HWAVEOUT, LPMMTIME, UINT);
typedef MMRESULT (WINAPI* WRITEPROC)(HWAVEOUT, LPWAVEHDR, UINT);
typedef MMRESULT (WINAPI* PREPAREHEADERPROC)(HWAVEOUT, LPWAVEHDR, UINT);
typedef MMRESULT (WINAPI* UNPREPAREHEADERPROC)(HWAVEOUT, LPWAVEHDR, UINT);

/*****************************************************************************
*
*    Debugging
*    Levels:
*    1 - errors only
*    2 - significant events
*    3 - regular events
*    4 - heaps o' information
*
*****************************************************************************/

#if DBG

    extern int VddDebugLevel;
    #define dprintf( _x_ )                          VddDbgOut _x_
    #define dprintf1( _x_ ) if (VddDebugLevel >= 1) VddDbgOut _x_
    #define dprintf2( _x_ ) if (VddDebugLevel >= 2) VddDbgOut _x_
    #define dprintf3( _x_ ) if (VddDebugLevel >= 3) VddDbgOut _x_
    #define dprintf4( _x_ ) if (VddDebugLevel >= 4) VddDbgOut _x_

#else

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\common.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Main header file for vdmdbg

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it
--*/


#if DBG
#define DEBUG   1
#endif

#define TOOL_HMASTER    0       // Offset to hGlobalHeap (in kdata.asm)
#define TOOL_HMODFIRST  4       // Offset to hExeHead (in kdata.asm)
#define TOOL_HEADTDB    14      // Offset to headTDB (in kdata.asm)
#define TOOL_HMASTLEN   22      // Offset to SelTableLen (in kdata.asm)
#define TOOL_HMASTSTART 24      // Offset to SelTableStart (in kdata.asm)

#define HI_FIRST        6       // Offset to hi_first in heap header
#define HI_SIZE         24      // Size of HeapInfo structure

#define GI_LRUCHAIN     2       // Offset to gi_lruchain in heap header
#define GI_LRUCOUNT     4       // Offset to gi_lrucount in heap header
#define GI_FREECOUNT    16      // Offset to gi_free_count in heap header

#define GA_COUNT        0       // Offset to ga_count in arena header
#define GA_OWNER386     18      // Offset to "pga_owner member in globalarena

#define GA_OWNER        1       // Offset to "owner" member within Arena

#define GA_FLAGS        5       // Offset to ga_flags in arena header
#define GA_NEXT         9       // Offset to ga_next in arena header
#define GA_HANDLE       10      // Offset to ga_handle in arena header
#define GA_LRUNEXT      14      // Offset to ga_lrunext in arena header
#define GA_FREENEXT     GA_LRUNEXT  // Offset to ga_freenext in arena header

#define GA_SIZE         16      // Size of the GlobalArena structure

#define LI_SIG          HI_SIZE+10  // Offset to signature
#define LI_SIZE         HI_SIZE+12  // Size of LocalInfo structure
#define LOCALSIG        0x4C48  // 'HL' Signature

#define TDB_next        0       // Offset to next TDB in TDB
#define TDB_PDB         72      // Offset to PDB in TDB

#define GF_PDB_OWNER    0x100   // Low byte is kernel flags

#define NEMAGIC         0x454E  // 'NE' Signature

#define NE_MAGIC        0       // Offset to NE in module header
#define NE_USAGE        2       // Offset to usage
#define NE_CBENTTAB     6       // Offset to cbenttab (really next module ptr)
#define NE_PATHOFFSET   10      // Offset to file path stuff
#define NE_CSEG         28      // Offset to cseg, number of segs in module
#define NE_SEGTAB       34      // Offset to segment table ptr in modhdr
#define NE_RESTAB       38      // Offset to resident names table ptr in modhdr

#define NS_HANDLE       8       // Offset to handle in seg table
#define NEW_SEG1_SIZE   10      // Size of the NS_ stuff


typedef struct {
    DWORD   dwSize;
    DWORD   dwAddress;
    DWORD   dwBlockSize;
    WORD    hBlock;
    WORD    wcLock;
    WORD    wcPageLock;
    WORD    wFlags;
    WORD    wHeapPresent;
    WORD    hOwner;
    WORD    wType;
    WORD    wData;
    DWORD   dwNext;
    DWORD   dwNextAlt;
} GLOBALENTRY16, *LPGLOBALENTRY16;


#pragma pack(2)
typedef struct {
    DWORD   dwSize;
    char    szModule[MAX_MODULE_NAME];
    WORD    hModule;
    WORD    wcUsage;
    char    szExePath[MAX_PATH16];
    WORD    wNext;
} MODULEENTRY16, *LPMODULEENTRY16;
#pragma pack()

typedef struct _segentry {
    struct _segentry *Next;
    int     type;
    char    szExePath[MAX_PATH16];
    char    szModule[MAX_MODULE_NAME];
    WORD    selector;
    WORD    segment;
    DWORD   length;  
} SEGENTRY, *PSEGENTRY;

#define SEGTYPE_V86         1
#define SEGTYPE_PROT        2

#pragma  pack(1)

typedef struct _GNODE32 {     // GlobalArena
   DWORD pga_next      ;    // next arena entry (last points to self)
   DWORD pga_prev      ;    // previous arena entry (first points to self)
   DWORD pga_address   ;    // 32 bit linear address of memory
   DWORD pga_size      ;    // 32 bit size in bytes
   WORD  pga_handle    ;    // back link to handle table entry
   WORD  pga_owner     ;    // Owner field (current task)
   BYTE  pga_count     ;    // lock count for movable segments
   BYTE  pga_pglock    ;    // # times page locked
   BYTE  pga_flags     ;    // 1 word available for flags
   BYTE  pga_selcount  ;    // Number of selectors allocated
   DWORD pga_lruprev   ;    // Previous entry in lru chain
   DWORD pga_lrunext   ;    // Next entry in lru chain
} GNODE32;
typedef GNODE32 UNALIGNED *PGNODE32;

typedef struct _GHI32 {
    WORD  hi_check     ;    // arena check word (non-zero enables heap checking)
    WORD  hi_freeze    ;    // arena frozen word (non-zero prevents compaction)
    WORD  hi_count     ;    // #entries in arena
    WORD  hi_first     ;    // first arena entry (sentinel, always busy)
    WORD  hi_res1      ;    // reserved
    WORD  hi_last      ;    // last arena entry (sentinel, always busy)
    WORD  hi_res2      ;    // reserved
    BYTE  hi_ncompact  ;    // #compactions done so far (max of 3)
    BYTE  hi_dislevel  ;    // current discard level
    DWORD hi_distotal  ;    // total amount discarded so far
    WORD  hi_htable    ;    // head of handle table list
    WORD  hi_hfree     ;    // head of free handle table list
    WORD  hi_hdelta    ;    // #handles to allocate each time
    WORD  hi_hexpand   ;    // address of near procedure to expand handles for this arena
    WORD  hi_pstats    ;    // address of statistics table or zero
} GHI32;
typedef GHI32 UNALIGNED *PGHI32;

typedef struct _HEAPENTRY {
    GNODE32 gnode;
    DWORD CurrentEntry;
    DWORD NextEntry;
    WORD Selector;
    int  SegmentNumber;
    char OwnerName[9];
    char FileName[9];
    char ModuleArg[9];
} HEAPENTRY;

typedef struct _NEHEADER {
    WORD ne_magic       ;
    BYTE ne_ver         ;
    BYTE ne_rev         ;
    WORD ne_enttab      ;
    WORD ne_cbenttab    ;
    DWORD ne_crc        ;
    WORD ne_flags       ;
    WORD ne_autodata    ;
    WORD ne_heap        ;
    WORD ne_stack       ;
    DWORD ne_csip       ;
    DWORD ne_sssp       ;
    WORD ne_cseg        ;
    WORD ne_cmod        ;
    WORD ne_cbnrestab   ;
    WORD ne_segtab      ;
    WORD ne_rsrctab     ;
    WORD ne_restab      ;
    WORD ne_modtab      ;
    WORD ne_imptab      ;
    DWORD ne_nrestab    ;
    WORD ne_cmovent     ;
    WORD ne_align       ;
    WORD ne_cres        ;
    BYTE ne_exetyp      ;
    BYTE ne_flagsothers ;
    WORD ne_pretthunks  ;
    WORD ne_psegrefbytes;
    WORD ne_swaparea    ;
    WORD ne_expver      ;
} NEHEADER;
typedef NEHEADER UNALIGNED *PNEHEADER;

#pragma  pack()

#ifndef i386

//
// Structures in 486 emulator for obtaining registers (FROM NT_CPU.C)
//

typedef struct NT_CPU_REG {
    ULONG *nano_reg;         /* where the nano CPU keeps the register */
    ULONG *reg;              /* where the light compiler keeps the reg */
    ULONG *saved_reg;        /* where currently unused bits are kept */
    ULONG universe_8bit_mask;/* is register in 8-bit form? */
    ULONG universe_16bit_mask;/* is register in 16-bit form? */
} NT_CPU_REG;

typedef struct NT_CPU_INFO {
    /* Variables for deciding what mode we're in */
    BOOL *in_nano_cpu;      /* is the Nano CPU executing? */
    ULONG *universe;         /* the mode that the CPU is in */

    /* General purpose register pointers */
    NT_CPU_REG eax, ebx, ecx, edx, esi, edi, ebp;

    /* Variables for getting SP or ESP. */
    BOOL *stack_is_big;     /* is the stack 32-bit? */
    ULONG *nano_esp;         /* where the Nano CPU keeps ESP */
    UCHAR **host_sp;          /* ptr to variable holding stack pointer as a
                               host address */
    UCHAR **ss_base;          /* ptr to variables holding base of SS as a
                               host address */
    ULONG *esp_sanctuary;    /* top 16 bits of ESP if we're now using SP */

    ULONG *eip;

    /* Segment registers. */
    USHORT *cs, *ds, *es, *fs, *gs, *ss;

    ULONG *flags;

    /* CR0, mainly to let us figure out if we're in real or protect mode */
    ULONG *cr0;
} NT_CPU_INFO;


#endif // i386

#define HANDLE_NULL  ((HANDLE)NULL)

#define LONG_TIMEOUT    INFINITE

#define READ_FIXED_ITEM(seg,offset,item)  \
    if ( ReadItem(hProcess,seg,offset,&item,sizeof(item)) ) goto punt;

#define WRITE_FIXED_ITEM(seg,offset,item)  \
    if ( WriteItem(hProcess,seg,offset,&item,sizeof(item)) ) goto punt;

#define LOAD_FIXED_ITEM(seg,offset,item)  \
    ReadItem(hProcess,seg,offset,&item,sizeof(item))

#define READ_SIZED_ITEM(seg,offset,item,size)  \
    if ( ReadItem(hProcess,seg,offset,item,size) ) goto punt;

#define WRITE_SIZED_ITEM(seg,offset,item,size)  \
    if ( WriteItem(hProcess,seg,offset,item,size) ) goto punt;

#define MALLOC(cb) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, cb)
#define FREE(addr) HeapFree(GetProcessHeap(), 0, addr)

extern WORD    wKernelSeg;
extern DWORD   dwOffsetTHHOOK;
extern LPVOID  lpRemoteAddress;
extern DWORD   lpRemoteBlock;
extern BOOL    fKernel386;
extern DWORD   dwLdtBase;
extern DWORD   dwIntelBase;
extern LPVOID  lpNtvdmState;
extern LPVOID  lpVdmDbgFlags;
extern LPVOID  lpNtCpuInfo;
extern LPVOID  lpVdmContext;
extern LPVOID  lpVdmBreakPoints;

BOOL
InternalGetThreadSelectorEntry(
    HANDLE hProcess,
    WORD   wSelector,
    LPVDMLDT_ENTRY lpSelectorEntry
    );

ULONG
InternalGetPointer(
    HANDLE  hProcess,
    WORD    wSelector,
    DWORD   dwOffset,
    BOOL    fProtMode
    );

BOOL
ReadItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    );

BOOL
WriteItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    );

BOOL
CallRemote16(
    HANDLE          hProcess,
    LPSTR           lpModuleName,
    LPSTR           lpEntryName,
    LPBYTE          lpArgs,
    WORD            wArgsPassed,
    WORD            wArgsSize,
    LPDWORD         lpdwReturnValue,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
    );

DWORD
GetRemoteBlock16(
    VOID
    );


VOID
ProcessBPNotification(
    LPDEBUG_EVENT lpDebugEvent
    );

VOID
ProcessInitNotification(
    LPDEBUG_EVENT lpDebugEvent
    );

VOID
ProcessSegmentNotification(
    LPDEBUG_EVENT lpDebugEvent
    );

VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    );

BOOL
GetInfoBySegmentNumber(
    LPSTR szModule,
    WORD SegNumber,
    VDM_SEGINFO *si
    );

BOOL
EnumerateModulesForValue(
    BOOL (WINAPI *pfnEnumModuleProc)(LPSTR,LPSTR,PWORD,PDWORD,PWORD),
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    );

#ifndef _X86_
WORD
ReadWord(
    HANDLE hProcess,
    LPVOID lpAddress
    );

DWORD
ReadDword(
    HANDLE hProcess,
    LPVOID lpAddress
    );

ULONG
GetRegValue(
    HANDLE hProcess,
    NT_CPU_REG reg,
    BOOL bInNano,
    ULONG UMask
    );

ULONG
GetEspValue(
    HANDLE hProcess,
    NT_CPU_INFO nt_cpu_info,
    BOOL bInNano
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\brkpt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    brkpt.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Neil Sandlin (neilsa) 1-Nov-1997 wrote it

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop

#define X86_BP_OPCODE 0xcc

//----------------------------------------------------------------------------
// ProcessBPNotification()
//
//
//----------------------------------------------------------------------------
VOID
ProcessBPNotification(
    LPDEBUG_EVENT lpDebugEvent
    )
{
    BOOL            b;
    HANDLE hProcess;
    HANDLE hThread;
    VDMCONTEXT      vcContext;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    CLIENT_ID ClientId;
    VDM_BREAKPOINT VdmBreakPoints[MAX_VDM_BREAKPOINTS] = {0};
    ULONG           vdmEip;
    DWORD lpNumberOfBytes;
    int             i;
    UCHAR  opcode;
    PVOID lpInst;

    hProcess = OpenProcess( PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION,
                            FALSE, lpDebugEvent->dwProcessId );

    if ( hProcess == HANDLE_NULL ) {
        return;
    }
    
    ClientId.UniqueThread = (HANDLE)lpDebugEvent->dwThreadId;
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);
    Status = NtOpenThread(&hThread,
                          (ACCESS_MASK)THREAD_GET_CONTEXT,
                          &Obja,
                          &ClientId);
    if (!NT_SUCCESS(Status)) {
        CloseHandle( hProcess );
        return;
    }
    
    vcContext.ContextFlags = VDMCONTEXT_CONTROL;
    
    if (!VDMGetContext(hProcess, hThread, &vcContext)) {
        CloseHandle( hProcess );
        CloseHandle( hThread);
        return;
    } 
    
    CloseHandle( hThread );
    
    b = ReadProcessMemory(hProcess, lpVdmBreakPoints, VdmBreakPoints,
                          sizeof(VdmBreakPoints), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(VdmBreakPoints) ) {
        CloseHandle (hProcess);
        return;
    }
    
//    if ((getMSW() & MSW_PE) && SEGMENT_IS_BIG(vcContext.SegCs)) {
//        vdmEip = vcContext.Eip;
//    } else {
        vdmEip = (ULONG)LOWORD(vcContext.Eip);
//    }


    for (i=0; i<MAX_VDM_BREAKPOINTS; i++) {

        if ((VdmBreakPoints[i].Flags & VDMBP_ENABLED) &&
            (VdmBreakPoints[i].Flags & VDMBP_SET) &&
            (vcContext.SegCs == VdmBreakPoints[i].Seg) &&
            (vdmEip == VdmBreakPoints[i].Offset+1)  &&
            (!(vcContext.EFlags & V86FLAGS_V86) == !(VdmBreakPoints[i].Flags & VDMBP_V86)) ){

            // We must have hit this breakpoint. Back up the eip and
            // restore the original data
//            setEIP(getEIP()-1);
//            vcContext.Eip--;

            lpInst = (PVOID)InternalGetPointer(hProcess,
                                VdmBreakPoints[i].Seg, 
                                VdmBreakPoints[i].Offset,
                               ((VdmBreakPoints[i].Flags & VDMBP_V86)==0));
                               
            b = ReadProcessMemory(hProcess, lpInst, &opcode, 1,
                                  &lpNumberOfBytes);
                               

            if (b && (opcode == X86_BP_OPCODE)) {
                WriteProcessMemory(hProcess, lpInst, &VdmBreakPoints[i].Opcode, 1,
                                  &lpNumberOfBytes);
                
                VdmBreakPoints[i].Flags |= VDMBP_PENDING;
                VdmBreakPoints[i].Flags &= ~VDMBP_FLUSH;
                if (i == VDM_TEMPBP) {
                    // non-persistent breakpoint
                    VdmBreakPoints[i].Flags &= ~VDMBP_SET;
                }
                WriteProcessMemory(hProcess, lpVdmBreakPoints, VdmBreakPoints,
                          sizeof(VdmBreakPoints), &lpNumberOfBytes);
            }

            break;

        }
    }

    CloseHandle( hProcess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <vdmdbg.h>
#include <dbginfo.h>
#include <stdio.h>
#include <string.h>
#include <common.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\toolhelp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdmdbg.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it

--*/

#include <precomp.h>
#pragma hdrstop


VOID CopyToGlobalEntry16(
    LPGLOBALENTRY   lpGlobalEntry,
    LPGLOBALENTRY16 lpGlobalEntry16
) {
    if ( lpGlobalEntry == NULL || lpGlobalEntry16 == NULL ) {
        return;
    }
    lpGlobalEntry16->dwSize       = sizeof(GLOBALENTRY16);
    lpGlobalEntry16->dwAddress    = lpGlobalEntry->dwAddress;
    lpGlobalEntry16->dwBlockSize  = lpGlobalEntry->dwBlockSize;
    lpGlobalEntry16->hBlock       = (WORD)lpGlobalEntry->hBlock;
    lpGlobalEntry16->wcLock       = lpGlobalEntry->wcLock;
    lpGlobalEntry16->wcPageLock   = lpGlobalEntry->wcPageLock;
    lpGlobalEntry16->wFlags       = lpGlobalEntry->wFlags;
    lpGlobalEntry16->wHeapPresent = (BOOLEAN)lpGlobalEntry->wHeapPresent;
    lpGlobalEntry16->hOwner       = (WORD)lpGlobalEntry->hOwner;
    lpGlobalEntry16->wType        = lpGlobalEntry->wType;
    lpGlobalEntry16->wData        = lpGlobalEntry->wData;
    lpGlobalEntry16->dwNext       = lpGlobalEntry->dwNext;
    lpGlobalEntry16->dwNextAlt    = lpGlobalEntry->dwNextAlt;
}

VOID CopyFromGlobalEntry16(
    LPGLOBALENTRY   lpGlobalEntry,
    LPGLOBALENTRY16 lpGlobalEntry16
) {
    if ( lpGlobalEntry == NULL || lpGlobalEntry16 == NULL ) {
        return;
    }
    lpGlobalEntry->dwSize         = sizeof(GLOBALENTRY);
    lpGlobalEntry->dwAddress      = lpGlobalEntry16->dwAddress;
    lpGlobalEntry->dwBlockSize    = lpGlobalEntry16->dwBlockSize;
    lpGlobalEntry->hBlock         = (HANDLE)lpGlobalEntry16->hBlock;
    lpGlobalEntry->wcLock         = lpGlobalEntry16->wcLock;
    lpGlobalEntry->wcPageLock     = lpGlobalEntry16->wcPageLock;
    lpGlobalEntry->wFlags         = lpGlobalEntry16->wFlags;
    lpGlobalEntry->wHeapPresent   = lpGlobalEntry16->wHeapPresent;
    lpGlobalEntry->hOwner         = (HANDLE)lpGlobalEntry16->hOwner;
    lpGlobalEntry->wType          = lpGlobalEntry16->wType;
    lpGlobalEntry->wData          = lpGlobalEntry16->wData;
    lpGlobalEntry->dwNext         = lpGlobalEntry16->dwNext;
    lpGlobalEntry->dwNextAlt      = lpGlobalEntry16->dwNextAlt;
}


BOOL
WINAPI
VDMGlobalFirst(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define GF_SIZE 6           // 6 bytes are passed to GlobalFirst
    BYTE            Args[GF_SIZE+sizeof(GLOBALENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpGlobalEntry->dwSize != sizeof(GLOBALENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += GF_SIZE;

    lpbyte = Args;

    // Push the flags
    (*(LPWORD)lpbyte) = wFlags;
    lpbyte += sizeof(WORD);

    // Push the pointer to the pointer to the GLOBALENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "GlobalFirst",
            Args,
            GF_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );


    return( (BOOL)((WORD)dwResult) );
}


BOOL
WINAPI
VDMGlobalNext(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPGLOBALENTRY   lpGlobalEntry,
    WORD            wFlags,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define GN_SIZE 6           // 6 bytes are passed to GlobalNext
    BYTE            Args[GN_SIZE+sizeof(GLOBALENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpGlobalEntry->dwSize != sizeof(GLOBALENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += GN_SIZE;

    lpbyte = Args;

    // Push the flags
    (*(LPWORD)lpbyte) = wFlags;
    lpbyte += sizeof(WORD);

    // Push the pointer to the pointer to the GLOBALENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "GlobalNext",
            Args,
            GN_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromGlobalEntry16( lpGlobalEntry, (LPGLOBALENTRY16)lpbyte );

    return( (BOOL)((WORD)dwResult) );
}

VOID CopyToModuleEntry16(
    LPMODULEENTRY   lpModuleEntry,
    LPMODULEENTRY16 lpModuleEntry16
) {
    if ( lpModuleEntry == NULL || lpModuleEntry16 == NULL ) {
        return;
    }
    lpModuleEntry16->dwSize  = sizeof(MODULEENTRY16);
    lpModuleEntry16->hModule = (WORD)lpModuleEntry->hModule;
    lpModuleEntry16->wcUsage = lpModuleEntry->wcUsage;
    lpModuleEntry16->wNext   = lpModuleEntry->wNext;
    strncpy( lpModuleEntry16->szModule, lpModuleEntry->szModule, MAX_MODULE_NAME );
    strncpy( lpModuleEntry16->szExePath, lpModuleEntry->szExePath, MAX_PATH16 );
}

VOID CopyFromModuleEntry16(
    LPMODULEENTRY   lpModuleEntry,
    LPMODULEENTRY16 lpModuleEntry16
) {
    if ( lpModuleEntry == NULL || lpModuleEntry16 == NULL ) {
        return;
    }
    lpModuleEntry->dwSize   = sizeof(MODULEENTRY);
    lpModuleEntry->hModule  = (HANDLE)lpModuleEntry16->hModule;
    lpModuleEntry->wcUsage  = lpModuleEntry16->wcUsage;
    lpModuleEntry->wNext    = lpModuleEntry16->wNext;
    strncpy( lpModuleEntry->szModule, lpModuleEntry16->szModule, MAX_MODULE_NAME );
    strncpy( lpModuleEntry->szExePath, lpModuleEntry16->szExePath, MAX_PATH16 );
}

BOOL
WINAPI
VDMModuleFirst(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define MF_SIZE 4           // 4 bytes are passed to ModuleFirst
    BYTE            Args[GF_SIZE+sizeof(MODULEENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpModuleEntry->dwSize != sizeof(MODULEENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += MF_SIZE;

    lpbyte = Args;

    // Push the pointer to the pointer to the MODULEENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "ModuleFirst",
            Args,
            MF_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    return( (BOOL)((WORD)dwResult) );
}

BOOL
WINAPI
VDMModuleNext(
    HANDLE          hProcess,
    HANDLE          hUnused,
    LPMODULEENTRY   lpModuleEntry,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
) {
#define MN_SIZE 4           // 4 bytes are passed to ModuleNext
    BYTE            Args[GF_SIZE+sizeof(MODULEENTRY16)];
    LPBYTE          lpbyte;
    DWORD           vpBuff;
    DWORD           dwResult;
    BOOL            b;
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpModuleEntry->dwSize != sizeof(MODULEENTRY) ) {
        return( FALSE );
    }

    vpBuff = GetRemoteBlock16();
    vpBuff += MN_SIZE;

    lpbyte = Args;

    // Push the pointer to the pointer to the MODULEENTRY16 structure
    (*(LPWORD)lpbyte) = LOWORD(vpBuff);
    lpbyte += sizeof(WORD);

    (*(LPWORD)lpbyte) = HIWORD(vpBuff);
    lpbyte += sizeof(WORD);

    CopyToModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    b = CallRemote16(
            hProcess,
            "TOOLHELP.DLL",
            "ModuleNext",
            Args,
            MN_SIZE,
            sizeof(Args),
            &dwResult,
            lpEventProc,
            lpData );

    if ( !b ) {
        return( FALSE );
    }
    CopyFromModuleEntry16( lpModuleEntry, (LPMODULEENTRY16)lpbyte );

    return( (BOOL)((WORD)dwResult) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\util.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it

--*/

#include <precomp.h>
#pragma hdrstop

WORD    wKernelSeg = 0;
DWORD   dwOffsetTHHOOK = 0L;
LPVOID  lpRemoteAddress = NULL;
DWORD   lpRemoteBlock = 0;
BOOL    fKernel386 = FALSE;
DWORD   dwLdtBase = 0;
DWORD   dwIntelBase = 0;
LPVOID  lpNtvdmState = NULL;
LPVOID  lpVdmDbgFlags = NULL;
LPVOID  lpVdmContext = NULL;
LPVOID  lpNtCpuInfo = NULL;
LPVOID  lpVdmBreakPoints = NULL;

//----------------------------------------------------------------------------
// InternalGetThreadSelectorEntry()
//
//   Routine to return a LDT_ENTRY structure for the passed in selector number.
//   Its is assumed that we are talking about protect mode selectors.
//   For x86 systems, take the easy way and just call the system.  For non-x86
//   systems, we get some information from softpc and index into them as the
//   LDT and GDT tables.
//
//----------------------------------------------------------------------------
BOOL
InternalGetThreadSelectorEntry(
    HANDLE hProcess,
    WORD   wSelector,
    LPVDMLDT_ENTRY lpSelectorEntry
    )
{
    BOOL bResult = FALSE;
    DWORD lpNumberOfBytesRead;

    // For non-intel systems, query the information from the LDT
    // that we have a pointer to from the VDMINTERNALINFO that we
    // got passed.

    if (!dwLdtBase) {

        RtlFillMemory( lpSelectorEntry, sizeof(VDMLDT_ENTRY), (UCHAR)0 );

    } else {

        bResult = ReadProcessMemory(
                    hProcess,
                    (LPVOID)(dwLdtBase+((wSelector&~7))),
                    lpSelectorEntry,
                    sizeof(VDMLDT_ENTRY),
                    &lpNumberOfBytesRead
                    );

    }

    return( bResult );
}


//----------------------------------------------------------------------------
// InternalGetPointer()
//
//   Routine to convert a 16-bit address into a 32-bit address.  If fProtMode
//   is TRUE, then the selector table lookup is performed.  Otherwise, simple
//   real mode address calculations are performed.  On non-x86 systems, the
//   base of real memory is added into the
//
//----------------------------------------------------------------------------
ULONG
InternalGetPointer(
    HANDLE  hProcess,
    WORD    wSelector,
    DWORD   dwOffset,
    BOOL    fProtMode
    )
{
    VDMLDT_ENTRY    le;
    ULONG           ulResult;
    ULONG           base;
    ULONG           limit;
    BOOL            b;

    if ( fProtMode ) {
        b = InternalGetThreadSelectorEntry( hProcess,
                                            wSelector,
                                            &le );
        if ( !b ) {
            return( 0 );
        }

        base =   ((ULONG)le.HighWord.Bytes.BaseHi << 24)
               + ((ULONG)le.HighWord.Bytes.BaseMid << 16)
               + ((ULONG)le.BaseLow);
        limit = (ULONG)le.LimitLow
              + ((ULONG)le.HighWord.Bits.LimitHi << 16);
        if ( le.HighWord.Bits.Granularity ) {
            limit <<= 12;
            limit += 0xFFF;
        }
    } else {
        base = wSelector << 4;
        limit = 0xFFFF;
    }
    if ( dwOffset > limit ) {
        ulResult = 0;
    } else {
        ulResult = base + dwOffset;
#ifndef i386
        ulResult += dwIntelBase;
#endif
    }

    return( ulResult );
}


//----------------------------------------------------------------------------
// ReadItem
//
//    Internal routine used to read items out of the debugee's address space.
//    The routine returns TRUE for failure.  This allows easy failure testing.
//
//----------------------------------------------------------------------------
BOOL
ReadItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    )
{
    LPVOID  lp;
    BOOL    b;
    DWORD   dwBytes;

    if ( nSize == 0 ) {
        return( FALSE );
    }

    lp = (LPVOID)InternalGetPointer(
                    hProcess,
                    (WORD)(wSeg | 1),
                    dwOffset,
                    TRUE );
    if ( lp == NULL ) return( TRUE );

    b = ReadProcessMemory(
                    hProcess,
                    lp,
                    lpitem,
                    nSize,
                    &dwBytes );
    if ( !b || dwBytes != nSize ) return( TRUE );

    return( FALSE );
}

//----------------------------------------------------------------------------
// WriteItem
//
//    Internal routine used to write items into the debugee's address space.
//    The routine returns TRUE for failure.  This allows easy failure testing.
//
//----------------------------------------------------------------------------
BOOL
WriteItem(
    HANDLE  hProcess,
    WORD    wSeg,
    DWORD   dwOffset,
    LPVOID  lpitem,
    UINT    nSize
    )
{
    LPVOID  lp;
    BOOL    b;
    DWORD   dwBytes;

    if ( nSize == 0 ) {
        return( FALSE );
    }

    lp = (LPVOID)InternalGetPointer(
                    hProcess,
                    (WORD)(wSeg | 1),
                    dwOffset,
                    TRUE );
    if ( lp == NULL ) return( TRUE );

    b = WriteProcessMemory(
                    hProcess,
                    lp,
                    lpitem,
                    nSize,
                    &dwBytes );
    if ( !b || dwBytes != nSize ) return( TRUE );

    return( FALSE );
}



BOOL
CallRemote16(
    HANDLE          hProcess,
    LPSTR           lpModuleName,
    LPSTR           lpEntryName,
    LPBYTE          lpArgs,
    WORD            wArgsPassed,
    WORD            wArgsSize,
    LPDWORD         lpdwReturnValue,
    DEBUGEVENTPROC  lpEventProc,
    LPVOID          lpData
    )
{
    HANDLE          hRemoteThread;
    DWORD           dwThreadId;
    DWORD           dwContinueCode;
    DEBUG_EVENT     de;
    BOOL            b;
    BOOL            fContinue;
    COM_HEADER      comhead;
    WORD            wRemoteSeg;
    WORD            wRemoteOff;
    WORD            wOff;
    UINT            uModuleLength;
    UINT            uEntryLength;

    if ( lpRemoteAddress == NULL || lpRemoteBlock == 0 ) {
#ifdef DEBUG
        OutputDebugString("Remote address or remote block not initialized\n");
#endif
        return( FALSE );
    }

    wRemoteSeg = HIWORD(lpRemoteBlock);
    wRemoteOff = LOWORD(lpRemoteBlock);
    wOff = wRemoteOff;

    // Fill in the communications buffer header

    READ_FIXED_ITEM( wRemoteSeg, wOff, comhead );

    comhead.wArgsPassed = wArgsPassed;
    comhead.wArgsSize   = wArgsSize;

    uModuleLength = strlen(lpModuleName) + 1;
    uEntryLength = strlen(lpEntryName) + 1;

    //
    // If this call won't fit into the buffer, then fail.
    //
    if ( (UINT)comhead.wBlockLength < sizeof(comhead) + wArgsSize + uModuleLength + uEntryLength ) {
#ifdef DEBUG
        OutputDebugString("Block won't fit\n");
#endif
        return( FALSE );
    }


    WRITE_FIXED_ITEM( wRemoteSeg, wOff, comhead );
    wOff += sizeof(comhead);

    // Fill in the communications buffer arguments
    WRITE_SIZED_ITEM( wRemoteSeg, wOff, lpArgs, wArgsSize );
    wOff += wArgsSize;

    // Fill in the communications buffer module name and entry name
    WRITE_SIZED_ITEM( wRemoteSeg, wOff, lpModuleName, uModuleLength );
    wOff += (WORD) uModuleLength;

    WRITE_SIZED_ITEM( wRemoteSeg, wOff, lpEntryName, uEntryLength );
    wOff += (WORD) uEntryLength;

    hRemoteThread = CreateRemoteThread(
                    hProcess,
                    NULL,
                    (DWORD)0,
                    lpRemoteAddress,
                    NULL,
                    0,
                    &dwThreadId );

    if ( hRemoteThread == (HANDLE)0 ) {     // Fail if we couldn't creaet thrd
#ifdef DEBUG
        OutputDebugString("CreateRemoteThread failed\n");
#endif
        return( FALSE );
    }

    //
    // Wait for the EXIT_THREAD_DEBUG_EVENT.
    //

    fContinue = TRUE;

    while ( fContinue ) {

        b = WaitForDebugEvent( &de, LONG_TIMEOUT );

        if (!b) {
            TerminateThread( hRemoteThread, 0 );
            CloseHandle( hRemoteThread );
            return( FALSE );
        }

        if ( de.dwThreadId == dwThreadId &&
               de.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT ) {
            fContinue = FALSE;
        }

        if ( lpEventProc ) {
            dwContinueCode = (* lpEventProc)( &de, lpData );
        } else {
            dwContinueCode = DBG_CONTINUE;
        }

        ContinueDebugEvent( de.dwProcessId, de.dwThreadId, dwContinueCode );

    }

    b = WaitForSingleObject( hRemoteThread, LONG_TIMEOUT );
    CloseHandle( hRemoteThread );

    if (b) {
#ifdef DEBUG
        OutputDebugString("Wait for remote thread failed\n");
#endif
        return( FALSE );
    }

    //
    // Get the return value and returned arguments
    //
    wOff = wRemoteOff;

    READ_FIXED_ITEM( wRemoteSeg, wOff, comhead );
    wOff += sizeof(comhead);

    *lpdwReturnValue = comhead.dwReturnValue;

    // Read back the communications buffer arguments
    READ_SIZED_ITEM( wRemoteSeg, wOff, lpArgs, wArgsSize );

    return( comhead.wSuccess );

punt:
    return( FALSE );
}

DWORD
GetRemoteBlock16(
    VOID
    )
{
    if ( lpRemoteBlock == 0 ) {
        return( 0 );
    }
    return( ((DWORD)lpRemoteBlock) + sizeof(COM_HEADER) );
}


VOID
ProcessInitNotification(
    LPDEBUG_EVENT lpDebugEvent
    )
{
    VDMINTERNALINFO viInfo;
    DWORD           lpNumberOfBytesRead;
    HANDLE          hProcess;
    BOOL            b;
    LPDWORD         lpdw;

    lpdw = &(lpDebugEvent->u.Exception.ExceptionRecord.ExceptionInformation[0]);
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    if ( hProcess == HANDLE_NULL ) {
        return;
    }

    b = ReadProcessMemory(hProcess,
                          (LPVOID)lpdw[3],
                          &viInfo,
                          sizeof(viInfo),
                          &lpNumberOfBytesRead
                          );
    if ( !b || lpNumberOfBytesRead != sizeof(viInfo) ) {
        return;

    }

    if ( wKernelSeg == 0 ) {
        wKernelSeg = viInfo.wKernelSeg;
        dwOffsetTHHOOK = viInfo.dwOffsetTHHOOK;
    }
    if ( lpRemoteAddress == NULL ) {
        lpRemoteAddress = viInfo.lpRemoteAddress;
    }
    if ( lpRemoteBlock == 0 ) {
        lpRemoteBlock = viInfo.lpRemoteBlock;
    }

    dwLdtBase = viInfo.dwLdtBase;
    dwIntelBase = viInfo.dwIntelBase;
    fKernel386 = viInfo.f386;
    lpNtvdmState = viInfo.lpNtvdmState;
    lpVdmDbgFlags = viInfo.lpVdmDbgFlags;
    lpVdmContext  = viInfo.vdmContext;
    lpNtCpuInfo  = viInfo.lpNtCpuInfo;
    lpVdmBreakPoints = viInfo.lpVdmBreakPoints;

    CloseHandle( hProcess );
}

VOID
ParseModuleName(
    LPSTR szName,
    LPSTR szPath
    )
/*++

    Routine Description:

        This routine strips off the 8 character file name from a path

    Arguments:

        szName - pointer to buffer of 8 characters (plus null)
        szPath - full path of file

    Return Value

        None.

--*/

{
    LPSTR lPtr = szPath;
    LPSTR lDest = szName;
    int BufferSize = 9;

    while(*lPtr) lPtr++;     // scan to end

    while( ((DWORD)lPtr > (DWORD)szPath) &&
           ((*lPtr != '\\') && (*lPtr != '/'))) lPtr--;

    if (*lPtr) lPtr++;

    while((*lPtr) && (*lPtr!='.')) {
        if (!--BufferSize) break;
        *lDest++ = *lPtr++;
    }

    *lDest = 0;
}

#ifndef i386

WORD
ReadWord(
    HANDLE hProcess,
    PVOID lpAddress
    )
{
    NTSTATUS bResult;
    WORD value;
    ULONG NumberOfBytesRead;

    bResult = ReadProcessMemory(
                hProcess,
                lpAddress,
                &value,
                sizeof(WORD),
                &NumberOfBytesRead
                );
    return value;
}

DWORD
ReadDword(
    HANDLE hProcess,
    PVOID lpAddress
    )
{
    NTSTATUS bResult;
    DWORD value;
    ULONG NumberOfBytesRead;

    bResult = ReadProcessMemory(
                hProcess,
                lpAddress,
                &value,
                sizeof(DWORD),
                &NumberOfBytesRead
                );
    return value;
}

//
// The following two routines implement the very funky way that we
// have to get register values on the 486 emulator.
//

ULONG
GetRegValue(
    HANDLE hProcess,
    NT_CPU_REG reg,
    BOOL bInNano,
    ULONG UMask
    )

{
    if (bInNano) {

        return(ReadDword(hProcess, reg.nano_reg));

    } else if (UMask & reg.universe_8bit_mask) {

        return (ReadDword(hProcess, reg.saved_reg) & 0xFFFFFF00 |
                ReadDword(hProcess, reg.reg) & 0xFF);

    } else if (UMask & reg.universe_16bit_mask) {

        return (ReadDword(hProcess, reg.saved_reg) & 0xFFFF0000 |
                ReadDword(hProcess, reg.reg) & 0xFFFF);

    } else {

        return (ReadDword(hProcess, reg.reg));

    }
}

ULONG
GetEspValue(
    HANDLE hProcess,
    NT_CPU_INFO nt_cpu_info,
    BOOL bInNano
    )

{
    if (bInNano) {

        return (ReadDword(hProcess, nt_cpu_info.nano_esp));

    } else {

        if (ReadDword(hProcess, nt_cpu_info.stack_is_big)) {

            return (ReadDword(hProcess, nt_cpu_info.host_sp) -
                    ReadDword(hProcess, nt_cpu_info.ss_base));

        } else {

            return (ReadDword(hProcess, nt_cpu_info.esp_sanctuary) & 0xFFFF0000 |
                    (ReadDword(hProcess, nt_cpu_info.host_sp) -
                     ReadDword(hProcess, nt_cpu_info.ss_base) & 0xFFFF));

        }

    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\sym.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sym.c

Abstract:

    This function contains the 16-bit symbol support for VDMDBG

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts
    Neil Sandlin (NeilSa) 01-Mar-1997 Moved it to VDMDBG,
                                      Rewrote it

--*/

#include <precomp.h>
#pragma hdrstop

#define PRINTF(x) TRUE

#define MYOF_FLAGS (OF_READ | OF_SHARE_DENY_NONE)

#define MAX_MODULE_LIST 200
char ModuleList[MAX_MODULE_LIST][9];
int ModuleListCount = 0;

typedef struct _SYM_MAP {
    WORD  map_ptr;
    WORD  map_lsa;
    WORD  pgm_ent;
    WORD  abs_cnt;
    WORD  abs_ptr;
    WORD  seg_cnt;
    WORD  seg_ptr;
    BYTE   sym_nam_max;
    BYTE   map_nam_len;
    char    map_name[20];
} SYM_MAP;

typedef struct _SYM_SEG {
    WORD  nxt_seg;
    WORD  sym_cnt;
    WORD  sym_ptr;
    WORD  seg_lsa;
    WORD  seg_in[4];
    WORD  seg_lin;
    BYTE   seg_ldd;
    char    seg_cin;
    BYTE   seg_nam_len;
    char    seg_name[20];
} SYM_SEG;

typedef struct _SYM_ITEM {
    WORD  sym_val;
    BYTE   sym_nam_len;
    char    sym_name[256];
} SYM_ITEM;



BOOL
FindExport(
    LPSTR           filename,
    WORD            segment,
    WORD            offset,
    LPSTR           sym_text,
    BOOL            next,
    LONG            *dist
    )
{
    int     iFile;
    OFSTRUCT    ofs;
    int     rc;
    IMAGE_DOS_HEADER doshdr;
    IMAGE_OS2_HEADER winhdr;
    BYTE    Table[65536];
    BYTE    bBundles;
    BYTE    bFlags;
    BYTE    *ptr;
    WORD    wIndex = 1;
    int     i;
    int     this_dist;
    int     wIndexBest = -1;
    char    myfilename[256];
#pragma pack(1)
    typedef struct
    {
    BYTE        bFlags;
    UNALIGNED WORD  wSegOffset;
    } FENTRY, *PFENTRY;

    typedef struct
    {
    BYTE        bFlags;
    UNALIGNED WORD  wINT3F;
    BYTE        bSegNumber;
    UNALIGNED WORD  wSegOffset;
    } MENTRY, *PMENTRY;
#pragma pack()

    strncpy(myfilename, filename, sizeof(myfilename));
    myfilename[sizeof(myfilename)-1] = '\0';

    if (-1 == (iFile=OpenFile(myfilename, &ofs, MYOF_FLAGS))) {

        //PRINTF("VDMDBG: Error reading file %s\n", filename);
        strncpy(myfilename, filename, sizeof(myfilename)-sizeof(".exe"));
        myfilename[sizeof(myfilename)-sizeof(".exe")-1] = '\0';
        strcat(myfilename, ".exe");

        if (-1 == (iFile=OpenFile(myfilename, &ofs, MYOF_FLAGS))) {

            //PRINTF("VDMDBG: Error reading file %s\n", myfilename);
            strncpy(myfilename, filename, sizeof(myfilename)-sizeof(".dll"));
            myfilename[sizeof(myfilename)-sizeof(".dll")-1] = '\0';
            strcat(myfilename, ".dll");

            if (-1 == (iFile=OpenFile(myfilename, &ofs, MYOF_FLAGS))) {
                //PRINTF("VDMDBG: Error reading file %s\n", myfilename);
                PRINTF("VDMDBG: Error reading file\n");
                return FALSE;
            }
        }
    }

    rc = _lread(iFile, &doshdr, sizeof(doshdr));
    if (rc != sizeof(doshdr)) {
    PRINTF("VDMDBG: Error reading DOS header\n");
    goto Error;
    }
    if (doshdr.e_magic != IMAGE_DOS_SIGNATURE) {
    PRINTF("VDMDBG: Error - no DOS EXE signature");
    goto Error;
    }
    rc = _llseek(iFile, doshdr.e_lfanew, FILE_BEGIN);
    if (rc == -1) {
    PRINTF("VDMDBG: Error - could not seek - probably not Win3.1 exe\n");
    goto Error;
    }
    rc = _lread(iFile, &winhdr, sizeof(winhdr));
    if (rc != sizeof(winhdr)) {
    PRINTF("VDMDBG: Error - could not read WIN header - probably not Win3.1 exe\n");
    goto Error;
    }
    if (winhdr.ne_magic != IMAGE_OS2_SIGNATURE) {
    PRINTF("VDMDBG: Error - not WIN EXE signature\n");
    goto Error;
    }
    rc = _llseek(iFile, doshdr.e_lfanew+winhdr.ne_enttab, FILE_BEGIN);
    if (rc == -1) {
    PRINTF("VDMDBG: Error - could not seek to entry table\n");
    goto Error;
    }
    rc = _lread(iFile, Table, winhdr.ne_cbenttab);
    if (rc != winhdr.ne_cbenttab) {
    PRINTF("VDMDBG: Error - could not read entry table\n");
    goto Error;
    }
    ptr = Table;
    while (TRUE) {
        bBundles = *ptr++;
        if (bBundles == 0)
            break;

        bFlags = *ptr++;
        switch (bFlags) {
            case 0: // Placeholders
            wIndex += bBundles;
            break;

            case 0xff:  // movable segments
            for (i=0; i<(int)bBundles; ++i) {
                PMENTRY pe = (PMENTRY )ptr;
                if (pe->bSegNumber == segment) {
                this_dist = (!next) ? offset - pe->wSegOffset
                                    : pe->wSegOffset - offset;
                if ( this_dist >= 0 && (this_dist < *dist || *dist == -1) ) {
                    // mark this as the best match so far
                    *dist = this_dist;
                    wIndexBest = wIndex;
                }
                }
                ptr += sizeof(MENTRY);
                wIndex++;
            }
            break;

            default:    // fixed segments
            if ((int)bFlags != segment) {
                ptr += (int)bBundles * sizeof(FENTRY);
                wIndex += (int)bBundles;
            } else {
                for (i=0; i<(int)bBundles; ++i) {
                PFENTRY pe = (PFENTRY)ptr;
                this_dist = (!next) ? offset - pe->wSegOffset
                                    : pe->wSegOffset - offset;
                if ( this_dist >= 0 && (this_dist < *dist || *dist == -1) ) {
                    // mark this as the best match so far
                    *dist = this_dist;
                    wIndexBest = wIndex;
                }
                ptr += sizeof(FENTRY);
                wIndex++;
                }
            }
            break;
        }
    }
    if (wIndexBest == -1) {
    // no match found - error out
Error:
        _lclose(iFile);
        return FALSE;
    }

    // Success: match found
    // wIndexBest = ordinal of the function
    // segment:offset = address to look up
    // *dist = distance from segment:offset to the symbol
    // filename = name of .exe/.dll

    // Look for the ordinal in the resident name table
    rc = _llseek(iFile, doshdr.e_lfanew+winhdr.ne_restab, FILE_BEGIN);
    if (rc == -1) {
        PRINTF("VDMDBG: Error - unable to seek to residentname table\n");
        goto Error;
    }
    rc = _lread(iFile, Table, winhdr.ne_modtab-winhdr.ne_restab);
    if (rc != winhdr.ne_modtab-winhdr.ne_restab) {
        PRINTF("VDMDBG: Error - unable to read entire resident name table\n");
        goto Error;
    }
    ptr = Table;
    while (*ptr) {
        if ( *(UNALIGNED USHORT *)(ptr+1+*ptr) == (USHORT)wIndexBest) {
            // found the matching name
            *(ptr+1+*ptr) = '\0';   // null-terminate the function name
            strcpy(sym_text, ptr+1);
            goto Finished;
        }
        ptr += *ptr + 3;
    }

    // Look for the ordinal in the non-resident name table
    rc = _llseek(iFile, doshdr.e_lfanew+winhdr.ne_nrestab, FILE_BEGIN);
    if (rc == -1) {
        PRINTF("VDMDBG: Error - unable to seek to non-residentname table\n");
        goto Error;
    }
    rc = _lread(iFile, Table, winhdr.ne_cbnrestab);
    if (rc != winhdr.ne_cbnrestab) {
        PRINTF("VDMDBG: Error - unable to read entire non-resident name table\n");
        goto Error;
    }
    ptr = Table;
    while (*ptr) {
        if ( *(UNALIGNED USHORT *)(ptr+1+*ptr) == (USHORT)wIndexBest) {
            // found the matching name
            *(ptr+1+*ptr) = '\0';   // null-terminate the function name
            strcpy(sym_text, ptr+1);
            goto Finished;
        }
        ptr += *ptr + 3;
    }
    // fall into error path - no match found
    goto Error;

Finished:
    _lclose(iFile);
    return TRUE;
}


BOOL
ExtractSymbol(
    int iFile,
    DWORD ulSegPos,
    DWORD ulSymPos,
    WORD csym,
    WORD seglsa,
    WORD segment,
    DWORD offset,
    BOOL next,
    LPSTR sym_text,
    PLONG pdist
    )
{
    WORD uLastSymdefPos=0;
    /* ulWrap allows for wrapping around with more than 64K of symbols */
    DWORD ulWrap=0;
    LONG SymOffset;
    LONG this_dist;
    BOOL fResult = FALSE;
    char name_text[256];

    for (; csym--; ulSymPos+=sizeof(WORD))
    {
        WORD uSymdefPos;
        SYM_ITEM sym;

        if (_llseek(iFile, ulSymPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&uSymdefPos, sizeof(uSymdefPos)) != sizeof(uSymdefPos))
            return FALSE;
        if (uSymdefPos < uLastSymdefPos)
            ulWrap += 0x10000L;
        _llseek(iFile, ulSegPos + uSymdefPos + ulWrap, FILE_BEGIN);
        _lread(iFile, (LPSTR)&sym, sizeof(sym));

        if (segment == 0) {
            SymOffset = (LONG)seglsa*16 + sym.sym_val;
        } else {
            SymOffset = (LONG)sym.sym_val;
        }

        // Depending on whether the caller wants the closest symbol
        // from below or above, compute the distance from the current
        // symbol to the target offset.
        switch( next ) {
            case FALSE:
                this_dist = offset - SymOffset;
                break;
            case TRUE:
                this_dist = SymOffset - offset;
                break;
        }

        //
        // Since we don't really know if the current symbol is actually
        // the nearest symbol, just remember it if it qualifies. Keep
        // the best distance so far in 'dist'.
        //
        if ((this_dist >= 0) && ((this_dist < *pdist) || (*pdist == -1))) {
            *pdist = this_dist;
            strncpy(name_text, sym.sym_name, sym.sym_nam_len);
            name_text[sym.sym_nam_len] = 0;
            fResult = TRUE;
        }

        uLastSymdefPos = uSymdefPos;
    }

    if (fResult) {
        //
        // The scan of the symbols in this segment produced a winner.
        // Copy the name and displacement back up to the caller.
        //
        strcpy(sym_text, name_text);
    }
    return fResult;
}

BOOL
WalkSegmentsForSymbol(
    int iFile,
    SYM_MAP *pMap,
    ULONG ulMapPos,
    WORD segment,
    DWORD offset,
    BOOL next,
    LPSTR sym_text,
    PDWORD pDisplacement
    )
{

    DWORD ulSegPos;
    LONG dist = -1;
    BOOL fResult = FALSE;
    WORD this_seg;

#if 0
    /* first, walk absolute segment */
    if (fAbsolute && map.abs_cnt != 0) {

        /* the thing with seg_ptr below is to allow for an absolute
         * segment with more than 64K of symbols: if the segment
         * pointer of the next symbol is more than 64K away, then
         * add 64K to the beginning of the table of symbol pointers.
         */
        if (ExtractSymbol(iFile,
                          ulMapPos,
                          ulMapPos + pMap->abs_ptr + (pMap->seg_ptr&0xF000)*0x10L,
                          pMap->abs_cnt,
                          0,
                          segment,
                          offset,
                          next,
                          sym_text,
                          pDisplacement)) {
            return TRUE;
        }
    }
#endif

    /* now walk other segments */
    ulSegPos = (DWORD)pMap->seg_ptr * 16;
    for (this_seg = 0; this_seg < pMap->seg_cnt; this_seg++) {
        SYM_SEG seg;

        if (_llseek(iFile, ulSegPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&seg, sizeof(seg)) != sizeof(seg))
            return FALSE;

        if ((segment == 0) || (segment == this_seg+1)) {
            if (ExtractSymbol(iFile,
                              ulSegPos,
                              ulSegPos + seg.sym_ptr,
                              seg.sym_cnt,
                              seg.seg_lsa,
                              segment,
                              offset,
                              next,
                              sym_text,
                              &dist)) {
                fResult = TRUE;
                if (segment != 0) {
                    // only looking in one segment
                    break;
                }
            }
        }
        ulSegPos = (DWORD)seg.nxt_seg * 16;
    }

    if (fResult) {
        *pDisplacement = dist;
    }
    return fResult;
}


BOOL
WINAPI
VDMGetSymbol(
    LPSTR fn,
    WORD segment,
    DWORD offset,
    BOOL bProtectMode,
    BOOL next,
    LPSTR sym_text,
    PDWORD pDisplacement
    )
{
    int         iFile;
    char        filename[256];
    OFSTRUCT    ofs;
    SYM_MAP     map;
    SYM_SEG     seg;
    SYM_ITEM    item;
    ULONG       ulMapPos = 0;

    strncpy(filename, fn,sizeof(filename)-sizeof(".sym"));
    filename[sizeof(filename)-sizeof(".sym")-1] = '\0';
    strcat(filename,".sym");

    iFile = OpenFile( filename, &ofs, MYOF_FLAGS );

    if ( iFile == -1 ) {
        // Open the .EXE/.DLL file and see if the address corresponds
        // to an exported function.
        return(FindExport(fn,segment,(WORD)offset,sym_text,next,pDisplacement));
    }

    do {

        if (_llseek( iFile, ulMapPos, FILE_BEGIN) == -1) {
            PRINTF("VDMDBG: GetSymbol failed to seek to map\n");
            break;
        }

        if (_lread( iFile, (LPSTR)&map, sizeof(map)) != sizeof(map)) {
            PRINTF("VDMDBG: GetSymbol failed to read map\n");
            break;
        }

        if (WalkSegmentsForSymbol(iFile, &map, ulMapPos,
                                  segment, offset, next,
                                  sym_text, pDisplacement)) {
            _lclose( iFile );
            return TRUE;
        }

    } while(ulMapPos);

    _lclose( iFile );
    return FALSE;
}


BOOL
ExtractValue(
    int iFile,
    DWORD ulSegPos,
    DWORD ulSymPos,
    WORD csym,
    LPSTR szSymbol,
    PWORD pValue
    )
{
    WORD uLastSymdefPos=0;
    /* ulWrap allows for wrapping around with more than 64K of symbols */
    DWORD ulWrap=0;
    LONG SymOffset;
    char name_text[256];

    for (; csym--; ulSymPos+=sizeof(WORD))
    {
        WORD uSymdefPos;
        SYM_ITEM sym;

        if (_llseek(iFile, ulSymPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&uSymdefPos, sizeof(uSymdefPos)) != sizeof(uSymdefPos))
            return FALSE;
        if (uSymdefPos < uLastSymdefPos)
            ulWrap += 0x10000L;
        _llseek(iFile, ulSegPos + uSymdefPos + ulWrap, FILE_BEGIN);
        _lread(iFile, (LPSTR)&sym, sizeof(sym));

        strncpy(name_text, sym.sym_name, sym.sym_nam_len);
        name_text[sym.sym_nam_len] = 0;

        if (_stricmp(szSymbol, name_text) == 0) {
            *pValue = sym.sym_val;
            return TRUE;
        }

        uLastSymdefPos = uSymdefPos;
    }

    return FALSE;
}

BOOL
WalkSegmentsForValue(
    int iFile,
    SYM_MAP *pMap,
    ULONG ulMapPos,
    LPSTR szSymbol,
    PWORD pSegmentBase,
    PWORD pSegmentNumber,
    PWORD pValue
    )
{

    DWORD ulSegPos;
    WORD this_seg;

#if 0
    /* first, walk absolute segment */
    if (fAbsolute && pMap->abs_cnt != 0) {

        /* the thing with seg_ptr below is to allow for an absolute
         * segment with more than 64K of symbols: if the segment
         * pointer of the next symbol is more than 64K away, then
         * add 64K to the beginning of the table of symbol pointers.
         */
        if (ExtractValue(iFile,
                          ulMapPos,
                          ulMapPos + pMap->abs_ptr + (pMap->seg_ptr&0xF000)*0x10L,
                          pMap->abs_cnt,
                          szSymbol,
                          pValue)) {
            return TRUE;
        }
    }
#endif

    /* now walk other segments */
    ulSegPos = (DWORD)pMap->seg_ptr * 16;
    for (this_seg = 0; this_seg < pMap->seg_cnt; this_seg++) {
        SYM_SEG seg;

        if (_llseek(iFile, ulSegPos, FILE_BEGIN) == -1)
            return FALSE;
        if (_lread(iFile, (LPSTR)&seg, sizeof(seg)) != sizeof(seg))
            return FALSE;

        if (ExtractValue(iFile,
                          ulSegPos,
                          ulSegPos + seg.sym_ptr,
                          seg.sym_cnt,
                          szSymbol,
                          pValue)) {
            *pSegmentBase = seg.seg_lsa;
            *pSegmentNumber = this_seg+1;
            return TRUE;
        }
        ulSegPos = (DWORD)seg.nxt_seg * 16;
    }
    return FALSE;
}


BOOL
WalkMapForValue(
    LPSTR  fn,
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    )
{
    int         iFile;
    char        filename[256];
    OFSTRUCT    ofs;
    SYM_MAP     map;
    SYM_SEG     seg;
    SYM_ITEM    item;
    ULONG       ulMapPos = 0;
    WORD        SegmentNumber;
    WORD        SegmentBase;
    WORD        Value;

    strncpy(filename, fn, sizeof(filename)-sizeof(".sym"));
    filename[sizeof(filename)-sizeof(".sym")-1] = '\0';
    strcat(filename,".sym");

    iFile = OpenFile( filename, &ofs, MYOF_FLAGS );

    if ( iFile == -1 ) {
        return FALSE;
    }

    do {

        if (_llseek( iFile, ulMapPos, FILE_BEGIN) == -1) {
            PRINTF("VDMDBG: failed to seek to map\n");
            break;
        }

        if (_lread( iFile, (LPSTR)&map, sizeof(map)) != sizeof(map)) {
            PRINTF("VDMDBG: failed to read map\n");
            break;
        }

        if (WalkSegmentsForValue(iFile, &map, ulMapPos,
                                  szSymbol, &SegmentBase, &SegmentNumber, &Value)) {

            VDM_SEGINFO si;

            if (GetInfoBySegmentNumber(fn, SegmentNumber, &si)) {

                *pSelector = si.Selector;
                if (!si.Type) {
                    *pType = VDMADDR_V86;

                    if (!si.SegNumber) {
                        // This is a "combined" map of all the segments,
                        // so we need to calculate the offset
                        *pOffset = (DWORD)SegmentBase*16 + Value;
                    } else {
                        // This is a "split" v86 map
                        *pOffset = (DWORD) Value;
                    }
                } else {
                    *pType = VDMADDR_PM16;
                    *pOffset = (DWORD)Value;
                }

                _lclose( iFile );
                return TRUE;
            }
        }

    } while(ulMapPos);

    _lclose( iFile );
    return FALSE;
}

BOOL
WINAPI
VDMGetAddrExpression(
    LPSTR  szModule,
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    )
{
    int         iFile;
    char        filename[256];
    OFSTRUCT    ofs;
    SYM_MAP     map;
    SYM_SEG     seg;
    SYM_ITEM    item;
    ULONG       ulMapPos = 0;

    if (szModule) {
        return(WalkMapForValue(szModule, szSymbol, pSelector, pOffset, pType));
    }

    return (EnumerateModulesForValue(VDMGetAddrExpression,
                                     szSymbol,
                                     pSelector,
                                     pOffset,
                                     pType));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\segment.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    segment.c

Abstract:

    This module contains the debugging support needed to track
    16-bit VDM segment notifications.

Author:

    Neil Sandlin (neilsa) 1-Mar-1997 Rewrote it

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <stdio.h>

SEGENTRY SegListHead = {0};


//----------------------------------------------------------------------------
// VDMGetSegtablePointer
//
//  This is an undocumented entry point that allows VDMEXTS to dump the
//  segment list
//
//----------------------------------------------------------------------------
PSEGENTRY
WINAPI
VDMGetSegtablePointer(
    VOID
    )
{
    return SegListHead.Next;
}

//----------------------------------------------------------------------------
// VDMIsModuleLoaded
//
//  Given the path parameter, this routine determines if there are any 
//  segments in the segment list from the specified executable.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMIsModuleLoaded(
    LPSTR szPath
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;

    if (!*szPath) {
        return FALSE;
    }

    while (pSegEntry) {
        if ( _stricmp(pSegEntry->szExePath, szPath) == 0 ) {
            return TRUE;
        }
        pSegEntry = pSegEntry->Next;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
// SegmentLoad
//
//  This routine adds an entry to the segment list based on the parameters
//  of a client SegmentLoad notification.
//
//----------------------------------------------------------------------------
BOOL
SegmentLoad(
    WORD selector,
    WORD segment,
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry;

    if (strlen(szExePath) >= MAX_PATH16) {
        return FALSE;
    }
    pSegEntry = MALLOC(sizeof(SEGENTRY));
    if (pSegEntry == NULL) {
        return FALSE;
    }
    pSegEntry->Next = SegListHead.Next;
    SegListHead.Next = pSegEntry;

    pSegEntry->selector = selector;
    pSegEntry->segment = segment;
    pSegEntry->type = SEGTYPE_PROT;
    strcpy( pSegEntry->szExePath, szExePath );
    ParseModuleName(pSegEntry->szModule, szExePath);
    pSegEntry->length = 0;
    return TRUE;
}

//----------------------------------------------------------------------------
// SegmentFree
//
//  This routine removes the entry from the segment list that matches the
//  pass selector.
//
//----------------------------------------------------------------------------
BOOL
SegmentFree(
    WORD selector
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    PSEGENTRY pSegTmp;
    BOOL fResult = FALSE;

    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_PROT) &&
            (pSegEntry->selector == selector)) {
            
            pSegPrev->Next = pSegEntry->Next;
            pSegTmp = pSegEntry;
            pSegEntry = pSegTmp->Next;
            FREE(pSegTmp);
            fResult = TRUE;
            
        } else {
            pSegEntry = pSegEntry->Next;
        }
    }
    return fResult;
}

//----------------------------------------------------------------------------
// ModuleLoad
//
//  This routine adds an entry to the segment list based on the parameters
//  of a client ModuleLoad notification.
//
//----------------------------------------------------------------------------
BOOL
ModuleLoad(
    WORD selector,
    WORD segment,
    DWORD length,
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry;

    if (strlen(szExePath) >= MAX_PATH16) {
        return FALSE;
    }
    pSegEntry = MALLOC(sizeof(SEGENTRY));
    if (pSegEntry == NULL) {
        return FALSE;
    }
    pSegEntry->Next = SegListHead.Next;
    SegListHead.Next = pSegEntry;

    pSegEntry->selector = selector;
    pSegEntry->segment = segment;
    pSegEntry->type = SEGTYPE_V86;
    strcpy( pSegEntry->szExePath, szExePath );
    ParseModuleName(pSegEntry->szModule, szExePath);
    pSegEntry->length = length;
    return TRUE;
}

//----------------------------------------------------------------------------
// ModuleFree
//
//  This routine removes all entries from the segment list that contain
//  the specified path name.
//
//----------------------------------------------------------------------------
BOOL
ModuleFree(
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    PSEGENTRY pSegTmp;
    BOOL fResult = FALSE;

    while (pSegEntry) {
        if ( _stricmp(pSegEntry->szExePath, szExePath) == 0 ) {
        
            pSegPrev->Next = pSegEntry->Next;
            pSegTmp = pSegEntry;
            pSegEntry = pSegTmp->Next;
            FREE(pSegTmp);
            fResult = TRUE;
            
        } else {
            pSegEntry = pSegEntry->Next;
        }
    }
    return fResult;
}

BOOL
V86SegmentMove(
    WORD Selector,
    WORD segment,
    DWORD length,
    LPSTR szExePath
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;

    //
    // first see if one exists already
    //
    pSegEntry = SegListHead.Next;
    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_V86) &&
            (pSegEntry->segment == segment)) {
                // Normal segmove, just update selector
            pSegEntry->selector = Selector;
            return TRUE;
        }
        pSegEntry = pSegEntry->Next;
    }

    //
    // An entry for this segment doesn't exist, so create one
    //

    ModuleLoad(Selector, segment, length, szExePath);

    //
    // Now delete segment zero for this module. This prevents
    // confusion in the symbol routines
    //

    pSegEntry = SegListHead.Next;
    pSegPrev = &SegListHead;
    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_V86) &&
            ( _stricmp(pSegEntry->szExePath, szExePath) == 0 ) &&
            (pSegEntry->segment == 0)) {

            // Unlink and free it
            pSegPrev->Next = pSegEntry->Next;
            FREE(pSegEntry);

            break;
        }
        pSegEntry = pSegEntry->Next;
    }

    return TRUE;
}

BOOL
PMSegmentMove(
    WORD Selector1,
    WORD Selector2
    )
{
    PSEGENTRY pSegEntry;

    if (!Selector2) {
        return (SegmentFree(Selector1));
    }

    // Look for the segment entry
    pSegEntry = SegListHead.Next;
    while (pSegEntry) {
        if ((pSegEntry->type == SEGTYPE_PROT) &&
            (pSegEntry->selector == Selector1)) {
                // Normal segmove, just update selector
            pSegEntry->selector = Selector2;
            return TRUE;
        }
        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// ProcessSegmentNotification
//
//  This routine is the main entry point for the following debugger
//  notifications:
//      DBG_SEGLOAD
//      DBG_SEGFREE
//      DBG_SEGMOVE
//      DBG_MODLOAD
//      DBG_MODFREE
//
//  It is called from VDMProcessException.
//
//----------------------------------------------------------------------------
VOID
ProcessSegmentNotification(
    LPDEBUG_EVENT lpDebugEvent
    )
{
    BOOL            b;
    DWORD           lpNumberOfBytesRead;
    LPDWORD         lpdw;
    SEGMENT_NOTE    se;
    HANDLE          hProcess;
    PSEGENTRY       pSegEntry, pSegPrev;

    lpdw = &(lpDebugEvent->u.Exception.ExceptionRecord.ExceptionInformation[0]);
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    if ( hProcess == HANDLE_NULL ) {
        return;
    }

    b = ReadProcessMemory(hProcess,
                          (LPVOID)lpdw[2],
                          &se,
                          sizeof(se),
                          &lpNumberOfBytesRead );

    if ( !b || lpNumberOfBytesRead != sizeof(se) ) {
        return;
    }

    switch(LOWORD(lpdw[0])) {

    case DBG_SEGLOAD:

        SegmentLoad(se.Selector1, se.Segment, se.FileName);
        break;

    case DBG_SEGMOVE:

        if (se.Type == SN_V86) {
            V86SegmentMove(se.Selector2, se.Segment, se.Length, se.FileName);
        } else {
            PMSegmentMove(se.Selector1, se.Selector2);
        }
        break;

    case DBG_SEGFREE:

        // Here, se.Type is a boolean to tell whether to restore
        // any breakpoints in the segment. That was done in the api
        // because wdeb386 didn't know how to move the breakpoint
        // definitions during a SEGMOVE. Currently, we ignore it, but
        // it would be nice to either support the flag, or better to 
        // have ntsd update the breakpoints based on it.

        SegmentFree(se.Selector1);
        break;

    case DBG_MODFREE:
        ModuleFree(se.FileName);
        break;

    case DBG_MODLOAD:
        ModuleLoad(se.Selector1, 0, se.Length, se.FileName);
        break;

    }

    CloseHandle( hProcess );
}


void
CopySegmentInfo(
    VDM_SEGINFO *si,
    PSEGENTRY pSegEntry
    )
{
    si->Selector = pSegEntry->selector;
    si->SegNumber = pSegEntry->segment;
    si->Length = pSegEntry->length;
    si->Type = (pSegEntry->type == SEGTYPE_V86) ? 0 : 1;
    strcpy(si->ModuleName, pSegEntry->szModule);
    strcpy(si->FileName, pSegEntry->szExePath);
}


//----------------------------------------------------------------------------
// VDMGetSegmentInfo
//
//  This routine fills in a VDM_SEGINFO structure for the segment that matches
//  the specified parameters.
//  notifications:
//      DBG_SEGLOAD
//      DBG_SEGFREE
//      DBG_SEGMOVE
//      DBG_MODLOAD
//      DBG_MODFREE
//
//  It is called from VDMProcessException.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetSegmentInfo(
    WORD Selector,
    ULONG Offset,
    BOOL bProtectMode,
    VDM_SEGINFO *si
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    int mode = bProtectMode ? SEGTYPE_PROT : SEGTYPE_V86;
    ULONG Base, BaseEnd, Target;

    while (pSegEntry) {
        if (pSegEntry->type == mode) {
            switch(mode) {

            case SEGTYPE_PROT:
                if (pSegEntry->selector == Selector) {
                    CopySegmentInfo(si, pSegEntry);
                    return TRUE;
                }
                break;

            case SEGTYPE_V86:
                Base = pSegEntry->selector << 4;
                BaseEnd = Base + pSegEntry->length;
                Target = (Selector << 4) + Offset;
                if ((Target >= Base) && (Target < BaseEnd)) {
                    CopySegmentInfo(si, pSegEntry);
                    return TRUE;
                }
                break;
            }
        }
        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}



BOOL
GetInfoBySegmentNumber(
    LPSTR szModule,
    WORD SegNumber,
    VDM_SEGINFO *si
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    ULONG Base, BaseEnd, Target;

    while (pSegEntry) {

        if (_stricmp(szModule, pSegEntry->szModule) == 0) {

            if (pSegEntry->segment == 0 || pSegEntry->segment == SegNumber) {
                CopySegmentInfo(si, pSegEntry);
                return TRUE;
            }
        }
        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}

BOOL
EnumerateModulesForValue(
    BOOL (WINAPI *pfnEnumModuleProc)(LPSTR,LPSTR,PWORD,PDWORD,PWORD),
    LPSTR  szSymbol,
    PWORD  pSelector,
    PDWORD pOffset,
    PWORD  pType
    )
{
    PSEGENTRY pSegEntry = SegListHead.Next;
    PSEGENTRY pSegPrev = &SegListHead;
    ULONG Base, BaseEnd, Target;

    while (pSegEntry) {

        if (pSegEntry->szModule) {
        //
        // BUGBUG should optimize this so that it only calls
        // the enum proc once per module, instead of once per
        // segment
        //

            if ((*pfnEnumModuleProc)(pSegEntry->szModule,
                                     szSymbol,
                                     pSelector,
                                     pOffset,
                                     pType)) {
                return TRUE;
            }
        }

        pSegEntry = pSegEntry->Next;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\dllentry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllentry.c

Abstract:

    This module contains VdmDbgDllEntry, the entrypoint for
    vdmdbg.dll.  We don't use CRT to speak of, if that changes
    this should be renamed DllMain, which DLLMainCRTStartup calls.
    Also in that case DisableThreadLibraryCalls may be inappropriate.

Author:

    Dave Hart (davehart) 26-Oct-97 Added DllEntry to fix leak
                                   in repeated load/unloads.

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop



BOOL
VdmDbgDllEntry(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

/*++

Routine Description:

    This function is the "entry point" for the DLL, called with
    process and thread attach and detach messages.  We disable
    thread attach and detach notifications since we don't use them.
    The primary reason for this is to clean up open handles to
    the shared memory and associated mutex at process detach, so
    folks who load and unload vdmdbg.dll repeatedly won't leak.

Arguments:

    DllHandle

    Reason

    Context - Not Used

Return Value:

    STATUS_SUCCESS

--*/

{
switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(DllHandle);

        break;


    case DLL_PROCESS_DETACH:

        //
        // Close handles to shared memory and mutex, if we're
        // being unloaded from the process (Context/lpReserved
        // NULL) as opposed to process shutdown (Context 1)
        //

        break;

    default:
        break;
}

    return TRUE;  // FALSE means don't load for DLL_PROCESS_ATTACH
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\vdmdbg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    vdmdbg.c

Abstract:

    This module contains the debugging support needed to debug
    16-bit VDM applications

Author:

    Bob Day      (bobday) 16-Sep-1992 Wrote it

Revision History:

    Neil Sandlin (neilsa) 1-Mar-1997 Enhanced it

--*/

#include <precomp.h>
#pragma hdrstop

WORD LastEventFlags;
DWORD gdwShareWOW;   // just to make include of sharewow.h happy

//----------------------------------------------------------------------------
// VDMGetThreadSelectorEntry()
//
//   Public interface to the InternalGetThreadSelectorEntry, needed because
//   that routine requires the process handle.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetThreadSelectorEntry(
    HANDLE  hProcess,
    HANDLE  hUnused,
    WORD    wSelector,
    LPVDMLDT_ENTRY lpSelectorEntry
) {
    BOOL    fResult;
    UNREFERENCED_PARAMETER(hUnused);

    fResult = InternalGetThreadSelectorEntry(
                    hProcess,
                    wSelector,
                    lpSelectorEntry );

    return( fResult );
}


//----------------------------------------------------------------------------
// VDMGetPointer()
//
//   Public interface to the InternalGetPointer, needed because that
//   routine requires the process handle.
//
//----------------------------------------------------------------------------
ULONG
WINAPI
VDMGetPointer(
    HANDLE  hProcess,
    HANDLE  hUnused,
    WORD    wSelector,
    DWORD   dwOffset,
    BOOL    fProtMode
) {
    ULONG   ulResult;
    UNREFERENCED_PARAMETER(hUnused);

    ulResult = InternalGetPointer(
                hProcess,
                wSelector,
                dwOffset,
                fProtMode );

    return( ulResult );
}

//
// Obselete functions
//
BOOL
WINAPI
VDMGetThreadContext(
    LPDEBUG_EVENT lpDebugEvent, 
    LPVDMCONTEXT    lpVDMContext)
{
    HANDLE          hProcess;
    BOOL bReturn;
    
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    bReturn = VDMGetContext(hProcess, NULL, lpVDMContext);
    
    CloseHandle( hProcess );
    return bReturn;
}

BOOL WINAPI VDMSetThreadContext(
    LPDEBUG_EVENT lpDebugEvent, 
    LPVDMCONTEXT    lpVDMContext)
{
    HANDLE          hProcess;
    BOOL bReturn;
    
    hProcess = OpenProcess( PROCESS_VM_READ, FALSE, lpDebugEvent->dwProcessId );

    bReturn = VDMSetContext(hProcess, NULL, lpVDMContext);
    
    CloseHandle( hProcess );
    return bReturn;
}

//----------------------------------------------------------------------------
// VDMGetContext()
//
//   Interface to get the simulated context.  The same functionality as
//   GetThreadContext except that it happens on the simulated 16-bit context,
//   rather than the 32-bit context.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
) {
    VDMCONTEXT      vcContext;
    BOOL            b;
    DWORD           lpNumberOfBytesRead;
    int             i;
    BOOL            bUseVDMContext = TRUE;

#ifdef _X86_
    if (hThread) {
        vcContext.ContextFlags = lpVDMContext->ContextFlags;
        if (!GetThreadContext(hThread, (CONTEXT*)&vcContext)) {
            return FALSE;
        }
        if ((vcContext.EFlags & V86FLAGS_V86) || (vcContext.SegCs != 0x1b)) {
            bUseVDMContext = FALSE;
        }
    }
#endif 

    if (bUseVDMContext) {
        b = ReadProcessMemory(hProcess,
                              lpVdmContext,
                              &vcContext,
                              sizeof(vcContext),
                              &lpNumberOfBytesRead
                              );
        if ( !b || lpNumberOfBytesRead != sizeof(vcContext) ) {
            return( FALSE );
        }
    }

#ifdef _X86_
    if ((lpVDMContext->ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        lpVDMContext->Ebp    = vcContext.Ebp;
        lpVDMContext->Eip    = vcContext.Eip;
        lpVDMContext->SegCs  = vcContext.SegCs;
        lpVDMContext->EFlags = vcContext.EFlags;
        lpVDMContext->SegSs  = vcContext.SegSs;
        lpVDMContext->Esp    = vcContext.Esp;
    }

    //
    // Set segment register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //
        // These values are junk most of the time, but useful
        // for debugging under certain conditions.  Therefore,
        // we report whatever was in the frame.
        //

        lpVDMContext->SegGs = vcContext.SegGs;
        lpVDMContext->SegFs = vcContext.SegFs;
        lpVDMContext->SegEs = vcContext.SegEs;
        lpVDMContext->SegDs = vcContext.SegDs;
    }

    //
    // Set integer register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_INTEGER) == VDMCONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        lpVDMContext->Edi = vcContext.Edi;
        lpVDMContext->Esi = vcContext.Esi;
        lpVDMContext->Ebx = vcContext.Ebx;
        lpVDMContext->Ecx = vcContext.Ecx;
        lpVDMContext->Edx = vcContext.Edx;
        lpVDMContext->Eax = vcContext.Eax;
    }

    //
    // Fetch floating register contents if requested, and type of target
    // is user.  (system frames have no fp state, so ignore request)
    //

    if ( (lpVDMContext->ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
          VDMCONTEXT_FLOATING_POINT ) {

        lpVDMContext->FloatSave.ControlWord   = vcContext.FloatSave.ControlWord;
        lpVDMContext->FloatSave.StatusWord    = vcContext.FloatSave.StatusWord;
        lpVDMContext->FloatSave.TagWord       = vcContext.FloatSave.TagWord;
        lpVDMContext->FloatSave.ErrorOffset   = vcContext.FloatSave.ErrorOffset;
        lpVDMContext->FloatSave.ErrorSelector = vcContext.FloatSave.ErrorSelector;
        lpVDMContext->FloatSave.DataOffset    = vcContext.FloatSave.DataOffset;
        lpVDMContext->FloatSave.DataSelector  = vcContext.FloatSave.DataSelector;
        lpVDMContext->FloatSave.Cr0NpxState   = vcContext.FloatSave.Cr0NpxState;
        for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
            lpVDMContext->FloatSave.RegisterArea[i] = vcContext.FloatSave.RegisterArea[i];
        }
    }

    //
    // Fetch Dr register contents if requested.  Values may be trash.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS) {

        lpVDMContext->Dr0 = vcContext.Dr0;
        lpVDMContext->Dr1 = vcContext.Dr1;
        lpVDMContext->Dr2 = vcContext.Dr2;
        lpVDMContext->Dr3 = vcContext.Dr3;
        lpVDMContext->Dr6 = vcContext.Dr6;
        lpVDMContext->Dr7 = vcContext.Dr7;
    }

#else

    {
        NT_CPU_INFO nt_cpu_info;
        BOOL        bInNano;
        ULONG       UMask;

        b = ReadProcessMemory(hProcess,
                              lpNtCpuInfo,
                              &nt_cpu_info,
                              sizeof(NT_CPU_INFO),
                              &lpNumberOfBytesRead
                              );
        if ( !b || lpNumberOfBytesRead != sizeof(NT_CPU_INFO) ) {
            return( FALSE );
        }

        
        bInNano = ReadDword(hProcess, nt_cpu_info.in_nano_cpu);
        UMask   = ReadDword(hProcess, nt_cpu_info.universe);

        lpVDMContext->Eax = GetRegValue(hProcess, nt_cpu_info.eax, bInNano, UMask);
        lpVDMContext->Ecx = GetRegValue(hProcess, nt_cpu_info.ecx, bInNano, UMask);
        lpVDMContext->Edx = GetRegValue(hProcess, nt_cpu_info.edx, bInNano, UMask);
        lpVDMContext->Ebx = GetRegValue(hProcess, nt_cpu_info.ebx, bInNano, UMask);
        lpVDMContext->Ebp = GetRegValue(hProcess, nt_cpu_info.ebp, bInNano, UMask);
        lpVDMContext->Esi = GetRegValue(hProcess, nt_cpu_info.esi, bInNano, UMask);
        lpVDMContext->Edi = GetRegValue(hProcess, nt_cpu_info.edi, bInNano, UMask);

        lpVDMContext->Esp    = GetEspValue(hProcess, nt_cpu_info, bInNano);

        //
        // nt_cpu_info.flags isn't very much use, because several of the
        // flags values are not kept in memory, but computed each time.
        // The emulator doesn't supply us with the right value, so we
        // try to get it from the code in ntvdmd.dll
        //

        lpVDMContext->EFlags = vcContext.EFlags;

        //
        // On risc platforms, we don't run in V86 mode, we run in REAL mode.
        // So the widespread usage of testing the V86 mode bit in EFLAGS
        // would not correctly determine the address mode. Since there is
        // no more room in the VDM context structure, the simplest thing
        // to do is simply pretend to be in V86 mode when we are in REAL mode.
        //
        if (ReadDword(hProcess, nt_cpu_info.cr0) & 1) {
            lpVDMContext->EFlags |= V86FLAGS_V86;
        }

        lpVDMContext->Eip    = ReadDword(hProcess, nt_cpu_info.eip);

        lpVDMContext->SegEs = ReadWord(hProcess, nt_cpu_info.es);
        lpVDMContext->SegCs = ReadWord(hProcess, nt_cpu_info.cs);
        lpVDMContext->SegSs = ReadWord(hProcess, nt_cpu_info.ss);
        lpVDMContext->SegDs = ReadWord(hProcess, nt_cpu_info.ds);
        lpVDMContext->SegFs = ReadWord(hProcess, nt_cpu_info.fs);
        lpVDMContext->SegGs = ReadWord(hProcess, nt_cpu_info.gs);

    }
#endif

    return( TRUE );
}

//----------------------------------------------------------------------------
// VDMSetContext()
//
//   Interface to set the simulated context.  Similar in most respects to
//   the SetThreadContext API supported by Win NT.  Only differences are
//   in the bits which must be "sanitized".
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMSetContext(
    HANDLE          hProcess,
    HANDLE          hThread,
    LPVDMCONTEXT    lpVDMContext
) {
    VDMINTERNALINFO viInfo;
    VDMCONTEXT      vcContext;
    BOOL            b;
    DWORD           lpNumberOfBytes;
    INT             i;
    BOOL            bUseVDMContext = TRUE;

#ifdef _X86_
    if (hThread) {
        if (!GetThreadContext(hThread, (CONTEXT*)&vcContext)) {
            return FALSE;
        }
        if ((vcContext.EFlags & V86FLAGS_V86) || (vcContext.SegCs != 0x1b)) {
            bUseVDMContext = FALSE;
        }
    }
#endif

    if (bUseVDMContext) {
        b = ReadProcessMemory(hProcess,
                              lpVdmContext,
                              &vcContext,
                              sizeof(vcContext),
                              &lpNumberOfBytes
                              );
        if ( !b || lpNumberOfBytes != sizeof(vcContext) ) {
            return( FALSE );
        }
    }

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_CONTROL) == VDMCONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        vcContext.Ebp    = lpVDMContext->Ebp;
        vcContext.Eip    = lpVDMContext->Eip;

        //
        // Don't allow them to modify the mode bit.
        //
        // Only allow these bits to get set:  01100000110111110111
        //    V86FLAGS_CARRY        0x00001
        //    V86FLAGS_?            0x00002
        //    V86FLAGS_PARITY       0x00004
        //    V86FLAGS_AUXCARRY     0x00010
        //    V86FLAGS_ZERO         0x00040
        //    V86FLAGS_SIGN         0x00080
        //    V86FLAGS_TRACE        0x00100
        //    V86FLAGS_INTERRUPT    0x00200
        //    V86FLAGS_DIRECTION    0x00400
        //    V86FLAGS_OVERFLOW     0x00800
        //    V86FLAGS_RESUME       0x10000
        //    V86FLAGS_VM86         0x20000
        //    V86FLAGS_ALIGNMENT    0x40000
        //
        // Commonly flags will be 0x10246
        //
        if ( vcContext.EFlags & V86FLAGS_V86 ) {
            vcContext.EFlags = V86FLAGS_V86 | (lpVDMContext->EFlags &
               ( V86FLAGS_CARRY
               | 0x0002
               | V86FLAGS_PARITY
               | V86FLAGS_AUXCARRY
               | V86FLAGS_ZERO
               | V86FLAGS_SIGN
               | V86FLAGS_TRACE
               | V86FLAGS_INTERRUPT
               | V86FLAGS_DIRECTION
               | V86FLAGS_OVERFLOW
               | V86FLAGS_RESUME
               | V86FLAGS_ALIGNMENT
               | V86FLAGS_IOPL
               ));
        } else {
            vcContext.EFlags = ~V86FLAGS_V86 & (lpVDMContext->EFlags &
               ( V86FLAGS_CARRY
               | 0x0002
               | V86FLAGS_PARITY
               | V86FLAGS_AUXCARRY
               | V86FLAGS_ZERO
               | V86FLAGS_SIGN
               | V86FLAGS_TRACE
               | V86FLAGS_INTERRUPT
               | V86FLAGS_DIRECTION
               | V86FLAGS_OVERFLOW
               | V86FLAGS_RESUME
               | V86FLAGS_ALIGNMENT
               | V86FLAGS_IOPL
               ));
        }

        //
        // CS might only be allowable as a ring 3 selector.
        //
        if ( vcContext.EFlags & V86FLAGS_V86 ) {
            vcContext.SegCs  = lpVDMContext->SegCs;
        } else {
#ifdef i386
            vcContext.SegCs  = lpVDMContext->SegCs | 0x0003;
#else
            vcContext.SegCs  = lpVDMContext->SegCs;
#endif
        }

        vcContext.SegSs  = lpVDMContext->SegSs;
        vcContext.Esp    = lpVDMContext->Esp;
    }

    //
    // Set segment register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_SEGMENTS) == VDMCONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //
        vcContext.SegGs = lpVDMContext->SegGs;
        vcContext.SegFs = lpVDMContext->SegFs;
        vcContext.SegEs = lpVDMContext->SegEs;
        vcContext.SegDs = lpVDMContext->SegDs;
    }

    //
    // Set integer register contents if specified.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_INTEGER) == VDMCONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        vcContext.Edi = lpVDMContext->Edi;
        vcContext.Esi = lpVDMContext->Esi;
        vcContext.Ebx = lpVDMContext->Ebx;
        vcContext.Ecx = lpVDMContext->Ecx;
        vcContext.Edx = lpVDMContext->Edx;
        vcContext.Eax = lpVDMContext->Eax;
    }

    //
    // Fetch floating register contents if requested, and type of target
    // is user.
    //

    if ( (lpVDMContext->ContextFlags & VDMCONTEXT_FLOATING_POINT) ==
          VDMCONTEXT_FLOATING_POINT ) {

        vcContext.FloatSave.ControlWord   = lpVDMContext->FloatSave.ControlWord;
        vcContext.FloatSave.StatusWord    = lpVDMContext->FloatSave.StatusWord;
        vcContext.FloatSave.TagWord       = lpVDMContext->FloatSave.TagWord;
        vcContext.FloatSave.ErrorOffset   = lpVDMContext->FloatSave.ErrorOffset;
        vcContext.FloatSave.ErrorSelector = lpVDMContext->FloatSave.ErrorSelector;
        vcContext.FloatSave.DataOffset    = lpVDMContext->FloatSave.DataOffset;
        vcContext.FloatSave.DataSelector  = lpVDMContext->FloatSave.DataSelector;
        vcContext.FloatSave.Cr0NpxState   = lpVDMContext->FloatSave.Cr0NpxState;
        for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
            vcContext.FloatSave.RegisterArea[i] = lpVDMContext->FloatSave.RegisterArea[i];
        }
    }

    //
    // Fetch Dr register contents if requested.  Values may be trash.
    //

    if ((lpVDMContext->ContextFlags & VDMCONTEXT_DEBUG_REGISTERS) ==
        VDMCONTEXT_DEBUG_REGISTERS) {

        vcContext.Dr0 = lpVDMContext->Dr0;
        vcContext.Dr1 = lpVDMContext->Dr1;
        vcContext.Dr2 = lpVDMContext->Dr2;
        vcContext.Dr3 = lpVDMContext->Dr3;
        vcContext.Dr6 = lpVDMContext->Dr6;
        vcContext.Dr7 = lpVDMContext->Dr7;
    }

#ifdef _X86_
    if (!bUseVDMContext) {
        if (!SetThreadContext(hThread, (CONTEXT*)&vcContext)) {
            return FALSE;
        }
    }
#endif

    b = WriteProcessMemory(
            hProcess,
            lpVdmContext,
            &vcContext,
            sizeof(vcContext),
            &lpNumberOfBytes
            );

    if ( !b || lpNumberOfBytes != sizeof(vcContext) ) {
        return( FALSE );
    }

    return( TRUE );
}

//----------------------------------------------------------------------------
// VDMBreakThread()
//
//   Interface to interrupt a thread while it is running without any break-
//   points.  An ideal debugger would have this feature.  Since it is hard
//   to implement, we will be doing it later.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMBreakThread(
    HANDLE      hProcess,
    HANDLE      hThread
) {
    return( FALSE );
}

//----------------------------------------------------------------------------
// VDMProcessException()
//
//   This function acts as a filter of debug events.  Most debug events
//   should be ignored by the debugger (because they don't have the context
//   record pointer or the internal info structure setup.  Those events
//   cause this function to return FALSE, which tells the debugger to just
//   blindly continue the exception.  When the function does return TRUE,
//   the debugger should look at the exception code to determine what to
//   do (and all the the structures have been set up properly to deal with
//   calls to the other APIs).
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMProcessException(
    LPDEBUG_EVENT lpDebugEvent
) {
    LPDWORD         lpdw;
    int             mode;
    BOOL            fResult = TRUE;

    lpdw = &(lpDebugEvent->u.Exception.ExceptionRecord.ExceptionInformation[0]);

    mode = LOWORD(lpdw[0]);
    LastEventFlags = HIWORD(lpdw[0]);

    switch( mode ) {
        case DBG_SEGLOAD:
        case DBG_SEGMOVE:
        case DBG_SEGFREE:
        case DBG_MODLOAD:
        case DBG_MODFREE:
            ProcessSegmentNotification(lpDebugEvent);
            fResult = FALSE;
            break;
            
        case DBG_BREAK:
            ProcessBPNotification(lpDebugEvent);
            break;            
    }

    ProcessInitNotification(lpDebugEvent);

    return( fResult );
}


//----------------------------------------------------------------------------
// VDMGetSelectorModule()
//
//   Interface to determine the module and segment associated with a given
//   selector.  This is useful during debugging to associate symbols with
//   code and data segments.  The symbol lookup should be done by the
//   debugger, given the module and segment number.
//
//   This code was adapted from the Win 3.1 ToolHelp DLL
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetSelectorModule(
    HANDLE          hProcess,
    HANDLE          hUnused,
    WORD            wSelector,
    PUINT           lpSegmentNumber,
    LPSTR           lpModuleName,
    UINT            nNameSize,
    LPSTR           lpModulePath,
    UINT            nPathSize
) {
    BOOL            b;
    DWORD           lpNumberOfBytes;
    BOOL            fResult;
    DWORD           lphMaster;
    DWORD           lphMasterLen;
    DWORD           lphMasterStart;
    DWORD           lpOwner;
    DWORD           lpThisModuleResTab;
    DWORD           lpThisModuleName;
    DWORD           lpPath;
    DWORD           lpThisModulecSeg;
    DWORD           lpThisModuleSegTab;
    DWORD           lpThisSegHandle;
    WORD            wMaster;
    WORD            wMasterLen;
    DWORD           dwMasterStart;
    DWORD           dwArenaOffset;
    WORD            wArenaSlot;
    DWORD           lpArena;
    WORD            wModHandle;
    WORD            wResTab;
    UCHAR           cLength;
    WORD            wPathOffset;
    UCHAR           cPath;
    WORD            cSeg;
    WORD            iSeg;
    WORD            wSegTab;
    WORD            wHandle;
//    CHAR            chName[MAX_MODULE_NAME_LENGTH];
//    CHAR            chPath[MAX_MODULE_PATH_LENGTH];
    UNREFERENCED_PARAMETER(hUnused);

    if ( lpModuleName != NULL ) *lpModuleName = '\0';
    if ( lpModulePath != NULL ) *lpModulePath = '\0';
    if ( lpSegmentNumber != NULL ) *lpSegmentNumber = 0;

    fResult = FALSE;

#if 0
    if ( wKernelSeg == 0 ) {
        return( FALSE );
    }

    // Read out the master heap selector

    lphMaster = InternalGetPointer(
                    hProcess,
                    wKernelSeg,
                    dwOffsetTHHOOK + TOOL_HMASTER,  // To hGlobalHeap
                    TRUE );
    if ( lphMaster == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lphMaster,
            &wMaster,
            sizeof(wMaster),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wMaster) ) goto punt;

    wMaster |= 1;          // Convert to selector

    // Read out the master heap selector length

    lphMasterLen = InternalGetPointer(
                    hProcess,
                    wKernelSeg,
                    dwOffsetTHHOOK + TOOL_HMASTLEN, // To SelTableLen
                    TRUE );
    if ( lphMasterLen == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lphMasterLen,
            &wMasterLen,
            sizeof(wMasterLen),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wMasterLen) ) goto punt;

    // Read out the master heap selector start

    lphMasterStart = InternalGetPointer(
                    hProcess,
                    wKernelSeg,
                    dwOffsetTHHOOK + TOOL_HMASTSTART,   // To SelTableStart
                    TRUE );
    if ( lphMasterStart == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lphMasterStart,
            &dwMasterStart,
            sizeof(dwMasterStart),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(dwMasterStart) ) goto punt;

    // Now make sure the selector provided is in the right range

    if ( fKernel386 ) {

        // 386 kernel?
        wArenaSlot = (WORD)(wSelector & 0xFFF8);   // Mask low 3 bits

        wArenaSlot = wArenaSlot >> 1;       // Sel/8*4

        if ( (WORD)wArenaSlot > wMasterLen ) goto punt;   // Out of range

        wArenaSlot += (WORD)dwMasterStart;

        // Ok, Now read out the area header offset

        dwArenaOffset = (DWORD)0;               // Default to 0

        lpArena = InternalGetPointer(
                        hProcess,
                        wMaster,
                        wArenaSlot,
                        TRUE );
        if ( lpArena == (DWORD)NULL ) goto punt;

        // 386 Kernel?
        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpArena,
                &dwArenaOffset,
                sizeof(dwArenaOffset),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(dwArenaOffset) ) goto punt;

        // Read out the owner member

        lpOwner = InternalGetPointer(
                        hProcess,
                        wMaster,
                        dwArenaOffset+GA_OWNER386,
                        TRUE );
        if ( lpOwner == (DWORD)NULL ) goto punt;

    } else {
        lpOwner = InternalGetPointer(
                        hProcess,
                        wSelector,
                        0,
                        TRUE );
        if ( lpOwner == (DWORD)NULL ) goto punt;

        lpOwner -= GA_SIZE;
        lpOwner += GA_OWNER;
    }

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpOwner,
            &wModHandle,
            sizeof(wModHandle),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wModHandle) ) goto punt;

    // Now read out the owners module name

    // Name is the first name in the resident names table

    lpThisModuleResTab = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_RESTAB,
                        TRUE );
    if ( lpThisModuleResTab == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleResTab,
            &wResTab,
            sizeof(wResTab),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wResTab) ) goto punt;

    // Get the 1st byte of the resident names table (1st byte of module name)

    lpThisModuleName = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        wResTab,
                        TRUE );
    if ( lpThisModuleName == (DWORD)NULL ) goto punt;

    // PASCAL string (1st byte is length), read the byte.

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &cLength,
            sizeof(cLength),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cLength) ) goto punt;

    if ( cLength > MAX_MODULE_NAME_LENGTH ) goto punt;

    // Now go read the text of the name

    lpThisModuleName += 1;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &chName,
            cLength,
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != (DWORD)cLength ) goto punt;

    chName[cLength] = '\0';     // Nul terminate it

    // Grab out the path name too!

    lpPath = InternalGetPointer(
                    hProcess,
                    wModHandle,
                    NE_PATHOFFSET,
                    TRUE );
    if ( lpPath == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpPath,
            &wPathOffset,
            sizeof(wPathOffset),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wPathOffset) ) goto punt;

    // Get the 1st byte of the path name

    lpThisModuleName = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        wPathOffset,
                        TRUE );
    if ( lpThisModuleName == (DWORD)NULL ) goto punt;

    // PASCAL string (1st byte is length), read the byte.

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &cPath,
            sizeof(cPath),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cPath) ) goto punt;

    if ( cPath > MAX_MODULE_NAME_LENGTH ) goto punt;

    lpThisModuleName += 8;          // 1st 8 characters are ignored
    cPath -= 8;

    // Now go read the text of the name

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleName,
            &chPath,
            cPath,
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != (DWORD)cPath ) goto punt;

    chPath[cPath] = '\0';     // Nul terminate it

    // Ok, we found the module we need, now grab the right selector for the
    // segment number passed in.

    lpThisModulecSeg = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_CSEG,
                        TRUE );
    if ( lpThisModulecSeg == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModulecSeg,
            &cSeg,
            sizeof(cSeg),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cSeg) ) goto punt;

    // Read the segment table pointer for this module

    lpThisModuleSegTab = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_SEGTAB,
                        TRUE );
    if ( lpThisModuleSegTab == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleSegTab,
            &wSegTab,
            sizeof(wSegTab),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wSegTab) ) goto punt;

    // Loop through all of the segments for this module trying to find
    // one with the right handle.

    iSeg = 0;
    wSelector &= 0xFFF8;

    while ( iSeg < cSeg ) {

        lpThisSegHandle = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            wSegTab+iSeg*NEW_SEG1_SIZE+NS_HANDLE,
                            TRUE );
        if ( lpThisSegHandle == (DWORD)NULL ) goto punt;

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisSegHandle,
                &wHandle,
                sizeof(wHandle),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(wHandle) ) goto punt;

        wHandle &= 0xFFF8;

        if ( wHandle == (WORD)wSelector ) {
            break;
        }
        iSeg++;
    }

    if ( iSeg >= cSeg ) goto punt;      // Wasn't found at all!

    if ( lpModuleName && strlen(chName)+1 > nNameSize ) goto punt;
    if ( lpModulePath && strlen(chPath)+1 > nPathSize ) goto punt;

    if ( lpModuleName != NULL ) strcpy( lpModuleName, chName );
    if ( lpModulePath != NULL ) strcpy( lpModulePath, chPath );
    if ( lpSegmentNumber != NULL ) *lpSegmentNumber = iSeg;

    fResult = TRUE;

punt:
#endif
    return( fResult );
}

//----------------------------------------------------------------------------
// VDMGetModuleSelector()
//
//   Interface to determine the selector for a given module's segment.
//   This is useful during debugging to associate code and data segments
//   with symbols.  The symbol lookup should be done by the debugger, to
//   determine the module and segment number, which are then passed to us
//   and we determine the current selector for that module's segment.
//
//   Again, this code was adapted from the Win 3.1 ToolHelp DLL
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMGetModuleSelector(
    HANDLE          hProcess,
    HANDLE          hUnused,
    UINT            uSegmentNumber,
    LPSTR           lpModuleName,
    LPWORD          lpSelector
) {
    BOOL            b;
    DWORD           lpNumberOfBytes;
    BOOL            fResult;
    WORD            wModHandle;
    DWORD           lpModuleHead;
    DWORD           lpThisModuleName;
    DWORD           lpThisModuleNext;
    DWORD           lpThisModuleResTab;
    DWORD           lpThisModulecSeg;
    DWORD           lpThisModuleSegTab;
    DWORD           lpThisSegHandle;
    WORD            wResTab;
    UCHAR           cLength;
    WORD            cSeg;
    WORD            wSegTab;
    WORD            wHandle;
//    CHAR            chName[MAX_MODULE_NAME_LENGTH];
    UNREFERENCED_PARAMETER(hUnused);

    *lpSelector = 0;

    fResult = FALSE;

#if 0
    if ( wKernelSeg == 0 ) {
        return( FALSE );
    }

    lpModuleHead = InternalGetPointer(
                        hProcess,
                        wKernelSeg,
                        dwOffsetTHHOOK + TOOL_HMODFIRST,
                        TRUE );
    if ( lpModuleHead == (DWORD)NULL ) goto punt;

    // lpModuleHead is a pointer into kernels data segment. It points to the
    // head of the module list (a chain of near pointers).

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpModuleHead,
            &wModHandle,
            sizeof(wModHandle),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wModHandle) ) goto punt;

    while( wModHandle != (WORD)0 ) {

        wModHandle |= 1;

        // Name is the first name in the resident names table

        lpThisModuleResTab = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            NE_RESTAB,
                            TRUE );
        if ( lpThisModuleResTab == (DWORD)NULL ) goto punt;

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleResTab,
                &wResTab,
                sizeof(wResTab),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(wResTab) ) goto punt;

        // Get the 1st byte of the resident names table (1st byte of module name)

        lpThisModuleName = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            wResTab,
                            TRUE );
        if ( lpThisModuleName == (DWORD)NULL ) goto punt;

        // PASCAL string (1st byte is length), read the byte.

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleName,
                &cLength,
                sizeof(cLength),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(cLength) ) goto punt;

        if ( cLength > MAX_MODULE_NAME_LENGTH ) goto punt;

        lpThisModuleName += 1;

        // Now go read the text of the name

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleName,
                &chName,
                cLength,
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != (DWORD)cLength ) goto punt;

        chName[cLength] = '\0';     // Nul terminate it

        if ( _stricmp(chName, lpModuleName) == 0 ) {
            // Found the name which matches!
            break;
        }

        // Move to the next module in the list.

        lpThisModuleNext = InternalGetPointer(
                            hProcess,
                            wModHandle,
                            NE_CBENTTAB,
                            TRUE );
        if ( lpThisModuleNext == (DWORD)NULL ) goto punt;

        b = ReadProcessMemory(
                hProcess,
                (LPVOID)lpThisModuleNext,
                &wModHandle,
                sizeof(wModHandle),
                &lpNumberOfBytes
                );
        if ( !b || lpNumberOfBytes != sizeof(wModHandle) ) goto punt;
    }

    if ( wModHandle == (WORD)0 ) {
        goto punt;
    }

    // Ok, we found the module we need, now grab the right selector for the
    // segment number passed in.

    lpThisModulecSeg = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_CSEG,
                        TRUE );
    if ( lpThisModulecSeg == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModulecSeg,
            &cSeg,
            sizeof(cSeg),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(cSeg) ) goto punt;

    if ( uSegmentNumber > (DWORD)cSeg ) goto punt;

    // Read the segment table pointer for this module

    lpThisModuleSegTab = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        NE_SEGTAB,
                        TRUE );
    if ( lpThisModuleSegTab == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisModuleSegTab,
            &wSegTab,
            sizeof(wSegTab),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wSegTab) ) goto punt;

    lpThisSegHandle = InternalGetPointer(
                        hProcess,
                        wModHandle,
                        wSegTab+(WORD)uSegmentNumber*NEW_SEG1_SIZE+NS_HANDLE,
                        TRUE );
    if ( lpThisSegHandle == (DWORD)NULL ) goto punt;

    b = ReadProcessMemory(
            hProcess,
            (LPVOID)lpThisSegHandle,
            &wHandle,
            sizeof(wHandle),
            &lpNumberOfBytes
            );
    if ( !b || lpNumberOfBytes != sizeof(wHandle) ) goto punt;

    *lpSelector = (WORD)(wHandle | 1);

    fResult = TRUE;

punt:
#endif
    return( fResult );
}



DWORD
WINAPI
VDMGetDbgFlags(
    HANDLE hProcess
    )
{
    ULONG NtvdmState;
    ULONG VdmDbgFlags;
    BOOL b;
    DWORD lpNumberOfBytes;

    //
    // Merge in the two places where our flags are kept
    //
    b = ReadProcessMemory(hProcess, lpNtvdmState, &NtvdmState,
                          sizeof(NtvdmState), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(NtvdmState) ) {
        return 0;
    }

    b = ReadProcessMemory(hProcess, lpVdmDbgFlags, &VdmDbgFlags,
                          sizeof(VdmDbgFlags), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(VdmDbgFlags) ) {
        return 0;
    }

    return ((NtvdmState & (VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER)) |
            (VdmDbgFlags & ~(VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER)));
}

BOOL
WINAPI
VDMSetDbgFlags(
    HANDLE hProcess,
    DWORD VdmDbgFlags
    )
{
    ULONG NtvdmState;
    BOOL b;
    DWORD lpNumberOfBytes;

    //
    // The flags are spread out in two places, so split off the appropriate
    // bits and write them separately.
    //
    b = ReadProcessMemory(hProcess, lpNtvdmState, &NtvdmState,
                          sizeof(NtvdmState), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(NtvdmState) ) {
        return FALSE;
    }

    
    NtvdmState &= ~(VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER);
    NtvdmState |= VdmDbgFlags & (VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER);


    b = WriteProcessMemory(hProcess, lpNtvdmState, &NtvdmState,
                           sizeof(NtvdmState), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(NtvdmState) ) {
        return FALSE;
    }

    VdmDbgFlags &= ~(VDMDBG_BREAK_EXCEPTIONS | VDMDBG_BREAK_DEBUGGER);
    b = WriteProcessMemory(hProcess, lpVdmDbgFlags, &VdmDbgFlags,
                           sizeof(VdmDbgFlags), &lpNumberOfBytes);

    if ( !b || lpNumberOfBytes != sizeof(VdmDbgFlags) ) {
        return FALSE;
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmdbg\wow.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    wow.c

Abstract:

    This module contains the WOW vdmdbg functions


Revision History:

--*/
#include <precomp.h>
#pragma hdrstop

typedef WORD HAND16;

#define SHAREWOW_MAIN
#include <vdmapi.h>
#include <vdm.h>


//----------------------------------------------------------------------------
// VDMKillWOW()
//
//   Interface to kill the wow sub-system.  This may not be needed and is
//   certainly not needed now.  We are going to look into fixing the
//   debugging interface so this is not necessary.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMKillWOW(
    VOID
) {
    return( FALSE );
}

//----------------------------------------------------------------------------
// VDMDetectWOW()
//
//   Interface to detect whether the wow sub-system has already been started.
//   This may not be needed and is certainly not needed now.  We are going
//   to look into fixing the debugging interface so this is not necessary.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
VDMDetectWOW(
    VOID
) {
    return( FALSE );
}


INT
WINAPI
VDMEnumProcessWOW(
    PROCESSENUMPROC fp,
    LPARAM          lparam
) {
    SHAREDPROCESS       SharedProcess[16];
    LPSHAREDPROCESS     lpsp;    
    INT                 count = 0;
    BOOL                fRet;
    VDMINFO             VdmInfo;
    DWORD               cbProcArray;
    BOOL                fRetry = FALSE;


    RtlZeroMemory(&VdmInfo, sizeof(VDMINFO));
    VdmInfo.iTask = 0;
    VdmInfo.VDMState = ASKING_FOR_WOWPROCLIST;
    VdmInfo.Enviornment = SharedProcess;
    VdmInfo.EnviornmentSize = sizeof(SharedProcess);

    cbProcArray = sizeof(SharedProcess);

VDMEnumProcessRetry:

    if(GetNextVDMCommand(&VdmInfo)) {                 
       
       if (cbProcArray < VdmInfo.EnviornmentSize &&
           !fRetry) 
       {
          lpsp = MALLOC(VdmInfo.EnviornmentSize);
          if(!lpsp) {
             return 0;
          }
          VdmInfo.Enviornment = lpsp;
          cbProcArray = VdmInfo.EnviornmentSize;
          fRetry = TRUE;   
       
          goto VDMEnumProcessRetry;
       }

       count = 0;
       lpsp = (LPSHAREDPROCESS) VdmInfo.Enviornment;

       cbProcArray = cbProcArray > VdmInfo.EnviornmentSize ? VdmInfo.EnviornmentSize : cbProcArray;

       while (cbProcArray) {
              cbProcArray -= sizeof(SHAREDPROCESS);       
              count++;
              if ( fp ) {
                  fRet = (*fp)( lpsp->dwProcessId, lpsp->dwAttributes, lparam );
                  if ( fRet ) {              
                     break;
                  }
              }     
              lpsp++;
       }
    }

    if (fRetry) {
        FREE(VdmInfo.Enviornment);
    }
        
    return( count );
}


INT
WINAPI
VDMEnumTaskWOWWorker(
    DWORD           dwProcessId,
    void *          fp,
    LPARAM          lparam,
    BOOL            fEx
) {
    SHAREDTASK          SharedTask[16];
    LPSHAREDTASK        lpst;
    INT                 count = 0;
    BOOL                fRet;
    VDMINFO             VdmInfo;
    DWORD               cbTaskArray;
    BOOL                fRetry = FALSE;

    RtlZeroMemory(&VdmInfo, sizeof(VDMINFO));

    VdmInfo.VDMState = ASKING_FOR_WOWTASKLIST;
    VdmInfo.Enviornment = SharedTask;
    VdmInfo.EnviornmentSize = sizeof(SharedTask);
    VdmInfo.iTask = dwProcessId;

    cbTaskArray = sizeof(SharedTask);

VDMEnumTaskRetry:

    if(GetNextVDMCommand(&VdmInfo)) {
       if(cbTaskArray < VdmInfo.EnviornmentSize  &&
          !fRetry)
       {
          lpst = MALLOC(VdmInfo.EnviornmentSize);
          if(!lpst) {
             return 0;
          }
          VdmInfo.Enviornment = lpst;
          cbTaskArray = VdmInfo.EnviornmentSize;
          fRetry = TRUE;
          goto VDMEnumTaskRetry;
       } 
        

       lpst = (LPSHAREDTASK) VdmInfo.Enviornment;

       cbTaskArray = cbTaskArray > VdmInfo.EnviornmentSize ? VdmInfo.EnviornmentSize : cbTaskArray;

       count = 0; 
    
       while(cbTaskArray) {
           cbTaskArray -= sizeof(SHAREDTASK); 
           count++;
           if ( fp && lpst->hMod16 ) {
               if (fEx) {
                   fRet = ((TASKENUMPROCEX)fp)( lpst->dwThreadId, lpst->hMod16, lpst->hTask16,
                                             lpst->szModName, lpst->szFilePath, lparam );
               } else {
                   fRet = ((TASKENUMPROC)fp)( lpst->dwThreadId, lpst->hMod16, lpst->hTask16, lparam );
               }
               if ( fRet ) {     
                   break;
               }
           }
           lpst++;
       }
    }

    if (fRetry) {
      FREE(VdmInfo.Enviornment);    
    }

    return( count );
}


INT
WINAPI
VDMEnumTaskWOW(
    DWORD           dwProcessId,
    TASKENUMPROC    fp,
    LPARAM          lparam
) {
    return VDMEnumTaskWOWWorker(dwProcessId, (void *)fp, lparam, 0);
}


INT
WINAPI
VDMEnumTaskWOWEx(
    DWORD           dwProcessId,
    TASKENUMPROCEX  fp,
    LPARAM          lparam
) {
    return VDMEnumTaskWOWWorker(dwProcessId, (void *)fp, lparam, 1);
}


BOOL
WINAPI
VDMTerminateTaskWOW(
    DWORD           dwProcessId,
    WORD            htask
)
{
    SHAREDPROCESS       SharedProcess;
    BOOL                fRet = FALSE;
    HANDLE              hProcess;
    HANDLE              hRemoteThread;
    DWORD               dwThreadId;
    VDMINFO             VdmInfo;

    RtlZeroMemory(&VdmInfo, sizeof(VDMINFO));
    VdmInfo.iTask = dwProcessId;
    VdmInfo.VDMState = ASKING_FOR_WOWPROCLIST;
    VdmInfo.Enviornment = (LPVOID)&SharedProcess;
    VdmInfo.EnviornmentSize = sizeof(SHAREDPROCESS);

    if(GetNextVDMCommand(&VdmInfo)) {                           
      
       //
       // Get a handle to the process and start W32HungAppNotifyThread
       // running with htask as the parameter.
       //
       
       hProcess = OpenProcess(
                      PROCESS_ALL_ACCESS,
                      FALSE,
                      SharedProcess.dwProcessId
                      );
       
       if (hProcess) {
       
           hRemoteThread = CreateRemoteThread(
                               hProcess,
                               NULL,
                               0,
                               SharedProcess.pfnW32HungAppNotifyThread,
                               (LPVOID) htask,
                               0,
                               &dwThreadId
                               );
       
           if (hRemoteThread) {
               fRet = TRUE;
               CloseHandle(hRemoteThread);
           }
       
           CloseHandle(hProcess);
       }
    }

    return fRet;
}


BOOL
VDMStartTaskInWOW(
    DWORD           pidTarget,
    LPSTR           lpCommandLine,
    WORD            wShow
)
{
    HWND  hwnd = NULL;
    DWORD pid;
    BOOL  fRet;

    do {

        hwnd = FindWindowEx(NULL, hwnd, TEXT("WowExecClass"), NULL);

        if (hwnd) {

            pid = 0;
            GetWindowThreadProcessId(hwnd, &pid);
        }

    } while (hwnd && pid != pidTarget);


    if (hwnd && pid == pidTarget) {

#define WM_WOWEXEC_START_TASK (WM_USER+2)
        PostMessage(hwnd, WM_WOWEXEC_START_TASK, GlobalAddAtom(lpCommandLine), wShow);
        fRet = TRUE;

    } else {

        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\data.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Data.c

Abstract:

    This module contains definitions for global data for the IEU and
    VDD debugging extensions

Author:

    Dave Hastings (daveh) 2-Apr-1992

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
//
// Pointers to NTSD api
//

PWINDBG_OUTPUT_ROUTINE Print;
PWINDBG_GET_EXPRESSION GetExpression;
PWINDBG_GET_SYMBOL GetSymbol;
PWINDBG_CHECK_CONTROL_C CheckCtrlC;

PWINDBG_READ_PROCESS_MEMORY_ROUTINE  ReadMem;
PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE WriteMem;

PWINDBG_GET_THREAD_CONTEXT_ROUTINE     ExtGetThreadContext;
PWINDBG_SET_THREAD_CONTEXT_ROUTINE     ExtSetThreadContext;
PWINDBG_IOCTL_ROUTINE                  ExtIoctl;
PWINDBG_STACKTRACE_ROUTINE             ExtStackTrace;


HANDLE hCurrentProcess;
HANDLE hCurrentThread;
LPSTR lpArgumentString;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\disasm.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    disasm.c

Abstract:

    This file contains the x86 disassmbler invoked by "!bde.u <16:16 address>"

Author:

    Barry Bond    (BarryBo)

Revision History:

    09-May-1995 Barry Bond  (BarryBo)   Created
    15-Jan-1996 Neil Sandlin (NeilSa)   Merged with vdmexts
                                        32 bit segments fixes

--*/

#include <precomp.h>
#pragma hdrstop

WORD  gSelector = 0;
ULONG gOffset = 0;
int gMode = 0;

VOID
u(
    CMD_ARGLIST
) {
    VDMCONTEXT      ThreadContext;
    WORD            selector;
    ULONG           offset;
    int             mode;
    char            rgchOutput[128];
    char            rgchExtra[128];
    BYTE            rgbInstruction[64];
    CHAR            sym_text[255];
    CHAR            sym_prev[255] = "";
    DWORD           dist;
    int             cb;
    int             i;
    int             j;
    int             count=10;
    ULONG           Base;
    SELECTORINFO    si;
    ULONG           BPNum;
    UCHAR           BPData;
    BOOL            bIsBP;

    CMD_INIT();

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        if (!gSelector && !gOffset) {
            selector = (WORD) ThreadContext.SegCs;
            offset   = ThreadContext.Eip;
        } else {
            mode = gMode;
            selector = gSelector;
            offset = gOffset;
        }
    } else if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    if (GetNextToken()) {
        count = (int) EXPRESSION(lpArgumentString);
        if (count > 1000) {
            PRINTF("Count too large - ignored\n");
            count=10;
        }
    }

    if ( mode != PROT_MODE && mode != V86_MODE) {
        PRINTF(" Disassembly of flat mode code not allowed.\n");
        return;
    }

    LoadBreakPointCache();
    Base = GetInfoFromSelector( selector, mode, &si ) + GetIntelBase();

    for (i=0; i<count; ++i) {

        if (FindSymbol(selector, offset, sym_text, &dist, BEFORE, mode )) {
            if (_stricmp(sym_text, sym_prev)) {
                if ( dist == 0 ) {
                    PRINTF("%s:\n", sym_text );
                } else {
                    PRINTF("%s+0x%lx:\n", sym_text, dist );
                }
                strcpy(sym_prev, sym_text);
            }
        }

        cb = sizeof(rgbInstruction);
        if ((DWORD)(offset+cb) >= si.Limit)
            cb -= offset+cb-si.Limit;
        if (!READMEM((LPVOID)(Base+offset), rgbInstruction, cb)) {
            PRINTF("%04x:%08x: <Error Reading Memory>\n", selector, offset);
            return;
        }

        if (bIsBP = IsVdmBreakPoint(selector,
                                    offset,
                                    mode==PROT_MODE,
                                    &BPNum,
                                    &BPData)) {
            rgbInstruction[0] = BPData;
        }

        cb = unassemble_one(rgbInstruction,
                si.bBig,
                selector, offset,
                rgchOutput,
                rgchExtra,
                &ThreadContext,
                mode);

        gOffset += cb;

        if (offset > 0xffff) {
            PRINTF("%04x:%08x ", selector, offset);
        } else {
            PRINTF("%04x:%04x ", selector, offset);
        }

        for (j=0; j<cb; ++j)
            PRINTF("%02x", rgbInstruction[j]);
        for (; j<8; ++j)
            PRINTF("  ");

        PRINTF("%s\t%s", rgchOutput, rgchExtra);

        if (bIsBP) {
            PRINTF("; BP%d",BPNum);
        }

        PRINTF("\n");
        offset+=cb;
    }
}


typedef struct _ADDR {
    ULONG     sOff;
    USHORT    sSeg;
} ADDR;


LPBYTE checkprefixes(LPBYTE);
void AppendPrefixes(void);
void DisplayAddress(int mod, int rm, int sOff, int size);
int DisplayBOP(void);

#define modrmB      1
#define modrmW      2
#define reg1B       3
#define reg1W       4
#define reg2B       5
#define reg2W       6
#define eeeControl  7
#define eeeDebug    8
#define eeeTest     9
#define regSeg      10
#define ALreg       11
#define AHreg       12
#define BLreg       13
#define BHreg       14
#define CLreg       15
#define CHreg       16
#define DLreg       17
#define DHreg       18
#define AXreg       19
#define BXreg       20
#define CXreg       21
#define DXreg       22
#define SIreg       23
#define DIreg       24
#define SPreg       25
#define BPreg       26
#define CSreg       27
#define SSreg       28
#define DSreg       29
#define ESreg       30
#define FSreg       31
#define GSreg       32
#define ImmB        33
#define ImmBEnter   34
#define ImmBS       35
#define ImmW        36
#define ImmW1       37
#define jmpB        38
#define jmpW        39
#define memB        40
#define memW        41
#define memD        42
#define indirmodrmW 43
#define indirFARmodrmW 44
#define memB1       45


int DmodrmB(LPBYTE);
int DmodrmW(LPBYTE);
int Dreg1B(LPBYTE);
int Dreg1W(LPBYTE);
int Dreg2B(LPBYTE);
int Dreg2W(LPBYTE);
int DeeeControl(LPBYTE);
int DeeeDebug(LPBYTE);
int DeeeTest(LPBYTE);
int DregSeg(LPBYTE);
int DALreg(LPBYTE);
int DAHreg(LPBYTE);
int DBLreg(LPBYTE);
int DBHreg(LPBYTE);
int DCLreg(LPBYTE);
int DCHreg(LPBYTE);
int DDLreg(LPBYTE);
int DDHreg(LPBYTE);
int DAXreg(LPBYTE);
int DBXreg(LPBYTE);
int DCXreg(LPBYTE);
int DDXreg(LPBYTE);
int DSIreg(LPBYTE);
int DDIreg(LPBYTE);
int DSPreg(LPBYTE);
int DBPreg(LPBYTE);
int DCSreg(LPBYTE);
int DSSreg(LPBYTE);
int DDSreg(LPBYTE);
int DESreg(LPBYTE);
int DFSreg(LPBYTE);
int DGSreg(LPBYTE);
int DImmB(LPBYTE);
int DImmBEnter(LPBYTE);
int DImmBS(LPBYTE);
int DImmW(LPBYTE);
int DImmW1(LPBYTE); // immediate-16 for 1-byte instructions
int DjmpB(LPBYTE);
int DjmpW(LPBYTE);
int DmemB(LPBYTE);
int DmemB1(LPBYTE);
int DmemW(LPBYTE);
int DmemD(LPBYTE);
int DindirmodrmW(LPBYTE);
int DindirFARmodrmW(LPBYTE);

struct {
    int (*pfn)(LPBYTE);
} rgpfn[] = {

 0,         // 0th entry is reserved
 DmodrmB,
 DmodrmW,
 Dreg1B,
 Dreg1W,
 Dreg2B,
 Dreg2W,
 DeeeControl,
 DeeeDebug,
 DeeeTest,
 DregSeg,
 DALreg,
 DAHreg,
 DBLreg,
 DBHreg,
 DCLreg,
 DCHreg,
 DDLreg,
 DDHreg,
 DAXreg,
 DBXreg,
 DCXreg,
 DDXreg,
 DSIreg,
 DDIreg,
 DSPreg,
 DBPreg,
 DCSreg,
 DSSreg,
 DDSreg,
 DESreg,
 DFSreg,
 DGSreg,
 DImmB,
 DImmBEnter,
 DImmBS,
 DImmW,
 DImmW1, // immediate-16 for 1-byte instructions
 DjmpB,
 DjmpW,
 DmemB,
 DmemW,
 DmemD,
 DindirmodrmW,
 DindirFARmodrmW,
 DmemB1
};

VDMCONTEXT  *g_pThreadContext;
int         g_mode;
char *g_pchOutput;  // the disassembled instruction
char *g_pchExtra;   // contents of memory (if any) modified by this instr.
int prefixes;

//NOTE: if first byte = 0x0f, then the instruction is two bytes long

char *szRegsB[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};
char *szRegsW[] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
char *szRegsD[] = {"eax","ecx","edx","ebx","esp","ebp","esi","edi"};
char *szRegsSeg[] = {"es", "cs", "ss", "ds", "fs", "gs", "(bad)", "(bad)"};
char *szMod[]   = {"[bx+si", "[bx+di", "[bp+si", "[bp+di", "[si", "[di", "[bp", "[bx"};

#define PREFIX_REPZ 1
#define PREFIX_REPNZ 2
#define PREFIX_LOCK 4
#define PREFIX_CS 8
#define PREFIX_SS 0x10
#define PREFIX_DS 0x20
#define PREFIX_ES 0x40
#define PREFIX_FS 0x80
#define PREFIX_GS 0x100
#define PREFIX_DATA 0x200
#define PREFIX_ADR 0x400
#define PREFIX_FWAIT 0x800

#define GROUP_1B    -1
#define GROUP_1WS   -2
#define GROUP_1W    -3
#define GROUP_2B    -4
#define GROUP_2W    -5
#define GROUP_2B_1  -6
#define GROUP_2W_1  -7
#define GROUP_2B_CL -8
#define GROUP_2W_CL -9
#define GROUP_3B    -10
#define GROUP_3W    -11
#define GROUP_4     -12
#define GROUP_5     -13
#define GROUP_6     -14
#define GROUP_7     -15
#define GROUP_8     -16

#define FLOATCODE   -51
#define FLOAT       FLOATCODE

// WARNING: This list must remain in sync with the szInstructions[] array
#define szAdc   1
#define szAdd   2
#define szAnd   3
#define szBad   4
#define szCmp   5
#define szDec   6
#define szIn    7
#define szInc   8
#define szJmp   9
#define szMov   10
#define szOr    11
#define szOut   12
#define szRcl   13
#define szRcr   14
#define szRol   15
#define szRor   16
#define szSar   17
#define szSbb   18
#define szShl   19
#define szShr   20
#define szSub   21
#define szTest  22
#define szPop   23
#define szPush  24
#define szXchg  25
#define szXor   26
#define szDaa   27
#define szDas   28
#define szPusha 29
#define szPopa  30
#define szBound 31
#define szArpl  32
#define szAaa   33
#define szAas   34
#define szImul  35
#define szIdiv  36
#define szJo    37
#define szJno   38
#define szJb    39
#define szJae   40
#define szJe    41
#define szJne   42
#define szJbe   43
#define szJa    44
#define szJs    45
#define szJns   46
#define szJp    47
#define szJnp   48
#define szJl    49
#define szJnl   50
#define szJle   51
#define szJg    52
#define szNop   53
#define szLea   54
#define szCbw   55
#define szCwd   56
#define szCall  57
#define szPushf 58
#define szPopf  59
#define szSahf  60
#define szLahf  61
#define szMovsb 62
#define szMovsw 63
#define szCmpsb 64
#define szCmpsw 65
#define szStosb 66
#define szStosw 67
#define szLodsb 68
#define szLodsw 69
#define szScasb 70
#define szScasw 71
#define szRetn  72
#define szLes   73
#define szLds   74
#define szEnter 75
#define szLeave 76
#define szRetf  77
#define szInt3  78
#define szInt   79
#define szInto  80
#define szIret  81
#define szAam   82
#define szAad   83
#define szXlat  84
#define szLoopne 85
#define szLoope 86
#define szLoop  87
#define szJcxz  88
#define szHalt  89
#define szCmc   90
#define szClc   91
#define szStc   92
#define szCli   93
#define szSti   94
#define szCld   95
#define szStd   96
#define szLar   97
#define szLsl   98
#define szClts  99
#define szSeto  100
#define szSetno 101
#define szSetb  102
#define szSetae 103
#define szSete  104
#define szSetne 105
#define szSetbe 106
#define szSeta  107
#define szSets  108
#define szSetns 109
#define szSetp  110
#define szSetnp 111
#define szSetl  112
#define szSetge 113
#define szSetle 114
#define szSetg  115
#define szBt    116
#define szShld  117
#define szBts   118
#define szShrd  119
#define szShdr  120
#define szLss   121
#define szBtr   122
#define szLfs   123
#define szLgs   124
#define szMovzx 125
#define szBtc   126
#define szBsf   127
#define szBsr   128
#define szMovsx 129
#define szNot   130
#define szNeg   131
#define szMul   132
#define szDiv   133
#define szSldt  134
#define szStr   135
#define szLldt  136
#define szLtr   137
#define szVerr  138
#define szVerw  139
#define szSgdt  140
#define szSidt  141
#define szLgdt  142
#define szLidt  143
#define szSmsw  144
#define szLmsw  145

// WARNING: This must stay in sync with the #define list above
char *szInstructions[] = {
    "",     //used to indicate groups
    "adc",
    "add",
    "and",
    "(bad)",
    "cmp",
    "dec",
    "in",
    "inc",
    "jmp",
    // 10
    "mov",
    "or",
    "out",
    "rcl",
    "rcr",
    "rol",
    "ror",
    "sar",
    "sbb",
    "shl",
    // 20
    "shr",
    "sub",
    "test",
    "pop",
    "push",
    "xchg",
    "xor",
    "daa",
    "das",
    "pusha",
    // 30
    "popa",
    "bound",
    "arpl",
    "aaa",
    "aas",
    "imul",
    "idiv",
    "jo",
    "jno",
    "jb",
    // 40
    "jae",
    "je",
    "jne",
    "jbe",
    "ja",
    "js",
    "jns",
    "jp",
    "jnp",
    "jl",
    // 50
    "jnl",
    "jle",
    "jg",
    "nop",
    "lea",
    "cbw",
    "cwd",
    "call",
    "pushf",
    "popf",
    // 60
    "sahf",
    "lahf",
    "movsb",
    "movsw",
    "cmpsb",
    "cmpsw",
    "stosb",
    "stosw",
    "lodsb",
    "lodsw",
    // 70
    "scasb",
    "scasw",
    "retn",
    "les",
    "lds",
    "enter",
    "leave",
    "retf",
    "int3",
    "int",
    // 80
    "into",
    "iret",
    "aam",
    "aad",
    "xlat",
    "loopne",
    "loope",
    "loop",
    "jcxz",
    "halt",
    // 90
    "cmc",
    "clc",
    "stc",
    "cli",
    "sti",
    "cld",
    "std",
    "lar",
    "lsl",
    "clts",
    // 100
    "seto",
    "setno",
    "setb",
    "setae",
    "sete",
    "setne",
    "setbe",
    "seta",
    "sets",
    "setns",
    // 110
    "setp",
    "setnp",
    "setl",
    "setge",
    "setle",
    "setg",
    "bt",
    "shld",
    "bts",
    "shrd",
    // 120
    "shdr",
    "lss",
    "btr",
    "lfs",
    "lgs",
    "movzx",
    "btc",
    "bsf",
    "bsr",
    "movsx",
    // 130
    "not",
    "neg",
    "mul",
    "div",
    "sldt",
    "str",
    "lldt",
    "ltr",
    "verr",
    "verw",
    // 140
    "sgdt",
    "sidt",
    "lgdt",
    "lidt",
    "smsw",
    "lmsw"
};

struct dis {
    int     szName;
    char    iPart1;
    char    iPart2;
    char    iPart3;
};

struct dis dis386[] = {
    // 0
    { szAdd, modrmB, reg1B },
    { szAdd, modrmW, reg1W },
    { szAdd, reg1B, modrmB },
    { szAdd, reg1W, modrmW },
    { szAdd, ALreg, ImmB },
    { szAdd, AXreg, ImmW },
    { szPush, ESreg },
    { szPop, ESreg},
    // 8
    { szOr, modrmB, reg1B },
    { szOr, modrmW, reg1W },
    { szOr, reg1B, modrmB },
    { szOr, reg1W, modrmW },
    { szOr, ALreg, ImmB },
    { szOr, AXreg, ImmW },
    { szPush, CSreg },
    { szBad },                  // 0x0f is the 2-byte instr prefix
    // 10
    { szAdc, modrmB, reg1B },
    { szAdc, modrmW, reg1W },
    { szAdc, reg1B, modrmB },
    { szAdc, reg1W, modrmW },
    { szAdc, ALreg, ImmB },
    { szAdc, AXreg, ImmW },
    { szPush, SSreg },
    { szPop, SSreg },
    // 18
    { szSbb, modrmB, reg1B },
    { szSbb, modrmW, reg1W },
    { szSbb, reg1B, modrmB },
    { szSbb, reg1W, modrmW },
    { szSbb, ALreg, ImmB },
    { szSbb, AXreg, ImmW },
    { szPush, DSreg },
    { szPop, DSreg },
    // 20
    { szAnd, modrmB, reg1B },
    { szAnd, modrmW, reg1W },
    { szAnd, reg1B, modrmB },
    { szAnd, reg1W, modrmW },
    { szAnd, ALreg, ImmB },
    { szAnd, AXreg, ImmW },
    { szBad },                  // ES override prefix
    { szDaa },
    // 28
    { szSub, modrmB, reg1B },
    { szSub, modrmW, reg1W },
    { szSub, reg1B, modrmB },
    { szSub, reg1W, modrmW },
    { szSub, ALreg, ImmB },
    { szSub, AXreg, ImmW },
    { szBad },                  // CS override prefix
    { szDas },
    // 30
    { szXor, modrmB, reg1B },
    { szXor, modrmW, reg1W },
    { szXor, reg1B, modrmB },
    { szXor, reg1W, modrmW },
    { szXor, ALreg, ImmB },
    { szXor, AXreg, ImmW },
    { szBad},                   // SS override prefix
    { szAaa },
    // 38
    { szCmp, modrmB, reg1B },
    { szCmp, modrmW, reg1W },
    { szCmp, reg1B, modrmB },
    { szCmp, reg1W, modrmW },
    { szCmp, ALreg, ImmB },
    { szCmp, AXreg, ImmW },
    { szBad },
    { szAas },
    // 40
    { szInc, AXreg },
    { szInc, CXreg },
    { szInc, DXreg },
    { szInc, BXreg },
    { szInc, SPreg },
    { szInc, BPreg },
    { szInc, SIreg },
    { szInc, DIreg },
    // 48
    { szDec, AXreg },
    { szDec, CXreg },
    { szDec, DXreg },
    { szDec, BXreg },
    { szDec, SPreg },
    { szDec, BPreg },
    { szDec, SIreg },
    { szDec, DIreg },
    // 50
    { szPush, AXreg },
    { szPush, CXreg },
    { szPush, DXreg },
    { szPush, BXreg },
    { szPush, SPreg },
    { szPush, BPreg },
    { szPush, SIreg },
    { szPush, DIreg },
    // 58
    { szPop, AXreg },
    { szPop, CXreg },
    { szPop, DXreg },
    { szPop, BXreg },
    { szPop, SPreg },
    { szPop, BPreg },
    { szPop, SIreg },
    { szPop, DIreg },
    // 60
    { szPusha },
    { szPopa },
    { szBound, reg1W, modrmW },
    { szArpl, reg1W, reg2W },
    { szBad },                  // FS segment override
    { szBad },                  // GS segment override
    { szBad },                  // op size prefix
    { szBad },                  // addr size prefix
    // 68
    { szPush, ImmW},
    { szImul, reg1W, modrmW },
    { szPush, ImmBS},
    { szImul, reg1B, modrmB },
    { szIn, ImmB, DXreg },
    { szIn, ImmW, DXreg },
    { szOut, ImmB, DXreg },
    { szOut, ImmW, DXreg },
    // 70
    { szJo, jmpB },
    { szJno, jmpB },
    { szJb, jmpB },
    { szJae, jmpB },
    { szJe, jmpB },
    { szJne, jmpB },
    { szJbe, jmpB },
    { szJa, jmpB },
    // 78
    { szJs, jmpB },
    { szJns, jmpB },
    { szJp, jmpB },
    { szJnp, jmpB },
    { szJl, jmpB },
    { szJnl, jmpB },
    { szJle, jmpB },
    { szJg, jmpB },
    // 80
    { GROUP_1B },
    { GROUP_1W },
    { szBad },
    { GROUP_1WS },
    { szTest, reg1B, modrmB },
    { szTest, reg1W, modrmW },
    { szXchg, reg1B, modrmB },
    { szXchg, reg1W, modrmW },
    // 88
    { szMov, modrmB, reg1B },
    { szMov, modrmW, reg1W },
    { szMov, reg1B, modrmB  },
    { szMov, reg1W, modrmW },
    { szMov, modrmW, regSeg },
    { szLea, reg1W, modrmW },
    { szMov, regSeg, modrmW },
    { szPop, modrmW },
    // 90
    { szNop },
    { szXchg, AXreg, CXreg },
    { szXchg, AXreg, DXreg },
    { szXchg, AXreg, BXreg },
    { szXchg, AXreg, SPreg },
    { szXchg, AXreg, BPreg },
    { szXchg, AXreg, SIreg },
    { szXchg, AXreg, DIreg },
    // 98
    { szCbw },
    { szCwd },
    { szCall, memD },
    { szBad },
    { szPushf },
    { szPopf },
    { szSahf },
    { szLahf },
    // a0
    { szMov, ALreg, memB },
    { szMov, AXreg, memW },
    { szMov, memB, ALreg },
    { szMov, memW, AXreg },
    { szMovsb },
    { szMovsw },
    { szCmpsb },
    { szCmpsw },
    // a8
    { szTest, ALreg, ImmB },
    { szTest, AXreg, ImmW },
    { szStosb },
    { szStosw },
    { szLodsb },
    { szLodsw },
    { szScasb },
    { szScasw },
    // b0
    { szMov, ALreg, ImmB },
    { szMov, CLreg, ImmB },
    { szMov, DLreg, ImmB },
    { szMov, BLreg, ImmB },
    { szMov, AHreg, ImmB },
    { szMov, CHreg, ImmB },
    { szMov, DHreg, ImmB },
    { szMov, BHreg, ImmB },
    // b8
    { szMov, AXreg, ImmW },
    { szMov, CXreg, ImmW },
    { szMov, DXreg, ImmW },
    { szMov, BXreg, ImmW },
    { szMov, SPreg, ImmW },
    { szMov, BPreg, ImmW },
    { szMov, SIreg, ImmW },
    { szMov, DIreg, ImmW },
    // c0
    { GROUP_2B },
    { GROUP_2W },
    { szRetn, ImmW },
    { szRetn },
    { szLes, reg1W, modrmW },
    { szLds, reg1W, modrmW },
    { szMov, modrmB, ImmB },
    { szMov, modrmW, ImmW },
    // c8
    { szEnter, ImmW, ImmBEnter },
    { szLeave },
    { szRetf, ImmW1 },
    { szRetf },
    { szInt3 },
    { szInt, ImmB },
    { szInto },
    { szIret },
    // d0
    { GROUP_2B_1 },
    { GROUP_2W_1 },
    { GROUP_2B_CL },
    { GROUP_2W_CL },
    { szAam, ImmB },
    { szAad, ImmB },
    { szBad },
    { szXlat },
    // d8
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    { FLOAT },
    // e0
    { szLoopne, jmpB },
    { szLoope, jmpB },
    { szLoop, jmpB },
    { szJcxz, jmpB },
    { szIn, ALreg, memB1 },
    { szIn, AXreg, memB1 },
    { szOut, memB1, ALreg },
    { szOut, memB1, AXreg },
    // e8
    { szCall, jmpW },
    { szJmp, jmpW },
    { szJmp, memD },
    { szJmp, jmpB },
    { szIn, ALreg, DXreg },
    { szIn, AXreg, DXreg },
    { szOut, DXreg, ALreg },
    { szOut, DXreg, AXreg },
    // f0
    { szBad },      // lock prefix
    { szBad },
    { szBad },      // repne prefix
    { szBad },      // repz prefix
    { szHalt },
    { szCmc },
    { GROUP_3B },
    { GROUP_3W },
    // f8
    { szClc },
    { szStc },
    { szCli },
    { szSti },
    { szCld },
    { szStd },
    { GROUP_4 },
    { GROUP_5 },
};


struct dis dis386_2[] = {
    // 00
    { GROUP_6 },
    { GROUP_7 },
    { szLar, reg1W, modrmW },
    { szLsl, reg1W, modrmW },
    { szBad },
    { szBad },
    { szClts },
    { szBad },
    // 08
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 10
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 18
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 20
    { szMov, reg2W, eeeControl },
    { szMov, reg2W, eeeDebug },
    { szMov, eeeControl, reg2W },
    { szMov, eeeDebug, reg2W },
    { szMov, reg2W, eeeTest },
    { szBad },
    { szMov, eeeTest, reg2W },
    { szBad },
    // 28
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 30
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 38
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 40
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 48
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 50
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 58
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 60
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 68
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 70
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 78
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // 80
    { szJo, jmpW },
    { szJno, jmpW },
    { szJb, jmpW },
    { szJae, jmpW },
    { szJe, jmpW },
    { szJne, jmpW },
    { szJbe, jmpW },
    { szJa, jmpW },
    // 88
    { szJs, jmpW },
    { szJns, jmpW },
    { szJp, jmpW },
    { szJnp, jmpW },
    { szJl, jmpW },
    { szJnl, jmpW },
    { szJle, jmpW },
    { szJg, jmpW },
    // 90
    { szSeto, modrmB },
    { szSetno, modrmB },
    { szSetb, modrmB },
    { szSetae, modrmB },
    { szSete, modrmB },
    { szSetne, modrmB },
    { szSetbe, modrmB },
    { szSeta, modrmB },
    // 98
    { szSets, modrmB },
    { szSetns, modrmB },
    { szSetp, modrmB },
    { szSetnp, modrmB },
    { szSetl, modrmB },
    { szSetge, modrmB },
    { szSetle, modrmB },
    { szSetg, modrmB },
    // a0
    { szPush, FSreg },
    { szPop, FSreg },
    { szBad },
    { szBt, modrmW, reg1W },
    { szShld, reg1W, modrmW, ImmB },
    { szShld, reg1W, modrmW, CLreg },
    { szBad },
    { szBad },
    // a8
    { szPush, GSreg },
    { szPop, GSreg },
    { szBad },
    { szBts, modrmW, reg1W },
    { szShrd, reg1W, modrmW, ImmB },
    { szShdr, reg1W, modrmW, CLreg },
    { szBad },
    { szImul, reg1W, modrmW },
    // b0
    { szBad },
    { szBad },
    { szLss, reg1W, modrmW },
    { szBtr, modrmW, reg1W },
    { szLfs, reg1W, modrmW },
    { szLgs, reg1W, modrmW },
    { szMovzx, reg1B, modrmB },
    { szMovzx, reg1W, modrmW },
    // b8
    { szBad },
    { szBad },
    { GROUP_8 },
    { szBtc, modrmW, reg1W },
    { szBsf, reg1W, modrmW },
    { szBsr, reg1W, modrmW },
    { szMovsx, reg1B, modrmB },
    { szMovsx, reg1W, modrmW },
    // c0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // c8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // d0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // d8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // e0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // e8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // f0
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    // f8
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
    { szBad },
};

struct dis dis386_groups[][8] = {
    // GROUP_1B
    {
        { szAdd, modrmB, ImmB },
        { szOr,  modrmB, ImmB },
        { szAdc, modrmB, ImmB },
        { szSbb, modrmB, ImmB },
        { szAnd, modrmB, ImmB },
        { szSub, modrmB, ImmB },
        { szXor, modrmB, ImmB },
        { szCmp, modrmB, ImmB }
    },
    // GROUP_1WS
    {
        { szAdd, modrmW, ImmBS },
        { szOr,  modrmW, ImmBS },
        { szAdc, modrmW, ImmBS },
        { szSbb, modrmW, ImmBS },
        { szAnd, modrmW, ImmBS },
        { szSub, modrmW, ImmBS },
        { szXor, modrmW, ImmBS },
        { szCmp, modrmW, ImmBS }
    },
    // GROUP_1W
    {
        { szAdd, modrmW, ImmW },
        { szOr,  modrmW, ImmW },
        { szAdc, modrmW, ImmW },
        { szSbb, modrmW, ImmW },
        { szAnd, modrmW, ImmW },
        { szSub, modrmW, ImmW },
        { szXor, modrmW, ImmW },
        { szCmp, modrmW, ImmW }
    },
    // GROUP_2B
    {
        { szRol, modrmB, ImmB },
        { szRor, modrmB, ImmB },
        { szRcl, modrmB, ImmB },
        { szRcr, modrmB, ImmB },
        { szShl, modrmB, ImmB },
        { szShr, modrmB, ImmB },
        { szBad },
        { szSar, modrmB, ImmB }
    },
    // GROUP_2W
    {
        { szRol, modrmW, ImmB },
        { szRor, modrmW, ImmB },
        { szRcl, modrmW, ImmB },
        { szRcr, modrmW, ImmB },
        { szShl, modrmW, ImmB },
        { szShr, modrmW, ImmB },
        { szBad },
        { szSar, modrmW, ImmB }
    },
    // GROUP_2B_1
    {
        { szRol, modrmB },
        { szRor, modrmB },
        { szRcl, modrmB },
        { szRcr, modrmB },
        { szShl, modrmB },
        { szShr, modrmB },
        { szBad },
        { szSar, modrmB }
    },
    // GROUP_2W_1
    {
        { szRol, modrmW },
        { szRor, modrmW },
        { szRcl, modrmW },
        { szRcr, modrmW },
        { szShl, modrmW },
        { szShr, modrmW },
        { szBad },
        { szSar, modrmW }
    },
    // GROUP_2B_CL
    {
        { szRol, modrmB, CLreg },
        { szRor, modrmB, CLreg },
        { szRcl, modrmB, CLreg },
        { szRcr, modrmB, CLreg },
        { szShl, modrmB, CLreg },
        { szShr, modrmB, CLreg },
        { szBad },
        { szSar, modrmB, CLreg }
    },
    // GROUP_2W_CL
    {
        { szRol, modrmW, CLreg },
        { szRor, modrmW, CLreg },
        { szRcl, modrmW, CLreg },
        { szRcr, modrmW, CLreg },
        { szShl, modrmW, CLreg },
        { szShr, modrmW, CLreg },
        { szBad },
        { szSar, modrmW, CLreg }
    },
    // GROUP_3B
    {
        { szTest, modrmB, ImmB },
        { szBad },
        { szNot, modrmB },
        { szNeg, modrmB },
        { szMul, ALreg, modrmB },
        { szImul, ALreg, modrmB },
        { szDiv, ALreg, modrmB },
        { szIdiv, ALreg, modrmB }
    },
    // GROUP_3W
    {
        { szTest, modrmW, ImmW },
        { szBad },
        { szNot, modrmW },
        { szNeg, modrmW },
        { szMul, AXreg, modrmW },
        { szImul, AXreg, modrmW },
        { szDiv, AXreg, modrmW },
        { szIdiv, AXreg, modrmW }
    },
    // GROUP_4
    {
        { szInc, modrmB },
        { szDec, modrmB },
        { szBad },
        { szBad },
        { szBad },
        { szBad },
        { szBad },
        { szBad }
    },
    // GROUP_5
    {
        { szInc, modrmW },
        { szDec, modrmW },
        { szCall, indirmodrmW },
        { szCall, indirFARmodrmW },
        { szJmp, indirmodrmW },
        { szJmp, indirFARmodrmW },
        { szPush, modrmW },
        { szBad }
    },
    // GROUP_6
    {
        { szSldt, modrmW },
        { szStr, modrmW },
        { szLldt, modrmW },
        { szLtr, modrmW },
        { szVerr, modrmW },
        { szVerw, modrmW },
        { szBad },
        { szBad }
    },
    // GROUP_7
    {
        { szSgdt, modrmW },
        { szSidt, modrmW },
        { szLgdt, modrmW },
        { szLidt, modrmW },
        { szSmsw, modrmW },
        { szBad },
        { szLmsw, modrmW },
        { szBad }
    },
    // GROUP_8
    {
        { szBad },
        { szBad },
        { szBad },
        { szBad },
        { szBt, modrmW, ImmB },
        { szBts, modrmW, ImmB },
        { szBtr, modrmW, ImmB },
        { szBtc, modrmW, ImmB }
    }
};

UCHAR OpcodeSize;
BYTE *pData;
ADDR g_InstrAddr;
BOOL bBig;

void AppendString(char *str)
{
    strcpy(g_pchOutput, (str));
    g_pchOutput+=strlen(g_pchOutput);
}

void ExtraString(char *str)
{
    strcpy(g_pchExtra, (str));
    g_pchExtra+=strlen(g_pchExtra);
}

#define AppendChar(c)      {*g_pchOutput++ = (c);}
#define AppendNumber(d) {_ultoa((ULONG)d,g_pchOutput, 16); g_pchOutput+=strlen(g_pchOutput);}

#define ExtraChar(c)       {*g_pchExtra++ = (c);}
#define ExtraNumber(d)     {_ultoa((ULONG)d,g_pchExtra, 16); g_pchExtra+=strlen(g_pchExtra);}
#define OPERAND_32 ((prefixes & PREFIX_DATA) ^ bBig)
#define ADDR_32 ((prefixes & PREFIX_ADR) ^ bBig)

int unassemble_one(
    BYTE        *pInstrStart,   // instruction to decode (can be local buffer)
    BOOL            bDefaultBig,
    WORD            wInstrSeg,      // selector of instruction
    DWORD       dwInstrOff,     // offset of instruction
    char        *pchOutput,     // [out] disassembled instruction
    char        *pchExtra,      // [out] extra info (ie. "es:[53]=1234")
                                //       (can be NULL)
    VDMCONTEXT  *pThreadContext,
    int         mode
) {
    int         i;
    int         cb;
    BYTE        *pInstr = pInstrStart;
    struct dis      *pszDecode;

    g_pThreadContext = pThreadContext;
    g_mode = mode;

    g_pchOutput = pchOutput;
    g_InstrAddr.sSeg = wInstrSeg;
    g_InstrAddr.sOff = dwInstrOff;
    bBig = bDefaultBig;

    gMode = mode;
    gSelector = wInstrSeg;
    gOffset = dwInstrOff;

    if (pchExtra)
        *pchExtra = '\0';

    g_pchExtra = pchExtra;

    if (*(UNALIGNED USHORT*)pInstr == 0xc4c4) {
        pData = pInstr;
        pData+=2;
        return DisplayBOP();
    }

    pInstr = checkprefixes(pInstr);

    OpcodeSize = 1;

    if (*pInstr == 0x0f) {
        OpcodeSize++;
        pInstr++;
        pszDecode = &dis386_2[*pInstr];
    } else {
        pszDecode = &dis386[*pInstr];
    }

    if (prefixes & PREFIX_REPZ)
        AppendString("repz ");
    if (prefixes & PREFIX_REPNZ)
        AppendString("repnz ");
    if (prefixes & PREFIX_LOCK)
        AppendString("lock ");
    if ((prefixes & PREFIX_FWAIT) && ((*pInstr < 0xd8) || (*pInstr > 0xdf))) {
        /* fwait not followed by floating point instruction */
        AppendString("fwait");
        return (1);
    }

    pInstr++;
    pData = pInstr;
    if (pszDecode->szName < 0) {    // found a GROUP_ or FLOAT entry...
        i = (-pszDecode->szName)-1;
        if (pszDecode->szName == FLOATCODE) {
            AppendString("*float* ");
            //Later: mputs("Floating point instructions NYI\n");
            return 1;
        } else {
            pszDecode = &dis386_groups[i][(*pInstr>>3)&7];
        }
    }

    AppendString(szInstructions[pszDecode->szName]);

    if (pszDecode->iPart1) {

        AppendChar('\t');

        i = (*(rgpfn[pszDecode->iPart1].pfn))(pInstr);

        if (pszDecode->iPart2) {

            AppendString(", ");
            i+=(*(rgpfn[pszDecode->iPart2].pfn))(pInstr);

            if (pszDecode->iPart3) {

                AppendString(", ");
                i+=(*(rgpfn[pszDecode->iPart3].pfn))(pInstr);

            }
        }

        pInstr+=i;
    }

    AppendChar('\0');
    cb = pInstr - pInstrStart;    // return length of instruction

    return cb;
}

BOOL safe_read_byte(
    ADDR        addr,
    BYTE        *pb
) {
    ULONG       Base;

    *pb = 0xbb;
    Base = GetInfoFromSelector( addr.sSeg, g_mode, NULL );
    if (Base == (ULONG)-1 || Base == 0) {
    return FALSE;
    }

    Base += GetIntelBase();

    return READMEM((LPVOID)(Base+(ULONG)addr.sOff), pb, 1);
}

BOOL safe_read_short(
    ADDR        addr,
    SHORT       *ps
) {
    ULONG       Base;

    Base = GetInfoFromSelector( addr.sSeg, g_mode, NULL );
    if (Base == (ULONG)-1 || Base == 0) {
    return FALSE;
    }

    Base += GetIntelBase();

    return READMEM((LPVOID)(Base+(ULONG)addr.sOff), ps, 2);
}

BOOL safe_read_long(
    ADDR        addr,
    LONG        *pl
) {
    ULONG       Base;

    Base = GetInfoFromSelector( addr.sSeg, g_mode, NULL );
    if (Base == (ULONG)-1 || Base == 0) {
    return FALSE;
    }

    Base += GetIntelBase();

    return READMEM((LPVOID)(Base+(ULONG)addr.sOff), pl, 4);
}


int Dreg1B(LPBYTE lpB)
{
    BYTE b = (*lpB >> 3) & 7;

    AppendString(szRegsB[b]);

    return 0;
}

int Dreg1W(LPBYTE lpB)
{
    BYTE b = (*lpB >> 3) & 7;

    if (OPERAND_32)
        AppendString(szRegsD[b]);
    else
        AppendString(szRegsW[b]);

    return 0;
}

int Dreg2B(LPBYTE lpB)
{
    BYTE b = *lpB & 7;

    AppendString(szRegsB[b]);

    return 0;
}

int Dreg2W(LPBYTE lpB)
{
    BYTE b = *lpB & 7;

    if (OPERAND_32)
        AppendString(szRegsD[b]);
    else
        AppendString(szRegsW[b]);

    return 0;
}

int DmodrmB(LPBYTE lpB)
{
    BYTE rm = *lpB & 0x07;
    BYTE mod = *lpB >> 6;
    unsigned short num;
    int iRet;

    pData++;                                // skip past mod r/m
    if (mod == 3) {
        AppendPrefixes();
        AppendString(szRegsB[rm]);
        return 1;
    }

    iRet = 0;
    AppendString("byte ptr ");
    AppendPrefixes();
    AppendString(szMod[rm]);
    AppendChar('+');

    switch (mod) {
        case 0:
            if (rm == 6) {
                g_pchOutput-=3; // back up over the 'BP+'
                num = *((UNALIGNED USHORT*)pData);
                AppendNumber(num);
                pData+=2;
                iRet = 3;
            } else {
                num = 0;
                g_pchOutput--;
                iRet = 1;
            }
            break;

        case 1:
            num = *pData;
            AppendNumber(num);
            pData++;
            iRet = 2;
            break;

        case 2:
            num = *((UNALIGNED USHORT*)pData);
            AppendNumber(num);
            pData += 2;
            iRet = 3;
            break;
    }

    AppendChar(']');

    DisplayAddress(mod, rm, num, 1);

    return iRet;
}

int DmodrmW(LPBYTE lpB)
{
    BYTE rm = *lpB & 0x07;
    BYTE mod = *lpB >> 6;
    ULONG num;
    int iRet;

    pData++;                                // skip past mod r/m
    AppendPrefixes();

    if (mod == 3) {
        if (OPERAND_32)
            AppendString(szRegsD[rm]);
        else
            AppendString(szRegsW[rm]);
        return 1;
    }

    if (ADDR_32) {
        AppendChar('[');
        AppendString(szRegsD[rm]);
    } else {
        AppendString(szMod[rm]);
    }
    AppendChar('+');

    switch (mod) {
        case 0:
            //
            // Handle special cases of ModRM
            //
            if ((rm == 6) && !ADDR_32) {
                g_pchOutput-=3; // back up over 'BP+'
                num = *((UNALIGNED USHORT*)pData);
                AppendNumber(num);
                pData+=2;
                iRet = 3;
            } else if ((rm == 5) && ADDR_32) {
                g_pchOutput-=4; // back up over 'EBP+'
                num = *((UNALIGNED ULONG*)pData);
                AppendNumber(num);
                pData+=4;
                iRet = 5;
            } else {
                g_pchOutput--;  // else back up over '+' alone
                num=0;
                iRet = 1;
            }
            break;

        case 1:
            num = *pData;
            AppendNumber(num);
            pData++;
            iRet = 2;
            break;

        case 2:
            num = *((UNALIGNED USHORT *)pData);
            AppendNumber(num);
            pData+=2;
            iRet = 3;
            break;
    }

    AppendChar(']');

    DisplayAddress(mod, rm, num, ADDR_32 ? 4 : 2);

    return iRet;
}


void DisplayAddress(int mod, int rm, int sOff, int size)
{
    ADDR addr;

    // if caller of unassemble_one() didn't want extra info, return now
    if (g_pchExtra == NULL)
    return;

    // no memory reference
    if (mod == 3)
    return;

    // display prefix

    if (prefixes & PREFIX_DS) {
    ExtraChar('D');
    addr.sSeg = (USHORT)g_pThreadContext->SegDs;
    } else if (prefixes & PREFIX_ES) {
    ExtraChar('E');
    addr.sSeg = (USHORT)g_pThreadContext->SegEs;
    } else if (prefixes & PREFIX_FS) {
    ExtraChar('F');
    addr.sSeg = (USHORT)g_pThreadContext->SegFs;
    } else if (prefixes & PREFIX_GS) {
    ExtraChar('G');
    addr.sSeg = (USHORT)g_pThreadContext->SegGs;
    } else if (prefixes & PREFIX_CS) {
    ExtraChar('C');
    addr.sSeg = (USHORT)g_pThreadContext->SegCs;
    } else if ( (prefixes & PREFIX_SS) || rm==2 || rm == 3) {
    ExtraChar('S');
    addr.sSeg = (USHORT)g_pThreadContext->SegSs;
    } else if (rm == 6 && mod != 0) {
    ExtraChar('S');
    addr.sSeg = (USHORT)g_pThreadContext->SegSs;
    } else {
    ExtraChar('D');
    addr.sSeg = (USHORT)g_pThreadContext->SegDs;
    }

    ExtraString("S:[");

    switch (rm) {
    case 0:
        addr.sOff = (USHORT)(g_pThreadContext->Ebx + g_pThreadContext->Esi);
        break;

    case 1:
        addr.sOff = (USHORT)(g_pThreadContext->Ebx + g_pThreadContext->Edi);
        break;

    case 2:
        addr.sOff = (USHORT)(g_pThreadContext->Ebp + g_pThreadContext->Esi);
        break;

    case 3:
        addr.sOff = (USHORT)(g_pThreadContext->Ebp + g_pThreadContext->Edi);
        break;

    case 4:
        addr.sOff = (USHORT)g_pThreadContext->Esi;
        break;

    case 5:
        addr.sOff = (USHORT)g_pThreadContext->Edi;
        break;

    case 6:
        if (mod == 0)
        addr.sOff = 0;
        else
        addr.sOff = (USHORT)g_pThreadContext->Ebp;
        break;

    default:
        addr.sOff = (USHORT)g_pThreadContext->Ebx;

    }

    addr.sOff += sOff;
    ExtraNumber(addr.sOff);
    ExtraString("]=");
    if (size == 2) {
    SHORT s;
    if (safe_read_short(addr, &s)) {
        ExtraNumber( s );
    } else {
        ExtraString("????");
    }
    } else if (size == 1) {
    BYTE b;
    if (safe_read_byte(addr, &b)) {
        ExtraNumber( b );
    } else {
        ExtraString("??");
    }
    } else if (size == 4) {
    LONG l;
    if (safe_read_long(addr, &l)) {
        ExtraNumber( l );
    } else {
        ExtraString("????????");
    }
    } else {
    ExtraString("Unknown size!");
    }
}

int DisplayBOP(void)
{
    UCHAR mjcode;
    int InstSize = 3;

    AppendString("BOP   ");

    mjcode = *((UCHAR *)pData);
    pData++;
    AppendNumber(mjcode);

    switch (mjcode) {
    case 0x50:
    case 0x52:
    case 0x53:
    case 0x54:
    case 0x58:
        //
        // This BOP has a minor function code
        //
        InstSize++;
        AppendString(", ");
        AppendNumber(*((UCHAR *)pData));
    }
    return InstSize;
}

int DALreg(LPBYTE lpB)
{
    AppendString("al");

    return 0;
}

int DAHreg(LPBYTE lpB)
{
    AppendString("ah");

    return 0;
}

int DBLreg(LPBYTE lpB)
{
    AppendString("bl");

    return 0;
}

int DBHreg(LPBYTE lpB)
{
    AppendString("bh");

    return 0;
}

int DCLreg(LPBYTE lpB)
{
    AppendString("cl");

    return 0;
}

int DCHreg(LPBYTE lpB)
{
    AppendString("ch");

    return 0;
}

int DDLreg(LPBYTE lpB)
{
    AppendString("dl");

    return 0;
}

int DDHreg(LPBYTE lpB)
{
    AppendString("dh");

    return 0;
}

int DAXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("ax");

    return 0;
}

int DBXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("bx");

    return 0;
}

int DCXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("cx");

    return 0;
}

int DDXreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("dx");

    return 0;
}

int DBPreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("bp");

    return 0;
}

int DSPreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("sp");

    return 0;
}

int DSIreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("si");

    return 0;
}

int DDIreg(LPBYTE lpB)
{
    if (OPERAND_32)
        AppendChar('e');

    AppendString("di");

    return 0;
}

int DCSreg(LPBYTE lpB)
{
    AppendString("cs");

    return 0;
}

int DDSreg(LPBYTE lpB)
{
    AppendString("ds");

    return 0;
}

int DSSreg(LPBYTE lpB)
{
    AppendString("es");

    return 0;
}

int DESreg(LPBYTE lpB)
{
    AppendString("es");

    return 0;
}

int DFSreg(LPBYTE lpB)
{
    AppendString("fs");

    return 0;
}

int DGSreg(LPBYTE lpB)
{
    AppendString("gs");

    return 0;
}

int DImmB(LPBYTE lpB)
{
    AppendNumber(*((UCHAR *)pData));
    pData++;

    return 1;
}

int DImmBEnter(LPBYTE lpB)
{
    AppendNumber(*((UCHAR *)pData));
    pData++;

    return 1;
}

int DImmBS(LPBYTE lpB)  // sign-extend 8-bit value to 16 bits
{
    int i = (signed char)*(pData);

    AppendNumber((USHORT)i);
    pData++;

    return 1;
}

int DImmW(LPBYTE lpB)
{
    if (OPERAND_32) {

            AppendNumber( *((UNALIGNED ULONG*)pData) );
            pData+=4;
            return 4;

        } else {

            AppendNumber( *((UNALIGNED USHORT*)pData) );
            pData+=2;
            return 2;

        }
}

int DImmW1(LPBYTE lpB)
{
    AppendNumber( *((UNALIGNED SHORT*)(pData)) );
    pData++;

    return 2;
}

int DjmpB(LPBYTE lpB)
{
    ULONG Dest = g_InstrAddr.sOff + (LONG)*((UNALIGNED CHAR *)lpB) + OpcodeSize + 1;

    if (OPERAND_32) {
        AppendNumber(Dest);
    } else {
        AppendNumber((USHORT)Dest);
    }

    return 1;
}

int DjmpW(LPBYTE lpB)
{

    if (OPERAND_32) {
        AppendNumber(g_InstrAddr.sOff + *((UNALIGNED ULONG *)lpB) + OpcodeSize + 4);
        return 4;
    } else {
        AppendNumber(LOWORD(g_InstrAddr.sOff + (ULONG)*((UNALIGNED USHORT *)lpB) + OpcodeSize + 2));
        return 2;
    }
}

int DregSeg(LPBYTE lpB)
{
    BYTE b = (*lpB >> 3) & 7;

    AppendString(szRegsSeg[b]);

    return 0;
}


int DmemB(LPBYTE lpB)
{
    ADDR addr;

    addr.sOff = *(lpB+1);

    AppendChar('[');
    AppendNumber( addr.sOff );
    AppendChar(']');

    if (g_pchExtra) {
        BYTE b;

        if (prefixes & PREFIX_DS) {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        } else if (prefixes & PREFIX_ES) {
            ExtraChar('E');
            addr.sSeg = (USHORT)g_pThreadContext->SegEs;
        } else if (prefixes & PREFIX_FS) {
            ExtraChar('F');
            addr.sSeg = (USHORT)g_pThreadContext->SegFs;
        } else if (prefixes & PREFIX_GS) {
            ExtraChar('G');
            addr.sSeg = (USHORT)g_pThreadContext->SegGs;
        } else if (prefixes & PREFIX_CS) {
            ExtraChar('C');
            addr.sSeg = (USHORT)g_pThreadContext->SegCs;
        } else if (prefixes & PREFIX_SS) {
            ExtraChar('S');
            addr.sSeg = (USHORT)g_pThreadContext->SegSs;
        } else {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        }

        ExtraString("S:[");
        ExtraNumber( addr.sOff );
        ExtraString("]=");
        if (safe_read_byte(addr, &b)) {
            ExtraNumber( b );
        } else {
            ExtraString("??");
        }

    }

    return 1;
}

int DmemB1(LPBYTE lpB)
{
    AppendNumber( *lpB );

    return 1;
}

int DmemW(LPBYTE lpB)
{
    int i;
    ADDR addr;

    addr.sOff = *(lpB+1);

    AppendChar('[');
    if (ADDR_32) {
        AppendNumber( *((UNALIGNED long*)lpB) );
        i=4;
    } else {
        addr.sOff = *((UNALIGNED short *)lpB);
        AppendNumber( addr.sOff );
        i=2;
    }
    AppendChar(']');

    if (g_pchExtra) {

        if (prefixes & PREFIX_DS) {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        } else if (prefixes & PREFIX_ES) {
            ExtraChar('E');
            addr.sSeg = (USHORT)g_pThreadContext->SegEs;
        } else if (prefixes & PREFIX_FS) {
            ExtraChar('F');
            addr.sSeg = (USHORT)g_pThreadContext->SegFs;
        } else if (prefixes & PREFIX_GS) {
            ExtraChar('G');
            addr.sSeg = (USHORT)g_pThreadContext->SegGs;
        } else if (prefixes & PREFIX_CS) {
            ExtraChar('C');
            addr.sSeg = (USHORT)g_pThreadContext->SegCs;
        } else if (prefixes & PREFIX_SS) {
            ExtraChar('S');
            addr.sSeg = (USHORT)g_pThreadContext->SegSs;
        } else {
            ExtraChar('D');
            addr.sSeg = (USHORT)g_pThreadContext->SegDs;
        }

        ExtraString("S:[");
        ExtraNumber( addr.sOff );
        ExtraString("]=");
        if (i == 2) {
            SHORT s;
            if (safe_read_short(addr, &s)) {
                ExtraNumber( s );
            } else {
                ExtraString( "????" );
            }
        } else {
            LONG l;

            if (safe_read_long(addr, &l)) {
                ExtraNumber( l );
            } else {
                ExtraString( "????????" );
            }
        }
    }

    return i;
}


int DmemD(LPBYTE lpB)
{
    int i;

    if (OPERAND_32) {
        AppendNumber( *(((UNALIGNED SHORT*)lpB)+2) );
        AppendChar(':');
        AppendNumber( *((UNALIGNED long*)lpB) );
        i=6;
    } else {
        USHORT sel, off;

        sel = *(((UNALIGNED SHORT*)lpB)+1);
        off = *((UNALIGNED SHORT*)lpB);
        AppendNumber( sel );
        AppendChar(':');
        AppendNumber( off );
        i=4;

        if (g_pchExtra) {
            char sym_text[1000];
            LONG dist;

            // if the exact symbol name was found, print it
            if (FindSymbol(   sel,
                   off,
                   sym_text,
                   &dist,
                   BEFORE,
                   g_mode)) {
                ExtraString("= ");
                ExtraString(sym_text);
                if (dist) {
                    ExtraString(" + ");
                    ExtraNumber( dist );
                }
            }
        }

    }

    return i;
}

int DindirmodrmW(LPBYTE lpB)
{
    int i;

    AppendString("FAR PTR ");
    i = DmodrmW(lpB);
    AppendChar(']');

    return i;
}


int DindirFARmodrmW(LPBYTE lpB)
{
    int i;

    AppendString("FAR PTR ");
    i = DmodrmW(lpB);
    AppendChar(']');

    return i;
}


int DeeeControl(LPBYTE lpB)
{
    AppendChar('c');
    AppendChar('r');
    AppendChar('0'+ ((*lpB >> 3) & 7) );

    return 1;
}

int DeeeDebug(LPBYTE lpB)
{
    AppendChar('d');
    AppendChar('r');
    AppendChar('0'+ ((*lpB >> 3) & 7) );

    return 1;
}

int DeeeTest(LPBYTE lpB)
{
    AppendChar('t');
    AppendChar('r');
    AppendChar('0'+ ((*lpB >> 3) & 7) );

    return 1;
}


LPBYTE checkprefixes(LPBYTE lpB)
{
    prefixes = 0;

    for (;;) {

        switch (*lpB) {
            case 0xf3:
                prefixes |= PREFIX_REPZ;
                break;
            case 0xf2:
                prefixes |= PREFIX_REPNZ;
                break;
            case 0xf0:
                prefixes |= PREFIX_LOCK;
                break;
            case 0x2e:
                prefixes |= PREFIX_CS;
                break;
            case 0x36:
                prefixes |= PREFIX_SS;
                break;
            case 0x3e:
                prefixes |= PREFIX_DS;
                break;
            case 0x26:
                prefixes |= PREFIX_ES;
                break;
            case 0x64:
                prefixes |= PREFIX_FS;
                break;
            case 0x65:
                prefixes |= PREFIX_GS;
                break;
            case 0x66:
                prefixes |= PREFIX_DATA;
                break;
            case 0x67:
                prefixes |= PREFIX_ADR;
                break;
            case 0x9b:
                prefixes |= PREFIX_FWAIT;
                break;
            default:
                return lpB;
        }
    lpB++;
    }
}


void AppendPrefixes(void)
{
    if (prefixes & PREFIX_CS)
        AppendString("cs:");
    if (prefixes & PREFIX_DS)
        AppendString("ds:");
    if (prefixes & PREFIX_SS)
        AppendString("ss:");
    if (prefixes & PREFIX_ES)
        AppendString("es:");
    if (prefixes & PREFIX_FS)
        AppendString("fs:");
    if (prefixes & PREFIX_GS)
        AppendString("gs:");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\dib.c ===
/******************************Module*Header*******************************\
* Module Name: dib.c
*
* This file is for debugging tools and extensions.
*
* Created: 12-Jan-1996
* Author: VadimB
*
* History:
* Jan 12 96 VadimB Created to dump a list of dib.drv support structures
*
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <wmdisp32.h>
#include <wcuricon.h>
#include <wucomm.h>
#include <doswow.h>
#include <wdib.h>
#include <wowgdip.h>

//
// Local function prototypes
//

extern INT  WDahtoi(LPSZ lpsz);
extern INT  WDParseArgStr(LPSZ lpszArgStr, CHAR **argv, INT iMax);

LPVOID DumpDibInfo(PDIBINFO pdi)
{
    DIBINFO di;
    
    READMEM_XRETV(di, pdi, NULL);
    pdi = &di;  

    PRINTF(">> Structure at %08X\n", (DWORD)(LPVOID)pdi);
    PRINTF("di_hdc: (32)%08X (16)%04X\n", pdi->di_hdc, ((DWORD)(pdi->di_hdc))<<2);
    PRINTF("di_newdib: %08X\n", (DWORD)pdi->di_newdib);
    PRINTF("di_newIntelDib: %08X\n", (DWORD)pdi->di_newIntelDib);
    PRINTF("di_hbm: (32)%08X\n", (DWORD)pdi->di_hbm);
    PRINTF("di_dibsize: %08X\n", (DWORD)pdi->di_dibsize);
    PRINTF("di_originaldibsel: %08X\n", (DWORD)pdi->di_originaldibsel);
    PRINTF("di_originaldibflags: %08X\n", (DWORD)pdi->di_originaldibflags);
    PRINTF("di_lockcount: %08X\n", (DWORD)pdi->di_lockcount);
    PRINTF("\n");

    return (LPVOID)pdi->di_next;
}


VOID DumpDibChain(LPSTR lpszExpressionHead)
{
    PDIBINFO pdi;

    GETEXPRADDR(pdi, lpszExpressionHead);
    READMEM_XRET(pdi, pdi);

    if (NULL == pdi) {
        PRINTF("List %s is empty!\n", lpszExpressionHead);
    }
    else {
        PRINTF("\nDump of the DIB.DRV support structure: %s\n", lpszExpressionHead);
        PRINTF("-------------------------------------------------------\n");
        
        while (NULL != pdi) {
            pdi = DumpDibInfo(pdi);
        }
    }
}


VOID 
dhdib(
    CMD_ARGLIST
    )
{
// dump dib support chain
// dumps: dhdib @<address> - dump at address
// dumps: dhdib   - everything...
    
    CHAR* argv[3];
    int nArgs;
    BOOL fDumpDib = TRUE;
    static CHAR* symDibHead = "wow32!pDibInfoHead";
    PDIBINFO pdi;

    CMD_INIT();
    ASSERT_WOW_PRESENT;

    nArgs = WDParseArgStr(lpArgumentString, argv, 2);
    if (nArgs > 0) {

        CHAR* parg = argv[0];
        switch(toupper(*parg)) {  // dump at...
            case '@':
                // recover address and dump!
                {
                    CHAR* pch = *++parg ? 
                                    parg : 
                                    (nArgs >= 2 ? argv[1] : NULL);
                    if (pch) {
                        pdi = (PDIBINFO)WDahtoi(pch);
                        fDumpDib = FALSE;
                    }
                    else {
                        PRINTF("Invalid Parameter\n"); 
                    }
                }
                break;

            default:
                break;
        }
    }


    if (fDumpDib) {
        DumpDibChain(symDibHead);
    }
    else {
        if (pdi) {
            DumpDibInfo(pdi);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\dos.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains miscellaneous DOS VDMEXTS functions

Author:

    Neil Sandlin (NeilSa) 29-Jul-1996 Wrote it

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop
#include <doswow.h>

VOID
ddh(
    CMD_ARGLIST
    )
/*
    Dump DOS Heap
*/
{
    DWORD selector;
    BYTE Sig;
    WORD Size;
    WORD Owner;
    int count = 0;
    char Module[9];

    CMD_INIT();

    if (!GetNextToken()) {
        WORD wSegment, wSelector;
        LONG lOffset;
        int Mode;

        if (!FindAddress("arena_head",
                         Module, &wSegment, &wSelector, &lOffset, &Mode, FALSE)) {

            PRINTF("Can't find symbol ntdos!arena_head\n");
            return;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(wSelector<<4)+lOffset), &wSelector, 2)) {
            PRINTF("Error reading ntdos!arena_head\n");
            return;
        }
        selector = wSelector;
    } else {
        selector = (DWORD) EXPRESSION(lpArgumentString);
    }

    PRINTF("DOS memory chain dump\n\n");
    PRINTF("   Addr   Sig Size   Owner\n");
    PRINTF("--------- --- ----  --------\n");

    while (1) {

        if (selector > 0x10000) {
            PRINTF("%08x: Segment value out of range (> 1MB)\n", selector);
            break;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(selector<<4)), &Sig, 1)) {
            PRINTF("%04x:0000: <Error Reading Memory>\n", selector);
            break;
        }

        if ((Sig != 'M') && (Sig != 'Z')) {
            PRINTF("%04x:0000: <Invalid DOS heap block>\n", selector);
            break;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(selector<<4)+1), &Owner, 2)) {
            PRINTF("%04x:0001: <Error Reading Memory>\n", selector);
            break;
        }

        if (!READMEM((LPVOID)(GetIntelBase()+(selector<<4)+3), &Size, 2)) {
            PRINTF("%04x:0003: <Error Reading Memory>\n", selector);
            break;
        }

        PRINTF("%04x:0000: %c  %.04X ", selector, Sig, Size);


        if (Owner == 0) {
            PRINTF(" Free\n");
        } else if (Owner<=8) {
            PRINTF(" System\n");
        } else {
            if (!READMEM((LPVOID)(GetIntelBase()+((Owner-1)<<4)+8), Module, 8)) {
                PRINTF("%04x:0008: <Error Reading Memory>\n", selector);
                break;
            }
            Module[8] = 0;
            PRINTF(" %s\n", Module);
        }

        if ((Sig == 'Z') && (selector>0x9ffe)) {
            break;
        }
        selector += Size;
        selector ++;
    }

}


BOOL
DumpSFT(
    USHORT index,
    BOOL Verbose
    )
{
    USHORT usSFN = index;
    ULONG pSfFlat;
    ULONG pSftFlat;
    DOSSF  DosSf;
    DOSSFT DosSft;
    USHORT usSFTCount;
    ULONG  ulSFLink;

    if (!ReadMemExpression("ntvdm!pSFTHead", &pSfFlat, sizeof(pSfFlat))) {
        return FALSE;
    }

    if (!READMEM((LPVOID)(pSfFlat), &DosSf, sizeof(DosSf))) {
        PRINTF("%08x: <Error Reading Memory>\n", pSfFlat);
        return FALSE;
    }

    // Find the right SFT group
    while (usSFN >= (usSFTCount = DosSf.SFCount)){
        usSFN = usSFN - usSFTCount;
        ulSFLink = DosSf.SFLink;
        if (LOWORD(ulSFLink) == 0xffff)
            return FALSE;

        pSfFlat = (((ULONG)(HIWORD(ulSFLink))<<4) + LOWORD(ulSFLink)) + GetIntelBase();

        if (!READMEM((LPVOID)(+pSfFlat), &DosSf, sizeof(DosSf))) {
            PRINTF("%08x: <Error Reading Memory>\n", pSfFlat);
            return FALSE;
        }
    }

    // Get the begining of SFT
    pSftFlat = (ULONG)&(((PDOSSF)pSfFlat)->SFTable);
    pSftFlat += usSFN*sizeof(DOSSFT);

    if (!READMEM((LPVOID)(pSftFlat), &DosSft, sizeof(DosSft))) {
        PRINTF("%08x: <Error Reading Memory>\n", pSftFlat);
        return FALSE;
    }

    PRINTF("%.2X(%.8X)  %.4X %.4X %.2X %.4X %.8X %.4X %.8X\n",
            (UCHAR)index,
            pSftFlat,
            DosSft.SFT_Ref_Count,
            DosSft.SFT_Mode,
            DosSft.SFT_Attr,
            DosSft.SFT_Flags,
            DosSft.SFT_Devptr,
            DosSft.SFT_PID,
            DosSft.SFT_NTHandle);

    if (Verbose) {
        PRINTF("                         %.4X %.4X %.8X %.8X %.8X\n",
            DosSft.SFT_Time,
            DosSft.SFT_Date,
            DosSft.SFT_Size,
            DosSft.SFT_Position,
            DosSft.SFT_Chain);
    }
    return TRUE;
}


VOID
dsft(
    CMD_ARGLIST
    )
/*
    Dump DOS system SFT
*/
{
    USHORT i;
    CMD_INIT();

    PRINTF("SFT           Ref  Mode At Flgs  Devptr  PID  NTHandle\n");

    if (GetNextToken()) {
        DumpSFT((USHORT) EXPRESSION(lpArgumentString), FALSE);
        return;
    }

    for (i=0; i<255; i++) {
        if (!DumpSFT(i, FALSE)) {
            break;
        }
    }
}


VOID
dfh(
    CMD_ARGLIST
    )
/*
    Dump File handle
*/
{
    DOSPDB DosPdb;
    BOOL bDumpAll = TRUE;
    BOOL bUseCurrentPDB = TRUE;
    USHORT pdb;
    ULONG ppdb;
    UCHAR Fh;
    ULONG pJfn;
    UCHAR SftIndex;

    CMD_INIT();

    if (GetNextToken()) {
        if (*lpArgumentString == '*') {
            SkipToNextWhiteSpace();
        } else {
           Fh = (UCHAR)EvaluateToken();
           bDumpAll = FALSE;
        }
        if (GetNextToken()) {
            pdb = (USHORT)EvaluateToken();
            bUseCurrentPDB = FALSE;
        }
    }

    if (bUseCurrentPDB) {
        if (!ReadMemExpression("ntvdm!puscurrentpdb", &ppdb, sizeof(ppdb))) {
            return;
        }
        if (!READMEM((LPVOID)(ppdb), &pdb, sizeof(pdb))) {
            PRINTF("<Error Reading puscurrentpdb at %.8x>\n", ppdb);
            return;
        }
    }

    if (!READMEM((LPVOID)(GetIntelBase()+((ULONG)(pdb)<<4)), &DosPdb, sizeof(DosPdb))) {
        PRINTF("<Error Reading PDB at &%.4x:0000> (%x)\n", pdb,(GetIntelBase()+((ULONG)(pdb)<<4)));
        return;
    }

    if (!bDumpAll && (Fh >= DosPdb.PDB_JFN_Length)) {
        PRINTF("<File handle %.2x out of range (0:%.02X)>\n", Fh, DosPdb.PDB_JFN_Length);
        return;
    }

    pJfn = GetIntelBase() + ((ULONG)(HIWORD(DosPdb.PDB_JFN_Pointer))<<4) +
                            LOWORD(DosPdb.PDB_JFN_Pointer);

#if 0
    PRINTF("%.8X %.8X %.8X\n", GetIntelBase(), (ULONG)(HIWORD(DosPdb.PDB_JFN_Pointer))<<4, (ULONG)LOWORD(DosPdb.PDB_JFN_Pointer));
    PRINTF("pdb=%.4X pjfn=%.8X ljfn=%.4X Flat=%.8X\n", pdb, DosPdb.PDB_JFN_Pointer, DosPdb.PDB_JFN_Length, pJfn);
#endif

    PRINTF("fh SFT           Ref  Mode At Flgs  Devptr  PID  NTHandle\n");

    if (bDumpAll) {
        for (Fh = 0; Fh < DosPdb.PDB_JFN_Length; Fh++) {
            if (!READMEM((LPVOID)(pJfn + Fh),
                         &SftIndex, sizeof(SftIndex))) {
                PRINTF("<Error Reading JFT at %.8x>\n", pJfn + Fh);
                return;
            }

            if (SftIndex != 0xff) {
                PRINTF("%.2X ", Fh);
                DumpSFT((USHORT)SftIndex, FALSE);
            }

        }

    } else {

        if (!READMEM((LPVOID)(pJfn + Fh),
                     &SftIndex, sizeof(SftIndex))) {
            PRINTF("<Error Reading JFT at %.8x>\n", pJfn + Fh);
            return;
        }

        if (SftIndex != 0xff) {
            PRINTF("%.2X ", Fh);
            DumpSFT((USHORT)SftIndex, FALSE);
        } else {
            PRINTF("Handle %.2X is not open\n", Fh);
        }
    }
}


BOOL DumpEnvironment(WORD segEnv, int mode)
{
    char rgchEnv[32768];
    char *pch;
    char *pchLimit;

    if (!READMEM((LPVOID)(GetIntelBase() + GetInfoFromSelector(segEnv, mode, NULL)),
                 rgchEnv, sizeof(rgchEnv))) {
        PRINTF("<Error Reading Environment at &%.4x:0 (%.8x)>\n", segEnv, GetIntelBase() + (segEnv << 4));
        return FALSE;
    }

    //
    // Dump each string in environment block until
    // double-null termination.
    //

    pch = rgchEnv;
    pchLimit = rgchEnv + sizeof(rgchEnv);

    while (pch < pchLimit && *pch) {

        if (!strchr(pch, '=')) {
            PRINTF("<malformed environment string, halting dump>\n");
            return FALSE;
        }
        PRINTF("    %s\n", pch);
        pch += strlen(pch) + 1;
    }

    if (pch >= pchLimit) {
        PRINTF("<Environment exceeded 32k, dump halted>\n", pch);
        return FALSE;
    }

    //
    // pch now points at the second null of the double-null termination,
    // advance past this null and dump the magic word that follows and
    // the EXE path after that.
    //

    pch++;
    if (pch >= pchLimit - 1) {
        PRINTF("<Environment exceeded 32k, dump halted>\n", pch);
        return FALSE;
    }

    if (1 != *(WORD UNALIGNED *)pch) {
        PRINTF("\nMagic word after double-null IS NOT ONE, dump halted: 0x%x\n", *(WORD UNALIGNED *)pch);
        return FALSE;
    }
    pch += sizeof(WORD);
    if ( (pch + strlen(pch) + 1) > pchLimit) {
        PRINTF("<Environment exceeded 32k, dump halted>\n", pch);
        return FALSE;
    }

    PRINTF("EXE path: <%s>\n", pch);

    return TRUE;
}


VOID
denv(
    CMD_ARGLIST
    )
/*
    Dump environment block for current DOS process or given environment selector

    !denv <bPMode> <segEnv>

    Examples:
    !denv             - Dumps environment for current DOS process
    !denv 0 145d      - Dumps DOS environment at &145d:0 (145d from PDB_environ of DOS process)
    !denv 1 16b7      - Dumps DOS environment at #16b7:0 (16b7 from !dt -v segEnvironment)
*/
{
    DOSPDB DosPdb;
    BOOL bUseCurrentPDB = TRUE;
    USHORT pdb;
    USHORT segEnv;
    ULONG ppdb;
    int mode = PROT_MODE;

    CMD_INIT();

    if (GetNextToken()) {
        mode = (int)EvaluateToken();
        if (GetNextToken()) {
            segEnv = (USHORT)EvaluateToken();
            bUseCurrentPDB = FALSE;
        }
    }

    if (bUseCurrentPDB) {
        if (!ReadMemExpression("ntvdm!puscurrentpdb", &ppdb, sizeof(ppdb))) {
            return;
        }
        if (!READMEM((LPVOID)(GetIntelBase()+ppdb), &pdb, sizeof(pdb))) {
            PRINTF("<Error Reading puscurrentpdb at %.8x>\n", ppdb);
            return;
        }
        PRINTF("Current PDB is 0x%x\n", pdb);
        if (!READMEM((LPVOID)(GetIntelBase()+((ULONG)(pdb)<<4)), &DosPdb, sizeof(DosPdb))) {
             PRINTF("<Error Reading PDB at &%.4x:0000>\n", pdb);
             return;
        }
        segEnv = DosPdb.PDB_environ;
        //
        // Guess mode for current PDB's PDB_environ (could be real or PM depending
        // on where we are in dosx).
        //
        if ( (segEnv & 0x7) == 0x7 ) {
            mode = PROT_MODE;
        } else {
            mode = V86_MODE;
        }
    }
    PRINTF("Environment %s is 0x%x\n", mode ? "selector" : "segment", segEnv);

    if (segEnv) {
        DumpEnvironment(segEnv, mode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\debug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains code to manage software breakpoints

Author:

    Neil Sandlin (neilsa) 1-Nov-1995

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop
#include <dpmi.h>
#include <dbgsvc.h>
#include <dbginfo.h>
#include <stdio.h>

#define BREAKPOINT_CLEAR 1
#define BREAKPOINT_DISABLE 2
#define BREAKPOINT_ENABLE 3

#define VDMBP_ARRAY "ntvdmd!VdmBreakPoints"

VDM_BREAKPOINT VdmBPCache[MAX_VDM_BREAKPOINTS] = {0};
// BP zero is reserved for internal use
#define TEMP_BP 0

BOOL
LoadBreakPointCache(
    VOID
    )
{
    ULONG lpAddress;
    lpAddress = (*GetExpression)(VDMBP_ARRAY);

    if (!lpAddress) {
        PRINTF("Could not find symbol %s\n",VDMBP_ARRAY);
        return FALSE;
    }

    if (!READMEM((PVOID)lpAddress, &VdmBPCache, sizeof(VdmBPCache))) {
        PRINTF("Error reading BP memory\n");
        return FALSE;
    }
    return TRUE;
}

BOOL
FlushBreakPointCache(
    VOID
    )
{
    ULONG lpAddress;
    lpAddress = (*GetExpression)(VDMBP_ARRAY);

    if (!lpAddress) {
        PRINTF("Could not find symbol %s\n",VDMBP_ARRAY);
        return FALSE;
    }

    if (!WRITEMEM((PVOID)lpAddress, &VdmBPCache, sizeof(VdmBPCache))) {
        PRINTF("Error writing BP memory\n");
        return FALSE;
    }
    return TRUE;
}



BOOL
IsVdmBreakPoint(
    USHORT selector,
    ULONG offset,
    BOOL bProt,
    PULONG pBpNum,
    PUCHAR pBpData
    )
//
// Callers of this function must first call LoadBreakPointCache()
//
{
    ULONG BPNum;

    for (BPNum = 0; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if ((VdmBPCache[BPNum].Flags & VDMBP_SET) &&
            (VdmBPCache[BPNum].Seg == selector)   &&
            (VdmBPCache[BPNum].Offset == offset)) {

            if ((bProt && ~(VdmBPCache[BPNum].Flags & VDMBP_V86)) ||
                (~bProt && (VdmBPCache[BPNum].Flags & VDMBP_V86))) {
                *pBpNum = BPNum;
                *pBpData = VdmBPCache[BPNum].Opcode;
                return TRUE;
            }
        }
    }
    return FALSE;
}


VOID
DisableBreakPoint(
    VDM_BREAKPOINT *pBP
    )
{
    int mode;
    ULONG lpAddress;
    BYTE byte;

    if (!(pBP->Flags & VDMBP_ENABLED)) {
        // already not enabled
        return;
    }

    pBP->Flags &= ~VDMBP_ENABLED;

    if (pBP->Flags & VDMBP_PENDING) {
        pBP->Flags &= ~VDMBP_PENDING;
        return;
    }


    if (pBP->Flags & VDMBP_V86) {
        mode = V86_MODE;
    } else {
        mode = PROT_MODE;
    }

    lpAddress = GetInfoFromSelector(pBP->Seg, mode, NULL) + GetIntelBase() + pBP->Offset;

    if (READMEM((PVOID)lpAddress, &byte, 1)) {
        if (byte == 0xcc) {
            WRITEMEM((PVOID)lpAddress, &pBP->Opcode, 1);
        }
    }

    pBP->Flags |= VDMBP_FLUSH;
    pBP->Flags &= ~VDMBP_PENDING;

#ifndef i386
    if (!InVdmPrompt()) {
        PRINTF("\n***Warning: command not issued from VDM> prompt.\nOpcode has not been flushed!\n\n");
    }
#endif
}

VOID
EnableBreakPoint(
    VDM_BREAKPOINT *pBP
    )
{
    int mode;
    ULONG lpAddress;
    BYTE byte;

    if (pBP->Flags & VDMBP_ENABLED) {
        return;
    }

    EnableDebuggerBreakpoints();

    if (pBP->Flags & VDMBP_V86) {
        mode = V86_MODE;
    } else {
        mode = PROT_MODE;
    }

    lpAddress = GetInfoFromSelector(pBP->Seg, mode, NULL) + GetIntelBase() + pBP->Offset;

    if (READMEM((PVOID)lpAddress, &byte, 1)) {
        if (byte != 0xcc) {
            static BYTE bpOp = 0xcc;

            WRITEMEM((PVOID)lpAddress, &bpOp, 1);
            pBP->Opcode = byte;
        }
    } else {

        PRINTF("Error enabling breakpoint at %04X:%08X\n", pBP->Seg, pBP->Offset);
        return;
    }

    pBP->Flags |= (VDMBP_ENABLED | VDMBP_FLUSH);
    pBP->Flags &= ~VDMBP_PENDING;

#ifndef i386
    if (!InVdmPrompt()) {
        PRINTF("\n***Warning: command not issued from VDM> prompt.\nBP has not been flushed!\n\n");
    }
#endif

}


VOID
UpdateBreakPoint(
    int Cmd
    )

{
    int BPNum;
    int count = 0;
    BOOL DoBreakPoints[MAX_VDM_BREAKPOINTS] = {FALSE};
    BOOL DoAll = FALSE;

    if (!LoadBreakPointCache()) {
        return;
    }

    while (GetNextToken()) {
        if (*lpArgumentString == '*') {
            DoAll = TRUE;
            count++;
            break;
        }
        
        
        if(sscanf(lpArgumentString, "%d", &BPNum) != 1 || BPNum >= MAX_VDM_BREAKPOINTS) {
            PRINTF("Invalid breakpoint - %d\n", BPNum);
            return;
        }
        DoBreakPoints[BPNum] = TRUE;
        count++;
        SkipToNextWhiteSpace();
    }

    if (!count) {
        PRINTF("Please specify a breakpoint #\n");
        return;
    }


    for (BPNum=0; BPNum<MAX_VDM_BREAKPOINTS; BPNum++) {

        if (!DoBreakPoints[BPNum] && !DoAll) {
            continue;
        }

        if (!(VdmBPCache[BPNum].Flags & VDMBP_SET)) {
            continue;
        }
        switch(Cmd) {

        case BREAKPOINT_CLEAR:

            if (VdmBPCache[BPNum].Flags & VDMBP_ENABLED) {
                DisableBreakPoint(&VdmBPCache[BPNum]);
            }
            VdmBPCache[BPNum].Flags &= ~VDMBP_SET;
            break;

        case BREAKPOINT_DISABLE:

            if (VdmBPCache[BPNum].Flags & VDMBP_ENABLED) {
                DisableBreakPoint(&VdmBPCache[BPNum]);
            }
            break;

        case BREAKPOINT_ENABLE:

            if (!(VdmBPCache[BPNum].Flags & VDMBP_ENABLED)) {
                EnableBreakPoint(&VdmBPCache[BPNum]);
            }
            break;

        }
    }

    FlushBreakPointCache();
}

VOID
bc(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    UpdateBreakPoint(BREAKPOINT_CLEAR);
}

VOID
bd(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    UpdateBreakPoint(BREAKPOINT_DISABLE);
}

VOID
be(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    UpdateBreakPoint(BREAKPOINT_ENABLE);
}


VOID
bl(
    CMD_ARGLIST
    )
{
    int BPNum;
    int mode;
    DWORD dist;
    CHAR  sym_text[255];

    CMD_INIT();

    if (!LoadBreakPointCache()) {
        return;
    }

    for (BPNum = 0; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if (VdmBPCache[BPNum].Flags & VDMBP_SET) {

            PRINTF("%d %s%s%s ", BPNum,
                    (VdmBPCache[BPNum].Flags & VDMBP_ENABLED) ? "e" : "d",
                    (VdmBPCache[BPNum].Flags & VDMBP_FLUSH) ? "f" : " ",
                    (VdmBPCache[BPNum].Flags & VDMBP_PENDING) ? "p" : " ");

            if (VdmBPCache[BPNum].Flags & VDMBP_V86) {
                mode = V86_MODE;
                PRINTF("&");
            } else {
                mode = PROT_MODE;
                PRINTF("#");
            }

            PRINTF("%04X:", VdmBPCache[BPNum].Seg);

            if (VdmBPCache[BPNum].Offset > 0xffff) {
                PRINTF("%08X", VdmBPCache[BPNum].Offset);
            } else {
                PRINTF("%04X", VdmBPCache[BPNum].Offset);
            }

            PRINTF("   %04X:***", VdmBPCache[BPNum].Count);


            if (FindSymbol(VdmBPCache[BPNum].Seg, VdmBPCache[BPNum].Offset,
                           sym_text, &dist, BEFORE, mode )) {

                if ( dist == 0 ) {
                    PRINTF(" %s", sym_text );
                } else {
                    PRINTF(" %s+0x%lx", sym_text, dist );
                }
            }
            PRINTF("\n");
        }
    }
}


VOID
bp(
    CMD_ARGLIST
    )
{
#ifdef _X86_
    CMD_INIT();
    PRINTF("Error- Use native BP command on x86 platforms\n");
#else
    int BPNum;
    VDMCONTEXT      ThreadContext;
    WORD            selector;
    ULONG           offset;
    USHORT          count = 1;
    int mode;
    USHORT flags = 0;

    CMD_INIT();

    if (!LoadBreakPointCache()) {
        return;
    }

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        PRINTF("Please enter an address\n");
        return;
    }

    if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    if (mode == V86_MODE) {
        flags = VDMBP_V86;
    }

    //
    // first see if it's set already
    //
    for (BPNum = 0; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if (VdmBPCache[BPNum].Flags & VDMBP_SET) {
            if ((VdmBPCache[BPNum].Seg == selector) &&
                (VdmBPCache[BPNum].Offset == offset) &&
                !(VdmBPCache[BPNum].Flags ^ flags))
                                                 {

                VdmBPCache[BPNum].Count = count;

                if (!(VdmBPCache[BPNum].Flags & VDMBP_ENABLED)) {
                    EnableBreakPoint(&VdmBPCache[BPNum]);
                }

                FlushBreakPointCache();
                PRINTF("breakpoint %d redefined\n", BPNum);
                return;

            }
        }
    }


    //
    // Not found, set a new one
    for (BPNum = 1; BPNum < MAX_VDM_BREAKPOINTS; BPNum++) {

        if (!(VdmBPCache[BPNum].Flags & (VDMBP_SET | VDMBP_FLUSH))) {
            VdmBPCache[BPNum].Seg = selector;
            VdmBPCache[BPNum].Offset = offset;
            VdmBPCache[BPNum].Count = count;
            VdmBPCache[BPNum].Flags = VDMBP_SET | flags;
            EnableBreakPoint(&VdmBPCache[BPNum]);

            FlushBreakPointCache();
            return;

        }
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\dpmi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains miscellaneous VDMEXTS functions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop
#include <dpmi.h>


VOID
PrintOneFaultVector(
    int vector,
    ULONG pHandler
    )
{
    VDM_FAULTHANDLER handler;
    char            sym_text[255];
    ULONG dist;

    PRINTF("%02X: ", vector);

    if (!READMEM((LPVOID)pHandler, &handler, sizeof(VDM_FAULTHANDLER))) {
        PRINTF("<error reading memory>\n");
        return;
    }

    PRINTF("%04LX:%08lX ", handler.CsSelector, handler.Eip);

    if (FindSymbol(handler.CsSelector, handler.Eip, sym_text, &dist, BEFORE, PROT_MODE )) {
        if ( dist == 0 ) {
            PRINTF("%s", sym_text );
        } else {
            PRINTF("%s+0x%lx", sym_text, dist );
        }
    }
    PRINTF("\n");

}



VOID
df(
    CMD_ARGLIST
    )
{
    int vector = -1;
    LPVOID pHandlers;


    CMD_INIT();

    if (GetNextToken()) {
        vector = EvaluateToken();
        if ((vector < 0) || (vector > 0x1f)) {
            PRINTF("Invalid fault vector\n");
            return;
        }
    }

    pHandlers = (LPVOID) EXPRESSION("ntvdm!dpmifaulthandlers");
    if (!pHandlers) {
        PRINTF("Could get symbol ntvdm!dpmifaulthandlers\n");
        return;
    }


    if (vector >= 0) {

        PrintOneFaultVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_FAULTHANDLER));

    } else for (vector = 0; vector < 0x20; vector++) {

        PrintOneFaultVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_FAULTHANDLER));

    }

}


VOID
PrintOneInterruptVector(
    int vector,
    ULONG pHandler
    )
{
    VDM_INTERRUPTHANDLER handler;
    char            sym_text[255];
    ULONG dist;

    PRINTF("%02X: ", vector);

    if (!READMEM((LPVOID)pHandler, &handler, sizeof(VDM_INTERRUPTHANDLER))) {
        PRINTF("<error reading memory>\n");
        return;
    }

    PRINTF("%04LX:%08lX ", handler.CsSelector, handler.Eip);

    if (FindSymbol(handler.CsSelector, handler.Eip, sym_text, &dist, BEFORE, PROT_MODE )) {
        if ( dist == 0 ) {
            PRINTF("%s", sym_text );
        } else {
            PRINTF("%s+0x%lx", sym_text, dist );
        }
    }

    PRINTF("\n");

}



VOID
di(
    CMD_ARGLIST
    )
{
    int vector = -1;
    LPVOID pHandlers;

    CMD_INIT();

    if (GetNextToken()) {
        vector = EvaluateToken();
        if ((vector < 0) || (vector > 0xff)) {
            PRINTF("Invalid interrupt vector\n");
            return;
        }
    }

    pHandlers = (LPVOID) EXPRESSION("ntvdm!dpmiinterrupthandlers");
    if (!pHandlers) {
        PRINTF("Could get symbol ntvdm!dpmiinterrupthandlers\n");
        return;
    }

    if (vector >= 0) {

        PrintOneInterruptVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_INTERRUPTHANDLER));

    } else for (vector = 0; vector < 0x100; vector++) {

        PrintOneInterruptVector(vector, (ULONG)pHandlers +
                                  vector*sizeof(VDM_INTERRUPTHANDLER));

    }

}

VOID
rmcb(
    CMD_ARGLIST
    )
{
    RMCB_INFO Rmcb[MAX_RMCBS];
    USHORT RMCallBackBopSeg;
    USHORT RMCallBackBopOffset;
    int i;
    int count = 0;

    CMD_INIT();

    if (!ReadMemExpression("ntvdm!DpmiRmcb", Rmcb, MAX_RMCBS*sizeof(RMCB_INFO))) {
        return;
    }

    if (!ReadMemExpression("ntvdm!RMCallBackBopSeg", &RMCallBackBopSeg, 2)) {
        return;
    }

    if (!ReadMemExpression("ntvdm!RMCallBackBopOffset", &RMCallBackBopOffset, 2)) {
        return;
    }


    for (i=0; i<MAX_RMCBS; i++) {
        if (Rmcb[i].bInUse) {

            if (!count++) {
                PRINTF("\n");
                PRINTF(" CallBack      PM Proc         RM Struct       Stack Sel\n");
            }

            PRINTF("&%.4X:%.4X  -  ", RMCallBackBopSeg-i,
                                     RMCallBackBopOffset + (i*16));

            PRINTF("#%.4X:%.8X  #%.4X:%.8X  %.4X\n",
                                     Rmcb[i].ProcSeg,
                                     Rmcb[i].ProcOffset,
                                     Rmcb[i].StrucSeg,
                                     Rmcb[i].StrucOffset,
                                     Rmcb[i].StackSel);

        }
    }

    if (!count) {
        PRINTF("No dpmi real mode callbacks are defined\n");
    } else {
        PRINTF("\n");
    }

}


VOID
DumpDpmiMemChain(
    ULONG Head
    )
{
    MEM_DPMI MemBlock;
    ULONG pMem;
    ULONG Count = 0;

    if (!Head) {
        PRINTF("Error accessing ntvdm symbols\n");
        return;
    }

    if (!READMEM((LPVOID)(Head), &MemBlock, sizeof(MEM_DPMI))) {
        PRINTF("<Error Reading memory list head>\n");
        return;
    }

    pMem = (ULONG) MemBlock.Next;

    if (pMem == Head) {
        PRINTF("The list is empty.\n");
    } else {

        PRINTF("Address  Length   Owner Sel  Cnt   Next     Prev\n");
        while (pMem != Head) {

            if (!READMEM((LPVOID)(pMem), &MemBlock, sizeof(MEM_DPMI))) {
                PRINTF("<Error Reading memory list block at %.08X>\n", pMem);
                return;
            }

            PRINTF("%.08X %.08X %.04X  %.04X %.04X  %.08X %.08X\n",
                        MemBlock.Address, MemBlock.Length,
                        MemBlock.Owner, MemBlock.Sel, MemBlock.SelCount,
                        MemBlock.Next, MemBlock.Prev);

            pMem = (ULONG) MemBlock.Next;
            Count++;
            if (Count>100) {
                PRINTF("Possible Corruption\n");
                return;
            }
        }

    }

}

VOID
dpx(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    PRINTF("\n*** Dpmi XMEM Allocation chain ***\n\n");
    DumpDpmiMemChain(EXPRESSION("ntvdm!XmemHead"));
}

VOID
dpd(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    PRINTF("\n*** Dpmi DOSMEM Allocation chain ***\n\n");
    DumpDpmiMemChain(EXPRESSION("ntvdm!DosMemHead"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntsdexts.h>
#include <string.h>
#include <stdlib.h>

#include <vdm.h>
#include <vdmdbg.h>
#include <vdmexts.h>

#include <ctype.h>
#define DEBUG_OR_WOWPROFILE 1
#include <wow32.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\misc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains miscellaneous VDMEXTS functions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop
#include <ctype.h>

extern DWORD gOffset;       // in disasm.c

VOID
DumpMemory(
    UINT UnitSize,
    BOOL bAscii
    )
{
    VDMCONTEXT ThreadContext;
    int mode;
    int j, lines = 8, linelength;
    WORD selector;
    ULONG offset, endoffset, units;
    ULONG base;
    char ch;

    if (!UnitSize) {
        return;
    }

    mode = GetContext( &ThreadContext );

    if (!GetNextToken()) {
        PRINTF("Please specify an address\n");
        return;
    }

    if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    if (GetNextToken()) {
        if ((*lpArgumentString == 'l') || (*lpArgumentString == 'L')) {
            lpArgumentString++;
        }
        units = EvaluateToken();
        lines = (units*UnitSize+15)/16;
    } else {
        units = (lines*16)/UnitSize;
    }

    endoffset = offset+units*UnitSize;

    base = GetInfoFromSelector(selector, mode, NULL) + GetIntelBase();

    while (lines--) {
        if (offset & 0xFFFF0000) {
            PRINTF("%04x:%08lx ", selector, offset);
        } else {
            PRINTF("%04x:%04x ", selector, LOWORD(offset));
        }

        linelength = endoffset - offset;
        if (linelength > 16) {
            linelength = 16;
        }

        switch(UnitSize) {

        case 1:
            for (j=0; j<linelength; j++) {
                if (j==8) {
                    PRINTF("-");
                } else {
                    PRINTF(" ");
                }
                PRINTF("%02x", ReadByteSafe(base+offset+j));
            }

            break;
        case 2:
            for (j=0; j<linelength; j+=2) {
                PRINTF(" %04x", ReadWordSafe(base+offset+j));
            }
            break;
        case 4:
            for (j=0; j<linelength; j+=4) {
                PRINTF(" %08lx", ReadDwordSafe(base+offset+j));
            }
            break;
        }

        if (bAscii) {

            j = (16-linelength)*2 + (16-linelength)/UnitSize;
            while (j--) {
                PRINTF(" ");
            }

            PRINTF("  ");

            for (j=0; j<linelength; j++) {
                ch = ReadByteSafe(base+offset+j);
                if (isprint(ch)) {
                    PRINTF("%c", ch);
                } else {
                    PRINTF(".");
                }
            }
        }
        PRINTF("\n");
        offset += 16;

    }

}

VOID
db(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    DumpMemory(1, TRUE);

}

VOID
dw(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    DumpMemory(2, FALSE);

}

VOID
dd(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    DumpMemory(4, FALSE);

}

VOID
EditMemory(
    UINT UnitSize
    )
{
    ULONG value, base, offset;
    WORD selector;
    int mode;

    if (!GetNextToken()) {
        PRINTF("Please specify an address\n");
        return;
    }

    if (!ParseIntelAddress(&mode, &selector, &offset)) {
        return;
    }

    base = GetInfoFromSelector(selector, mode, NULL) + GetIntelBase();

    while(GetNextToken()) {
        value = EvaluateToken();

        PRINTF("%04x base=%08x offset=%08x value=%08x\n", selector, base, offset, value);
        // this is endian dependant code
        WRITEMEM((LPVOID)(base+offset), &value, UnitSize);
        offset += UnitSize;

    }

}

VOID
eb(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    EditMemory(1);
}

VOID
ew(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    EditMemory(2);
}

VOID
ed(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    EditMemory(4);
}





VOID
r(
    CMD_ARGLIST
) {
    VDMCONTEXT              ThreadContext;
    int                     mode;
    char            sym_text[255];
    char            rgchOutput[128];
    char            rgchExtra[128];
    BYTE            rgbInstruction[64];
    WORD            selector;
    ULONG           offset;
    ULONG           dist;
    int  cb, j;
    ULONG Base;
    SELECTORINFO si;

    CMD_INIT();

    mode = GetContext( &ThreadContext );

    PRINTF("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
            ThreadContext.Eax,
            ThreadContext.Ebx,
            ThreadContext.Ecx,
            ThreadContext.Edx,
            ThreadContext.Esi,
            ThreadContext.Edi );
    PRINTF("eip=%08lx esp=%08lx ebp=%08lx                ",
            ThreadContext.Eip,
            ThreadContext.Esp,
            ThreadContext.Ebp );

    if (ThreadContext.EFlags != 0xffffffff) {
        if ( ThreadContext.EFlags & FLAG_OVERFLOW ) {
            PRINTF("ov ");
        } else {
            PRINTF("nv ");
        }
        if ( ThreadContext.EFlags & FLAG_DIRECTION ) {
            PRINTF("dn ");
        } else {
            PRINTF("up ");
        }
        if ( ThreadContext.EFlags & FLAG_INTERRUPT ) {
            PRINTF("ei ");
        } else {
            PRINTF("di ");
        }
        if ( ThreadContext.EFlags & FLAG_SIGN ) {
            PRINTF("ng ");
        } else {
            PRINTF("pl ");
        }
        if ( ThreadContext.EFlags & FLAG_ZERO ) {
            PRINTF("zr ");
        } else {
            PRINTF("nz ");
        }
        if ( ThreadContext.EFlags & FLAG_AUXILLIARY ) {
            PRINTF("ac ");
        } else {
            PRINTF("na ");
        }
        if ( ThreadContext.EFlags & FLAG_PARITY ) {
            PRINTF("po ");
        } else {
            PRINTF("pe ");
        }
        if ( ThreadContext.EFlags & FLAG_CARRY ) {
            PRINTF("cy ");
        } else {
            PRINTF("nc ");
        }
    }

    PRINTF("\n");
    PRINTF("cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x             ",
            ThreadContext.SegCs,
            ThreadContext.SegSs,
            ThreadContext.SegDs,
            ThreadContext.SegEs,
            ThreadContext.SegFs,
            ThreadContext.SegGs);

    if (ThreadContext.EFlags == 0xffffffff) {
        //
        // The contents of eflags are unreliable. This happens when you can't
        // do a "getEFLAGS()" to obtain the value.
        //
        PRINTF("efl=????????\n");

    } else {
        PRINTF("efl=%08lx\n",ThreadContext.EFlags );
    }

    //
    // Do disassembly of current instruction
    //

    selector = (WORD) ThreadContext.SegCs;
    offset = ThreadContext.Eip;

    Base = GetInfoFromSelector( selector, mode, &si ) + GetIntelBase();

    if (FindSymbol(selector, offset, sym_text, &dist, BEFORE, mode )) {
        if ( dist == 0 ) {
            PRINTF("%s:\n", sym_text );
        } else {
            PRINTF("%s+0x%lx:\n", sym_text, dist );
        }
    }

    cb = sizeof(rgbInstruction);
    if ((DWORD)(offset+cb) >= si.Limit)
         cb -= offset+cb-si.Limit;
    if (!READMEM((LPVOID)(Base+offset), rgbInstruction, cb)) {
        PRINTF("%04x:%08x: <Error Reading Memory>\n", selector, offset);
        return;
    }

    cb = unassemble_one(rgbInstruction,
                si.bBig,
                selector, offset,
                rgchOutput,
                rgchExtra,
                &ThreadContext,
                mode);

    if (offset > 0xffff) {
        PRINTF("%04x:%08x ", selector, offset);
    } else {
        PRINTF("%04x:%04x ", selector, offset);
    }

    for (j=0; j<cb; ++j)
        PRINTF("%02x", rgbInstruction[j]);
    for (; j<8; ++j)
        PRINTF("  ");
    PRINTF("%s\t%s\n", rgchOutput, rgchExtra);
}

VOID
SearchModuleList(
    VOID
    )
{
    VDMCONTEXT              ThreadContext;
    int                     mode;
    HEAPENTRY               he = {0};
    SELECTORINFO si;
    WORD         selector = 0;
    SEGENTRY  *se;
    char      filename[9];
    char    szModuleArg[255];
    BOOL bModuleNameGiven=FALSE;
    LPSTR pTemp;


    mode = GetContext( &ThreadContext );

    if (GetNextToken()) {

        if (IsTokenHex()) {
            selector = (WORD) EvaluateToken();
        } else {
            bModuleNameGiven = TRUE;
            pTemp = lpArgumentString;
            SkipToNextWhiteSpace();
            *lpArgumentString = 0;
            strcpy(szModuleArg, pTemp);
            if (strlen(szModuleArg) > 8) {
                szModuleArg[8] = 0;
            }
        }
    }


    PRINTF("Sel    Base     Limit  Type  Module  Seg\n");
    PRINTF("==== ======== ======== ==== ======== ===\n");

    se = GetSegtablePointer();
    while ( se ) {
        if ( selector == 0 ||
             se->selector == selector ||
             bModuleNameGiven) {

            switch (se->type) {

            case SEGTYPE_PROT:
                {
                    HEAPENTRY               he = {0};
                    he.Selector = se->selector;
                    if (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_QUIET)) {
                        break;
                    }
                }
                GetInfoFromSelector(se->selector, PROT_MODE, &si);
                ParseModuleName(filename, se->szExePath);

                if (!bModuleNameGiven || !_stricmp(filename, szModuleArg)) {

                    PRINTF("%04X %08lX %08lX",
                        se->selector,
                        si.Base,
                        si.Limit);
                    PRINTF(" %s", si.bCode ? "code" : "data");
                    PRINTF(" %-8.8s %d\n",
                        filename,
                        se->segment+1 );

                }
                break;

            case SEGTYPE_V86:
                ParseModuleName(filename, se->szExePath);

                if (!bModuleNameGiven || !_stricmp(filename, szModuleArg)) {

                    PRINTF("%04X %08lX %08lX %s %-8.8s %d\n",
                        se->selector,
                        se->selector << 4,
                        se->length,
                        "v86 ",
                        filename,
                        se->segment+1);
                }
                break;
            }

        }
        se = se->Next;
    }

    he.CurrentEntry = 0;        // reset scan
    if (bModuleNameGiven) {
        strcpy(he.ModuleArg, szModuleArg);
    } else {
        he.Selector = selector;
    }

    while (FindHeapEntry(&he, bModuleNameGiven ? FHE_FIND_MOD_ONLY :
                                                 FHE_FIND_SEL_ONLY,
                                                    FHE_FIND_QUIET)) {

        if (he.SegmentNumber != -1) {
            GetInfoFromSelector((WORD)(he.gnode.pga_handle | 1), PROT_MODE, &si);
            PRINTF("%04X %08lX %08lX",
                he.gnode.pga_handle | 1,
                he.gnode.pga_address,
                he.gnode.pga_size - 1);

            PRINTF(" %s", si.bCode ? "Code" : "Data");

            PRINTF(" %-8.8s %d\n",
                he.OwnerName,
                he.SegmentNumber+1);
        }

    }

}


VOID
lm(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    if (GetNextToken()) {

        SearchModuleList();

    } else {

        WORD sel;
        BOOL    b;
        NEHEADER owner;
        ULONG base;
        CHAR ModuleName[9];
        UCHAR len;

        if (!ReadMemExpression("ntvdmd!DbgWowhExeHead", &sel, sizeof(sel))) {
            return;
        }

        PRINTF("NEHeader  Module Name\n");
        while(sel) {

            base = GetInfoFromSelector(sel, PROT_MODE, NULL) + GetIntelBase();

            b = READMEM((LPVOID)base, &owner, sizeof(owner));

            if (!b || (owner.ne_magic != 0x454e)) {
                PRINTF("Invalid module list! (started with hExeHead)\n");
                return;
            }
          
            len = ReadByteSafe(base+owner.ne_restab);
            if (len>8) {
                len=8;
            }
            READMEM((LPVOID)(base+owner.ne_restab+1), ModuleName, 8);
          
            ModuleName[len] = 0;

            PRINTF("  %.04X     %s\n", sel, ModuleName);
            // This is mapped to ne_pnextexe in kernel
            sel = owner.ne_cbenttab;
        } 
    }
}

VOID
dg(
    CMD_ARGLIST
) {
    ULONG                   selector;
    ULONG                   Base;
    SELECTORINFO            si;
    int                     count = 16;

    CMD_INIT();

    if (!GetNextToken()) {
        PRINTF("Please enter a selector\n");
        return;
    }

    selector = EvaluateToken();

    if (GetNextToken()) {
        if (tolower(*lpArgumentString) == 'l') {
            lpArgumentString++;
        }
        count = (WORD) EvaluateToken();
    }

    while (count--) {

        Base = GetInfoFromSelector( (WORD) selector, PROT_MODE, &si );

        PRINTF("%04X => Base: %08lX", selector, Base);

#ifndef i386
        PRINTF(" (%08X)", Base+GetIntelBase());
#endif

        PRINTF("  Limit: %08lX  %s %s %s %s %s %s\n",
                si.Limit,
                si.bPresent ? " P" : "NP",
                si.bSystem ? "System" : si.bCode     ? "Code  " : "Data  ",
                si.bSystem ? ""       : si.bWrite    ? "W" : "R",
                si.bSystem ? ""       : si.bAccessed ? "A" : " ",
                si.bBig    ? "Big" : "",
                si.bExpandDown ? "ED" : ""
                );

        selector+=8;
        if (selector>0xffff) {
            break;
        }
    }

}

VOID
ntsd(
    CMD_ARGLIST
    )
{
#if 0
    PVOID Address;
    static BOOL bTrue = TRUE;
#endif    

    CMD_INIT();

    PRINTF("vdmexts: obselete command 'ntsd', use '.<cmd>' from VDM> prompt\n");
#if 0
    if (!InVdmPrompt()) {
        PRINTF("This command only works at the VDM> prompt\n");
    }

    Address = (PVOID)(*GetExpression)("ntvdmd!bWantsNtsdPrompt");

    if (Address) {
        WRITEMEM((PVOID)Address, &bTrue, sizeof(BOOL));
        PRINTF("Enter 'g' to return from the ntsd prompt\n");
    } else {
        PRINTF("Can't find symbol 'ntvdmd!bWantsNtsdPrompt'\n");
    }
#endif
}


VOID
q(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    PRINTF("!vdmexts.q quitting debugger...");
    ExitProcess(0);
}


//
// fs find string
// case-insensitive
// searches LDT selectors one by one, first 64k only.
//

VOID
fs(
    CMD_ARGLIST
) {
    ULONG                   selector;
    ULONG                   Base;
    ULONG                   cbCopied;
    SELECTORINFO            si;
    BYTE                    Buffer[65*1024];
    LPSTR                   pszSearch;
    LPSTR                   pch;

    CMD_INIT();

    RtlZeroMemory(Buffer, sizeof(Buffer));

    if (!GetNextToken()) {
        PRINTF("Please enter a string to find in 16:16 memory\n");
        return;
    }

    pszSearch = lpArgumentString;

    PRINTF("Searching 16:16 memory for '%s'\n", pszSearch);

    for (selector = 7;
         selector < 0x10000;
         selector += 8) {

        Base = GetInfoFromSelector( (WORD) selector, PROT_MODE, &si );

        //
        // If the selector is valid and present read up to 64k
        // into Buffer.
        //

        if (Base != (ULONG)-1 && si.bPresent) {

            cbCopied = si.Limit + 1;

            if (cbCopied > 0x10000) {
                cbCopied = 0x10000;
            }

            if (!READMEM((LPVOID)(Base + GetIntelBase()), Buffer, cbCopied)) {
                PRINTF("Unable to read selector %04x contents at %x for %x bytes\n",
                       selector, Base + GetIntelBase(), cbCopied);
            } else {

                //
                // search the block for the string, buffer is 1k too big and
                // zero-inited so that strcmp is safe.
                //

                for (pch = Buffer;
                     pch < (Buffer + cbCopied);
                     pch++) {

                    if (!_memicmp(pch, pszSearch, strlen(pszSearch))) {

                        //
                        // Match!
                        //

                        PRINTF("%04x:%04x (%08x) '%s'\n",
                               selector,
                               pch - Buffer,
#ifndef i386
                               GetIntelBase() +
#endif
                               Base + (pch - Buffer),
                               pch);
                    }
                }
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\platform.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    platform.c

Abstract:

    These are the entry points of the commands that don't exist
    on every platform.

Author:

    Neil Sandlin (NeilSa) 15-Jan-1996 

Notes:


Revision History:

--*/

#include <precomp.h>
#pragma hdrstop




VOID
es(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    PRINTF("es has been replaced with the 'x' command\n");

}

VOID
eventinfo(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    EventInfop();
#else
    PRINTF("Eventinfo is not implemented on this platform\n");
#endif

}


VOID
pdump(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfDumpp();
#else
    PRINTF("pdump is not implemented on this platform\n");
#endif

}

VOID
pint(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfIntp();
#else
    PRINTF("pint is not implemented on this platform\n");
#endif

}

VOID
pstart(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfStartp();
#else
    PRINTF("pstart is not implemented on this platform\n");
#endif

}

VOID
pstop(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    ProfStopp();
#else
    PRINTF("pstop is not implemented on this platform\n");
#endif

}

VOID
vdmtib(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    VdmTibp();
#else
    PRINTF("VdmTib is not implemented on this platform\n");
#endif

}

VOID
fpu(
    CMD_ARGLIST
    )
{
    CMD_INIT();
#if defined(i386)
    Fpup();
#else
    PRINTF("fpu is not implemented on this platform\n");
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\heap.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop


BOOL    bWalkOnly = FALSE;

ULONG
GetHeapBase(
    VOID
    )
{
    WORD selector;
    SELECTORINFO si;

    if (!ReadMemExpression("ntvdmd!DbgWowhGlobalHeap", &selector, sizeof(selector))) {
        return 0;
    }

    GetInfoFromSelector(selector, PROT_MODE, &si);

    return(si.Base + GetIntelBase());

}



void
GetFileNameFromOwner(
    LPSTR filename,
    LPSTR OwnerName
    )
{
}


VOID
GetHeapOwnerInfo(
    HEAPENTRY *he
    )
{
    BOOL    b;
    NEHEADER owner;
    ULONG base;
    UCHAR len;
    int i;
    ULONG offset;
    WORD wTemp;

    he->SegmentNumber = -1;
    he->OwnerName[0] = 0;
    if (he->gnode.pga_owner == 0) {
        strcpy(he->OwnerName, "free");
        return;
    } else if (he->gnode.pga_owner>=0xFFF8) {
        strcpy(he->OwnerName, "sentinel");
        return;
    }


    base = GetInfoFromSelector(he->gnode.pga_owner, PROT_MODE, NULL)
            + GetIntelBase();

    b = READMEM((LPVOID)base, &owner, sizeof(owner));

    if (b) {
        if (owner.ne_magic == 0x454e) {

            len = ReadByteSafe(base+owner.ne_restab);
            if (len>8) {
                len=8;
            }
            READMEM((LPVOID)(base+owner.ne_restab+1), he->OwnerName, 8);

            he->OwnerName[len] = 0;
            if (!_stricmp(he->OwnerName, "kernel")) {
                strcpy(he->FileName, "krnl386");
            } else {
                strcpy(he->FileName, he->OwnerName);
            }

            offset = owner.ne_segtab;

            for (i=0; i<owner.ne_cseg; i++) {
                wTemp = ReadWordSafe(base+offset+8);    //get handle
                if (wTemp == he->gnode.pga_handle) {
                    he->SegmentNumber = i;
                    break;
                }
                offset += 10;
            }

        }
    }

}

BOOL
CheckGlobalHeap(
    BOOL bVerbose
    )
{
    PGHI32  pghi;
    DWORD   offset, prevoffset;
    DWORD   count, heapcount;
    DWORD   p;
    GNODE32 gnode;
    PBYTE   pFault = NULL;
    BOOL    bError = FALSE;

    pghi = (PGHI32)GetHeapBase();
    prevoffset = offset = (DWORD) ReadWord(&pghi->hi_first);
    heapcount = count = ReadWord(&pghi->hi_count);

    if (bVerbose) {
        PRINTF("Global Heap is at %08X\n", pghi);
    }


    while ((offset != 0) && (count)) {

        if (offset&0x1f) {
            PRINTF("Error! Kernel heap entry(%08X) contains invalid forward link (%08X)\n", prevoffset, offset);
            return FALSE;
        }

        p = (DWORD)pghi + offset;

        if (!ReadGNode32Safe(p, &gnode)) {

            PRINTF("Error! Kernel heap entry(%08X) contains invalid forward link (%08X)\n", prevoffset, offset);
            return FALSE;

        }

        if (count == heapcount) {
            // first entry
            if (offset != gnode.pga_prev) {
                PRINTF("Error! Kernel heap entry (%08X) contains invalid back link (%08X)\n", offset, gnode.pga_prev);
                PRINTF(" expecting (%08X)\n", offset);
                return FALSE;
            }
        } else {
            if (prevoffset != gnode.pga_prev) {
                PRINTF("Error! Kernel heap entry (%08X) contains invalid back link (%08X)\n", offset, gnode.pga_prev);
                PRINTF(" expecting (%08X)\n", prevoffset);
                return FALSE;
            }
        }

        prevoffset = offset;

        count--;
        if (offset == gnode.pga_next) {
            if (!count) {
                if (bVerbose) {
                    PRINTF("%d entries scanned\n", heapcount);
                }
                return TRUE;
            } else {
                PRINTF("Error! Kernel heap count (%d) larger then forward chain (%d)\n", heapcount, heapcount-count);
            }
        }
        offset = gnode.pga_next;
    }

    PRINTF("Error! Kernel heap count (%d) smaller then forward chain\n", heapcount);
    return FALSE;
}


BOOL
FindHeapEntry(
    HEAPENTRY *he,
    UINT FindMethod,
    BOOL bVerbose
    )
{
    PGHI32  pghi;
    DWORD   offset;
    DWORD   MaxEntries, count;
    DWORD   p;
    PBYTE   pFault = NULL;
    BOOL    bError = FALSE;

    pghi = (PGHI32)GetHeapBase();

    //
    // Verify that we are looking at a heap
    //
    offset = (DWORD) ReadWordSafe(&pghi->hi_first);
    p = (DWORD)pghi + offset;
    if (!ReadGNode32Safe(p, &he->gnode)) {
        if (bVerbose) {
            PRINTF("Heap not available\n");
        }
        return FALSE;
    } 
    if (offset != he->gnode.pga_prev) {
        if (bVerbose) {
            PRINTF("Heap not valid\n");
        }
        return FALSE;
    }


    //
    // The caller has requested that we return the next heap
    // entry since the last invocation, or the first entry.
    //

    if (he->CurrentEntry == 0) {

        // get first entry
        offset = (DWORD) ReadWord(&pghi->hi_first);

    } else {
        if (he->CurrentEntry == he->NextEntry) {
            return FALSE;
        }

        // get next entry
        offset = he->NextEntry;

    }

    he->CurrentEntry = offset;

    if ((he->Selector == 0) && (FindMethod != FHE_FIND_MOD_ONLY)) {

        p = (DWORD)pghi + offset;
        if (!ReadGNode32(p, &he->gnode)) {

            return FALSE;

        } 

        he->NextEntry = he->gnode.pga_next;
        GetHeapOwnerInfo(he);
        return TRUE;
    }

    // 
    // If we get here, the caller wants us to scan the heap
    //

    MaxEntries = ReadWord(&pghi->hi_count);
    count = 0;

    while ((offset != 0) && (count <= MaxEntries)) {

        p = (DWORD)pghi + offset;

        if (!ReadGNode32(p, &he->gnode)) {

            return FALSE;

        } else {

            if (FindMethod == FHE_FIND_ANY) {
                WORD sel = he->Selector;

                if (((sel|1)==((WORD)he->gnode.pga_handle|1)) ||
                    ((sel|1)==((WORD)he->gnode.pga_owner|1))  ||
                    (sel==offset))

                {
                    he->NextEntry = he->gnode.pga_next;
                    GetHeapOwnerInfo(he);
                    return TRUE;
                }

            } else if (FindMethod == FHE_FIND_MOD_ONLY) {

                GetHeapOwnerInfo(he);
                if (!_stricmp(he->OwnerName, he->ModuleArg)) {
                    he->NextEntry = he->gnode.pga_next;
                    return TRUE;
                }

            } else {
                if ((he->Selector|1)==((WORD)he->gnode.pga_handle|1)) {
                    he->NextEntry = he->gnode.pga_next;
                    GetHeapOwnerInfo(he);
                    return TRUE;
                }
            }
        }

        count++;
        if (offset == he->gnode.pga_next) {
            break;
        }
        offset = he->gnode.pga_next;
        he->CurrentEntry = offset;
    }

    return FALSE;
}


VOID
chkheap(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    if (CheckGlobalHeap(TRUE)) {
        PRINTF("Heap checks OK\n");
    }

}


//*************************************************************
//  dumpgheap xxx
//   where xxx is the 16-bit protect mode selector of the
//   Kernel global heap info.
//
//*************************************************************


VOID
dgh(
    CMD_ARGLIST
    )
{
    HEAPENTRY    he = {0};
    SELECTORINFO si;
    ULONG TotalAllocated = 0;
    ULONG TotalFree = 0;
    ULONG CountPrinted = 0;

    CMD_INIT();

    if (GetNextToken()) {
        he.Selector = (WORD) EXPRESSION( lpArgumentString );
    }

    PRINTF("Arena   Base     Limit  Hnd  Own  Fl Lk   Module  Type  Resid");
    PRINTF("\n");

    PRINTF("===== ======== ======== ==== ==== == ==  ======== ====  =====");
    PRINTF("\n");

    while (FindHeapEntry(&he, FHE_FIND_ANY, FHE_FIND_VERBOSE)) {

        PRINTF("%.5x", he.CurrentEntry);
        PRINTF(" %.8x", he.gnode.pga_address);
        PRINTF(" %.8X", he.gnode.pga_size);
        PRINTF(" %.4X", he.gnode.pga_handle);
        PRINTF(" %.4X", he.gnode.pga_owner);
        PRINTF(" %.2X", he.gnode.pga_flags);
        PRINTF(" %.2X", he.gnode.pga_count);
        PRINTF("  %-8.8s", he.OwnerName);

        GetInfoFromSelector((WORD)(he.gnode.pga_handle | 1), PROT_MODE, &si);

        PRINTF(" %s", si.bCode ? "Code" : "Data");

        if (he.SegmentNumber != -1) {
            PRINTF("    %d", he.SegmentNumber+1);
        } 
        PRINTF("\n");

        if (!he.gnode.pga_owner) {
            TotalFree += he.gnode.pga_size;
        } else {
            TotalAllocated += he.gnode.pga_size;
        }
        CountPrinted++;
    }

    if (CountPrinted > 1) {
        PRINTF("\n Allocated = %dK, Free = %dK\n", TotalAllocated/1024, TotalFree/1024);
    }
}

VOID
UpdateLockCount(
    int count
    )
{
    HEAPENTRY    he = {0};
    BYTE LockCount;

    if (GetNextToken()) {
        he.Selector = (WORD) EXPRESSION( lpArgumentString );
    } else {
        PRINTF("Please enter a selector or handle\n");
        return;
    }

    if (FindHeapEntry(&he, FHE_FIND_SEL_ONLY, FHE_FIND_VERBOSE)) {

        if (READMEM((LPVOID)(GetHeapBase()+he.CurrentEntry+0x14), &LockCount, 1)) {

            LockCount = (BYTE)((int) LockCount + count);
            WRITEMEM((LPVOID)(GetHeapBase()+he.CurrentEntry+0x14), &LockCount, 1);
            PRINTF("Lock count for %.4X is now %d\n", he.Selector, LockCount);

        } else {

            PRINTF("<can't read memory at that location>\n");

        }

    } else {
        PRINTF("Can't find selector %4X in WOW heap\n", he.Selector);
    }
}


VOID
glock(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    UpdateLockCount(1);
}


VOID
gunlock(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    UpdateLockCount(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\help.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    help.c

Abstract:

    This module dumps out help info for VDMEXTS

Author:

    Neil Sandlin (NeilSa) 15-Jan-1996

Notes:


Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

CHAR szAPIUSAGE[] = "Usage: !vdmexts.APIProfDmp [TblName] [APIspec]\n\n   where: TblName = kernel | user | gdi | keyboard | sound | shell | mmed\n                         (no TblName implies 'all tables')\n\n          APIspec = API # or API name";
CHAR szMSGUSAGE[] = "Usage: !vdmexts.MsgProfDmp [MessageName | MessageNum (decimal)]\n                         (no argument implies 'all messages')";

VOID
helpAPIProfDmp(
    VOID
    )
{
    PRINTF("\n\n%s\n", szAPIUSAGE);
}

VOID
helpMsgProfDmp(
    VOID
    )
{
    PRINTF("\n\n%s\n", szMSGUSAGE);
}


VOID
helpFilter(
    VOID
    )
{
    PRINTF("Usage: filter <option> <arg>\n\n");
    PRINTF(" where <option>=\n");
    PRINTF("<none>         - Dump current state\n");
    PRINTF("*              - Disables logging on all API classes\n");
    PRINTF("Reset          - Filter is reset to default state\n");
    PRINTF("CallId xxxx    - Adds api with given callid to list to be filtered\n");
    PRINTF("Task xxxx      - Filter on a Specific TaskID\n");
    PRINTF("Verbose        - Toggles Verbose Mode On/Off\n");
    PRINTF("Commdlg        - Toggles Filtering of Commdlg Calls On/Off\n");
    PRINTF("GDI            - Toggles Filtering of GDI Calls On/Off\n");
    PRINTF("Kernel         - Toggles Filtering of Kernel Calls On/Off\n");
    PRINTF("Kernel16       - Toggles Filtering of Kernel16 Calls On/Off\n");
    PRINTF("Keyboard       - Toggles Filtering of Keyboard Calls On/Off\n");
    PRINTF("MMedia         - Toggles Filtering of MMedia Calls On/Off\n");
    PRINTF("Sound          - Toggles Filtering of Sound Calls On/Off\n");
    PRINTF("User           - Toggles Filtering of User Calls On/Off\n");
    PRINTF("Winsock        - Toggles Filtering of Winsock Calls On/Off\n");
    PRINTF("\n");
}

VOID
help_denv(
    VOID
    )
{
    PRINTF("Dump environment block for current DOS process or given environment selector\n");
    PRINTF("\n");
    PRINTF("!denv <bPMode> <segEnv>\n");
    PRINTF("\n");
    PRINTF("Examples:\n");
    PRINTF("!denv             - Dumps environment for current DOS process\n");
    PRINTF("!denv 0 145d      - Dumps environment at &145d:0 (145d from PDB_environ of DOS process)\n");
    PRINTF("!denv 1 16b7      - Dumps environment at #16b7:0 (16b7 from !dt -v segEnvironment)\n");
    PRINTF("\n");
}

VOID
helpgdih16(
    VOID
    )
{
    PRINTF("Dumps info for 16-bit GDI handles\n");
    PRINTF("\n");
    PRINTF("!gdih16 [-v] <h16>\n");
    PRINTF("\n");
    PRINTF("Examples:\n");
    PRINTF("!gdih16 23        - Dumps the gdih32 associated with h16\n");
    PRINTF("!gdih16 -v 23     - verbose mode includes mapping table info\n");
    PRINTF("\n");
}

VOID
helpgdih32(
    VOID
    )
{
    PRINTF("Dumps info for 32-bit GDI handles\n");
    PRINTF("\n");
    PRINTF("!gdih32 [-v] <h32>\n");
    PRINTF("\n");
    PRINTF("Examples:\n");
    PRINTF("!gdih32 43502110    - Dumps the gdih16 associated with h32\n");
    PRINTF("!gdih32 -v 43502110 - verbose mode includes mapping table info\n");
    PRINTF("\n");
}

VOID
help(
    CMD_ARGLIST
) {
    CMD_INIT();

    if (GetNextToken()) {
        if (_strnicmp(lpArgumentString, "filter", 6) == 0) {
            helpFilter();
        } else if (_strnicmp(lpArgumentString, "apiprofdmp", 10) == 0) {
            helpAPIProfDmp();
        } else if (_strnicmp(lpArgumentString, "msgprofdmp", 10) == 0) {
            helpMsgProfDmp();
        } else if (_strnicmp(lpArgumentString, "denv", 4) == 0) {
            help_denv();
        } else if (_strnicmp(lpArgumentString, "hgdi16", 6) == 0) {
            helpgdih16();
        } else if (_strnicmp(lpArgumentString, "hgdi32", 6) == 0) {
            helpgdih32();
	    } else {
            PRINTF("No specific help information available for '%s'\n", lpArgumentString);
        }
        return;
    }
    if (!EXPRESSION("ntvdm!Ldt")) {
        PRINTF("\nWARNING: Symbols for NTVDM are not available.\n\n");
    }
    if (!EXPRESSION("wow32!gptdTaskHead")) {
        PRINTF("\nWOW commands are not currently available.\n\n");
    } else if (!EXPRESSION("wow32!iLogLevel")) {
        PRINTF("\nWOW32 is the free version: Some commands will be unavailable.\n\n");
    }

    PRINTF("------------- VDMEXTS Debug Extension help:--------------\n\n");
    PRINTF("help [cmd]             - Displays this list or gives details on command\n");
    PRINTF("ApiProfClr             - Clears the api profiling table\n");
    PRINTF("ApiProfDmp [options]   - Dumps the api profiling table\n");
    PRINTF("at 0xXXXX              - shows name associated with hex atom #\n");
    PRINTF("bp <addr>              - Sets a vdm breakpoint\n");
    PRINTF("bd/be <n>              - Disables/enables vdm breakpoint 'n'\n");
    PRINTF("bl                     - Lists vdm breakpoints\n");
    PRINTF("chkheap                - Checks WOW kernel's global heap\n");
    PRINTF("cia                    - Dump cursor/icon alias list\n");
    PRINTF("d<b|w|d> <addr> [len]  - Dump vdm memory\n");
    PRINTF("ddemem                 - Dump dde memory thunks\n");
    PRINTF("ddte <addr>            - Dump dispatch table entry pointed to by <addr>\n");
    PRINTF("denv <bProt> <selEnv>  - Dump environment for current task or given selector/segment\n");
    PRINTF("df [vector]            - Dump protect mode fault handler address\n");
    PRINTF("dfh [fh [pdb]]         - Dump DOS file handles for current or given PDB\n");
    PRINTF("dg <sel>               - Dump info on a selector\n");
    PRINTF("ddh [seg]              - Dump DOS heap chain starting at <seg>:0000\n");
    PRINTF("dgh [sel|ownersel]     - Dump WOW kernel's global heap\n");
    PRINTF("dhdib [@<address>]     - Dump dib.drv support structures (DIBINFO)\n");
    PRINTF("di [vector]            - Dump protect mode interrupt handler address\n");
    PRINTF("dma                    - Dump virtual DMA state\n");
    PRINTF("dpd                    - Dump DPMI DOS memory allocations\n");
    PRINTF("dpx                    - Dump DPMI extended memory allocations\n");
    PRINTF("dsft [sft]             - Dump all or specified DOS system file tables\n");
    PRINTF("dt [-v] <addr>         - Dump WOW Task Info\n");
    PRINTF("dwp <addr>             - Dump WOWPORT structure pointed to by <addr>\n");
    PRINTF("e<b|w|d> <addr> <data> - Edit vdm memory\n");
    PRINTF("filter [options]       - Manipulate logging filter\n");
    PRINTF("fs <text to find>      - Find text in 16:16 memory (case insensitive)\n");
    PRINTF("glock <sel>            - Increments the lock count on a moveable segment\n");
    PRINTF("gmem                   - Dumps Global/heap memory alloc'd by wow32\n");
    PRINTF("gunlock <sel>          - Decrements the lock count on a moveable segment\n");
    PRINTF("hgdi16 [-v] <h16>      - Returns 32-bit GDI handle for <h16>\n");
    PRINTF("hgdi32 [-v] <h32>      - Returns 16-bit GDI handle for <h32>\n");
    PRINTF("ica                    - Dump Interrupt Controller state\n");
    PRINTF("k                      - Stack trace\n");
    PRINTF("kb                     - Stack trace with symbols\n");
    PRINTF("LastLog                - Dumps Last Logged WOW APIs from Circular Buffer\n");
    PRINTF("lg [#num] [count]      - Dumps NTVDM history log\n");
    PRINTF("lgr [#num] [count]     - Dumps NTVDM history log (with regs)\n");
    PRINTF("lgt [1|2|3]            - Sets NTVDM history log timer resolution\n");
    PRINTF("lm <sel|modname>       - List loaded modules\n");
    PRINTF("ln [addr]              - Determine near symbols\n");
    PRINTF("LogFile [path]         - Create/close toggle for iloglevel capture to file\n");
    PRINTF("                         (path defaults to c:\\ilog.log)\n");
    PRINTF("MsgProfClr             - Clears the msg profiling table\n");
    PRINTF("MsgProfDmp [options]   - Dumps the msg profiling table\n");
    PRINTF("ntsd                   - Gets an NTSD prompt from the VDM prompt\n");
    PRINTF("r                      - Dump registers\n");
    PRINTF("rmcb                   - Dumps dpmi real mode callbacks\n");
    PRINTF("SetLogLevel xx         - Sets the WOW Logging Level\n");
    PRINTF("StepTrace              - Toggles Single Step Tracing On/Off\n");
    PRINTF("sx                     - Displays debugging options\n");
    PRINTF("sx<d|e> <flag>         - Disables/enables debugging options\n");
    PRINTF("u [addr] [len]         - Unassemble vdm code with symbols\n");
    PRINTF("wc <hwnd16>            - Dumps the window class structure of <hwnd16>\n");
    PRINTF("ww <hwnd16>            - Dumps the window structure of <hwnd16>\n");
    PRINTF("x <symbol>             - Get symbol's value\n");
#ifdef i386
    PRINTF("\n-------------- i386 specific commands\n");
    PRINTF("fpu                    - Dump 487 state\n");
    PRINTF("pdump                  - Dumps profile info to file \\profile.out\n");
    PRINTF("pint                   - Sets the profile interval\n");
    PRINTF("pstart                 - Causes profiling to start\n");
    PRINTF("pstop                  - Causes profiling to stop\n");
    PRINTF("vdmtib [addr]          - Dumps the register context in the vdmtib\n");
#endif
    PRINTF("\n\n");
    PRINTF("    where [options] can be displayed with 'help <cmd>'\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\stack.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Bob Day      (bobday) 29-Feb-1992 Grabbed standard header

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts

--*/

#include <precomp.h>
#pragma hdrstop

ULONG IntelBase;

void dump_params(
    ULONG                   params,
    char                    convention,
    int                     param_words
) {
    WORD                    word;
    int                     cnt;

    if ( param_words == 0 ) {
        param_words = 10;
    }
    PRINTF("(");
    cnt = 0;
    while ( cnt != param_words ) {
        if ( convention == 'c' ) {
            word = ReadWord(params+cnt);
        } else {
            word = ReadWord(params+(param_words-cnt));
        }
        if ( cnt == param_words - 1 ) {
            PRINTF("%04x",word);
        } else {
            PRINTF("%04x,",word);
        }
        cnt+=2;
    }
    PRINTF(")");
}

int look_for_near(
    ULONG           pbp,
    WORD            cs,
    WORD            ss,
    WORD            bp,
    int             framed,
    ULONG           csBase,
    int             mode,
    BOOL            fUseSymbols,
    BOOL            fParams
) {
    WORD            ip;
    ULONG           ra;
    char            call_type;
    char            frame_type;
    char            convention;
    int             param_words;
    signed short    dest;
    unsigned char   opcode;
    unsigned char   mod;
    unsigned char   type;
    unsigned char   rm;
    WORD            dest_ip;
    char            symbol[1000];
    BOOL            fOk;
    BOOL            fInst;
    BOOL            b;
    LONG            dist;
    BOOL            fDest;

    fOk = TRUE;
    fInst = FALSE;
    fDest = FALSE;

    param_words = 0;
    if ( framed ) {
        frame_type = 'B';
    } else {
        frame_type = 'C';
    }
    ip = ReadWord(pbp+2);
    ra = csBase + (ULONG)ip;

    do {
        opcode = ReadByteSafe(ra - 2);
        if ( opcode == CALL_NEAR_INDIRECT ) {
            if ( ReadByteSafe(ra - 3) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            opcode = ReadByteSafe(ra - 1);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_NEAR_TYPE ) {
                if ( mod == MOD0 && rm != RM6 ) {
                    fInst = TRUE;
                    break;
                }
                if ( mod == MOD3 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        opcode = ReadByteSafe(ra - 3);
        if ( opcode == CALL_NEAR_RELATIVE ) {
            if ( ReadByteSafe(ra - 4) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            dest = ReadWordSafe( ra - 2 );
            dest_ip = ip+dest;
            fInst = TRUE;
            fDest = TRUE;
            break;
        }
        if ( opcode == CALL_NEAR_INDIRECT ) {
            if ( ReadByteSafe(ra - 4) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            opcode = ReadByteSafe(ra - 2);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_NEAR_TYPE
                 && mod == MOD1 ) {
                fInst = TRUE;
                break;
            }
        }
        opcode = ReadByteSafe(ra - 4);
        if ( opcode == CALL_NEAR_INDIRECT ) {
            if ( ReadByteSafe(ra - 5) == PUSH_CS ) {
                call_type = 'f';
            } else {
                call_type = 'N';
            }
            opcode = ReadByteSafe(ra - 3);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_NEAR_TYPE ) {
                if ( mod == MOD0 && rm == RM6 ) {
                    fInst = TRUE;
                    break;
                }
                if ( mod == MOD2 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        fOk = FALSE;
    } while ( FALSE );

    if ( fOk ) {
        if ( fUseSymbols ) {
            b = FindSymbol( cs, (LONG)ip, symbol, &dist, BEFORE, mode );
        } else {
            b = FALSE;
        }
        b = FALSE;

        if ( b ) {
            if ( dist == 0 ) {
                PRINTF("%04X:%04X %s %c%c", ss, bp, symbol, call_type, frame_type );
            } else {
                PRINTF("%04X:%04X %s+0x%lx %c%c", ss, bp, symbol, dist, call_type, frame_type );
            }
        } else {
            PRINTF("%04X:%04X %04X:%04X %c%c", ss, bp, cs, ip, call_type, frame_type );
        }
        if ( fInst ) {
            if ( ReadWordSafe(ra) == ADD_SP ) {
                convention = 'c';
                param_words = ReadByteSafe( ra+2 );
            } else {
                convention = 'p';
            }
            if ( fUseSymbols && fDest ) {
                b = FindSymbol( cs, (LONG)dest_ip, symbol, &dist, BEFORE, mode );
            } else {
                b = FALSE;
            }
            if ( b ) {
                if ( dist == 0 ) {
                    PRINTF(" %ccall near %s", convention, symbol );
                } else {
                    PRINTF(" %ccall near %s+0x%lx", convention, symbol, dist );
                }
            } else {
                if ( fDest ) {
                    PRINTF(" %ccall near %04X", convention, dest_ip );
                } else {
                    PRINTF(" %ccall near [Indirect]", convention );
                }
            }
            if ( fParams ) {
                dump_params( pbp+4, convention, param_words );
            }
        }
        PRINTF("\n");
        return( 1 );
    }

    return( 0 );
}

int look_for_far(
    ULONG           pbp,
    WORD            *cs,
    WORD            ss,
    WORD            bp,
    int             framed,
    ULONG           *csBase,
    int             mode,
    BOOL            fUseSymbols,
    BOOL            fParams
) {
    WORD            ip;
    WORD            new_cs;
    ULONG           new_csBase;
    ULONG           ra;
    char            frame_type;
    char            convention;
    int             param_words;
    WORD            dest_cs;
    WORD            dest_ip;
    unsigned char   opcode;
    unsigned char   mod;
    unsigned char   type;
    unsigned char   rm;
    char            symbol[1000];
    BOOL            fOk;
    BOOL            fInst;
    BOOL            b;
    LONG            dist;
    BOOL            fDest;
    int             iMeth;
    WORD            low_this;
    WORD            high_this;

    fOk = TRUE;
    fInst = FALSE;
    fDest = FALSE;
    iMeth = -1;

    param_words = 0;
    if ( framed ) {
        frame_type = 'B';
    } else {
        frame_type = 'C';
    }
    ip = ReadWord(pbp+2);
    new_cs = ReadWord(pbp+4);
    new_csBase = GetInfoFromSelector( new_cs, mode, NULL ) + IntelBase;
    if ( new_csBase == -1 ) {
        return( 0 );
    }
    ra = new_csBase + (ULONG)ip;

    do {
        opcode = ReadByteSafe(ra - 2);
        if ( opcode == CALL_FAR_INDIRECT ) {
            opcode = ReadByte(ra - 1);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_FAR_TYPE ) {
                if ( mod == MOD0 && rm != RM6 ) {
                    fInst = TRUE;
                    iMeth = 0;
                    break;
                }
                if ( mod == MOD3 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        opcode = ReadByteSafe(ra - 3);
        if ( opcode == CALL_FAR_INDIRECT ) {
            opcode = ReadByteSafe(ra - 2);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_FAR_TYPE
                 && mod == MOD1 ) {
                fInst = TRUE;
                iMeth = ReadByteSafe(ra - 1);
                break;
            }
        }
        opcode = ReadByteSafe(ra - 4);
        if ( opcode == CALL_FAR_INDIRECT ) {
            opcode = ReadByteSafe(ra - 3);
            mod  = opcode & MOD_BITS;
            type = opcode & TYPE_BITS;
            rm   = opcode & RM_BITS;
            if ( type == INDIRECT_FAR_TYPE ) {
                if ( mod == MOD0 && rm == RM6 ) {
                    fInst = TRUE;
                    break;
                }
                if ( mod == MOD2 ) {
                    fInst = TRUE;
                    break;
                }
            }
        }
        opcode = ReadByteSafe(ra - 5);
        if ( opcode == CALL_FAR_ABSOLUTE ) {
            dest_ip = ReadWordSafe( ra - 4 );
            dest_cs = ReadWordSafe( ra - 2 );
            fInst = TRUE;
            fDest = TRUE;
            break;
        }
        fOk = FALSE;
    } while ( FALSE );

    if ( fOk ) {
        if ( fUseSymbols ) {
            b = FindSymbol( new_cs, (LONG)ip, symbol, &dist, BEFORE, mode );
        } else {
            b = FALSE;
        }
        b = FALSE;

        if ( b ) {
            if ( dist == 0 ) {
                PRINTF("%04X:%04X %s F%c", ss, bp, symbol, frame_type );
            } else {
                PRINTF("%04X:%04X %s+0x%lx F%c", ss, bp, symbol, dist, frame_type );
            }
        } else {
            PRINTF("%04X:%04X %04X:%04X F%c", ss, bp, new_cs, ip, frame_type );
        }
        if ( fInst ) {
            if ( ReadWordSafe(ra) == ADD_SP ) {
                convention = 'c';
                param_words = ReadByteSafe( ra+2 );
            } else {
                convention = 'p';
            }
            if ( fUseSymbols && fDest ) {
                b = FindSymbol( dest_cs, (LONG)dest_ip, symbol, &dist, BEFORE, mode );
            } else {
                b = FALSE;
            }
            if ( b ) {
                if ( dist == 0 ) {
                    PRINTF(" %ccall far %s", convention, symbol );
                } else {
                    PRINTF(" %ccall far %s + 0x%lx", convention, symbol, dist );
                }
            } else {
                if ( fDest ) {
                    PRINTF(" %ccall far %04X:%04X", convention, dest_cs, dest_ip );
                } else {
                    ULONG   thisBase;
                    ULONG   pvtbl;
                    ULONG   vtblBase;
                    ULONG   pfn;
                    WORD    low_vtbl;
                    WORD    high_vtbl;
                    WORD    low_fn;
                    WORD    high_fn;

                    if ( iMeth != -1 ) {
                        low_this = ReadWord(pbp+6);
                        high_this = ReadWord(pbp+8);

                        if ( low_this == 0 && high_this == 0 ) {
                            low_fn = 0;
                            high_fn = 0;
                            strcpy(symbol,"");
                        } else {
                            thisBase = GetInfoFromSelector( high_this, mode, NULL ) + IntelBase;
                            pvtbl = thisBase + (ULONG)low_this;

                            low_vtbl = ReadWord(pvtbl);
                            high_vtbl = ReadWord(pvtbl+2);

                            vtblBase = GetInfoFromSelector( high_vtbl, mode, NULL ) + IntelBase;
                            pfn = vtblBase + (ULONG)low_vtbl + iMeth;

                            low_fn = ReadWord(pfn);
                            high_fn = ReadWord(pfn+2);

                            b = FindSymbol( high_fn, (LONG)low_fn, symbol, &dist, BEFORE, mode );
                            if ( !b ) {
                                wsprintf(symbol,"%04X:%04X", high_fn, low_fn );
                            }
                        }
                    }
                    switch( iMeth ) {
                        default:
                        case -1:
                            if ( iMeth != -1 && (iMeth & 0x3) == 0 ) {
                                PRINTF(" %ccall far [Ind-%04X:%04x Method %d] %s", convention, high_this, low_this, iMeth/4, symbol );
                            } else {
                                PRINTF(" %ccall far [Indirect]", convention );
                            }
                            break;
                        case 0:
                            PRINTF(" %ccall far [Ind-%04X:%04X Method 0 - QI?] %s", convention, high_this, low_this, symbol);
                            break;
                        case 4:
                            PRINTF(" %ccall far [Ind-%04X:%04X Method 1 - AddRef?] %s", convention, high_this, low_this, symbol);
                            break;
                        case 8:
                            PRINTF(" %ccall far [Ind-%04X:%04X Method 2 - Release?] %s", convention, high_this, low_this, symbol);
                            break;
                    }
                }
            }
            if ( fParams ) {
                dump_params( pbp+6, convention, param_words );
            }
        }
        PRINTF("\n");
        *cs = new_cs;
        *csBase = new_csBase;
        return( 1 );
    }
    return( 0 );
}

int scan_for_frameless(
    WORD        ss,
    WORD        sp,
    WORD        next_bp,
    WORD        *cs,
    ULONG       ssBase,
    ULONG       *csBase,
    int         limit,
    int         mode,
    BOOL        fUseSymbols,
    BOOL        fParams
) {
    ULONG       pbp;
    int         result;
    int         cnt;

    cnt = 1000;
    sp -= 2;
    while ( limit ) {
        sp += 2;
        --cnt;
        if ( sp == next_bp || cnt == 0 ) {
            break;
        }

        pbp = ssBase + (ULONG)sp;

        result = look_for_near( pbp, *cs, ss, sp, 0, *csBase,
                                mode, fUseSymbols, fParams );
        if ( result ) {
            --limit;
            continue;
        }
        /*
        ** Check for far calls
        */
        result = look_for_far( pbp, cs, ss, sp, 0, csBase,
                               mode, fUseSymbols, fParams );
        if ( result ) {
            --limit;
            continue;
        }
    }

    return( 0 );
}

void stack_trace(
    WORD        ss,
    ULONG       ssBase,
    WORD        sp,
    WORD        bp,
    WORD        cs,
    ULONG       csBase,
    int         limit,
    int         mode,
    BOOL        fUseSymbols,
    BOOL        fGuessFrameless,
    BOOL        fParams
) {
    WORD        next_bp;
    ULONG       pbp;
    int         far_only;
    int         result;
    WORD        save_sp;
    WORD        save_bp;
    WORD        save_cs;
    ULONG       save_csBase;
    int         save_limit;

    save_sp = sp;
    save_bp = bp;
    save_cs = cs;
    save_csBase = csBase;
    save_limit = limit;

    PRINTF("[-Stack-] [-Retrn-] XY (X=Near/Far/far,Y=Call chain/BP Chain)\n");

    next_bp = bp;

    while ( limit ) {
        bp = next_bp;
        if ( bp == 0 ) {
            break;
        }
        if ( bp & 0x01 ) {
            far_only = 1;
            bp &= 0xFFFE;
        } else {
            far_only = 0;
        }
        pbp = ssBase + (ULONG)bp;
        next_bp = ReadWord(pbp);

        if ( fGuessFrameless ) {
            limit -= scan_for_frameless( ss, sp, bp, &cs,
                                         ssBase, &csBase, limit, mode, fUseSymbols,
                                         fParams );
        }

        if ( limit ) {
            /*
            ** Check for near calls
            */
            if ( far_only == 0 ) {
                result = look_for_near( pbp, cs, ss, bp, 1, csBase,
                                        mode, fUseSymbols, fParams );
                if ( result ) {
                    sp = bp + 4;
                    --limit;
                    continue;
                }
            }
            /*
            ** Check for far calls
            */
            result = look_for_far( pbp, &cs, ss, bp, 1, &csBase,
                                   mode, fUseSymbols, fParams );
            if ( result ) {
                sp = bp + 6;
                --limit;
                continue;
            }
            PRINTF("Could not find call\n");
            break;
        }
    }
    if ( fGuessFrameless ) {
        if ( limit ) {
            limit -= scan_for_frameless( 
                        ss, sp, 0, &cs, ssBase, &csBase, limit, mode,
                        fUseSymbols, fParams );
        }
    }
}

VOID
WalkStack(
) {
    VDMCONTEXT              ThreadContext;
    WORD                    bp;
    WORD                    sp;
    WORD                    ss;
    WORD                    cs;
    WORD                    ip;

    ULONG                   csBase;
    ULONG                   ssBase;
    int                     mode;
    int                     lines;

    mode = GetContext( &ThreadContext );
    IntelBase = GetIntelBase();

    sp = (WORD)ThreadContext.Esp;
    bp = (WORD)ThreadContext.Ebp;
    ss = (WORD)ThreadContext.SegSs;
    ip = (WORD)ThreadContext.Eip;
    cs = (WORD)ThreadContext.SegCs;

    csBase = GetInfoFromSelector( cs, mode, NULL ) + IntelBase;
    ssBase = GetInfoFromSelector( ss, mode, NULL ) + IntelBase;

    lines = 10;
    if (GetNextToken()) {
        lines = EXPRESSION( lpArgumentString );
    }

    stack_trace( ss,
                 ssBase,
                 sp,
                 bp,
                 cs,
                 csBase,
                 lines,
                 mode,
                 FALSE,
                 FALSE,
                 FALSE );
}

VOID
WalkStackVerbose(
) {
    VDMCONTEXT              ThreadContext;
    WORD                    bp;
    WORD                    sp;
    WORD                    ss;
    WORD                    cs;
    WORD                    ip;

    ULONG                   csBase;
    ULONG                   ssBase;
    int                     mode;
    int                     lines;

    mode = GetContext( &ThreadContext );
    IntelBase = GetIntelBase();

    sp = (WORD)ThreadContext.Esp;
    bp = (WORD)ThreadContext.Ebp;
    ss = (WORD)ThreadContext.SegSs;
    ip = (WORD)ThreadContext.Eip;
    cs = (WORD)ThreadContext.SegCs;

    csBase = GetInfoFromSelector( cs, mode, NULL ) + IntelBase;
    ssBase = GetInfoFromSelector( ss, mode, NULL ) + IntelBase;

    lines = 10;
    if (GetNextToken()) {
        lines = EXPRESSION( lpArgumentString );
    }

    stack_trace( ss,
                 ssBase,
                 sp,
                 bp,
                 cs,
                 csBase,
                 lines,
                 mode,
                 TRUE,
                 FALSE,
                 FALSE );
}

VOID
k(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    WalkStack();

}


VOID
kb(
    CMD_ARGLIST
    )
{
    CMD_INIT();
    WalkStackVerbose();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\mvdm\vdmexts\reflect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    reflect.c

Abstract:

    This module contains extensions having to do with event and exception
    reflection.

Author:

    Dave Hastings (daveh) 20-Apr-1992

Revision History:

    Neil Sandlin (NeilSa) 15-Jan-1996 Merged with vdmexts
    Neil Sandlin (NeilSa) 15-Jul-1996 Added 'SX' commands

--*/

#include <precomp.h>
#pragma hdrstop
#include <dbgsvc.h>

VOID
ClearVdmDbgTraceFlags(
    VOID
    )
{
    ULONG lpAddress;
    ULONG ulTF;

    lpAddress = (*GetExpression)("ntvdmd!VdmDbgTraceFlags");

    if (!lpAddress) {
        lpAddress = (*GetExpression)("ntvdm!InitialVdmDbgFlags");
    }

    if (!READMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG))) {
        PRINTF("Error reading memory\n");
        return;
    }

    ulTF = 0;

    WRITEMEM((PVOID)lpAddress, &ulTF, sizeof(ULONG));

}

VOID
dr(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    PRINTF("\nThe DR command is obselete and has been removed. The debugger now\n");
    PRINTF("breaks on ntvdm debug exceptions by default. If you are debugging\n");
    PRINTF("an unusual scenario where you need the debugger to reflect (ignore)\n");
    PRINTF("these exceptions (like in debugging a 16-bit debugger), use the\n");
    PRINTF("vdmexts.sxd command.\n\n");
}

VOID
er(
    CMD_ARGLIST
    )
{
    CMD_INIT();

    PRINTF("\nThe ER command is obselete and has been removed. By default,\n");
    PRINTF("the debugger will break on 'second chance' GP faults, which is\n");
    PRINTF("typically the desired behavior. If you are debugging an unusual\n");
    PRINTF("scenario that requires you to examine FIRST CHANCE faults, use\n");
    PRINTF("the vdmexts.sxe command.\n\n");
    PRINTF("If you are not sure if you need to turn this notification on, then\n");
    PRINTF("you probably don't need it.\n\n");

}


VOID
DoVdmtibFlag(
    ULONG Flag,
    BOOL bSet,
    LPSTR pTitle
    )
/*++

Routine Description:

    This routine toggles the exception reflection bit in the vdmtib, and
    reports the current state

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL Status;
    PVOID Address;
    ULONG Flags;


    Address = (PVOID) (FIXED_NTVDMSTATE_LINEAR + GetIntelBase());

    //
    // Read the current value of the flags
    //

    Status = READMEM(Address, &Flags, sizeof(ULONG));

    if (!Status)  {

        (ULONG)Address = (*GetExpression)("ntvdm!InitialVdmTibFlags");

        Status = READMEM((PVOID)Address, &Flags, sizeof(ULONG));

        if (!Status) {
            GetLastError();
            (*Print)("Could not get InitialTibflags\n");
            return;
        }
    }

    //
    // Toggle exception bit
    //
    if (bSet) {
        if (!(Flags & Flag)) {
            PRINTF("%s enabled\n", pTitle);
        }
        Flags |= Flag;
    } else {
        if (Flags & Flag) {
            PRINTF("%s disabled\n", pTitle);
        }
        Flags &= ~Flag;
    }

    Status = WRITEMEM(Address, &Flags, sizeof(ULONG));

    if (!Status) {
        GetLastError();
        (*Print)("Could not get set Flags\n");
        return;
    }
}


VOID
EnableDebuggerBreakpoints(
    VOID
    )
{

    DoVdmtibFlag(VDM_BREAK_DEBUGGER, TRUE, "Debug faults");
}

ULONG
TraceFlagFromName(
    LPSTR lpName
    )
{
    ULONG ulRet = 0;

    if (_strnicmp(lpName, "cw", 2) == 0) {
        ulRet = VDMDBG_BREAK_WOWTASK;
    } else if (_strnicmp(lpName, "cd", 2) == 0) {
        ulRet = VDMDBG_BREAK_DOSTASK;
    } else if (_strnicmp(lpName, "ld", 2) == 0) {
        ulRet = VDMDBG_BREAK_LOADDLL;
    }