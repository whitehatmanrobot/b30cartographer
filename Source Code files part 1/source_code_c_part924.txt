DisplayName(bstrName);
    IfFailGo(hr);

	hr = piScopeItemDef->put_AutoCreate(VARIANT_TRUE);
	IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piAutoScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewOtherNode(IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewOtherNode
(
    IScopeItemDef *piScopeItemDef
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    bool              bGood = false;
    IScopeItemDefs   *piOtherScopeItemDefs = NULL;
    CSelectionHolder *pScopeItemDefClone = NULL;
    BSTR              bstrName = NULL;

    hr = GetResourceString(IDS_NODE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_OtherNodes(&piOtherScopeItemDefs);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++m_iNextNodeNumber);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pScopeItemDefClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piScopeItemDef->put_Name(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_Key(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_NodeTypeName(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_DisplayName(bstrName);
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piOtherScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsAutoCreateChild(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::IsAutoCreateChild(CSelectionHolder *pSelection)
{
	HRESULT				 hr = S_FALSE;
	CSelectionHolder	*pParent = NULL;

	while (SEL_SNAPIN_ROOT != pSelection->m_st && pParent != m_pRootNode)
	{
		hr = m_pTreeView->GetParent(pSelection, &pParent);
		IfFailGo(hr);

		if (pParent == m_pAutoCreateRoot)
		{
			hr = S_OK;
			goto Error;
		}

		pSelection = pParent;
		pParent = NULL;
	}

	hr = S_FALSE;

Error:
	RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewChildNode(IScopeItemDef *piScopeItemDef, IScopeItemDefs *piScopeItemDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewChildNode
(
    IScopeItemDef   *piScopeItemDef,
    IScopeItemDefs  *piScopeItemDefs
)
{
    HRESULT           hr = S_OK;
    int               iResult = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    bool              bGood = false;
    CSelectionHolder *pScopeItemDefClone = NULL;
    BSTR              bstrName = NULL;

    hr = GetResourceString(IDS_NODE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    do {
        iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++m_iNextNodeNumber);
        if (iResult == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }

		hr = m_pTreeView->FindLabelInTree(szName, &pScopeItemDefClone);
		IfFailGo(hr);

        if (S_FALSE == hr)
        {
			hr = BSTRFromANSI(szName, &bstrName);
			IfFailGo(hr);

            bGood = true;
            break;
        }

        FREESTRING(bstrName);
    } while (false == bGood);

    hr = piScopeItemDef->put_Name(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_Key(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_NodeTypeName(bstrName);
    IfFailGo(hr);

    hr = piScopeItemDef->put_DisplayName(bstrName);
    IfFailGo(hr);

	hr = IsAutoCreateChild(m_pCurrentSelection);
	IfFailGo(hr);

	if (S_OK == hr)
	{
		hr = piScopeItemDef->put_AutoCreate(VARIANT_TRUE);
		IfFailGo(hr);
	}

Error:
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertNodeInTree(CSelectionHolder *pNode, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertNodeInTree
(
    CSelectionHolder *pNode,
    CSelectionHolder *pParent
)
{
    HRESULT              hr = S_OK;
    BSTR                 bstrName = NULL;
    TCHAR               *pszName = NULL;
    CSelectionHolder    *pChildren = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pViews = NULL;
    IViewDefs           *piViewDefs = NULL;

    hr = pNode->m_piObject.m_piScopeItemDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kScopeItemIcon, pNode);
    IfFailGo(hr);

    pViews = New CSelectionHolder(SEL_NODES_ANY_VIEWS, pNode->m_piObject.m_piScopeItemDef);
    if (NULL == pViews)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pNode->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = RegisterViewCollections(pViews, piViewDefs);
    IfFailGo(hr);

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pNode, kClosedFolderIcon, pViews);
    IfFailGo(hr);

    hr = pNode->m_piObject.m_piScopeItemDef->get_Children(&piScopeItemDefs);
    IfFailGo(hr);

    pChildren = New CSelectionHolder(SEL_NODES_ANY_CHILDREN, piScopeItemDefs);
    if (NULL == pChildren)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pChildren->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_CHILDREN, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pNode, kClosedFolderIcon, pChildren);
    IfFailGo(hr);

Error:
    RELEASE(piViewDefs);
    RELEASE(piScopeItemDefs);
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetScopeItemCollection(CSelectionHolder *pScopeItem, IScopeItemDefs **ppiScopeItemDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetScopeItemCollection
(
    CSelectionHolder *pScopeItem,
    IScopeItemDefs  **ppiScopeItemDefs
)
{
    HRESULT              hr = S_OK;
    IScopeItemDefs      *piScopeItemDefs = NULL;

    switch (pScopeItem->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_AUTO_CREATE_ROOT:
        hr = m_piSnapInDesignerDef->get_AutoCreateNodes(ppiScopeItemDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_OTHER:
        hr = m_piSnapInDesignerDef->get_OtherNodes(ppiScopeItemDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = pScopeItem->m_piObject.m_piScopeItemDef->get_Children(ppiScopeItemDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_CHILDREN:
        *ppiScopeItemDefs = pScopeItem->m_piObject.m_piScopeItemDefs;
        (*ppiScopeItemDefs)->AddRef();
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "DeleteScopeItem: Cannot determine appropriate parent");
        hr = S_FALSE;
        break;
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\selhold.cpp ===
//=--------------------------------------------------------------------------------------
// SelHold.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSelectionHolder implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "SelHold.h"

// for ASSERT and FAIL
//
SZTHISFILE


CSelectionHolder::CSelectionHolder() : m_st(SEL_NONE), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    m_piObject.m_lDummy = 0;
}


CSelectionHolder::CSelectionHolder(SelectionType st) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
}


CSelectionHolder::CSelectionHolder(SelectionType st, ISnapInDef *piSnapInDef) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piSnapInDef != NULL, "piSnapInDef is NULL");

    m_piObject.m_piSnapInDef = piSnapInDef;
    m_piObject.m_piSnapInDef->AddRef();

}


CSelectionHolder::CSelectionHolder(SelectionType st, IExtensionDefs *piExtensionDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piExtensionDefs != NULL, "piExtensionDefs is NULL");

    m_piObject.m_piExtensionDefs = piExtensionDefs;
    if (m_piObject.m_piExtensionDefs != NULL)
        m_piObject.m_piExtensionDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IExtendedSnapIn *piExtendedSnapIn) : m_st(SEL_EEXTENSIONS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piExtendedSnapIn != NULL, "piExtendedSnapIn is NULL");

    m_piObject.m_piExtendedSnapIn = piExtendedSnapIn;
    if (m_piObject.m_piExtendedSnapIn != NULL)
        m_piObject.m_piExtendedSnapIn->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IExtendedSnapIn *piExtendedSnapIn) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(piExtendedSnapIn != NULL, "piExtendedSnapIn is NULL");

    m_piObject.m_piExtendedSnapIn = piExtendedSnapIn;
    if (m_piObject.m_piExtendedSnapIn != NULL)
        m_piObject.m_piExtendedSnapIn->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IScopeItemDefs *pScopeItemDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pScopeItemDefs != NULL, "pScopeItemDefs is NULL");

    m_piObject.m_piScopeItemDefs = pScopeItemDefs;
    if (m_piObject.m_piScopeItemDefs != NULL)
        m_piObject.m_piScopeItemDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IScopeItemDef *pScopeItemDef) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pScopeItemDef != NULL, "pScopeItemDef is NULL");

    m_piObject.m_piScopeItemDef = pScopeItemDef;
    if (m_piObject.m_piScopeItemDef != NULL)
        m_piObject.m_piScopeItemDef->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IListViewDefs *pListViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pListViewDefs != NULL, "pListViewDefs is NULL");

    m_piObject.m_piListViewDefs = pListViewDefs;
    if (m_piObject.m_piListViewDefs != NULL)
        m_piObject.m_piListViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IListViewDef *pListViewDef) : m_st(SEL_VIEWS_LIST_VIEWS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pListViewDef != NULL, "pListViewDef is NULL");

    m_piObject.m_piListViewDef = pListViewDef;
    if (m_piObject.m_piListViewDef != NULL)
        m_piObject.m_piListViewDef->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IURLViewDefs *pURLViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pURLViewDefs != NULL, "pURLViewDefs is NULL");

    m_piObject.m_piURLViewDefs = pURLViewDefs;
    if (m_piObject.m_piURLViewDefs != NULL)
        m_piObject.m_piURLViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IURLViewDef *pURLViewDef) : m_st(SEL_VIEWS_URL_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pURLViewDef != NULL, "pURLViewDef is NULL");

    m_piObject.m_piURLViewDef = pURLViewDef;
    if (m_piObject.m_piURLViewDef != NULL)
        m_piObject.m_piURLViewDef->AddRef();
}


CSelectionHolder::CSelectionHolder(SelectionType st, IOCXViewDefs *pOCXViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pOCXViewDefs != NULL, "pOCXViewDefs is NULL");

    m_piObject.m_piOCXViewDefs = pOCXViewDefs;
    if (m_piObject.m_piOCXViewDefs != NULL)
        m_piObject.m_piOCXViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(IOCXViewDef *pOCXViewDef) : m_st(SEL_VIEWS_OCX_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pOCXViewDef != NULL, "pOCXViewDef is NULL");

    m_piObject.m_piOCXViewDef = pOCXViewDef;
    if (m_piObject.m_piOCXViewDef != NULL)
        m_piObject.m_piOCXViewDef->AddRef();
}

CSelectionHolder::CSelectionHolder(SelectionType st, ITaskpadViewDefs *pTaskpadViewDefs) : m_st(st), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pTaskpadViewDefs != NULL, "pTaskpadViewDefs is NULL");

    m_piObject.m_piTaskpadViewDefs = pTaskpadViewDefs;
    if (m_piObject.m_piTaskpadViewDefs != NULL)
        m_piObject.m_piTaskpadViewDefs->AddRef();
}


CSelectionHolder::CSelectionHolder(ITaskpadViewDef *pTaskpadViewDef) : m_st(SEL_VIEWS_TASK_PAD_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pTaskpadViewDef != NULL, "pTaskpadViewDef is NULL");

    m_piObject.m_piTaskpadViewDef = pTaskpadViewDef;
    if (m_piObject.m_piTaskpadViewDef != NULL)
        m_piObject.m_piTaskpadViewDef->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCImageLists *pMMCImageLists) : m_st(SEL_TOOLS_IMAGE_LISTS), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCImageLists != NULL, "pMMCImageLists is NULL");

    m_piObject.m_piMMCImageLists = pMMCImageLists;
    if (m_piObject.m_piMMCImageLists != NULL)
        m_piObject.m_piMMCImageLists->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCImageList *pMMCImageList) : m_st(SEL_TOOLS_IMAGE_LISTS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCImageList != NULL, "pMMCImageList is NULL");

    m_piObject.m_piMMCImageList = pMMCImageList;
    if (m_piObject.m_piMMCImageList != NULL)
        m_piObject.m_piMMCImageList->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCMenus *pMMCMenus) : m_st(SEL_TOOLS_MENUS), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCMenus != NULL, "pMMCMenus is NULL");

    m_piObject.m_piMMCMenus = pMMCMenus;
    if (m_piObject.m_piMMCMenus != NULL)
        m_piObject.m_piMMCMenus->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCMenu *pMMCMenu, IMMCMenus *piChildrenMenus) : m_st(SEL_TOOLS_MENUS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCMenu != NULL, "pMMCMenu is NULL");
    ASSERT(piChildrenMenus != NULL, "piChildrenMenus is NULL");

    m_piObject.m_piMMCMenu = pMMCMenu;
    if (m_piObject.m_piMMCMenu != NULL)
    {
        m_piObject.m_piMMCMenu->AddRef();

        m_piChildrenMenus = piChildrenMenus;
        m_piChildrenMenus->AddRef();
    }
}


CSelectionHolder::CSelectionHolder(IMMCToolbars *pMMCToolbars) : m_st(SEL_TOOLS_TOOLBARS), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCToolbars != NULL, "pMMCToolbars is NULL");

    m_piObject.m_piMMCToolbars = pMMCToolbars;
    if (m_piObject.m_piMMCToolbars != NULL)
        m_piObject.m_piMMCToolbars->AddRef();
}


CSelectionHolder::CSelectionHolder(IMMCToolbar *pMMCToolbar) : m_st(SEL_TOOLS_TOOLBARS_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pMMCToolbar != NULL, "pMMCToolbar is NULL");

    m_piObject.m_piMMCToolbar = pMMCToolbar;
    if (m_piObject.m_piMMCToolbar != NULL)
        m_piObject.m_piMMCToolbar->AddRef();
}


CSelectionHolder::CSelectionHolder(IDataFormats *pDataFormats) : m_st(SEL_XML_RESOURCES), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pDataFormats != NULL, "pDataFormats is NULL");

    m_piObject.m_piDataFormats = pDataFormats;
    if (m_piObject.m_piDataFormats != NULL)
        m_piObject.m_piDataFormats->AddRef();
}


CSelectionHolder::CSelectionHolder(IDataFormat *pDataFormat) : m_st(SEL_XML_RESOURCE_NAME), m_pvData(NULL), m_piChildrenMenus(NULL), m_fInUpdate(FALSE)
{
    ASSERT(pDataFormat != NULL, "pDataFormat is NULL");

    m_piObject.m_piDataFormat = pDataFormat;
    if (m_piObject.m_piDataFormat != NULL)
        m_piObject.m_piDataFormat->AddRef();
}


CSelectionHolder::~CSelectionHolder()
{
    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        RELEASE(m_piObject.m_piSnapInDef);
        break;

    case SEL_EXTENSIONS_ROOT:
    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:
        RELEASE(m_piObject.m_piExtensionDefs);
        break;

    case SEL_EEXTENSIONS_NAME:
    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:
        RELEASE(m_piObject.m_piExtendedSnapIn);
        break;

    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_OTHER:
	case SEL_NODES_ANY_CHILDREN:
        RELEASE(m_piObject.m_piScopeItemDefs);
        break;

    case SEL_NODES_ANY_NAME:
	case SEL_NODES_ANY_VIEWS:
        RELEASE(m_piObject.m_piScopeItemDef);
        break;

    case SEL_VIEWS_LIST_VIEWS:
        RELEASE(m_piObject.m_piListViewDefs);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        RELEASE(m_piObject.m_piListViewDef);
        break;

    case SEL_VIEWS_OCX:
        RELEASE(m_piObject.m_piOCXViewDefs);
        break;

    case SEL_VIEWS_OCX_NAME:
        RELEASE(m_piObject.m_piOCXViewDef);
        break;

    case SEL_VIEWS_URL:
        RELEASE(m_piObject.m_piURLViewDefs);
        break;

    case SEL_VIEWS_URL_NAME:
        RELEASE(m_piObject.m_piURLViewDef);
        break;

    case SEL_VIEWS_TASK_PAD:
        RELEASE(m_piObject.m_piTaskpadViewDefs);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        RELEASE(m_piObject.m_piTaskpadViewDef);
        break;

    case SEL_TOOLS_IMAGE_LISTS:
        RELEASE(m_piObject.m_piMMCImageLists);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        RELEASE(m_piObject.m_piMMCImageList);
        break;

    case SEL_TOOLS_MENUS:
        RELEASE(m_piObject.m_piMMCMenus);
        break;

    case SEL_TOOLS_MENUS_NAME:
        RELEASE(m_piObject.m_piMMCMenu);
        RELEASE(m_piChildrenMenus);
        break;

    case SEL_TOOLS_TOOLBARS:
        RELEASE(m_piObject.m_piMMCToolbars);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        RELEASE(m_piObject.m_piMMCToolbar);
        break;

    case SEL_XML_RESOURCES:
        RELEASE(m_piObject.m_piDataFormats);
        break;

    case SEL_XML_RESOURCE_NAME:
        RELEASE(m_piObject.m_piDataFormat);
        break;
    }
}



void CSelectionHolder::SetInUpdate(BOOL fInUpdate)
{
    m_fInUpdate = fInUpdate;
}



BOOL CSelectionHolder::InUpdate()
{
    return m_fInUpdate;
}


HRESULT CSelectionHolder::RegisterHolder()
{
    HRESULT              hr = S_OK;
    IUnknown            *piUnknown = NULL;
    IMMCMenu            *piMMCMenu = NULL;
    ITaskpad            *piTaskpad = NULL;
    IExtendedSnapIns    *piIExtendedSnapIns = NULL;

    hr = GetIUnknown(&piUnknown);
    IfFailGo(hr);

    hr = InternalRegisterHolder(piUnknown);
    IfFailGo(hr);

    if (SEL_EXTENSIONS_ROOT == m_st)
    {
        hr = m_piObject.m_piExtensionDefs->get_ExtendedSnapIns(&piIExtendedSnapIns);
        IfFailGo(hr);

        RELEASE(piUnknown);
        hr = piIExtendedSnapIns->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        hr = InternalRegisterHolder(piUnknown);
        IfFailGo(hr);
    }
    else if (SEL_TOOLS_MENUS_NAME == m_st)
    {
        RELEASE(piUnknown);
        hr = m_piChildrenMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        hr = InternalRegisterHolder(piUnknown);
        IfFailGo(hr);
    }
    else if (SEL_VIEWS_TASK_PAD_NAME == m_st)
    {
        hr = m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        RELEASE(piUnknown);
        hr = piTaskpad->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        hr = InternalRegisterHolder(piUnknown);
        IfFailGo(hr);
    }

Error:
    RELEASE(piIExtendedSnapIns);
    RELEASE(piTaskpad);
    RELEASE(piMMCMenu);
    RELEASE(piUnknown);

    RRETURN(hr);
}

HRESULT CSelectionHolder::InternalRegisterHolder(IUnknown *piUnknown)
{
    HRESULT        hr = S_OK;
    IObjectModel  *piObjectModel = NULL;
    long           lCookie = 0;

    hr = piUnknown->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    lCookie = 0;
    hr = piObjectModel->GetCookie(&lCookie);
    IfFailGo(hr);

    if (0 == lCookie)
    {
        hr = piObjectModel->SetCookie(reinterpret_cast<long>(this));
        IfFailGo(hr);
    }

Error:
    RELEASE(piObjectModel);

    RRETURN(hr);
}

HRESULT CSelectionHolder::UnregisterHolder()
{
    HRESULT        hr = S_OK;
    IUnknown      *piUnknown = NULL;
    IObjectModel  *piObjectModel = NULL;
    long           lCookie = 0;

    hr = GetIUnknown(&piUnknown);
    IfFailGo(hr);

    hr = piUnknown->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(0);
    IfFailGo(hr);

    if (SEL_TOOLS_MENUS_NAME == m_st)
    {
        RELEASE(piUnknown);
        hr = m_piChildrenMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&piUnknown));
        IfFailGo(hr);

        RELEASE(piObjectModel);
        hr = m_piChildrenMenus->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        lCookie = 0;
        hr = piObjectModel->SetCookie(0);
        IfFailGo(hr);
    }

Error:
    RELEASE(piObjectModel);
    RELEASE(piUnknown);

    RRETURN(hr);
}


HRESULT CSelectionHolder::GetIUnknown(IUnknown **ppiUnknown)
{
    HRESULT     hr = S_FALSE;

    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        hr = m_piObject.m_piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EXTENSIONS_ROOT:
    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtensionDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EEXTENSIONS_NAME:
    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtendedSnapIn->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_ANY_NAME:
	case SEL_NODES_ANY_VIEWS:
        hr = m_piObject.m_piScopeItemDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_OTHER:
	case SEL_NODES_ANY_CHILDREN:
        hr = m_piObject.m_piScopeItemDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS:
        hr = m_piObject.m_piListViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = m_piObject.m_piListViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX:
        hr = m_piObject.m_piOCXViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = m_piObject.m_piOCXViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL:
        hr = m_piObject.m_piURLViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL_NAME:
        hr = m_piObject.m_piURLViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD:
        hr = m_piObject.m_piTaskpadViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_piObject.m_piTaskpadViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS:
        hr = m_piObject.m_piMMCImageLists->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = m_piObject.m_piMMCImageList->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS:
        hr = m_piObject.m_piMMCMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = m_piObject.m_piMMCMenu->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS:
        hr = m_piObject.m_piMMCToolbars->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = m_piObject.m_piMMCToolbar->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCES:
        hr = m_piObject.m_piDataFormats->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = m_piObject.m_piDataFormat->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;
    }

    RRETURN(hr);
}


HRESULT CSelectionHolder::GetSelectableObject(IUnknown **ppiUnknown)
{
    HRESULT     hr = S_FALSE;
    ITaskpad   *piTaskpad = NULL;
    IMMCMenu   *piMMCMenu = NULL;

    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        hr = m_piObject.m_piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EXTENSIONS_ROOT:
    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtensionDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_EEXTENSIONS_NAME:
    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:
        hr = m_piObject.m_piExtendedSnapIn->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_ANY_NAME:
	case SEL_NODES_ANY_VIEWS:
        hr = m_piObject.m_piScopeItemDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_OTHER:
	case SEL_NODES_ANY_CHILDREN:
        hr = m_piObject.m_piScopeItemDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS:
        hr = m_piObject.m_piListViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = m_piObject.m_piListViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX:
        hr = m_piObject.m_piOCXViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = m_piObject.m_piOCXViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL:
        hr = m_piObject.m_piURLViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_URL_NAME:
        hr = m_piObject.m_piURLViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD:
        hr = m_piObject.m_piTaskpadViewDefs->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        hr = piTaskpad->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS:
        hr = m_piObject.m_piMMCImageLists->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = m_piObject.m_piMMCImageList->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS:
        hr = m_piObject.m_piMMCMenus->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = m_piObject.m_piMMCMenu->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS:
        hr = m_piObject.m_piMMCToolbars->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = m_piObject.m_piMMCToolbar->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCES:
        hr = m_piObject.m_piDataFormats->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = m_piObject.m_piDataFormat->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(ppiUnknown));
        break;
    }

Error:
    RELEASE(piMMCMenu);
    RELEASE(piTaskpad);

    RRETURN(hr);
}


HRESULT CSelectionHolder::GetName(BSTR *pbstrName)
{
    HRESULT     hr = S_FALSE;
    IMMCMenu   *piMMCMenu = NULL;

    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:
    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_TOOLS_ROOT:
    case SEL_VIEWS_ROOT:
        hr = m_piObject.m_piSnapInDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = m_piObject.m_piScopeItemDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = m_piObject.m_piListViewDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = m_piObject.m_piOCXViewDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = m_piObject.m_piURLViewDef->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_piObject.m_piTaskpadViewDef->get_Key(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = m_piObject.m_piMMCImageList->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = m_piObject.m_piMMCMenu->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = m_piObject.m_piMMCToolbar->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = m_piObject.m_piDataFormat->get_Name(pbstrName);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "GetName: Object does not support this function");
    }

Error:
    RELEASE(piMMCMenu);

    RRETURN(hr);
}


bool CSelectionHolder::IsEqual(const CSelectionHolder *pHolder) const
{
    if (m_st != pHolder->m_st)
        return false;

    if (m_piObject.m_lDummy != pHolder->m_piObject.m_lDummy)
        return false;

    return true;
}


bool CSelectionHolder::IsNotEqual(const CSelectionHolder *pHolder) const
{
    if (m_st != pHolder->m_st)
        return true;

    if (m_piObject.m_lDummy != pHolder->m_piObject.m_lDummy)
        return true;

    return false;
}


bool CSelectionHolder::IsVirtual() const
{
    switch (m_st)
    {
    case SEL_SNAPIN_ROOT:

    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
    case SEL_EEXTENSIONS_CC_TASK:
    case SEL_EEXTENSIONS_PP_ROOT:
    case SEL_EEXTENSIONS_TASKPAD:
    case SEL_EEXTENSIONS_TOOLBAR:
    case SEL_EEXTENSIONS_NAMESPACE:

    case SEL_EXTENSIONS_MYNAME:
    case SEL_EXTENSIONS_NEW_MENU:
    case SEL_EXTENSIONS_TASK_MENU:
    case SEL_EXTENSIONS_TOP_MENU:
    case SEL_EXTENSIONS_VIEW_MENU:
    case SEL_EXTENSIONS_PPAGES:
    case SEL_EXTENSIONS_TOOLBAR:
    case SEL_EXTENSIONS_NAMESPACE:

    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_NODES_OTHER:
    case SEL_NODES_ANY_CHILDREN:
    case SEL_NODES_ANY_VIEWS:

    case SEL_TOOLS_ROOT:
    case SEL_TOOLS_IMAGE_LISTS:
    case SEL_TOOLS_MENUS:
    case SEL_TOOLS_TOOLBARS:

    case SEL_VIEWS_ROOT:
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:

    case SEL_XML_RESOURCES:
        return true;
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\stub_mssnapr_i.c ===
#include <mssnapr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\snaputil.cpp ===
//=--------------------------------------------------------------------------=
// snaputil.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Utitlity Routines for the SnapIn Designer
//

#include "pch.h"
#include "common.h"
#include "desmain.h"

// for ASSERT and FAIL
//
SZTHISFILE


CGlobalHelp g_GlobalHelp;

IHelp *CGlobalHelp::m_pIHelp = NULL;
DWORD  CGlobalHelp::m_cSnapInDesigners = 0;
char   CGlobalHelp::m_szDesignerName[256] = "Snap-in Designer";
BOOL   CGlobalHelp::m_fHaveDesignerName = FALSE;

CGlobalHelp::CGlobalHelp()
{
    m_pIHelp = NULL;
}

CGlobalHelp::~CGlobalHelp()
{
    RELEASE(m_pIHelp);
}

VOID CALLBACK CGlobalHelp::MsgBoxCallback(LPHELPINFO lpHelpInfo)
{
    ShowHelp(lpHelpInfo->dwContextId);
}

HRESULT CGlobalHelp::ShowHelp(DWORD dwHelpContextId)
{
    HRESULT hr = S_OK;

    if (NULL != m_pIHelp)
    {
        hr = m_pIHelp->ShowHelp(HELP_FILENAME_WIDE, 
                                HELP_CONTEXT, 
                                dwHelpContextId);
    }

    return hr;
}

void CGlobalHelp::Attach(IHelp* pIHelp)
{
    if(m_pIHelp == NULL)
    {
        pIHelp->AddRef();

        m_pIHelp = pIHelp;
    }
    else
    {
        m_pIHelp->AddRef();
    }

    m_cSnapInDesigners++;
}

void CGlobalHelp::Detach()
{
    QUICK_RELEASE(m_pIHelp);
    m_cSnapInDesigners--;
    if (0 == m_cSnapInDesigners)
    {
        m_pIHelp = NULL;
    }
}

//=--------------------------------------------------------------------------=
// CGlobalHelp::GetDesignerName
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      Pointer to null terminates string containing designer name. This
//      pointer is guaranteed to be valid.
//
// Notes:
//
// If designer name has not yet been loaded from the resource DLL then loads it.
// If load fails then designer name will be default English string set in its
// initialization at the top of this file.
//

char *CGlobalHelp::GetDesignerName()
{
    if (!m_fHaveDesignerName)
    {
        (void)::LoadString(::GetResourceHandle(), 
                           IDS_DESIGNER_NAME,
                           m_szDesignerName,
                           sizeof(m_szDesignerName) / sizeof(m_szDesignerName[0]));
        m_fHaveDesignerName = TRUE;
    }
    return m_szDesignerName;
}


//=--------------------------------------------------------------------------=
// SDU_DisplayMessage
//=--------------------------------------------------------------------------=
//
// Parameters:
//      UINT   idMessage        [in]  resource ID of message format string
//      UINT   uMsgBoxOpts      [in]  MB_OK etc.
//      DWORD  dwHelpContextID  [in]  Help Context ID
//      int   *pMsgBoxRet       [out] IDOK, IDCANCEL etc, returned here
//      ...                     [in]  arguments for % replacements in string
//
// Output:
//      HRESULT
//
// Notes:
//
// Formats message from string table using Win32 FormatMessage API and displays
// it in a message box with a help button (automatically adds MB_HELP). If the
// string has replacements then they must use FormatMessage style e.g.
//
// "The file %1!s! for %2!s! is missing from the project directory."
//
// All messages displayed by the designer must use this function. Doing so
// guarantees that localization and help support have been handled correctly.
//
// How to Create a New Message
// ===========================
// 1. Add a string to a STRINGTABLE in the mssnapd.rc
// 2. Add an ID string that matches the name in mssnapd.id
// 3. Call this function passing the string's resource ID and HID_Xxxx where
// Xxxx is the ID string added mssnapd.id.
//

HRESULT cdecl SDU_DisplayMessage
(
    UINT            idMessage,
    UINT            uMsgBoxOpts,
    DWORD           dwHelpContextID,
    HRESULT         hrDisplay,
    MessageOptions  Option,
    int            *pMsgBoxRet,
    ...
)
{
    HRESULT      hr = S_OK;
    int          MsgBoxRet = 0;
    DWORD        cchMsg = 0;
    char         szMessage[2048];
    char        *pszFormattedMessage = NULL;
    char        *pszDisplayMessage = "An error occurred in the Snap-in Designer but the error message could not be loaded.";
    int          nRet = 0;
    IErrorInfo  *piErrorInfo = NULL;
    BSTR         bstrSource = NULL;
    BSTR         bstrDescription = NULL;

    MSGBOXPARAMS mbp;
    ::ZeroMemory(&mbp, sizeof(mbp));

    va_list pArgList;
    va_start(pArgList, pMsgBoxRet);

    mbp.dwContextHelpId = dwHelpContextID;

    cchMsg = (DWORD)::LoadString(::GetResourceHandle(), 
                                 idMessage,
                                 szMessage,
                                 sizeof(szMessage) / sizeof(szMessage[0]));
    IfFalseGoto(0 < cchMsg, S_OK, Display);

    cchMsg = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                             FORMAT_MESSAGE_FROM_STRING,
                             szMessage,
                             0, // no message ID, passing string
                             0, // no language ID, passing string
                             (LPTSTR)&pszFormattedMessage,
                             0, // minimum buffer size
                             &pArgList);

    IfFalseGoto(0 < cchMsg, S_OK, Display);
    pszFormattedMessage = pszDisplayMessage;

    if ( (AppendErrorInfo == Option) & (cchMsg < sizeof(szMessage) - 1) )
    {
        ::strcpy(szMessage, pszFormattedMessage);
        IfFailGoto(::GetErrorInfo(0, &piErrorInfo), Display);
        IfFalseGoto(NULL != piErrorInfo, S_OK, Display);
        IfFailGoto(piErrorInfo->GetHelpContext(&mbp.dwContextHelpId), Display);
        IfFailGoto(piErrorInfo->GetSource(&bstrSource), Display);
        IfFailGoto(piErrorInfo->GetDescription(&bstrDescription), Display);
        IfFalseGoto(NULL != bstrSource, S_OK, Display);
        IfFalseGoto(NULL != bstrDescription, S_OK, Display);
        _snprintf(&szMessage[cchMsg], sizeof(szMessage) - cchMsg - 1,
                  "\r\nError &H%08.8X (%u) %S: %S", hrDisplay, HRESULT_CODE(hrDisplay), bstrSource, bstrDescription);
        pszDisplayMessage = szMessage;
    }

Display:
    
    mbp.cbSize = sizeof(mbp);
    mbp.hwndOwner = ::GetActiveWindow();
    mbp.hInstance = ::GetResourceHandle();
    mbp.lpszText = pszDisplayMessage;
    mbp.lpszCaption = CGlobalHelp::GetDesignerName();
    mbp.dwStyle = uMsgBoxOpts | MB_HELP;
    mbp.lpfnMsgBoxCallback = CGlobalHelp::MsgBoxCallback;
    mbp.dwLanguageId = LANGIDFROMLCID(g_lcidLocale);

    MsgBoxRet = ::MessageBoxIndirect(&mbp);
    IfFalseGo(0 != MsgBoxRet, HRESULT_FROM_WIN32(GetLastError()));

    if(pMsgBoxRet != NULL)
    {
        *pMsgBoxRet = MsgBoxRet;
    }

Error:

    va_end(pArgList);

    if (NULL != pszFormattedMessage)
    {
        ::LocalFree(pszFormattedMessage);
    }
    QUICK_RELEASE(piErrorInfo);
    return hr;
}


//=--------------------------------------------------------------------------=
// SDU_GetLastError()
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      Return value from Win32 API function GetLastError()
//
// Notes:
//
// This function is available only in debug builds. It is for use in the
// debugger when a Win32 API call fails and you need to examine the return from
// GetLastError(). Open the quick watch window (Shift+F9) and type in
//
// SDU_GetLastError()
//
// The debugger will call the function and show its return value.
//

#if defined(DEBUG)

DWORD SDU_GetLastError()
{
    return ::GetLastError();
}

#endif


//=--------------------------------------------------------------------------=
// ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts null terminated WCHAR string to null terminated ANSI string. 
// Allocates ANSI string using CtlAlloc() function. If successful, caller
// must free ANSI string with CtlFree() function.
//
HRESULT ANSIFromWideStr
(
    WCHAR   *pwszWideStr,
    char   **ppszAnsi
)
{
    HRESULT hr = S_OK;
    int     cchAnsi = 0;
    int     cchWideStr = (int)::wcslen(pwszWideStr);
    int     cchConverted = 0;

    *ppszAnsi = NULL;

    if (0 != cchWideStr)
    {
        // get required buffer length

        cchAnsi = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                        0,           // performance and mapping flags 
                                        pwszWideStr, // address of wide-character string 
                                        cchWideStr,  // number of characters in string 
                                        NULL,        // address of buffer for new string 
                                        0,           // size of buffer 
                                        NULL,        // address of default for unmappable characters 
                                        NULL         // address of flag set when default char. used 
                                       );
        if (0 == cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<char *>(::CtlAlloc(cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        IfFailGo(hr);
    }

    if (0 != cchWideStr)
    {
        // now convert the string and copy it to the buffer
        cchConverted = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                             0,           // performance and mapping flags 
                                             pwszWideStr, // address of wide-character string 
                                             cchWideStr,  // number of characters in string 
                                            *ppszAnsi,    // address of buffer for new string 
                                             cchAnsi,     // size of buffer 
                                             NULL,        // address of default for unmappable characters 
                                             NULL         // address of flag set when default char. used 
                                            );
        if (cchConverted != cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null byte

    *((*ppszAnsi) + cchAnsi) = '\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            ::CtlFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// WideStrFromANSI(const char *pszAnsi, WCHAR **ppwszWideStr)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts null terminated ANSI string to a null terminated WCHAR string. 
// Allocates WCHAR string buffer using the CtlAlloc() function. If successful,
// caller must free WCHAR string using the CtlFree() function.
//
HRESULT WideStrFromANSI
(
    const char    *pszAnsi,
    WCHAR        **ppwszWideStr
)
{
    HRESULT    hr = S_OK;
    int        cchANSI = ::strlen(pszAnsi);
    int        cchWideStr = 0;
    int        cchConverted = 0;

    *ppwszWideStr = NULL;

    if (0 != cchANSI)
    {
        // get required buffer length
        cchWideStr = ::MultiByteToWideChar(CP_ACP,  // code page - ANSI code page
                                           0,       // performance and mapping flags 
                                           pszAnsi, // address of multibyte string 
                                           cchANSI, // number of characters in string 
                                           NULL,    // address of buffer for new string 
                                           0        // size of buffer 
                                          );
        if (0 == cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the WCHAR *
    *ppwszWideStr = static_cast<WCHAR *>(::CtlAlloc(sizeof(WCHAR) * (cchWideStr + 1)));
    if (*ppwszWideStr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 != cchANSI)
    {
        // now convert the string and copy it to the buffer
        cchConverted = ::MultiByteToWideChar(CP_ACP,       // code page - ANSI code page
                                             0,            // performance and mapping flags 
                                             pszAnsi,      // address of multibyte string 
                                             cchANSI,      // number of characters in string 
                                            *ppwszWideStr, // address of buffer for new string 
                                             cchWideStr    // size of buffer 
                                            );
        if (cchConverted != cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null character
    *((*ppwszWideStr) + cchWideStr) = L'\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            ::CtlFree(*ppwszWideStr);
            *ppwszWideStr = NULL;
        }
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// ANSIFromBSTR(BSTR bstr, TCHAR **ppszAnsi)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts BSTR to null terminated ANSI string. Allocates ANSI string using
// CtlAlloc() function. If successful, caller must free ANSI string with CtlFree()
// function.
//
HRESULT ANSIFromBSTR(BSTR bstr, TCHAR **ppszAnsi)
{
    HRESULT     hr = S_OK;
    int         cchBstr = (int) ::SysStringLen(bstr);
    int         cchConverted = 0;
    int         cchAnsi = 0;

    *ppszAnsi = NULL;

    if (0 != cchBstr)
    {
        // get required buffer length
        cchAnsi = ::WideCharToMultiByte(CP_ACP,  // code page - ANSI code page
                                        0,       // performance and mapping flags 
                                        bstr,    // address of wide-character string 
                                        cchBstr, // number of characters in string 
                                        NULL,    // address of buffer for new string 
                                        0,       // size of buffer 
                                        NULL,    // address of default for unmappable characters 
                                        NULL     // address of flag set when default char. used 
                                       );
        if (cchAnsi == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<TCHAR *>(::CtlAlloc(cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 != cchBstr)
    {
        // now convert the string and copy it to the buffer
        cchConverted = ::WideCharToMultiByte(CP_ACP,    // code page - ANSI code page
                                             0,         // performance and mapping flags 
                                             bstr,      // address of wide-character string 
                                             cchBstr,   // number of characters in string 
                                             *ppszAnsi, // address of buffer for new string 
                                             cchAnsi,   // size of buffer 
                                             NULL,      // address of default for unmappable characters 
                                             NULL       // address of flag set when default char. used 
                                            );
        if (cchConverted != cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null byte
    *((*ppszAnsi) + cchAnsi) = '\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            ::CtlFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// BSTRFromANSI(TCHAR *pszAnsi, BSTR *pbstr)
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Converts null terminated ANSI string to a null terminated BSTR. Allocates
// BSTR. If successful, caller must free BSTR using ::SysFreeString().
//
HRESULT BSTRFromANSI(const TCHAR *pszAnsi, BSTR *pbstr)
{
    HRESULT  hr = S_OK;
    WCHAR   *pwszWideStr = NULL;

    // convert to a wide string first
    hr = ::WideStrFromANSI(pszAnsi, &pwszWideStr);
    IfFailGo(hr);

    // allocate a BSTR and copy it
    *pbstr = ::SysAllocStringLen(pwszWideStr, ::wcslen(pwszWideStr));
    if (*pbstr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pwszWideStr)
    {
        ::CtlFree(pwszWideStr);
    }

    RRETURN(hr);
}


HRESULT GetResourceString(int iStringID, char *pszBuffer, int iBufferLen)
{
    HRESULT     hr = S_OK;
    int         iResult = 0;

    iResult = ::LoadString(GetResourceHandle(),
                           iStringID,
                           pszBuffer,
                           iBufferLen);
    if (0 == iResult)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        CError::GenerateInternalExceptionInfo(hr);
    }

    RRETURN(hr);
}


HRESULT GetExtendedSnapInDisplayName
(
    IExtendedSnapIn  *piExtendedSnapIn,
    char            **ppszDisplayName
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrName = NULL;
    BSTR     bstrGUID = NULL;
    char    *pszName = NULL;
    size_t   cbName = 0;
    char    *pszGUID = NULL;
    size_t   cbGUID = 0;
    char    *pszDisplayName = NULL;

    hr = piExtendedSnapIn->get_NodeTypeName(&bstrName);
    IfFailGo(hr);

    hr = piExtendedSnapIn->get_NodeTypeGUID(&bstrGUID);
    IfFailGo(hr);

    if (NULL != bstrName)
    {
        hr = ::ANSIFromBSTR(bstrName, &pszName);
        IfFailGo(hr);
        cbName = ::strlen(pszName);
    }

    if (NULL != bstrGUID)
    {
        hr = ::ANSIFromBSTR(bstrGUID, &pszGUID);
        IfFailGo(hr);
        cbGUID = ::strlen(pszGUID);
    }

    // Allocate enough room for two names separated by a space plus a null byte

    pszDisplayName = (char *)::CtlAlloc(cbName + cbGUID + 2);
    if (NULL == pszDisplayName)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 != cbGUID)
    {
        ::memcpy(pszDisplayName, pszGUID, cbGUID + 1);
    }

    if (0 != cbName)
    {
        pszDisplayName[cbGUID] = ' ';
        ::memcpy(&pszDisplayName[cbGUID + 1], pszName, cbName + 1);
    }

    *ppszDisplayName = pszDisplayName;

Error:
    FREESTRING(bstrName);
    FREESTRING(bstrGUID);

    if (NULL != pszName)
        CtlFree(pszName);

    if (NULL != pszGUID)
        CtlFree(pszGUID);

   RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\selhold.h ===
//=--------------------------------------------------------------------------------------
// SelHold.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSelectionHolder declaration
//=-------------------------------------------------------------------------------------=

#ifndef _SELECTIONHOLDER_H_
#define _SELECTIONHOLDER_H_


////////////////////////////////////////////////////////////////////////////////////
// SelectionHolder
//
// There is one SelectionType for each kind of node in the Snap-In Designer tree
//
typedef enum tagSELECTION_TYPE
{
	SEL_NONE                    =  0,

	SEL_SNAPIN_ROOT             =  1,

    SEL_EXTENSIONS_ROOT         = 10,    // Extensions

    SEL_EEXTENSIONS_NAME        = 11,    // Extensions/<Extended snap-in>
    SEL_EEXTENSIONS_CC_ROOT     = 12,    // Extensions/<Extended snap-in>/Context Menus
    SEL_EEXTENSIONS_CC_NEW      = 13,    // Extensions/<Extended snap-in>/Context Menus/New
    SEL_EEXTENSIONS_CC_TASK     = 14,    // Extensions/<Extended snap-in>/Context Menus/Task
    SEL_EEXTENSIONS_PP_ROOT     = 15,    // Extensions/<Extended snap-in>/Property Pages
    SEL_EEXTENSIONS_TASKPAD     = 16,    // Extensions/<Extended snap-in>/Taskpad
    SEL_EEXTENSIONS_TOOLBAR     = 17,    // Extensions/<Extended snap-in>/Toolbar
    SEL_EEXTENSIONS_NAMESPACE   = 18,    // Extensions/<Extended snap-in>/NameSpace

    SEL_EXTENSIONS_MYNAME       = 20,    // Extensions/<Snap-in Name>
    SEL_EXTENSIONS_NEW_MENU     = 21,    // Extensions/<Snap-in Name>/ExtendsNewMenu
    SEL_EXTENSIONS_TASK_MENU    = 22,    // Extensions/<Snap-in Name>/ExtendsTaskMenu
    SEL_EXTENSIONS_TOP_MENU     = 23,    // Extensions/<Snap-in Name>/ExtendsTopMenu
    SEL_EXTENSIONS_VIEW_MENU    = 24,    // Extensions/<Snap-in Name>/ExtendsViewMenu
    SEL_EXTENSIONS_PPAGES       = 25,    // Extensions/<Snap-in Name>/ExtendsPropertyPages
    SEL_EXTENSIONS_TOOLBAR      = 26,    // Extensions/<Snap-in Name>/ExtendsToolbar
    SEL_EXTENSIONS_NAMESPACE    = 27,    // Extensions/<Snap-in Name>/ExtendsNameSpace

    SEL_NODES_ROOT              = 40,    // Nodes
    SEL_NODES_AUTO_CREATE       = 41,    // Nodes/AutoCreate
    SEL_NODES_AUTO_CREATE_ROOT  = 42,    // Nodes/AutoCreate/Root
    SEL_NODES_AUTO_CREATE_RTCH  = 43,    // Nodes/AutoCreate/Root/Children
    SEL_NODES_AUTO_CREATE_RTVW  = 44,    // Nodes/AutoCreate/Root/Views
    SEL_NODES_OTHER             = 45,    // Nodes/Other
    SEL_NODES_ANY_NAME          = 46,    // Nodes/<any>/<node name>
    SEL_NODES_ANY_CHILDREN      = 47,    // Nodes/<any>/<any>/Children
    SEL_NODES_ANY_VIEWS         = 48,    // Nodes/<any>/<any>/Views

    SEL_TOOLS_ROOT              = 50,    // Tools
    SEL_TOOLS_IMAGE_LISTS       = 51,    // Tools/Image Lists
    SEL_TOOLS_IMAGE_LISTS_NAME  = 52,    // Tools/Image Lists/<image list name>
    SEL_TOOLS_MENUS             = 53,    // Tools/Menus
    SEL_TOOLS_MENUS_NAME        = 54,    // Tools/Menus/<menu name>
    SEL_TOOLS_TOOLBARS          = 55,    // Tools/Toolbars
    SEL_TOOLS_TOOLBARS_NAME     = 56,    // Tools/Toolbars/<toolbar name>

    SEL_VIEWS_ROOT              = 60,    // Views
    SEL_VIEWS_LIST_VIEWS        = 61,    // Views/List Views
    SEL_VIEWS_LIST_VIEWS_NAME   = 62,    // Views/List Views/<view name>
    SEL_VIEWS_OCX               = 63,    // Views/OCX Views
    SEL_VIEWS_OCX_NAME          = 64,    // Views/OCX Views/<view name>
    SEL_VIEWS_URL               = 65,    // Views/URL Views
    SEL_VIEWS_URL_NAME          = 66,    // Views/URL Views/<view name>
    SEL_VIEWS_TASK_PAD          = 67,    // Views/Taskpad Views
    SEL_VIEWS_TASK_PAD_NAME     = 68,    // Views/Taskpad Views/<view name>

    SEL_XML_RESOURCES           = 70,    // Resources
    SEL_XML_RESOURCE_NAME       = 71     // Resource/<resource name>
} SelectionType;


class CSelectionHolder : public CtlNewDelete
{
public:
    CSelectionHolder();
    CSelectionHolder(SelectionType st);
    CSelectionHolder(SelectionType st, ISnapInDef *piSnapInDef);

    CSelectionHolder(SelectionType st, IExtensionDefs *piExtensionDefs);
    CSelectionHolder(IExtendedSnapIn *piExtendedSnapIn);
    CSelectionHolder(SelectionType st, IExtendedSnapIn *piExtendedSnapIn);

    CSelectionHolder(SelectionType st, IScopeItemDefs *pScopeItemDefs);
    CSelectionHolder(SelectionType st, IScopeItemDef *pScopeItemDef);

    CSelectionHolder(SelectionType st, IListViewDefs *pListViewDefs);
    CSelectionHolder(IListViewDef *pListViewDef);
    CSelectionHolder(SelectionType st, IURLViewDefs *pURLViewDefs);
    CSelectionHolder(IURLViewDef *pURLViewDef);
    CSelectionHolder(SelectionType st, IOCXViewDefs *pOCXViewDefs);
    CSelectionHolder(IOCXViewDef *pOCXViewDef);
    CSelectionHolder(SelectionType st, ITaskpadViewDefs *pTaskpadViewDefs);
    CSelectionHolder(ITaskpadViewDef *pTaskpadViewDef);

    CSelectionHolder(IMMCImageLists *pMMCImageLists);
    CSelectionHolder(IMMCImageList *pMMCImageList);
    CSelectionHolder(IMMCMenus *pMMCMenus);
    CSelectionHolder(IMMCMenu *pMMCMenu, IMMCMenus *piChildrenMenus);
    CSelectionHolder(IMMCToolbars *pMMCToolbars);
    CSelectionHolder(IMMCToolbar *pMMCToolbar);

    CSelectionHolder(IDataFormats *pDataFormats);
    CSelectionHolder(IDataFormat *pDataFormat);

    ~CSelectionHolder();

public:
    bool IsEqual(const CSelectionHolder *pHolder) const;
    bool IsNotEqual(const CSelectionHolder *pHolder) const;

    bool IsVirtual() const;

    HRESULT RegisterHolder();
    HRESULT InternalRegisterHolder(IUnknown *piUnknown);
	HRESULT UnregisterHolder();
    HRESULT GetIUnknown(IUnknown **ppiUnknown);
    HRESULT GetSelectableObject(IUnknown **ppiUnknown);
    HRESULT GetName(BSTR *pbstrName);
    void SetInUpdate(BOOL fInUpdate);
    BOOL InUpdate();

public:
    SelectionType   m_st;
    BOOL            m_fInUpdate;
    void           *m_pvData;
    union
    {
        ISnapInDef            *m_piSnapInDef;
        IExtensionDefs        *m_piExtensionDefs;
        IExtendedSnapIn       *m_piExtendedSnapIn;
        IScopeItemDefs        *m_piScopeItemDefs;
        IScopeItemDef         *m_piScopeItemDef;
        IListViewDefs         *m_piListViewDefs;
        IListViewDef          *m_piListViewDef;
        IURLViewDefs          *m_piURLViewDefs;
        IURLViewDef           *m_piURLViewDef;
        IOCXViewDefs          *m_piOCXViewDefs;
        IOCXViewDef           *m_piOCXViewDef;
        ITaskpadViewDefs      *m_piTaskpadViewDefs;
        ITaskpadViewDef       *m_piTaskpadViewDef;
        IMMCImageLists        *m_piMMCImageLists;
        IMMCImageList         *m_piMMCImageList;
        IMMCMenus             *m_piMMCMenus;
        IMMCMenu              *m_piMMCMenu;
		IMMCToolbars          *m_piMMCToolbars;
		IMMCToolbar           *m_piMMCToolbar;
		IDataFormats          *m_piDataFormats;
		IDataFormat           *m_piDataFormat;
        long                   m_lDummy;
    } m_piObject;
    IMMCMenus   *m_piChildrenMenus;
};

#endif // _SELECTIONHOLDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\taskpvw.cpp ===
//=--------------------------------------------------------------------------------------
// taskpvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- TaskpadView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddTaskpadView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddTaskpadView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    ITaskpadViewDefs      *piTaskpadViewDefs = NULL;
    VARIANT                vtEmpty;
    ITaskpadViewDef       *piTaskpadViewDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        if (piTaskpadViewDefs != NULL)
        {
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piTaskpadViewDefs->Add(vtEmpty, vtEmpty, &piTaskpadViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piTaskpadViewDef);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddTaskpadViewDef(CSelectionHolder *pParent, ITaskpadViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddTaskpadViewDef(CSelectionHolder *pParent, ITaskpadViewDef *piTaskpadViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pTaskpadView = NULL;
    IViewDefs           *piViewDefs = NULL;
    ITaskpadViewDefs    *piTaskpadViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddTaskpadViewDef: pParent is NULL");
    ASSERT(NULL != pParent->m_piObject.m_piTaskpadViewDefs, "OnAddTaskpadViewDef: pParent->m_piObject.m_piTaskpadViewDefs is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD:
        piTaskpadViewDefs = pParent->m_piObject.m_piTaskpadViewDefs;
        piTaskpadViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddTaskpadViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewTaskpadView(piTaskpadViewDefs, piTaskpadViewDef, &pTaskpadView);
    IfFailGo(hr);

    hr = InsertTaskpadViewInTree(pTaskpadView, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pTaskpadView);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pTaskpadView);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pTaskpadView);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piTaskpadViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingTaskpadView(IViewDefs *piViewDefs, ITaskpadViewDef *piTaskpadViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingTaskpadView(IViewDefs *piViewDefs, ITaskpadViewDef *piTaskpadViewDef)
{
    HRESULT           hr = S_OK;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->AddFromMaster(piTaskpadViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameTaskpadView(CSelectionHolder *pTaskpadView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameTaskpadView(CSelectionHolder *pTaskpadView, BSTR bstrNewName)
{
    HRESULT     hr = S_OK;
    TCHAR      *pszName = NULL;

    ASSERT(SEL_VIEWS_TASK_PAD_NAME == pTaskpadView->m_st, "RenameTaskpadView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Name(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pTaskpadView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pTaskpadView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteTaskpadView(CSelectionHolder *pTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteTaskpadView
(
    CSelectionHolder *pTaskpadView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    VARIANT           vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pTaskpadView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->get_Key(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pTaskpadView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        vtKey.vt = VT_BSTR;
        vtKey.bstrVal = ::SysAllocString(bstrName);
        if (NULL == vtKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK(hr);
        }

        hr = piTaskpadViewDefs->Remove(vtKey);
        IfFailGo(hr);
    }

Error:
    FREESTRING(bstrName);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteTaskpadView(CSelectionHolder *pTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteTaskpadView
(
    CSelectionHolder *pTaskpadView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    ITaskpadViewDefs  *piTaskpadViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pTaskpadView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pTaskpadView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pTaskpadView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pTaskpadView);
    IfFailGo(hr);

    delete pTaskpadView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        hr = piTaskpadViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowTaskpadViewProperties(ITaskpadViewDef *piTaskpadViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowTaskpadViewProperties
(
    ITaskpadViewDef *piTaskpadViewDef
)
{
    HRESULT         hr = S_OK;
    int             iResult = 0;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[3];

    hr = GetResourceString(IDS_TASK_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piTaskpadViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_TaskpadViewDefGeneralPP;
    pageClsID[1] = CLSID_TaskpadViewDefBackgroundPP;
    pageClsID[2] = CLSID_TaskpadViewDefTasksPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 3;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDef *piTaskpadViewDef, CSelectionHolder **ppTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewTaskpadView
(
    ITaskpadViewDefs  *piTaskpadViewDefs,
    ITaskpadViewDef   *piTaskpadViewDef,
    CSelectionHolder **ppTaskpadView
)
{
    HRESULT                hr = S_OK;

    *ppTaskpadView = New CSelectionHolder(piTaskpadViewDef);
    if (NULL == *ppTaskpadView)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewTaskpadView(piTaskpadViewDefs, *ppTaskpadView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewTaskpadView(ITaskpadViewDefs *piTaskpadViewDefs, CSelectionHolder *pTaskpadView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewTaskpadView
(
    ITaskpadViewDefs  *piTaskpadViewDefs,
    CSelectionHolder  *pTaskpadView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 0;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pTaskpadViewDefClone = NULL;
    ITaskpad         *piTaskpad = NULL;

    ASSERT(NULL != piTaskpadViewDefs, "InitializeNewTaskpadView: piTaskpadViewDefs is NULL");
    ASSERT(NULL != pTaskpadView, "InitializeNewTaskpadView: pTaskpadView is NULL");

    hr = piTaskpadViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewTaskpadView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_TASK_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, ++iItemNumber);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pTaskpadViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Key(bstrName);
        IfFailGo(hr);

        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        hr = piTaskpad->put_Name(bstrName);
        IfFailGo(hr);
    }

    hr = pTaskpadView->RegisterHolder();
    IfFailGo(hr);

Error:
    RELEASE(piTaskpad);
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertTaskpadViewInTree(CSelectionHolder *pTaskpadView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertTaskpadViewInTree
(
    CSelectionHolder *pTaskpadView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pTaskpadView->m_piObject.m_piTaskpadViewDef->get_Key(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kTaskpadIcon, pTaskpadView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Support functions to manipulate IViewDef's
// Searching
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetOwningViewCollection(IViewDefs **ppiViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetOwningViewCollection
(
    IViewDefs **ppiViewDefs
)
{
    HRESULT              hr = S_OK;

    hr = GetOwningViewCollection(m_pCurrentSelection, ppiViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetOwningViewCollection(CSelectionHolder *pView, IViewDefs **ppiViewDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::GetOwningViewCollection
(
    CSelectionHolder *pView,
    IViewDefs       **ppiViewDefs
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;
    ISnapInDef          *piSnapInDef = NULL;

    switch (pView->m_st)
    {
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
        IfFailGo(hr);

        hr = piSnapInDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_VIEWS:
    case SEL_VIEWS_LIST_VIEWS_NAME:
    case SEL_VIEWS_OCX_NAME:
    case SEL_VIEWS_URL_NAME:
    case SEL_VIEWS_TASK_PAD_NAME:
        hr = m_pTreeView->GetParent(pView, &pParent);
        IfFailGo(hr);

        switch (pParent->m_st)
        {
        case SEL_NODES_ANY_NAME:
        case SEL_NODES_ANY_VIEWS:
            hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(ppiViewDefs);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
            hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
            IfFailGo(hr);

            hr = piSnapInDef->get_ViewDefs(ppiViewDefs);
            IfFailGo(hr);
            break;

        default:
            ASSERT(0, "Unexpected parent");
        }
        break;

    case SEL_NODES_ANY_NAME:
        hr = pView->m_piObject.m_piScopeItemDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_ROOT:
        hr = m_piSnapInDesignerDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:
        hr = m_piSnapInDesignerDef->get_ViewDefs(ppiViewDefs);
        IfFailGo(hr);
        break;
    }

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsSatelliteView(CSelectionHolder *pView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return S_OK if this view is part of a satellite collection, S_FALSE otherwise.
//
HRESULT CSnapInDesigner::IsSatelliteView(CSelectionHolder *pView)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    hr = m_pTreeView->GetParent(pView, &pParent);
    IfFailGo(hr);

    switch (pParent->m_st)
    {
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:
        hr = S_FALSE;
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::IsSatelliteCollection(CSelectionHolder *pViewCollection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Return S_OK if collection is a satellite collection, S_FALSE otherwise.
//
HRESULT CSnapInDesigner::IsSatelliteCollection(CSelectionHolder *pViewCollection)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pParent = NULL;

    switch (pViewCollection->m_st)
    {
        // Possible parent nodes of a view:
    case SEL_NODES_AUTO_CREATE_RTVW:
        // Anything off of SnapIn/Auto-Create/Static Node/Views is a satellite collection
        break;

    case SEL_NODES_ANY_VIEWS:
        // Anything off of SnapIn/Auto-Create/Static Node/<name>/Views, recursively, and
        // anything off of SnapIn/Other/<name>/Views is a satellite collection
        break;

    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:
        // If these depend off of SnapIn/Views then they are NOT a satellite collection
        hr = m_pTreeView->GetParent(pViewCollection, &pParent);
        IfFailGo(hr);

        switch (pParent->m_st)
        {
        case SEL_VIEWS_ROOT:
            hr = S_FALSE;
            break;
        }
        break;

    default:
        ASSERT(0, "IsSatelliteCollection: wrong argument");
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\snaputil.h ===
//=--------------------------------------------------------------------------=
// snaputil.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Utitlity Routines for the SnapIn Designer
//

#ifndef _SNAPUTIL_H_
#define _SNAPUTIL_H_



class CGlobalHelp;

extern CGlobalHelp g_GlobalHelp;

class CGlobalHelp
{
public:
    CGlobalHelp();
    ~CGlobalHelp();

public:
    static VOID CALLBACK MsgBoxCallback(LPHELPINFO lpHelpInfo);
    static HRESULT ShowHelp(DWORD dwHelpContextId);
    static void Attach(IHelp* pIHelp);
    static void Detach();
    static char *GetDesignerName();

private:
    static IHelp *m_pIHelp;
    static DWORD  m_cSnapInDesigners;
    static char   m_szDesignerName[256];
    static BOOL   m_fHaveDesignerName;
};


enum MessageOptions { AppendErrorInfo, DontAppendErrorInfo };

HRESULT cdecl SDU_DisplayMessage // Displays a formatted message from STRINGTABLE
(
    UINT            idMessage,
    UINT            uMsgBoxOpts,
    DWORD           dwHelpContextID,
    HRESULT         hrDisplay,
    MessageOptions  Options,
    int            *pMsgBoxRet,
    ...
);


////////////////////////////////////////////////////////////////////
// String conversion functions

HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi);
HRESULT WideStrFromANSI(const char *pszAnsi, WCHAR **ppwszWideStr);

HRESULT ANSIFromBSTR(BSTR bstr, TCHAR **ppszAnsi);
HRESULT BSTRFromANSI(const TCHAR *pszAnsi, BSTR *pbstr);

HRESULT GetResourceString(int iStringID, char *pszBuffer, int iBufferLen);



////////////////////////////////////////////////////////////////////
// Misc. Utility Functions

// Synthesize a display name for an extended snap-in from its node type name
// and node type GUID

HRESULT GetExtendedSnapInDisplayName(IExtendedSnapIn  *piExtendedSnapIn,
                                     char            **ppszDisplayName);

#endif  // _SNAPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\treeview.cpp ===
//=--------------------------------------------------------------------------------------
// TreeView.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CTreeView implementation
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// These are the bitmap resource IDs that match the icon list.

static const UINT rgImageListBitmaps[] =
{
    /* kOpenFolderIcon      */  IDB_BITMAP_OPEN_FOLDER,
    /* kClosedFolderIcon    */  IDB_BITMAP_CLOSED_FOLDER,
    /* kScopeItemIcon       */  IDB_BITMAP_SCOPE_ITEM,
    /* kImageListIcon       */  IDB_BITMAP_IMAGE_LIST,
    /* kMenuIcon            */  IDB_BITMAP_MENU,
    /* kToolbarIcon         */  IDB_BITMAP_TOOLBAR,
    /* kListViewIcon        */  IDB_BITMAP_LIST_VIEW,
    /* kOCXViewIcon         */  IDB_BITMAP_OCX_VIEW,
    /* kURLViewIcon         */  IDB_BITMAP_URL_VIEW,
    /* kTaskpadIcon         */  IDB_BITMAP_TASKPAD,
    /* kDataFmtIcon         */  IDB_BITMAP_DATAFMT
};

const int   gcImages = 11;


//=--------------------------------------------------------------------------------------
// CTreeView::CTreeView
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Intialize member variables
//
CTreeView::CTreeView() : m_hTreeView(0), m_fnTreeProc(0)
{
}


//=--------------------------------------------------------------------------------------
// CTreeView::~CTreeView
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Ensure all dynamically allocated objects are freed
//
CTreeView::~CTreeView()
{
    Clear();

    if (NULL != m_hTreeView) {
        ImageList_Destroy(TreeView_GetImageList(m_hTreeView, TVSIL_NORMAL));
        ::DestroyWindow(m_hTreeView);
    }
}


//=--------------------------------------------------------------------------------------
// CTreeView::Initialize
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Build the initial view
//
HRESULT CTreeView::Initialize
(
    HWND  hwndParent,
    RECT& rc
)
{
    HRESULT     hr = S_OK;
    HIMAGELIST  hImageList = NULL;
    char        szzWindowName[1];
    DWORD       dwStyle = WS_CHILD | WS_VISIBLE | TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS | TVS_EDITLABELS | TVS_SHOWSELALWAYS;
    size_t      i = 0;

    if (NULL != m_hTreeView)
        return S_OK;

    szzWindowName[0] = 0;

    hr = CreateImageList(&hImageList);
    IfFailGo(hr);

    m_hTreeView = ::CreateWindowEx(0,
                                   WC_TREEVIEW,
                                   szzWindowName,
                                   dwStyle,
                                   0,
                                   rc.top,
                                   rc.right - rc.left,
                                   rc.bottom - rc.top,
                                   hwndParent,
                                   reinterpret_cast<HMENU>(1),
                                   GetResourceHandle(),
                                   NULL);
    if (NULL == m_hTreeView)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    TreeView_SetImageList(m_hTreeView, hImageList, TVSIL_NORMAL);

    ::SetWindowLong(m_hTreeView, GWL_USERDATA, reinterpret_cast<LONG>(this));

    m_fnTreeProc = reinterpret_cast<WNDPROC>(::SetWindowLong(m_hTreeView, GWL_WNDPROC, reinterpret_cast<LONG>(CTreeView::DesignerTreeWindowProc)));
    if (NULL == m_fnTreeProc)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::CreateImageList(HIMAGELIST *phImageList)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//
HRESULT CTreeView::CreateImageList
(
    HIMAGELIST *phImageList
)
{
    HRESULT     hr = S_OK;
    HBITMAP     hBitmap = NULL;
    int         i = 0;
    int         iResult = 0;
    HIMAGELIST  hImageList = NULL;

    hImageList = ImageList_Create(16,
                                  16,
                                  0,
                                  1,
                                  0);
    if (hImageList == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    for (i = 0; i < gcImages; i++)
    {
        hBitmap = ::LoadBitmap(GetResourceHandle(), MAKEINTRESOURCE(rgImageListBitmaps[i]));
        if (hBitmap == NULL)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }


        iResult = ImageList_Add(hImageList, hBitmap, NULL);
        if (iResult == -1)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        DeleteObject(hBitmap);
        hBitmap = NULL;
    }

    *phImageList = hImageList;

Error:
    if (NULL != hBitmap)
        DeleteObject(hBitmap);

    if (FAILED(hr))
    {
        if (hImageList != NULL)
            ImageList_Destroy(hImageList);

        *phImageList = NULL;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::DesignerTreeWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//
LRESULT CALLBACK CTreeView::DesignerTreeWindowProc
(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT    hr = S_OK;
    CTreeView *pView = NULL;
    LRESULT    lResult = TRUE;

    pView = reinterpret_cast<CTreeView *>(::GetWindowLong(hwnd, GWL_USERDATA));
    if (pView == NULL)
        return DefWindowProc(hwnd, msg, wParam, lParam);
    else if (hwnd == pView->m_hTreeView)
    {
        switch (msg)
        {
        case WM_SETFOCUS:
//            hr = pView->OnGotFocus(msg, wParam, lParam, &lResult);
//            CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);
            break;
        }
    }

    return ::CallWindowProc(pView->m_fnTreeProc, hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Clear()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Called upon termination to clear the tree and all selection holders.
//
HRESULT CTreeView::Clear()
{
    HRESULT  hr = S_OK;
    BOOL     fRet = FALSE;

    hr = ClearTree(TVI_ROOT);
    IfFailGo(hr);

    fRet = TreeView_DeleteAllItems(m_hTreeView);
    if (fRet != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::ClearTree(HTREEITEM hItemParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::ClearTree
(
    HTREEITEM hItemParent
)
{
    HRESULT            hr = S_OK;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = ClearTree(hItemChild);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
            delete pSelection;

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::RenameAllSatelliteViews(CSelectionHolder *pView, TCHAR *pszNewViewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::RenameAllSatelliteViews
(
    CSelectionHolder *pView,
    TCHAR            *pszNewViewName
)
{
    HRESULT            hr = S_FALSE;

    hr = RenameAllSatelliteViews(TVI_ROOT, pView, pszNewViewName);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::RenameAllSatelliteViews(HTREEITEM hItemParent, CSelectionHolder *pView, TCHAR *pszNewViewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::RenameAllSatelliteViews
(
    HTREEITEM          hItemParent,
    CSelectionHolder  *pView,
    TCHAR             *pszNewViewName
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    IUnknown          *piunkView = NULL;
    IUnknown          *piunkTargetView = NULL;

    hr = pView->GetIUnknown(&piunkView);
    IfFailGo(hr);

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = RenameAllSatelliteViews(hItemChild, pView, pszNewViewName);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection != pView && pSelection->m_st == pView->m_st)
        {
            hr = pSelection->GetIUnknown(&piunkTargetView);
            IfFailGo(hr);

            if (piunkTargetView == piunkView)
            {
                hr = ChangeText(pSelection, pszNewViewName);
                IfFailGo(hr);
            }

            RELEASE(piunkTargetView);
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RELEASE(piunkTargetView);
    RELEASE(piunkView);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindInTree(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Attempts to find a CSelectionHolder in the tree that resolves to the argument piUnknown.
// If found, returns it in the [out] parameter ppSelectionHolder and the return value
// of the function is S_OK, otherwise the return value is S_FALSE.
// Search is depth-first.
//
HRESULT CTreeView::FindInTree
(
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;

    hr = FindInTree(TVI_ROOT, piUnknown, ppSelectionHolder);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindInTree(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindInTree
(
    HTREEITEM          hItemParent,
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    IUnknown          *piUnknownTarget = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        hr = pSelection->GetIUnknown(&piUnknownTarget);
        IfFailGo(hr);

        if (piUnknownTarget == piUnknown)
        {
            *ppSelectionHolder = pSelection;
            hr = S_OK;
            goto Error;
        }

        hr = FindInTree(hItemChild, piUnknown, ppSelectionHolder);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            goto Error;
        }

        RELEASE(piUnknownTarget);
        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RELEASE(piUnknownTarget);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindSelectableObject(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindSelectableObject
(
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;

    hr = FindSelectableObject(TVI_ROOT, piUnknown, ppSelectionHolder);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindSelectableObject(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindSelectableObject
(
    HTREEITEM          hItemParent,
    IUnknown          *piUnknown,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    IUnknown          *piUnknownTarget = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        hr = pSelection->GetSelectableObject(&piUnknownTarget);
        IfFailGo(hr);

        if (piUnknownTarget == piUnknown)
        {
            *ppSelectionHolder = pSelection;
            hr = S_OK;
            goto Error;
        }

        hr = FindSelectableObject(hItemChild, piUnknown, ppSelectionHolder);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            goto Error;
        }

        RELEASE(piUnknownTarget);
        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RELEASE(piUnknownTarget);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindLabelInTree(TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindLabelInTree
(
    TCHAR             *pszLabel,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_OK;

    hr = FindLabelInTree(TVI_ROOT, pszLabel, ppSelectionHolder);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::FindLabelInTree(HTREEITEM hItemParent, TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::FindLabelInTree
(
    HTREEITEM          hItemParent,
    TCHAR             *pszLabel,
    CSelectionHolder **ppSelectionHolder
)
{
    HRESULT            hr = S_OK;
    HTREEITEM          hItemChild = NULL;
    TVITEM             tv;
    TCHAR              pszBuffer[1024];
    BOOL               bReturn = FALSE;
    CSelectionHolder  *pSelection = NULL;

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        pszBuffer[0] = 0;
        ::memset(&tv, 0, sizeof(TVITEM));
        tv.mask = TVIF_TEXT;
        tv.hItem = hItemChild;
        tv.pszText = pszBuffer;
        tv.cchTextMax = 1023;
        bReturn = TreeView_GetItem(m_hTreeView, &tv);

        if (TRUE == bReturn)
        {
            if (0 == _tcscmp(pszBuffer, pszLabel))
            {
                *ppSelectionHolder = pSelection;
                hr = S_OK;
                goto Error;
            }
        }

        hr = FindLabelInTree(hItemChild, pszLabel, ppSelectionHolder);
        IfFailGo(hr);

        if (S_OK == hr)
        {
            goto Error;
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

    hr = S_FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::CountSelectableObjects(long *plCount)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the number of non-virtual selection holders in the tree.
//
HRESULT CTreeView::CountSelectableObjects
(
    long        *plCount
)
{
    HRESULT            hr = S_FALSE;

    hr = Count(TVI_ROOT, plCount);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Count(HTREEITEM hItemParent, long *plCount)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::Count
(
    HTREEITEM    hItemParent,
    long        *plCount
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    CSelectionHolder  *pParentSelection = NULL;

    // If this item is 
    // Nodes\Auto-Create\Static Node\ResultViews or
    // <any node>\ResultViews then don't count its children as they
    // will be counted under SnapIn1\ResultViews\ListViews etc.

    if (TVI_ROOT != hItemParent)
    {
        hr = GetItemParam(hItemParent, &pParentSelection);
        IfFailGo(hr);

        if ( (SEL_NODES_AUTO_CREATE_RTVW == pParentSelection->m_st) ||
             (SEL_NODES_ANY_VIEWS == pParentSelection->m_st) )
        {
            goto Error; // nothing to do
        }
    }

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = Count(hItemChild, plCount);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection->IsVirtual() == false)
        {
            ++(*plCount);
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::CollectSelectableObjects(IUnknown *piUnknown[], long *plOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Collect all non-virtual selection holders in piUnknown array.
//
HRESULT CTreeView::CollectSelectableObjects
(
    IUnknown    *ppiUnknown[],
    long        *plOffset
)
{
    HRESULT            hr = S_FALSE;

    hr = Collect(TVI_ROOT, ppiUnknown, plOffset);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Collect(HTREEITEM hItemParent, IUnknown *ppiUnknown[], long *plOffset)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::Collect
(
    HTREEITEM    hItemParent,
    IUnknown    *ppiUnknown[],
    long        *plOffset
)
{
    HRESULT            hr = S_FALSE;
    HTREEITEM          hItemChild = NULL;
    CSelectionHolder  *pSelection = NULL;
    CSelectionHolder  *pParentSelection = NULL;

    // If this item is 
    // Nodes\Auto-Create\Static Node\ResultViews or
    // <any node>\ResultViews then don't collect its children as they
    // will be collected under SnapIn1\ResultViews\ListViews etc.

    if (TVI_ROOT != hItemParent)
    {
        hr = GetItemParam(hItemParent, &pParentSelection);
        IfFailGo(hr);

        if ( (SEL_NODES_AUTO_CREATE_RTVW == pParentSelection->m_st) ||
             (SEL_NODES_ANY_VIEWS == pParentSelection->m_st) )
        {
            goto Error; // nothing to do
        }
    }

    hItemChild = TreeView_GetChild(m_hTreeView, hItemParent);
    while (hItemChild != NULL)
    {
        hr = Collect(hItemChild, ppiUnknown, plOffset);
        IfFailGo(hr);

        hr = GetItemParam(hItemChild, &pSelection);
        IfFailGo(hr);

        if (pSelection->IsVirtual() == false)
        {
            hr = pSelection->GetSelectableObject(&(ppiUnknown[*plOffset]));
            IfFailGo(hr);

            ++(*plOffset);
        }

        hItemChild = TreeView_GetNextSibling(m_hTreeView, hItemChild);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::AddNode(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add a node to the tree.
//
HRESULT CTreeView::AddNode
(
    const char        *pszNodeName,
    CSelectionHolder  *pParent,
    int                iImage,
    CSelectionHolder  *pItem
)
{
    HRESULT         hr = S_OK;
    HTREEITEM       hParent = NULL;
    BOOL            fRet = FALSE;
    TV_INSERTSTRUCT is;
    HTREEITEM       hItem = NULL;

    ASSERT(pszNodeName != NULL, "Parameter pszNodeName is NULL");
    ASSERT(pItem != NULL, "Parameter pItem is NULL");

    if (pParent == NULL)
        hParent = TVI_ROOT;
    else
        hParent = reinterpret_cast<HTREEITEM>(pParent->m_pvData);

    is.hParent = hParent;
    is.hInsertAfter = TVI_LAST;
    is.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    is.item.hItem = 0;
    is.item.state = 0;
    is.item.stateMask = 0;
    is.item.pszText = const_cast<char *>(pszNodeName);
    is.item.cchTextMax = ::strlen(pszNodeName);
    is.item.iImage = iImage;
    is.item.iSelectedImage = iImage;
    is.item.cChildren = 0;
    is.item.lParam = reinterpret_cast<LPARAM>(pItem);

    hItem = TreeView_InsertItem(m_hTreeView, &is);
    if (hItem == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Is it a big deal if fRet is false?
    fRet = TreeView_EnsureVisible(m_hTreeView, hItem);

    pItem->m_pvData = hItem;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::AddNodeAfter(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pPrevious, CSelectionHolder *pItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Add a node to the tree.
//
// If pParent is NULL then insert at root of tree
// If pPrevious is NULL then inserts at top of subtree owned by parent
//
HRESULT CTreeView::AddNodeAfter
(
    const char        *pszNodeName,
    CSelectionHolder  *pParent,
    int                iImage,
    CSelectionHolder  *pPrevious,
    CSelectionHolder  *pItem
)
{
    HRESULT         hr = S_OK;
    HTREEITEM       hParent = NULL;
    HTREEITEM       hPrevious = NULL;
    BOOL            fRet = FALSE;
    TV_INSERTSTRUCT is;
    HTREEITEM       hItem = NULL;

    ASSERT(pszNodeName != NULL, "Parameter pszNodeName is NULL");
    ASSERT(pItem != NULL, "Parameter pItem is NULL");

    // If there is no parent then insert at root of tree

    if (pParent == NULL)
        hParent = TVI_ROOT;
    else
        hParent = reinterpret_cast<HTREEITEM>(pParent->m_pvData);

    // If there is no previous then insert at top of subtree owned by parent

    if (NULL == pPrevious)
    {
        hPrevious = TVI_FIRST;
    }
    else
    {
        hPrevious = reinterpret_cast<HTREEITEM>(pPrevious->m_pvData);;
    }

    is.hParent = hParent;
    is.hInsertAfter = hPrevious;
    is.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    is.item.hItem = 0;
    is.item.state = 0;
    is.item.stateMask = 0;
    is.item.pszText = const_cast<char *>(pszNodeName);
    is.item.cchTextMax = ::strlen(pszNodeName);
    is.item.iImage = iImage;
    is.item.iSelectedImage = iImage;
    is.item.cChildren = 0;
    is.item.lParam = reinterpret_cast<LPARAM>(pItem);

    hItem = TreeView_InsertItem(m_hTreeView, &is);
    if (hItem == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Is it a big deal if fRet is false?
    fRet = TreeView_EnsureVisible(m_hTreeView, hItem);

    pItem->m_pvData = hItem;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::DeleteNode(CSelectionHolder *pItem)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::DeleteNode(CSelectionHolder *pItem)
{
    HRESULT     hr = S_OK;
    BOOL        bResult = FALSE;

    bResult = TreeView_DeleteItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pItem->m_pvData));

//Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetItemParam(CSelectionHolder *pItem, CSelectionHolder **ppObject)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the selection holder located in pItem->pvData in the tree.
//
HRESULT CTreeView::GetItemParam
(
    CSelectionHolder  *pItem,
    CSelectionHolder **ppObject
)
{
    HRESULT     hr = S_OK;
    TV_ITEM     tvItem;

    ASSERT(m_hTreeView != NULL, "m_hTreeView is NULL");
    ASSERT(pItem != NULL, "pItem is NULL");
    ASSERT(ppObject != NULL, "ppObject is NULL");

    memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.hItem = reinterpret_cast<HTREEITEM>(pItem->m_pvData);
    tvItem.mask = TVIF_PARAM;

    TreeView_GetItem(m_hTreeView, &tvItem);
    if (tvItem.lParam == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *ppObject = reinterpret_cast<CSelectionHolder *>(tvItem.lParam);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetItemParam(HTREEITEM hItem, CSelectionHolder **ppObject)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the selection holder located in hItem in the tree.
//
HRESULT CTreeView::GetItemParam
(
    HTREEITEM          hItem,
    CSelectionHolder **ppObject
)
{
    HRESULT     hr = S_OK;
    TV_ITEM     tvItem;

    ASSERT(m_hTreeView != NULL, "m_hTreeView is NULL");
    ASSERT(hItem != NULL, "hItem is NULL");
    ASSERT(ppObject != NULL, "ppObject is NULL");

    memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.hItem = hItem;
    tvItem.mask = TVIF_PARAM;

    TreeView_GetItem(m_hTreeView, &tvItem);
    if (tvItem.lParam == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    *ppObject = reinterpret_cast<CSelectionHolder *>(tvItem.lParam);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::ChangeText(CSelectionHolder *pItem, char *pszNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Change the text of the node pointed by pItem to be pszNewName.
//
HRESULT CTreeView::ChangeText
(
    CSelectionHolder *pItem,
    char             *pszNewName
)
{
    HRESULT		hr = S_OK;
    TV_ITEM		tvItem;
    BOOL		fResult = FALSE;

    ::memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.mask = TVIF_TEXT;
    tvItem.hItem = (HTREEITEM) pItem->m_pvData;
    tvItem.pszText = pszNewName;
    tvItem.cchTextMax = ::strlen(pszNewName);

    fResult = TreeView_SetItem(m_hTreeView, &tvItem);
    if (fResult != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::ChangeNodeIcon(CSelectionHolder *pItem, int iImage)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Change the the icon of the node pointed by pItem to be iImage
//
HRESULT CTreeView::ChangeNodeIcon
(
    CSelectionHolder *pItem,
    int               iImage
)
{
    HRESULT     hr = S_OK;
    TV_ITEM     tvItem;
    BOOL        fResult = FALSE;

    ::memset(&tvItem, 0, sizeof(TV_ITEM));

    tvItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvItem.hItem = reinterpret_cast<HTREEITEM>(pItem->m_pvData);
    tvItem.iImage = iImage;
    tvItem.iSelectedImage = iImage;

    fResult = TreeView_SetItem(m_hTreeView, &tvItem);
    if (fResult != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::HitTest(POINT pHit, CSelectionHolder **ppSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Return the selection holder located at the coordinates pHit.
//
HRESULT CTreeView::HitTest
(
    POINT              pHit,
    CSelectionHolder **ppSelection
)
{
    HRESULT          hr = S_OK;
    TV_HITTESTINFO   hti;
    HTREEITEM        hItem = NULL;
    CSelectionHolder item;

    ASSERT(NULL != ppSelection, "HitTest: ppSelection is NULL");
    ASSERT(NULL != m_hTreeView, "HitTest: m_hTreeView is NULL");

    *ppSelection = NULL;

    hti.pt.x = pHit.x;
    hti.pt.y = pHit.y;

    hItem = TreeView_HitTest(m_hTreeView, &hti);

    if (NULL != hItem)
    {
        item.m_pvData = hItem;

        hr = GetItemParam(&item, ppSelection);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetRectangle(CSelectionHolder *pSelection, RECT *prc)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetRectangle
(
    CSelectionHolder *pSelection,
    RECT             *prc
)
{
    HRESULT         hr = S_OK;
    BOOL            bResult = FALSE;

    bResult = TreeView_GetItemRect(m_hTreeView,
                                   reinterpret_cast<HTREEITEM>(pSelection->m_pvData),
                                   prc,
                                   TRUE);
    if (bResult != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::SelectItem(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Select the tree node pointed by pSelection.
//
HRESULT CTreeView::SelectItem
(
    CSelectionHolder *pSelection
)
{
    HRESULT		hr = S_OK;
    BOOL		fReturn = FALSE;

    ASSERT(m_hTreeView != NULL, "SelectItem: m_hTreeView is NULL");
    ASSERT(pSelection != NULL, "SelectItem: pSelection i NULL");

    fReturn = TreeView_SelectItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData));
    if (fReturn != TRUE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::Edit(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Select the tree node pointed by pSelection.
//
HRESULT CTreeView::Edit(CSelectionHolder *pSelection)
{
    HRESULT		hr = S_OK;

    TreeView_EditLabel(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetParent(CSelectionHolder *pSelection, CSelectionHolder **ppParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Select the tree node pointed by pSelection.
//
HRESULT CTreeView::GetParent
(
    CSelectionHolder  *pSelection,
    CSelectionHolder **ppParent
)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hParent = NULL;

    ASSERT(m_hTreeView != NULL, "GetParent: m_hTreeView is NULL");
    ASSERT(pSelection != NULL, "GetParent: pSelection i NULL");

    hParent = TreeView_GetParent(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData));
    if (hParent == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetItemParam(hParent, ppParent);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetFirstChildNode(CSelectionHolder *pSelection, CSelectionHolder **ppChild)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetFirstChildNode(CSelectionHolder *pSelection, CSelectionHolder **ppChild)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hChild = NULL;

    *ppChild = NULL;

    hChild = TreeView_GetNextItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pSelection->m_pvData), TVGN_CHILD);
    if (NULL == hChild)
    {
        // Maybe an error or no children
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (FAILED(hr))
        {
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            hr = S_FALSE;
            goto Error;
        }
    }

    hr = GetItemParam(hChild, ppChild);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetNextChildNode(CSelectionHolder *pChild, CSelectionHolder **ppNextChild)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetNextChildNode(CSelectionHolder *pChild, CSelectionHolder **ppNextChild)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hNextChild = NULL;

    *ppNextChild = NULL;

    hNextChild = TreeView_GetNextItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pChild->m_pvData), TVGN_NEXT);
    if (NULL == hNextChild)
    {
        // Maybe an error or no more children
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (FAILED(hr))
        {
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            hr = S_FALSE;
            goto Error;
        }
    }

    hr = GetItemParam(hNextChild, ppNextChild);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetPreviousNode(CSelectionHolder *pNode, CSelectionHolder **ppPreviousNode)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetPreviousNode(CSelectionHolder *pNode, CSelectionHolder **ppPreviousNode)
{
    HRESULT		hr = S_OK;
    HTREEITEM   hPreviousNode = NULL;

    hPreviousNode = TreeView_GetNextItem(m_hTreeView, reinterpret_cast<HTREEITEM>(pNode->m_pvData), TVGN_PREVIOUS);
    if (NULL == hPreviousNode)
    {
        // Maybe an error or no more children
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (FAILED(hr))
        {
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            hr = S_FALSE;
            goto Error;
        }
    }

    hr = GetItemParam(hPreviousNode, ppPreviousNode);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel)
{
    HRESULT     hr = S_OK;
    BOOL        bResult = FALSE;
    TVITEM      tv;
    char        buffer[1024];

    ::memset(&tv, 0, sizeof(TVITEM));
    tv.mask = TVIF_TEXT;
    tv.hItem = reinterpret_cast<HTREEITEM>(pSelection->m_pvData);
    tv.pszText = buffer;
    tv.cchTextMax = 1023;

    bResult = TreeView_GetItem(m_hTreeView, &tv);
    if (TRUE == bResult)
    {
        hr = BSTRFromANSI(buffer, pbstrLabel);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CTreeView::GetLabelA(CSelectionHolder *pSelection, char *pszBuffer, int cbBuffer)
{
    HRESULT     hr = S_OK;
    TVITEM      tv;

    ::memset(&tv, 0, sizeof(TVITEM));
    tv.mask = TVIF_TEXT;
    tv.hItem = reinterpret_cast<HTREEITEM>(pSelection->m_pvData);
    tv.pszText = pszBuffer;
    tv.cchTextMax = cbBuffer;

    IfFalseGo(TreeView_GetItem(m_hTreeView, &tv), E_FAIL);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::PruneAndGraft()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Grafts the specified node and any subtree to the new parent node. Removes
// the node and any subtree from its old parent.
//
HRESULT CTreeView::PruneAndGraft
(
    CSelectionHolder *pNode,
    CSelectionHolder *pNewParentNode,
    int               iImage
)
{
    HRESULT hr = S_OK;

    CSelectionHolder OldNode;
    ::ZeroMemory(&OldNode, sizeof(OldNode));

    // Create a shallow copy of the node so we can use it later to delete it
    // from the treeview. The only significant piece of information in the
    // clone is the HTREEITEM in CSelectionHolder.m_pvData as that is used
    // by CTreeView::GetFirstChildNode. This allows us to make a simple copy
    // rather than AddRef()ing the contained object.

    OldNode = *pNode;

    // Replicate the old node and any potential sub-tree onto the new parent

    IfFailGo(Graft(pNode, pNewParentNode, iImage));

    // Delete the old node and any potential sub-tree from the treeview. Use
    // the clone we created above as it contains the old HTREEITEM.

    IfFailGo(DeleteNode(&OldNode));

Error:

    // Clean out the clone so that the CSelectionHolder destructor doesn't
    // release the object as it is still owned by the original CSelectionHolder.

    ::ZeroMemory(&OldNode, sizeof(OldNode));

    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CTreeView::Graft()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Grafts the specified node and any subtree to the new parent node.
//
HRESULT CTreeView::Graft
(
    CSelectionHolder *pNode,
    CSelectionHolder *pNewParentNode,
    int               iImage
)
{
    HRESULT           hr = S_OK;
    char              szNodeLabel[512] = "";
    CSelectionHolder *pNextChild = NULL;

    CSelectionHolder OldNode;
    ::ZeroMemory(&OldNode, sizeof(OldNode));

    CSelectionHolder OldChild;
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    // Create a shallow copy of the node so we can use it later to get its 1st
    // child from the treeview. The only significant piece of information in the
    // clone is the HTREEITEM in CSelectionHolder.m_pvData as that is used
    // by CTreeView::GetFirstChildNode. This allows us to make a simple copy
    // rather than AddRef()ing the contained object.

    OldNode = *pNode;

    // Get the node's label

    IfFailGo(GetLabelA(pNode, szNodeLabel, sizeof(szNodeLabel)));

    // Create a new node in the treeview under the new parent and give it
    // ownership of the existing CSelectionHolder. This will replace the
    // HTREEITEM in CSelectionHolder.m_pvData.

    IfFailGo(AddNode(szNodeLabel, pNewParentNode, iImage, pNode));

    // If the old node has children then add them to the new node

    IfFailGo(GetFirstChildNode(&OldNode, &pNextChild));

    while (S_OK == hr)
    {
        // Clone the child because the recursive call to this function will
        // change its HTREEITEM.
        OldChild = *pNextChild;

        IfFailGo(Graft(pNextChild, pNode, iImage));
        IfFailGo(GetNextChildNode(&OldChild, &pNextChild));
    }

Error:

    // Clean out the clones so that the CSelectionHolder destructor doesn't
    // release the object as it is still owned by the original CSelectionHolder.

    ::ZeroMemory(&OldNode, sizeof(OldNode));
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CTreeView::MoveNodeAfter()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// Moves pNode to the position immediately after pPreviousNode as a peer of
// pPreviousNode. Moves all children of pNode to the new position. Deletes the
// old pNode and all of its children.
//
HRESULT CTreeView::MoveNodeAfter
(
    CSelectionHolder *pNode,
    CSelectionHolder *pNewParentNode,
    CSelectionHolder *pPreviousNode,
    int               iImage
)
{
    HRESULT           hr = S_OK;
    char              szNodeLabel[512] = "";
    CSelectionHolder *pNextChild = NULL;

    CSelectionHolder OldNode;
    ::ZeroMemory(&OldNode, sizeof(OldNode));

    CSelectionHolder OldChild;
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    // Create a shallow copy of the node so we can use it later to delete it
    // from the treeview. The only significant piece of information in the
    // clone is the HTREEITEM in CSelectionHolder.m_pvData as that is used
    // by CTreeView::GetFirstChildNode. This allows us to make a simple copy
    // rather than AddRef()ing the contained object.

    OldNode = *pNode;

    // Get the node's label

    IfFailGo(GetLabelA(pNode, szNodeLabel, sizeof(szNodeLabel)));

    // Create a new node in the treeview after pPrevious and give it
    // ownership of the existing CSelectionHolder. This will replace the
    // HTREEITEM in CSelectionHolder.m_pvData.

    IfFailGo(AddNodeAfter(szNodeLabel, pNewParentNode, iImage,
                          pPreviousNode, pNode));

    // If the old node has children then add them to the new node

    IfFailGo(GetFirstChildNode(&OldNode, &pNextChild));

    while (S_OK == hr)
    {
        // Clone the child because the recursive call to this function will
        // change its HTREEITEM.
        OldChild = *pNextChild;

        IfFailGo(Graft(pNextChild, pNode, iImage));
        IfFailGo(GetNextChildNode(&OldChild, &pNextChild));
    }

    // Delete the old node and any potential sub-tree from the treeview. Use
    // the clone we created above as it contains the old HTREEITEM.

    IfFailGo(DeleteNode(&OldNode));

Error:

    // Clean out the clone so that the CSelectionHolder destructor doesn't
    // release the object as it is still owned by the original CSelectionHolder.

    ::ZeroMemory(&OldNode, sizeof(OldNode));
    ::ZeroMemory(&OldChild, sizeof(OldChild));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\tvcmd.cpp ===
//=--------------------------------------------------------------------------------------
// tvcmd.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Command multiplexers
// Deleting, properties
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingView(MMCViewMenuInfo *pMMCViewMenuInfo)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingView(MMCViewMenuInfo *pMMCViewMenuInfo)
{
    HRESULT           hr = S_OK;
    IViewDefs        *piViewDefs = NULL;
    CSelectionHolder *pParent = NULL;
    ISnapInDef       *piSnapInDef = NULL;

    if (m_pCurrentSelection != NULL)
    {
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_AUTO_CREATE_ROOT:
            hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
            IfFailGo(hr);

            hr = piSnapInDef->get_ViewDefs(&piViewDefs);
            IfFailGo(hr);
            break;

        case SEL_NODES_ANY_VIEWS:
            hr = m_pTreeView->GetParent(m_pCurrentSelection, &pParent);
            IfFailGo(hr);

            hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
            IfFailGo(hr);
            break;

        case SEL_NODES_ANY_NAME:
            hr = m_pCurrentSelection->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
            IfFailGo(hr);
            break;
        }
    }

    if (piViewDefs != NULL)
    {
        switch (pMMCViewMenuInfo->m_vmit)
        {
        case MMCViewMenuInfo::vmitListView:
            hr = AddExistingListView(piViewDefs, pMMCViewMenuInfo->m_view.m_piListViewDef);
            IfFailGo(hr);
            break;

        case MMCViewMenuInfo::vmitOCXView:
            hr = AddExistingOCXView(piViewDefs, pMMCViewMenuInfo->m_view.m_piOCXViewDef);
            IfFailGo(hr);
            break;

        case MMCViewMenuInfo::vmitURLView:
            hr = AddExistingURLView(piViewDefs, pMMCViewMenuInfo->m_view.m_piURLViewDef);
            IfFailGo(hr);
            break;

        case MMCViewMenuInfo::vmitTaskpad:
            hr = AddExistingTaskpadView(piViewDefs, pMMCViewMenuInfo->m_view.m_piTaskpadViewDef);
            IfFailGo(hr);
            break;
        }
    }

Error:
    RELEASE(piSnapInDef);
    RELEASE(piViewDefs);
    if (pMMCViewMenuInfo != NULL)
        delete pMMCViewMenuInfo;

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DoRename(CSelectionHolder *pSelection, TCHAR *pszNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
// The point here is to trigger an ObjectModel notification.
//
HRESULT CSnapInDesigner::DoRename(CSelectionHolder *pSelection, TCHAR *pszNewName)
{
    HRESULT     hr = S_OK;
    BSTR        bstrNewName = NULL;
    ISnapInDef *piSnapInDef = NULL;
    ITaskpad   *piTaskpad = NULL;

    hr = BSTRFromANSI(pszNewName, &bstrNewName);
    IfFailGo(hr);

    // Check that the new name is valid
    IfFailGo(ValidateName(bstrNewName));
    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:
        hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
        IfFailGo(hr);

        hr = piSnapInDef->put_Name(bstrNewName);
        IfFailGo(hr);

    case SEL_NODES_ANY_NAME:
        hr = pSelection->m_piObject.m_piScopeItemDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = pSelection->m_piObject.m_piListViewDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = pSelection->m_piObject.m_piURLViewDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = pSelection->m_piObject.m_piOCXViewDef->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = pSelection->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad);
        IfFailGo(hr);

        hr = piTaskpad->put_Name(bstrNewName);
        IfFailGo(hr);

        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = pSelection->m_piObject.m_piMMCImageList->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = pSelection->m_piObject.m_piMMCToolbar->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = pSelection->m_piObject.m_piMMCMenu->put_Name(bstrNewName);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = pSelection->m_piObject.m_piDataFormat->put_Name(bstrNewName);
        IfFailGo(hr);
        break;
    }

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_RENAME_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_RenameFailed, hr, AppendErrorInfo, NULL);
    }

    RELEASE(piSnapInDef);
    RELEASE(piTaskpad);
    FREESTRING(bstrNewName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DoDelete(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DoDelete(CSelectionHolder *pSelection)
{
    HRESULT     hr = S_OK;

    switch (pSelection->m_st)
    {
    case SEL_EEXTENSIONS_NAME:
        hr = DeleteExtendedSnapIn(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_CC_NEW:
        hr = DeleteExtensionNewMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_CC_TASK:
        hr = DeleteExtensionTaskMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_PP_ROOT:
        hr = DeleteExtensionPropertyPages(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_TASKPAD:
        hr = DeleteExtensionTaskpad(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_TOOLBAR:
        hr = DeleteExtensionToolbar(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EEXTENSIONS_NAMESPACE:
        hr = DeleteExtensionNameSpace(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_NEW_MENU:
        hr = DeleteMyExtendsNewMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_TASK_MENU:
        hr = DeleteMyExtendsTaskMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_TOP_MENU:
        hr = DeleteMyExtendsTopMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_VIEW_MENU:
        hr = DeleteMyExtendsViewMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_PPAGES:
        hr = DeleteMyExtendsPPages(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_TOOLBAR:
        hr = DeleteMyExtendsToolbar(pSelection);
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_NAMESPACE:
        hr = DeleteMyExtendsNameSpace(pSelection);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = DeleteScopeItem(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = DeleteListView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = DeleteOCXView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = DeleteURLView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = DeleteTaskpadView(pSelection);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = DeleteImageList(pSelection);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = DeleteMenu(pSelection);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = DeleteToolbar(pSelection);
        IfFailGo(hr);
        break;

    case SEL_XML_RESOURCE_NAME:
        hr = DeleteDataFormat(pSelection);
        IfFailGo(hr);
    }

Error:
    if (FAILED(hr))
    {
        (void)::SDU_DisplayMessage(IDS_DELETE_FAILED, MB_OK | MB_ICONHAND, HID_mssnapd_DeleteFailed, hr, AppendErrorInfo, NULL);
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowProperties(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowProperties
(
    CSelectionHolder *pSelection
)
{
    HRESULT                hr = S_OK;
    CSelectionHolder      *pParent = NULL;

    ASSERT(pSelection != NULL, "ShowProperties: pSelection is NULL");

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:

    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_NODES_OTHER:

    case SEL_TOOLS_ROOT:
    case SEL_TOOLS_IMAGE_LISTS:
    case SEL_TOOLS_MENUS:
    case SEL_TOOLS_TOOLBARS:
    case SEL_VIEWS_ROOT:
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_TASK_PAD:

    case SEL_XML_RESOURCES:
        hr = ShowSnapInProperties();
        IfFailGo(hr);
        break;

    case SEL_EXTENSIONS_ROOT:
        hr = ShowSnapInExtensions();
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_NAME:
        hr = ShowNodeProperties(pSelection->m_piObject.m_piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_NODES_ANY_CHILDREN:
    case SEL_NODES_ANY_VIEWS:
        hr = m_pTreeView->GetParent(pSelection, &pParent);
        IfFailGo(hr);

        ASSERT(SEL_NODES_ANY_NAME == pParent->m_st, "ShowProperties: Expected ScopeItem");

        hr = ShowNodeProperties(pParent->m_piObject.m_piScopeItemDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        hr = ShowListViewProperties(pSelection->m_piObject.m_piListViewDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_OCX_NAME:
        hr = ShowOCXViewProperties(pSelection->m_piObject.m_piOCXViewDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL_NAME:
        hr = ShowURLViewProperties(pSelection->m_piObject.m_piURLViewDef);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        hr = ShowTaskpadViewProperties(pSelection->m_piObject.m_piTaskpadViewDef);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_IMAGE_LISTS_NAME:
        hr = ShowImageListProperties(pSelection->m_piObject.m_piMMCImageList);
        IfFailGo(hr);
        break;

    case SEL_TOOLS_TOOLBARS_NAME:
        hr = ShowToolbarProperties(pSelection->m_piObject.m_piMMCToolbar);
        IfFailGo(hr);
    default:
        hr = S_FALSE;
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------
// Manipulating the ISnapInDef
// renaming and properties
//=--------------------------------------------------------------------------------------
//=--------------------------------------------------------------------------------------


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameSnapIn(CSelectionHolder *pSnapIn, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameSnapIn(CSelectionHolder *pSnapIn, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    ISnapInDef          *piSnapInDef = NULL;
    BSTR                 bstrOldName = NULL;
    TCHAR               *pszName = NULL;
    CSelectionHolder    *pExtension = NULL;

    ASSERT(SEL_SNAPIN_ROOT == pSnapIn->m_st, "RenameSnapIn: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pTreeView->GetLabel(pSnapIn, &bstrOldName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Name(&bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->ChangeText(pSnapIn, pszName);
    IfFailGo(hr);

    hr = m_pTreeView->GetFirstChildNode(m_pRootExtensions, &pExtension);
    IfFailGo(hr);

    while (SEL_EXTENSIONS_MYNAME != pExtension->m_st)
    {
        hr = m_pTreeView->GetNextChildNode(pExtension, &pExtension);
        IfFailGo(hr);
    }

    if (NULL != pExtension)
    {
        hr = m_pTreeView->ChangeText(pExtension, pszName);
        IfFailGo(hr);
    }

Error:
    if (NULL != pszName)
        CtlFree(pszName);
    RELEASE(piSnapInDef);
    FREESTRING(bstrOldName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowSnapInProperties()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowSnapInProperties()
{
    HRESULT              hr = S_OK;
    OCPFIPARAMS          ocpfiParams;
    TCHAR                szBuffer[kMaxBuffer + 1];
    BSTR                 bstrCaption = NULL;
    IUnknown            *pUnk[1];
    CLSID                pageClsID[2];
    ISnapInDef          *piSnapInDef = NULL;
    SnapInTypeConstants  OldSnapInType = siStandAlone;
    SnapInTypeConstants  NewSnapInType = siStandAlone;

    hr = GetResourceString(IDS_SNAPIN_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Store the snap-in type. If it changes in the property sheet then we
    // may need to adjust the tree by adding or removing the auto-creates
    // subtree.
    
    IfFailGo(piSnapInDef->get_Type(&OldSnapInType));

    hr = piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_SnapInDefGeneralPP;
    pageClsID[1] = CLSID_SnapInDefImageListPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 2;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = DISPID_SNAPIN_TYPE;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

    // Check if the snap-in type changed
    
    IfFailGo(piSnapInDef->get_Type(&NewSnapInType));
    IfFalseGo(NewSnapInType != OldSnapInType, S_OK);

    // If the old type was not an extension and now it is an extension then
    // we need to remove the auto-creates subtree

    if ( (siExtension != OldSnapInType) && (siExtension == NewSnapInType) )
    {
        IfFailGo(RemoveAutoCreateSubTree());
    }

    // If the old type was an extension and now it not an extension then
    // we need to add the auto-creates subtree

    else if ( (siExtension == OldSnapInType) && (siExtension != NewSnapInType) )
    {
        IfFailGo(CreateAutoCreateSubTree(m_pRootNodes));
    }


Error:
    RELEASE(piSnapInDef);
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowSnapInExtensions()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowSnapInExtensions()
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[1];
    ISnapInDef     *piSnapInDef = NULL;

    hr = GetResourceString(IDS_SNAPIN_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_SnapInDefExtensionsPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 1;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = DISPID_SNAPIN_TYPE;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\tvpopul.cpp ===
//=--------------------------------------------------------------------------------------
// tvpopul.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- Initializing and populating the tree view
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "desmain.h"
#include "TreeView.h"

// for ASSERT and FAIL
//
SZTHISFILE


const int   kMaxBuffer = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializePresentation()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the tree. This top level function populates the root and
//      four children, and calls helper functions tha build the sub-trees off them.
// 
HRESULT CSnapInDesigner::InitializePresentation()
{
    HRESULT              hr = S_OK;
    ISnapInDef          *piSnapInDef = NULL;
    TCHAR               *pszSnapInName = NULL;

    // Create the tree root node
    hr = GetSnapInName(&pszSnapInName);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    m_pRootNode = New CSelectionHolder(SEL_SNAPIN_ROOT, piSnapInDef);
    if (NULL == m_pRootNode)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pRootNode->RegisterHolder();
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszSnapInName, NULL, kClosedFolderIcon, m_pRootNode);
    IfFailGo(hr);

    hr = CreateExtensionsTree(m_pRootNode);
    IfFailGo(hr);

    hr = CreateNodesTree(m_pRootNode);
    IfFailGo(hr);

    hr = CreateToolsTree(m_pRootNode);
    IfFailGo(hr);

    hr = CreateViewsTree(m_pRootNode);
    IfFailGo(hr);

    // UNDONE: we are leaving the data formats section out of the tree until
    // we make a final decision regarding XML
    
    // hr = CreateDataFormatsTree(m_pRootNode);
    IfFailGo(hr);

    hr = OnSelectionChanged(m_pRootNode);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(m_pRootNode);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);
    if (NULL != pszSnapInName)
        CtlFree(pszSnapInName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateExtensionsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the Extensions subtree
//
HRESULT CSnapInDesigner::CreateExtensionsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT              hr = S_OK;
    IExtensionDefs      *piExtensionDefs = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    m_pRootExtensions = New CSelectionHolder(SEL_EXTENSIONS_ROOT, piExtensionDefs);
    if (NULL == m_pRootExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // We want to receive notifications of changes to basic properties and additions to the collection
    // of extended snap-ins.
    hr = m_pRootExtensions->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_EXTENSIONS_ROOT, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, m_pRootExtensions);
    IfFailGo(hr);

    hr = PopulateExtensions(m_pRootExtensions);
    IfFailGo(hr);

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateExtensions(CSelectionHolder *pExtensionsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Extensions subtree. We cycle through IExtensionDefs collection
//      of the snap-in and populate tree nodes accordingly.
//
HRESULT CSnapInDesigner::PopulateExtensions
(
    CSelectionHolder *pExtensionsParent
)
{
    HRESULT             hr = S_OK;
    IExtensionDefs     *piExtensionDefs = NULL;
    ISnapInDef         *piSnapInDef = NULL;
    SnapInTypeConstants sitc = siStandAlone;
    IExtendedSnapIns   *piExtendedSnapIns = NULL;
    long                lCount = 0;
    long                lIndex = 1;
    IExtendedSnapIn    *piExtendedSnapIn = NULL;
    VARIANT             vtIndex;
    TCHAR              *pszSnapInName = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    // Add the snap-ins we're extending
    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Type(&sitc);
    IfFailGo(hr);

    if (siStandAlone != sitc)
    {
        hr = piExtensionDefs->get_ExtendedSnapIns(&piExtendedSnapIns);
        IfFailGo(hr);

        hr = piExtendedSnapIns->get_Count(&lCount);
        IfFailGo(hr);

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.vt = VT_I4;
            vtIndex.lVal = lIndex;
            hr = piExtendedSnapIns->get_Item(vtIndex, &piExtendedSnapIn);
            IfFailGo(hr);

            hr = CreateExtendedSnapIn(pExtensionsParent, piExtendedSnapIn);
            IfFailGo(hr);

            RELEASE(piExtendedSnapIn);
        }
    }

    // Always extend myself
    m_pRootMyExtensions = New CSelectionHolder(SEL_EXTENSIONS_MYNAME, piExtensionDefs);
    if (NULL == m_pRootMyExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetSnapInName(&pszSnapInName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszSnapInName, pExtensionsParent, kClosedFolderIcon, m_pRootMyExtensions);
    IfFailGo(hr);

    hr = PopulateSnapInExtensions(m_pRootMyExtensions, piExtensionDefs);
    IfFailGo(hr);

Error:
    if (NULL != pszSnapInName)
        CtlFree(pszSnapInName);
    ::VariantClear(&vtIndex);
    RELEASE(piExtendedSnapIn);
    RELEASE(piExtendedSnapIns);
    RELEASE(piSnapInDef);
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateExtendedSnapIn(CSelectionHolder *pRoot, IExtendedSnapIn *piExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Extensions/<Extended snap-in> node.
//
HRESULT CSnapInDesigner::CreateExtendedSnapIn(CSelectionHolder *pRoot, IExtendedSnapIn *piExtendedSnapIn)
{
    HRESULT           hr = S_OK;
    char             *pszDisplayName = NULL;
    CSelectionHolder *pExtendedSnapIn = NULL;

    IfFailGo(::GetExtendedSnapInDisplayName(piExtendedSnapIn, &pszDisplayName));

    pExtendedSnapIn = New CSelectionHolder(piExtendedSnapIn);
    IfFailGo(hr);

    pExtendedSnapIn->RegisterHolder();
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszDisplayName, pRoot, kClosedFolderIcon,
                              pExtendedSnapIn);
    IfFailGo(hr);

    hr = PopulateExtendedSnapIn(pExtendedSnapIn);
    IfFailGo(hr);

Error:
    if (NULL != pszDisplayName)
        CtlFree(pszDisplayName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Extensions/<Extended snap-in> node.
//
HRESULT CSnapInDesigner::PopulateExtendedSnapIn(CSelectionHolder *pExtendedSnapIn)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pContextMenus = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    VARIANT_BOOL         bValue = VARIANT_FALSE;
    CSelectionHolder    *pSelection = NULL;

    // Create the Context Menus folder
    pContextMenus = New CSelectionHolder(SEL_EEXTENSIONS_CC_ROOT, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
    if (NULL == pContextMenus)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_EXT_CONTEXT_MENUS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pContextMenus);
    IfFailGo(hr);

    // Check to see if it extends New menu
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_CC_NEW, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_CTX_MENU_NEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pContextMenus, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Task menu
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_CC_TASK, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_CTX_MENU_TASK, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pContextMenus, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Property Pages
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_PP_ROOT, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_PAGES, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Taskpad
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_TASKPAD, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_TASKPAD, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Toolbar
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_TOOLBAR, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_TOOLBAR, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

    // Check to see if it extends Namespace
    hr = pExtendedSnapIn->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pSelection = New CSelectionHolder(SEL_EEXTENSIONS_NAMESPACE, pExtendedSnapIn->m_piObject.m_piExtendedSnapIn);
        if (NULL == pSelection)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_EXT_PROP_NAMESPACE, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pExtendedSnapIn, kClosedFolderIcon, pSelection);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateSnapInExtensions(CSelectionHolder *pRoot, IExtensionDefs *piExtensionDefs)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Extensions/<Snap-in Name> node.
//
// <Root>/Extensions/<Snap-in Name>/ExtendsNewMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsTaskMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsTopMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsViewMenu
// <Root>/Extensions/<Snap-in Name>/ExtendsPropertyPages
// <Root>/Extensions/<Snap-in Name>/ExtendsToolbar
// <Root>/Extensions/<Snap-in Name>/ExtendsNameSpace

HRESULT CSnapInDesigner::PopulateSnapInExtensions(CSelectionHolder *pRoot, IExtensionDefs *piExtensionDefs)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    VARIANT_BOOL         bValue = VARIANT_FALSE;
    CSelectionHolder    *pNode = NULL;

    // <Root>/Extensions/<Snap-in Name>/ExtendsNewMenu
    hr = piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_NEW_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_NEW_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsTaskMenu
    hr = piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_TASK_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_TASK_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsTopMenu
    hr = piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_TOP_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_TOP_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsViewMenu
    hr = piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_VIEW_MENU, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_VIEW_MENU, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsPropertyPages
    hr = piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_PPAGES, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_PPAGES, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsToolbar
    hr = piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_TOOLBAR, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_TOOLBAR, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

    // <Root>/Extensions/<Snap-in Name>/ExtendsNamespace
    hr = piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_TRUE == bValue)
    {
        pNode = New CSelectionHolder(SEL_EXTENSIONS_NAMESPACE, piExtensionDefs);
        if (NULL == pNode)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = GetResourceString(IDS_MYEXT_NAMESPACE, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pNode);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateNodesTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Nodes node.
//
HRESULT CSnapInDesigner::CreateNodesTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Create the parent node, <Root>/Nodes.
    m_pRootNodes = New CSelectionHolder(SEL_NODES_ROOT, piSnapInDef);
    if (NULL == m_pRootNodes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_NODES_ROOT, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, m_pRootNodes);
    IfFailGo(hr);

    // Populate the subtree
    hr = PopulateNodes(m_pRootNodes);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateNodes(CSelectionHolder *pNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Nodes subtree.
//
HRESULT CSnapInDesigner::PopulateNodes
(
    CSelectionHolder *pNodesParent
)
{
    HRESULT              hr = S_OK;
    ISnapInDef          *piSnapInDef = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    IScopeItemDefs      *piScopeItemDefs = NULL;
    SnapInTypeConstants  SnapInType = siStandAlone;

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    IfFailGo(piSnapInDef->get_Type(&SnapInType));

    if (siExtension != SnapInType)
    {
        IfFailGo(CreateAutoCreateSubTree(pNodesParent));
    }

    // Build the <Root>/Nodes/Other tree
    hr = m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs);
    IfFailGo(hr);

    m_pOtherRoot = New CSelectionHolder(SEL_NODES_OTHER, piScopeItemDefs);
    if (NULL == m_pOtherRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pOtherRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_NODES_OTHER, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pNodesParent, kClosedFolderIcon, m_pOtherRoot);
    IfFailGo(hr);

    hr = PopulateOtherNodes(m_pOtherRoot);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateAutoCreateSubTree(CSelectionHolder *pNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Create the <Root>/Nodes/Auto-Create subtree.
//
HRESULT CSnapInDesigner::CreateAutoCreateSubTree
(
    CSelectionHolder *pNodesParent
)
{
    HRESULT              hr = S_OK;
    TCHAR                szBuffer[kMaxBuffer + 1];
    SnapInTypeConstants  SnapInType = siStandAlone;
    ISnapInDef          *piSnapInDef = NULL;

    IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));

    // Create the <Root>/Nodes/Auto-Create tree
    m_pAutoCreateRoot = New CSelectionHolder(SEL_NODES_AUTO_CREATE, piSnapInDef);
    if (NULL == m_pAutoCreateRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        IfFailGo(hr);
    }

    hr = GetResourceString(IDS_NODES_AUTO_CREATE, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    // Insert node at the top of <Root>/Nodes

    hr = m_pTreeView->AddNodeAfter(szBuffer, pNodesParent, kClosedFolderIcon,
                                   NULL, m_pAutoCreateRoot);
    IfFailGo(hr);

    hr = PopulateAutoCreateNodes(m_pAutoCreateRoot);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateAutoCreateNodes(CSelectionHolder *pAutoCreateNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the Nodes/Auto-Create subtree. Cycle through the IScopeItemDef's for
//      auto-create nodes and populate this subtree.
//
HRESULT CSnapInDesigner::PopulateAutoCreateNodes
(
    CSelectionHolder *pAutoCreateNodesParent
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pRootNode = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Always have a root: <Root>/Nodes/Auto-Create/Static Node
    pRootNode = New CSelectionHolder(SEL_NODES_AUTO_CREATE_ROOT, piSnapInDef);
    if (NULL == pRootNode)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_NODES_STATIC, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pAutoCreateNodesParent,
                              kClosedFolderIcon, pRootNode);
    IfFailGo(hr);

    hr = PopulateStaticNodeTree(pRootNode);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}


HRESULT CSnapInDesigner::RemoveAutoCreateSubTree()
{
    HRESULT           hr = S_OK;
    IScopeItemDefs   *piAutoCreates = NULL;
    IScopeItemDefs   *piScopeItemDefs = NULL;
    ISnapInDef       *piSnapInDef = NULL;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;

    IfFalseGo(NULL != m_pAutoCreateRoot, S_OK);

    // Get <Root>/Nodes/Auto-Create/Static Node/Children
    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piAutoCreates));

    // Remove everything from the collection
    IfFailGo(piAutoCreates->Clear());

    // Get <Root>/Nodes/Auto-Create/Static Node/ResultViews
    IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));
    IfFailGo(piSnapInDef->get_ViewDefs(&piViewDefs));

    // Remove everything from each of the result view collections
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(piListViewDefs->Clear());
    
    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));
    IfFailGo(piOCXViewDefs->Clear());

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));
    IfFailGo(piURLViewDefs->Clear());

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(piTaskpadViewDefs->Clear());

    IfFailGo(DeleteSubTree(m_pAutoCreateRoot));
    IfFailGo(m_pTreeView->DeleteNode(m_pAutoCreateRoot));

    // Need to unregister here in order to set
    // SnapInDesignerDef.AutoCreateNodes cookie to zero. If the user
    // decides to switch back to standalone or dual mode, the code in
    // CSnapInDesigner::PopulateStaticNodeTree() will detect a zero cookie
    // and register a new one.
    
    IfFailGo(m_pAutoCreateRoot->UnregisterHolder());
    m_pAutoCreateRoot = NULL;

    IfFailGo(OnSelectionChanged(m_pRootNode));
    IfFailGo(m_pTreeView->SelectItem(m_pRootNode));

Error:
    QUICK_RELEASE(piAutoCreates);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}


HRESULT CSnapInDesigner::DeleteSubTree(CSelectionHolder *pNode)
{
    HRESULT           hr = S_OK;
    CSelectionHolder *pNextChild = NULL;
    CSelectionHolder *pThisChild = NULL;

    IfFailGo(m_pTreeView->GetFirstChildNode(pNode, &pNextChild));

    while (NULL != pNextChild)
    {
        pThisChild = pNextChild;
        IfFailGo(m_pTreeView->GetNextChildNode(pThisChild, &pNextChild));

        IfFailGo(DeleteSubTree(pThisChild));
        IfFailGo(m_pTreeView->DeleteNode(pThisChild));
        IfFailGo(pThisChild->UnregisterHolder());
        delete pThisChild;
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateOtherNodes(CSelectionHolder *pOtherNodesParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the Nodes/Other subtree.
//
HRESULT CSnapInDesigner::PopulateOtherNodes
(
    CSelectionHolder *pOtherNodesParent
)
{
    HRESULT            hr = S_OK;
    IScopeItemDefs    *piScopeItemDefs = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IScopeItemDef     *piScopeItemDef = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs);
    IfFailGo(hr);

    hr = piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->get_Item(vtIndex, &piScopeItemDef);
        IfFailGo(hr);

        hr = PopulateNodeTree(pOtherNodesParent, piScopeItemDef);
        IfFailGo(hr);

        RELEASE(piScopeItemDef);
    }

Error:
    RELEASE(piScopeItemDef);
    ::VariantClear(&vtIndex);
    RELEASE(piScopeItemDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateStaticNodeTree(CSelectionHolder *pStaticNode)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//      Populate the <Root>/Nodes/Auto-Create/Static Node/ subtree.
//
HRESULT CSnapInDesigner::PopulateStaticNodeTree
(
    CSelectionHolder  *pStaticNode
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pChildrenRoot = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];
    IScopeItemDefs    *piScopeItemDefs = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IScopeItemDef     *piScopeItemDef = NULL;
    CSelectionHolder  *pViewsRoot = NULL;
    IViewDefs         *piViewDefs = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // <Root>/Nodes/Auto-Create/Static Node/Views
    pViewsRoot = New CSelectionHolder(SEL_NODES_AUTO_CREATE_RTVW, piSnapInDef);
    if (NULL == pViewsRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piSnapInDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = RegisterViewCollections(pViewsRoot, piViewDefs);
    IfFailGo(hr);

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pStaticNode, kClosedFolderIcon, pViewsRoot);
    IfFailGo(hr);

    // Cycle through the views defined for this node
    hr = PopulateListViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    hr = PopulateOCXViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    hr = PopulateURLViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    hr = PopulateTaskpadViews(piViewDefs, pViewsRoot);
    IfFailGo(hr);

    // <Root>/Nodes/Auto-Create/Static Node/Children
    hr = m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs);
    IfFailGo(hr);

    pChildrenRoot = New CSelectionHolder(SEL_NODES_AUTO_CREATE_RTCH, piScopeItemDefs);
    if (NULL == pChildrenRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pChildrenRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_CHILDREN, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pStaticNode, kClosedFolderIcon, pChildrenRoot);
    IfFailGo(hr);

    hr = piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->get_Item(vtIndex, &piScopeItemDef);
        IfFailGo(hr);

        hr = PopulateNodeTree(pChildrenRoot, piScopeItemDef);
        IfFailGo(hr);

        RELEASE(piScopeItemDef);
    }

Error:
    RELEASE(piViewDefs);
    RELEASE(piScopeItemDef);
    ::VariantClear(&vtIndex);
    RELEASE(piScopeItemDefs);
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateToolsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the <Root>/Tools subtree
//
HRESULT CSnapInDesigner::CreateToolsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pRootTools = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    pRootTools = New CSelectionHolder(SEL_TOOLS_ROOT, piSnapInDef);
    if (NULL == pRootTools)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_TOOLS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pRootTools);
    IfFailGo(hr);

    hr = InitializeToolsTree(pRootTools);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeToolsTree(CSelectionHolder *pToolsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the 3 basic nodes of the <Root>/Tools subtree
//
HRESULT CSnapInDesigner::InitializeToolsTree
(
    CSelectionHolder *pToolsParent
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    IMMCImageLists    *piMMCImageLists = NULL;
    IMMCMenus         *piMMCMenus = NULL;
    IMMCToolbars      *piMMCToolbars = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // ImageLists
    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    m_pToolImgLstRoot = New CSelectionHolder(piMMCImageLists);
    if (NULL == m_pToolImgLstRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pToolImgLstRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_IMAGE_LISTS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pToolsParent, kClosedFolderIcon, m_pToolImgLstRoot);
    IfFailGo(hr);

    hr = PopulateImageLists(m_pToolImgLstRoot);
    IfFailGo(hr);

    // Menus
    hr = m_piSnapInDesignerDef->get_Menus(&piMMCMenus);
    IfFailGo(hr);

    m_pToolMenuRoot = New CSelectionHolder(piMMCMenus);
    if (NULL == m_pToolMenuRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pToolMenuRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_MENUS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pToolsParent, kClosedFolderIcon, m_pToolMenuRoot);
    IfFailGo(hr);

    hr = PopulateMenus(m_pToolMenuRoot, piMMCMenus);
    IfFailGo(hr);

    // Toolbars
    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    m_pToolToolbarRoot = New CSelectionHolder(piMMCToolbars);
    if (NULL == m_pToolToolbarRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pToolToolbarRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_TOOLBARS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pToolsParent, kClosedFolderIcon, m_pToolToolbarRoot);
    IfFailGo(hr);

    hr = PopulateToolbars(m_pToolToolbarRoot);
    IfFailGo(hr);

Error:
    RELEASE(piMMCToolbars);
    RELEASE(piMMCMenus);
    RELEASE(piMMCImageLists);
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateImageLists(CSelectionHolder *pImageListsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Tools/ImageLists subtree
//
HRESULT CSnapInDesigner::PopulateImageLists
(
    CSelectionHolder *pImageListsParent
)
{
    HRESULT            hr = S_OK;
    IMMCImageLists    *piMMCImageLists = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IMMCImageList     *piMMCImageList = NULL;
    CSelectionHolder  *pImageList = NULL;
    BSTR               bstrName = NULL;
    TCHAR             *pszAnsi = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists);
    IfFailGo(hr);

    hr = piMMCImageLists->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCImageLists->get_Item(vtIndex, &piMMCImageList);
        IfFailGo(hr);

        hr = m_pSnapInTypeInfo->AddImageList(piMMCImageList);
        IfFailGo(hr);

        pImageList = New CSelectionHolder(piMMCImageList);
        if (NULL == pImageList)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pImageList->RegisterHolder();
        IfFailGo(hr);

        hr = piMMCImageList->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pImageListsParent, kImageListIcon, pImageList);
        IfFailGo(hr);

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piMMCImageList);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    RELEASE(piMMCImageList);
    RELEASE(piMMCImageLists);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateMenus(CSelectionHolder *pMenusParent, IMMCMenus *piMMCMenus)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Tools/Menus subtree
//
HRESULT CSnapInDesigner::PopulateMenus
(
    CSelectionHolder *pMenusParent,
    IMMCMenus        *piMMCMenus
)
{
    HRESULT            hr = S_OK;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    CSelectionHolder  *pMenu = NULL;
    IMMCMenu          *piMMCMenu = NULL;
    BSTR               bstrName = NULL;
    TCHAR             *pszAnsi = NULL;
    IMMCMenus         *piChildren = NULL;
    long               lChildrenCount = 0;

    ::VariantInit(&vtIndex);

    hr = piMMCMenus->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCMenus->get_Item(vtIndex, reinterpret_cast<MMCMenu **>(&piMMCMenu));
        IfFailGo(hr);

        hr = piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piChildren));
        IfFailGo(hr);

        pMenu = New CSelectionHolder(piMMCMenu, piChildren);
        if (NULL == pMenu)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pMenu->RegisterHolder();
        IfFailGo(hr);

        hr = piMMCMenu->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pMenusParent, kMenuIcon, pMenu);
        IfFailGo(hr);

        hr = m_pSnapInTypeInfo->IsNameDefined(bstrName);
        IfFailGo(hr);

        if (S_FALSE == hr)
        {
            hr = m_pSnapInTypeInfo->AddMenu(pMenu->m_piObject.m_piMMCMenu);
            IfFailGo(hr);
        }

		hr = piChildren->get_Count(&lChildrenCount);
		IfFailGo(hr);

        if (lChildrenCount > 0)
        {
            hr = PopulateMenus(pMenu, piChildren);
            IfFailGo(hr);
        }

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piMMCMenu);
        RELEASE(piChildren);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    RELEASE(piMMCMenu);
    RELEASE(piChildren);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateToolbars(CSelectionHolder *pToolbarsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Tools/Toolbars subtree
//
HRESULT CSnapInDesigner::PopulateToolbars
(
    CSelectionHolder *pToolbarsParent
)
{
    HRESULT            hr = S_OK;
    IMMCToolbars      *piMMCToolbars = NULL;
    long               lCount = 0;
    long               lIndex = 0;
    VARIANT            vtIndex;
    IMMCToolbar       *piMMCToolbar = NULL;
    CSelectionHolder  *pToolbar = NULL;
    BSTR               bstrName = NULL;
    TCHAR             *pszAnsi = NULL;

    ::VariantInit(&vtIndex);

    hr = m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars);
    IfFailGo(hr);

    hr = piMMCToolbars->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;

        hr = piMMCToolbars->get_Item(vtIndex, &piMMCToolbar);
        IfFailGo(hr);

        hr = m_pSnapInTypeInfo->AddToolbar(piMMCToolbar);
        IfFailGo(hr);

        pToolbar = New CSelectionHolder(piMMCToolbar);
        if (NULL == pToolbar)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pToolbar->RegisterHolder();
        IfFailGo(hr);

        hr = piMMCToolbar->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pToolbarsParent, kToolbarIcon, pToolbar);
        IfFailGo(hr);

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piMMCToolbar);
    }

Error:
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    RELEASE(piMMCToolbar);
    RELEASE(piMMCToolbars);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateViewsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the  <Root>/Views subtree
//
HRESULT CSnapInDesigner::CreateViewsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    CSelectionHolder  *pRootViews = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Create the views subtree
    pRootViews = New CSelectionHolder(SEL_VIEWS_ROOT, piSnapInDef);
    if (NULL == pRootViews)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pRootViews);
    IfFailGo(hr);

    hr = InitializeViews(pRootViews);
    IfFailGo(hr);

Error:
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeViews(CSelectionHolder *pViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Populate the <Root>/Views/* tree.
//
HRESULT CSnapInDesigner::InitializeViews
(
    CSelectionHolder *pViewsParent
)
{
    HRESULT            hr = S_OK;
    ISnapInDef        *piSnapInDef = NULL;
    IViewDefs         *piViewDefs = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];
    CSelectionHolder  *pViewTaskRoot = NULL;
    IListViewDefs     *piListViewDefs = NULL;
    IOCXViewDefs      *piOCXViewDefs = NULL;
    IURLViewDefs      *piURLViewDefs = NULL;
    ITaskpadViewDefs  *piTaskpadViewDefs = NULL;

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    // Get the master collections of views
    hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    // Create the ListView node and populate the subtree
    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    m_pViewListRoot = New CSelectionHolder(SEL_VIEWS_LIST_VIEWS, piListViewDefs);
    if (NULL == m_pViewListRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pViewListRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_LISTVIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, m_pViewListRoot);
    IfFailGo(hr);

    hr = PopulateListViews(piViewDefs, m_pViewListRoot);
    IfFailGo(hr);

    // Create the OCXView node and populate the subtree
    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    m_pViewOCXRoot = New CSelectionHolder(SEL_VIEWS_OCX, piOCXViewDefs);
    if (NULL == m_pViewOCXRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pViewOCXRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_OCXVIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, m_pViewOCXRoot);
    IfFailGo(hr);

    hr = PopulateOCXViews(piViewDefs, m_pViewOCXRoot);
    IfFailGo(hr);

    // Create the URLView node and populate the subtree
    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    m_pViewURLRoot = New CSelectionHolder(SEL_VIEWS_URL, piURLViewDefs);
    if (NULL == m_pViewURLRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pViewURLRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_URLVIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, m_pViewURLRoot);
    IfFailGo(hr);

    hr = PopulateURLViews(piViewDefs, m_pViewURLRoot);
    IfFailGo(hr);

    // Create the TaskpadView node and populate the subtree
    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    pViewTaskRoot = New CSelectionHolder(SEL_VIEWS_TASK_PAD, piTaskpadViewDefs);
    if (NULL == pViewTaskRoot)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pViewTaskRoot->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_TASKPADS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pViewsParent, kClosedFolderIcon, pViewTaskRoot);
    IfFailGo(hr);

    hr = PopulateTaskpadViews(piViewDefs, pViewTaskRoot);
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piSnapInDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateListViews(IViewDefs *piViewDefs, CSelectionHolder *pListViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateListViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pListViewsParent
)
{
    HRESULT           hr = S_OK;
    IListViewDefs    *piListViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    IListViewDef     *piListViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (piViewDefs == NULL)
    {
        goto Error;
    }

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    if (NULL != piListViewDefs)
    {
        hr = piListViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
            IfFailGo(hr);

            hr = piListViewDef->get_Name(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piListViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pListViewsParent, kListViewIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piListViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piListViewDefs);
    RELEASE(piListViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateOCXViews(IViewDefs *piViewDefs, CSelectionHolder *pOCXViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateOCXViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pOCXViewsParent
)
{
    HRESULT           hr = S_OK;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    IOCXViewDef      *piOCXViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (NULL == piViewDefs)
    {
        goto Error;
    }

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    if (NULL != piOCXViewDefs)
    {
        hr = piOCXViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
            IfFailGo(hr);

            hr = piOCXViewDef->get_Name(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piOCXViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pOCXViewsParent, kOCXViewIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piOCXViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piOCXViewDefs);
    RELEASE(piOCXViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateURLViews(IViewDefs *piViewDefs, CSelectionHolder *pURLViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateURLViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pURLViewsParent
)
{
    HRESULT           hr = S_OK;
    IURLViewDefs     *piURLViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    IURLViewDef      *piURLViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (NULL == piViewDefs)
    {
        goto Error;
    }

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    if (NULL != piURLViewDefs)
    {
        hr = piURLViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
            IfFailGo(hr);

            hr = piURLViewDef->get_Name(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piURLViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pURLViewsParent, kURLViewIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piURLViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piURLViewDefs);
    RELEASE(piURLViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateTaskpadViews(IViewDefs *piViewDefs, CSelectionHolder *pTaskpadViewsParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Initialize the top tree nodes for the views subtree.
//
HRESULT CSnapInDesigner::PopulateTaskpadViews
(
    IViewDefs        *piViewDefs,
    CSelectionHolder *pTaskpadViewsParent
)
{
    HRESULT           hr = S_OK;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    long              lCount = 0;
    VARIANT           vtIndex;
    long              lIndex = 0;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    BSTR              bstrName = NULL;
    TCHAR            *pszName = NULL;
    CSelectionHolder *pSelection = NULL;

    if (NULL == piViewDefs)
    {
        goto Error;
    }

    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    if (NULL != piTaskpadViewDefs)
    {
        hr = piTaskpadViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        ::VariantInit(&vtIndex);
        vtIndex.vt = VT_I4;

        for (lIndex = 1; lIndex <= lCount; ++lIndex)
        {
            vtIndex.lVal = lIndex;
            hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
            IfFailGo(hr);

            hr = piTaskpadViewDef->get_Key(&bstrName);
            IfFailGo(hr);

            if (NULL != bstrName && ::SysStringLen(bstrName) > 0)
            {
                hr = ANSIFromWideStr(bstrName, &pszName);
                IfFailGo(hr);

                if (NULL != pszName && ::strlen(pszName) > 0)
                {
                    pSelection = New CSelectionHolder(piTaskpadViewDef);
                    if (NULL == pSelection)
                    {
                        hr = SID_E_OUTOFMEMORY;
                        EXCEPTION_CHECK_GO(hr);
                    }

                    hr = m_pTreeView->AddNode(pszName, pTaskpadViewsParent, kTaskpadIcon, pSelection);
                    IfFailGo(hr);

                    hr = pSelection->RegisterHolder();
                    IfFailGo(hr);

                    CtlFree(pszName);
                    pszName = NULL;
                }
            }

            RELEASE(piTaskpadViewDef);
            FREESTRING(bstrName);
        }
    }

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RegisterViewCollections(CSelectionHolder *pSelection, IViewDefs *piViewDefs)
//=--------------------------------------------------------------------------------------
//  
HRESULT CSnapInDesigner::RegisterViewCollections(CSelectionHolder *pSelection, IViewDefs *piViewDefs)
{
    HRESULT              hr = S_OK;
    IObjectModel        *piObjectModel = NULL;
    IListViewDefs       *piListViewDefs = NULL;
    IOCXViewDefs        *piOCXViewDefs = NULL;
    IURLViewDefs        *piURLViewDefs = NULL;
    ITaskpadViewDefs    *piTaskpadViewDefs = NULL;

    hr = piViewDefs->get_ListViews(&piListViewDefs);
    IfFailGo(hr);

    hr = piListViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

    hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
    IfFailGo(hr);

    RELEASE(piObjectModel);
    hr = piOCXViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    RELEASE(piObjectModel);
    hr = piURLViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

    RELEASE(piObjectModel);
    hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
    IfFailGo(hr);

    hr = piTaskpadViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->SetCookie(reinterpret_cast<long>(pSelection));
    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateNodeTree(CSelectionHolder *pNodeParent, IScopeItemDef *piScopeItemDef)
//=--------------------------------------------------------------------------------------
//  
//  Recursive function used to populate a node tree. For a piScopeItemDef, create the
//  piScopeItemDef/Children/* and piScopeItemDef/Views/* subtrees.
//
HRESULT CSnapInDesigner::PopulateNodeTree
(
    CSelectionHolder *pNodeParent,
    IScopeItemDef    *piScopeItemDef
)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pSelection = NULL;
    BSTR                 bstrName = NULL;
    TCHAR               *pszAnsi = NULL;
    CSelectionHolder    *pChildren = NULL;
    TCHAR                szBuffer[kMaxBuffer + 1];
    CSelectionHolder    *pViews = NULL;
    IScopeItemDefs      *piScopeItemDefs = NULL;
    long                 lCount = 0;
    long                 lIndex = 0;
    VARIANT              vtIndex;
    IScopeItemDef       *piChildScopeItemDef = NULL;
    IViewDefs           *piViewDefs = NULL;

    ::VariantInit(&vtIndex);

    pSelection = New CSelectionHolder(SEL_NODES_ANY_NAME, piScopeItemDef);
    if (NULL == pSelection)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pSelection->RegisterHolder();
    IfFailGo(hr);

    hr = piScopeItemDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszAnsi);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszAnsi, pNodeParent, kScopeItemIcon, pSelection);
    IfFailGo(hr);

    // Populate the views for this node
    pViews = New CSelectionHolder(SEL_NODES_ANY_VIEWS, piScopeItemDef);
    if (NULL == pViews)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = piScopeItemDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    hr = RegisterViewCollections(pViews, piViewDefs);
    IfFailGo(hr);

    hr = GetResourceString(IDS_VIEWS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pSelection, kClosedFolderIcon, pViews);
    IfFailGo(hr);

    hr = PopulateListViews(piViewDefs, pViews);
    IfFailGo(hr);

    hr = PopulateOCXViews(piViewDefs, pViews);
    IfFailGo(hr);

    hr = PopulateURLViews(piViewDefs, pViews);
    IfFailGo(hr);

    hr = PopulateTaskpadViews(piViewDefs, pViews);
    IfFailGo(hr);

    // Populate the children for this node
    hr = piScopeItemDef->get_Children(&piScopeItemDefs);
    IfFailGo(hr);

    pChildren = New CSelectionHolder(SEL_NODES_ANY_CHILDREN, piScopeItemDefs);
    if (NULL == pChildren)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = pChildren->RegisterHolder();
    IfFailGo(hr);

    hr = GetResourceString(IDS_CHILDREN, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pSelection, kClosedFolderIcon, pChildren);
    IfFailGo(hr);

    hr = piScopeItemDefs->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piScopeItemDefs->get_Item(vtIndex, &piChildScopeItemDef);
        IfFailGo(hr);

        hr = PopulateNodeTree(pChildren, piChildScopeItemDef);
        IfFailGo(hr);

        RELEASE(piChildScopeItemDef);
    }

Error:
    RELEASE(piViewDefs);
    RELEASE(piChildScopeItemDef);
    RELEASE(piScopeItemDefs);
    if (NULL != pszAnsi)
        CtlFree(pszAnsi);
    FREESTRING(bstrName);
    ::VariantClear(&vtIndex);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CreateDataFormatsTree(CSelectionHolder *pRoot)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//      Create the  <Root>/Data Formats subtree
//
HRESULT CSnapInDesigner::CreateDataFormatsTree
(
    CSelectionHolder *pRoot
)
{
    HRESULT            hr = S_OK;
    IDataFormats      *piDataFormats = NULL;
    CSelectionHolder  *pRootDataFormats = NULL;
    TCHAR              szBuffer[kMaxBuffer + 1];

    hr = m_piSnapInDesignerDef->get_DataFormats(&piDataFormats);
    IfFailGo(hr);

    // Create the Data Formats subtree
    pRootDataFormats = New CSelectionHolder(piDataFormats);
    if (NULL == piDataFormats)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetResourceString(IDS_DATAFORMATS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(szBuffer, pRoot, kClosedFolderIcon, pRootDataFormats);
    IfFailGo(hr);

    hr = pRootDataFormats->RegisterHolder();
    IfFailGo(hr);

    hr = PopulateDataFormats(pRootDataFormats, piDataFormats);
    IfFailGo(hr);

Error:
    RELEASE(piDataFormats);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateDataFormats(CSelectionHolder *pRoot, IDataFormats *piDataFormats)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::PopulateDataFormats
(
    CSelectionHolder *pRoot,
    IDataFormats     *piDataFormats
)
{
    HRESULT              hr = S_OK;
    long                 lCount = 0;
    long                 lIndex = 0;
    VARIANT              vtIndex;
    IDataFormat         *piDataFormat = NULL;
    CSelectionHolder    *pDataFormat = NULL;
    BSTR                 bstrName = NULL;
    TCHAR               *pszAnsi = NULL;

    ::VariantInit(&vtIndex);

    hr = piDataFormats->get_Count(&lCount);
    IfFailGo(hr);

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.vt = VT_I4;
        vtIndex.lVal = lIndex;
        hr = piDataFormats->get_Item(vtIndex, &piDataFormat);
        IfFailGo(hr);

        pDataFormat = New CSelectionHolder(piDataFormat);
        if (NULL == pDataFormat)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        hr = pDataFormat->RegisterHolder();
        IfFailGo(hr);

        hr = piDataFormat->get_Name(&bstrName);
        IfFailGo(hr);

        ANSIFromBSTR(bstrName, &pszAnsi);
        IfFailGo(hr);

        hr = m_pTreeView->AddNode(pszAnsi, pRoot, kDataFmtIcon, pDataFormat);
        IfFailGo(hr);

        if (NULL != pszAnsi)
        {
            CtlFree(pszAnsi);
            pszAnsi = NULL;
        }
        FREESTRING(bstrName);
        RELEASE(piDataFormat);
    }

Error:
    FREESTRING(bstrName);
    ::VariantClear(&vtIndex);
    RELEASE(piDataFormat);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::GetSnapInName
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//
HRESULT CSnapInDesigner::GetSnapInName
(
    TCHAR **ppszNodeName
)
{
    HRESULT         hr = S_OK;
    ISnapInDef     *piSnapInDef = NULL;
    BSTR            bstrName = NULL;

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = piSnapInDef->get_Name(&bstrName);
    if (bstrName != NULL)
    {
        hr = ANSIFromBSTR(bstrName, ppszNodeName);
        IfFailGo(hr);
    }

Error:
    RELEASE(piSnapInDef);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\help\makefile.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    makefile.inc

Abstract:

    This file implements the target specified in sources in NTTARGETFILE0.
    It executes a VB tool that generates help ID header files and an RC
    file containing all the help strings used by the runtime IDL

!ENDIF

GenHelpIDs:
    SET THUNDER55=..\..\..\vb98
    SET TOOLS=TOOLS
	..\..\tools\idheader.bat mssnapr.id $(O)\mssnapr_helpids.h $(O)\mssnapr_helpstrs.h $(O)\mssnapr_helpstrs.rc -NoIncludePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\treeview.h ===
//=--------------------------------------------------------------------------------------
// TreeView.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// CTreeView declaration
//=-------------------------------------------------------------------------------------=

#ifndef _TREEVIEW_H_
#define _TREEVIEW_H_

#include "SelHold.h"


// Icon identifiers for the tree view
const int   kOpenFolderIcon    = 0;
const int   kClosedFolderIcon  = 1;
const int   kScopeItemIcon     = 2;
const int   kImageListIcon     = 3;
const int   kMenuIcon          = 4;
const int   kToolbarIcon       = 5;
const int   kListViewIcon      = 6;
const int   kOCXViewIcon       = 7;
const int   kURLViewIcon       = 8;
const int   kTaskpadIcon       = 9;
const int   kDataFmtIcon       = 10;

typedef int (_stdcall *FnPtr)(void);

////////////////////////////////////////////////////////////////////////////////////
//
// Class CTreeView
//
////////////////////////////////////////////////////////////////////////////////////

class CTreeView : public CError, public CtlNewDelete
{
public:
    CTreeView();
    ~CTreeView();

    HRESULT Initialize(HWND hwndParent, RECT& rc);
    HRESULT CreateTreeView(HWND hwndParent);


////////////////////////////////////////////////////////////////////////////////////
// WinProc and friends
public:
    static LRESULT CALLBACK DesignerTreeWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HWND TreeViewWindow()                       { return m_hTreeView; }

    HRESULT CreateImageList(HIMAGELIST *phImageList);


////////////////////////////////////////////////////////////////////////////////////
// Basic operations on the TreeView
protected:
    HRESULT ClearTree(HTREEITEM hItemParent);
    HRESULT Clear();

public:
    HRESULT RenameAllSatelliteViews(CSelectionHolder *pView, TCHAR *pszNewViewName);
    HRESULT RenameAllSatelliteViews(HTREEITEM          hItemParent,
                                    CSelectionHolder  *pView,
                                    TCHAR             *pszNewViewName);

    HRESULT FindInTree(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);
    HRESULT FindInTree(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);

    HRESULT FindSelectableObject(IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);
    HRESULT FindSelectableObject(HTREEITEM hItemParent, IUnknown *piUnknown, CSelectionHolder **ppSelectionHolder);

    HRESULT FindLabelInTree(TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder);
    HRESULT FindLabelInTree(HTREEITEM hItemParent, TCHAR *pszLabel, CSelectionHolder **ppSelectionHolder);

    HRESULT Count(HTREEITEM hItemParent, long *plCount);
    HRESULT CountSelectableObjects(long *plCount);

    HRESULT Collect(HTREEITEM hItemParent, IUnknown *ppiUnknown[], long *plOffset);
    HRESULT CollectSelectableObjects(IUnknown *ppiUnknown[], long *plOffset);

    HRESULT AddNode(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pItem);
    HRESULT AddNodeAfter(const char *pszNodeName, CSelectionHolder *pParent, int iImage, CSelectionHolder *pPrevious, CSelectionHolder *pItem);

    HRESULT DeleteNode(CSelectionHolder *pItem);
    HRESULT GetItemParam(CSelectionHolder *pItem, CSelectionHolder **ppObject);
    HRESULT GetItemParam(HTREEITEM hItem, CSelectionHolder **ppObject);
    HRESULT ChangeText(CSelectionHolder *pItem, char *pszNewName);
    HRESULT ChangeNodeIcon(CSelectionHolder *pItem, int iImage);
    HRESULT HitTest(POINT pHit, CSelectionHolder **ppSelection);
    HRESULT GetRectangle(CSelectionHolder *pSelection, RECT *prc);
    HRESULT SelectItem(CSelectionHolder *pSelection);
    HRESULT Edit(CSelectionHolder *pSelection);

    HRESULT GetParent(CSelectionHolder *pSelection, CSelectionHolder **ppParent);
    HRESULT GetFirstChildNode(CSelectionHolder *pSelection, CSelectionHolder **ppChild);
    HRESULT GetNextChildNode(CSelectionHolder *pChild, CSelectionHolder **ppNextChild);
    HRESULT GetPreviousNode(CSelectionHolder *pNode, CSelectionHolder **ppPreviousNode);

    HRESULT GetLabel(CSelectionHolder *pSelection, BSTR *pbstrLabel);
    HRESULT GetLabelA(CSelectionHolder *pSelection, char *pszBuffer, int cbBuffer);

    HRESULT MoveNodeAfter(CSelectionHolder *pNode,
                          CSelectionHolder *pParent,
                          CSelectionHolder *pPrevious,
                          int               iImage);

    HRESULT PruneAndGraft(CSelectionHolder *pNode, CSelectionHolder *pNewParentNode, int iImage);
    HRESULT Graft(CSelectionHolder *pNode, CSelectionHolder *pNewParentNode, int iImage);

////////////////////////////////////////////////////////////////////////////////////
// Member variables
protected:
    HWND                 m_hTreeView;
    WNDPROC              m_fnTreeProc;
};


#endif // _TREEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\wndproc.cpp ===
//=--------------------------------------------------------------------------------------
// wndproc.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//
//=------------------------------------------------------------------------------------=
//
// Designer WinProc and friends
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "desmain.h"
#include "TreeView.h"

// for ASSERT and FAIL
//
SZTHISFILE

#define CheckHMenuResult(hMenu) \
                if (NULL == (hMenu))                                \
                {                                                   \
                    hr = HRESULT_FROM_WIN32(::GetLastError());      \
                    EXCEPTION_CHECK_GO(hr);                         \
                }

//=--------------------------------------------------------------------------------------
// Toolbar stuff
//
const int kToolbarIdentifier    =   9;
const int kMainBitmapCount              =  14;
const int kMainBitmapSize               =  16;       // square


// static array describing our main toolbar.
//
static TBBUTTON g_MainButtons[] = {
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  0, CMD_ADD_NODE,         TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  1, CMD_ADD_LISTVIEW,     TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  2, CMD_ADD_TASKPAD,      TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  3, CMD_ADD_OCX_VIEW,     TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  4, CMD_ADD_WEB_VIEW,     TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  5, CMD_ADD_IMAGE_LIST,   TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  6, CMD_ADD_TOOLBAR,      TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  7, CMD_ADD_MENU,         TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        {  8, CMD_PROMOTE,          TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        {  9, CMD_DEMOTE,           TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { 10, CMD_MOVE_UP,          TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { 11, CMD_MOVE_DOWN,        TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
    { 12, CMD_VIEW_PROPERTIES,  TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
    { 13, CMD_DELETE,           TBSTATE_ENABLED,  TBSTYLE_BUTTON, 0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1},
        { -1, 0,                    0,                TBSTYLE_SEP,    0, 0, 0, -1}
};


//=--------------------------------------------------------------------------------------
// array that contains mappings between ids and resource ids for tooltip strings.
//
struct IdToResId {
    UINT    id;
    WORD    resid;
} static g_tooltipMappings [] = {
    { CMD_ADD_NODE,             IDS_TT_ADD_NODE},
    { CMD_ADD_LISTVIEW,         IDS_TT_ADD_LISTVIEW},
    { CMD_ADD_TASKPAD,          IDS_TT_ADD_TASKPAD},
    { CMD_ADD_OCX_VIEW,         IDS_TT_ADD_OCX_VIEW},
    { CMD_ADD_WEB_VIEW,         IDS_TT_ADD_WEB_VIEW},
    { CMD_ADD_IMAGE_LIST,       IDS_TT_ADD_IMAGE_LIST},
    { CMD_ADD_TOOLBAR,          IDS_TT_ADD_TOOLBAR},
    { CMD_ADD_MENU,             IDS_TT_ADD_MENU},
    { CMD_PROMOTE,              IDS_TT_PROMOTE},
    { CMD_DEMOTE,               IDS_TT_DEMOTE},
    { CMD_MOVE_UP,              IDS_TT_MOVE_UP},
    { CMD_MOVE_DOWN,            IDS_TT_MOVE_DOWN},
    { CMD_VIEW_PROPERTIES,      IDS_TT_VIEW_PROPERTIES},
    { CMD_DELETE,               IDS_TT_DELETE},
    { 0xffff, 0xffff}
};


//=--------------------------------------------------------------------------=
// CSnapInDesigner::BeforeCreateWindow(DWORD *pdwWindowStyle, DWORD *pdwExWindowStyle, LPSTR pszWindowTitle)
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::RegisterClassData()
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::RegisterClassData()
{
    HRESULT     hr = S_OK;
    ATOM        atom = 0;
    WNDCLASSEX  wndClass;

        if (0 == ::GetClassInfoEx(GetResourceHandle(), WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_SNAPINDESIGNER), &wndClass))
        {
        ::memset(&wndClass, 0, sizeof(WNDCLASSEX));

                wndClass.cbSize                 = sizeof(WNDCLASSEX);
        wndClass.style          = NULL; // CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        wndClass.lpfnWndProc    = COleControl::ControlWindowProc;
        wndClass.hInstance      = GetResourceHandle();
        wndClass.hCursor        = ::LoadCursor(NULL, IDC_ARROW);
        wndClass.hbrBackground  = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
        wndClass.lpszClassName  = WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_SNAPINDESIGNER);

        atom = ::RegisterClassEx(&wndClass);
        if (0 == atom)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK(hr);
        }
    }

    return SUCCEEDED(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::AfterCreateWindow()
//=--------------------------------------------------------------------------=
//
// Notes:
//
BOOL CSnapInDesigner::AfterCreateWindow()
{
    HRESULT       hr = S_OK;
    int           iToolbarHeight = 0;
    RECT          rc;
    RECT          rcTreeView;
    ISnapInDef   *piSnapInDef = NULL;
    BOOL          fInteractive = VARIANT_FALSE;

    IfFailGo(AttachAmbients());
    IfFailGo(m_Ambients.GetInteractive(&fInteractive));

    IfFailGo(GetHostServices(fInteractive));

    g_GlobalHelp.Attach(m_piHelp);

    // Initialize the Views: toolbar and treeview
    hr = InitializeToolbar();
    IfFailGo(hr);

    iToolbarHeight = m_rcToolbar.bottom - m_rcToolbar.top;
    ::GetWindowRect(m_hwnd, &rc);

    ::SetRect(&rcTreeView,
              0,
              iToolbarHeight,
              rc.right,
              rc.bottom - rc.top);

    m_pTreeView = New CTreeView();
    if (NULL == m_pTreeView)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = m_pTreeView->Initialize(m_hwnd, rcTreeView);
    IfFailGo(hr);

    ::MoveWindow(m_pTreeView->TreeViewWindow(),
                 0,
                 iToolbarHeight,
                 rc.right - rc.left,
                 rc.bottom - rc.top - iToolbarHeight,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    if (NULL == m_bstrName)
    {
        hr = UpdateDesignerName();
        IfFailGo(hr);
    }

    hr = m_piSnapInDesignerDef->get_SnapInDef(&piSnapInDef);
    IfFailGo(hr);

    hr = m_pSnapInTypeInfo->InitializeTypeInfo(piSnapInDef, m_bstrName);
    IfFailGo(hr);

    // Populate the tree
    hr = InitializePresentation();
    IfFailGo(hr);

    hr = OnPrepareToolbar();
    IfFailGo(hr);

    ::SetFocus(m_pTreeView->TreeViewWindow());

    if (FALSE == m_bDidLoad)
    {
        ::PostMessage(m_hwnd, CMD_SHOW_MAIN_PROPERTIES, 0, 0);
    }

Error:
    RELEASE(piSnapInDef);

    return SUCCEEDED(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeToolbar()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
//
HRESULT CSnapInDesigner::InitializeToolbar()
{
    HRESULT     hr = S_OK;
    RECT        rc;

    m_hwdToolbar = ::CreateToolbarEx(m_hwnd,
                                     TBSTYLE_TOOLTIPS | WS_CHILD,
                                     kToolbarIdentifier,
                                     kMainBitmapCount,
                                     GetResourceHandle(),
                                     IDB_TOOLBAR,
                                     g_MainButtons,
                                     sizeof(g_MainButtons) / sizeof(TBBUTTON),
                                     kMainBitmapSize,
                                     kMainBitmapSize,
                                     kMainBitmapSize,
                                     kMainBitmapSize,
                                     sizeof(TBBUTTON));
    if (m_hwdToolbar == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    ::GetWindowRect(m_hwnd, &rc);
    ::GetWindowRect(m_hwdToolbar, &m_rcToolbar);

    ::MoveWindow(m_hwdToolbar,
                 0,
                 0,
                 rc.right - rc.left,
                 m_rcToolbar.bottom - m_rcToolbar.top,
                 SWP_NOZORDER | SWP_NOACTIVATE);

    ::ShowWindow(m_hwdToolbar, SW_SHOW);

Error:
    RRETURN(hr);
}


void CSnapInDesigner::OnHelp()
{
    DWORD dwHelpContextID = HID_mssnapd_DesignerWindow;

    if (NULL == m_pCurrentSelection)
    {
        goto DisplayHelp;
    }

    switch (m_pCurrentSelection->m_st)
    {
        case SEL_SNAPIN_ROOT:
            dwHelpContextID = HID_mssnapd_DesignerWindow;
            break;

        case SEL_EXTENSIONS_ROOT:
            dwHelpContextID = HID_mssnapd_Extensions;
            break;

        case SEL_EXTENSIONS_NEW_MENU:
        case SEL_EXTENSIONS_TASK_MENU:
        case SEL_EXTENSIONS_TOP_MENU:
        case SEL_EXTENSIONS_VIEW_MENU:
        case SEL_EXTENSIONS_PPAGES:
        case SEL_EXTENSIONS_TOOLBAR:
        case SEL_EXTENSIONS_NAMESPACE:
            dwHelpContextID = HID_mssnapd_MyExtensions;
            break;

        case SEL_EEXTENSIONS_CC_ROOT:
        case SEL_EEXTENSIONS_CC_NEW:
        case SEL_EEXTENSIONS_CC_TASK:
        case SEL_EEXTENSIONS_PP_ROOT:
        case SEL_EEXTENSIONS_TASKPAD:
        case SEL_EEXTENSIONS_TOOLBAR:
        case SEL_EEXTENSIONS_NAMESPACE:
            dwHelpContextID = HID_mssnapd_Extensions;
            break;

        case SEL_NODES_ROOT:
        case SEL_NODES_AUTO_CREATE:
        case SEL_NODES_AUTO_CREATE_ROOT:
        case SEL_NODES_ANY_NAME:
        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
        case SEL_NODES_OTHER:
            dwHelpContextID = HID_mssnapd_Nodes;
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
        case SEL_VIEWS_ROOT:
            dwHelpContextID = HID_mssnapd_ResultViews;
            break;

        case SEL_TOOLS_ROOT:
            dwHelpContextID = HID_mssnapd_Tools;
            break;

        case SEL_TOOLS_IMAGE_LISTS:
        case SEL_TOOLS_IMAGE_LISTS_NAME:
            dwHelpContextID = HID_mssnapd_ImageLists;
            break;

        case SEL_VIEWS_LIST_VIEWS:
        case SEL_VIEWS_LIST_VIEWS_NAME:
            dwHelpContextID = HID_mssnapd_ListViews;
            break;

        case SEL_VIEWS_OCX:
        case SEL_VIEWS_OCX_NAME:
            dwHelpContextID = HID_mssnapd_OCXViews;
            break;

        case SEL_VIEWS_URL:
        case SEL_VIEWS_URL_NAME:
            dwHelpContextID = HID_mssnapd_URLViews;
            break;

        case SEL_VIEWS_TASK_PAD:
        case SEL_VIEWS_TASK_PAD_NAME:
            dwHelpContextID = HID_mssnapd_Taskpads;
            break;

        case SEL_TOOLS_TOOLBARS:
        case SEL_TOOLS_TOOLBARS_NAME:
            dwHelpContextID = HID_mssnapd_Toolbars;
            break;

        case SEL_TOOLS_MENUS:
        case SEL_TOOLS_MENUS_NAME:
            dwHelpContextID = HID_mssnapd_Menus;
            break;

        default:
            dwHelpContextID = HID_mssnapd_DesignerWindow;
            break;
    }

    
DisplayHelp:
    g_GlobalHelp.ShowHelp(dwHelpContextID);
}

//=--------------------------------------------------------------------------=
// CSnapInDesigner::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------=
//
// Notes:
//
LRESULT CSnapInDesigner::WindowProc
(
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT     hr = S_FALSE;
    long        lResult = 0;
    HMENU       hmenuPopup = NULL;
    BOOL        fSystemMenu = FALSE;
    TCHAR      *pszNewName = NULL;

    switch (uMsg)
    {
    case WM_SIZE:
        hr = OnResize(uMsg, wParam, lParam);
        IfFailGo(hr);
        return TRUE;

    case WM_SETFOCUS:
        uMsg = uMsg;
//        hr = theView->OnGotFocus(uMsg, wParam, lParam, &lResult);
//        CSF_CHECK(SUCCEEDED(hr), hr, CSF_TRACE_INTERNAL_ERRORS);
        return TRUE;

    case WM_ACTIVATE:
        uMsg = uMsg;
        return TRUE;

    case WM_NOTIFY:
        hr = OnNotify(uMsg, wParam, lParam, &lResult);
        IfFailGo(hr);
        return (0 == lResult) ? FALSE : TRUE;

    case WM_COMMAND:
        hr = OnCommand(uMsg, wParam, lParam);
        IfFailGo(hr);
        return TRUE;

    case WM_INITMENUPOPUP:
        hmenuPopup = reinterpret_cast<HMENU>(wParam);
        fSystemMenu = static_cast<BOOL>(HIWORD(lParam));
        if (fSystemMenu == FALSE)
        {
            hr = OnInitMenuPopup(hmenuPopup);
            IfFailGo(hr);
        }
        return TRUE;

    case WM_CONTEXTMENU:
        hr = OnContextMenu(m_hwnd, uMsg, wParam, lParam);
        IfFailGo(hr);
        return TRUE;

    case WM_HELP:
        OnHelp();
        return TRUE;

    case CMD_SHOW_MAIN_PROPERTIES:
        hr = ShowProperties(m_pRootNode);
        IfFailGo(hr);
        return TRUE;

    case CMD_ADD_EXISTING_VIEW:
        hr = AddExistingView(reinterpret_cast<MMCViewMenuInfo *>(lParam));
        IfFailGo(hr);
        return TRUE;

    case CMD_RENAME_NODE:
        pszNewName = reinterpret_cast<TCHAR *>(lParam);
        ASSERT(NULL != pszNewName, "WindowProc: pszNewName is NULL");

        hr = DoRename(m_pCurrentSelection, pszNewName);
        IfFailGo(hr);

        ::CtlFree(pszNewName);
        return TRUE;

    default:
        return OcxDefWindowProc(uMsg, wParam, lParam);
    }

Error:
    return FALSE;
}


//=--------------------------------------------------------------------------=
// CSnapInDesigner::OnDraw(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize)
//=--------------------------------------------------------------------------=
//
// Notes:
//
STDMETHODIMP CSnapInDesigner::OnDraw
(
    DWORD    dvAspect,
    HDC      hdcDraw,
    LPCRECTL prcBounds,
    LPCRECTL prcWBounds,
    HDC      hicTargetDev,
    BOOL     fOptimize
)
{
    return S_OK;
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnResize(UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnResize
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT     hr = S_FALSE;
    HWND        hwdParent = NULL;
    RECT        rcClient;
    int         iWidth = 0;
    int         iToolbarHeight = 0;

    if (m_hwnd)
    {
        hwdParent = ::GetParent(m_hwnd);
        ::GetClientRect(hwdParent, &rcClient);

        iWidth = rcClient.right - rcClient.left;

        // Resize ourselves
        ::MoveWindow(m_hwnd,
                     0,
                     0,
                     iWidth,
                     rcClient.bottom - rcClient.top,
                     SWP_NOZORDER | SWP_NOACTIVATE);

        // Resize the toolbar
        iToolbarHeight = m_rcToolbar.bottom - m_rcToolbar.top;

        ::MoveWindow(m_hwdToolbar,
                     0,
                     0,
                     iWidth,
                     iToolbarHeight,
                     SWP_NOZORDER | SWP_NOACTIVATE);

        // Resize the tree view
        if (NULL != m_pTreeView)
        {
            ::MoveWindow(m_pTreeView->TreeViewWindow(),
                         0,
                         iToolbarHeight,
                         iWidth,
                         rcClient.bottom - rcClient.top - iToolbarHeight,
                         SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnCommand(UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnCommand
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT   hr = S_OK;
    WORD      wNotifyCode = HIWORD(wParam);             // Should be zero if from a menu
    WORD      wID = LOWORD(wParam);                             // Menu item

    m_bDoingPromoteOrDemote = false;

    switch (wID)
    {
    case CMD_ADD_NODE:
        hr = AddNewNode();
        IfFailGo(hr);
        break;

    case CMD_ADD_LISTVIEW:
        hr = AddListView();
        IfFailGo(hr);
        break;

    case CMD_ADD_TASKPAD:
        hr = AddTaskpadView();
        IfFailGo(hr);
        break;

    case CMD_ADD_OCX_VIEW:
        hr = AddOCXView();
        IfFailGo(hr);
        break;

    case CMD_ADD_WEB_VIEW:
        hr = AddURLView();
        IfFailGo(hr);
        break;

    case CMD_ADD_IMAGE_LIST:
        hr = AddImageList();
        IfFailGo(hr);
        break;

    case CMD_ADD_TOOLBAR:
        hr = AddToolbar();
        IfFailGo(hr);
        break;

    case CMD_ADD_MENU:
        hr = AddMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_DEMOTE:
        hr = DemoteMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_PROMOTE:
        hr = PromoteMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_MOVE_UP:
        hr = MoveMenuUp(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_MOVE_DOWN:
        hr = MoveMenuDown(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_VIEW_PROPERTIES:
        hr = ShowProperties(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_RENAME:
        hr = m_pTreeView->Edit(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_VIEW_DLGUNITS:
        IfFailGo(ShowDlgUnitConverter());
        break;

    case CMD_DELETE:
        hr = DoDelete(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_CM_NEW:
        hr = DoExtensionNewMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_CM_TASK:
        hr = DoExtensionTaskMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;
    case CMD_EXT_PPAGES:
        hr = DoExtensionPropertyPages(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_TASKPAD:
        hr = DoExtensionTaskpad(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_TOOLBAR:
        hr = DoExtensionToolbar(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXT_NAMESPACE:
        hr = DoExtensionNameSpace(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_NEW_MENU:
        hr = DoMyExtendsNewMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_TASK_MENU:
        hr = DoMyExtendsTaskMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_TOP_MENU:
        hr = DoMyExtendsTopMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_VIEW_MENU:
        hr = DoMyExtendsViewMenu(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_PPAGES:
        hr = DoMyExtendsPPages(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_TOOLBAR:
        hr = DoMyExtendsToolbar(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_EXTE_NAMESPACE:
        hr = DoMyExtendsNameSpace(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    case CMD_ADD_RESOURCE:
        hr = AddResource();
        IfFailGo(hr);
        break;

    case CMD_VIEW_RESOURCE_REFRESH:
        hr = RefreshResource(m_pCurrentSelection);
        IfFailGo(hr);
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnNotify(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *lResult)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnNotify
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *lResult
)
{
        HRESULT           hr = S_FALSE;
        int               idCtrl;
        LPNMHDR           pnmh = NULL;
        NM_TREEVIEW          *pnmtv = NULL;
        HTREEITEM         htiCurrent = NULL;
    CSelectionHolder  selection;
    CSelectionHolder *pSelection = NULL;
    DWORD             dwPos = 0;
    POINT             pHit;
    NMTVDISPINFO     *pnmTVDispInfo = NULL;
    TCHAR            *pszNewName = NULL;

    idCtrl = static_cast<int>(wParam);
        pnmh = reinterpret_cast<LPNMHDR>(lParam);

        switch (pnmh->code)
        {
    case TTN_NEEDTEXT:
        hr = OnNeedText(lParam);
        IfFailGo(hr);
        break;

        case NM_DBLCLK:
        dwPos = ::GetMessagePos();

        pHit.x = static_cast<LONG>(static_cast<short>(LOWORD(dwPos)));
        pHit.y = static_cast<LONG>(static_cast<short>(HIWORD(dwPos)));

        ::ScreenToClient(m_pTreeView->TreeViewWindow(), &pHit);

        hr = m_pTreeView->HitTest(pHit, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
        {
            hr = OnDoubleClick(pSelection);
            IfFailGo(hr);

            if (hr == S_FALSE)
            {
                WinProcHandled(FALSE);
            }
            else
            {
                WinProcHandled(TRUE);
            }
            hr = S_OK;
        }
        else
        {
            WinProcHandled(FALSE);
        }
        break;

    case TVN_SELCHANGED:
                pnmtv = reinterpret_cast<NM_TREEVIEW *>(lParam);
        htiCurrent = pnmtv->itemNew.hItem;

        selection.m_pvData = htiCurrent;
        hr = m_pTreeView->GetItemParam(htiCurrent, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
        {
            hr = OnSelectionChanged(pSelection);
            IfFailGo(hr);
        }
        WinProcHandled(FALSE);
        break;

    case TVN_ITEMEXPANDED:
                pnmtv = reinterpret_cast<NM_TREEVIEW *>(lParam);
        if (pnmtv->action == TVE_COLLAPSE)
        {
            htiCurrent = pnmtv->itemNew.hItem;

            selection.m_pvData = htiCurrent;
            hr = m_pTreeView->GetItemParam(htiCurrent, &pSelection);
            IfFailGo(hr);

            if (SEL_NODES_ANY_NAME != pSelection->m_st && SEL_TOOLS_MENUS_NAME != pSelection->m_st)
            {
                hr = m_pTreeView->ChangeNodeIcon(pSelection, kClosedFolderIcon);
                IfFailGo(hr);
            }
        }
        else if (pnmtv->action == TVE_EXPAND)
        {
            htiCurrent = pnmtv->itemNew.hItem;

            selection.m_pvData = htiCurrent;
            hr = m_pTreeView->GetItemParam(htiCurrent, &pSelection);
            IfFailGo(hr);

            if (SEL_NODES_ANY_NAME != pSelection->m_st && SEL_TOOLS_MENUS_NAME != pSelection->m_st)
            {
                hr = m_pTreeView->ChangeNodeIcon(pSelection, kOpenFolderIcon);
                IfFailGo(hr);
            }
        }
        WinProcHandled(FALSE);
        break;

    case TVN_KEYDOWN:
        hr = OnKeyDown(reinterpret_cast<NMTVKEYDOWN *>(lParam));
        IfFailGo(hr);

        WinProcHandled(FALSE);
        break;

    case TVN_BEGINLABELEDIT:
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
        case SEL_NODES_ANY_NAME:
        case SEL_TOOLS_IMAGE_LISTS_NAME:
        case SEL_TOOLS_MENUS_NAME:
        case SEL_TOOLS_TOOLBARS_NAME:
        case SEL_VIEWS_LIST_VIEWS_NAME:
        case SEL_VIEWS_OCX_NAME:
        case SEL_VIEWS_URL_NAME:
        case SEL_VIEWS_TASK_PAD_NAME:
        case SEL_XML_RESOURCE_NAME:
            WinProcHandled(FALSE);  // Enable label editing
            break;
        default:
            WinProcHandled(TRUE);   // Disable label editing
            break;
        }
        break;

    case TVN_ENDLABELEDIT:
        // This message needs to complete before we attempt any further operations,
        // so at this point the only thing we do is post another message.
        pnmTVDispInfo = reinterpret_cast<NMTVDISPINFO *>(lParam);
        ASSERT(NULL != pnmTVDispInfo, "OnNotify: pnmTVDispInfo is NULL");

        if ( (NULL != pnmTVDispInfo->item.pszText) &&
             (pnmTVDispInfo->item.cchTextMax < 1024) )
        {
            pszNewName = reinterpret_cast<TCHAR *>(::CtlAlloc(sizeof(TCHAR) * (pnmTVDispInfo->item.cchTextMax + 1)));
            if (NULL == pszNewName)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            _tcscpy(pszNewName, pnmTVDispInfo->item.pszText);

            ::PostMessage(m_hwnd, CMD_RENAME_NODE, 0, reinterpret_cast<LPARAM>(pszNewName));
            WinProcHandled(FALSE);
        }
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnNeedText(LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnNeedText
(
    LPARAM lParam
)
{
    HRESULT         hr = S_OK;
        LPTOOLTIPTEXT   pttt = NULL;
        int             x = 0;

    pttt = reinterpret_cast<LPTOOLTIPTEXT>(lParam);
    pttt->hinst = GetResourceHandle();

    // get the resource id associated with this ID
    while (0xffff != g_tooltipMappings[x].id)
    {
        if (g_tooltipMappings[x].id == pttt->hdr.idFrom)
            break;
        x++;
    }

    if (0xffff != g_tooltipMappings[x].id)
        pttt->lpszText = MAKEINTRESOURCE(g_tooltipMappings[x].resid);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDoubleClick(CSelectionHolder *pSelection)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnDoubleClick
(
    CSelectionHolder *pSelection
)
{
    HRESULT          hr = S_OK;
    BSTR             bstrObject = NULL;
    BSTR             bstrEventHandler = NULL;
    ICodeNavigate   *piCodeNavigate = NULL;
    IMMCButtons     *piMMCButtons = NULL;
    IMMCButton      *piMMCButton = NULL;
    long             cButtons = 0;
    ITaskpad        *piTaskpad = NULL;

    SnapInTaskpadTypeConstants TaskpadType = Default;

    SnapInButtonStyleConstants ButtonStyle = siDefault;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    ASSERT(pSelection != NULL, "OnDoubleClick: pSelection is NULL");

    switch (pSelection->m_st)
    {
    case SEL_SNAPIN_ROOT:
        bstrObject = ::SysAllocString(L"SnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Load");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_ROOT:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_NEW_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddNewMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_TASK_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTaskMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_TOP_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTopMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_VIEW_MENU:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddViewMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_PPAGES:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"CreatePropertyPages");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_TOOLBAR:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"SetControlBar");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EXTENSIONS_NAMESPACE:
        bstrObject = ::SysAllocString(L"ScopeItems");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_CC_ROOT:
    case SEL_EEXTENSIONS_CC_NEW:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddNewMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_CC_TASK:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTaskMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_PP_ROOT:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"CreatePropertyPages");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_TASKPAD:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTasks");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_TOOLBAR:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        bstrEventHandler = ::SysAllocString(L"SetControlBar");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_EEXTENSIONS_NAMESPACE:
        bstrObject = ::SysAllocString(L"ExtensionSnapIn");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;


    case SEL_NODES_ROOT:
    case SEL_NODES_AUTO_CREATE:
    case SEL_NODES_AUTO_CREATE_ROOT:
    case SEL_NODES_ANY_NAME:
    case SEL_NODES_AUTO_CREATE_RTCH:
    case SEL_NODES_ANY_CHILDREN:
        bstrObject = ::SysAllocString(L"ScopeItems");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Initialize");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_NODES_OTHER:
        bstrObject = ::SysAllocString(L"ScopeItems");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Expand");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_NODES_AUTO_CREATE_RTVW:
    case SEL_NODES_ANY_VIEWS:
    case SEL_TOOLS_ROOT:
    case SEL_TOOLS_IMAGE_LISTS:
    case SEL_TOOLS_IMAGE_LISTS_NAME:
    case SEL_VIEWS_ROOT:
    case SEL_VIEWS_LIST_VIEWS:
    case SEL_VIEWS_OCX:
    case SEL_VIEWS_URL:
    case SEL_VIEWS_URL_NAME:
    case SEL_VIEWS_TASK_PAD:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Initialize");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_VIEWS_OCX_NAME:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"InitializeControl");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_VIEWS_TASK_PAD_NAME:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(pSelection->m_piObject.m_piTaskpadViewDef->get_Taskpad(&piTaskpad));
        IfFailGo(piTaskpad->get_Type(&TaskpadType));

        if (Listpad == TaskpadType)
        {
            bstrEventHandler = ::SysAllocString(L"ListpadButtonClick");
        }
        else if (Custom == TaskpadType)
        {
            bstrEventHandler = ::SysAllocString(L"TaskNotify");
        }
        else // default taskpad
        {
            bstrEventHandler = ::SysAllocString(L"TaskClick");
        }
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_TOOLBARS:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"SetControlBar");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_MENUS:
        bstrObject = ::SysAllocString(L"Views");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"AddTopMenuItems");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_MENUS_NAME:
        hr = pSelection->m_piObject.m_piMMCMenu->get_Name(&bstrObject);
        IfFailGo(hr);

        bstrEventHandler = ::SysAllocString(L"Click");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    case SEL_TOOLS_TOOLBARS_NAME:

        hr = pSelection->m_piObject.m_piMMCToolbar->get_Name(&bstrObject);
        IfFailGo(hr);

        // Determine whether this toolbar represents a toolbar or a menu
        // button by examining the button styles. A menu button is defined by
        // a toolbar in which all buttons have the dropdown style.

        IfFailGo(pSelection->m_piObject.m_piMMCToolbar->get_Buttons(reinterpret_cast<MMCButtons **>(&piMMCButtons)));
        IfFailGo(piMMCButtons->get_Count(&cButtons));

        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;

        while ( (varIndex.lVal <= cButtons) && (NULL == bstrEventHandler) )
        {
            IfFailGo(piMMCButtons->get_Item(varIndex, reinterpret_cast<MMCButton **>(&piMMCButton)));
            IfFailGo(piMMCButton->get_Style(&ButtonStyle));
            if (siDropDown != ButtonStyle)
            {
                // Found a button that is not dropdown style. Assume this is
                // a toolbar.

                bstrEventHandler = ::SysAllocString(L"ButtonClick");
                if (NULL == bstrEventHandler)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }
            }
            varIndex.lVal++;
        }

        // If we are here and the loop didn't set the event handler name then
        // either the toolbar has no buttons defined or all of the buttons have
        // the dropdown style which means that the toolbar represents a menu
        // button.

        if (NULL == bstrEventHandler)
        {
            if (0 == cButtons)
            {
                // No buttons defined. Default to a toolbar.
                bstrEventHandler = ::SysAllocString(L"ButtonClick");
            }
            else
            {
                bstrEventHandler = ::SysAllocString(L"ButtonMenuClick");
            }
            if (NULL == bstrEventHandler)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
        }

        break;

    case SEL_VIEWS_LIST_VIEWS_NAME:
        bstrObject = ::SysAllocString(L"ResultViews");
        if (NULL == bstrObject)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        bstrEventHandler = ::SysAllocString(L"Initialize");
        if (NULL == bstrEventHandler)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        break;

    default:
        hr = S_FALSE;
        break;
    }

    if (NULL != m_piCodeNavigate2)
    {
        if (NULL != bstrEventHandler)
        {
            hr = m_piCodeNavigate2->DisplayEventHandler(bstrObject, bstrEventHandler);
            IfFailGo(hr);
        }
        else if (NULL != bstrObject)
        {
            hr = m_piCodeNavigate2->QueryInterface(IID_ICodeNavigate, reinterpret_cast<void **>(&piCodeNavigate));
            IfFailGo(hr);

            hr = piCodeNavigate->DisplayDefaultEventHandler(bstrObject);
            IfFailGo(hr);
        }
    }

Error:
    QUICK_RELEASE(piCodeNavigate);
    QUICK_RELEASE(piTaskpad);
    FREESTRING(bstrEventHandler);
    FREESTRING(bstrObject);
    QUICK_RELEASE(piMMCButtons);
    QUICK_RELEASE(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnPrepareToolbar()
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnPrepareToolbar()
{
    HRESULT     hr = S_OK;
    LRESULT             lResult = 0;

    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_PROMOTE, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_DEMOTE, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_UP, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_DOWN, MAKELONG(TRUE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(FALSE, 0));
    lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(FALSE, 0));

    if (m_pCurrentSelection != NULL)
    {
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        // Extensions subtree
        case SEL_EXTENSIONS_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_EEXTENSIONS_NAME:
        case SEL_EEXTENSIONS_CC_NEW:
        case SEL_EEXTENSIONS_CC_TASK:
        case SEL_EEXTENSIONS_PP_ROOT:
        case SEL_EEXTENSIONS_TASKPAD:
        case SEL_EEXTENSIONS_TOOLBAR:
        case SEL_EEXTENSIONS_NAMESPACE:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        // We turn bits off in the extensibility model by deleting a node from the tree.
        case SEL_EXTENSIONS_NEW_MENU:
        case SEL_EXTENSIONS_TASK_MENU:
        case SEL_EXTENSIONS_TOP_MENU:
        case SEL_EXTENSIONS_VIEW_MENU:
        case SEL_EXTENSIONS_PPAGES:
        case SEL_EXTENSIONS_TOOLBAR:
        case SEL_EXTENSIONS_NAMESPACE:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_AUTO_CREATE_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_OTHER:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_ANY_NAME:
            // Enable new node, net view buttons.
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_ANY_CHILDREN:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_NODE, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_NODES_ANY_VIEWS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        // Tools subtree
        case SEL_TOOLS_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_IMAGE_LIST, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_MENUS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_MENUS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_PROMOTE, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_DEMOTE, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_UP, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_HIDEBUTTON,   (WPARAM) CMD_MOVE_DOWN, MAKELONG(FALSE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));

            hr = CanPromoteMenu(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_PROMOTE, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_PROMOTE, MAKELONG(FALSE, 0));

            hr = CanDemoteMenu(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DEMOTE, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DEMOTE, MAKELONG(FALSE, 0));

            hr = CanMoveMenuUp(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_UP, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_UP, MAKELONG(FALSE, 0));

            hr = CanMoveMenuDown(m_pCurrentSelection);
            IfFailGo(hr);
            if (S_OK == hr)
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_DOWN, MAKELONG(TRUE, 0));
            else
                lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_MOVE_DOWN, MAKELONG(FALSE, 0));

            break;

        case SEL_TOOLS_TOOLBARS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(TRUE, 0));
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TOOLBAR, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        // View subtree
        case SEL_VIEWS_ROOT:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_LIST_VIEWS:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_LISTVIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_OCX:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_OCX_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_OCX_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_URL:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_WEB_VIEW, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_URL_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_TASK_PAD:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_TASKPAD, MAKELONG(TRUE, 0));
            break;

        case SEL_VIEWS_TASK_PAD_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;

        case SEL_XML_RESOURCES:
//            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_ADD_MENU, MAKELONG(TRUE, 0));
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_VIEW_PROPERTIES, MAKELONG(TRUE, 0));
            break;

        case SEL_XML_RESOURCE_NAME:
            lResult = ::SendMessage(m_hwdToolbar, TB_ENABLEBUTTON, (WPARAM) CMD_DELETE, MAKELONG(TRUE, 0));
            break;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnKeyDown(NMTVKEYDOWN *pNMTVKeyDown)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnKeyDown(NMTVKEYDOWN *pNMTVKeyDown)
{
    HRESULT     hr = S_OK;

    switch (pNMTVKeyDown->wVKey)
    {
    case VK_DELETE:
        hr = DoDelete(m_pCurrentSelection);
        IfFailGo(hr);
        break;

    default:
        break;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnContextMenu(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnContextMenu
(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HRESULT           hr = S_OK;
    DWORD             dwPos = 0;
    POINT             pHit;
    CSelectionHolder *pSelection = NULL;
    RECT              rc;

    // lParam is valid if this is a right mouse click
    if (-1 != lParam)
    {
        // Make sure we select the tree item under the mouse
        dwPos = ::GetMessagePos();

        // Vegas #46772: Multi-monitor support
        pHit.x = (LONG)(short)LOWORD(dwPos);
        pHit.y = (LONG)(short)HIWORD(dwPos);
        ::ScreenToClient(m_pTreeView->TreeViewWindow(), &pHit);

        hr = m_pTreeView->HitTest(pHit, &pSelection);
        IfFailGo(hr);

        if (pSelection != NULL)
        {
            // First make sure that the item we're clicking on is selected
            if (m_pCurrentSelection == NULL || m_pCurrentSelection->IsEqual(pSelection) != true)
            {
                hr = OnSelectionChanged(pSelection);
                IfFailGo(hr);

                hr = m_pTreeView->SelectItem(pSelection);
                IfFailGo(hr);
            }
        }
    }

    if (NULL != m_pCurrentSelection)
    {
        hr = m_pTreeView->GetRectangle(m_pCurrentSelection, &rc);
        IfFailGo(hr);

        pHit.x = rc.right;
        pHit.y = rc.top;
        ::ClientToScreen(m_pTreeView->TreeViewWindow(), &pHit);
        IfFailGo(hr);

        hr = DoOnContextMenu(pHit.x, pHit.y);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DoOnContextMenu(int x, int y)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::DoOnContextMenu(int x, int y)
{
    HRESULT           hr = S_OK;
    HMENU             hMenu = NULL;
    HMENU             hSubMenu = NULL;
    int               iCmd = 0;

    if (m_pCurrentSelection != NULL)
    {
        // Select the appropriate MENU resouce
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_ROOT));
            CheckHMenuResult(hMenu);
            break;

        case SEL_EXTENSIONS_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_EXTENSIONS_ROOT));
            CheckHMenuResult(hMenu);
            break;

        case SEL_EEXTENSIONS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_EXTENSIONS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_EXTENSIONS_MYNAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_THIS_EXTENSIONS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_AUTO_CREATE_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_STATIC_NODE));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_NODE_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_ANY_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_NODE));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_NODE_CHILDREN));
            CheckHMenuResult(hMenu);
            break;

        case SEL_NODES_OTHER:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_NODE_OTHER));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TOOLS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_IMAGE_LISTS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_IMAGE_LIST));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_MENUS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_MENUS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_MENUS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_MENU));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_TOOLBARS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TOOLBARS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TOOLBAR));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_ROOT:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_LIST_VIEWS:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_LIST_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_OCX:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_OCX_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_URL:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_URL_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_TASK_PAD:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_TASKPAD_VIEWS));
            CheckHMenuResult(hMenu);
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
        case SEL_VIEWS_OCX_NAME:
        case SEL_VIEWS_URL_NAME:
        case SEL_VIEWS_TASK_PAD_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_VIEW));
            CheckHMenuResult(hMenu);
            break;

        case SEL_XML_RESOURCES:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_RESOURCES));
            CheckHMenuResult(hMenu);
            break;

        case SEL_XML_RESOURCE_NAME:
            hMenu = ::LoadMenu(GetResourceHandle(), MAKEINTRESOURCE(IDR_MENU_RESOURCE));
            CheckHMenuResult(hMenu);
            break;
        }

        // If we've got a resource, invoke the menu
        if (hMenu != NULL)
        {
            hSubMenu = ::GetSubMenu(hMenu, 0);
            if (hSubMenu == NULL)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK_GO(hr);
            }

            iCmd = ::TrackPopupMenu(hSubMenu,
                                    TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                    x,
                                    y,
                                    0,
                                    m_hwnd,
                                    NULL);

            if (SEL_NODES_AUTO_CREATE_ROOT == m_pCurrentSelection->m_st
             || SEL_NODES_AUTO_CREATE_RTVW == m_pCurrentSelection->m_st
             || SEL_NODES_ANY_VIEWS == m_pCurrentSelection->m_st
             || SEL_NODES_ANY_NAME == m_pCurrentSelection->m_st)
            {
                hr = CleanPopupNodeViews(hSubMenu, iCmd);
                IfFailGo(hr);
            }

            ::PostMessage(m_hwnd, WM_COMMAND, iCmd, 0);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopup(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopup
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    if (m_pCurrentSelection != NULL)
    {
        switch (m_pCurrentSelection->m_st)
        {
        case SEL_SNAPIN_ROOT:
            hr = OnInitMenuPopupRoot(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_EXTENSIONS_ROOT:
            hr = OnInitMenuPopupExtensionRoot(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_EEXTENSIONS_NAME:
            hr = OnInitMenuPopupExtension(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_EXTENSIONS_MYNAME:
            hr = OnInitMenuPopupMyExtensions(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_ROOT:
            hr = OnInitMenuPopupStaticNode(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_ANY_NAME:
            hr = OnInitMenuPopupNode(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTCH:
        case SEL_NODES_ANY_CHILDREN:
            hr = OnInitMenuPopupNodeChildren(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_AUTO_CREATE_RTVW:
        case SEL_NODES_ANY_VIEWS:
            hr = OnInitMenuPopupNodeViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_NODES_OTHER:
            hr = OnInitMenuPopupNodeOther(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_ROOT:
            hr = OnInitMenuPopupToolsRoot(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS:
            hr = OnInitMenuPopupImageLists(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_IMAGE_LISTS_NAME:
            hr = OnInitMenuPopupImageList(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS:
            hr = OnInitMenuPopupMenus(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_MENUS_NAME:
            hr = OnInitMenuPopupMenu(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS:
            hr = OnInitMenuPopupToolbars(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_TOOLS_TOOLBARS_NAME:
            hr = OnInitMenuPopupToolbar(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_ROOT:
            hr = OnInitMenuPopupViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_LIST_VIEWS:
            hr = OnInitMenuPopupListViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_OCX:
            hr = OnInitMenuPopupOCXViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_URL:
            hr = OnInitMenuPopupURLViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_TASK_PAD:
            hr = OnInitMenuPopupTaskpadViews(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_VIEWS_LIST_VIEWS_NAME:
        case SEL_VIEWS_OCX_NAME:
        case SEL_VIEWS_URL_NAME:
        case SEL_VIEWS_TASK_PAD_NAME:
            hr = OnInitMenuPopupView(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCES:
            hr = OnInitMenuPopupResources(hmenuPopup);
            IfFailGo(hr);
            break;

        case SEL_XML_RESOURCE_NAME:
            hr = OnInitMenuPopupResourceName(hmenuPopup);
            IfFailGo(hr);
            break;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupRoot(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupRoot
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupExtensionRoot(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupExtensionRoot
(
    HMENU hmenuPopup
)
{
    HRESULT                     hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupExtension(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupExtension
(
    HMENU hmenuPopup
)
{
    HRESULT                     hr = S_OK;
    VARIANT_BOOL        bValue = VARIANT_FALSE;

    ASSERT(NULL != m_pCurrentSelection, "OnInitMenuPopupExtension: Current selection is NULL");
    ASSERT(SEL_EEXTENSIONS_NAME == m_pCurrentSelection->m_st, "OnInitMenuPopupExtension: Unexpected current selection is NULL");

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_NEW, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_NEW, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_TASK, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_CM_TASK, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_PPAGES, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_PPAGES, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsTaskpad(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TASKPAD, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_TOOLBAR, MF_BYCOMMAND | MF_GRAYED);

    hr = m_pCurrentSelection->m_piObject.m_piExtendedSnapIn->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXT_NAMESPACE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXT_NAMESPACE, MF_BYCOMMAND | MF_GRAYED);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupMyExtensions(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupMyExtensions
(
    HMENU hmenuPopup
)
{
    HRESULT                     hr = S_OK;
    IExtensionDefs     *piExtensionDefs = NULL;
    VARIANT_BOOL        bValue = VARIANT_FALSE;

    m_piSnapInDesignerDef->get_ExtensionDefs(&piExtensionDefs);
    IfFailGo(hr);

    hr = piExtensionDefs->get_ExtendsNewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NEW_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NEW_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsTaskMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TASK_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TASK_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsTopMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOP_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOP_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsPropertyPages(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_PPAGES, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_PPAGES, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsViewMenu(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_VIEW_MENU, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_VIEW_MENU, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsToolbar(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_TOOLBAR, MF_BYCOMMAND | MF_GRAYED);

    hr = piExtensionDefs->get_ExtendsNameSpace(&bValue);
    IfFailGo(hr);

    if (VARIANT_FALSE == bValue)
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NAMESPACE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_EXTE_NAMESPACE, MF_BYCOMMAND | MF_GRAYED);

Error:
    RELEASE(piExtensionDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupStaticNode(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupStaticNode
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;
    HMENU       hAddViewMenu = NULL;
    HMENU       hExistingViewsMenu = NULL;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    hAddViewMenu = ::GetSubMenu(hmenuPopup, 1);
    if (hAddViewMenu != NULL)
    {
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);
    }

    hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 2);
    if (hExistingViewsMenu != NULL)
    {
        hr = PopulateNodeViewsMenu(hExistingViewsMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNode(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNode
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;
    HMENU       hAddViewMenu = NULL;
    HMENU       hExistingViewsMenu = NULL;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    hAddViewMenu = ::GetSubMenu(hmenuPopup, 2);
    if (hAddViewMenu != NULL)
    {
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);
    }

    hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 3);
    if (hExistingViewsMenu != NULL)
    {
        hr = PopulateNodeViewsMenu(hExistingViewsMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNodeChildren(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNodeChildren
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNodeChildren(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNodeOther
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_NODE, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupNodeViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupNodeViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;
    HMENU       hAddViewMenu = NULL;
    HMENU       hExistingViewsMenu = NULL;

    hAddViewMenu = ::GetSubMenu(hmenuPopup, 0);
    if (hAddViewMenu != NULL)
    {
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
        ::EnableMenuItem(hAddViewMenu, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);
    }

    hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 1);
    if (hExistingViewsMenu != NULL)
    {
        hr = PopulateNodeViewsMenu(hExistingViewsMenu);
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupToolsRoot(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupToolsRoot
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_IMAGE_LIST, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_MENU, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupImageLists(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupImageLists
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_IMAGE_LIST, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupImageList(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupImageList
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupMenus(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupMenus
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_MENU, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupMenu(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupMenu
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_MENU, MF_BYCOMMAND | MF_ENABLED);

    hr = CanDemoteMenu(m_pCurrentSelection);
    IfFailGo(hr);

    if (S_OK == hr)
        ::EnableMenuItem(hmenuPopup, CMD_DEMOTE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_DEMOTE, MF_BYCOMMAND | MF_GRAYED);

    hr = CanPromoteMenu(m_pCurrentSelection);
    IfFailGo(hr);

    if (S_OK == hr)
        ::EnableMenuItem(hmenuPopup, CMD_PROMOTE, MF_BYCOMMAND | MF_ENABLED);
    else
        ::EnableMenuItem(hmenuPopup, CMD_PROMOTE, MF_BYCOMMAND | MF_GRAYED);

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupToolbars(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupToolbars
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_TOOLBAR, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupToolbar(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupToolbar
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupListViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupListViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_LISTVIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupOCXViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupOCXViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_OCX_VIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupURLViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupURLViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_WEB_VIEW, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupTaskpadViews(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupTaskpadViews
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_TASKPAD, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupView(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupView
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_PROPERTIES, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupResources(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupResources
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_ADD_RESOURCE, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnInitMenuPopupResourceName(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::OnInitMenuPopupResourceName
(
    HMENU hmenuPopup
)
{
    HRESULT             hr = S_OK;

    ::EnableMenuItem(hmenuPopup, CMD_RENAME, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_DELETE, MF_BYCOMMAND | MF_ENABLED);
    ::EnableMenuItem(hmenuPopup, CMD_VIEW_RESOURCE_REFRESH, MF_BYCOMMAND | MF_ENABLED);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddViewToViewMenu(HMENU hMenu, int iMenuItem, char *pszMenuItemText)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::AddViewToViewMenu(HMENU hMenu, int iMenuItem, char *pszMenuItemText, MMCViewMenuInfo *pMMCViewMenuInfo)
{
    HRESULT       hr = S_OK;
    MENUITEMINFO  minfo;
    BOOL          bReturn = FALSE;

    ::memset(&minfo, 0, sizeof(MENUITEMINFO));

    minfo.cbSize = sizeof(MENUITEMINFO);
    minfo.fMask = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
    minfo.fType = MFT_STRING;
    minfo.fState = MFS_ENABLED;
    minfo.wID = CMD_ADD_EXISTING_VIEW + iMenuItem;
    minfo.dwItemData = reinterpret_cast<DWORD>(pMMCViewMenuInfo);
    minfo.dwTypeData = pszMenuItemText;
    minfo.cch = ::strlen(pszMenuItemText);

    bReturn = ::InsertMenuItem(hMenu, iMenuItem, TRUE, &minfo);
    if (bReturn == FALSE)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindListViewInCollection(BSTR bstrName, IListViewDefs *piListViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindListViewInCollection
(
    BSTR           bstrName,
    IListViewDefs *piListViewDefs
)
{
    HRESULT        hr = S_OK;
    VARIANT        vtKey;
    IListViewDef  *piListViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piListViewDefs->get_Item(vtKey, &piListViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

    IfFailGo(hr);

Error:
    RELEASE(piListViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateListViews(HMENU hMenu, int *piCurrentMenuItem, IListViewDefs *piListViewDefs, IListViewDefs *piTargetListViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateListViews
(
    HMENU          hMenu,
    int           *piCurrentMenuItem,
    IListViewDefs *piListViewDefs,
    IListViewDefs *piTargetListViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    IListViewDef    *piListViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piListViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piListViewDefs->get_Item(vtIndex, &piListViewDef);
        IfFailGo(hr);

        hr = piListViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = FindListViewInCollection(bstrName, piTargetListViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piListViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piListViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piListViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindOCXViewInCollection(BSTR bstrName, IOCXViewDefs *piOCXViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindOCXViewInCollection
(
    BSTR           bstrName,
    IOCXViewDefs  *piOCXViewDefs
)
{
    HRESULT        hr = S_OK;
    VARIANT        vtKey;
    IOCXViewDef   *piOCXViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piOCXViewDefs->get_Item(vtKey, &piOCXViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

    IfFailGo(hr);

Error:
    RELEASE(piOCXViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateOCXViews(HMENU hMenu, int *piCurrentMenuItem, IOCXViewDefs *piOCXViewDefs, IOCXViewDefs *piTargetOCXViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateOCXViews
(
    HMENU          hMenu,
    int           *piCurrentMenuItem,
    IOCXViewDefs  *piOCXViewDefs,
    IOCXViewDefs  *piTargetOCXViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    IOCXViewDef     *piOCXViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piOCXViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piOCXViewDefs->get_Item(vtIndex, &piOCXViewDef);
        IfFailGo(hr);

        hr = piOCXViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = FindOCXViewInCollection(bstrName, piTargetOCXViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piOCXViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piOCXViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piOCXViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindURLViewInCollection(BSTR bstrName, IURLViewDefs *piURLViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindURLViewInCollection
(
    BSTR           bstrName,
    IURLViewDefs  *piURLViewDefs
)
{
    HRESULT        hr = S_OK;
    VARIANT        vtKey;
    IURLViewDef   *piURLViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piURLViewDefs->get_Item(vtKey, &piURLViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

        goto Error;

Error:
    RELEASE(piURLViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateURLViews(HMENU hMenu, int *piCurrentMenuItem, IURLViewDefs *piURLViewDefs, IURLViewDefs *piTargetURLViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateURLViews
(
    HMENU          hMenu,
    int           *piCurrentMenuItem,
    IURLViewDefs  *piURLViewDefs,
    IURLViewDefs  *piTargetURLViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    IURLViewDef     *piURLViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piURLViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piURLViewDefs->get_Item(vtIndex, &piURLViewDef);
        IfFailGo(hr);

        hr = piURLViewDef->get_Name(&bstrName);
        IfFailGo(hr);

        hr = FindURLViewInCollection(bstrName, piTargetURLViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piURLViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piURLViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piURLViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::FindTaskpadViewInCollection(BSTR bstrName, ITaskpadViewDefs *piTaskpadViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::FindTaskpadViewInCollection
(
    BSTR               bstrName,
    ITaskpadViewDefs  *piTaskpadViewDefs
)
{
    HRESULT            hr = S_OK;
    VARIANT            vtKey;
    ITaskpadViewDef   *piTaskpadViewDef = NULL;

    ::VariantInit(&vtKey);

    vtKey.vt = VT_BSTR;
    vtKey.bstrVal = ::SysAllocString(bstrName);
    if (vtKey.bstrVal == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK(hr);
    }

    hr = piTaskpadViewDefs->get_Item(vtKey, &piTaskpadViewDef);
    if (hr == SID_E_ELEMENT_NOT_FOUND)
    {
        hr = S_FALSE;
        goto Error;
    }

    IfFailGo(hr);

Error:
    RELEASE(piTaskpadViewDef);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateTaskpadViews(HMENU hMenu, int *piCurrentMenuItem, ITaskpadViewDefs *piTaskpadViewDefs, ITaskpadViewDefs *piTargetTaskpadViewDefs)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateTaskpadViews
(
    HMENU             hMenu,
    int              *piCurrentMenuItem,
    ITaskpadViewDefs *piTaskpadViewDefs,
    ITaskpadViewDefs *piTargetTaskpadViewDefs
)
{
    HRESULT          hr = S_OK;
    long             lCount = 0;
    VARIANT          vtIndex;
    long             lIndex = 0;
    ITaskpadViewDef *piTaskpadViewDef = NULL;
    BSTR             bstrName = NULL;
    char            *pszName = NULL;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    hr = piTaskpadViewDefs->get_Count(&lCount);
    IfFailGo(hr);

    ::VariantInit(&vtIndex);
    vtIndex.vt = VT_I4;

    for (lIndex = 1; lIndex <= lCount; ++lIndex)
    {
        vtIndex.lVal = lIndex;
        hr = piTaskpadViewDefs->get_Item(vtIndex, &piTaskpadViewDef);
        IfFailGo(hr);

        hr = piTaskpadViewDef->get_Key(&bstrName);
        IfFailGo(hr);

        hr = FindTaskpadViewInCollection(bstrName, piTargetTaskpadViewDefs);
        IfFailGo(hr);

        if (hr == S_FALSE)
        {
            hr = ANSIFromWideStr(bstrName, &pszName);
            IfFailGo(hr);

            if (pszName != NULL && ::strlen(pszName) > 0)
            {
                pMMCViewMenuInfo = new MMCViewMenuInfo(piTaskpadViewDef);
                if (pMMCViewMenuInfo == NULL)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                hr = AddViewToViewMenu(hMenu, *piCurrentMenuItem, pszName, pMMCViewMenuInfo);
                IfFailGo(hr);

                ++(*piCurrentMenuItem);
                CtlFree(pszName);
                pszName = NULL;
            }
        }

        RELEASE(piTaskpadViewDef);
        FREESTRING(bstrName);
    }

Error:
    RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);
    if (pszName != NULL)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::PopulateNodeViewsMenu(HMENU hmenuPopup)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::PopulateNodeViewsMenu
(
    HMENU hmenuPopup
)
{
    HRESULT                   hr = S_OK;
    int               iMenuItem = 0;
    IViewDefs        *piTargetViewDefs = NULL;
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IListViewDefs    *piTargetListViewDefs = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IOCXViewDefs     *piTargetOCXViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    IURLViewDefs     *piTargetURLViewDefs = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDefs *piTargetTaskpadViewDefs = NULL;
    long              lCount = 0;

    ASSERT(m_piSnapInDesignerDef != NULL, "PopulateViews: m_piSnapInDesignerDef is NULL");

    hr = GetOwningViewCollection(&piTargetViewDefs);
    IfFailGo(hr);

    hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_ListViews(&piListViewDefs);
        IfFailGo(hr);

        if (NULL != piListViewDefs)
        {
            hr = piTargetViewDefs->get_ListViews(&piTargetListViewDefs);
            IfFailGo(hr);

            hr = PopulateListViews(hmenuPopup, &iMenuItem, piListViewDefs, piTargetListViewDefs);
            IfFailGo(hr);
        }

        hr = piViewDefs->get_OCXViews(&piOCXViewDefs);
        IfFailGo(hr);

        if (NULL != piOCXViewDefs)
        {
            hr = piTargetViewDefs->get_OCXViews(&piTargetOCXViewDefs);
            IfFailGo(hr);

            hr = PopulateOCXViews(hmenuPopup, &iMenuItem, piOCXViewDefs, piTargetOCXViewDefs);
            IfFailGo(hr);
        }

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        if (NULL != piURLViewDefs)
        {
            hr = piTargetViewDefs->get_URLViews(&piTargetURLViewDefs);
            IfFailGo(hr);

            hr = PopulateURLViews(hmenuPopup, &iMenuItem, piURLViewDefs, piTargetURLViewDefs);
            IfFailGo(hr);
        }

        hr = piViewDefs->get_TaskpadViews(&piTaskpadViewDefs);
        IfFailGo(hr);

        if (NULL != piTaskpadViewDefs)
        {
            hr = piTargetViewDefs->get_TaskpadViews(&piTargetTaskpadViewDefs);
            IfFailGo(hr);

            hr = PopulateTaskpadViews(hmenuPopup, &iMenuItem, piTaskpadViewDefs, piTargetTaskpadViewDefs);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piTargetListViewDefs);
    RELEASE(piListViewDefs);
    RELEASE(piTargetOCXViewDefs);
    RELEASE(piOCXViewDefs);
    RELEASE(piTargetURLViewDefs);
    RELEASE(piURLViewDefs);
    RELEASE(piTargetTaskpadViewDefs);
    RELEASE(piTaskpadViewDefs);
    RELEASE(piTargetViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::CleanPopupNodeViews(HMENU hmenuPopup, int iCmd)
//=--------------------------------------------------------------------------------------
//
//  Notes
//
HRESULT CSnapInDesigner::CleanPopupNodeViews
(
    HMENU hmenuPopup,
    int   iCmd
)
{
    HRESULT                  hr = S_OK;
    HMENU            hExistingViewsMenu = NULL;
    int              iCount = 0;
    int              iItemNumber = 0;
    MENUITEMINFO     menuItemInfo;
    BOOL             bReturn = FALSE;
    MMCViewMenuInfo *pMMCViewMenuInfo = NULL;

    switch (m_pCurrentSelection->m_st)
    {
    case SEL_NODES_AUTO_CREATE_ROOT:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 2);
        break;

    case SEL_NODES_AUTO_CREATE_RTVW:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 1);
        break;

    case SEL_NODES_ANY_VIEWS:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 1);
        break;

    case SEL_NODES_ANY_NAME:
        hExistingViewsMenu = ::GetSubMenu(hmenuPopup, 3);
        break;
    }

    if (hExistingViewsMenu == NULL)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    iCount = ::GetMenuItemCount(hExistingViewsMenu);
    if (iCount == -1)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    for (iItemNumber = 0; iItemNumber < iCount; ++iItemNumber)
    {
        ::memset(&menuItemInfo, 0, sizeof(MENUITEMINFO));
        menuItemInfo.cbSize = sizeof(MENUITEMINFO);
        menuItemInfo.fMask = MIIM_DATA;

        bReturn = ::GetMenuItemInfo(hExistingViewsMenu, iItemNumber, TRUE, &menuItemInfo);
        if (bReturn == FALSE)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        pMMCViewMenuInfo = reinterpret_cast<MMCViewMenuInfo *>(menuItemInfo.dwItemData);
        if (pMMCViewMenuInfo != NULL)
        {
            if (iItemNumber == iCmd - CMD_ADD_EXISTING_VIEW)
            {
                if (::PostMessage(m_hwnd, CMD_ADD_EXISTING_VIEW, 0, reinterpret_cast<LPARAM>(pMMCViewMenuInfo)) == 0)
                {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    EXCEPTION_CHECK_GO(hr);
                }
            }
            else
                delete pMMCViewMenuInfo;
        }
    }

Error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapd\mssnapd\urlvw.cpp ===
//=--------------------------------------------------------------------------------------
// urlvw.cpp
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=------------------------------------------------------------------------------------=
//
// CSnapInDesigner implementation -- URLView-related command handling
//=-------------------------------------------------------------------------------------=


#include "pch.h"
#include "common.h"
#include "TreeView.h"
#include "desmain.h"
#include "guids.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Size for our character string buffers
const int   kMaxBuffer                  = 512;


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddURLView()
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddURLView()
{
    HRESULT                hr = S_OK;
    IViewDefs             *piViewDefs = NULL;
    IURLViewDefs          *piURLViewDefs = NULL;
    VARIANT                vtEmpty;
    IURLViewDef           *piIURLViewDef = NULL;

    ::VariantInit(&vtEmpty);

    hr = GetOwningViewCollection(&piViewDefs);
    IfFailGo(hr);

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        if (piURLViewDefs != NULL)
        {
            ::VariantInit(&vtEmpty);
            vtEmpty.vt = VT_ERROR;
            vtEmpty.scode = DISP_E_PARAMNOTFOUND;

            hr = piURLViewDefs->Add(vtEmpty, vtEmpty, &piIURLViewDef);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piIURLViewDef);
    RELEASE(piURLViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::AddExistingURLView(IViewDefs *piViewDefs, IURLViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::AddExistingURLView(IViewDefs *piViewDefs, IURLViewDef *piURLViewDef)
{
    HRESULT           hr = S_OK;
    IURLViewDefs     *piURLViewDefs = NULL;

    hr = piViewDefs->get_URLViews(&piURLViewDefs);
    IfFailGo(hr);

    hr = piURLViewDefs->AddFromMaster(piURLViewDef);
    IfFailGo(hr);

Error:
    RELEASE(piURLViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnAddURLViewDef(CSelectionHolder *pParent, IURLViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
//  Invoked in response to an IObjectModelHost:Add() notification.
//
HRESULT CSnapInDesigner::OnAddURLViewDef(CSelectionHolder *pParent, IURLViewDef *piURLViewDef)
{
    HRESULT              hr = S_OK;
    CSelectionHolder    *pURLView = NULL;
    IViewDefs           *piViewDefs = NULL;
    IURLViewDefs        *piURLViewDefs = NULL;

    ASSERT(NULL != pParent, "OnAddURLViewDef: pParent is NULL");
    ASSERT(NULL != piURLViewDef, "OnAddURLViewDef: piURLViewDef is NULL");

    switch (pParent->m_st)
    {
    case SEL_NODES_AUTO_CREATE_RTVW:
        hr = pParent->m_piObject.m_piSnapInDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);
        break;

    case SEL_VIEWS_URL:
        piURLViewDefs = pParent->m_piObject.m_piURLViewDefs;
        piURLViewDefs->AddRef();
        break;

    case SEL_NODES_ANY_VIEWS:
        hr = pParent->m_piObject.m_piScopeItemDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);

        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);
        break;

    default:
        ASSERT(0, "OnAddURLViewDef: Cannot determine owning collection");
        goto Error;
    }

    hr = MakeNewURLView(piURLViewDefs, piURLViewDef, &pURLView);
    IfFailGo(hr);

    hr = InsertURLViewInTree(pURLView, pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pURLView);
    IfFailGo(hr);

    hr = m_pTreeView->SelectItem(pURLView);
    IfFailGo(hr);

    hr = m_pTreeView->Edit(pURLView);
    IfFailGo(hr);

    m_fDirty = TRUE;

Error:
    RELEASE(piViewDefs);
    RELEASE(piURLViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::RenameURLView(CSelectionHolder *pURLView, BSTR bstrNewName)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::RenameURLView(CSelectionHolder *pURLView, BSTR bstrNewName)
{
    HRESULT              hr = S_OK;
    TCHAR               *pszName = NULL;

    ASSERT(SEL_VIEWS_URL_NAME == pURLView->m_st, "RenameURLView: wrong argument");

    hr = m_piDesignerProgrammability->IsValidIdentifier(bstrNewName);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = SID_E_INVALIDARG;
        goto Error;
    }

    hr = pURLView->m_piObject.m_piURLViewDef->put_Key(bstrNewName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrNewName, &pszName);
    IfFailGo(hr);

    // Rename all satellite views
    hr = m_pTreeView->RenameAllSatelliteViews(pURLView, pszName);
    IfFailGo(hr);

    // Rename the actual view
    hr = m_pTreeView->ChangeText(pURLView, pszName);
    IfFailGo(hr);

Error:
    if (NULL != pszName)
        CtlFree(pszName);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::DeleteURLView(CSelectionHolder *pURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::DeleteURLView
(
    CSelectionHolder *pURLView
)
{
    HRESULT           hr = S_OK;
    bool              bIsSatelliteView = false;
    IObjectModel     *piObjectModel = NULL;
    long              lUsageCount = 0;
    BSTR              bstrName = NULL;
    IViewDefs        *piViewDefs = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    VARIANT          vtKey;

    ::VariantInit(&vtKey);

    // We allow any satellite view to be deleted
    hr = IsSatelliteView(pURLView);
    IfFailGo(hr);

    // But if it's a master with a UsageCount > 0 we don't allow deleting it.
    if (S_FALSE == hr)
    {
        hr = pURLView->m_piObject.m_piURLViewDef->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
        IfFailGo(hr);

        hr = piObjectModel->GetUsageCount(&lUsageCount);
        IfFailGo(hr);

        if (lUsageCount > 1)
        {
            (void)::SDU_DisplayMessage(IDS_VIEW_IN_USE, MB_OK | MB_ICONHAND, HID_mssnapd_ViewInUse, 0, DontAppendErrorInfo, NULL);
            goto Error;
        }
    }
    else
        bIsSatelliteView = true;

    hr = pURLView->m_piObject.m_piURLViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pURLView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    if (piViewDefs != NULL)
    {
        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        if (piURLViewDefs != NULL)
        {
            vtKey.vt = VT_BSTR;
            vtKey.bstrVal = ::SysAllocString(bstrName);
            if (NULL == vtKey.bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK(hr);
            }

            hr = piURLViewDefs->Remove(vtKey);
            IfFailGo(hr);
        }
    }

Error:
    RELEASE(piURLViewDefs);
    RELEASE(piViewDefs);
    RELEASE(piObjectModel);
    ::VariantClear(&vtKey);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::OnDeleteURLView(CSelectionHolder *pURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::OnDeleteURLView
(
    CSelectionHolder *pURLView
)
{
    HRESULT            hr = S_OK;
    CSelectionHolder  *pParent = NULL;
    bool               bIsSatelliteView = false;
    IViewDefs         *piViewDefs = NULL;
    IURLViewDefs      *piURLViewDefs = NULL;
    long               lCount = 0;

    hr = IsSatelliteView(pURLView);
    IfFailGo(hr);

    bIsSatelliteView = (S_OK == hr) ? true : false;

    if (true == bIsSatelliteView)
    {
        hr = GetOwningViewCollection(pURLView, &piViewDefs);
        IfFailGo(hr);
    }
    else
    {
        hr = m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs);
        IfFailGo(hr);
    }

    // Find out who the next selection should be
    hr = m_pTreeView->GetParent(pURLView, &pParent);
    IfFailGo(hr);

    // Delete the node from the tree
    hr = m_pTreeView->DeleteNode(pURLView);
    IfFailGo(hr);

    delete pURLView;

    // Select the next selection
    if (NULL != piViewDefs)
    {
        hr = piViewDefs->get_URLViews(&piURLViewDefs);
        IfFailGo(hr);

        hr = piURLViewDefs->get_Count(&lCount);
        IfFailGo(hr);

        if (0 == lCount)
        {
            hr = m_pTreeView->ChangeNodeIcon(pParent, kClosedFolderIcon);
            IfFailGo(hr);
        }
    }

    hr = m_pTreeView->SelectItem(pParent);
    IfFailGo(hr);

    hr = OnSelectionChanged(pParent);
    IfFailGo(hr);

Error:
    RELEASE(piURLViewDefs);
    RELEASE(piViewDefs);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::ShowURLViewProperties(IURLViewDef *piURLViewDef)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::ShowURLViewProperties
(
    IURLViewDef *piURLViewDef
)
{
    HRESULT         hr = S_OK;
    OCPFIPARAMS     ocpfiParams;
    TCHAR           szBuffer[kMaxBuffer + 1];
    BSTR            bstrCaption = NULL;
    IUnknown       *pUnk[1];
    CLSID           pageClsID[1];

    hr = GetResourceString(IDS_URL_PROPS, szBuffer, kMaxBuffer);
    IfFailGo(hr);

    hr = BSTRFromANSI(szBuffer, &bstrCaption);
    IfFailGo(hr);

    hr = piURLViewDef->QueryInterface(IID_IUnknown, reinterpret_cast<void **>(&pUnk[0]));
    IfFailGo(hr);

    pageClsID[0] = CLSID_URLViewDefGeneralPP;

    ::memset(&ocpfiParams, 0, sizeof(OCPFIPARAMS));
    ocpfiParams.cbStructSize = sizeof(OCPFIPARAMS);
    ocpfiParams.hWndOwner = m_hwnd;
    ocpfiParams.x = 0;
    ocpfiParams.y = 0;
    ocpfiParams.lpszCaption = bstrCaption;
    ocpfiParams.cObjects = 1;
    ocpfiParams.lplpUnk = pUnk;
    ocpfiParams.cPages = 1;
    ocpfiParams.lpPages = pageClsID;
    ocpfiParams.lcid = g_lcidLocale;
    ocpfiParams.dispidInitialProperty = 0;

    hr = ::OleCreatePropertyFrameIndirect(&ocpfiParams);
    IfFailGo(hr);

Error:
    RELEASE(pUnk[0]);
    FREESTRING(bstrCaption);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::MakeNewURLView(IURLViewDefs *piURLViewDefs, IURLViewDef *piURLViewDef, CSelectionHolder **ppURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::MakeNewURLView
(
    IURLViewDefs      *piURLViewDefs,
    IURLViewDef       *piURLViewDef,
    CSelectionHolder **ppURLView
)
{
    HRESULT                hr = S_OK;

    *ppURLView = New CSelectionHolder(piURLViewDef);
    if (*ppURLView == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = InitializeNewURLView(piURLViewDefs, *ppURLView);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InitializeNewURLView(IURLViewDefs *piURLViewDefs, CSelectionHolder *pURLView)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InitializeNewURLView
(
    IURLViewDefs     *piURLViewDefs,
    CSelectionHolder *pURLView
)
{
    HRESULT           hr = S_OK;
    IObjectModel     *piObjectModel = NULL;
    CSelectionHolder *pViewCollection = NULL;
    int               iResult = 0;
    int               iItemNumber = 1;
    TCHAR             szBuffer[kMaxBuffer + 1];
    TCHAR             szName[kMaxBuffer + 1];
    BSTR              bstrName = NULL;
    bool              bGood = false;
    CSelectionHolder *pURLViewDefClone = NULL;

    hr = piURLViewDefs->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel));
    IfFailGo(hr);

    hr = piObjectModel->GetCookie(reinterpret_cast<long *>(&pViewCollection));
    IfFailGo(hr);

    ASSERT(NULL != pViewCollection, "InitializeNewURLView: Bad Cookie");

    hr = IsSatelliteCollection(pViewCollection);
    IfFailGo(hr);

    if (S_FALSE == hr)
    {
        hr = GetResourceString(IDS_URL_VIEW, szBuffer, kMaxBuffer);
        IfFailGo(hr);

        do {
            iResult = _stprintf(szName, _T("%s%d"), szBuffer, iItemNumber++);
            if (iResult == 0)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                EXCEPTION_CHECK(hr);
            }

			hr = m_pTreeView->FindLabelInTree(szName, &pURLViewDefClone);
			IfFailGo(hr);

            if (S_FALSE == hr)
            {
				hr = BSTRFromANSI(szName, &bstrName);
				IfFailGo(hr);

                bGood = true;
                break;
            }

            FREESTRING(bstrName);
        } while (false == bGood);

        hr = pURLView->m_piObject.m_piURLViewDef->put_Name(bstrName);
        IfFailGo(hr);

        hr = pURLView->m_piObject.m_piURLViewDef->put_Key(bstrName);
        IfFailGo(hr);
    }

    hr = pURLView->RegisterHolder();
    IfFailGo(hr);

Error:
    FREESTRING(bstrName);
    RELEASE(piObjectModel);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------------------
// CSnapInDesigner::InsertURLViewInTree(CSelectionHolder *pURLView, CSelectionHolder *pParent)
//=--------------------------------------------------------------------------------------
//  
//  Notes
//
HRESULT CSnapInDesigner::InsertURLViewInTree
(
    CSelectionHolder *pURLView,
    CSelectionHolder *pParent
)
{
    HRESULT hr = S_OK;
    BSTR    bstrName = NULL;
    TCHAR  *pszName = NULL;

    hr = pURLView->m_piObject.m_piURLViewDef->get_Name(&bstrName);
    IfFailGo(hr);

    hr = ANSIFromBSTR(bstrName, &pszName);
    IfFailGo(hr);

    hr = m_pTreeView->AddNode(pszName, pParent, kURLViewIcon, pURLView);
    IfFailGo(hr);

Error:
    if (pszName != NULL)
        CtlFree(pszName);
    FREESTRING(bstrName);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\button.h ===
//=--------------------------------------------------------------------------=
// button.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButton class definition. Implements the MMCButton object.
//
//=--------------------------------------------------------------------------=

#ifndef _BUTTON_DEFINED_
#define _BUTTON_DEFINED_

#include "toolbar.h"

class CMMCToolbar;

class CMMCButton : public CSnapInAutomationObject,
                   public CPersistence,
                   public IMMCButton
{
    private:
        CMMCButton(IUnknown *punkOuter);
        ~CMMCButton();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButton
        COCLASS_PROPERTY_RO(CMMCButton,     ButtonMenus, MMCButtonMenus, IMMCButtonMenus, DISPID_BUTTON_BUTTON_MENUS);

        BSTR_PROPERTY_RO(CMMCButton,       Caption, DISPID_BUTTON_CAPTION);
        STDMETHOD(put_Caption)(BSTR bstrCaption);

        STDMETHOD(put_Enabled)(VARIANT_BOOL fvarEnabled);
        STDMETHOD(get_Enabled)(VARIANT_BOOL *pfvarEnabled);

        VARIANT_PROPERTY_RW(CMMCButton,    Image, DISPID_BUTTON_IMAGE);
        SIMPLE_PROPERTY_RW(CMMCButton,     Index, long, DISPID_BUTTON_INDEX);
        BSTR_PROPERTY_RW(CMMCButton,       Key, DISPID_BUTTON_KEY);

        STDMETHOD(put_MixedState)(VARIANT_BOOL fvarMixedState);
        STDMETHOD(get_MixedState)(VARIANT_BOOL *pfvarMixedState);

        SIMPLE_PROPERTY_RW(CMMCButton,     Style, SnapInButtonStyleConstants, DISPID_BUTTON_STYLE);
        VARIANTREF_PROPERTY_RW(CMMCButton, Tag, DISPID_BUTTON_TAG);

        BSTR_PROPERTY_RO(CMMCButton,       ToolTipText, DISPID_BUTTON_TOOLTIP_TEXT);
        STDMETHOD(put_ToolTipText)(BSTR bstrToolTipText);

        STDMETHOD(put_Value)(SnapInButtonValueConstants Value);
        STDMETHOD(get_Value)(SnapInButtonValueConstants *pValue);

        STDMETHOD(put_Visible)(VARIANT_BOOL fvarVisible);
        STDMETHOD(get_Visible)(VARIANT_BOOL *pfvarVisible);

    // Public utility methods

    public:
        void SetToolbar(CMMCToolbar *pMMCToolbar) { m_pMMCToolbar = pMMCToolbar; }
        CMMCToolbar *GetToolbar() { return m_pMMCToolbar; }
        long GetIndex() { return m_Index; }
        VARIANT GetImage() { return m_varImage; }
        SnapInButtonStyleConstants GetStyle() { return m_Style; }
        SnapInButtonValueConstants GetValue() { return m_Value; }
        VARIANT_BOOL GetEnabled() { return m_fvarEnabled; }
        VARIANT_BOOL GetVisible() { return m_fvarVisible; }
        VARIANT_BOOL GetMixedState() { return m_fvarMixedState; }
        LPOLESTR GetCaption() { return static_cast<LPOLESTR>(m_bstrCaption); }
        LPOLESTR GetToolTipText() { return static_cast<LPOLESTR>(m_bstrToolTipText); }
        
    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT SetButtonState(MMC_BUTTON_STATE State, VARIANT_BOOL fvarValue);
        HRESULT GetButtonState(MMC_BUTTON_STATE State, VARIANT_BOOL *pfvarValue);

        VARIANT_BOOL                m_fvarEnabled;
        VARIANT_BOOL                m_fvarVisible;
        VARIANT_BOOL                m_fvarMixedState;
        SnapInButtonValueConstants  m_Value;
        CMMCToolbar                *m_pMMCToolbar;

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButton,                   // name
                                &CLSID_MMCButton,            // clsid
                                "MMCButton",                 // objname
                                "MMCButton",                 // lblname
                                &CMMCButton::Create,         // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCButton,             // dispatch IID
                                NULL,                        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _Button_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\array.h ===
//=--------------------------------------------------------------------------=
// array.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//
//=--------------------------------------------------------------------------=

#ifndef _CARRAY_DEFINED_
#define _CARRAY_DEFINED_


//=--------------------------------------------------------------------------=
//
// class CArray
//
// This is taken directly from MFC's CArray source.
//
//
//=--------------------------------------------------------------------------=

template <class Object>
class CArray
{

       public:

// Construction
           CArray();

// Attributes
           long GetSize() const;
           long GetUpperBound() const;
           HRESULT SetSize(long nNewSize, long nGrowBy = -1L);

// Operations
    // Clean up
           HRESULT FreeExtra();
           void RemoveAll();

    // Accessing elements
           Object GetAt(long nIndex) const;
           void SetAt(long nIndex, Object NewElement);

    // Direct Access to the element data (may return NULL)
           const Object *GetData() const;
           Object *GetData();

    // Potentially growing the array
           HRESULT SetAtGrow(long nIndex, Object NewElement);

           HRESULT Add(Object NewElement, long *plIndex);

    // Operations that move elements around
           HRESULT InsertAt(long nIndex, Object NewElement, long nCount = 1L);

           void RemoveAt(long nIndex, long nCount = 1L);
           HRESULT InsertAt(long nStartIndex, CArray* pNewArray);

// Implementation
       protected:
           Object   *m_pData;     // the actual array of data
           long      m_nSize;     // # of elements (upperBound - 1)
           long      m_nMaxSize;  // max allocated
           long      m_nGrowBy;   // grow amount


       public:
           ~CArray();
};

template <class Object>
CArray<Object>::CArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template <class Object>
CArray<Object>::~CArray()
{
    if (NULL != m_pData)
    {
        ::CtlFree(m_pData);
        m_pData = NULL;
    }
}

template <class Object>
HRESULT CArray<Object>::SetSize(long nNewSize, long nGrowBy)
{
    HRESULT hr = S_OK;

    if (nGrowBy != -1L)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (Object *)::CtlAlloc(nNewSize * sizeof(Object));
        if (NULL == m_pData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        memset(m_pData, 0, nNewSize * sizeof(Object));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(Object));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        long nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024L, max(4L, m_nSize / 8L));
        }
        long nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        Object *pNewData = (Object *)::CtlAlloc(nNewMax * sizeof(Object));
        if (NULL == pNewData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(Object));

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(Object));

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    // Always free up unused space.

    hr = FreeExtra();
Error:
    H_RRETURN(hr);
}


template <class Object>
HRESULT CArray<Object>::FreeExtra()
{
    HRESULT hr = S_OK;
    if (m_nSize != m_nMaxSize)
    {
        Object* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (Object*)::CtlAlloc(m_nSize * sizeof(Object));
            if (NULL == pNewData)
            {
                hr = SID_E_OUTOFMEMORY;
                GLOBAL_EXCEPTION_CHECK_GO(hr)
            }

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(Object));
        }

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
Error:
    H_RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////

template <class Object>
HRESULT CArray<Object>::SetAtGrow(long lIndex, Object NewElement)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        H_IfFailRet(SetSize(lIndex+1L));
    }
    m_pData[lIndex] = NewElement;
    return S_OK;
}


template <class Object>
HRESULT CArray<Object>::InsertAt(long lIndex, Object NewElement, long nCount)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        // adding after the end of the array
        H_IfFailRet(SetSize(lIndex + nCount));  // grow so lIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        long nOldSize = m_nSize;
        H_IfFailRet(SetSize(m_nSize + nCount));  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[lIndex+nCount], &m_pData[lIndex],
                (nOldSize-lIndex) * sizeof(Object));

        // re-init slots we copied from

        memset(&m_pData[lIndex], 0, nCount * sizeof(Object));

    }

    // copy elements into the empty space
    while (nCount--)
    {
        m_pData[lIndex++] = NewElement;
    }

    return S_OK;
}



template <class Object>
void CArray<Object>::RemoveAt(long lIndex, long nCount)
{
    // just remove a range
    long nMoveCount = m_nSize - (lIndex + nCount);

    if (nMoveCount)
        memmove(&m_pData[lIndex], &m_pData[lIndex + nCount],
                nMoveCount * sizeof(Object));
    m_nSize -= nCount;
}

template <class Object>
HRESULT CArray<Object>::InsertAt(long nStartIndex, CArray* pNewArray)
{
    HRESULT hr = S_OK;
    if (pNewArray->GetSize() > 0)
    {
        H_IfFailRet(InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()));
        for (long i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
    return S_OK;
}

template <class Object>
long CArray<Object>::GetSize() const
{
    return m_nSize;
}

template <class Object>
long CArray<Object>::GetUpperBound() const
{
    return m_nSize-1L;
}

template <class Object>
void CArray<Object>::RemoveAll()
{
    (void)SetSize(0);
}

template <class Object>
Object CArray<Object>::GetAt(long lIndex) const
{
    return m_pData[lIndex];
}

template <class Object>
void CArray<Object>::SetAt(long lIndex, Object NewElement)
{ 
    m_pData[lIndex] = NewElement;
}

template <class Object>
const Object *CArray<Object>::GetData() const
{
    return (const Object *)m_pData;
}

template <class Object>
Object *CArray<Object>::GetData()
{
    return m_pData;
}

template <class Object>
HRESULT CArray<Object>::Add(Object NewElement, long *plIndex)
{
    HRESULT hr = S_OK;
    long lIndex = m_nSize;
    H_IfFailRet(SetAtGrow(lIndex, NewElement));
    *plIndex = lIndex;
    return S_OK;
}

//=--------------------------------------------------------------------------=
//
//                              class CIPArray 
// Obsolete. Code not used.
//
//=--------------------------------------------------------------------------=


template <class IObject>
class CIPArray
{

    public:

// Construction
        CIPArray();

// Attributes
        long GetSize() const;
        long GetUpperBound() const;
        HRESULT SetSize(long nNewSize, long nGrowBy = -1L);

// Operations
    // Clean up
        HRESULT FreeExtra();
        void RemoveAll();

    // Accessing elements
        IObject* GetAt(long nIndex) const;
        void SetAt(long nIndex, IObject* piNewElement);

    // Direct Access to the element data (may return NULL)
        const IObject** GetData() const;
        IObject** GetData();

    // Potentially growing the array
        HRESULT SetAtGrow(long nIndex, IObject* piNewElement);

        HRESULT Add(IObject* piNewElement, long *plIndex);

    // Operations that move elements around
        HRESULT InsertAt(long nIndex, IObject* piNewElement, long nCount = 1L);

        void RemoveAt(long nIndex, long nCount = 1L);
        HRESULT InsertAt(long nStartIndex, CIPArray* pNewArray);

// Implementation
    protected:
        IObject  **m_pData;     // the actual array of data
        long       m_nSize;     // # of elements (upperBound - 1)
        long       m_nMaxSize;  // max allocated
        long       m_nGrowBy;   // grow amount


    public:
        ~CIPArray();
};

template <class IObject>
CIPArray<IObject>::CIPArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template <class IObject>
CIPArray<IObject>::~CIPArray()
{
    if (NULL != m_pData)
    {
        ::CtlFree(m_pData);
        m_pData = NULL;
    }
}

template <class IObject>
HRESULT CIPArray<IObject>::SetSize(long nNewSize, long nGrowBy)
{
    HRESULT hr = S_OK;

    if (nGrowBy != -1L)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (IObject **)::CtlAlloc(nNewSize * sizeof(IObject *));
        if (NULL == m_pData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        memset(m_pData, 0, nNewSize * sizeof(IObject *));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(IObject *));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        long nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024L, max(4L, m_nSize / 8L));
        }
        long nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        IObject **pNewData = (IObject **)::CtlAlloc(nNewMax * sizeof(IObject *));
        if (NULL == pNewData)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr)
        }

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(IObject *));

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(IObject *));

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    // Always free up unused space.
    
    hr = FreeExtra();
Error:
    H_RRETURN(hr);
}


template <class IObject>
HRESULT CIPArray<IObject>::FreeExtra()
{
    HRESULT hr = S_OK;
    if (m_nSize != m_nMaxSize)
    {
        IObject **pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (IObject **)::CtlAlloc(m_nSize * sizeof(IObject *));
            if (NULL == pNewData)
            {
                hr = SID_E_OUTOFMEMORY;
                GLOBAL_EXCEPTION_CHECK_GO(hr)
            }

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(IObject *));
        }

        // get rid of old stuff (note: no destructors called)
        if (NULL != m_pData)
        {
            ::CtlFree(m_pData);
        }
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
Error:
    H_RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////

template <class IObject>
HRESULT CIPArray<IObject>::SetAtGrow(long lIndex, IObject *piNewElement)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        H_IfFailRet(SetSize(lIndex+1L));
    }
    m_pData[lIndex] = piNewElement;
    return S_OK;
}


template <class IObject>
HRESULT CIPArray<IObject>::InsertAt(long lIndex, IObject *piNewElement, long nCount)
{
    HRESULT hr = S_OK;
    if (lIndex >= m_nSize)
    {
        // adding after the end of the array
        H_IfFailRet(SetSize(lIndex + nCount));  // grow so lIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        long nOldSize = m_nSize;
        H_IfFailRet(SetSize(m_nSize + nCount));  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[lIndex+nCount], &m_pData[lIndex],
                (nOldSize-lIndex) * sizeof(IObject *));

        // re-init slots we copied from

        memset(&m_pData[lIndex], 0, nCount * sizeof(IObject *));

    }

    // copy elements into the empty space
    while (nCount--)
    {
        m_pData[lIndex++] = piNewElement;
    }

    return S_OK;
}



template <class IObject>
void CIPArray<IObject>::RemoveAt(long lIndex, long nCount)
{
    // just remove a range
    long nMoveCount = m_nSize - (lIndex + nCount);

    if (nMoveCount)
        memmove(&m_pData[lIndex], &m_pData[lIndex + nCount],
                nMoveCount * sizeof(IObject *));
    m_nSize -= nCount;
}

template <class IObject>
HRESULT CIPArray<IObject>::InsertAt(long nStartIndex, CIPArray* pNewArray)
{
    HRESULT hr = S_OK;
    if (pNewArray->GetSize() > 0)
    {
        H_IfFailRet(InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()));
        for (long i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
    return S_OK;
}

template <class IObject>
long CIPArray<IObject>::GetSize() const
{
    return m_nSize;
}

template <class IObject>
long CIPArray<IObject>::GetUpperBound() const
{
    return m_nSize-1L;
}

template <class IObject>
void CIPArray<IObject>::RemoveAll()
{
    (void)SetSize(0);
}

template <class IObject>
IObject * CIPArray<IObject>::GetAt(long lIndex) const
{
    return m_pData[lIndex];
}

template <class IObject>
void CIPArray<IObject>::SetAt(long lIndex, IObject *piNewElement)
{ 
    m_pData[lIndex] = piNewElement;
}

template <class IObject>
const IObject ** CIPArray<IObject>::GetData() const
{
    return (const IObject **)m_pData;
}

template <class IObject>
IObject ** CIPArray<IObject>::GetData()
{
    return m_pData;
}

template <class IObject>
HRESULT CIPArray<IObject>::Add(IObject *piNewElement, long *plIndex)
{
    HRESULT hr = S_OK;
    long lIndex = m_nSize;
    H_IfFailRet(SetAtGrow(lIndex, piNewElement));
    *plIndex = lIndex;
    return S_OK;
}


#endif // _CARRAY_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\button.cpp ===
//=--------------------------------------------------------------------------=
// button.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButton class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "button.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButton::CMMCButton(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCBUTTON,
                            static_cast<IMMCButton *>(this),
                            static_cast<CMMCButton *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButton,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButton::~CMMCButton()
{
    RELEASE(m_piButtonMenus);
    FREESTRING(m_bstrCaption);
    (void)::VariantClear(&m_varImage);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrToolTipText);

    InitMemberVariables();
}

void CMMCButton::InitMemberVariables()
{
    m_piButtonMenus = NULL;
    m_bstrCaption = NULL;
    m_fvarEnabled = VARIANT_TRUE;

    ::VariantInit(&m_varImage);
    
    m_Index = 0;
    m_bstrKey = NULL;
    m_fvarMixedState = VARIANT_FALSE;
    m_Style = siDefault;

    ::VariantInit(&m_varTag);

    m_bstrToolTipText = NULL;
    m_Value = siUnpressed;
    m_fvarVisible = VARIANT_TRUE;
    m_pMMCToolbar = NULL;
}

IUnknown *CMMCButton::Create(IUnknown * punkOuter)
{
    CMMCButton *pMMCButton = New CMMCButton(punkOuter);
    if (NULL == pMMCButton)
    {
        return NULL;
    }
    else
    {
        return pMMCButton->PrivateUnknown();
    }
}

HRESULT CMMCButton::SetButtonState
(
    MMC_BUTTON_STATE State,
    VARIANT_BOOL     fvarValue
)
{
    HRESULT hr = S_OK;
    BOOL    fIsToolbar = FALSE;
    BOOL    fIsMenuButton = FALSE;

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        IfFailGo(m_pMMCToolbar->SetButtonState(this, State,
                                               VARIANTBOOL_TO_BOOL(fvarValue)));
    }
    else
    {
        IfFailGo(m_pMMCToolbar->IsMenuButton(&fIsMenuButton));
        if (fIsMenuButton)
        {
            IfFailGo(m_pMMCToolbar->SetMenuButtonState(this, State,
                                               VARIANTBOOL_TO_BOOL(fvarValue)));
        }
    }

Error:
    RRETURN(hr);
}



HRESULT CMMCButton::GetButtonState
(
    MMC_BUTTON_STATE  State,
    VARIANT_BOOL     *pfvarValue
)
{
    HRESULT hr = S_OK;
    BOOL    fValue = FALSE;
    BOOL    fIsToolbar = FALSE;

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        IfFailGo(m_pMMCToolbar->GetButtonState(this, State, &fValue));
        *pfvarValue = BOOL_TO_VARIANTBOOL(fValue);
    }

    // If we belong to a menu button then we must use our currently stored
    // state variable as MMC does not support getting menu button state.

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         IMMCButton Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CMMCButton::put_Caption(BSTR bstrCaption)
{
    HRESULT hr = S_OK;
    BOOL    fIsMenuButton = FALSE;

    // Set our member variable first

    IfFailGo(SetBstr(bstrCaption, &m_bstrCaption, DISPID_BUTTON_CAPTION));

    // If we belong to a live menu button then ask MMC to change its text
    
    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsMenuButton(&fIsMenuButton));
    IfFalseGo(fIsMenuButton, S_OK);

    IfFailGo(m_pMMCToolbar->SetMenuButtonText(this,
                                              m_bstrCaption,
                                              m_bstrToolTipText));
Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::put_ToolTipText(BSTR bstrToolTipText)
{
    HRESULT hr = S_OK;
    BOOL    fIsMenuButton = FALSE;

    // Set our member variable first

    IfFailGo(SetBstr(bstrToolTipText, &m_bstrToolTipText, DISPID_BUTTON_TOOLTIP_TEXT));

    // If we belong to a live menu button then ask MMC to change its tooltip

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsMenuButton(&fIsMenuButton));
    IfFalseGo(fIsMenuButton, S_OK);

    IfFailGo(m_pMMCToolbar->SetMenuButtonText(this,
                                              m_bstrCaption,
                                              m_bstrToolTipText));
Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCButton::put_Enabled(VARIANT_BOOL fvarEnabled)
{
    HRESULT hr = S_OK;

    // Set our current value

    IfFailGo(SetSimpleType(fvarEnabled, &m_fvarEnabled, DISPID_BUTTON_ENABLED));

    // If we belong to a live toolbar then set its button state
    
    IfFailGo(SetButtonState(ENABLED, m_fvarEnabled));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_Enabled(VARIANT_BOOL *pfvarEnabled)
{
    HRESULT hr = S_OK;

    // Get our current value
    
    *pfvarEnabled = m_fvarEnabled;

    // If we are attached to a live toolbar then get its value
    
    IfFailGo(GetButtonState(ENABLED, pfvarEnabled));

    // In case we got a live value, store it in our current value
    
    m_fvarEnabled = *pfvarEnabled;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::put_MixedState(VARIANT_BOOL fvarMixedState)
{
    HRESULT hr = S_OK;

    // Set our current value

    IfFailGo(SetSimpleType(fvarMixedState, &m_fvarMixedState, DISPID_BUTTON_MIXEDSTATE));

    // If we belong to a live toolbar then set its button state

    IfFailGo(SetButtonState(INDETERMINATE, m_fvarMixedState));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_MixedState(VARIANT_BOOL *pfvarMixedState)
{
    HRESULT hr = S_OK;

    // Get our current value

    *pfvarMixedState = m_fvarMixedState;

    // If we are attached to a live toolbar then get its value

    IfFailGo(GetButtonState(INDETERMINATE, pfvarMixedState));

    // In case we got a live value, store it in our current value

    m_fvarMixedState = *pfvarMixedState;


Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::put_Value(SnapInButtonValueConstants Value)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fvarPressed = (siPressed == Value) ? VARIANT_TRUE : VARIANT_FALSE;

    // Set our current value

    IfFailGo(SetSimpleType(Value, &m_Value, DISPID_BUTTON_VALUE));

    // If we belong to a live toolbar then set its button state

    IfFailGo(SetButtonState(BUTTONPRESSED, fvarPressed));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_Value(SnapInButtonValueConstants *pValue)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fvarPressed = (siPressed == m_Value) ? VARIANT_TRUE : VARIANT_FALSE;

    // If we are attached to a live toolbar then get its value

    IfFailGo(GetButtonState(BUTTONPRESSED, &fvarPressed));

    // In case we got a live value, store it in our current value

    m_Value = (VARIANT_TRUE == fvarPressed) ? siPressed : siUnpressed;

    // Get our current value

    *pValue = m_Value;

Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCButton::put_Visible(VARIANT_BOOL fvarVisible)
{
    HRESULT hr = S_OK;

    // Set our current value

    IfFailGo(SetSimpleType(fvarVisible, &m_fvarVisible, DISPID_BUTTON_VISIBLE));

    // If we belong to a live toolbar then set its button state

    IfFailGo(SetButtonState(HIDDEN, NEGATE_VARIANTBOOL(m_fvarVisible)));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCButton::get_Visible(VARIANT_BOOL *pfvarVisible)
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fvarPressed = NEGATE_VARIANTBOOL(m_fvarVisible);

    // If we are attached to a live toolbar then get its value

    IfFailGo(GetButtonState(HIDDEN, &fvarPressed));

    // In case we got a live value, store it in our current value

    m_fvarVisible = NEGATE_VARIANTBOOL(fvarPressed);

    // Get our current value

    *pfvarVisible = m_fvarVisible;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButton::Persist()
{
    HRESULT hr = S_OK;
    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistObject(&m_piButtonMenus, CLSID_MMCButtonMenus,
                            OBJECT_TYPE_MMCBUTTONMENUS, IID_IMMCButtonMenus,
                            OLESTR("ButtonMenus")));

    if (InitNewing() || Loading())
    {
        IfFailRet(m_piButtonMenus->putref_Parent(static_cast<IMMCButton *>(this)));
    }

    IfFailRet(PersistBstr(&m_bstrCaption, L"", OLESTR("Caption")));

    IfFailRet(PersistSimpleType(&m_fvarEnabled, VARIANT_TRUE, OLESTR("Enabled")));

    IfFailRet(PersistVariant(&m_varImage, varDefault, OLESTR("Image")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistSimpleType(&m_fvarMixedState, VARIANT_FALSE, OLESTR("MixedState")));

    IfFailRet(PersistSimpleType(&m_Style, siDefault, OLESTR("Style")));

    IfFailRet(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailRet(PersistBstr(&m_bstrToolTipText, L"", OLESTR("ToolTipText")));

    IfFailRet(PersistSimpleType(&m_Value, siUnpressed, OLESTR("Value")));

    IfFailRet(PersistSimpleType(&m_fvarVisible, VARIANT_TRUE, OLESTR("Visible")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButton::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCButton == riid)
    {
        *ppvObjOut = static_cast<IMMCButton *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButton::OnSetHost()
{
    // When the host is being removed need to remove parent from menu buttons
    // to avoid circular ref counts.
    // This is the only opportunity we have to do that and it will occur
    // both at design time and at runtime.

    if (NULL == GetHost())
    {
        RRETURN(m_piButtonMenus->putref_Parent(NULL));
    }
    else
    {
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdr.cpp ===
//=--------------------------------------------------------------------------=
// colhdr.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colhdr.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCColumnHeader::CMMCColumnHeader(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCCOLUMNHEADER,
                            static_cast<IMMCColumnHeader *>(this),
                            static_cast<CMMCColumnHeader *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCColumnHeader,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCColumnHeader::~CMMCColumnHeader()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrText);
    (void)::VariantClear(&m_varTextFilter);
    (void)::VariantClear(&m_varNumericFilter);
    (void)::VariantClear(&m_varTag);
    InitMemberVariables();
}

void CMMCColumnHeader::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

    ::VariantInit(&m_varTextFilter);
    ::VariantInit(&m_varNumericFilter);
    ::VariantInit(&m_varTag);

    m_bstrText = NULL;

    m_sWidth = static_cast<short>(siColumnAutoWidth);
    m_Alignment = siColumnLeft;
    m_fvarHidden = VARIANT_FALSE;
    m_TextFilterMaxLen = MAX_PATH; // This is the header control's default
    m_pMMCColumnHeaders = NULL;
}


IUnknown *CMMCColumnHeader::Create(IUnknown * punkOuter)
{
    CMMCColumnHeader *pMMCColumnHeader = New CMMCColumnHeader(punkOuter);
    if (NULL == pMMCColumnHeader)
    {
        return NULL;
    }
    else
    {
        return pMMCColumnHeader->PrivateUnknown();
    }
}



HRESULT CMMCColumnHeader::SetFilter()
{
    HRESULT hr = S_OK;

    if (VT_EMPTY != m_varTextFilter.vt)
    {
        IfFailGo(SetTextFilter(m_varTextFilter));
    }
    else if (VT_EMPTY != m_varNumericFilter.vt)
    {
        IfFailGo(SetNumericFilter(m_varNumericFilter));
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCColumnHeader::SetTextFilter(VARIANT varTextFilter)
{
    HRESULT         hr = S_OK;
    IHeaderCtrl2   *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD           dwType = MMC_STRING_FILTER;
    CResultView    *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    // Determine the filter value.

    if (VT_EMPTY == varTextFilter.vt)
    {
        dwType |= MMC_FILTER_NOVALUE;
    }
    else
    {
        if (VT_BSTR != varTextFilter.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        FilterData.pszText = varTextFilter.bstrVal;
    }

    FilterData.cchTextMax = static_cast<int>(m_TextFilterMaxLen);

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.
    
    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( (!pResultView->InActivate()) && (!pResultView->InInitialize()) )
    {
        // Set the filter value. Adjust the column index for one-based.

        hr = piHeaderCtrl2->SetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                            dwType, &FilterData);
        if (E_NOTIMPL == hr)
        {
            hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


HRESULT CMMCColumnHeader::SetNumericFilter(VARIANT varNumericFilter)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD         dwType = MMC_INT_FILTER;
    CResultView  *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    // Determine the filter value.

    if (VT_EMPTY == varNumericFilter.vt)
    {
        dwType |= MMC_FILTER_NOVALUE;
    }
    else
    {
        hr = ::ConvertToLong(varNumericFilter, &FilterData.lValue);
        if (S_OK != hr)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( (!pResultView->InActivate()) && (!pResultView->InInitialize()) )
    {
        // Set the filter value. Adjust the column index for one-based.

        hr = piHeaderCtrl2->SetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                            dwType, &FilterData);
        if (E_NOTIMPL == hr)
        {
            hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


HRESULT CMMCColumnHeader::SetHeaderCtrlWidth(int nWidth)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;

    // If we are connected to MMC then change it in the header control too

    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    hr = m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    IfFalseGo(!pResultView->InActivate(), S_OK);
    IfFalseGo(!pResultView->InInitialize(), S_OK);

    hr = piHeaderCtrl2->SetColumnWidth(static_cast<int>(m_Index - 1L), nWidth);
    EXCEPTION_CHECK_GO(hr);

Error:

    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//
//                      IMMCColumnHeader Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCColumnHeader::put_Text(BSTR Text)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;

    // Set the property

    IfFailGo(SetBstr(Text, &m_bstrText, DISPID_COLUMNHEADER_TEXT));

    // If we are connected to MMC then change it in MMC too.
    
    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    hr = m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( (!pResultView->InActivate()) && (!pResultView->InInitialize()) )
    {
        hr = piHeaderCtrl2->SetColumnText(static_cast<int>(m_Index - 1L), Text);
        EXCEPTION_CHECK_GO(hr);
    }
    
Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::put_Width(short sWidth)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;
    int           nWidth = 0;

    // Set the property

    m_sWidth = sWidth;

    if (siColumnAutoWidth == sWidth)
    {
        nWidth = MMCLV_AUTO;
    }
    else
    {
        nWidth = static_cast<int>(sWidth);
    }

    // If we are connected to MMC then change it in the header control too

    IfFailGo(SetHeaderCtrlWidth(nWidth));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::get_Width(short *psWidth)
{
    HRESULT       hr = S_OK;
    int           nWidth = 0;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed
    CResultView  *pResultView = NULL;

    // Get our stored value of the property

    *psWidth = m_sWidth;

    // If we are connected to MMC then try to get it from MMC so the snap-in
    // can see any changes made by the user.

    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    hr = m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( pResultView->InActivate() || pResultView->InInitialize() )
    {
        goto Error;
    }

    hr = piHeaderCtrl2->GetColumnWidth(static_cast<int>(m_Index - 1L),
                                       &nWidth);
    EXCEPTION_CHECK_GO(hr);

    m_sWidth = static_cast<short>(nWidth);
    if (MMCLV_AUTO == m_sWidth)
    {
        m_sWidth = siColumnAutoWidth;
    }

    *psWidth = m_sWidth;

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::put_Hidden(VARIANT_BOOL fvarHidden)
{
    HRESULT      hr = S_OK;
    int          nWidth = 0;
    IColumnData *piColumnData = NULL; // Not AddRef()ed

    // Set the property

    m_fvarHidden = fvarHidden;

    // If we are connected to MMC then change it in the header control too.
    // This only works on MMC 1.2 so we need to check if a 1.2 interface is
    // available as a version check.

    IfFalseGo(NULL != m_pMMCColumnHeaders, S_OK);
    IfFailGo(m_pMMCColumnHeaders->GetIColumnData(&piColumnData));

    if (VARIANT_TRUE == fvarHidden)
    {
        nWidth = HIDE_COLUMN;
    }
    else
    {
        // We are revealing the column. Set its width using the current value
        // of our Width property.

        nWidth = static_cast<int>(m_sWidth);
    }
    IfFailGo(SetHeaderCtrlWidth(nWidth));

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::get_Hidden(VARIANT_BOOL *pfvarHidden)
{
    *pfvarHidden = m_fvarHidden;
    return S_OK;
}


STDMETHODIMP CMMCColumnHeader::put_TextFilter(VARIANT varTextFilter)
{
    HRESULT hr = S_OK;

    // Check for allowable variant types.

    if ( (VT_EMPTY != varTextFilter.vt) && (VT_BSTR != varTextFilter.vt) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set the property value.

    if (VT_EMPTY != varTextFilter.vt)
    {
        IfFailGo(SetVariant(varTextFilter, &m_varTextFilter, DISPID_COLUMNHEADER_TEXT_FILTER));
    }
    else
    {
        // At runtime the snap-in can set this to VT_EMPTY. SetVariant() does not
        // accept VT_EMPTY.

        hr = ::VariantClear(&m_varTextFilter);
        EXCEPTION_CHECK_GO(hr);
    }

    // Try to set it in MMC
    
    IfFailGo(SetTextFilter(m_varTextFilter));

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCColumnHeader::get_TextFilter(VARIANT *pvarTextFilter)
{
    HRESULT         hr = S_OK;
    IHeaderCtrl2   *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD           dwType = MMC_STRING_FILTER;
    CResultView    *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    ::VariantInit(pvarTextFilter);

    // Get the property value. If we are connected to MMC we'll overwrite it.

    IfFailGo(GetVariant(pvarTextFilter, m_varTextFilter));

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( pResultView->InActivate() || pResultView->InInitialize() )
    {
        goto Error;
    }

    // Allocate a buffer for the text filter value

    FilterData.pszText =
              (LPOLESTR)CtlAllocZero((m_TextFilterMaxLen + 1) * sizeof(OLECHAR));

    if (NULL == FilterData.pszText)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    FilterData.cchTextMax = static_cast<int>(m_TextFilterMaxLen + 1);

    // Clear out the property value stored above as at this point we will only
    // return what we get from MMC
    hr = ::VariantClear(pvarTextFilter);
    EXCEPTION_CHECK_GO(hr);

    // Get the filter value. Adjust the column index for one-based.

    hr = piHeaderCtrl2->GetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                        &dwType, &FilterData);
    if (E_NOTIMPL == hr)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
    }
    EXCEPTION_CHECK_GO(hr);

    if (MMC_STRING_FILTER == dwType)
    {
        // Store the string returned from MMC
        pvarTextFilter->bstrVal = ::SysAllocString(FilterData.pszText);
        if (NULL == pvarTextFilter->bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        pvarTextFilter->vt = VT_BSTR;
    }
    else
    {
        // Text filter is empty. Returned VARIANT is already empty from the
        // VariantClear() call so nothing to do.
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        (void)::VariantClear(pvarTextFilter);
    }

    if (NULL != FilterData.pszText)
    {
        CtlFree(FilterData.pszText);
    }
    RRETURN(hr);
}



STDMETHODIMP CMMCColumnHeader::put_NumericFilter(VARIANT varNumericFilter)
{
    HRESULT hr = S_OK;
    long    lValue = 0;

    // Check for allowable variant types

    if (VT_EMPTY != varNumericFilter.vt)
    {
        hr = ::ConvertToLong(varNumericFilter, &lValue);
        if (S_OK != hr)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Set the property value.

    if (VT_EMPTY != varNumericFilter.vt)
    {
        IfFailGo(SetVariant(varNumericFilter, &m_varNumericFilter, DISPID_COLUMNHEADER_NUMERIC_FILTER));
    }
    else
    {
        // At runtime the snap-in can set this to VT_EMPTY. SetVariant() does not
        // accept VT_EMPTY.

        hr = ::VariantClear(&m_varNumericFilter);
        EXCEPTION_CHECK_GO(hr);
    }

    // Set the filter value in MMC

    IfFailGo(SetNumericFilter(varNumericFilter));

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

STDMETHODIMP CMMCColumnHeader::get_NumericFilter(VARIANT *pvarNumericFilter)
{
    HRESULT         hr = S_OK;
    IHeaderCtrl2   *piHeaderCtrl2 = NULL; // Not AddRef()ed
    DWORD           dwType = MMC_INT_FILTER;
    CResultView    *pResultView = NULL;

    MMC_FILTERDATA FilterData;
    ::ZeroMemory(&FilterData, sizeof(FilterData));

    ::VariantInit(pvarNumericFilter);

    // Get the property value. If we are connected to MMC we'll overwrite it.

    IfFailGo(GetVariant(pvarNumericFilter, m_varNumericFilter));

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    // Check whether the ResultView is in an Initialize or Activate
    // event. If so then don't set it in MMC because the columns have
    // not yet been added. (They are added after ResultViews_Activate).

    // This statement will work because we got the IHeaderCtrl2 meaning that
    // back pointers are connect all the way up to the owning View.

    pResultView = m_pMMCColumnHeaders->GetListView()->GetResultView();

    if ( pResultView->InActivate() || pResultView->InInitialize() )
    {
        goto Error;
    }

    // Clear out the property value stored above as at this point we will only
    // return what we get from MMC
    hr = ::VariantClear(pvarNumericFilter);
    EXCEPTION_CHECK_GO(hr);

    // Get the filter value. Adjust the column index for one-based.

    hr = piHeaderCtrl2->GetColumnFilter(static_cast<UINT>(m_Index - 1L),
                                        &dwType, &FilterData);
    if (E_NOTIMPL == hr)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
    }
    EXCEPTION_CHECK_GO(hr);

    if (MMC_INT_FILTER == dwType)
    {
        pvarNumericFilter->vt = VT_I4;
        pvarNumericFilter->lVal = FilterData.lValue;
    }

Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeader::Persist()
{
    HRESULT  hr = S_OK;
    VARIANT *pvarTextFilter = &m_varTextFilter;
    VARIANT *pvarNumericFilter = &m_varNumericFilter;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    VARIANT varFilterDefault;
    ::VariantInit(&varFilterDefault);

    varFilterDefault.vt = VT_BSTR;
    varFilterDefault.bstrVal = ::SysAllocString(L"");

    if (NULL == varFilterDefault.bstrVal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailGo(PersistSimpleType(&m_sWidth, static_cast<short>(siColumnAutoWidth), OLESTR("Width")));

    IfFailGo(PersistSimpleType(&m_Alignment, siColumnLeft, OLESTR("Alignment")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 3) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_fvarHidden, VARIANT_FALSE, OLESTR("Hidden")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 5) )
    {
    }
    else
    {
        // If saving and variants are empty then convert them to empty strings

        if ( Saving() )
        {
            if (VT_EMPTY == m_varTextFilter.vt)
            {
                pvarTextFilter = &varFilterDefault;
            }

            if (VT_EMPTY == m_varNumericFilter.vt)
            {
                pvarNumericFilter = &varFilterDefault;
            }
        }

        IfFailGo(PersistVariant(pvarTextFilter, varFilterDefault, OLESTR("TextFilter")));
        IfFailGo(PersistSimpleType(&m_TextFilterMaxLen, (long)MAX_PATH, OLESTR("TextFilterMaxLen")));
        IfFailGo(PersistVariant(pvarNumericFilter, varFilterDefault, OLESTR("NumericFilter")));

        // If loading and a filter contains an empty BSTR then change it to
        // VT_EMPTY
        
        if ( Loading() )
        {
            if (VT_BSTR == m_varTextFilter.vt)
            {
                if (!ValidBstr(m_varTextFilter.bstrVal))
                {
                    ::SysFreeString(m_varTextFilter.bstrVal);
                    ::VariantInit(&m_varTextFilter);
                }
            }

            if (VT_BSTR == m_varNumericFilter.vt)
            {
                if (!ValidBstr(m_varNumericFilter.bstrVal))
                {
                    ::SysFreeString(m_varNumericFilter.bstrVal);
                    ::VariantInit(&m_varNumericFilter);
                }
            }
        }
    }

Error:
    (void)::VariantClear(&varFilterDefault);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeader::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCColumnHeader == riid)
    {
        *ppvObjOut = static_cast<IMMCColumnHeader *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\buttons.h ===
//=--------------------------------------------------------------------------=
// buttons.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtons class definition - implements the MMCButtons collection 
//
//=--------------------------------------------------------------------------=

#ifndef _BUTTONS_DEFINED_
#define _BUTTONS_DEFINED_

#include "collect.h"
#include "toolbar.h"

class CMMCToolbar;

class CMMCButtons : public CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>,
                    public CPersistence
{
    protected:
        CMMCButtons(IUnknown *punkOuter);
        ~CMMCButtons();

    public:
        static IUnknown *Create(IUnknown * punk);
        void SetToolbar(CMMCToolbar *pMMCToolbar) { m_pMMCToolbar = pMMCToolbar; }

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButtons
        STDMETHOD(Add)(VARIANT      Index,
                       VARIANT      Key, 
                       VARIANT      Caption,
                       VARIANT      Style,
                       VARIANT      Image,
                       VARIANT      ToolTipText,
                       MMCButton  **ppMMCButton);
        STDMETHOD(Remove)(VARIANT Index);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        CMMCToolbar *m_pMMCToolbar; // back pointer to owning toolbar
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButtons,                 // name
                                &CLSID_MMCButtons,          // clsid
                                "MMCButtons",               // objname
                                "MMCButtons",               // lblname
                                &CMMCButtons::Create,       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCButtons,           // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _BUTTONS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\buttons.cpp ===
//=--------------------------------------------------------------------------=
// buttons.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtons class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "buttons.h"
#include "ctlbar.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButtons::CMMCButtons(IUnknown *punkOuter) :
    CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>(
                                               punkOuter,
                                               OBJECT_TYPE_MMCBUTTONS,
                                               static_cast<IMMCButtons *>(this),
                                               static_cast<CMMCButtons *>(this),
                                               CLSID_MMCButton,
                                               OBJECT_TYPE_MMCBUTTON,
                                               IID_IMMCButton,
                                               static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButtons,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButtons::~CMMCButtons()
{
    InitMemberVariables();
}

void CMMCButtons::InitMemberVariables()
{
    m_pMMCToolbar = NULL;
}

IUnknown *CMMCButtons::Create(IUnknown * punkOuter)
{
    CMMCButtons *pMMCButtons = New CMMCButtons(punkOuter);
    if (NULL == pMMCButtons)
    {
        return NULL;
    }
    else
    {
        return pMMCButtons->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IMMCButtons Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCButtons::Add
(
    VARIANT      Index,
    VARIANT      Key, 
    VARIANT      Caption,
    VARIANT      Style,
    VARIANT      Image,
    VARIANT      TooltipText,
    MMCButton  **ppMMCButton
)
{
    HRESULT     hr = S_OK;
    IMMCButton *piMMCButton = NULL;
    CMMCButton *pMMCButton = NULL;
    BOOL        fIsToolbar = FALSE;
    IToolbar   *piToolbar = NULL;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::Add(Index, Key, &piMMCButton);
    IfFailGo(hr);

    if (ISPRESENT(Caption))
    {
        hr = ::VariantChangeType(&varCoerced, &Caption, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButton->put_Caption(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(TooltipText))
    {
        hr = ::VariantChangeType(&varCoerced, &TooltipText, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButton->put_ToolTipText(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Style))
    {
        hr = ::VariantChangeType(&varCoerced, &Style, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButton->put_Style(static_cast<SnapInButtonStyleConstants>(varCoerced.iVal)));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Image))
    {
        IfFailGo(piMMCButton->put_Image(Image));
    }

    *ppMMCButton = reinterpret_cast<MMCButton *>(piMMCButton);

    // If we belong to a live toolbar at runtime, and it is a toolbar (as
    // opposed to a menu button), then add the button to the MMC toolbar

    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButton, &pMMCButton));
        IfFailGo(CControlbar::GetToolbar(m_pMMCToolbar->GetSnapIn(),
                                         m_pMMCToolbar,
                                         &piToolbar));
        IfFailGo(m_pMMCToolbar->AddButton(piToolbar, pMMCButton));
    }
            
Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCButton);
    }
    QUICK_RELEASE(piToolbar);
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}



STDMETHODIMP CMMCButtons::Remove(VARIANT Index)
{
    HRESULT     hr = S_OK;
    IMMCButton *piMMCButton = NULL;
    long        lIndex = 0;
    BOOL        fIsToolbar = FALSE;

    // First get the button from the collection

    IfFailGo(get_Item(Index, &piMMCButton));

    // Get its numerical index

    IfFailGo(piMMCButton->get_Index(&lIndex));

    // Check if it is a toolbar before removing the button because if it is
    // the last button then the toolbar has no way to know whether it is a
    // toolbar or a menu button.

    if (NULL != m_pMMCToolbar)
    {
        IfFailGo(m_pMMCToolbar->IsToolbar(&fIsToolbar));
    }

    // Remove the buton from the collection
    
    hr = CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::Remove(Index);
    IfFailGo(hr);

    // If we belong to a live toolbar at runtime, and it is a toolbar (as
    // opposed to a menu button), then remove the button from the MMC toolbar

    IfFalseGo(fIsToolbar, S_OK);
    IfFalseGo(NULL != m_pMMCToolbar, S_OK);
    IfFalseGo(m_pMMCToolbar->Attached(), S_OK);
    IfFailGo(m_pMMCToolbar->RemoveButton(lIndex));
    
Error:
    QUICK_RELEASE(piMMCButton);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtons::Persist()
{
    HRESULT      hr = S_OK;
    IMMCButton  *piMMCButton = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::Persist(piMMCButton);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtons::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCButtons == riid)
    {
        *ppvObjOut = static_cast<IMMCButtons *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInCollection<IMMCButton, MMCButton, IMMCButtons>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\clipbord.cpp ===
//=--------------------------------------------------------------------------=
// clipbord.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCClipboard class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "clipbord.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCClipboard::CMMCClipboard(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCCLIPBOARD,
                            static_cast<IMMCClipboard *>(this),
                            static_cast<CMMCClipboard *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCClipboard::~CMMCClipboard()
{
    // Remove read-only so contained collections can be cleaned up.
    (void)SetReadOnly(FALSE);

    RELEASE(m_piScopeItems);
    RELEASE(m_piListItems);
    RELEASE(m_piDataObjects);
    InitMemberVariables();
}

void CMMCClipboard::InitMemberVariables()
{
    m_SelectionType = siEmpty;
    m_piScopeItems = NULL;
    m_piListItems = NULL;
    m_piDataObjects = NULL;
    m_pScopeItems = NULL;
    m_pListItems = NULL;
    m_pDataObjects = NULL;
}

IUnknown *CMMCClipboard::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punk = NULL;
    CMMCClipboard *pMMCClipboard = New CMMCClipboard(punkOuter);

    if (NULL == pMMCClipboard)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    punk = CScopeItems::Create(NULL);
    if (NULL == punk)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punk->QueryInterface(IID_IScopeItems,
                     reinterpret_cast<void **>(&pMMCClipboard->m_piScopeItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk,
                                                  &pMMCClipboard->m_pScopeItems));
    punk->Release();
    
    punk = CMMCListItems::Create(NULL);
    if (NULL == punk)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punk->QueryInterface(IID_IMMCListItems,
                      reinterpret_cast<void **>(&pMMCClipboard->m_piListItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk,
                                                  &pMMCClipboard->m_pListItems));
    punk->Release();

    punk = CMMCDataObjects::Create(NULL);
    if (NULL == punk)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(punk->QueryInterface(IID_IMMCDataObjects,
                    reinterpret_cast<void **>(&pMMCClipboard->m_piDataObjects)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk,
                                                &pMMCClipboard->m_pDataObjects));
    RELEASE(punk);

Error:
    QUICK_RELEASE(punk);
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCClipboard)
        {
            delete pMMCClipboard;
        }
        return NULL;
    }
    else
    {
        return pMMCClipboard->PrivateUnknown();
    }
}

void CMMCClipboard::SetReadOnly(BOOL fReadOnly)
{
    m_pScopeItems->SetReadOnly(fReadOnly);
    m_pListItems->SetReadOnly(fReadOnly);
    m_pDataObjects->SetReadOnly(fReadOnly);
}

HRESULT CMMCClipboard::DetermineSelectionType()
{
    HRESULT hr = S_OK;
    long    cScopeItems = 0;
    long    cListItems = 0;
    long    cForeignItems = 0;

    // Get the counts of everything we're currently holding

    IfFailGo(m_piScopeItems->get_Count(&cScopeItems));
    IfFailGo(m_piListItems->get_Count(&cListItems));
    IfFailGo(m_piDataObjects->get_Count(&cForeignItems));

    // There is no really clean way to code this so we'll use a clear but less
    // efficient algorithm to show exactly the criteria used and to be sure
    // that all cases are covered.

    if ( (0 != cScopeItems) && (0 != cListItems) && (0 != cForeignItems) )
    {
        m_SelectionType = siMultiMixedForeign;
    }
    else if ( (0 != cScopeItems) && (0 != cListItems) && (0 == cForeignItems) )
    {
        m_SelectionType = siMultiMixed;
    }
    else if ( (0 == cScopeItems) && (0 != cListItems) && (0 != cForeignItems) )
    {
        m_SelectionType = siMultiMixedForeign;
    }
    else if ( (0 != cScopeItems) && (0 == cListItems) && (0 != cForeignItems) )
    {
        m_SelectionType = siMultiMixedForeign;
    }
    else if ( (0 != cScopeItems) && (0 == cListItems) && (0 == cForeignItems) )
    {
        if (cScopeItems > 1L)
        {
            m_SelectionType = siMultiScopeItems;
        }
        else
        {
            m_SelectionType = siSingleScopeItem;
        }
    }
    else if ( (0 == cScopeItems) && (0 != cListItems) && (0 == cForeignItems) )
    {
        if (cListItems > 1L)
        {
            m_SelectionType = siMultiListItems;
        }
        else
        {
            m_SelectionType = siSingleListItem;
        }
    }
    else if ( (0 == cScopeItems) && (0 == cListItems) && (0 != cForeignItems) )
    {
        if (cForeignItems > 1L)
        {
            m_SelectionType = siMultiForeign;
        }
        else
        {
            m_SelectionType = siSingleForeign;
        }
    }
    else
    {
        m_SelectionType = siEmpty;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCClipboard::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCClipboard == riid)
    {
        *ppvObjOut = static_cast<IMMCClipboard *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\clipbord.h ===
//=--------------------------------------------------------------------------=
// clipbord.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1998-1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCClipboard class definition - implements the MMCClipboard object
//
//=--------------------------------------------------------------------------=

#ifndef _CLIPBORD_DEFINED_
#define _CLIPBORD_DEFINED_

#include "snapin.h"
#include "scopitms.h"
#include "listitms.h"
#include "dataobjs.h"

class CScopeItems;
class CMMCListItems;
class CMMCDataObjects;

// Helper macros to weed out seleciton types

#define IsForeign(Type) ( (siSingleForeign     == Type) || \
                          (siMultiMixed        == Type) || \
                          (siMultiForeign      == Type) || \
                          (siMultiMixedForeign == Type) )


#define IsSingle(Type) ( (siSingleForeign   == Type) || \
                         (siSingleScopeItem == Type) || \
                         (siSingleListItem  == Type) )


class CMMCClipboard : public CSnapInAutomationObject,
                      public IMMCClipboard
{
    public:
        CMMCClipboard(IUnknown *punkOuter);
        ~CMMCClipboard();
        static IUnknown *Create(IUnknown *punkOuter);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCClipboard

        SIMPLE_PROPERTY_RO(CMMCClipboard, SelectionType, SnapInSelectionTypeConstants,      DISPID_CLIPBOARD_SELECTION_TYPE);
        COCLASS_PROPERTY_RO(CMMCClipboard, ScopeItems,    ScopeItems,      IScopeItems,     DISPID_CLIPBOARD_SCOPEITEMS);
        COCLASS_PROPERTY_RO(CMMCClipboard, ListItems,     MMCListItems,    IMMCListItems,   DISPID_CLIPBOARD_LISTITEMS);
        COCLASS_PROPERTY_RO(CMMCClipboard, DataObjects,   MMCDataObjects,  IMMCDataObjects, DISPID_CLIPBOARD_DATAOBJECTS);

    // Public Utility Methods
        HRESULT DetermineSelectionType();
        void SetSelectionType(SnapInSelectionTypeConstants Type) { m_SelectionType = Type; }
        SnapInSelectionTypeConstants GetSelectionType() { return m_SelectionType; }
        void SetReadOnly(BOOL fReadOnly);
        CScopeItems *GetScopeItems() { return m_pScopeItems; }
        CMMCListItems *GetListItems() { return m_pListItems; }
        CMMCDataObjects *GetDataObjects() { return m_pDataObjects; }
      
    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // These are the the 3 collections: MMCClipboard.ScopeItems,
        // MMCClipboard.ListItems, and MMCClipboard.DataObjects 

        CScopeItems     *m_pScopeItems;
        CMMCListItems   *m_pListItems;
        CMMCDataObjects *m_pDataObjects;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCClipboard,           // name
                                &CLSID_MMCClipboard,    // clsid
                                "MMCClipboard",         // objname
                                "MMCClipboard",         // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCClipboard,     // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _CLIPBORD_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdrs.h ===
//=--------------------------------------------------------------------------=
// colhdrs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeaders class definition - implements the MMCColumnHeaders
// collection
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNHEADERS_DEFINED_
#define _COLUMNHEADERS_DEFINED_

#include "collect.h"
#include "view.h"
#include "listview.h"

class CMMCListView;

class CMMCColumnHeaders : public CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>,
                          public CPersistence
{
    protected:
        CMMCColumnHeaders(IUnknown *punkOuter);
        ~CMMCColumnHeaders();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCColumnHeaders
        STDMETHOD(Add)(VARIANT           Index,
                       VARIANT           Key, 
                       VARIANT           Text,
                       VARIANT           Width,
                       VARIANT           Alignment,
                       MMCColumnHeader **ppMMCColumnHeader);

    // Public utility methods

    public:

        void SetListView(CMMCListView *pMMCListView) { m_pMMCListView = pMMCListView; }
        CMMCListView *GetListView() { return m_pMMCListView; }

        HRESULT GetIHeaderCtrl2(IHeaderCtrl2 **ppiHeaderCtrl2);
        HRESULT GetIColumnData(IColumnData **ppiColumnData);

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CMMCListView *m_pMMCListView; // back pointer to owning list view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCColumnHeaders,           // name
                                &CLSID_MMCColumnHeaders,    // clsid
                                "MMCColumnHeaders",         // objname
                                "MMCColumnHeaders",         // lblname
                                &CMMCColumnHeaders::Create, // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCColumnHeaders,     // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _COLUMNHEADERS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdr.h ===
//=--------------------------------------------------------------------------=
// colhdr.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class definition - implements MMCColumnHeader object
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNHEADER_DEFINED_
#define _COLUMNHEADER_DEFINED_

#include "colhdrs.h"

class CMMCColumnHeader : public CSnapInAutomationObject,
                         public CPersistence,
                         public IMMCColumnHeader
{
    private:
        CMMCColumnHeader(IUnknown *punkOuter);
        ~CMMCColumnHeader();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCColumnHeader

    public:

        SIMPLE_PROPERTY_RW(CMMCColumnHeader,     Index, long, DISPID_COLUMNHEADER_INDEX);
        BSTR_PROPERTY_RW(CMMCColumnHeader,       Key, DISPID_COLUMNHEADER_KEY);
        VARIANTREF_PROPERTY_RW(CMMCColumnHeader, Tag, DISPID_COLUMNHEADER_TAG);

        // For text we can use the macro for propget because we only need to
        // return our stored value. For propput we may need to call into MMC.
        
        STDMETHOD(put_Text)(BSTR Text);
        BSTR_PROPERTY_RO(CMMCColumnHeader, Text, DISPID_COLUMNHEADER_TEXT);

        STDMETHOD(put_Width)(short sWidth);
        STDMETHOD(get_Width)(short *psWidth);

        SIMPLE_PROPERTY_RW(CMMCColumnHeader, Alignment, SnapInColumnAlignmentConstants, DISPID_COLUMNHEADER_ALIGNMENT);

        STDMETHOD(put_Hidden)(VARIANT_BOOL fvarHidden);
        STDMETHOD(get_Hidden)(VARIANT_BOOL *pfvarHidden);

        STDMETHOD(put_TextFilter)(VARIANT varTextFilter);
        STDMETHOD(get_TextFilter)(VARIANT *pvarTextFilter);

        SIMPLE_PROPERTY_RW(CMMCColumnHeader, TextFilterMaxLen, long, DISPID_COLUMNHEADER_TEXT_FILTER_MAX_LEN);

        STDMETHOD(put_NumericFilter)(VARIANT varNumericFilter);
        STDMETHOD(get_NumericFilter)(VARIANT *pvarNumericFilter);

    // Public Utility methods

    public:

        void SetColumnHeaders(CMMCColumnHeaders *pMMCColumnHeaders) { m_pMMCColumnHeaders = pMMCColumnHeaders; }
        BSTR GetText() { return m_bstrText; }
        long GetPosition() { return m_lPosition; }
        long GetIndex() { return m_Index; }
        BOOL HaveTextFilter() { return VT_EMPTY != m_varTextFilter.vt; }
        BOOL HaveNumericFilter() { return VT_EMPTY != m_varNumericFilter.vt; }
        short GetWidth() { return m_sWidth; }
        SnapInColumnAlignmentConstants GetAlignment() { return m_Alignment; }
        BOOL Hidden() { return VARIANTBOOL_TO_BOOL(m_fvarHidden); }
        HRESULT SetFilter();

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT SetTextFilter(VARIANT varTextFilter);
        HRESULT SetNumericFilter(VARIANT varNumericFilter);
        HRESULT SetHeaderCtrlWidth(int nWidth);

        // These variables hold the values of properties that have explicit
        // put/get functions.

        VARIANT_BOOL       m_fvarHidden;
        long               m_lPosition;
        short              m_sWidth;
        VARIANT            m_varTextFilter;
        VARIANT            m_varNumericFilter;

        CMMCColumnHeaders *m_pMMCColumnHeaders; // back pointer to owning collection
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCColumnHeader,           // name
                                &CLSID_MMCColumnHeader,    // clsid
                                "MMCColumnHeader",         // objname
                                "MMCColumnHeader",         // lblname
                                &CMMCColumnHeader::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IMMCColumnHeader,     // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _COLUMNHEADER_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colhdrs.cpp ===
//=--------------------------------------------------------------------------=
// colhdrs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeaders class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colhdrs.h"
#include "colhdr.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCColumnHeaders::CMMCColumnHeaders(IUnknown *punkOuter) :
    CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>(
                      punkOuter,
                      OBJECT_TYPE_MMCCOLUMNHEADERS,
                      static_cast<IMMCColumnHeaders *>(this),
                      static_cast<CMMCColumnHeaders *>(this),
                      CLSID_MMCColumnHeader,
                      OBJECT_TYPE_MMCCOLUMNHEADER,
                      IID_IMMCColumnHeader,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCColumnHeaders,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CMMCColumnHeaders::InitMemberVariables()
{
    m_pMMCListView = NULL;
}

CMMCColumnHeaders::~CMMCColumnHeaders()
{
    InitMemberVariables();
}

IUnknown *CMMCColumnHeaders::Create(IUnknown * punkOuter)
{
    CMMCColumnHeaders *pMMCColumnHeaders = New CMMCColumnHeaders(punkOuter);
    if (NULL == pMMCColumnHeaders)
    {
        return NULL;
    }
    else
    {
        return pMMCColumnHeaders->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
// CMMCColumnHeaders::GetIHeaderCtrl2
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IHeaderCtrl2 **ppiHeaderCtrl2 [out] if non-NULL IHeaderCtrl2 returned here
//                                        NOT AddRef()ed
//                                        DO NOT call Release on the returned
//                                        interface pointer
// Output:
//      HRESULT
//
// Notes:
//
// As we are only a lowly column headers collection and the IHeaderCtrl2 pointer
// is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated column headers collection
// created  by the user or if any object up the hierarchy is isolated then we
// will return SID_E_DETACHED_OBJECT
//

HRESULT CMMCColumnHeaders::GetIHeaderCtrl2(IHeaderCtrl2 **ppiHeaderCtrl2)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pMMCListView, hr);

    pResultView = m_pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, hr);

    pScopePaneItem = pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);
    IfFalseGo(pScopePaneItem->Active(), hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    *ppiHeaderCtrl2 = pView->GetIHeaderCtrl2();
    IfFalseGo(NULL != *ppiHeaderCtrl2, hr);

    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CMMCColumnHeaders::GetIColumnData
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IColumnData **ppiColumnData [out] if non-NULL IColumnData returned here
//                                    NOT AddRef()ed
//                                    DO NOT call Release on the returned
//                                    interface pointer
// Output:
//      HRESULT
//
// Notes:
//
// As we are only a lowly column headers collection and the IColumnData pointer
// is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated column headers collection
// created  by the user or if any object up the hierarchy is isolated then we
// will return SID_E_DETACHED_OBJECT
//

HRESULT CMMCColumnHeaders::GetIColumnData(IColumnData **ppiColumnData)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pMMCListView, hr);

    pResultView = m_pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, hr);

    pScopePaneItem = pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);
    IfFalseGo(pScopePaneItem->Active(), hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    *ppiColumnData = pView->GetIColumnData();

    // If IColumnData is NULL then we are in MMC < 1.2
    
    IfFalseGo(NULL != *ppiColumnData, SID_E_MMC_FEATURE_NOT_AVAILABLE);

    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IMMCColumnHeaders Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCColumnHeaders::Add
(
    VARIANT           Index,
    VARIANT           Key, 
    VARIANT           Text,
    VARIANT           Width,
    VARIANT           Alignment,
    MMCColumnHeader **ppMMCColumnHeader
)
{
    HRESULT           hr = S_OK;
    IMMCColumnHeader *piMMCColumnHeader = NULL;
    CMMCColumnHeader *pMMCColumnHeader = NULL;
    long              lIndex = 0;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>::Add(Index, Key, &piMMCColumnHeader);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varCoerced, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCColumnHeader->put_Text(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);
    
    if (ISPRESENT(Width))
    {
        hr = ::VariantChangeType(&varCoerced, &Width, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCColumnHeader->put_Width(varCoerced.iVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Alignment))
    {
        hr = ::VariantChangeType(&varCoerced, &Alignment, 0, VT_I2);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCColumnHeader->put_Alignment(static_cast<SnapInColumnAlignmentConstants>(varCoerced.iVal)));
    }

    // Give the column header its back pointer to the collection

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCColumnHeader,
                                                   &pMMCColumnHeader));
    pMMCColumnHeader->SetColumnHeaders(this);

    *ppMMCColumnHeader = reinterpret_cast<MMCColumnHeader *>(piMMCColumnHeader);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCColumnHeader);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeaders::Persist()
{
    HRESULT           hr = S_OK;
    IMMCColumnHeader *piMMCColumnHeader = NULL; // Not AddRef()ed
    CMMCColumnHeader *pMMCColumnHeader = NULL;
    long              lIndex = 0;
    long              cCols = 0;
    long              i = 0;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>::Persist(piMMCColumnHeader);

    // If we just loaded then:
    // Give the column headers their back pointers to the collection and set
    // their default Position properties.

    if (Loading())
    {
        cCols = GetCount();
        for (i = 0; i < cCols; i++)
        {
            piMMCColumnHeader = GetItemByIndex(i);

            IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCColumnHeader,
                                                           &pMMCColumnHeader));
            pMMCColumnHeader->SetColumnHeaders(this);
        }
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCColumnHeaders::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCColumnHeaders == riid)
    {
        *ppvObjOut = static_cast<IMMCColumnHeaders *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCColumnHeader, MMCColumnHeader, IMMCColumnHeaders>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colset.cpp ===
//=--------------------------------------------------------------------------=
// colset.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colset.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CColumnSetting::CColumnSetting(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_COLUMNSETTING,
                            static_cast<IColumnSetting *>(this),
                            static_cast<CColumnSetting *>(this),
                            0,     // no property pages
                            NULL,  // no property pages
                            NULL)  // no peristence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CColumnSetting::~CColumnSetting()
{
    FREESTRING(m_bstrKey);
    InitMemberVariables();
}

void CColumnSetting::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

    m_Width = 0;
    m_Hidden = VARIANT_FALSE;
    m_Position = 0;
}


IUnknown *CColumnSetting::Create(IUnknown * punkOuter)
{
    CColumnSetting *pColumnSetting = New CColumnSetting(punkOuter);
    if (NULL == pColumnSetting)
    {
        return NULL;
    }
    else
    {
        return pColumnSetting->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CColumnSetting::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IColumnSetting == riid)
    {
        *ppvObjOut = static_cast<IColumnSetting *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colsets.cpp ===
//=--------------------------------------------------------------------------=
// colsets.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSettings class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "colsets.h"
#include "colset.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CColumnSettings::CColumnSettings(IUnknown *punkOuter) :
    CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>(
                      punkOuter,
                      OBJECT_TYPE_COLUMNSETTINGS,
                      static_cast<IColumnSettings *>(this),
                      static_cast<CColumnSettings *>(this),
                      CLSID_ColumnSetting,
                      OBJECT_TYPE_COLUMNSETTING,
                      IID_IColumnSetting,
                      NULL)  // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CColumnSettings::InitMemberVariables()
{
    m_pView = NULL;
    m_bstrColumnSetID = NULL;
}

CColumnSettings::~CColumnSettings()
{
    InitMemberVariables();
    FREESTRING(m_bstrColumnSetID);
}

IUnknown *CColumnSettings::Create(IUnknown * punkOuter)
{
    CColumnSettings *pColumnSettings = New CColumnSettings(punkOuter);
    if (NULL == pColumnSettings)
    {
        return NULL;
    }
    else
    {
        return pColumnSettings->PrivateUnknown();
    }
}


static int __cdecl CompareColumnPosition
(
    const MMC_COLUMN_DATA *pCol1,
    const MMC_COLUMN_DATA *pCol2
)
{
    int nResult = 0;

    if (pCol1->ulReserved < pCol2->ulReserved)
    {
        nResult = -1;
    }
    else if (pCol1->ulReserved == pCol2->ulReserved)
    {
        nResult = 0;
    }
    else if (pCol1->ulReserved > pCol2->ulReserved)
    {
        nResult = 1;
    }
    return nResult;
}




//=--------------------------------------------------------------------------=
//                      IColumnSettings Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CColumnSettings::Add
(
    VARIANT         Index,
    VARIANT         Key, 
    VARIANT         Width,
    VARIANT         Hidden,
    VARIANT         Position,
    ColumnSetting **ppColumnSetting
)
{
    HRESULT         hr = S_OK;
    IColumnSetting *piColumnSetting = NULL;
    CColumnSetting *pColumnSetting = NULL;
    long            lIndex = 0;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>::Add(Index, Key, &piColumnSetting);
    IfFailGo(hr);

    if (ISPRESENT(Width))
    {
        hr = ::VariantChangeType(&varCoerced, &Width, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piColumnSetting->put_Width(varCoerced.lVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Hidden))
    {
        hr = ::VariantChangeType(&varCoerced, &Hidden, 0, VT_BOOL);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piColumnSetting->put_Hidden(varCoerced.boolVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Position))
    {
        hr = ::VariantChangeType(&varCoerced, &Position, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piColumnSetting->put_Position(varCoerced.iVal));
    }
    else
    {
        // A new column header's position defaults to its index

        IfFailGo(piColumnSetting->get_Index(&lIndex));
        IfFailGo(piColumnSetting->put_Position(lIndex));
    }

    *ppColumnSetting = reinterpret_cast<ColumnSetting *>(piColumnSetting);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piColumnSetting);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}


STDMETHODIMP CColumnSettings::Persist()
{
    HRESULT              hr = S_OK;
    CColumnSetting      *pColumnSetting = NULL;
    MMC_COLUMN_SET_DATA *pColSetData = NULL;
    MMC_COLUMN_DATA     *pColData = NULL;
    long                 i = 0;
    long                 cColumns = 0;
    size_t               cbBuffer = 0;
    IColumnData         *piColumnData = NULL; // Not AddRef()ed
    SColumnSetID        *pSColumnSetID = NULL;

    if (NULL == m_pView)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    piColumnData = m_pView->GetIColumnData();
    if (NULL == piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::GetColumnSetID(m_bstrColumnSetID, &pSColumnSetID));

    // Allocate memory for the column config data. Use CoTaskMemAlloc() to be
    // compatible with the way MMC allocates it.

    cColumns = GetCount();
    IfFalseGo(0 != cColumns, S_OK); // no columns, nothing to do

    cbBuffer = sizeof(MMC_COLUMN_SET_DATA) +
               (cColumns * sizeof(MMC_COLUMN_DATA));

    pColSetData = (MMC_COLUMN_SET_DATA *)CtlAllocZero(static_cast<DWORD>(cbBuffer));
    if (NULL == pColSetData)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::ZeroMemory(pColSetData, static_cast<DWORD>(cbBuffer));

    pColSetData->cbSize = sizeof(MMC_COLUMN_SET_DATA);
    pColSetData->nNumCols = static_cast<int>(cColumns);
    pColSetData->pColData = (MMC_COLUMN_DATA *)((pColSetData) + 1);

    for (i = 0, pColData = pColSetData->pColData;
         i < cColumns;
         i++, pColData++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pColumnSetting));

        pColData->nColIndex = static_cast<int>(pColumnSetting->GetIndex() - 1L);
        if (pColumnSetting->Hidden())
        {
            pColData->dwFlags |= HDI_HIDDEN;
        }
        pColData->nWidth = static_cast<int>(pColumnSetting->GetWidth());

        // For now put Position in the reserved field. We'll clean it up
        // below afer reordering the columns
        pColData->ulReserved = pColumnSetting->GetPosition();
    }

    // At this point the column data structs are in the array in index order
    // They need to be sorted according to their Position property.

    ::qsort(pColSetData->pColData,
            static_cast<size_t>(cColumns),
            sizeof(MMC_COLUMN_DATA),
            reinterpret_cast<int (__cdecl *)(const void *c1, const void *c2)>
            (CompareColumnPosition)
           );

    // Zero out the reserved field we used above to hold the position

    for (i = 0, pColData = pColSetData->pColData;
         i < cColumns;
         i++, pColData++)
    {
        pColData->ulReserved = 0;
    }

    // Tell MMC do persist the column data

    hr = piColumnData->SetColumnConfigData(pSColumnSetID, pColSetData);
    EXCEPTION_CHECK_GO(hr);

Error:
    if (NULL != pColSetData)
    {
        CtlFree(pColSetData);
    }
    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CColumnSettings::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IColumnSettings == riid)
    {
        *ppvObjOut = static_cast<IColumnSettings *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colset.h ===
//=--------------------------------------------------------------------------=
// colset.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSetting class definition - ColumnSetting object implementation
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNSETTING_DEFINED_
#define _COLUMNSETTING_DEFINED_

#include "colhdrs.h"

class CColumnSetting : public CSnapInAutomationObject,
                       public IColumnSetting
{
    private:
        CColumnSetting(IUnknown *punkOuter);
        ~CColumnSetting();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IColumnSetting

    public:

        SIMPLE_PROPERTY_RW(CColumnSetting, Index,    long,         DISPID_COLUMNSETTING_INDEX);
        BSTR_PROPERTY_RW(CColumnSetting,   Key,                    DISPID_COLUMNSETTING_KEY);
        SIMPLE_PROPERTY_RW(CColumnSetting, Width,    long,         DISPID_COLUMNSETTING_WIDTH);
        SIMPLE_PROPERTY_RW(CColumnSetting, Hidden,   VARIANT_BOOL, DISPID_COLUMNSETTING_HIDDEN);
        SIMPLE_PROPERTY_RW(CColumnSetting, Position, long,         DISPID_COLUMNSETTING_POSITION);

    // Public Utility methods

    public:

        long GetPosition() { return m_Position; }
        long GetIndex() { return m_Index; }
        long GetWidth() { return m_Width; }
        BOOL Hidden() { return VARIANTBOOL_TO_BOOL(m_Hidden); }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ColumnSetting,           // name
                                &CLSID_ColumnSetting,    // clsid
                                "ColumnSetting",         // objname
                                "ColumnSetting",         // lblname
                                &CColumnSetting::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IColumnSetting,     // dispatch IID
                                NULL,                    // event IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _COLUMNSETTING_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converb.cpp ===
//=--------------------------------------------------------------------------=
// converb.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerb class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "converb.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCConsoleVerb::CMMCConsoleVerb(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCCONSOLEVERB,
                            static_cast<IMMCConsoleVerb *>(this),
                            static_cast<CMMCConsoleVerb *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCConsoleVerb::~CMMCConsoleVerb()
{
    FREESTRING(m_bstrKey);
    InitMemberVariables();
}

void CMMCConsoleVerb::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_Verb = siNone;
    m_pView = NULL;
}

IUnknown *CMMCConsoleVerb::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMMCConsoleVerb = NULL;

    CMMCConsoleVerb *pMMCConsoleVerb = New CMMCConsoleVerb(punkOuter);

    IfFalseGo(NULL != pMMCConsoleVerb, SID_E_OUTOFMEMORY);
    punkMMCConsoleVerb = pMMCConsoleVerb->PrivateUnknown();

Error:
    return punkMMCConsoleVerb;
}



//=--------------------------------------------------------------------------=
// CMMCConsoleVerb::GetIConsoleVerb
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IConsoleVerb *ppiConsoleVerb  [out] MMC's IConsoleVerb for the owning view
//                                      not AddRef()ed
//    
//
// Output:
//      HRESULT
//
// Notes:
//
// Gets a non-AddRef()ed IConsoleVerb from the current view.
//

HRESULT CMMCConsoleVerb::GetIConsoleVerb(IConsoleVerb **ppiConsoleVerb)
{
    HRESULT hr = S_OK;

    IfFalseGo(NULL != m_pView, SID_E_DETACHED_OBJECT);
    *ppiConsoleVerb = m_pView->GetIConsoleVerb();
    IfFalseGo(NULL != *ppiConsoleVerb, SID_E_INTERNAL);

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


HRESULT CMMCConsoleVerb::SetVerbState
(
    MMC_BUTTON_STATE StateType,
    BOOL             fNewState
)
{
    HRESULT       hr = S_OK;
    IConsoleVerb *piConsoleVerb = NULL; // Not AddRef()ed

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));

    hr = piConsoleVerb->SetVerbState(static_cast<MMC_CONSOLE_VERB>(m_Verb),
                                     StateType, fNewState);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


HRESULT CMMCConsoleVerb::GetVerbState
(
    MMC_BUTTON_STATE  StateType,
    VARIANT_BOOL     *pfvarCurrentState
)
{
    HRESULT       hr = S_OK;
    BOOL          fCurrentState = FALSE;
    IConsoleVerb *piConsoleVerb = NULL; // Not AddRef()ed

    *pfvarCurrentState = VARIANT_FALSE;

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));

    hr = piConsoleVerb->GetVerbState(static_cast<MMC_CONSOLE_VERB>(m_Verb),
                                     StateType, &fCurrentState);
    EXCEPTION_CHECK_GO(hr);

    *pfvarCurrentState = VARIANTBOOL_TO_BOOL(fCurrentState);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//
//                      IMMCConsoleVerb Methods
//
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCConsoleVerb::put_Enabled(VARIANT_BOOL fvarEnabled)
{
    RRETURN(SetVerbState(ENABLED, VARIANTBOOL_TO_BOOL(fvarEnabled)));
}

STDMETHODIMP CMMCConsoleVerb::get_Enabled(VARIANT_BOOL *pfvarEnabled)
{
    RRETURN(GetVerbState(ENABLED, pfvarEnabled));
}


STDMETHODIMP CMMCConsoleVerb::put_Checked(VARIANT_BOOL fvarChecked)
{
    RRETURN(SetVerbState(CHECKED, VARIANTBOOL_TO_BOOL(fvarChecked)));
}


STDMETHODIMP CMMCConsoleVerb::get_Checked(VARIANT_BOOL *pfvarChecked)
{
    RRETURN(GetVerbState(CHECKED, pfvarChecked));
}


STDMETHODIMP CMMCConsoleVerb::put_Hidden(VARIANT_BOOL fvarHidden)
{
    RRETURN(SetVerbState(HIDDEN, VARIANTBOOL_TO_BOOL(fvarHidden)));
}


STDMETHODIMP CMMCConsoleVerb::get_Hidden(VARIANT_BOOL *pfvarHidden)
{
    RRETURN(GetVerbState(HIDDEN, pfvarHidden));
}


STDMETHODIMP CMMCConsoleVerb::put_Indeterminate(VARIANT_BOOL fvarIndeterminate)
{
    RRETURN(SetVerbState(INDETERMINATE, VARIANTBOOL_TO_BOOL(fvarIndeterminate)));
}


STDMETHODIMP CMMCConsoleVerb::get_Indeterminate(VARIANT_BOOL *pfvarIndeterminate)
{
    RRETURN(GetVerbState(INDETERMINATE, pfvarIndeterminate));
}


STDMETHODIMP CMMCConsoleVerb::put_ButtonPressed(VARIANT_BOOL fvarButtonPressed)
{
    RRETURN(SetVerbState(BUTTONPRESSED, VARIANTBOOL_TO_BOOL(fvarButtonPressed)));
}


STDMETHODIMP CMMCConsoleVerb::get_ButtonPressed(VARIANT_BOOL *pfvarButtonPressed)
{
    RRETURN(GetVerbState(BUTTONPRESSED, pfvarButtonPressed));
}


STDMETHODIMP CMMCConsoleVerb::put_Default(VARIANT_BOOL fvarDefault)
{
    HRESULT           hr = S_OK;
    MMC_CONSOLE_VERB  Verb = static_cast<MMC_CONSOLE_VERB>(m_Verb);
    IConsoleVerb     *piConsoleVerb = NULL; // Not AddRef()ed

    if (VARIANT_FALSE == fvarDefault)
    {
        Verb = MMC_VERB_NONE;
    }

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));
    
    hr = piConsoleVerb->SetDefaultVerb(Verb);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCConsoleVerb::get_Default(VARIANT_BOOL *pfvarDefault)
{
    HRESULT           hr = S_OK;
    MMC_CONSOLE_VERB  Verb = MMC_VERB_NONE;
    IConsoleVerb     *piConsoleVerb = NULL; // Not AddRef()ed

    *pfvarDefault = VARIANT_FALSE;

    IfFailGo(GetIConsoleVerb(&piConsoleVerb));

    hr = piConsoleVerb->GetDefaultVerb(&Verb);
    EXCEPTION_CHECK_GO(hr);

    if (Verb == static_cast<MMC_CONSOLE_VERB>(m_Verb))
    {
        *pfvarDefault = VARIANT_TRUE;
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCConsoleVerb::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCConsoleVerb == riid)
    {
        *ppvObjOut = static_cast<IMMCConsoleVerb *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converb.h ===
//=--------------------------------------------------------------------------=
// converb.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerb class definition - implements MMCConsoleVerb object
//
//=--------------------------------------------------------------------------=

#ifndef _CONVERB_DEFINED_
#define _CONVERB_DEFINED_

#include "view.h"

class CMMCConsoleVerb : public CSnapInAutomationObject,
                        public IMMCConsoleVerb
{
    private:
        CMMCConsoleVerb(IUnknown *punkOuter);
        ~CMMCConsoleVerb();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCConsoleVerb
        SIMPLE_PROPERTY_RW(CMMCConsoleVerb, Index, long, DISPID_CONSOLEVERB_INDEX);

        BSTR_PROPERTY_RW(CMMCConsoleVerb, Key, DISPID_CONSOLEVERB_KEY);

        SIMPLE_PROPERTY_RW(CMMCConsoleVerb, Verb, SnapInConsoleVerbConstants, DISPID_CONSOLEVERB_VERB);

        STDMETHOD(put_Enabled)(VARIANT_BOOL fvarEnabled);
        STDMETHOD(get_Enabled)(VARIANT_BOOL *pfvarEnabled);

        STDMETHOD(put_Checked)(VARIANT_BOOL fvarChecked);
        STDMETHOD(get_Checked)(VARIANT_BOOL *pfvarChecked);

        STDMETHOD(put_Hidden)(VARIANT_BOOL fvarHidden);
        STDMETHOD(get_Hidden)(VARIANT_BOOL *pfvarHidden);

        STDMETHOD(put_Indeterminate)(VARIANT_BOOL fvarIndeterminate);
        STDMETHOD(get_Indeterminate)(VARIANT_BOOL *pfvarIndeterminate);

        STDMETHOD(put_ButtonPressed)(VARIANT_BOOL fvarButtonPressed);
        STDMETHOD(get_ButtonPressed)(VARIANT_BOOL *pfvarButtonPressed);

        STDMETHOD(put_Default)(VARIANT_BOOL fvarDefault);
        STDMETHOD(get_Default)(VARIANT_BOOL *pfvarDefault);

    // Public utility methods
    public:
        void SetView(CView *pView) { m_pView = pView; }
        CView *GetView() { return m_pView; };

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        HRESULT SetVerbState(MMC_BUTTON_STATE StateType,
                             BOOL             fNewState);

        HRESULT GetVerbState(MMC_BUTTON_STATE StateType,
                             VARIANT_BOOL     *pfvarCurrentState);

        HRESULT GetIConsoleVerb(IConsoleVerb **ppiConsoleVerb);

        CView *m_pView; //owning view, needed for access to MMC's IConsoleVerb
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCConsoleVerb,             // name
                                NULL,                       // clsid
                                NULL,                       // objname
                                NULL,                       // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCConsoleVerb,       // dispatch IID
                                NULL,                       // no event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _CONVERB_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\collect.h ===
//=--------------------------------------------------------------------------=
// collect.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInCollection class definition
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPINCOLLECTION_DEFINED_
#define _SNAPINCOLLECTION_DEFINED_

#include "siautobj.h"
#include "help.h"
#include "array.h"
#include "localobj.h"
#include "tlver.h"
#include "errors.h"
#include "error.h"
#include "rtutil.h"

// This macro determines whether a VARIANT has an acceptable type for a
// a collection index


#define IS_VALID_INDEX_TYPE(v) ( (VT_UI1  == (v).vt) || \
                                 (VT_I2   == (v).vt) || \
                                 (VT_I4   == (v).vt) || \
                                 (VT_BSTR == (v).vt) )

// Forward reference to CEnumObjects class that implements IEnumVARIANT
// to support For...Each in VB

template <class IObject, class CoClass, class ICollection>
class CEnumObjects;

//=--------------------------------------------------------------------------=
//
// class CSnapInCollection
//
// This is a template class that implements all the collections in the
// designer runtime.
//
// Template Arguments:
//
// class IObject - this is the interface of the object that is contained in
//                 the collection (e.g. IMMCColumnHeader). Every object interface
//                 must have Index and Key properties.
//
// class CoClass - this is the coclass of the object contained in the collection
//                 (e.g. MMCColumnHeader)
//
// class ICollection - this is the interface of the collection class e.g.
//                     IMMCColumnHeaders
//
// Every object in a collection has a key and an index. The index is simply
// its one-based ordinal position in the colleciton. They key is a string that
// uniquely identifies an object in the collection.
//
// There are two types of collections: master and keys-only.
// A master collection is a 'normal' collection. It contains interface pointers
// to the objects in the collection.
//
// A keys-only collection holds interfaces pointers like a master collection
// when it is new. When it is saved in a project, it serializes only
// the objects' keys and the count of objects.
// Keys-only collections are used in the design-time
// definition objects to deal with the situation where a result view is
// used by multiple nodes and it also appears in the general result views
// section at the bottom of the designer treeview.
// When a keys-only collection is loaded, it creates new objects but only
// sets their Key property. When a caller attempts to
// get an object from a keys-only collection that was read from serialization,
// the collection is updated to hold all of the interface pointers just like
// the master collection.
//
// Collections support notifications to an object model host using
// IObjectModelHost (defined in mssnapr.idl). Notifications are sent for
// updates, adds, and deletes.
//
// When an object is added or removed, the collection calls
// IObjectMode::Increment/DecrementUsageCount. The usage count, (separate from
// the object's reference count) indicates membership in a collection. The
// design time uses this to determine if a result view is in use by checking
// how may collections it belongs to. If it only belongs to one, (i.e. it is
// not used by any nodes), then it can be deleted by the user.
//
// Collections can also be marked read-only to prevent Add/Remove/Clear from
// working.
//
// The class uses a stolen verion of MFC's CArray template class to hold
// the interface pointer.
//=--------------------------------------------------------------------------=

template <class IObject, class CoClass, class ICollection>
class CSnapInCollection : public CSnapInAutomationObject,
                          public ICollection
{
    protected:
        CSnapInCollection(IUnknown     *punkOuter,
                          int           nObjectType,
                          void         *piMainInterface,
                          void         *pThis,
                          REFCLSID      clsidObject,
                          UINT          idObject,
                          REFIID        iidObject,
                          CPersistence *pPersistence);

        ~CSnapInCollection();

    public:

        // Standard collection methods exposed for all collections

        STDMETHOD(get_Count)(long *plCount);
        STDMETHOD(get_Item)(VARIANT Index, IObject **ppiObject);
        STDMETHOD(get_Item)(VARIANT Index, CoClass **ppObject);
        STDMETHOD(get__NewEnum)(IUnknown **ppunkEnum);
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, IObject **ppiNewObject);
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, CoClass **ppNewObject);

        // AddFromMaster adds an existing object from a master collection
        // to a keys-only collection. This is called at design time when
        // the user adds an existing result view to a node.
        
        STDMETHOD(AddFromMaster)(IObject *piMasterObject);

        // More standard collection methods
        
        STDMETHOD(Clear)();
        STDMETHOD(Remove)(VARIANT Index);

        // Swap allows exchanging the position of two elements in a collection
        // Used at design time to implement the moving of menus.
        
        STDMETHOD(Swap)(long lOldIndex, long lNewIndex);

        // Derived collection classes may use this method for adding
        // non-cocreatable objects

        HRESULT AddExisting(VARIANT Index, VARIANT Key, IObject *piObject);

        // Some handy helpers

        // Simple helper for getting directly to collection items by index
        // without AddRef(). NOTE: this is the zero based index.

        IObject *GetItemByIndex(long lIndex) { return m_IPArray.GetAt(lIndex); }

        // Look up an object by name (without using VARIANT index)

        HRESULT GetItemByName(BSTR bstrName, IObject **ppiObject);

        // Get the collection count

        long GetCount() { return m_IPArray.GetSize(); }

        // Set the read-only status of the collection

        void SetReadOnly(BOOL fReadOnly) { m_fReadOnly = fReadOnly; }

        // Get the read-only status of the collection

        BOOL ReadOnly() { return m_fReadOnly; }

    protected:

        // If the collection class supports persistence then it must call
        // this method in its Persist() method. Note that this class does
        // not derive from CPersistence and this method is *not* the override
        // of CPersistence::Persist().

        HRESULT Persist(IObject *piObject);

        // If the collection class is potentially keys-only then it must
        // specialize this method in order to supply an interface pointer
        // to the master collection.

#if defined(MASTER_COLLECTION)
        HRESULT GetMaster(ICollection **ppiCollection);
#endif

    // CSnapInAutomationObject overrides

        // This implementation will call CSnapInAutomationObject::SetObjectHost
        // for each collection member
        virtual HRESULT OnSetHost();

    private:

        void InitMemberVariables();
        HRESULT ReleaseAllItems();
        HRESULT AddToMaster(VARIANT Index, VARIANT Key, IObject **ppiNewObject);
        HRESULT RemoveFromMaster(VARIANT Index);
        HRESULT GetFromMaster(IObject *piKeyItem, IObject **ppiMasterItem);
        HRESULT SyncWithMaster();
        HRESULT CreateItem(IObject **ppiObject);
        HRESULT FindItem(VARIANT Index, long *plIndex, IObject **ppiObject);

        enum FindOptions { DontGenerateExceptionInfoOnError,
                           GenerateExceptionInfoOnError };
        
        HRESULT FindItemByKey(BSTR bstrKey, long *plIndex, FindOptions option,
                              IObject **ppiObject);
        HRESULT FindSlot(VARIANT  Index,
                         VARIANT  Key,
                         long    *plNewIndex,
                         BSTR    *pbstrKey,
                         IObject *piObject);
        HRESULT DecrementObjectUsageCount(IObject *piObject);
        HRESULT IncrementObjectUsageCount(IObject *piObject);
        HRESULT UpdateIndexes(long lStart);

        CArray<IObject *>    m_IPArray;           // holds interface pointers
                                                  // of objects in collection
        CLSID                m_clsidObject;       // CLSID of contained object
        UINT                 m_idObject;          // Framework ID of contained
                                                  // object from localobj.h
                                                  
        IID                  m_iidObject;         // IID of contained object
        CPersistence        *m_pPersistence;      // Used to implement save/load
        BOOL                 m_fSyncedWithMaster; // TRUE=keys-only collection
                                                  // has been synced up with
                                                  // master following
                                                  // deserialization
        BOOL                 m_fReadOnly;         // TRUE=Add/Remove/Clear not
                                                  // allowed
};




//=--------------------------------------------------------------------------=
// CSnapInCollection constructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IUnknown     *punkOuter       [in] outer IUnknown if aggregated
//   int           nObjectType     [in] collection object ID from localobj.h
//   void         *piMainInterface [in] collection object interface (e.g. IMMCButtons)
//   void         *pThis           [in] collection class' this pointer
//   REFCLSID      clsidObject     [in] contained object CLSID
//   UINT          idObject        [in] contained object ID from localobj.h
//   REFIID        iidObject       [in] contained object IID (e.g. IID_IMMCButton)
//   CPersistence *pPersistence    [in] collection's persistence object
//
// Output:
//   None
//
// Notes:
//
// Calls base class contstructor and stores parameters. Cannot fail.
//
template <class IObject, class CoClass, class ICollection>
CSnapInCollection<IObject, CoClass, ICollection>::CSnapInCollection
(
    IUnknown     *punkOuter,
    int           nObjectType,
    void         *piMainInterface,
    void         *pThis,
    REFCLSID      clsidObject,
    UINT          idObject,
    REFIID        iidObject,
    CPersistence *pPersistence
) : CSnapInAutomationObject(punkOuter,
                            nObjectType,
                            piMainInterface,
                            pThis,
                            0,    // no property pages
                            NULL, // no property pages
                            pPersistence)
{
    InitMemberVariables();
    m_clsidObject = clsidObject;
    m_idObject = idObject;
    m_iidObject = iidObject;
    m_pPersistence = pPersistence;
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::InitMemberVariables
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
//
// Initializes member variables
//
template <class IObject, class CoClass, class ICollection>
void CSnapInCollection<IObject, CoClass, ICollection>::InitMemberVariables()
{
    m_pPersistence = NULL;
    m_IPArray.SetSize(0);

    // m_fSyncedWithMaster is initialized to TRUE. When a keys-only collection
    // is deserialized then it will be set to FALSE so that the first Get will
    // do the synchronization.

    m_fSyncedWithMaster = TRUE;
    m_fReadOnly = FALSE;
}



//=--------------------------------------------------------------------------=
// CSnapInCollection destructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
//
// Revokes read-only status, releases all interface pointers, and initializes
// member variables
//
template <class IObject, class CoClass, class ICollection>
CSnapInCollection<IObject, CoClass, ICollection>::~CSnapInCollection()
{
    m_fReadOnly = FALSE;
    (void)Clear();
    InitMemberVariables();
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::get_Count
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long *plCount [out] - count of objects in collection returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Count method
// Asks CArray for current size
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get_Count(long *plCount)
{
    *plCount = m_IPArray.GetSize();
    return S_OK;
}



//=--------------------------------------------------------------------------=
// CSnapInCollection::get__NewEnum
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IUnknown **ppunkEnum [out] - IUnknown of object that implements
//                               IEnumVARIANT returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements For...Each in VB. To implement For...Each VB starts by asking
// the collection for its _NewEnum property. It will QI the returned IUnknown
// for IEnumVARIANT and then call IEnumVARIANT::Next to get each element
// of the collection.
//
// Creates an instance of the CEnumObjects class (defined below in this file)
// and returns its IUnknown.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get__NewEnum
(
    IUnknown **ppunkEnum
)
{
    HRESULT       hr = S_OK;
    CEnumObjects<IObject, CoClass, ICollection> *pEnumObjects = New CEnumObjects<IObject, CoClass, ICollection>(this);

    if (NULL == pEnumObjects)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILED(hr))
    {
        if (NULL != pEnumObjects)
        {
            delete pEnumObjects;
        }
        *ppunkEnum = NULL;
    }
    else
    {
        *ppunkEnum = static_cast<IUnknown *>(static_cast<IEnumVARIANT *>(pEnumObjects));
    }

    H_RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapInCollection::ReleaseAllItems
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   HRESULT
//
// Notes:
//
// Iterates through collection and does:
// 1) Removes object mode host from object so that it will release its back
//    pointer
// 2) Releases inteface pointer on object
// 3) Sets the interface pointer position in the CArray to NULL
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::ReleaseAllItems()
{
   HRESULT hr = S_OK;
   long    i = 0;
   long    cItems = m_IPArray.GetSize();
   IObject *piObject = NULL; 

   while (i < cItems)
   {
       piObject = m_IPArray.GetAt(i);
       if (NULL != piObject)
       {
           H_IfFailRet(RemoveObjectHost(piObject));
           piObject->Release();
           m_IPArray.SetAt(i, NULL);
       }
       i++;
   }
   return S_OK;
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::Clear
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Clear method.
// Calls ReleaseAllItems to release inteface pointers in CArray
// Truncates CArray to zero size
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Clear()
{
   HRESULT hr = S_OK;

   if (m_fReadOnly)
   {
       hr = SID_E_COLLECTION_READONLY;
       EXCEPTION_CHECK_GO(hr);
   }
   
   H_IfFailGo(ReleaseAllItems());
   H_IfFailGo(m_IPArray.SetSize(0));

Error:
   H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::AddToMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index for new object
//  VARIANT   Key          [in]  Key for new object
//  IObject **ppiNewObject [out] Newly added object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Adds a new object to a master collection. This method is called from
// CSnapInCollection::Add when the caller is adding an object to a keys-only
// collection. It calls the virtual function GetMaster which must be overriden
// by the derived collection class as only it know who its master collection is.
// For example, at design time, when the user adds a new list view under a node,
// the designer calls the ScopeItemDef.ViewDefs.ListViewDefs.Add. That collection
// is keys-only, so CSnapInCollection.Add calls this method. CListViewDefs
// (in lvdefs.cpp) overrides GetMaster and returns the master
// SnapInDesignerDef.ViewDefs.ListViewDefs.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::AddToMaster
(
    VARIANT   Index,
    VARIANT   Key,
    IObject **ppiNewObject
)
{
    HRESULT      hr = S_OK;
#if defined(MASTER_COLLECTION)
    ICollection *piMasterCollection = NULL;

    H_IfFailRet(GetMaster(&piMasterCollection));
    hr = piMasterCollection->Add(Index, Key, ppiNewObject);

    QUICK_RELEASE(piMasterCollection);
#endif
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::RemoveFromMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index or key of object to remove
//
// Output:
//   HRESULT
//
// Notes:
//
// Removes an object from a master collection. This method is called from
// CSnapInCollection::Add when the caller is adding an object to a keys-only
// collection and a failure occurs after adding the object. See 
// CSnapInCollection::AddToMaster above for more info
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::RemoveFromMaster(VARIANT Index)
{
    HRESULT      hr = S_OK;
#if defined(MASTER_COLLECTION)
    ICollection *piMasterCollection = NULL;

    H_IfFailGo(GetMaster(&piMasterCollection));
    hr = piMasterCollection->Remove(Index);

Error:
    QUICK_RELEASE(piMasterCollection);
#endif
    H_RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapInCollection::GetFromMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject  *piKeyItem     [in] object from keys-only collection
//  IObject **ppiMasterItem [out] corresponding object from master collection
//
// Output:
//   HRESULT
//
// Notes:
//
// When a keys-only collection receives a get_Item call it must sync up with
// the master collection and replace all of its key-only objects with interface
// pointers on the real objects. This function returns the corresponding object
// from the master collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::GetFromMaster
(
    IObject  *piKeyItem,
    IObject **ppiMasterItem
)
{
    HRESULT      hr = S_OK;
#if defined(MASTER_COLLECTION)
    ICollection *piMasterCollection = NULL;
    VARIANT      varKey;
    ::VariantInit(&varKey);

    // Call the collection's overriden GetMaster to get the master collection.

    H_IfFailGo(GetMaster(&piMasterCollection));
    H_IfFailGo(piKeyItem->get_Key(&varKey.bstrVal));
    varKey.vt = VT_BSTR;
    hr = piMasterCollection->get_Item(varKey, ppiMasterItem);

Error:
    QUICK_RELEASE(piMasterCollection);
    (void)::VariantClear(&varKey);
#endif
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Remove
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT Index     [in] Index or key of object to remove
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Remove method
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Remove(VARIANT Index)
{
    long     lIndex = 0;
    IObject *piObject = NULL;
    HRESULT  hr = S_OK;

    if (m_fReadOnly)
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Do a find to ensure the item is there and to AddRef() it.

    H_IfFailGo(FindItem(Index, &lIndex, &piObject));

    // Release the collection's reference on the object and remove it from the
    // array (we still have the ref from the find)

    m_IPArray.GetAt(lIndex)->Release();
    m_IPArray.SetAt(lIndex, NULL);
    m_IPArray.RemoveAt(lIndex);

    // If this is a real collection (not keys-only) then we need to decrement
    // the indexes of each item following the item that was added. This will
    // ensure that the index property of every item following the deleted item
    // correctly represents its position in the array.

    if (!KeysOnly())
    {
        H_IfFailGo(UpdateIndexes(lIndex));
    }

    // Notify the object host of the deletion

    H_IfFailGo(NotifyDelete(piObject));

    // Decrement the object's usage count as it is now leaving this
    // collection

    H_IfFailGo(DecrementObjectUsageCount(piObject));

    // Remove its object host reference

    H_IfFailGo(RemoveObjectHost(piObject));

    // The QUICK_RELEASE() macro below will release the reference from
    // the find.

Error:
    QUICK_RELEASE(piObject);
    H_RRETURN(hr);
}





//=--------------------------------------------------------------------------=
// CSnapInCollection::GetItemByName
//=--------------------------------------------------------------------------=
//
// Parameters:
//  BSTR      bstrName  [in] Key of object to retrieve
//  IObject **ppiObject [out] Object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Convenient shortcut for get_Item with a VARIANT containing a key. Relieves the
// caller from having to use the VARIANT. Function really should be called
// GetItemByKey.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::GetItemByName(BSTR bstrName, IObject **ppiObject)
{
    VARIANT varIndex;
    ::VariantInit(&varIndex);

    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = bstrName;
    H_RRETURN(get_Item(varIndex, ppiObject));
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::get_Item
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index     [in] Index or key of object to retrieve
//  IObject **ppiObject [out] Object interface pointer returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Item property for gets that return interface
// pointers. Called when VB code
// does:
//          Set SomeInterface = SomeCollection(SomeIndex)
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get_Item
(
    VARIANT   Index,
    IObject **ppiObject
)
{
    HRESULT hr = S_OK;
    long    lIndex = 0;

    if (NULL == ppiObject)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are not yet synced up with the master collection then
    // do it now.

    if ( KeysOnly() && (!m_fSyncedWithMaster) )
    {
        H_IfFailRet(SyncWithMaster());
    }

    H_IfFailRet(FindItem(Index, &lIndex, ppiObject));
Error:
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::get_Item
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index     [in] Index or key of object to retrieve
//  CoClass **ppObject [out] Object pointer returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Item property for gets that return coclasses
// Called when VB code
// does:
//          Set SomeObject = SomeCollection(SomeIndex)
//
// A CoClass pointer is just an inteface pointer to the default interface for the
// coclass. This function just uses the interface pointer version of get_Item
// (see above) and casts the returned pointer to a coclass pointer
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::get_Item
(
    VARIANT   Index,
    CoClass **ppObject
)
{
    H_RRETURN(get_Item(Index, reinterpret_cast<IObject **>(ppObject)));
}





//=--------------------------------------------------------------------------=
// CSnapInCollection::Add
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index for new object
//  VARIANT   Key          [in]  Key for new object
//  IObject **ppiNewObject [out] Newly added object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Add that returns interface pointer on new
// object.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Add
(
    VARIANT   Index,
    VARIANT   Key,
    IObject **ppiNewObject)
{
    HRESULT  hr = S_OK;
    BOOL     fAdded = FALSE;
    BOOL     fAddedToMaster = FALSE;
    long     lNewIndex = 0;
    BSTR     bstrKey = NULL;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    if (m_fReadOnly)
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Check that the requested index and key are valid and
    // convert them to a long and a BSTR

    H_IfFailGo(FindSlot(Index, Key, &lNewIndex, &bstrKey, (IObject *)NULL));

    if (KeysOnly())
    {
        // If there is a master collection then do the add there.
        // Don't pass an index as the master collection will append it.
        // The master collection will set *it's* index and the key in
        // the object. In this case the Index property will not match
        // the index in m_IPArray. This is only done for collections
        // used in the extensibility model at design time.

        H_IfFailGo(AddToMaster(varUnspecifiedIndex, Key, ppiNewObject));
        fAddedToMaster = TRUE;
    }
    else
    {
        // Create the new object and set its index and key

        H_IfFailGo(CreateItem(ppiNewObject));
        H_IfFailGo((*ppiNewObject)->put_Index(lNewIndex + 1L));
        H_IfFailGo((*ppiNewObject)->put_Key(bstrKey));
        H_IfFailGo(SetObjectHost(*ppiNewObject));
    }

    // Increment the object's usage count as it is now part of this
    // collection

    H_IfFailGo(IncrementObjectUsageCount(*ppiNewObject));

    H_IfFailGo(m_IPArray.InsertAt(lNewIndex, *ppiNewObject));
    fAdded = TRUE;


    // If this is a real collection (not keys-only) then we need to increment
    // the indexes of each item following the item that was added. In the
    // case of an insert this will ensure that the index property of every
    // item following the new item correctly represents its position in the
    // array. In the case of an append, this call will not do anything.
    
    if (!KeysOnly())
    {
        H_IfFailGo(UpdateIndexes(lNewIndex + 1L));
    }

    // In both cases notify the UI of the addition

    hr = NotifyAdd(m_IPArray.GetAt(lNewIndex));

Error:
    FREESTRING(bstrKey);
    if (SUCCEEDED(hr))
    {
        // The collection has one ref. Add a ref for return to caller. 
        (*ppiNewObject)->AddRef();
    }
    else
    {
        if (fAddedToMaster)
        {
            (void)RemoveFromMaster(Key);
        }
        if (fAdded)
        {
            (void)RemoveObjectHost(*ppiNewObject);
            m_IPArray.RemoveAt(lNewIndex);
        }
        QUICK_RELEASE(*ppiNewObject);
    }
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Add
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT   Index        [in]  Index for new object
//  VARIANT   Key          [in]  Key for new object
//  CoClass **ppNewObject  [out] Newly added object returned here
//
// Output:
//   HRESULT
//
// Notes:
//
// Implements standard Collection.Add that returns object pointer on new
// object.
//
// A CoClass pointer is just an inteface pointer to the default interface for the
// coclass. This function just uses the interface pointer version of Add
// (see above) and casts the returned pointer to a coclass pointer
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Add
(
    VARIANT   Index,
    VARIANT   Key,
    CoClass **ppNewObject
)
{
    H_RRETURN(Add(Index, Key, reinterpret_cast<IObject **>(ppNewObject)));
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::UpdateIndexes
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long lStart [in] First index to be updated
//
// Output:
//   HRESULT
//
// Notes:
//
// Increments the Index property of every object in the collection starting with
// the object whose current Index value is lStart
// object.
//
// This function is used when adding or removing objects from the collection
// so that the Index property always reflects the object's ordinal position
// in the collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::UpdateIndexes(long lStart)
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cItems = m_IPArray.GetSize();

    // Starting at the specified array index, update each object's
    // index property to its position in the array + 1 (as we are a one
    // based collection).

    for (i = lStart; i < cItems; i++)
    {
        H_IfFailGo(m_IPArray.GetAt(i)->put_Index(i + 1L));
    }

Error:    
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::AddExisting
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT  Index        [in] Index for new object
//  VARIANT  Key          [in] Key for new object
//  IObject *piNewObject  [in] Object to be added
//
// Output:
//   HRESULT
//
// Notes:
//
// Adds an existing object to the collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::AddExisting
(
    VARIANT  Index,
    VARIANT  Key,
    IObject  *piObject
)
{
    HRESULT  hr = S_OK;
    BOOL     fAdded = FALSE;
    long     lNewIndex = 0;
    BSTR     bstrKey = NULL;

    // Check that the requested index and key are valid and
    // convert them to a long and a BSTR

    H_IfFailGo(FindSlot(Index, Key, &lNewIndex, &bstrKey, (IObject *)NULL));

    H_IfFailGo(piObject->put_Index(lNewIndex + 1L));
    H_IfFailGo(piObject->put_Key(bstrKey));
    H_IfFailGo(SetObjectHost(piObject));
    H_IfFailGo(m_IPArray.InsertAt(lNewIndex, piObject));
    fAdded = TRUE;

    // Increment the object's usage count as it is now part of this
    // collection

    H_IfFailGo(IncrementObjectUsageCount(piObject));

    // If this is a real collection (not keys-only) then we need to increment
    // the indexes of each item following the item that was added. In the
    // case of an insert this will ensure that the index property of every
    // item following the new item correctly represents its position in the
    // array. In the case of an append, this call will not do anything.

    if (!KeysOnly())
    {
        H_IfFailGo(UpdateIndexes(lNewIndex + 1L));
    }

    // Notify the UI of the addition

    hr = NotifyAdd(m_IPArray.GetAt(lNewIndex));

    // Add a ref for the collection

    piObject->AddRef();

Error:
    FREESTRING(bstrKey);
    if (FAILED(hr))
    {
        if (fAdded)
        {
            (void)RemoveObjectHost(piObject);
            m_IPArray.RemoveAt(lNewIndex);
        }
    }
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::AddExisting
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject *piMasterObject  [in] Object to be added
//
// Output:
//   HRESULT
//
// Notes:
//
// Adds an existing object from a master collection
// to a keys-only collection. This is called at design time when
// the user adds an existing result view to a node.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::AddFromMaster
(
    IObject *piMasterObject
)
{
    HRESULT  hr = S_OK;
    BOOL     fAdded = FALSE;
    long     lNewIndex = 0;

    H_IfFailGo(m_IPArray.Add(piMasterObject, &lNewIndex));
    piMasterObject->AddRef();
    fAdded = TRUE;

    // Increment the object's usage count as it is now part of this
    // collection

    H_IfFailGo(IncrementObjectUsageCount(piMasterObject));

    // Notify the UI of the addition

    hr = NotifyAdd(m_IPArray.GetAt(lNewIndex));

Error:
    if (FAILED(hr) && fAdded)
    {
        m_IPArray.RemoveAt(lNewIndex);
    }
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Swap
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long lIndex1 [in] index of first object to swap
//  long lIndex2 [in] index of second object to swap
//
// Output:
//   HRESULT
//
// Notes:
//
// Echanges the positions of two objects in the collection and updates their
// Index properties to reflect the new positions. Used at design time when
// a user moves a menu.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CSnapInCollection<IObject, CoClass, ICollection>::Swap
(
    long lIndex1,
    long lIndex2
)
{
    HRESULT  hr = S_OK;
    IObject *piObject1 = NULL; // Not AddRef()ed
    IObject *piObject2 = NULL; // Not AddRef()ed
    long     cItems = m_IPArray.GetSize();

    // Check index validity (1 based).
    // Old index must be somewhere in the collection. New index must be either
    // in the collection or 1 past the end (i.e append to end).

    if ( (lIndex1 < 1L) || (lIndex1 > cItems) ||
         (lIndex2 < 1L) || (lIndex2 > cItems)
       )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get object pointers and switch 'em

    piObject1 = m_IPArray.GetAt(lIndex1 - 1L);
    piObject2 = m_IPArray.GetAt(lIndex2 - 1L);
    m_IPArray.SetAt(lIndex1 - 1L, piObject2);
    m_IPArray.SetAt(lIndex2 - 1L, piObject1);

    // Update both objects' index properties
    
    H_IfFailGo(piObject1->put_Index(lIndex2));
    H_IfFailGo(piObject2->put_Index(lIndex1));

Error:
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::Persist
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject *piObject [in] a NULL interface pointer on the contained object
//                         Only used internally within the function. Does not
//                         affect the caller.
//
// Output:
//   HRESULT
//
// Notes:
// If the collection class supports persistence then it must call
// this method in its Persist() functon override. Note that this class does
// not derive from CPersistence and this method is *not* the override
// of CPersistence::Persist(). Collections that support persistence must pass
// their CPersistence pointer to the CSnapInCollection constructor.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::Persist(IObject *piObject)
{
    HRESULT  hr = S_OK;
    long     cItems = m_IPArray.GetSize();
    long     iItem = 0;
    long     lNewIndex = 0;
    IObject *piNewObject = NULL;
    BOOL     fKeysOnly = FALSE;
    BSTR     bstrKey = NULL;
    
    OLECHAR  wszPropBagItem[32];
    ::ZeroMemory(wszPropBagItem, sizeof(wszPropBagItem));

    VARIANT varIndex;
    ::VariantInit(&varIndex);
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    // Always persist count and KeysOnly. Need to persist KeysOnly even for
    // an empty collection because it is only set during InitNew. If we didn't
    // serialize it then when the project is next loaded it will revert to
    // its default value because InitNew will not be called.

    H_IfFalseGo(NULL != m_pPersistence, S_OK);
    H_IfFailGo(m_pPersistence->PersistSimpleType(&cItems, 0L, OLESTR("Count")));

    if (m_pPersistence->Saving())
    {
        fKeysOnly = KeysOnly();
    }

    H_IfFailGo(m_pPersistence->PersistSimpleType(&fKeysOnly, FALSE, OLESTR("KeysOnly")));

    if (m_pPersistence->Loading())
    {
        SetKeysOnly(fKeysOnly);
    }

    // If the collection is empty then we're done.
    
    H_IfFalseGo(0 != cItems, S_OK);

    // Set up prefix of prop bag item name. For each item we will append
    // its index (Item0, Item1, etc.) and use this as the property name
    // for they item's key in a keys only collection.

    ::wcscpy(wszPropBagItem, L"Item");

    if (m_pPersistence->Saving())
    {
        while(varIndex.lVal <= cItems)
        {
            H_IfFailGo(get_Item(varIndex, &piObject));
            ::_ltow(varIndex.lVal, &wszPropBagItem[4], 10); // Creates string "Item<n>"
            if (fKeysOnly)
            {
                H_IfFailGo(piObject->get_Key(&bstrKey));
                H_IfFailGo(m_pPersistence->PersistBstr(&bstrKey, L"", wszPropBagItem));
            }
            else
            {
                H_IfFailGo(m_pPersistence->PersistObject(&piObject,
                                                         m_clsidObject,
                                                         m_idObject,
                                                         m_iidObject,
                                                         wszPropBagItem));
            }
            FREESTRING(bstrKey);
            RELEASE(piObject);
            varIndex.lVal++;
        }
    }

    else if (m_pPersistence->Loading())
    {
        // Need to clean out collection before we load it

        H_IfFailGo(ReleaseAllItems());

        // Set array size up front to avoid multiple reallocations

        H_IfFailGo(m_IPArray.SetSize(cItems));

        if (fKeysOnly)
        {
            m_fSyncedWithMaster = FALSE; // sync with master on 1st Get
        }
        else
        {
            m_fSyncedWithMaster = TRUE; // we are the master, no sync
        }

        while(varIndex.lVal <= cItems)
        {
            ::_ltow(varIndex.lVal, &wszPropBagItem[4], 10); // Creates string "Item<n>"
            if (fKeysOnly)
            {
                // Create a new object and set only its key. When
                // the first get_Item occurs we will sync with the
                // master using this key.
                H_IfFailGo(CreateItem(&piNewObject));
                H_IfFailGo(m_pPersistence->PersistBstr(&bstrKey, L"", wszPropBagItem));
                H_IfFailGo(piNewObject->put_Key(bstrKey));
                FREESTRING(bstrKey);
            }
            else
            {
                H_IfFailGo(m_pPersistence->PersistObject(&piNewObject,
                                                         m_clsidObject,
                                                         m_idObject,
                                                         m_iidObject,
                                                         wszPropBagItem));
            }

            // Increment the object's usage count as it is now part of this
            // collection

            H_IfFailGo(IncrementObjectUsageCount(piNewObject));
            
            m_IPArray.SetAt(varIndex.lVal - 1L, piNewObject);

            piNewObject = NULL; // don't release because collection owns it
            varIndex.lVal++;
        }
    }

Error:
    FREESTRING(bstrKey);
    QUICK_RELEASE(piNewObject);
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::CreateItem
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IObject **ppiObject [out] interface pointer on newly created object
//
// Output:
//   HRESULT
//
// Notes:
//
// Used when adding a new object to the collection or when deserializing a
// collection. Creates the object, calls IPersistStreamInit::InitNew, and returns
// the object
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::CreateItem(IObject **ppiObject)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;

    *ppiObject = NULL;

    // Create the object and get its native interface (CreateObject function
    // is in rtutil.cpp).

    H_IfFailGo(CreateObject(m_idObject, m_iidObject, ppiObject));

    // If the object supports persistence then call InitNew

    hr = (*ppiObject)->QueryInterface(IID_IPersistStreamInit,
                               reinterpret_cast<void **>(&piPersistStreamInit));
    if (FAILED(hr))
    {
        if (E_NOINTERFACE == hr)
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = piPersistStreamInit->InitNew();
    }

Error:
    if (FAILED(hr))
    {
        RELEASE(*ppiObject);
    }
    QUICK_RELEASE(piPersistStreamInit);
    H_RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// FindItem
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT  Index      [in]  Index or key of object
//  long    *plIndex    [out] Index of object returned here (if found)
//  IObject **ppiObject [out] Interface pointer on object returned here (if found)
//
// Output:
//      HRESULT 
//
// Notes:
//
// Finds an object in the collection referenced by index or key.
// Index is interpreted as a one-based array index.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::FindItem
(
    VARIANT   Index,
    long     *plIndex,
    IObject **ppiObject
)
{
    HRESULT  hr = S_OK;
    long     lIndex = 0;
    BSTR     bstrKey = NULL; // Do not free with SysFreeString()

    VARIANT varLong;
    ::VariantInit(&varLong);

    // First check if Index contains a string. If it does then do
    // a key lookup otherwise attempt to convert to a long.

    if (::IsString(Index, &bstrKey))
    {
        H_IfFailGo(FindItemByKey(Index.bstrVal, plIndex,
                                 GenerateExceptionInfoOnError, ppiObject));
    }
    else if (S_OK == ::ConvertToLong(Index, &lIndex))
    {
        // Adjust to zero based and use it to directly index the array
        lIndex--;

        if ( (lIndex < 0) || (lIndex >= m_IPArray.GetSize()) )
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            EXCEPTION_CHECK_GO(hr);
        }
        *ppiObject = m_IPArray.GetAt(lIndex);
        (*ppiObject)->AddRef();
        *plIndex = lIndex;
    }
    else
    {
        // Anything else is unusable.
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// FindItemByKey
//=--------------------------------------------------------------------------=
//
// Parameters:
//  BSTR          bstrKey   [in]  Key of object
//  long         *plIndex   [out] Index returned here if object found
//  FindOptions   option    [in]  DontGenerateExceptionInfoOnError or
//                                GenerateExceptionInfoOnError. Don't option
//                                is used when testing for presence of item
//                                in collection.
//  IObject     **ppiObject [out] Interface pointer on object returned here (if found)
//
// Output:
//      HRESULT
//
// Notes:
//
// Determines the array index of an existing item by doing a linear search for
// an item that has the same key.
//
// CONSIDER: simple linear search is used because snap-in collections tend to be
// small. If performance every becomes an issue this should probably changed to
// use hash buckets.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::FindItemByKey
(
    BSTR          bstrKey,
    long         *plIndex,
    FindOptions   option,
    IObject     **ppiObject
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrItemKey = NULL;
    BOOL     fFound = FALSE;
    IObject *piObject = NULL;
    long     i = 0;
    long     cItems = m_IPArray.GetSize();

    if (NULL != bstrKey)
    {
        while ( (i < cItems) && (!fFound) )
        {
            piObject = m_IPArray.GetAt(i);
            H_IfFailGo(piObject->get_Key(&bstrItemKey));
            if (NULL != bstrItemKey)
            {
                if (::_wcsicmp(bstrKey, bstrItemKey) == 0)
                {
                    piObject->AddRef();
                    *ppiObject = piObject;
                    *plIndex = i;
                    fFound = TRUE;
                }
            }
            FREESTRING(bstrItemKey);
            i++;
        }
    }

    if (!fFound)
    {
        hr = SID_E_ELEMENT_NOT_FOUND;
        if (GenerateExceptionInfoOnError == option)
        {
            EXCEPTION_CHECK(hr);
        }
    }

Error:
    H_RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapInCollection::FindSlot
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  Index      [in]  Index specified in Add method (one based)
//      VARIANT  Key        [in]  Key specified in Add method
//      long    *plNewIndex [out] Index of new item in array (zero based)
//      BSTR    *pbstrKey   [out] Key of new item
//      IObject *piObject   [in]  Bogus pointer for template arg
//
// Output:
//      HRESULT
//
// Notes:
//
// Determines the array index and key of a new item being added to the
// collection.
//
// If Index is unspecified then the new index will be at the end of the
// collection.
// If Index is specified then:
// If Index is an object then it is an invalid argument.
// If Index cannot be converted to an integer then it is an invalid argument.
// If Index is not within the current bounds of the array then it is invalid.
// If Index is within bounds then then the operation is treated as an insert
// and Index.lVal will be returned in *plNewIndex.
// 
// If Key is unspecified then it will be set to a NULL BSTR.
// If Key is specified then:
// If Key is an object then it is an invalid argument.
// If Key cannot be converted to a string then it is invalid.
// If Key already exists in the collection then it is invalid.
//

template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::FindSlot
(
    VARIANT  Index,
    VARIANT  Key,
    long    *plNewIndex,
    BSTR    *pbstrKey,
    IObject *piObject
)
{
    HRESULT   hr = S_OK;
    long      lIndex = 0;
    long      cItems = m_IPArray.GetSize();
    VARIANT   varKey;

    ::VariantInit(&varKey);

    // Attempt to convert key to string

    if (ISPRESENT(Key))
    {
        hr = ::VariantChangeType(&varKey, &Key, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        if (SUCCEEDED(FindItemByKey(varKey.bstrVal, &lIndex,
                                    DontGenerateExceptionInfoOnError,
                                    &piObject)))
        {
            piObject->Release();
            hr = SID_E_KEY_NOT_UNIQUE;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Process Index as described above

    if (!ISPRESENT(Index))
    {
        lIndex = cItems; // append to end
    }
    else
    {
        if (S_OK != ConvertToLong(Index, &lIndex))
        {
            hr = SID_E_INVALIDARG;
            goto Error;
        }

        lIndex--; // convert from 1-based to 0-based for our internal array

        if (0 == cItems)
        {
            if (lIndex != 0)
            {
                hr = SID_E_INDEX_OUT_OF_RANGE;
                goto Error;
            }
        }
        else if ( (lIndex < 0) || (lIndex > cItems) )
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            goto Error;
        }
        EXCEPTION_CHECK_GO(hr);
    }

    // If no key was specified then return NULL bstr for key

    if (!ISPRESENT(Key))
    {
        varKey.vt = VT_BSTR;
        varKey.bstrVal = NULL;
    }

Error:
    if (FAILED(hr))
    {
        ::VariantClear(&varKey);
    }
    else
    {
        *plNewIndex = lIndex;
        *pbstrKey = varKey.bstrVal;
    }
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapInCollection::SyncWithMaster
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//      HRESULT
//
// Notes:
// Used in a keys-only collection when caller does its first get_Item. Replaces
// all of the key-only objects in the collection with the corresponding object
// from the master collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::SyncWithMaster()
{
    HRESULT   hr = S_OK;
#if defined(MASTER_COLLECTION)
    IObject  *piMasterItem = NULL;
    long      cItems = m_IPArray.GetSize();
    long      i = 0;

    while(i < cItems)
    {
        // Get the item from the master collection. This will come back
        // AddRef()ed
        
        H_IfFailGo(GetFromMaster(m_IPArray.GetAt(i), &piMasterItem));

        // Release the item in our collection. No need to dec its usage count
        // as it will be destroyed at this point.
        
        H_IfFailRet(RemoveObjectHost(m_IPArray.GetAt(i)));
        m_IPArray.GetAt(i)->Release();

        // Put the master item in its place.
        
        m_IPArray.SetAt(i, piMasterItem);

        // Increment the master item's usage count as it is now part of this
        // collection as wekk

        H_IfFailGo(IncrementObjectUsageCount(piMasterItem));

        piMasterItem = NULL;
        i++;
    }

    m_fSyncedWithMaster = TRUE;

Error:
    QUICK_RELEASE(piMasterItem);
#endif
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::DecrementObjectUsageCount
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IObject *piObject [in] Object for which usage count should be decremented
//
// Output:
//      HRESULT
//
// Notes:
// 
// Calls IObjectModel->DecrementUsageCount on the object. Usage count indicates
// membership in a collection and is used by the design time to keep track
// of result views used by multiple nodes.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::DecrementObjectUsageCount
(
    IObject *piObject
)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    H_IfFailGo(piObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));
    H_IfFailGo(piObjectModel->DecrementUsageCount());

Error:
    QUICK_RELEASE(piObjectModel);
    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapInCollection::IncrementObjectUsageCount
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IObject *piObject [in] Object for which usage count should be incremented
//
// Output:
//      HRESULT
//
// Notes:
// 
// Calls IObjectModel->IncrementUsageCount on the object. Usage count indicates
// membership in a collection and is used by the design time to keep track
// of result views used by multiple nodes.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::IncrementObjectUsageCount
(
    IObject *piObject
)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    H_IfFailGo(piObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));
    H_IfFailGo(piObjectModel->IncrementUsageCount());

Error:
    QUICK_RELEASE(piObjectModel);
    H_RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapInCollection::OnSetHost                      [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//      HRESULT
//
// Notes:
// 
// When a caller calls IObjectModel::SetHost, the CSnapInAutomationObject
// implementation of that method calls the virtual function OnSetHost.
// This class overrides it and calls IObjectModel::SetHost on every object
// in the collection.
//
template <class IObject, class CoClass, class ICollection>
HRESULT CSnapInCollection<IObject, CoClass, ICollection>::OnSetHost()
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cItems = m_IPArray.GetSize();

    while (i < cItems)
    {
        H_IfFailRet(SetObjectHost(m_IPArray.GetAt(i)));
        i++;
    }
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                        Class CEnumObjects
//
// This class implements IEnumVARIANT for all collections. IEnumVARIANT is
// used when VB code does For...Each on a collection. (See
// CSnapInCollection::get__NewEnum above).
//
// The class maintains a back pointer to the CSnapInCollection class and
// enumerates it based on a simple current index member variable. If the
// collection changes during the enumeration then the For...Each will not
// work correctly.
//
// This class could not be derived from the framework's CUnknown object because
// compiler won't allow passing this pointer to base member constructor
// (CUnknown's ctor) from a  template class' ctor.
// This error occurrs even if warning 4355 is disabled.
//=--------------------------------------------------------------------------=


template <class IObject, class CoClass, class ICollection>
class CEnumObjects : public CtlNewDelete,
                     public IEnumVARIANT,
                     public ISupportErrorInfo
  
{
       public:
           CEnumObjects(CSnapInCollection<IObject, CoClass, ICollection> *pCollection);
           ~CEnumObjects();

       private:

        // IUnknown
           STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
           STDMETHOD_(ULONG, AddRef)(void);
           STDMETHOD_(ULONG, Release)(void);

        // ISupportErrorInfo
           STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

        // IEnumVARIANT
           STDMETHOD(Next)(unsigned long   celt,
                           VARIANT        *rgvar,
                           unsigned long  *pceltFetched);        
           STDMETHOD(Skip)(unsigned long celt);        
           STDMETHOD(Reset)();        
           STDMETHOD(Clone)(IEnumVARIANT **ppenum);

           void InitMemberVariables();

           long  m_iCurrent;    // Current element for Next method
           ULONG m_cRefs;       // ref count on this object

           // Back pointer to collection class

           CSnapInCollection<IObject, CoClass, ICollection> *m_pCollection;
};


//=--------------------------------------------------------------------------=
// CEnumObjects constructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//   CSnapInCollection<IObject, CoClass, ICollection> *pCollection
//
//   [in] pointer to owning collection class. Will be stored and used while enumerator
//   is alive. The enumerator does not AddRef the collection.
//
// Output:
//   None
//
// Notes:
//
// Sets enumerator ref count to 1
//
template <class IObject, class CoClass, class ICollection>
CEnumObjects<IObject, CoClass, ICollection>::CEnumObjects
(
    CSnapInCollection<IObject, CoClass, ICollection> *pCollection
)
{
    InitMemberVariables();
    m_pCollection = pCollection;
    m_cRefs = 1;
}



//=--------------------------------------------------------------------------=
// CEnumObjects destructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//
// Output:
//   None
//
// Notes:
//
template <class IObject, class CoClass, class ICollection>
CEnumObjects<IObject, CoClass, ICollection>::~CEnumObjects()
{
    InitMemberVariables();
}


//=--------------------------------------------------------------------------=
// CEnumObjects::InitMemberVariables
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//
// Output:
//   None
//
// Notes:
//
template <class IObject, class CoClass, class ICollection>
void CEnumObjects<IObject, CoClass, ICollection>::InitMemberVariables()
{
    m_iCurrent = 0;
    m_cRefs = 0;
    m_pCollection = NULL;
}

//=--------------------------------------------------------------------------=
//                        IUnknown Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CEnumObjects::QueryInterface                                    [IUnknnown]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  REFIID   riid       [in]  IID of interface requested
//  void   **ppvObjOut  [out] interface pointer returned here
//
// Output:
//   None
//
// Notes:
// Interfaces supported:
//      IID_IUnknown
//      IID_IEnumVARIANT
//      IID_ISupportErrorInfo
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::QueryInterface
(
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr = S_OK;

    if (DO_GUIDS_MATCH(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObjOut = static_cast<IUnknown *>(static_cast<IEnumVARIANT *>(this));
    }
    else if (DO_GUIDS_MATCH(riid, IID_IEnumVARIANT))
    {
        AddRef();
        *ppvObjOut = static_cast<IEnumVARIANT *>(this);
    }
    else if (DO_GUIDS_MATCH(riid, IID_ISupportErrorInfo))
    {
        AddRef();
        *ppvObjOut = static_cast<ISupportErrorInfo *>(this);
    }
    else
    {
        *ppvObjOut = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::AddRef                                            [IUnknnown]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP_(ULONG) CEnumObjects<IObject, CoClass, ICollection>::AddRef()
{
    m_cRefs++;
    return m_cRefs;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Release                                           [IUnknnown]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
//  Deletes object when ref count reaches zero
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP_(ULONG) CEnumObjects<IObject, CoClass, ICollection>::Release()
{
    if (m_cRefs > 0)
    {
        m_cRefs--;
        if (0 == m_cRefs)
        {
            delete this;
            return 0;
        }
        else
        {
            return m_cRefs;
        }
    }
    else
    {
        H_ASSERT(FALSE, "CEnumObjects::Release() past zero refs");
        return m_cRefs;
    }
}

//=--------------------------------------------------------------------------=
//                      ISupportErrorInfo Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CEnumObjects::InterfaceSupportsErrorInfo                 [ISupportErrorInfo]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  REFIID riid [in] Caller requests to know if this inteface supports rich
//                   error info
//
// Output:
//   None
//
// Notes:
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    return (riid == IID_IEnumVARIANT) ? S_OK : S_FALSE;
}


//=--------------------------------------------------------------------------=
//                        IEnumVARIANT Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CEnumObjects::Next                                           [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long   celt         [in] number of elements to fetch
//  VARIANT        *rgvar        [in, out] array in which to place elements
//  unsigned long  *pceltFetched [out] no. of elements placed in rgvar returned here
//
// Output:
//   None
//
// Notes:
// Returns the next celt IDispatch pointers of objects in the collection
// starting at the current position. Current position starts at 0 and continues
// until end of collection. Current position can be returned to zero by calling
// Reset (see below)
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Next
(
    unsigned long   celt,
    VARIANT        *rgvar,
    unsigned long  *pceltFetched
)
{
    HRESULT       hr = S_OK;
    unsigned long i = 0;
    
    // Initialize result array.

    for (i = 0; i < celt; i++)
    {
        ::VariantInit(&rgvar[i]);
    }

    // Copy in IDispatch pointers

    for (i = 0; i < celt; i++) 
    {
        H_IfFalseGo(m_iCurrent < m_pCollection->GetCount(), S_FALSE);

        H_IfFailGo(m_pCollection->GetItemByIndex(m_iCurrent)->QueryInterface(
                                 IID_IDispatch,
                                reinterpret_cast<void **>(&rgvar[i].pdispVal)));

        rgvar[i].vt = VT_DISPATCH;
        m_iCurrent++;
    }

Error:

    if (FAILED(hr))
    {
        for (i = 0; i < celt; i++)
        {
            (void)::VariantClear(&rgvar[i]);
        }
    }

    if (pceltFetched != NULL)
    {
        if (FAILED(hr))
        {
            *pceltFetched = 0;
        }
        else
        {
            *pceltFetched = i;
        }
    }

    H_RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Skip                                           [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  unsigned long   celt         [in] number of elements to skip
//
// Output:
//   None
//
// Notes:
// Advances the current position to be used in a Next method call by celt. If
// overflows past end of collection, wraps around to the start.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Skip
(
    unsigned long celt
)
{
    m_iCurrent += celt;
    m_iCurrent %= m_pCollection->GetCount();
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Reset                                          [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//   None
//
// Notes:
// Resets the current position to be used in a Next method call to zero.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Reset()
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CEnumObjects::Clone                                          [IEnumVARIANT]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IEnumVARIANT **ppenum [out] newly cloned enumerator
//
// Output:
//   None
//
// Notes:
// Creates a new CEnumObjects and passes it the same collection. Sets the
// new CEnumObjects' current position to the same as this one's.
//
template <class IObject, class CoClass, class ICollection>
STDMETHODIMP CEnumObjects<IObject, CoClass, ICollection>::Clone(IEnumVARIANT **ppenum)
{
    HRESULT hr = S_OK;

    CEnumObjects<IObject, CoClass, ICollection> *pClone =
                           New CEnumObjects<IObject, CoClass, ICollection>(m_pCollection);

    if (NULL == pClone)
    {
        *ppenum = NULL;
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    pClone->m_iCurrent = m_iCurrent;
    *ppenum = static_cast<IEnumVARIANT *>(pClone);

Error:
    H_RRETURN(hr);
}

#endif // _SNAPINCOLLECTION_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\common.h ===
//=--------------------------------------------------------------------------------------
// common.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Common header files for mssnapr that cannot go into the pch because they
// have symbols that are defined differently in different source files (e.g.
// INITGUIDS and INITOBJECTS.
//=-------------------------------------------------------------------------------------=

#include <ad98.h>
#include <autoobj.h>
#include "errors.h"
#include "error.h"
#include "persobj.h"
#include "siautobj.h"
#include "rtutil.h"
#include "..\..\mssnapd\mssnapd\guids.h" // for design time property page CLSIDs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\colsets.h ===
//=--------------------------------------------------------------------------=
// colsets.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSettings class definition - ColumnSettings collection implementation
//
//=--------------------------------------------------------------------------=

#ifndef _COLUMNSETTINGS_DEFINED_
#define _COLUMNSETTINGS_DEFINED_

#include "collect.h"
#include "view.h"

class CColumnSettings : public CSnapInCollection<IColumnSetting, ColumnSetting, IColumnSettings>
{
    protected:
        CColumnSettings(IUnknown *punkOuter);
        ~CColumnSettings();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IColumnSettings
        BSTR_PROPERTY_RW(CColumnSettings, ColumnSetID, DISPID_COLUMNSETTINGS_COLUMN_SET_ID);
        STDMETHOD(Add)(VARIANT           Index,
                       VARIANT           Key, 
                       VARIANT           Width,
                       VARIANT           Hidden,
                       VARIANT           Position,
                       ColumnSetting **ppColumnSetting);
        STDMETHOD(Persist)();

    // Public utility methods

    public:

        void SetView(CView *pView) { m_pView = pView; }
        CView *GetView() { return m_pView; }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CView *m_pView; // back pointer to owning view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ColumnSettings,           // name
                                &CLSID_ColumnSettings,    // clsid
                                "ColumnSettings",         // objname
                                "ColumnSettings",         // lblname
                                &CColumnSettings::Create, // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IColumnSettings,     // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _COLUMNSETTINGS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converbs.h ===
//=--------------------------------------------------------------------------=
// converbs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerbs class definition - implements MMCConsoleVerbs collection
//
//=--------------------------------------------------------------------------=

#ifndef _CONVERBS_DEFINED_
#define _CONVERBS_DEFINED_

#include "collect.h"
#include "view.h"

class CView;

class CMMCConsoleVerbs : public CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>
{
    protected:
        CMMCConsoleVerbs(IUnknown *punkOuter);
        ~CMMCConsoleVerbs();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCConsoleVerbs
        STDMETHOD(get_Item)(VARIANT Index, MMCConsoleVerb **ppMMCConsoleVerb);
        STDMETHOD(get_DefaultVerb)(SnapInConsoleVerbConstants *pVerb);

    // Public utility methods
    public:
        HRESULT SetView(CView *pView);
        CView *GetView() { return m_pView; };

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

        CView *m_pView; //owning view, needed for access to MMC's IConsoleVerb
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCConsoleVerbs,            // name
                                NULL,                       // clsid
                                NULL,                       // objname
                                NULL,                       // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCConsoleVerbs,      // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _CONVERBS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\converbs.cpp ===
//=--------------------------------------------------------------------------=
// converbs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCConsoleVerbs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "converbs.h"
#include "converb.h"

// for ASSERT and FAIL
//
SZTHISFILE



struct
{
    SnapInConsoleVerbConstants  Verb;
    WCHAR                      *pwszKey;

} static const g_Verbs[] =
{
    { siNone,       L"siNone"       },
    { siOpen,       L"siOpen"       },
    { siCopy,       L"siCopy"       },
    { siPaste,      L"siPaste"      },
    { siDelete,     L"siDelete"     },
    { siProperties, L"siProperties" },
    { siRename,     L"siRename"     },
    { siRefresh,    L"siRefresh"    },
    { siPrint,      L"siPrint"      },
    { siCut,        L"siCut"        }
};

static const size_t g_cVerbs = sizeof(g_Verbs) / sizeof(g_Verbs[0]);





#pragma warning(disable:4355)  // using 'this' in constructor

//=--------------------------------------------------------------------------=
// CMMCConsoleVerbs::CMMCConsoleVerbs
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IUnknown *punkOuter [in] controlling unknown
//
// Output:
//
// Notes:
//
// Constructor.
//
// Passes CLSID_NULL to the CSnapInCollection constructor because the
// contained object (MMCConsoleVerb) is not co-createable. CSnapInCollection
// only uses it for persistence and Add(). This collection does not use those
// features.
//

CMMCConsoleVerbs::CMMCConsoleVerbs(IUnknown *punkOuter) :
    CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>(punkOuter,
                                           OBJECT_TYPE_MMCCONSOLEVERBS,
                                           static_cast<IMMCConsoleVerbs *>(this),
                                           static_cast<CMMCConsoleVerbs *>(this),
                                           CLSID_NULL,
                                           OBJECT_TYPE_MMCCONSOLEVERB,
                                           IID_IMMCConsoleVerb,
                                           NULL) // no persistence
{
    m_pView = NULL;
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCConsoleVerbs::~CMMCConsoleVerbs()
{
    m_pView = NULL;
}

IUnknown *CMMCConsoleVerbs::Create(IUnknown * punkOuter)
{
    HRESULT           hr = S_OK;
    IUnknown         *punkMMCConsoleVerb = NULL;
    IMMCConsoleVerb  *piMMCConsoleVerb = NULL;
    CMMCConsoleVerbs *pMMCConsoleVerbs = New CMMCConsoleVerbs(punkOuter);
    size_t            i = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Was the MMCConsoleVerb collection object created?

    if (NULL == pMMCConsoleVerbs)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }


    // Add an item to the collection for each of the verbs.

    varIndex.vt = VT_I4;

    for (i = 0; i < g_cVerbs; i++)
    {
        punkMMCConsoleVerb = CMMCConsoleVerb::Create(NULL);
        if (NULL == punkMMCConsoleVerb)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(punkMMCConsoleVerb->QueryInterface(IID_IMMCConsoleVerb,
                                  reinterpret_cast<void **>(&piMMCConsoleVerb)));

        IfFailGo(piMMCConsoleVerb->put_Verb(g_Verbs[i].Verb));

        varIndex.lVal = static_cast<long>(i) + 1L; // 1 based collection

        // Use the text version of the enum for the key

        varKey.bstrVal = ::SysAllocString(g_Verbs[i].pwszKey);
        if (NULL == varKey.bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        varKey.vt = VT_BSTR;

        IfFailGo(pMMCConsoleVerbs->AddExisting(varIndex, varKey, piMMCConsoleVerb));

        RELEASE(punkMMCConsoleVerb);
        RELEASE(piMMCConsoleVerb);

        hr = ::VariantClear(&varKey);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }


Error:
    QUICK_RELEASE(punkMMCConsoleVerb);
    QUICK_RELEASE(piMMCConsoleVerb);
    (void)::VariantClear(&varKey);
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCConsoleVerbs)
        {
            delete pMMCConsoleVerbs;
        }
        return NULL;
    }
    else
    {
        return pMMCConsoleVerbs->PrivateUnknown();
    }
}


HRESULT CMMCConsoleVerbs::SetView(CView *pView)
{
    HRESULT          hr = S_OK;
    long             cVerbs = GetCount();
    long             i = 0;
    CMMCConsoleVerb *pMMCConsoleVerb = NULL;

    m_pView = pView;

    for (i = 0; i < cVerbs; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pMMCConsoleVerb));
        pMMCConsoleVerb->SetView(pView);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         IMMCConsoleVerbs Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCConsoleVerbs::get_Item
(
    VARIANT          Index,
    MMCConsoleVerb **ppMMCConsoleVerb
)
{
    HRESULT          hr = S_OK;
    size_t           i = 0;
    long             lIndex = 0;
    BOOL             fFound = FALSE;;
    IMMCConsoleVerb *piMMCConsoleVerb = NULL; // Not AddRef()ed

    // If the index can be converted to a long then check whether it contains a
    // SnapInConsoleVerbConstants enum.

    hr = ::ConvertToLong(Index, &lIndex);
    if (SUCCEEDED(hr))
    {
        for (i = 0, fFound = FALSE; (i < g_cVerbs) && (!fFound); i++)
        {
            if (g_Verbs[i].Verb == static_cast<SnapInConsoleVerbConstants>(lIndex))
            {
                // Found it. Return to caller.

                piMMCConsoleVerb = GetItemByIndex(i);
                piMMCConsoleVerb->AddRef();
                fFound = TRUE;
            }
        }
        IfFalseGo(!fFound, S_OK);
    }

    // Index is something else, this is a normal get_Item by ordinal index
    // or key

    hr = CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>::get_Item(Index, &piMMCConsoleVerb);
    EXCEPTION_CHECK_GO(hr);

Error:
    if (NULL != piMMCConsoleVerb)
    {
        *ppMMCConsoleVerb = reinterpret_cast<MMCConsoleVerb *>(piMMCConsoleVerb);
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCConsoleVerbs::get_DefaultVerb
(
    SnapInConsoleVerbConstants *pVerb
)
{
    HRESULT           hr = S_OK;
    MMC_CONSOLE_VERB  Verb = MMC_VERB_NONE;
    IConsoleVerb     *piConsoleVerb = NULL; // Not AddRef()ed
    

    IfFalseGo(NULL != m_pView, SID_E_DETACHED_OBJECT);
    piConsoleVerb = m_pView->GetIConsoleVerb();
    IfFalseGo(NULL != piConsoleVerb, SID_E_INTERNAL);

    hr = piConsoleVerb->GetDefaultVerb(&Verb);

    *pVerb = static_cast<SnapInConsoleVerbConstants>(Verb);

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCConsoleVerbs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCConsoleVerbs == riid)
    {
        *ppvObjOut = static_cast<IMMCConsoleVerbs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCConsoleVerb, MMCConsoleVerb, IMMCConsoleVerbs>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctlbar.cpp ===
//=--------------------------------------------------------------------------=
// ctlbar.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CControlbar class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ctlbar.h"
#include "toolbar.h"
#include "mbuttons.h"
#include "clipbord.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CControlbar::CControlbar(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                            OBJECT_TYPE_CONTROLBAR,
                                            static_cast<IMMCControlbar *>(this),
                                            static_cast<CControlbar *>(this),
                                            0,    // no property pages
                                            NULL, // no property pages
                                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CControlbar::Create(IUnknown *punkOuter)
{
    HRESULT      hr = S_OK;
    IUnknown    *punkToolbars = CMMCToolbars::Create(NULL);
    CControlbar *pControlbar = New CControlbar(punkOuter);

    if ( (NULL == pControlbar) || (NULL == punkToolbars) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkToolbars,
                                                   &pControlbar->m_pToolbars));
Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pControlbar)
        {
            delete pControlbar;
        }
        return NULL;
    }
    else
    {
        return pControlbar->PrivateUnknown();
    }
}

CControlbar::~CControlbar()
{
    long i = 0;

    RELEASE(m_piControlbar);
    if (NULL != m_pToolbars)
    {
        m_pToolbars->Release();
    }

    if (NULL != m_ppunkControls)
    {
        for (i = 0; i < m_cControls; i++)
        {
            if (NULL != m_ppunkControls[i])
            {
                m_ppunkControls[i]->Release();
            }
        }
        ::CtlFree(m_ppunkControls);
    }
    
    InitMemberVariables();
}

void CControlbar::InitMemberVariables()
{
    m_pToolbars = NULL;
    m_pSnapIn = NULL;
    m_pView = NULL;
    m_piControlbar = NULL;
    m_ppunkControls = NULL;
    m_cControls = 0;
}


HRESULT CControlbar::GetControlIndex(IMMCToolbar *piMMCToolbar, long *plIndex)
{
    HRESULT hr = SID_E_INVALIDARG;
    long    cToolbars = m_pToolbars->GetCount();
    long    i = 0;

    *plIndex = 0;

    for (i = 0; (i < cToolbars) && (S_OK != hr); i++)
    {
        if (m_pToolbars->GetItemByIndex(i) == piMMCToolbar)
        {
            *plIndex = i;
            hr = S_OK;
        }
    }

    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


HRESULT CControlbar::GetControl
(
    CSnapIn      *pSnapIn,
    IMMCToolbar  *piMMCToolbar,
    IUnknown    **ppunkControl
)
{
    HRESULT     hr = S_OK;
    CControlbar *pControlbar = pSnapIn->GetCurrentControlbar();
    long         lIndex = 0;

    *ppunkControl = NULL;

    if (NULL == pControlbar)
    {
        hr = SID_E_CONTROLBAR_NOT_AVAILABLE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }


    // UNDONE: in an extension that does both namespace and toolbars, can
    // there be confusion between an old current view and the extension?

    if (SUCCEEDED(pControlbar->GetControlIndex(piMMCToolbar, &lIndex)))
    {
        *ppunkControl = pControlbar->m_ppunkControls[lIndex];
        (*ppunkControl)->AddRef();
    }

Error:
    RRETURN(hr);
}


HRESULT CControlbar::GetToolbar
(
    CSnapIn      *pSnapIn,
    IMMCToolbar  *piMMCToolbar,
    IToolbar    **ppiToolbar
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkToolbar = NULL;

    IfFailGo(GetControl(pSnapIn, piMMCToolbar, &punkToolbar));

    IfFailGo(punkToolbar->QueryInterface(IID_IToolbar,
                                         reinterpret_cast<void **>(ppiToolbar)));
Error:
    QUICK_RELEASE(punkToolbar);
    RRETURN(hr);
}


HRESULT CControlbar::GetMenuButton
(
    CSnapIn      *pSnapIn,
    IMMCToolbar  *piMMCToolbar,
    IMenuButton **ppiMenuButton
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMenuButton = NULL;

    IfFailGo(GetControl(pSnapIn, piMMCToolbar, &punkMenuButton));

    IfFailGo(punkMenuButton->QueryInterface(IID_IMenuButton,
                                         reinterpret_cast<void **>(ppiMenuButton)));
Error:
    QUICK_RELEASE(punkMenuButton);
    RRETURN(hr);
}





HRESULT CControlbar::OnControlbarSelect
(
    IDataObject *piDataObject,
    BOOL         fSelectionInScopePane,
    BOOL         fSelected
)
{
    HRESULT          hr = S_OK;
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCDataObjects *piMMCDataObjects = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // If we have an owning View then fire Views_UpdateControlbar.
    
    if (NULL != m_pView)
    {
        // Fire Views_UpdateControlbar

        m_pSnapIn->GetViews()->FireUpdateControlbar(
                                           static_cast<IView *>(m_pView),
                                           piMMCClipboard,
                                           BOOL_TO_VARIANTBOOL(fSelected),
                                           static_cast<IMMCControlbar *>(this));
    }
    else
    {
        // No owning View. Fire ExtensionSnapIn_UpdateControlbar

        ASSERT(IsForeign(SelectionType), "IExtendControlbar::ControlbarNotify(MMCN_SELECT) in an extension received a selection belonging to itself.")

        IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));

        m_pSnapIn->GetExtensionSnapIn()->FireUpdateControlbar(
                                     BOOL_TO_VARIANTBOOL(fSelectionInScopePane),
                                     BOOL_TO_VARIANTBOOL(fSelected),
                                     piMMCDataObjects,
                                     static_cast<IMMCControlbar *>(this));
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCDataObjects);
    RRETURN(hr);
}



HRESULT CControlbar::OnButtonClick(IDataObject *piDataObject, int idButton)
{
    HRESULT           hr = S_OK;
    CMMCToolbar      *pMMCToolbar = NULL;
    CMMCButton       *pMMCButton = NULL;
    IMMCClipboard    *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Get the MMCToolbar and MMCButton objects for the button clicked.

    IfFailGo(CMMCToolbar::GetToolbarAndButton(idButton, &pMMCToolbar,
                                              &pMMCButton, m_pSnapIn));
    // Fire MMCToolbar_ButtonClick
    
    pMMCToolbar->FireButtonClick(piMMCClipboard,
                                 static_cast<IMMCButton *>(pMMCButton));

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(S_OK);
}




//=--------------------------------------------------------------------------=
// CControlbar::OnMenuButtonClick
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject     [in] from MMCN_MENU_BTNCLICK
//      MENUBUTTONDATA *pMENUBUTTONDATA  [in] from MMCN_MENU_BTNCLICK
//
// Output:
//
// Notes:
//
// This function handles the MMCN_MENU_BTNCLICK notification. It will not
// be invoked during a debug session. In that circumstance the proxy for
// IExtendControlbar::ControlbarNotify() will QI for IExtendControlbarRemote
// and call its MenuButtonClick() method.
//


HRESULT CControlbar::OnMenuButtonClick
(
    IDataObject    *piDataObject,
    MENUBUTTONDATA *pMENUBUTTONDATA
)
{
    HRESULT           hr = S_OK;
    CMMCToolbar      *pMMCToolbar = NULL;
    CMMCButton       *pMMCButton = NULL;
    CMMCButtonMenu   *pMMCButtonMenu = NULL;
    IMMCClipboard    *piMMCClipboard = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Fire MMCToolbar_ButtonDropDown

    IfFailGo(FireMenuButtonDropDown(pMENUBUTTONDATA->idCommand,
                                    piMMCClipboard, &pMMCButton));

    // At this point the VB event handler has run and the snap-in has had a
    // chance to configure all the items on the menu by setting properties
    // such as MMCButton.ButtonMenus(i).Enabled, adding/removing items, etc.
    // We now need to display a popup menu at the co-ordinates passed by MMC.

    IfFailGo(DisplayPopupMenu(pMMCButton,
                              pMENUBUTTONDATA->x,
                              pMENUBUTTONDATA->y,
                              &pMMCButtonMenu));

   // If the user cancelled the selection or the snap-in gave us an empty
   // menu button then we're done.

   IfFalseGo(NULL != pMMCButtonMenu, S_OK);

   // Fire MMCToolbar_ButtonMenuClick. The button can give us its owning toolbar.

   pMMCToolbar = pMMCButton->GetToolbar();

   pMMCToolbar->FireButtonMenuClick(piMMCClipboard,
                                    static_cast<IMMCButtonMenu *>(pMMCButtonMenu));

Error:
    QUICK_RELEASE(piMMCClipboard);
    RRETURN(hr);
}




HRESULT CControlbar::FireMenuButtonDropDown
(
    int              idCommand,
    IMMCClipboard   *piMMCClipboard,
    CMMCButton     **ppMMCButton
)
{
    HRESULT           hr = S_OK;
    CMMCToolbar      *pMMCToolbar = NULL;
    CMMCButton       *pMMCButton = NULL;
    CMMCButtonMenu   *pMMCButtonMenu = NULL;

    // MENUBUTTONDATA.idCommand contains a pointer to the CMMCButton that owns
    // the menu button.

    pMMCButton = reinterpret_cast<CMMCButton *>(idCommand);

    // The button can give us its owning toolbar

    pMMCToolbar = pMMCButton->GetToolbar();

    // Fire MMCToolbar_ButtonDropDown

    pMMCToolbar->FireButtonDropDown(piMMCClipboard,
                                    static_cast<IMMCButton *>(pMMCButton));

    *ppMMCButton = pMMCButton;

    RRETURN(hr);
}




HRESULT CControlbar::DisplayPopupMenu
(
    CMMCButton      *pMMCButton,
    int              x,
    int              y,
    CMMCButtonMenu **ppMMCButtonMenuClicked
)
{
    HRESULT           hr = S_OK;
    IMMCButtonMenus  *piMMCButtonMenus = NULL;
    CMMCButtonMenus  *pMMCButtonMenus = NULL;
    CMMCButtonMenu   *pMMCButtonMenu = NULL;
    long              cItems = 0;
    long              i = 0;
    long              cPopupMenuItems = 0;
    HMENU             hMenu = NULL;
    UINT              uiFlags = 0;
    HWND              hwndConsoleFrame = NULL;
    char             *pszText = NULL;

    *ppMMCButtonMenuClicked = NULL;

    // First create an empty Win32 menu
    hMenu = ::CreatePopupMenu();
    if (NULL == hMenu)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // Now iterate through each of the items and add them to the menu

    IfFailGo(pMMCButton->get_ButtonMenus(
                       reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus)));

    IfFailGo(piMMCButtonMenus->get_Count(&cItems));

    // If the collection is empty then don't do anything
    
    IfFalseGo(0 != cItems, S_OK);
    
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButtonMenus,
                                                   &pMMCButtonMenus));

    for (i = 0; i < cItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                             pMMCButtonMenus->GetItemByIndex(i),
                                             &pMMCButtonMenu));

        // If the button menu is not marked visible then don't add it to
        // the popup menu

        if (!pMMCButtonMenu->GetVisible())
        {
            continue;
        }

        // Get all of the button menu properties to set the menu item flags
        
        uiFlags = MF_STRING;

        if (pMMCButtonMenu->GetChecked())
        {
            uiFlags |= MF_CHECKED;
        }
        else
        {
            uiFlags |= MF_UNCHECKED;
        }

        if (pMMCButtonMenu->GetGrayed())
        {
            uiFlags |= MF_GRAYED;
        }

        if (pMMCButtonMenu->GetEnabled())
        {
            uiFlags |= MF_ENABLED;
        }
        else
        {
            uiFlags |= MF_DISABLED;
        }

        if (pMMCButtonMenu->GetMenuBreak())
        {
            uiFlags |= MF_MENUBREAK;
        }

        if (pMMCButtonMenu->GetMenuBarBreak())
        {
            uiFlags |= MF_MENUBARBREAK;
        }

        if (pMMCButtonMenu->GetSeparator())
        {
            uiFlags |= MF_SEPARATOR;
        }

        IfFailGo(::ANSIFromWideStr(pMMCButtonMenu->GetText(), &pszText));

        // Append the menu item

        if (!::AppendMenu(hMenu, uiFlags, static_cast<UINT>(i + 1L), pszText))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        cPopupMenuItems++;

        ::CtlFree(pszText);
        pszText = NULL;
    }

    // If there are no items in the popup menu then don't display one. This
    // could happen if the user marked all items as invisible.

    IfFalseGo(0 != cPopupMenuItems, S_OK);

    // Get the console's main frame hwnd as owner for the menu. If we are a
    // primary snap-in then we'll have a view.

    if (NULL != m_pView)
    {
        hr = m_pView->GetIConsole2()->GetMainWindow(&hwndConsoleFrame);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        // As an extension we have no access to IConsole2 so do the next best
        // thing: use the active window for this thread as the owner of the
        // popup menu.

        hwndConsoleFrame = ::GetActiveWindow();
    }

    // Display the popup and wait for the selection.

    i = (long)::TrackPopupMenu(
                  hMenu,            // menu to display
                  TPM_LEFTALIGN |   // align left side of menu with x
                  TPM_TOPALIGN  |   // align top of menu with y
                  TPM_NONOTIFY  |   // don't send any messages during selection
                  TPM_RETURNCMD |   // make the ret val the selected item
                  TPM_LEFTBUTTON,   // allow selection with left button only
                  x,                // left side coordinate
                  y,                // top coordinate
                  0,                // reserved,
                  hwndConsoleFrame, // owner window
                  NULL);            // not used

    // A zero return could indicate either an error or that the user hit
    // Escape or clicked off of the menu to cancel the operation. GetLastError()
    // determines whether there was an error.

    if (0 == i)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    // if i is non-zero then it contains the index of the selected item + 1.
    // Use it to return the MMCButtonMenu object for the selected item.

    if (0 != i)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                        pMMCButtonMenus->GetItemByIndex(i - 1L),
                                        ppMMCButtonMenuClicked));
    }

Error:
    if (NULL != hMenu)
    {
        (void)::DestroyMenu(hMenu);
    }
    if (NULL != pszText)
    {
        ::CtlFree(pszText);
    }
    QUICK_RELEASE(piMMCButtonMenus);
    RRETURN(S_OK);
}


//=--------------------------------------------------------------------------=
// CControlbar::MenuButtonClick
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject   [in]  from MMCN_MENU_BTNCLICK
//      int             idCommand      [in]  from MENUBUTTONDATA.idCommand passed
//                                           to the proxy with MMCN_MENU_BTNCLICK
//      POPUP_MENUDEF **ppPopupMenuDef [out] popup menu definition returned here
//                                           so proxy can display it
//
// Output:
//
// Notes:
//
// This function effectively handles MMCN_MENU_BTNCLICK when running
// under a debugging session.
//
// The proxy for IExtendControlbar::ControlbarNotify() will QI for
// IExtendControlbarRemote and call this method when it gets MMCN_MENU_BTNCLICK.
// We fire MMCToolbar_ButtonDropDown and then return an array of menu item
// definitions. The proxy will display the popup menu on the MMC side and then
// call IExtendControlbarRemote::PopupMenuClick() if the user makes a selection.
// (See implementation below in CControlbar::PopupMenuClick()).
//

HRESULT CControlbar::MenuButtonClick
(
    IDataObject    *piDataObject,
    int             idCommand,
    POPUP_MENUDEF **ppPopupMenuDef
)
{
    HRESULT          hr = S_OK;
    CMMCButton      *pMMCButton = NULL;
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    CMMCButtonMenus *pMMCButtonMenus = NULL;
    CMMCButtonMenu  *pMMCButtonMenu = NULL;
    long             cItems = 0;
    long             i = 0;
    long             cPopupMenuItems = 0;
    UINT             uiFlags = 0;
    POPUP_MENUDEF   *pPopupMenuDef = NULL;
    POPUP_MENUITEM  *pPopupMenuItem = NULL;
    char            *pszText = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    *ppPopupMenuDef = NULL;

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Fire MMCToolbar_ButtonDropDown

    IfFailGo(FireMenuButtonDropDown(idCommand, piMMCClipboard, &pMMCButton));

    // At this point the VB event handler has run and the snap-in has had a
    // chance to configure all the items on the menu by setting properties
    // such as MMCButton.ButtonMenus(i).Enabled, adding/removing items, etc.
    // We now need to return an array of popup menu items for the proxy to
    // display.

    // Get the ButtonMenus collection and check if there is anything in there

    IfFailGo(pMMCButton->get_ButtonMenus(
                     reinterpret_cast<MMCButtonMenus **>((&piMMCButtonMenus))));

    IfFailGo(piMMCButtonMenus->get_Count(&cItems));

    // If the collection is empty then don't do anything

    IfFalseGo(0 != cItems, S_OK);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButtonMenus,
                                                   &pMMCButtonMenus));

    // Iterate through each of the items and add them to the menu definition

    for (i = 0; i < cItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                              pMMCButtonMenus->GetItemByIndex(i),
                                              &pMMCButtonMenu));

        // If the button menu is not marked visible then don't add it to
        // the popup menu

        if (!pMMCButtonMenu->GetVisible())
        {
            continue;
        }

        // Get all of the button menu properties to set the menu item flags

        uiFlags = MF_STRING;

        if (pMMCButtonMenu->GetChecked())
        {
            uiFlags |= MF_CHECKED;
        }
        else
        {
            uiFlags |= MF_UNCHECKED;
        }

        if (pMMCButtonMenu->GetGrayed())
        {
            uiFlags |= MF_GRAYED;
        }

        if (pMMCButtonMenu->GetEnabled())
        {
            uiFlags |= MF_ENABLED;
        }
        else
        {
            uiFlags |= MF_DISABLED;
        }

        if (pMMCButtonMenu->GetMenuBreak())
        {
            uiFlags |= MF_MENUBREAK;
        }

        if (pMMCButtonMenu->GetMenuBarBreak())
        {
            uiFlags |= MF_MENUBARBREAK;
        }

        if (pMMCButtonMenu->GetSeparator())
        {
            uiFlags |= MF_SEPARATOR;
        }

        IfFailGo(::ANSIFromWideStr(pMMCButtonMenu->GetText(), &pszText));

        // (Re)allocate the POPUP_MENUDEF structure to accomodate the new item.

        pPopupMenuDef = (POPUP_MENUDEF *)::CoTaskMemRealloc(pPopupMenuDef,
                               sizeof(POPUP_MENUDEF) +
                              ((cPopupMenuItems + 1L) * sizeof(POPUP_MENUITEM)));

        if (NULL == pPopupMenuDef)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        pPopupMenuDef->cMenuItems = cPopupMenuItems + 1L;

        // Fill in the menu item info. Need to CoTaskMemAlloc() a copy of the
        // string because it will be freed by the stub after it is transmitted.
        // This is a double allocation but the perf is not an issue here and we
        // would have to copy all of the code in ANSIFromWideStr() to avoid it.

        pPopupMenuItem = &pPopupMenuDef->MenuItems[cPopupMenuItems];
        
        pPopupMenuItem->uiFlags = uiFlags;
        pPopupMenuItem->uiItemID = static_cast<UINT>(i + 1L);

        pPopupMenuItem->pszItemText =
                        (char *)::CoTaskMemAlloc(::strlen((char *)pszText) + 1);

        if (NULL == pPopupMenuItem->pszItemText)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        ::strcpy((char *)pPopupMenuItem->pszItemText, pszText);

        cPopupMenuItems++;

        ::CtlFree(pszText);
        pszText = NULL;
    }

    // If there are no items in the popup menu then don't display one. This
    // could happen if the user marked all items as invisible.

    IfFalseGo(0 != cPopupMenuItems, S_OK);

    // Set POPUP_MENUDEF members and return the definition to the stub

    IfFailGo(pMMCButton->QueryInterface(IID_IUnknown,
                  reinterpret_cast<void **>(&pPopupMenuDef->punkSnapInDefined)));

    // Get the console's main frame hwnd as owner for the popup menu. If we are
    // an extension then upon return from this call the proxy will note that
    // pPopupMenuDef->hwndMenuOwner is NULL and call GetActiveWindow() to fill
    // it in. There is nothing better that we can do because an extension does
    // not have access to IConsole2 on MMC.

    if (NULL != m_pView)
    {
        hr = m_pView->GetIConsole2()->GetMainWindow(&pPopupMenuDef->hwndMenuOwner);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        pPopupMenuDef->hwndMenuOwner = NULL;
    }

    *ppPopupMenuDef = pPopupMenuDef;

Error:
    if (NULL != pszText)
    {
        ::CtlFree(pszText);
    }

    if ( FAILED(hr) && (NULL != pPopupMenuDef) )
    {
        for (i = 0; i < pPopupMenuDef->cMenuItems; i++)
        {
            if (NULL != pPopupMenuDef->MenuItems[i].pszItemText)
            {
                ::CoTaskMemFree(pPopupMenuDef->MenuItems[i].pszItemText);
            }
        }
        if (NULL != pPopupMenuDef->punkSnapInDefined)
        {
            pPopupMenuDef->punkSnapInDefined->Release();
        }
        ::CoTaskMemFree(pPopupMenuDef);
    }

    QUICK_RELEASE(piMMCButtonMenus);
    RRETURN(S_OK);
}



//=--------------------------------------------------------------------------=
// CControlbar::PopupMenuClick
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject *piDataObject [in] from MMCN_MENU_BTNCLICK
//      UINT         uIDItem      [in] ID of popup menu item selected
//      IUnknown    *punkParam    [in] punk we returned to stub in
//                                     CControlbar::MenuButtonClick() (see above).
//                                     This is IUnknown on CMMCButton.
//
// Output:
//
// Notes:
//
// This function effectively handles a popup menu selection for a menu button
// when running under a debugging session.
//
// After the proxy for IExtendControlbar::ControlbarNotify() has displayed
// a popup menu on our behalf, if the user made a selection it will call this
// method. See CControlbar::MenuButtonClick() above for more info.
//

HRESULT CControlbar::PopupMenuClick
(
    IDataObject *piDataObject,
    UINT         uiIDItem,
    IUnknown    *punkParam
)
{
    HRESULT          hr = S_OK;
    CMMCButton      *pMMCButton = NULL;
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCButtonMenus *piMMCButtonMenus = NULL;
    CMMCButtonMenus *pMMCButtonMenus = NULL;
    CMMCToolbar     *pMMCToolbar = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Check the parameters

    IfFalseGo(0 < uiIDItem, E_INVALIDARG);
    IfFalseGo(NULL != punkParam, E_INVALIDARG);

    // Create the selection

    IfFailGo(CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                             &SelectionType));

    // Get the CMMCButton from punkParam.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkParam, &pMMCButton));

    // Get the MMCButtonMenus collection

    IfFailGo(pMMCButton->get_ButtonMenus(
                       reinterpret_cast<MMCButtonMenus **>(&piMMCButtonMenus)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCButtonMenus,
                                                   &pMMCButtonMenus));

    // Fire MMCToolbar_ButtonMenuClick. The button can give us its owning toolbar.
    // The selected item is indexed by the menu item ID - 1

    pMMCToolbar = pMMCButton->GetToolbar();

    pMMCToolbar->FireButtonMenuClick(piMMCClipboard,
               pMMCButtonMenus->GetItemByIndex(static_cast<long>(uiIDItem - 1)));

Error:
    QUICK_RELEASE(piMMCButtonMenus);
    RRETURN(S_OK);
}




HRESULT CControlbar::SetControlbar(IControlbar *piControlbar)
{
    HRESULT      hr = S_OK;
    long         cToolbars = 0;
    long         i = 0;
    CMMCToolbar *pMMCToolbar = NULL;

    if (NULL != piControlbar)
    {
        RELEASE(m_piControlbar);
        piControlbar->AddRef();
        m_piControlbar = piControlbar;

        // If we have an owning View then fire Views_SetControlbar

        if (NULL != m_pView)
        {
            m_pSnapIn->GetViews()->FireSetControlbar(
                                           static_cast<IView *>(m_pView),
                                           static_cast<IMMCControlbar *>(this));
        }
        else
        {
            // No View. Fire ExtensionSnapIn_SetControlbar

            m_pSnapIn->GetExtensionSnapIn()->FireSetControlbar(
                                           static_cast<IMMCControlbar *>(this));
        }
    }
    else if (NULL != m_piControlbar)
    {
        // This is a cleanup call and we might have stuff on the controlbar

        cToolbars = m_pToolbars->GetCount();

        ASSERT(cToolbars <= m_cControls, "Toolbar and MMC control count are out of sync");

        IfFalseGo(cToolbars <= m_cControls, SID_E_INTERNAL);

        for (i = 0; i < cToolbars; i++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                 m_pToolbars->GetItemByIndex(i),
                                                 &pMMCToolbar));

            if (NULL != m_ppunkControls[i])
            {
                hr = m_piControlbar->Detach(m_ppunkControls[i]);
                EXCEPTION_CHECK_GO(hr);
                m_ppunkControls[i]->Release();
                m_ppunkControls[i] = NULL;
            }

            pMMCToolbar->Detach();
        }
        IfFailGo(m_pToolbars->Clear());
        RELEASE(m_piControlbar);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      IMMCControlbar Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CControlbar::Attach(IDispatch *Control)
{
    HRESULT            hr = S_OK;
    IMMCToolbar       *piMMCToolbar = NULL;
    CMMCToolbar       *pMMCToolbar = NULL;
    IUnknown          *punkControl = NULL;
    MMC_CONTROL_TYPE   nType = TOOLBAR;
    BOOL               fIsToolbar = FALSE;
    BOOL               fIsMenuButton = FALSE;
    long               lIndex = 0;
    IExtendControlbar *piExtendControlbar = NULL;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    VARIANT varKey;
    ::VariantInit(&varKey);

    if (NULL == Control)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // QI to determine the type of control. We only support IMMCToolbar.

    hr = Control->QueryInterface(IID_IMMCToolbar,
                                 reinterpret_cast<void **>(&piMMCToolbar));
    if (E_NOINTERFACE == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbar, &pMMCToolbar));

    // MMCToolbars must be all buttons or all menu buttons. That's how we
    // know whether to ask MMC to create a toolbar or menu button. Check
    // which to determine the control type we will as MMC to create

    IfFailGo(pMMCToolbar->IsToolbar(&fIsToolbar));
    if (fIsToolbar)
    {
        nType = TOOLBAR;
    }
    else
    {
        IfFailGo(pMMCToolbar->IsMenuButton(&fIsMenuButton));
        if (fIsMenuButton)
        {
            nType = MENUBUTTON;
        }
        else
        {
            hr = SID_E_TOOLBAR_INCONSISTENT;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Determine which object implements IExtendControlbar for us

    if (NULL != m_pView)
    {
        piExtendControlbar = static_cast<IExtendControlbar *>(m_pView);
    }
    else
    {
        piExtendControlbar = static_cast<IExtendControlbar *>(m_pSnapIn);
    }

    // Ask MMC to create the control and get MMC's IToolbar or IMenuButton

    hr = m_piControlbar->Create(nType, piExtendControlbar, &punkControl);
    EXCEPTION_CHECK_GO(hr);

    // Ask MMC to attach it

    hr = m_piControlbar->Attach(nType, punkControl);
    EXCEPTION_CHECK_GO(hr);

    // Set up the control with buttons, bitmaps etc.

    IfFailGo(pMMCToolbar->Attach(punkControl));

    if (NULL != m_pSnapIn)
    {
        pMMCToolbar->SetSnapIn(m_pSnapIn);
    }
    else
    {
        pMMCToolbar->SetSnapIn(m_pView->GetSnapIn());
    }

    // Add it to our list of controls. We need to remember them so that
    // we can remove them when IExtendControlbar::SetControlbar(NULL) is called.
    // Controls are indexed by name.

    IfFailGo(pMMCToolbar->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    IfFailGo(m_pToolbars->AddExisting(varUnspecifiedIndex, varKey, piMMCToolbar));

    // Add the control to the parallel array of IUnknown *. The AddExisting call
    // will have set the toolbar's index to its position in this collection. (It
    // is changed every time it is attached to a controlbar, but the index
    // property is not used other than right here).

    IfFailGo(pMMCToolbar->get_Index(&lIndex));

    lIndex--; // move from one-based collection index to zero-based array index

    // We never shrink, the IUnknown array, so if its size is large enough then
    // the corresponding slot it is free. If it is not large enough then grow
    // it now.

    if (m_cControls < (lIndex + 1L))
    {
        if (NULL == m_ppunkControls)
        {
            m_ppunkControls = (IUnknown **)::CtlAllocZero(sizeof(IUnknown *));
        }
        else
        {
            m_ppunkControls = (IUnknown **)::CtlReAllocZero(m_ppunkControls,
                                       sizeof(IUnknown *) * (m_cControls + 1L));
        }
        if (NULL == m_ppunkControls)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        m_cControls++;
    }

    punkControl->AddRef();
    m_ppunkControls[lIndex] = punkControl;

Error:
    QUICK_RELEASE(piMMCToolbar);
    QUICK_RELEASE(punkControl);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}



STDMETHODIMP CControlbar::Detach(IDispatch *Control)
{
    HRESULT      hr = S_OK;
    IMMCToolbar *piMMCToolbar = NULL;
    CMMCToolbar *pMMCToolbar = NULL;
    long         lIndex = 0;

    VARIANT varKey;
    ::VariantInit(&varKey);

    if (NULL == Control)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // QI to determine control type. We only support IMMCToolbar.

    hr = Control->QueryInterface(IID_IMMCToolbar,
                                 reinterpret_cast<void **>(&piMMCToolbar));
    if (E_NOINTERFACE == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbar, &pMMCToolbar));

    // Lookup the IMMCToolbar in our collection and get the index of its
    // corresponding MMC control IUnknown

    IfFailGo(GetControlIndex(piMMCToolbar, &lIndex));

    // Ask MMC to detach it and release it

    hr = m_piControlbar->Detach(m_ppunkControls[lIndex]);
    m_ppunkControls[lIndex]->Release();

    // Compress the IUnknown array

    while (lIndex < (m_cControls - 1L))
    {
        m_ppunkControls[lIndex] = m_ppunkControls[lIndex + 1L];
        lIndex++;
    }
    m_ppunkControls[lIndex] = NULL;

    // Tell the toolbar it is no longer attached to this controlbar in MMC

    pMMCToolbar->Detach();

    // Get its name and remove it from our list

    IfFailGo(pMMCToolbar->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    IfFailGo(m_pToolbars->Remove(varKey));

Error:
    QUICK_RELEASE(piMMCToolbar);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CControlbar::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCControlbar == riid)
    {
        *ppvObjOut = static_cast<IMMCControlbar *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CControlbar::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(static_cast<IMMCToolbars *>(m_pToolbars)));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtmenu.cpp ===
//=--------------------------------------------------------------------------=
// ctxtmenu.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CContextMenu class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ctxtmenu.h"
#include "menu.h"
#include "spanitem.h"
#include "lvdefs.h"
#include "lvdef.h"
#include "ocxvdefs.h"
#include "ocxvdef.h"
#include "urlvdefs.h"
#include "urlvdef.h"
#include "tpdvdefs.h"
#include "tpdvdef.h"



// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CContextMenu::CContextMenu(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                            OBJECT_TYPE_CONTEXTMENU,
                                            static_cast<IContextMenu *>(this),
                                            static_cast<CContextMenu *>(this),
                                            0,    // no property pages
                                            NULL, // no property pages
                                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CContextMenu::Create(IUnknown *punkOuter)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkMMCMenus = CMMCMenus::Create(NULL);
    CContextMenu *pContextMenu = New CContextMenu(punkOuter);

    if ( (NULL == pContextMenu) || (NULL == punkMMCMenus) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCMenus,
                                                   &pContextMenu->m_pMenus));

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pContextMenu)
        {
            delete pContextMenu;
        }
        return NULL;
    }
    else
    {
        return pContextMenu->PrivateUnknown();
    }
}

CContextMenu::~CContextMenu()
{
    if (NULL != m_pMenus)
    {
        m_pMenus->Release();
    }
    RELEASE(m_piContextMenuCallback);
    InitMemberVariables();
}

void CContextMenu::InitMemberVariables()
{
    m_pMenus = NULL;
    m_piContextMenuCallback = NULL;
    m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_TOP;
    m_pView = NULL;
    m_pSnapIn = NULL;
}

//=--------------------------------------------------------------------------=
// CContextMenu::AddMenuToMMC
//=--------------------------------------------------------------------------=
//
// Parameters:
//      CMMCMenu *pMMCMenu       [in] menu to be added to MMC
//      long     lInsertionPoint [in] insertion point ID for MMC
//
// Output:
//      HRESULT
//
// Notes:
//
//
// Adds each of the MMCMenu's children to the MMC menu at the
// specified insertion point. If a child has children of its own then it
// represents a submenu. This function is called recursively to add the
// submenu.
//    
// CContextMenu maintains a collection of MMCMenu objects that has a member
// for each menu item added to MMC's context menu. This collection is
// cleaned out in our IExtendContextMenu::AddMenuItems() implementation
// (see CContextMenu::AddMenuItems()). The command ID of a menu item added to
// MMC is the index into the collection. It would have been preferable
// to use a pointer the MMCMenu object as the command ID but MMC only
// allows 16 bit command IDs.
//
// When an item is selected we used the command ID to index the
// collection and use the corresponding MMCMenu object to fire the
// event. (See our IExtendContextMenu::Command implementation in
// CContextMenu::Command()).

HRESULT CContextMenu::AddMenuToMMC(CMMCMenu *pMMCMenu, long lInsertionPoint)
{
    HRESULT          hr = S_OK;
    IMMCMenus       *piMenuItems = NULL;
    CMMCMenus       *pMMCMenuItems = NULL;
    CMMCMenu        *pMMCMenuItem = NULL;
    long             cMenuItems = 0;
    long             i = 0;
    long             lIndexCmdID = 0;
    BOOL             fSkip = FALSE;
    BOOL             fHasChildren = FALSE;

    CONTEXTMENUITEM cmi;
    ::ZeroMemory(&cmi, sizeof(cmi));

    // Get the children of the MMCMenu. These represent the items that
    // are being added to MMC's menu at the specified insertion point.

    IfFailGo(pMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMenuItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMenuItems, &pMMCMenuItems));

    cMenuItems = pMMCMenuItems->GetCount();

    // Iterate through the menu items and add each one to MMC

    for (i = 0; i < cMenuItems; i++)
    {
        // Add the menu item to our MMCMenus collection and get its command ID
        IfFailGo(AddItemToCollection(m_pMenus, pMMCMenuItems, i,
                                     &pMMCMenuItem, &lIndexCmdID,
                                     &fHasChildren, &fSkip));
        if (fSkip)
        {
            // Menu item is not visible, skip it.
            continue;
        }

        // Fill in MMC's CONTEXTMENUITEM
        
        ::ZeroMemory(&cmi, sizeof(cmi));
        cmi.strName = pMMCMenuItem->GetCaption();
        cmi.strStatusBarText = pMMCMenuItem->GetStatusBarText();
        cmi.lCommandID = lIndexCmdID;
        cmi.lInsertionPointID = lInsertionPoint;

        cmi.fFlags |= pMMCMenuItem->GetChecked() ? MF_CHECKED : MF_UNCHECKED;
        cmi.fFlags |= pMMCMenuItem->GetEnabled() ? MF_ENABLED : MF_DISABLED;

        if (pMMCMenuItem->GetGrayed())
        {
            cmi.fFlags |= MF_GRAYED;
        }

        if (pMMCMenuItem->GetMenuBreak())
        {
            cmi.fFlags |= MF_MENUBREAK;
        }

        if (pMMCMenuItem->GetMenuBarBreak())
        {
            cmi.fFlags |= MF_MENUBARBREAK;
        }

        if (fHasChildren)
        {
            cmi.fFlags |= MF_POPUP;
        }

        if (pMMCMenuItem->GetDefault())
        {
            cmi.fSpecialFlags = CCM_SPECIAL_DEFAULT_ITEM;
        }

        hr = m_piContextMenuCallback->AddItem(&cmi);
        EXCEPTION_CHECK_GO(hr);

        // If the item is a popup then call this function recursively to add its
        // items. Pass the command ID of this menu as the insertion point for
        // the submenu.

        if (fHasChildren)
        {
            IfFailGo(AddMenuToMMC(pMMCMenuItem, cmi.lCommandID));
        }
    }

Error:
    QUICK_RELEASE(piMenuItems);
    RRETURN(hr);
}


HRESULT CContextMenu::AddItemToCollection
(
    CMMCMenus  *pMMCMenus,
    CMMCMenus  *pMMCMenuItems,
    long        lIndex,
    CMMCMenu  **ppMMCMenuItem,
    long       *plIndexCmdID,
    BOOL       *pfHasChildren,
    BOOL       *pfSkip
)
{
    HRESULT    hr = S_OK;
    IMMCMenus *piSubMenuItems = NULL;
    CMMCMenus *pOwningCollection = NULL;
    IMMCMenu  *piMMCMenuItem = NULL; // Not AddRef()ed
    CMMCMenu  *pMMCMenuItem = NULL;
    long       cSubMenuItems = 0;
    BSTR       bstrKey = NULL;

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    *ppMMCMenuItem = NULL;
    *plIndexCmdID = 0;
    *pfHasChildren = FALSE;
    *pfSkip = TRUE;

    // Get the menu item and its MMCMenu object

    piMMCMenuItem = pMMCMenuItems->GetItemByIndex(lIndex);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuItem, &pMMCMenuItem));

    // If the item is not marked as visible then go on to the next one

    IfFalseGo(pMMCMenuItem->GetVisible(), S_OK);
    *pfSkip = FALSE;

    // Store the index of the menu in its owning collection. We will need
    // to restore its index after we add the menu to our own collection
    // that represents this context menu.

    lIndex = pMMCMenuItem->GetIndex();

    // Store the key of the menu. CMMCMenus::AddExisting()
    // will use the name as the key (which is the default setting at
    // design time) but the dev may have changed it.
    // After we add it to our collection we will restore the key.
    // Note: there should never be duplicate menu names in a snap-in
    // project because the designer will not allow it.

    IfFailGo(piMMCMenuItem->get_Key(&bstrKey));

    // Store the owning collection of the menu as we will need to
    // restore that too after adding it to our collection.

    pOwningCollection = pMMCMenuItem->GetCollection();

    // Add the menu item to the MMCMenus collection. This will change its index
    // to its position in our collection.

    IfFailGo(pMMCMenus->AddExisting(piMMCMenuItem, varIndex));

    // Get the index in the MMCMenus collection to use as the command ID.

    *plIndexCmdID = pMMCMenuItem->GetIndex();

    // Restore the menu's original index that indicates its position
    // in its owning collection.

    pMMCMenuItem->SetIndex(lIndex);

    // Restore the menu's original key.

    IfFailGo(pMMCMenuItem->put_Key(bstrKey));
    FREESTRING(bstrKey);

    // Restore its real owning collection (the AddExisting call above
    // switched the owner to our collection).

    pMMCMenuItem->SetCollection(pOwningCollection);

    // The index trick above will work because when the menu item is
    // selected, we will use the command ID to access the menu in the MMCMenus
    // collection. Even though the index is technically incorrect,
    // CSnapInCollection (in collect.h) does not do a lookup when get_Item is
    // called with an integer index. It simply checks that the index is within
    // the bounds of the collection and returns the item at that offset.

    // This is extremely unlikely but as a command ID can only be 16 bits
    // we need to check that the item we just added is not number 0x10000.

    if ( ((*plIndexCmdID) & CCM_COMMANDID_MASK_RESERVED) != 0 )
    {
        hr = SID_E_TOO_MANY_MENU_ITEMS;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get count of submenu items for this item

    IfFailGo(pMMCMenuItem->get_Children(reinterpret_cast<MMCMenus **>(&piSubMenuItems)));
    IfFailGo(piSubMenuItems->get_Count(&cSubMenuItems));

    if (0 != cSubMenuItems)
    {
        *pfHasChildren = TRUE;
    }

    *ppMMCMenuItem = pMMCMenuItem;

Error:
    QUICK_RELEASE(piSubMenuItems);
    FREESTRING(bstrKey);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CContextMenu::AddPredefinedViews
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IContextMenuCallback *piContextMenuCallback [in] MMC interface for
//                                                       adding menu items
//      CScopeItem           *pScopeItem            [in] currently selected
//                                                       scope item
//
// Output:
//      HRESULT
//
// Notes:
//
// If the scope item has a design time defintion (IScopeItemDef) and
// that definition has views and those views are marked to be added to
// the view menu, then add 'em.
//

HRESULT CContextMenu::AddPredefinedViews
(
    IContextMenuCallback *piContextMenuCallback,
    CScopeItem           *pScopeItem,
    BSTR                  bstrCurrentDisplayString
)
{
    HRESULT           hr = S_OK;
    IScopeItemDef    *piScopeItemDef = NULL;// Not AddRef()ed
    IViewDefs        *piViewDefs = NULL;
    IListViewDefs    *piListViewDefs = NULL;
    IListViewDef     *piListViewDef = NULL;
    CListViewDef     *pListViewDef = NULL;
    IOCXViewDefs     *piOCXViewDefs = NULL;
    IOCXViewDef      *piOCXViewDef = NULL;
    COCXViewDef      *pOCXViewDef = NULL;
    IURLViewDefs     *piURLViewDefs = NULL;
    IURLViewDef      *piURLViewDef = NULL;
    CURLViewDef      *pURLViewDef = NULL;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    CTaskpadViewDef  *pTaskpadViewDef = NULL;
    long              cContextMenus = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    varIndex.vt = VT_I4;

    // Need to get the design time definition. If this is the static node
    // then it is SnapInDef. If not, then it is a ScopeItemDef.

    if (pScopeItem->IsStaticNode())
    {
        IfFailGo(GetSnapInViewDefs(&piViewDefs));
    }
    else
    {
        piScopeItemDef = pScopeItem->GetScopeItemDef();// Not AddRef()ed

        // If no design time definition then there's nothing to do as this
        // scope item was defined entirely in VB code.

        IfFalseGo(NULL != piScopeItemDef, S_OK);
        IfFailGo(piScopeItemDef->get_ViewDefs(&piViewDefs));
    }

    // Get each view collection and search for auto-view-menu definitions.
    // Note that we cannot use the shortcut CCollection::GetItemByIndex to
    // iterate through these collections because they are not master
    // collections and only get_Item() will sync up with the master.

    // Listviews

    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(piListViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piListViewDef);
        IfFailGo(piListViewDefs->get_Item(varIndex, &piListViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piListViewDef, &pListViewDef));

        if (!pListViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pListViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pListViewDef->GetViewMenuText(),
                                 pListViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }
    
    // OCX views

    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));
    IfFailGo(piOCXViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piOCXViewDef);
        IfFailGo(piOCXViewDefs->get_Item(varIndex, &piOCXViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piOCXViewDef, &pOCXViewDef));

        if (!pOCXViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pOCXViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pOCXViewDef->GetViewMenuText(),
                                 pOCXViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }

    // URL views

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));
    IfFailGo(piURLViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piURLViewDef);
        IfFailGo(piURLViewDefs->get_Item(varIndex, &piURLViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piURLViewDef, &pURLViewDef));

        if (!pURLViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pURLViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pURLViewDef->GetViewMenuText(),
                                 pURLViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }

    // Taskpad views

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(piTaskpadViewDefs->get_Count(&cContextMenus));

    for (varIndex.lVal = 1L; varIndex.lVal <= cContextMenus; varIndex.lVal++)
    {
        RELEASE(piTaskpadViewDef);
        IfFailGo(piTaskpadViewDefs->get_Item(varIndex, &piTaskpadViewDef));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piTaskpadViewDef, &pTaskpadViewDef));

        if (!pTaskpadViewDef->AddToViewMenu())
        {
            continue;
        }

        IfFailGo(AddViewMenuItem(pTaskpadViewDef->GetName(),
                                 bstrCurrentDisplayString,
                                 pTaskpadViewDef->GetViewMenuText(),
                                 pTaskpadViewDef->GetViewMenuStatusBarText(),
                                 piContextMenuCallback));
    }

    
Error:
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    QUICK_RELEASE(piOCXViewDefs);
    QUICK_RELEASE(piOCXViewDef);
    QUICK_RELEASE(piURLViewDefs);
    QUICK_RELEASE(piURLViewDef);
    QUICK_RELEASE(piTaskpadViewDefs);
    QUICK_RELEASE(piTaskpadViewDef);
    RRETURN(hr);
}


HRESULT CContextMenu::AddViewMenuItem
(
    BSTR                  bstrDisplayString,
    BSTR                  bstrCurrentDisplayString,
    LPWSTR                pwszText,
    LPWSTR                pwszToolTipText,
    IContextMenuCallback *piContextMenuCallback
)
{
    HRESULT      hr = S_OK;
    IMMCMenu    *piMMCMenu = NULL;
    CMMCMenu    *pMMCMenu = NULL;
    long         lIndex = 0;

    CONTEXTMENUITEM cmi;
    ::ZeroMemory(&cmi, sizeof(cmi));

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    // Add an MMCMenu to our collection of currently displayed context
    // menu items.

    IfFailGo(m_pMenus->Add(varUnspecified, varUnspecified, &piMMCMenu));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));

    // Get its index to use as the command ID.

    lIndex = pMMCMenu->GetIndex();

    // Tell the MMCMenu object is is being used as an auto-view-menu item.
    
    pMMCMenu->SetAutoViewMenuItem();

    // Set its display string so that the menu command handler (CContextMenu::Command)
    // can use it to change the result view.

    IfFailGo(pMMCMenu->SetResultViewDisplayString(bstrDisplayString));
    
    // Build the MMC ContextMenuItem and add it to the View menu

    cmi.strName = pwszText;
    cmi.strStatusBarText = pwszToolTipText;
    cmi.lCommandID = lIndex;
    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
    cmi.fFlags = 0;
    cmi.fSpecialFlags = 0;

    // Check whether this result view is the scope item's current result view.
    // If so then add a check mark.

    if (NULL != bstrCurrentDisplayString)
    {
        if (0 == ::wcscmp(bstrDisplayString, bstrCurrentDisplayString))
        {
            cmi.fFlags |= MF_CHECKED;
        }
    }

    hr = piContextMenuCallback->AddItem(&cmi);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMMCMenu);
    RRETURN(hr);
}


HRESULT CContextMenu::AddMenuItems
(
    IDataObject          *piDataObject,
    IContextMenuCallback *piContextMenuCallback,
    long                 *plInsertionAllowed,
    CScopePaneItem       *pSelectedItem
)
{
    HRESULT           hr = S_OK;
    IMMCClipboard    *piMMCClipboard = NULL;
    CMMCDataObject   *pMMCDataObject  = NULL;
    IScopeItems      *piScopeItems = NULL;
    IMMCListItems    *piMMCListItems = NULL;
    IMMCDataObjects  *piMMCDataObjects = NULL;
    long              cItems = 0;
    VARIANT_BOOL      fvarInsertionAllowed = VARIANT_FALSE;
    VARIANT_BOOL      fvarAddPredefinedViews = VARIANT_FALSE;
    BOOL              fExtension = FALSE;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Clean out our MMCMenu collection. This collection holds all the items
    // that will be added to the context menu during this method. If this is
    // not the first context menu in the life of the snap-in then the collection
    // will contain the items from the previously displayed context menu.

    IfFailGo(m_pMenus->Clear());

    // Even though MMC specifically says not to hold on to the callback
    // interface we do this here so that VB event handler code called from here
    // can call back into us (using ContextMenu.AddMenu) to insert menu
    // items. From MMC's point of view we are not holding this interface pointer
    // after this method returns. The AddRef() is technically not necessary
    // but is done as an extra safety measure.
    
    piContextMenuCallback->AddRef();
    m_piContextMenuCallback = piContextMenuCallback;

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0 )
    {
        m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        fvarInsertionAllowed = VARIANT_TRUE;
        m_pSnapIn->GetViews()->FireAddTopMenuItems(
                              static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                              piMMCClipboard,
                              static_cast<IContextMenu *>(this),
                              &fvarInsertionAllowed);
        if (VARIANT_FALSE == fvarInsertionAllowed)
        {
            *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_TOP;
        }
    }

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0 )
    {
        if (!IsForeign(SelectionType))
        {
            // Snap-in owns the selected items. Fire Views_AddNewMenuItems.

            m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_NEW;
            fvarInsertionAllowed = VARIANT_TRUE;
            m_pSnapIn->GetViews()->FireAddNewMenuItems(
                                  static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                                  piMMCClipboard,
                                  static_cast<IContextMenu *>(this),
                                  &fvarInsertionAllowed);
            if (VARIANT_FALSE == fvarInsertionAllowed)
            {
                *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_NEW;
            }
        }
        else
        {
            // We are acting as an extension.
            // Fire ExtensionSnapIn_AddNewMenuItems

            m_lInsertionPoint = CCM_INSERTIONPOINTID_3RDPARTY_NEW;

            IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
            m_pSnapIn->GetExtensionSnapIn()->FireAddNewMenuItems(
                                              piMMCDataObjects,
                                              static_cast<IContextMenu *>(this));
            // Release the data objects here because in an extension we could
            // be asked for new and task items and the code below also get
            // the data objects.
            RELEASE(piMMCDataObjects);
        }
    }

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0 )
    {
        if (!IsForeign(SelectionType))
        {
            // Snap-in owns the selected items. Fire Views_AddTaskMenuItems.

            m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_TASK;
            fvarInsertionAllowed = VARIANT_TRUE;
            m_pSnapIn->GetViews()->FireAddTaskMenuItems(
                                  static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                                  piMMCClipboard,
                                  static_cast<IContextMenu *>(this),
                                  &fvarInsertionAllowed);
            if (VARIANT_FALSE == fvarInsertionAllowed)
            {
                *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_TASK;
            }
        }
        else
        {
            // We are acting as an extension.
            // Fire ExtensionSnapIn_AddTaskMenuItems

            m_lInsertionPoint = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
            IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
            m_pSnapIn->GetExtensionSnapIn()->FireAddTaskMenuItems(
                                              piMMCDataObjects,
                                              static_cast<IContextMenu *>(this));
            RELEASE(piMMCDataObjects);
        }
    }

    if ( (*plInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) != 0 )
    {
        m_lInsertionPoint = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
        fvarInsertionAllowed = VARIANT_TRUE;
        fvarAddPredefinedViews = VARIANT_TRUE;

        m_pSnapIn->GetViews()->FireAddViewMenuItems(
                              static_cast<IView *>(m_pSnapIn->GetCurrentView()),
                              piMMCClipboard,
                              static_cast<IContextMenu *>(this),
                              &fvarInsertionAllowed,
                              &fvarAddPredefinedViews);
        if (VARIANT_FALSE == fvarInsertionAllowed)
        {
            *plInsertionAllowed &= ~CCM_INSERTIONALLOWED_TASK;
        }

        // If the snap-in didn't nix the addition of predefined views then
        // add them to the view menu
        if (VARIANT_TRUE == fvarAddPredefinedViews)
        {
            // Check if the data object represents a single scope item and that
            // it is the currently selected scope item.
            // If MMC is allowing adding to the view menu then this should be 
            // the case but we need to check to be sure.

            IfFalseGo(NULL != pSelectedItem, S_OK);

            IfFailGo(piMMCClipboard->get_ScopeItems(reinterpret_cast<ScopeItems **>(&piScopeItems)));
            IfFailGo(piScopeItems->get_Count(&cItems));
            IfFalseGo(1L == cItems, S_OK);

            // Get the scope item from the data object and compare it to the
            // selected scope item. We can't use the scope item from the
            // clipboard for a pointer comparison as it is a clone of the
            // real scope item.

            IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
            IfFalseGo(pMMCDataObject->GetScopeItem() == pSelectedItem->GetScopeItem(), S_OK);

            // Make sure there is nothing else in the selection
            
            IfFailGo(piMMCClipboard->get_ListItems(reinterpret_cast<MMCListItems **>(&piMMCListItems)));
            IfFailGo(piMMCListItems->get_Count(&cItems));
            IfFalseGo(0 == cItems, S_OK);

            IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
            IfFailGo(piMMCDataObjects->get_Count(&cItems));
            IfFalseGo(0 == cItems, S_OK);

            // Get the display string from the selected item so that we
            // can check its menu item if it is a predefined result view and
            // add the predefined views to the view menu.

            IfFailGo(AddPredefinedViews(piContextMenuCallback,
                                        pMMCDataObject->GetScopeItem(),
                                        pSelectedItem->GetDisplayString()));
        }
    }

Error:
    m_piContextMenuCallback = NULL;
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piScopeItems);
    QUICK_RELEASE(piMMCListItems);
    QUICK_RELEASE(piContextMenuCallback);
    QUICK_RELEASE(piMMCDataObjects);
    RRETURN(hr);
}


HRESULT CContextMenu::Command
(
    long            lCommandID,
    IDataObject    *piDataObject,
    CScopePaneItem *pSelectedItem
)
{
    HRESULT         hr = S_OK;
    IMMCClipboard  *piMMCClipboard = NULL;
    IMMCMenu       *piMMCMenu = NULL;
    CMMCMenu       *pMMCMenu = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Check for listview selection notification. This is sent by MMC when
    // a non-listview is in the result pane and the user selects one of the
    // listview options from the view menu (list, small, large, etc). We
    // notify the view that owns this CContextMenu object so the information
    // can be used for the subsequent IComponent::GetResultViewType() call.

    if (MMCC_STANDARD_VIEW_SELECT == lCommandID)
    {
        if (NULL != pSelectedItem)
        {
            IfFailGo(pSelectedItem->OnListViewSelected());
        }
        goto Error; // we're done
    }

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, m_pSnapIn,
                               &SelectionType));

    // The command ID is an index into our MMCMenus collection. Use it
    // to get the  the MMCMenu object for the selected item.

    varIndex.vt = VT_I4;
    varIndex.lVal = lCommandID;
    IfFailGo(m_pMenus->get_Item(varIndex, &piMMCMenu));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));

    // If this is an auto view menu item then initiate the new result view
    // display

    if (pMMCMenu->IsAutoViewMenuItem())
    {
        if (NULL != pSelectedItem)
        {
            // Get the result view display string from the MMCMenu
            // and set it in the currently selected ScopePaneItem as a
            // predefined view type. Reselect the scope item so that MMC
            // will change the result view.

            IfFailGo(pSelectedItem->DisplayNewResultView(
                                         pMMCMenu->GetResultViewDisplayString(),
                                         siPreDefined));
        }
    }
    else
    {
        // It is a snap-in defined menu item. Fire the menu click event.
        FireMenuClick(pMMCMenu, piMMCClipboard);
    }

Error:
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCMenu);
    RRETURN(hr);
}


void CContextMenu::FireMenuClick
(
    CMMCMenu      *pMMCMenu,
    IMMCClipboard *piMMCClipboard
)
{
    CMMCMenus *pMMCMenus = NULL;
    CMMCMenu  *pMMCParentMenu = NULL;

    // Fire the event on the menu item first.

    pMMCMenu->FireClick(pMMCMenu->GetIndex(), piMMCClipboard);

    // The snap-in may also be sinking events on the parent menu so if
    // there is one then fire it there too.

    pMMCMenus = pMMCMenu->GetCollection();

    if (NULL != pMMCMenus)
    {
        // Get the MMCMenu that owns the collection containing the menu
        // item that was clicked.

        pMMCParentMenu = pMMCMenus->GetParent();

        // Fire the event with the selected item's index

        if (NULL != pMMCParentMenu)
        {
            pMMCParentMenu->FireClick(pMMCMenu->GetIndex(), piMMCClipboard);
        }
    }
}

//=--------------------------------------------------------------------------=
//                         IContextMenu Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CContextMenu::AddMenu(MMCMenu *Menu)
{
    HRESULT   hr = S_OK;
    CMMCMenu *pMMCMenu = NULL;

    if (NULL == Menu)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                reinterpret_cast<IMMCMenu *>(Menu), &pMMCMenu));

    // Ask MMC to add the menu to the appropriate insertion point

    IfFailGo(AddMenuToMMC(pMMCMenu, m_lInsertionPoint));

Error:
    if (SID_E_DETACHED_OBJECT == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CContextMenu::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IContextMenu == riid)
    {
        *ppvObjOut = static_cast<IContextMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtmenu.h ===
//=--------------------------------------------------------------------------=
// ctxtmenu.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CContextMenu class definition - implements ContextMenu object
//
//=--------------------------------------------------------------------------=

#ifndef _CTXTMENU_DEFINED_
#define _CTXTMENU_DEFINED_

#include "menus.h"
#include "spanitem.h"
#include "view.h"

class CScopePaneItem;
class CMMCMenus;
class CMMCMenu;
class CView;

//=--------------------------------------------------------------------------=
// 
// class CContextMenu
//
// Implements ContextMenu object used by VB and implements IExtendContextMenu
// for CSnapIn and CView.
//
//=--------------------------------------------------------------------------=
class CContextMenu : public CSnapInAutomationObject,
                     public IContextMenu
{
    protected:
        CContextMenu(IUnknown *punkOuter);
        ~CContextMenu();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT AddMenuItems(IDataObject          *piDataObject,
                             IContextMenuCallback *piContextMenuCallback,
                             long                 *plInsertionAllowed,
                             CScopePaneItem       *pSelectedItem);
        HRESULT Command(long            lCommandID,
                        IDataObject    *piDataObject,
                        CScopePaneItem *pSelectedItem);

        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        void SetView(CView *pView) { m_pView = pView; }

        static void FireMenuClick(CMMCMenu      *pMMCMenu,
                                  IMMCClipboard *piMMCClipboard);

        static HRESULT AddItemToCollection(CMMCMenus  *pMMCMenus,
                                           CMMCMenus  *pMMCMenuItems,
                                           long        lIndex,
                                           CMMCMenu  **ppMMCMenu,
                                           long       *plIndexCmdID,
                                           BOOL       *pfHasChildren,
                                           BOOL       *pfSkip);

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IContextMenu
    private:

        STDMETHOD(AddMenu)(MMCMenu *Menu);

        void InitMemberVariables();
        HRESULT AddMenuToMMC(CMMCMenu *pMMCMenu, long lInsertionPoint);
        HRESULT AddPredefinedViews(IContextMenuCallback *piContextMenuCallback,
                                   CScopeItem           *pScopeItem,
                                   BSTR                  bstrCurrentDisplayString);
        HRESULT AddViewMenuItem(BSTR bstrDisplayString,
                                BSTR bstrCurrentDisplayString,
                                LPWSTR pwszText,
                                LPWSTR pwszToolTipText,
                                IContextMenuCallback *piContextMenuCallback);

        CMMCMenus            *m_pMenus;
        IContextMenuCallback *m_piContextMenuCallback; // MMC interface
        long                  m_lInsertionPoint;       // Current insertion point
        CView                *m_pView;                 // Owning CView
        CSnapIn              *m_pSnapIn;               // Owning CSnapIn
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(ContextMenu,            // name
                                NULL,                   // clsid
                                NULL,                   // objname
                                NULL,                   // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IContextMenu,      // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif _CTXTMENU_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtprov.h ===
//=--------------------------------------------------------------------------=
// ctxtprov.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCContextMenuProvider class definition
//
// Not used as MMC does not support IContextMenuProvier
//=--------------------------------------------------------------------------=

#ifndef _CTXTPROV_DEFINED_
#define _CTXTPROV_DEFINED_

#include "view.h"

class CMMCContextMenuProvider : public CSnapInAutomationObject,
                                public IMMCContextMenuProvider
{
    protected:
        CMMCContextMenuProvider(IUnknown *punkOuter);
        ~CMMCContextMenuProvider();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT SetProvider(IContextMenuProvider *piContextMenuProvider,
                            CView                *pView);

    // IMMCContextMenuProvider
    protected:
        STDMETHOD(AddSnapInItems)(VARIANT Objects);
        STDMETHOD(AddExtensionItems)(VARIANT Objects);
        STDMETHOD(ShowContextMenu)(VARIANT Objects, OLE_HANDLE hwnd,
                                   long xPos, long yPos);
        STDMETHOD(Clear)();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IContextMenu
    private:

        void InitMemberVariables();

        IContextMenuProvider *m_piContextMenuProvider;
        IUnknown             *m_punkView;
        CView                *m_pView;
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCContextMenuProvider,       // name
                                NULL,                         // clsid
                                NULL,                         // objname
                                NULL,                         // lblname
                                NULL,                         // creation function
                                TLIB_VERSION_MAJOR,           // major version
                                TLIB_VERSION_MINOR,           // minor version
                                &IID_IMMCContextMenuProvider, // dispatch IID
                                NULL,                         // event IID
                                HELP_FILENAME,                // help file
                                TRUE);                        // thread safe


#endif _CTXTPROV_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctlbar.h ===
//=--------------------------------------------------------------------------=
// ctlbar.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CControlbar class definition
//
//=--------------------------------------------------------------------------=

#ifndef _CTLBAR_DEFINED_
#define _CTLBAR_DEFINED_

#include "toolbars.h"
#include "button.h"
#include "mbutton.h"

class CMMCButton;
class CMMCButtonMenu;

//=--------------------------------------------------------------------------=
//
// class CControlbar
//
// Used by both CSnapIn (IComponentData) and CView (IComponent) to implement
// IExtendControlbar
//
//=--------------------------------------------------------------------------=

class CControlbar : public CSnapInAutomationObject,
                    public IMMCControlbar
{
    protected:
        CControlbar(IUnknown *punkOuter);
        ~CControlbar();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT SetControlbar(IControlbar *piControlbar);
        HRESULT OnControlbarSelect(IDataObject *piDataObject,
                                   BOOL fScopeItem, BOOL fSelected);
        HRESULT OnButtonClick(IDataObject *piDataObject, int idButton);
        HRESULT OnMenuButtonClick(IDataObject *piDataObject,
                                  MENUBUTTONDATA *pMENUBUTTONDATA);
        HRESULT FireMenuButtonDropDown(int              idCommand,
                                       IMMCClipboard   *piMMCClipboard,
                                       CMMCButton     **ppMMCButton);
        HRESULT DisplayPopupMenu(CMMCButton *pMMCButton,
                                 int x, int y,
                                 CMMCButtonMenu **ppMMCButtonMenuClicked);

        HRESULT MenuButtonClick(IDataObject   *piDataObject,
                                int             idCommand,
                                POPUP_MENUDEF **ppPopupMenuDef);
        HRESULT PopupMenuClick(IDataObject *piDataObject,
                               UINT         uIDItem,
                               IUnknown    *punkParam);

        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        void SetView(CView *pView) { m_pView = pView; }

        static HRESULT GetControl(CSnapIn      *pSnapin,
                                  IMMCToolbar  *piMMCToolbar,
                                  IUnknown    **ppunkControl);
        static HRESULT GetToolbar(CSnapIn      *pSnapin,
                                  IMMCToolbar  *piMMCToolbar,
                                  IToolbar    **ppiToolbar);
        static HRESULT GetMenuButton(CSnapIn      *pSnapin,
                                     IMMCToolbar  *piMMCToolbar,
                                     IMenuButton **ppiMenuButton);

    // CSnapInAutomationObject overrides
    protected:
        HRESULT OnSetHost();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IMMCControlbar
    private:
        STDMETHOD(Attach)(IDispatch *Control);
        STDMETHOD(Detach)(IDispatch *Control);

        void InitMemberVariables();

        HRESULT GetControlIndex(IMMCToolbar *piMMCToolbar, long *plIndex);

        // We keep a collection of all MMCToolbar objects that have been
        // attached to this controlbar

        CMMCToolbars            *m_pToolbars;

        // An MMCToolbar may be used in more than one view simultaneously.
        // Consequently it can't hold onto the MMC control IUnknown. This
        // array parallels the collection and holds an IUnknown per MMCToolbar.
        // When an MMCToolbar needs to call a method on MMC's IToolbar or
        // IMenuButton it gets the current View and gets the View's CControlbar.
        // It then asks the CControlbar for the IUnknown of the MMC control
        // which it represents in that View. (See GetControl()).
        
        IUnknown              **m_ppunkControls;  // array of IUnknowns
        long                    m_cControls;      // count of IUnknowns in array

        CSnapIn                 *m_pSnapIn;       // Back pointer to owning CSnapIn
        CView                   *m_pView;         // Back pointer to owning CView
        IControlbar             *m_piControlbar;  // MMC's IControlbar interface
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(Controlbar,             // name
                                NULL,                   // clsid
                                NULL,                   // objname
                                NULL,                   // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCControlbar,    // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif _CTLBAR_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmt.cpp ===
//=--------------------------------------------------------------------------=
// datafmt.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormat class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "datafmt.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CDataFormat::CDataFormat(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_DATAFORMAT,
                            static_cast<IDataFormat *>(this),
                            static_cast<CDataFormat *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_DataFormat,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CDataFormat::~CDataFormat()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrFileName);
    InitMemberVariables();
}

void CDataFormat::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrFileName = NULL;
}

IUnknown *CDataFormat::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkDataFormat = NULL;

    CDataFormat *pDataFormat = New CDataFormat(punkOuter);

    IfFalseGo(NULL != pDataFormat, SID_E_OUTOFMEMORY);
    punkDataFormat = pDataFormat->PrivateUnknown();

Error:
    return punkDataFormat;
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormat::Persist()
{
    HRESULT hr = S_OK;

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrFileName, L"", OLESTR("FileName")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormat::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IDataFormat == riid)
    {
        *ppvObjOut = static_cast<IDataFormat *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ctxtprov.cpp ===
//=--------------------------------------------------------------------------=
// ctxtprov.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCContextMenuProvider class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ctxtprov.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CMMCContextMenuProvider::CMMCContextMenuProvider(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                   OBJECT_TYPE_CONTEXTMENUPROVIDER,
                                   static_cast<IMMCContextMenuProvider *>(this),
                                   static_cast<CMMCContextMenuProvider *>(this),
                                   0,    // no property pages
                                   NULL, // no property pages
                                   NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


IUnknown *CMMCContextMenuProvider::Create(IUnknown *punkOuter)
{
    CMMCContextMenuProvider *pContextMenuProvider =
                                          New CMMCContextMenuProvider(punkOuter);

    if (NULL == pContextMenuProvider)
    {
        GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
        return NULL;
    }
    else
    {
        return pContextMenuProvider->PrivateUnknown();
    }
}

CMMCContextMenuProvider::~CMMCContextMenuProvider()
{
    RELEASE(m_piContextMenuProvider);
    RELEASE(m_punkView);
    InitMemberVariables();
}

void CMMCContextMenuProvider::InitMemberVariables()
{
    m_piContextMenuProvider = NULL;
    m_pView = NULL;
    m_punkView = NULL;
}


HRESULT CMMCContextMenuProvider::SetProvider
(
    IContextMenuProvider *piContextMenuProvider,
    CView                *pView
)
{
    HRESULT hr = S_OK;

    RELEASE(m_piContextMenuProvider);
    if (NULL != piContextMenuProvider)
    {
        piContextMenuProvider->AddRef();
    }
    m_piContextMenuProvider = piContextMenuProvider;

    m_pView = pView;
    RELEASE(m_punkView);

    IfFalseGo(NULL != pView, S_OK);

    IfFailGo(pView->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&m_punkView)));
    
Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IMMCContextMenuProvider Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCContextMenuProvider::AddSnapInItems(VARIANT Objects)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    IDataObject *piDataObject = NULL;

    if ( (NULL == m_piContextMenuProvider) || (NULL == m_punkView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    hr = m_piContextMenuProvider->AddPrimaryExtensionItems(m_punkView,
                                                           piDataObject);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCContextMenuProvider::AddExtensionItems(VARIANT Objects)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    IDataObject *piDataObject = NULL;

    if (NULL == m_piContextMenuProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    hr = m_piContextMenuProvider->AddThirdPartyExtensionItems(piDataObject);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCContextMenuProvider::ShowContextMenu
(
    VARIANT     Objects,
    OLE_HANDLE  hwnd,
    long        xPos,
    long        yPos
)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    long         lSelected = 0;
    IDataObject *piDataObject = NULL;

    if ( (NULL == m_piContextMenuProvider) || (NULL == m_pView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piContextMenuProvider->ShowContextMenu(reinterpret_cast<HWND>(hwnd),
                                                  xPos, yPos, &lSelected);
    EXCEPTION_CHECK_GO(hr);

    IfFalseGo(0 != lSelected, S_OK);

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    IfFailGo(m_pView->Command(lSelected, piDataObject));

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCContextMenuProvider::Clear()
{
    HRESULT       hr = S_OK;

    if (NULL == m_piContextMenuProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piContextMenuProvider->EmptyMenuList();
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCContextMenuProvider::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCContextMenuProvider == riid)
    {
        *ppvObjOut = static_cast<IMMCContextMenuProvider *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmts.cpp ===
//=--------------------------------------------------------------------------=
// datafmts.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormats class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "datafmts.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CDataFormats::CDataFormats(IUnknown *punkOuter) :
    CSnapInCollection<IDataFormat, DataFormat, IDataFormats>(punkOuter,
                                           OBJECT_TYPE_DATAFORMATS,
                                           static_cast<IDataFormats *>(this),
                                           static_cast<CDataFormats *>(this),
                                           CLSID_DataFormat,
                                           OBJECT_TYPE_DATAFORMAT,
                                           IID_IDataFormat,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_DataFormats,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CDataFormats::~CDataFormats()
{
}

IUnknown *CDataFormats::Create(IUnknown * punkOuter)
{
    CDataFormats *pMMCMenus = New CDataFormats(punkOuter);
    if (NULL == pMMCMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCMenus->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IDataFormats Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CDataFormats::Add
(
    VARIANT       Index,
    VARIANT       Key,
    VARIANT       FileName,
    IDataFormat **ppiDataFormat
)
{
    HRESULT      hr = S_OK;
    IDataFormat *piDataFormat = NULL;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    // Add the item to the collection.

    hr = CSnapInCollection<IDataFormat, DataFormat, IDataFormats>::Add(Index,
                                                           Key,
                                                           &piDataFormat);
    IfFailGo(hr);

    // If a file name was specified then set it

    if (ISPRESENT(FileName))
    {
        hr = ::VariantChangeType(&varCoerced, &FileName, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piDataFormat->put_FileName(varCoerced.bstrVal));
    }

    *ppiDataFormat = piDataFormat;
    
Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piDataFormat);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormats::Persist()
{
    HRESULT      hr = S_OK;
    IDataFormat *piDataFormat = NULL;

    // Do persistence operation

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IDataFormat, DataFormat, IDataFormats>::Persist(piDataFormat);
    IfFailGo(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CDataFormats::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IDataFormats == riid)
    {
        *ppvObjOut = static_cast<IDataFormats *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IDataFormat, DataFormat, IDataFormats>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmt.h ===
//=--------------------------------------------------------------------------=
// datafmt.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormat class definition
//
// Not used. Was going to encapulate use of XML to describe exported data formats
//=--------------------------------------------------------------------------=

#ifndef _DATAFMT_DEFINED_
#define _DATAFMT_DEFINED_


class CDataFormat : public CSnapInAutomationObject,
                    public CPersistence,
                    public IDataFormat
{
    private:
        CDataFormat(IUnknown *punkOuter);
        ~CDataFormat();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IDataFormat
        BSTR_PROPERTY_RW(CDataFormat,    Name,                      DISPID_DATAFORMAT_NAME);
        SIMPLE_PROPERTY_RW(CDataFormat,  Index,    long,            DISPID_DATAFORMAT_INDEX);
        BSTR_PROPERTY_RW(CDataFormat,    Key,                       DISPID_DATAFORMAT_KEY);
        BSTR_PROPERTY_RW(CDataFormat,    FileName,                  DISPID_DATAFORMAT_FILENAME);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(DataFormat,                  // name
                                &CLSID_DataFormat,           // clsid
                                "DataFormat",                // objname
                                "DataFormat",                // lblname
                                &CDataFormat::Create,        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IDataFormat,            // dispatch IID
                                NULL,                        // no event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _DATAFMT_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\datafmts.h ===
//=--------------------------------------------------------------------------=
// datafmts.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CDataFormats class definition
//
// Not used. Was going to encapulate use of XML to describe exported data formats
//=--------------------------------------------------------------------------=

#ifndef _DATAFMTS_DEFINED_
#define _DATAFMTS_DEFINED_

#include "collect.h"

class CDataFormats : public CSnapInCollection<IDataFormat, DataFormat, IDataFormats>,
                     public CPersistence
{
    protected:
        CDataFormats(IUnknown *punkOuter);
        ~CDataFormats();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IDataFormats
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, VARIANT FileName, IDataFormat **ppiDataFormat);

    // CPersistence overrides
    protected:
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(DataFormats,              // name
                                &CLSID_DataFormats,       // clsid
                                "DataFormats",            // objname
                                "DataFormats",            // lblname
                                &CDataFormats::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IDataFormats,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _DATAFMTS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobj.cpp ===
//=--------------------------------------------------------------------------=
// dataobj.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObject class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "dataobj.h"
#include "xtensons.h"
#include "xtenson.h"

// for ASSERT and FAIL
//
SZTHISFILE

BOOL CMMCDataObject::m_ClipboardFormatsRegistered = FALSE;
BOOL CMMCDataObject::m_fUsingUNICODEFormats = FALSE;

CLIPFORMAT CMMCDataObject::m_cfDisplayName              = 0;
CLIPFORMAT CMMCDataObject::m_cfNodeType                 = 0;
CLIPFORMAT CMMCDataObject::m_cfSzNodeType               = 0;
CLIPFORMAT CMMCDataObject::m_cfSnapinClsid              = 0;
CLIPFORMAT CMMCDataObject::m_cfWindowTitle              = 0;
CLIPFORMAT CMMCDataObject::m_cfDyanmicExtensions        = 0;
CLIPFORMAT CMMCDataObject::m_cfSnapInPreloads           = 0;
CLIPFORMAT CMMCDataObject::m_cfObjectTypesInMultiSelect = 0;
CLIPFORMAT CMMCDataObject::m_cfMultiSelectSnapIns       = 0;
CLIPFORMAT CMMCDataObject::m_cfMultiSelectDataObject    = 0;
CLIPFORMAT CMMCDataObject::m_cfSnapInInstanceID         = 0;
CLIPFORMAT CMMCDataObject::m_cfThisPointer              = 0;
CLIPFORMAT CMMCDataObject::m_cfNodeID                   = 0;
CLIPFORMAT CMMCDataObject::m_cfNodeID2                  = 0;
CLIPFORMAT CMMCDataObject::m_cfColumnSetID              = 0;

#if defined(DEBUG)
long g_cDataObjects = 0;
#endif


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCDataObject::CMMCDataObject(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCDATAOBJECT,
                            static_cast<IMMCDataObject *>(this),
                            static_cast<CMMCDataObject *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
#if defined(DEBUG)
    g_cDataObjects++;
#endif
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCDataObject::~CMMCDataObject()
{
#if defined(DEBUG)
    g_cDataObjects--;
#endif

    FREESTRING(m_bstrKey);

#if defined(USING_SNAPINDATA)
    RELEASE(m_piDefaultFormat);
#endif

    if (NULL != m_pSnapIn)
    {
        m_pSnapIn->Release();
    }

    if (NULL != m_pScopeItems)
    {
        m_pScopeItems->Release();
    }

    if (NULL != m_pScopeItem)
    {
        m_pScopeItem->Release();
    }

    if (NULL != m_pListItems)
    {
        m_pListItems->Release();
    }

    if (NULL != m_pListItem)
    {
        m_pListItem->Release();
    }

    FREESTRING(m_bstrCaption);
    RELEASE(m_piDataObjectForeign);

    if (NULL != m_pMMCObjectTypes)
    {
        ::CtlFree(m_pMMCObjectTypes);
    }

    (void)Clear();

    InitMemberVariables();
}

void CMMCDataObject::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

#if defined(USING_SNAPINDATA)
    m_piDefaultFormat = NULL;
#endif

    m_pSnapIn = NULL;
    m_pScopeItems = NULL;
    m_pScopeItem = NULL;
    m_pListItems = NULL;
    m_pListItem = NULL;
    m_bstrCaption = NULL;
    m_piDataObjectForeign = NULL;
    m_Type = ScopeItem;
    m_Context = CCT_UNINITIALIZED;
    m_pMMCObjectTypes = NULL;
    m_cFormats = 0;
    m_pcfFormatsANSI = NULL;
    m_pcfFormatsUNICODE = NULL;
    m_paData = NULL;
}

IUnknown *CMMCDataObject::Create(IUnknown * punkOuter)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = New CMMCDataObject(punkOuter);

    if (NULL == pMMCDataObject)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(RegisterClipboardFormats());

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCDataObject)
        {
            delete pMMCDataObject;
        }
        return NULL;
    }
    else
    {
        return pMMCDataObject->PrivateUnknown();
    }
}

HRESULT CMMCDataObject::RegisterClipboardFormats()
{
    HRESULT    hr = S_OK;
    FormatType Type = ANSI; // assume Win9x

    OSVERSIONINFO VerInfo;
    ::ZeroMemory(&VerInfo, sizeof(VerInfo));

    // If formats are already registered then return S_OK

    IfFalseGo(!m_ClipboardFormatsRegistered, S_OK);

    // Determine whether we are on NT or Win9x so that we know whether to
    // register clipboard format strings as UNICODE or ANSI.

    VerInfo.dwOSVersionInfoSize = sizeof(VerInfo);
    if (!::GetVersionEx(&VerInfo))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (VER_PLATFORM_WIN32_NT == VerInfo.dwPlatformId)
    {
        Type = UNICODE;
        m_fUsingUNICODEFormats = TRUE;
    }

    IfFailGo(RegisterClipboardFormat(CCF_DISPLAY_NAME, &m_cfDisplayName, Type));
    IfFailGo(RegisterClipboardFormat(CCF_NODETYPE, &m_cfNodeType, Type));
    IfFailGo(RegisterClipboardFormat(CCF_SZNODETYPE, &m_cfSzNodeType, Type));
    IfFailGo(RegisterClipboardFormat(CCF_SNAPIN_CLASSID, &m_cfSnapinClsid, Type));
    IfFailGo(RegisterClipboardFormat(CCF_WINDOW_TITLE, &m_cfWindowTitle, Type));
    IfFailGo(RegisterClipboardFormat(CCF_MMC_DYNAMIC_EXTENSIONS, &m_cfDyanmicExtensions, Type));
    IfFailGo(RegisterClipboardFormat(CCF_SNAPIN_PRELOADS, &m_cfSnapInPreloads, Type));
    IfFailGo(RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT, &m_cfObjectTypesInMultiSelect, Type));
    IfFailGo(RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS, &m_cfMultiSelectSnapIns, Type));
    IfFailGo(RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT, &m_cfMultiSelectDataObject, Type));
    IfFailGo(RegisterClipboardFormat(L"SnapInDesigner-SnapInInstanceID", &m_cfSnapInInstanceID, Type));
    IfFailGo(RegisterClipboardFormat(L"SnapInDesigner-ThisPointer", &m_cfThisPointer, Type));
    IfFailGo(RegisterClipboardFormat(CCF_NODEID, &m_cfNodeID, Type));
    IfFailGo(RegisterClipboardFormat(CCF_NODEID2, &m_cfNodeID2, Type));
    IfFailGo(RegisterClipboardFormat(CCF_COLUMN_SET_ID, &m_cfColumnSetID, Type));
    m_ClipboardFormatsRegistered = TRUE;

Error:
    RRETURN(hr);
}

HRESULT CMMCDataObject::RegisterClipboardFormat
(
    WCHAR       *pwszFormatName,
    CLIPFORMAT  *pcfFormat,
    FormatType   Type
)
{
    HRESULT  hr = S_OK;
    char    *pszFormatName = NULL;

    if (ANSI == Type)
    {
        IfFailGo(::ANSIFromWideStr(pwszFormatName, &pszFormatName));
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatA(pszFormatName));
    }
    else
    {
        *pcfFormat = static_cast<CLIPFORMAT>(::RegisterClipboardFormatW(pwszFormatName));
    }

    if (0 == *pcfFormat)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pszFormatName)
    {
        ::CtlFree(pszFormatName);
    }
    RRETURN(hr);
}


void CMMCDataObject::SetSnapIn(CSnapIn *pSnapIn)
{
    if (NULL != m_pSnapIn)
    {
        m_pSnapIn->Release();
    }
    if (NULL != pSnapIn)
    {
        pSnapIn->AddRef();
    }
    m_pSnapIn = pSnapIn;
}


void CMMCDataObject::SetType(Type type)
{
    m_Type = type;
}

CMMCDataObject::Type CMMCDataObject::GetType()
{
    return m_Type;
}

void CMMCDataObject::SetScopeItems(CScopeItems *pScopeItems)
{
    if (NULL != m_pScopeItems)
    {
        m_pScopeItems->Release();
    }
    if (NULL != pScopeItems)
    {
        pScopeItems->AddRef();
    }
    m_pScopeItems = pScopeItems;
}

CScopeItems *CMMCDataObject::GetScopeItems()
{
    return m_pScopeItems;
}


void CMMCDataObject::SetScopeItem(CScopeItem *pScopeItem)
{
    if (NULL != m_pScopeItem)
    {
        m_pScopeItem->Release();
    }
    if (NULL != pScopeItem)
    {
        pScopeItem->AddRef();
    }
    m_pScopeItem = pScopeItem;
}

CScopeItem *CMMCDataObject::GetScopeItem()
{
    return m_pScopeItem;
}


void CMMCDataObject::SetListItems(CMMCListItems *pListItems)
{
    if (NULL != m_pListItems)
    {
        m_pListItems->Release();
    }
    if (NULL != pListItems)
    {
        pListItems->AddRef();
    }
    m_pListItems = pListItems;
}

CMMCListItems *CMMCDataObject::GetListItems()
{
    return m_pListItems;
}

void CMMCDataObject::SetListItem(CMMCListItem *pListItem)
{
    m_pListItem = pListItem;
}

CMMCListItem *CMMCDataObject::GetListItem()
{
    return m_pListItem;
}


HRESULT CMMCDataObject::SetCaption(BSTR bstrCaption)
{
    RRETURN(CSnapInAutomationObject::SetBstr(bstrCaption, &m_bstrCaption, 0));
}


void CMMCDataObject::SetForeignData(IDataObject *piDataObject)
{
    RELEASE(m_piDataObjectForeign);
    if (NULL != piDataObject)
    {
        piDataObject->AddRef();
    }
    m_piDataObjectForeign = piDataObject;
}


HRESULT CMMCDataObject::WriteDisplayNameToStream(IStream *piStream)
{
    HRESULT hr = S_OK;

    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);
    IfFalseGo(NULL != m_pScopeItem, DV_E_CLIPFORMAT);

    IfFailGo(WriteWideStrToStream(piStream,
                            m_pScopeItem->GetScopeNode()->GetDisplayNamePtr()));
Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteSnapInCLSIDToStream(IStream *piStream)
{
    HRESULT   hr = S_OK;
    WCHAR    *pwszClsid = NULL;
    char      szClsid[256] = "";
    
    IfFalseGo(NULL != m_pSnapIn, DV_E_CLIPFORMAT);

    IfFailGo(::GetSnapInCLSID(m_pSnapIn->GetNodeTypeGUID(),
                              szClsid, sizeof(szClsid)));

    IfFailGo(::WideStrFromANSI(szClsid, &pwszClsid));
    IfFailGo(WriteGUIDToStream(piStream, pwszClsid));

Error:
    if (NULL != pwszClsid)
    {
        ::CtlFree(pwszClsid);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CMMCDataObject::WriteDynamicExtensionsToStream
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IStream *piStream [in] stream to which SMMCDynamicExtensions structure
//                             is written
//
// Output:
//      HRESULT
//
// Notes:
//
// If the data object is not for a scope item or a list item then return
// DV_E_CLIPFORMAT.
//
// If the scope item or list item does not have any dynamic extenions then
// return DV_E_CLIPFORMAT.
//
// Get the DynamicExtensions collection for the scope item or list item and
// write an SMMCDynamicExtensions structure to the stream containing the CLISDs
// of all the enabled extensions.
//
// SMMCDynamicExtensions is typedefed to be an SMMCObjectTypes which looks like
// this:
//
// typedef struct  _SMMCObjectTypes
// {
//     DWORD count;
//     GUID guid[ 1 ];
// } SMMCObjectTypes;
//
// As the array of GUIDs might be padded using the default alignment, when
// writing consecutive CLSIDs to the stream we need to account for that. This
// is done by creating an array of two clsids, filling the first one, and writing
// half the size of the array.
// 
// A note on the choice of using a stream for this format: at the time of this
// writing MMC only requests this format in an HGLOBAL. CMMCDataObject has been
// written to create a stream on an HGLOBAL in a data request in order to
// conveniently support TYMED_ISTREAM and TYMED_HGLOBAL without duplicating code.
// In the case of this format where iterating a collection is required to
// discover the actual size of the data, we could either iterate twice or do
// reallocs. I chose the reallocs for the ease of programming and from a perf
// perspective it is probably close. Given that extending a stream on an
// HGLOBAL consists of reallocs I decided to go for ease and consistency in the
// code rather than the small potential perf increase with the added complexity.
//
// Peter Shier 1-8-99
//

HRESULT CMMCDataObject::WriteDynamicExtensionsToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    long         cExtensions = 0;
    long         i = 0;
    DWORD        cEnabled = 0;
    IExtensions *piExtensions = NULL; // Not AddRef()ed
    CExtensions *pExtensions = NULL;
    CExtension  *pExtension = NULL;

    CLSID clsids[2];
    ::ZeroMemory(clsids, sizeof(clsids));

    LARGE_INTEGER liOffset;
    ::ZeroMemory(&liOffset, sizeof(liOffset));

    ULARGE_INTEGER uliStartSeekPos;
    ::ZeroMemory(&uliStartSeekPos, sizeof(uliStartSeekPos));

    ULARGE_INTEGER uliEndSeekPos;
    ::ZeroMemory(&uliEndSeekPos, sizeof(uliEndSeekPos));

    // Get the IExtensions collection for the object

    if (ScopeItem == m_Type)
    {
        piExtensions = m_pScopeItem->GetDynamicExtensions();
        IfFalseGo(NULL != piExtensions, DV_E_CLIPFORMAT);
    }
    else if (ListItem == m_Type)
    {
        piExtensions = m_pListItem->GetDynamicExtensions();
        IfFalseGo(NULL != piExtensions, DV_E_CLIPFORMAT);
    }
    else
    {
        IfFailGo(DV_E_CLIPFORMAT);
    }

    // Check whether there are any extensions in the collection

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piExtensions, &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(0 != cExtensions, DV_E_CLIPFORMAT); 

    // Get the current seek pointer so that we can later rewind and write the
    // correct number of clsids.

    hr = piStream->Seek(liOffset, STREAM_SEEK_CUR, &uliStartSeekPos);
    EXCEPTION_CHECK_GO(hr);

    // Write a bogus number of enabled extensions so that we can fill it in
    // later

    IfFailGo(WriteToStream(piStream, &cEnabled, sizeof(cEnabled)));

    // Iterate through the collection and use each non-namespace extension
    // that is enabled

    for (i = 0; i < cExtensions; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                   pExtensions->GetItemByIndex(i), &pExtension));

        if (!pExtension->Enabled())
        {
            continue;
        }

        if ( (pExtension->ExtendsContextMenu())   ||
             (pExtension->ExtendsToolbar())       ||
             (pExtension->ExtendsPropertySheet()) ||
             (pExtension->ExtendsTaskpad())
           )
        {
            hr = ::CLSIDFromString(pExtension->GetCLSID(), &clsids[0]);
            EXCEPTION_CHECK_GO(hr);

            // Write the CLSID. Use the clsids array to make sure that we
            // write a correctly padded number of bytes

            IfFailGo(WriteToStream(piStream, &clsids[0], sizeof(clsids) / 2));
            cEnabled++;
        }
    }

    // If none were enabled then don't return the format. Rewind the stream
    // so that is untouched in this case.

    if (0 == cEnabled)
    {
        liOffset.LowPart = uliStartSeekPos.LowPart;
        liOffset.HighPart = uliStartSeekPos.HighPart;

        hr = piStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
        EXCEPTION_CHECK_GO(hr);

        IfFailGo(DV_E_CLIPFORMAT);
    }

    // Some extensions are enabled. We need to write the correct count
    // of enabled extensions at the stream starting point

    // Get the final stream pointer so we can restore it after rewriting the
    // count

    hr = piStream->Seek(liOffset, STREAM_SEEK_CUR, &uliEndSeekPos);
    EXCEPTION_CHECK_GO(hr);

    // Seek back to the starting stream position and write the correct count

    liOffset.LowPart = uliStartSeekPos.LowPart;
    liOffset.HighPart = uliStartSeekPos.HighPart;
    
    hr = piStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
    EXCEPTION_CHECK_GO(hr);

    IfFailGo(WriteToStream(piStream, &cEnabled, sizeof(cEnabled)));

    // Restore the stream pointer to the end of the stream

    liOffset.LowPart = uliEndSeekPos.LowPart;
    liOffset.HighPart = uliEndSeekPos.HighPart;

    hr = piStream->Seek(liOffset, STREAM_SEEK_SET, NULL);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



HRESULT CMMCDataObject::WritePreloadsToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    BOOL    fPreloads = FALSE;

    if (NULL != m_pSnapIn)
    {
        fPreloads = m_pSnapIn->GetPreload();
    }

    IfFailGo(WriteToStream(piStream, &fPreloads, sizeof(fPreloads)));

Error:
    RRETURN(hr);
}



HRESULT CMMCDataObject::WriteSnapInInstanceIDToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    DWORD   SnapInInstanceID = 0;

    if (NULL == m_pSnapIn)
    {
        hr = DV_E_CLIPFORMAT;
    }
    else
    {
        SnapInInstanceID = GetSnapInInstanceID();
        IfFailGo(WriteToStream(piStream, &SnapInInstanceID, sizeof(SnapInInstanceID)));
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteNodeIDToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    BSTR    bstrNodeID = NULL; // Not allocated, do not free

    SNodeID SNodeIDStruct;
    ::ZeroMemory(&SNodeIDStruct, sizeof(SNodeIDStruct));

    // If this is not a single scope item then we don't have the format.
    
    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);

    bstrNodeID = m_pScopeItem->GetNodeID();

    if ( (!m_pScopeItem->SlowRetrieval()) && ValidBstr(bstrNodeID) )
    {
        // The snap-in says this node is not slow to retrieve and has
        // supplied a valid node ID. Return the node ID.

        SNodeIDStruct.cBytes = ::wcslen(bstrNodeID) * sizeof(WCHAR);

        // Note that in order to preserve alignment without having to reallocate
        // a real SNodeID we calculate the actual size of the ID portion of
        // the struct by subtracting the address of the struct from the address
        // of the the ID.
        
        IfFailGo(WriteToStream(piStream, &SNodeIDStruct,
                               (BYTE *)&SNodeIDStruct.id - (BYTE *)&SNodeIDStruct));

        IfFailGo(WriteToStream(piStream, bstrNodeID, SNodeIDStruct.cBytes));
    }
    else
    {
        // The snap-in has either indicated that that the node is slow to
        // retrieve or has set an empty node ID. Return a zero-length node ID.

        IfFailGo(WriteToStream(piStream, &SNodeIDStruct, sizeof(SNodeIDStruct)));
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteNodeID2ToStream(IStream *piStream)
{
    HRESULT hr = S_OK;
    BSTR    bstrNodeID = NULL; // Not allocated, do not free

    SNodeID2 SNodeID2Struct;
    ::ZeroMemory(&SNodeID2Struct, sizeof(SNodeID2Struct));

    // If this is not a single scope item then we don't have the format.

    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);

    bstrNodeID = m_pScopeItem->GetNodeID();

    // If the snap-in has set an empty node ID then we cannot return this
    // format.
    
    IfFalseGo(ValidBstr(bstrNodeID), DV_E_CLIPFORMAT);

    if (m_pScopeItem->SlowRetrieval())
    {
        SNodeID2Struct.dwFlags = MMC_NODEID_SLOW_RETRIEVAL;
    }

    SNodeID2Struct.cBytes = ::wcslen(bstrNodeID) * sizeof(WCHAR);

    // Note that in order to preserve alignment without having to reallocate
    // a real SNodeID we calculate the actual size of the ID portion of
    // the struct by subtracting the address of the struct from the address
    // of the the ID.

    IfFailGo(WriteToStream(piStream, &SNodeID2Struct,
                           (BYTE *)&SNodeID2Struct.id - (BYTE *)&SNodeID2Struct));

    IfFailGo(WriteToStream(piStream, bstrNodeID, SNodeID2Struct.cBytes));

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteColumnSetIDToStream(IStream *piStream)
{
    HRESULT          hr = S_OK;
    CView           *pCurrentView = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    IScopePaneItem  *piScopePaneItem = NULL;
    BSTR             bstrColumnSetID = NULL; // Not allocated, do not free

    SNodeID2 SNodeID2Struct;
    ::ZeroMemory(&SNodeID2Struct, sizeof(SNodeID2Struct));

    // If this is not a single scope item then we don't have the format.

    IfFalseGo(ScopeItem == m_Type, DV_E_CLIPFORMAT);

    // The column set ID is obtained from the ScopePaneItem
    // in Views.CurrentView.ScopePaneItems that corresponds to the ScopeItem
    // that owns this data object.

    IfFalseGo(NULL != m_pSnapIn, DV_E_CLIPFORMAT);

    pCurrentView = m_pSnapIn->GetCurrentView();
    IfFalseGo(NULL != pCurrentView, DV_E_CLIPFORMAT);

    pScopePaneItems = pCurrentView->GetScopePaneItems();
    IfFalseGo(NULL != pScopePaneItems, DV_E_CLIPFORMAT);

    // If the ScopePaneItem is not there then create it now because when MMC
    // retrieves this data format it is due to the selection of the ScopeItem
    // in the scope pane or the restoration of the selection following console
    // load.

    hr = pScopePaneItems->GetItemByName(m_pScopeItem->GetNamePtr(),
                                        &piScopePaneItem);
    if (SUCCEEDED(hr))
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem,
                                                       &pScopePaneItem));
    }
    else if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        IfFailGo(pScopePaneItems->AddNode(m_pScopeItem, &pScopePaneItem));
    }
    else
    {
        IfFailGo(hr);
    }

    bstrColumnSetID = pScopePaneItem->GetColumnSetID();

    IfFalseGo(ValidBstr(bstrColumnSetID), DV_E_CLIPFORMAT);

    SNodeID2Struct.cBytes = ::wcslen(bstrColumnSetID) * sizeof(WCHAR);

    // Note that in order to preserve alignment without having to reallocate
    // a real SNodeID2 we calculate the actual size of the ID portion of
    // the struct by subtracting the address of the struct from the address
    // of the member following the ID.

    IfFailGo(WriteToStream(piStream, &SNodeID2Struct,
                          (BYTE *)&SNodeID2Struct.id - (BYTE *)&SNodeID2Struct));

    IfFailGo(WriteToStream(piStream, bstrColumnSetID, SNodeID2Struct.cBytes));

Error:
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}

HRESULT CMMCDataObject::GetOurObjectTypes()
{
    HRESULT          hr = S_OK;
    long             i = 0;
    long             cScopeItems = 0;
    long             cListItems = 0;
    CScopeItem      *pScopeItem = NULL;
    CMMCListItem    *pMMCListItem = NULL;
    CScopeNode      *pScopeNode = NULL;
    GUID             guid = GUID_NULL;
    size_t           cMaxGuids = 0;

    // Determine how many objects we have

    if (NULL != m_pScopeItems)
    {
        cScopeItems = m_pScopeItems->GetCount();
    }

    if (NULL != m_pListItems)
    {
        cListItems = m_pListItems->GetCount();
    }

    // Allocate the SMMCObjectTypes structure using the maximum possible
    // number of GUIDs. After iterating through the items we are holding the
    // real number will be determined and that will be written to the stream.

    cMaxGuids = cScopeItems + cListItems;
    if (cMaxGuids > 0)
    {
        cMaxGuids--; // sub 1 because the structure defines an array of 1
    }

    m_pMMCObjectTypes = (SMMCObjectTypes *)::CtlAllocZero(
        sizeof(*m_pMMCObjectTypes) + cMaxGuids * sizeof(GUID));
    if (NULL == m_pMMCObjectTypes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    for (i = 0; i < cScopeItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
            m_pScopeItems->GetItemByIndex(i), &pScopeItem));
        pScopeNode = pScopeItem->GetScopeNode();
        if (NULL != pScopeNode)
        {
            hr = ::CLSIDFromString(pScopeNode->GetNodeTypeGUID(),
                                   &guid);
            EXCEPTION_CHECK_GO(hr);
            AddGuid(m_pMMCObjectTypes, &guid);
        }
    }

    for (i = 0; i < cListItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
            m_pListItems->GetItemByIndex(i), &pMMCListItem));
        hr = ::CLSIDFromString(pMMCListItem->GetNodeTypeGUID(),
                               &guid);
        EXCEPTION_CHECK_GO(hr);
        AddGuid(m_pMMCObjectTypes, &guid);
    }

Error:
    if ( (FAILED(hr)) && (NULL != m_pMMCObjectTypes) )
    {
        ::CtlFree(m_pMMCObjectTypes);
        m_pMMCObjectTypes = NULL;
    }
    RRETURN(hr);
}


HRESULT CMMCDataObject::GetForeignObjectTypes()
{
    HRESULT          hr = S_OK;
    SMMCObjectTypes *pMMCObjectTypes = NULL;
    BOOL             fGotData = FALSE;
    size_t           cbObjectTypes = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    if (NULL == m_piDataObjectForeign)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    FmtEtc.cfFormat = m_cfObjectTypesInMultiSelect;
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
    if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) )
    {
        hr = SID_E_FORMAT_NOT_AVAILABLE;
    }
    EXCEPTION_CHECK_GO(hr);

    fGotData = TRUE;

    pMMCObjectTypes = (SMMCObjectTypes *)::GlobalLock(StgMed.hGlobal);
    if (NULL == pMMCObjectTypes)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    cbObjectTypes = sizeof(*pMMCObjectTypes) +
                    (pMMCObjectTypes->count * sizeof(GUID)) -
                    sizeof(GUID);

    m_pMMCObjectTypes = (SMMCObjectTypes *)::CtlAllocZero(cbObjectTypes);
    if (NULL == m_pMMCObjectTypes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(m_pMMCObjectTypes, pMMCObjectTypes, cbObjectTypes);

Error:
    if (NULL != pMMCObjectTypes)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ::ReleaseStgMedium(&StgMed);
    }

    RRETURN(hr);
}


HRESULT CMMCDataObject::GetObjectTypes()
{
    HRESULT hr = S_OK;

    if (Foreign == m_Type)
    {
        IfFailGo(GetForeignObjectTypes());
    }
    else
    {
        IfFailGo(GetOurObjectTypes());
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCDataObject::WriteObjectTypesToStream(IStream *piStream)
{
    HRESULT hr = S_OK;

    if (NULL == m_pMMCObjectTypes)
    {
        IfFailGo(GetObjectTypes());
    }

    if (m_pMMCObjectTypes->count > 0)
    {
        IfFailGo(WriteToStream(piStream, m_pMMCObjectTypes,
                          sizeof(*m_pMMCObjectTypes) +
                          sizeof(GUID) * (m_pMMCObjectTypes->count - (DWORD)1)));
    }
    else
    {
        hr = DV_E_CLIPFORMAT;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



void CMMCDataObject::AddGuid(SMMCObjectTypes *pMMCObjectTypes, GUID *pguid)
{
    DWORD i = 0;
    BOOL  fFound = FALSE;

    while ( (i < pMMCObjectTypes->count) && (!fFound) )
    {
        if (pMMCObjectTypes->guid[i] == *pguid)
        {
            fFound = TRUE;
        }
        i++;
    }

    if (!fFound)
    {
        pMMCObjectTypes->guid[pMMCObjectTypes->count] = *pguid;
        pMMCObjectTypes->count++;
    }
}


HRESULT CMMCDataObject::WriteGUIDToStream
(
    IStream *piStream,
    OLECHAR *pwszGUID
)
{
    HRESULT hr = S_OK;
    GUID    guid = GUID_NULL;

    hr = ::CLSIDFromString(pwszGUID, &guid); 
    EXCEPTION_CHECK_GO(hr);

    hr = WriteToStream(piStream, &guid, sizeof(guid));

Error:
    RRETURN(hr);
}



HRESULT CMMCDataObject::WriteWideStrToStream
(
    IStream *piStream,
    WCHAR   *pwszString
)
{
    size_t  cbString = sizeof(WCHAR); // for terminating null

    if (NULL != pwszString)
    {
        cbString += (::wcslen(pwszString) * sizeof(WCHAR));
    }
    else
    {
        pwszString = L"";
    }
    RRETURN(WriteToStream(piStream, pwszString, static_cast<ULONG>(cbString)));
}


HRESULT CMMCDataObject::WriteToStream
(
    IStream *piStream,
    void    *pvBuffer,
    ULONG    cbToWrite
)
{
    ULONG   cbWritten = 0;
    HRESULT hr = piStream->Write(pvBuffer, cbToWrite, &cbWritten);
    EXCEPTION_CHECK_GO(hr);
    if (cbWritten != cbToWrite)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        EXCEPTION_CHECK(hr);
    }
Error:
    RRETURN(hr);
}


DWORD CMMCDataObject::GetSnapInInstanceID()
{
    if (NULL != m_pSnapIn)
    {
        return m_pSnapIn->GetInstanceID();
    }
    else
    {
        return 0;
    }
}


BOOL CMMCDataObject::GetFormatIndex(CLIPFORMAT cfFormat, ULONG *piFormat)
{
    ULONG i = 0;
    BOOL  fFound = FALSE;

    if (NULL != m_pcfFormatsANSI)
    {
        while ( (i < m_cFormats) && (!fFound) )
        {
            if (cfFormat == m_pcfFormatsANSI[i])
            {
                fFound = TRUE;
                *piFormat = i;
            }
            i++;
        }
    }
    if ( (!fFound) && (NULL != m_pcfFormatsUNICODE) )
    {
        while ( (i < m_cFormats) && (!fFound) )
        {
            if (cfFormat == m_pcfFormatsUNICODE[i])
            {
                fFound = TRUE;
                *piFormat = i;
            }
            i++;
        }
    }
    return fFound;
}


HRESULT CMMCDataObject::GetSnapInData(CLIPFORMAT cfFormat, IStream *piStream)
{
    HRESULT   hr = S_OK;
    ULONG     iFormat = 0;
    IUnknown *punkObject = NULL; // Not AddRef()ed

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    // Use a CStreamer object for its ability to write a VARIANT to a stream
    
    CStreamer *pStreamer = New CStreamer();

    if (NULL == pStreamer)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    pStreamer->SetStream(piStream);

    // Check if this is a snap-in defined format
    
    if (!GetFormatIndex(cfFormat, &iFormat))
    {
        hr = DV_E_CLIPFORMAT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Write the data to the stream. For BSTR's and UI1 arrays we don't call
    // CStreamer::StreamVariant() because it prepends the length for a
    // BSTR and it doesn't support arrays.

    switch (m_paData[iFormat].varData.vt)
    {
        case VT_UI1:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_DATE:
        case VT_CY:
            IfFailGo(pStreamer->StreamVariant(m_paData[iFormat].varData.vt,
                                              &m_paData[iFormat].varData,
                                              varDefault));
            break;

        case VT_UNKNOWN:
        case VT_DISPATCH:
            if (siPersistedObject == m_paData[iFormat].ObjectFormat)
            {
                IfFailGo(pStreamer->StreamVariant(m_paData[iFormat].varData.vt,
                                                  &m_paData[iFormat].varData,
                                                  varDefault));
            }
            else
            {
                if (VT_UNKNOWN == m_paData[iFormat].varData.vt)
                {
                    punkObject = m_paData[iFormat].varData.punkVal;
                }
                else
                {
                    punkObject = static_cast<IUnknown *>(m_paData[iFormat].varData.pdispVal);
                }
                hr = ::CoMarshalInterface(piStream,
                                          IID_IUnknown,
                                          punkObject,
                                          MSHCTX_INPROC, NULL,
                                          MSHLFLAGS_NORMAL);
                EXCEPTION_CHECK_GO(hr);
            }
            break;


        case VT_ARRAY | VT_UI1:
            IfFailGo(::WriteSafeArrayToStream(m_paData[iFormat].varData.parray,
                                              piStream,
                                              DontWriteLength));
            break;

        case VT_BSTR:
            IfFailGo(WriteWideStrToStream(piStream,
                                          m_paData[iFormat].varData.bstrVal));
            break;

        case VT_ARRAY | VT_BSTR:
            IfFailGo(WriteStringArrayToStream(piStream,
                                              m_paData[iFormat].varData.parray));
            break;

        default:
            hr = DV_E_CLIPFORMAT;
            EXCEPTION_CHECK_GO(hr);
            break;
    }

Error:
    if (NULL != pStreamer)
    {
        delete pStreamer;
    }
    RRETURN(hr);
}



HRESULT CMMCDataObject::WriteStringArrayToStream
(
    IStream   *piStream,
    SAFEARRAY *psaStrings
)
{
    HRESULT     hr = S_OK;
    LONG        lUBound = 0;
    LONG        lLBound = 0;
    LONG        cStrings = 0;
    LONG        i = 0;
    WCHAR       wchNull = L'\0';
    BSTR HUGEP *pbstr = NULL;

    // Get the upper and lower bounds to determine the number of strings

    hr = ::SafeArrayGetLBound(psaStrings, 1, &lLBound);
    EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(psaStrings, 1, &lUBound);
    EXCEPTION_CHECK_GO(hr);

    cStrings = (lUBound - lLBound) + 1L;

    // Access the array data and write the strings one after the other into
    // the stream

    hr = ::SafeArrayAccessData(psaStrings,
                               reinterpret_cast<void HUGEP **>(&pbstr));
    EXCEPTION_CHECK_GO(hr);

    for (i = 0; i < cStrings; i++)
    {
        IfFailGo(WriteWideStrToStream(piStream, pbstr[i]));
    }

    // Write a terminating null to the stream (giving a double null at the end)

    IfFailGo(WriteToStream(piStream, &wchNull, sizeof(wchNull)));

Error:
    if (NULL != pbstr)
    {
        (void)::SafeArrayUnaccessData(psaStrings);
    }
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                         IMMCDataObject Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCDataObject::get_ObjectTypes(SAFEARRAY **ppsaObjectTypes)
{
    HRESULT     hr = S_OK;
    DWORD       i = 0;
    OLECHAR     wszGUID[64];
    BSTR HUGEP *pbstr = NULL;

    if (NULL == ppsaObjectTypes)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    *ppsaObjectTypes = NULL;

    // First make sure we have the set of unique object types

    if (NULL == m_pMMCObjectTypes)
    {
        IfFailGo(GetObjectTypes());
    }

    // Allocate a SafeArray of BSTRs to hold the object type GUIDs

    *ppsaObjectTypes = ::SafeArrayCreateVector(VT_BSTR, 1,
                           static_cast<unsigned long>(m_pMMCObjectTypes->count));
    if (NULL == *ppsaObjectTypes)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ::SafeArrayAccessData(*ppsaObjectTypes,
                               reinterpret_cast<void HUGEP **>(&pbstr));
    EXCEPTION_CHECK_GO(hr);

    for (i = 0; i < m_pMMCObjectTypes->count; i++)
    {
        if (0 == ::StringFromGUID2(m_pMMCObjectTypes->guid[i], wszGUID,
                                   sizeof(wszGUID) / sizeof (wszGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        pbstr[i] = ::SysAllocString(wszGUID);
        if (NULL == pbstr[i])
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (NULL != pbstr)
    {
        (void)::SafeArrayUnaccessData(*ppsaObjectTypes);
    }

    if (FAILED(hr) && (NULL != *ppsaObjectTypes))
    {
        (void)::SafeArrayDestroy(*ppsaObjectTypes);
        *ppsaObjectTypes = NULL;
    }

    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::Clear()
{
    ULONG i = 0;

    if ( (0 != m_cFormats) && (NULL != m_paData) )
    {
        for (i = 0; i < m_cFormats; i++)
        {
            (void)::VariantClear(&m_paData[i].varData);
        }
        ::CtlFree(m_paData);
        m_paData = NULL;
        m_cFormats = 0;
    }

    if (NULL != m_pcfFormatsANSI)
    {
        ::CtlFree(m_pcfFormatsANSI);
        m_pcfFormatsANSI = NULL;
    }

    if (NULL != m_pcfFormatsUNICODE)
    {
        ::CtlFree(m_pcfFormatsUNICODE);
        m_pcfFormatsUNICODE = NULL;
    }
    return S_OK;
}


#if defined(USING_SNAPINDATA)
STDMETHODIMP CMMCDataObject::GetData
(
    BSTR          Format,
    ISnapInData **ppiSnapInData
)
{
    // UNDONE
    return E_NOTIMPL;
}
#endif


#if defined(USING_SNAPINDATA)
STDMETHODIMP CMMCDataObject::GetRawData
#else
STDMETHODIMP CMMCDataObject::GetData
#endif
(
    BSTR     Format,
    VARIANT  MaximumLength,
    VARIANT *pvarData
)
{
    HRESULT     hr = S_OK;
    ULONG       iFormat = 0;
    BOOL        fGotData = FALSE;
    DWORD       dwSize = 0;
    void       *pvSourceData = NULL;
    void HUGEP *pvArrayData = NULL;
    long        cbMax = 0;
    CLIPFORMAT  cfANSI = 0;
    CLIPFORMAT  cfUNICODE = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    STATSTG StatStg;
    ::ZeroMemory(&StatStg, sizeof(StatStg));

    // Check arguments

    if (NULL == pvarData)
    {
        hr = SID_E_INVALIDARG;
    }
    else
    {
        ::VariantInit(pvarData);
        if (NULL == Format)
        {
            hr = SID_E_INVALIDARG;
        }
        else if (ISPRESENT(MaximumLength))
        {
            hr = ::ConvertToLong(MaximumLength, &cbMax);
            if (S_FALSE == hr)
            {
                hr = SID_E_INVALIDARG;
            }
        }
    }
    EXCEPTION_CHECK_GO(hr);

    // Get the clipformat

    IfFailGo(RegisterClipboardFormat(Format, &cfANSI, ANSI));
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(RegisterClipboardFormat(Format, &cfUNICODE, UNICODE));
    }

    // If this is one of our own data objects then find the format and
    // copy the VARIANT

    if (Foreign != m_Type)
    {
        if (!GetFormatIndex(cfANSI, &iFormat))
        {
            hr = SID_E_FORMAT_NOT_AVAILABLE;
            EXCEPTION_CHECK_GO(hr);
        }
        hr = ::VariantCopy(pvarData, &m_paData[iFormat].varData);
        EXCEPTION_CHECK_GO(hr);
        goto Cleanup;
    }

    // This is a foreign data object. Need to request the data and copy it
    // to a SafeArray of Byte within the returned variant

    if (NULL == m_piDataObjectForeign)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }


    // Get the data from the foreign data object.
    // If maximum length is specified then do GetDataHere(TYMED_HGLOBAL)
    // Else try in this order:
    //  GetData(TYMED_HGLOBAL)
    //  GetData(TYMED_ISTREAM)
    //  GetDataHere(TYMED_ISTREAM)
    //  GetDataHere(TYMED_HGLOBAL) with a 1K buffer
    //
    // In all cases, if on a UNICODE system (NT4, Win2K) then try both ANSI
    // and UNICODE CLIPFORMATs as we have no way of knowing how the snap-in
    // registers its format.

    FmtEtc.cfFormat = cfANSI;
    FmtEtc.dwAspect = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    if (0 != cbMax)
    {
        StgMed.hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, cbMax);
        if (NULL == StgMed.hGlobal)
        {
            hr = HRESULT_FROM_WIN32(hr);
            EXCEPTION_CHECK_GO(hr);
        }
        hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
        if (FAILED(hr) && m_fUsingUNICODEFormats)
        {
            FmtEtc.cfFormat = cfUNICODE;
            hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
        }
        EXCEPTION_CHECK_GO(hr);
        goto CopyData;
    }

    // No maximum length. Try the options listed above. Start with
    // GetData(TYMED_HGLOBAL)
    
    hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
    if (FAILED(hr) && m_fUsingUNICODEFormats)
    {
        FmtEtc.cfFormat = cfUNICODE;
        hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
    }
    if (FAILED(hr))
    {
        // GetData(TYMED_HGLOBAL) didn't work. Try GetData(TYMED_ISTREAM).

        FmtEtc.tymed = TYMED_ISTREAM;
        StgMed.tymed = TYMED_ISTREAM;

        FmtEtc.cfFormat = cfANSI;
        hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
        if (FAILED(hr) && m_fUsingUNICODEFormats)
        {
            FmtEtc.cfFormat = cfUNICODE;
            hr = m_piDataObjectForeign->GetData(&FmtEtc, &StgMed);
        }
        if (FAILED(hr))
        {
            // GetData(TYMED_ISTREAM) didn't work.
            // Try GetDataHere(TYMED_ISTREAM)

            hr = ::CreateStreamOnHGlobal(NULL, // stream should allocate buffer
                                         TRUE, // stream should free buffer on release
                                         &StgMed.pstm);
            EXCEPTION_CHECK_GO(hr);

            FmtEtc.cfFormat = cfANSI;
            hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
            if (FAILED(hr) && m_fUsingUNICODEFormats)
            {
                FmtEtc.cfFormat = cfUNICODE;
                hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
            }
            if (FAILED(hr))
            {
                // GetDataHere(TYMED_ISTREAM) didn't work.
                // Try GetDataHere(TYMED_HGLOBAL) with a 1K buffer

                StgMed.pstm->Release();
                StgMed.pstm = NULL;

                StgMed.hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT,
                                               1024);
                if (NULL == StgMed.hGlobal)
                {
                    hr = HRESULT_FROM_WIN32(hr);
                    EXCEPTION_CHECK_GO(hr);
                }

                FmtEtc.tymed = TYMED_HGLOBAL;
                StgMed.tymed = TYMED_HGLOBAL;

                FmtEtc.cfFormat = cfANSI;
                hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
                if (FAILED(hr) && m_fUsingUNICODEFormats)
                {
                    FmtEtc.cfFormat = cfUNICODE;
                    hr = m_piDataObjectForeign->GetDataHere(&FmtEtc, &StgMed);
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
    }

    // At this point we have the data and it is either in TYMED_HGLOBAL
    // or TYMED_ISTREAM. First we need to determine how big it is.

CopyData:

    if (TYMED_HGLOBAL == StgMed.tymed)
    {
        dwSize = ::GlobalSize(StgMed.hGlobal);
        if (0 == dwSize)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else if (TYMED_ISTREAM == StgMed.tymed)
    {
        hr = StgMed.pstm->Stat(&StatStg, STATFLAG_NONAME);
        EXCEPTION_CHECK_GO(hr);

        if (0 != StatStg.cbSize.HighPart)
        {
            hr = SID_E_DATA_TOO_LARGE;
            EXCEPTION_CHECK_GO(hr);
        }
        dwSize = StatStg.cbSize.LowPart;
    }
    else
    {
        hr = SID_E_UNSUPPORTED_TYMED;
        EXCEPTION_CHECK_GO(hr);
    }

    // Create the SafeArray and get a pointer to its data buffer

    pvarData->parray = ::SafeArrayCreateVector(VT_UI1, 1,
                                           static_cast<unsigned long>(dwSize));
    if (NULL == pvarData->parray)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    pvarData->vt = VT_ARRAY | VT_UI1;

    hr = ::SafeArrayAccessData(pvarData->parray, &pvArrayData);
    EXCEPTION_CHECK_GO(hr);

    // Get access to the data and copy it to the SafeArray data buffer

    if (TYMED_HGLOBAL == StgMed.tymed)
    {
        pvSourceData = ::GlobalLock(StgMed.hGlobal);
        if (NULL == pvSourceData)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        ::memcpy(pvArrayData, pvSourceData, static_cast<size_t>(dwSize));
    }
    else
    {
        hr = StgMed.pstm->Read(pvArrayData, dwSize, NULL);
        EXCEPTION_CHECK_GO(hr);
    }

Cleanup:
Error:
    if (NULL != pvSourceData)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(pvarData->parray);
    }

    ::ReleaseStgMedium(&StgMed);

    if ( FAILED(hr) && ((VT_ARRAY | VT_UI1) == pvarData->vt) )
    {
        
        (void)::VariantClear(pvarData);
    }

    RRETURN(hr);
}



STDMETHODIMP CMMCDataObject::GetFormat
(
    BSTR          Format,
    VARIANT_BOOL *pfvarHaveFormat
)
{
    HRESULT    hr = S_OK;
    ULONG      iFormat = 0;
    CLIPFORMAT cfANSI = 0;
    CLIPFORMAT cfUNICODE = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));


    if ( (NULL == Format) || (NULL == pfvarHaveFormat) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarHaveFormat = VARIANT_FALSE;

    // Get the clipformat

    IfFailGo(RegisterClipboardFormat(Format, &cfANSI, ANSI));
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(RegisterClipboardFormat(Format, &cfUNICODE, UNICODE));
    }

    if (Foreign != m_Type)
    {
        if (GetFormatIndex(cfANSI, &iFormat))
        {
            *pfvarHaveFormat = VARIANT_TRUE;
        }
        goto Cleanup;
    }

    // This is a foreign data object. Need to query it for the format. We
    // query only for IStream because we get all foreign data that way.

    if (NULL == m_piDataObjectForeign)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    
    FmtEtc.cfFormat = cfANSI;
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_ISTREAM;

    // Query the data object

    hr = m_piDataObjectForeign->QueryGetData(&FmtEtc);
    if (FAILED(hr) && m_fUsingUNICODEFormats)
    {
        FmtEtc.cfFormat = cfUNICODE;
        hr = m_piDataObjectForeign->QueryGetData(&FmtEtc);
    }
    if (SUCCEEDED(hr))
    {
        *pfvarHaveFormat = VARIANT_TRUE;
    }
    else if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) )
    {
        hr = S_OK; // not an error, the format just isn't available.
    }
    else
    {
        EXCEPTION_CHECK_GO(hr);
    }

Cleanup:
Error:

    RRETURN(hr);
}



#if defined(USING_SNAPINDATA)

STDMETHODIMP CMMCDataObject::SetData
(
    ISnapInData *Data,
    BSTR         Format
)
{
    // UNDONE
    return E_NOTIMPL;
}
#endif


#if defined(USING_SNAPINDATA)
STDMETHODIMP CMMCDataObject::SetRawData
#else
STDMETHODIMP CMMCDataObject::SetData
#endif
(
    VARIANT Data,
    BSTR    Format,
    VARIANT ObjectFormat
)
{
    HRESULT     hr = S_OK;
    ULONG       iFormat = 0;
    CLIPFORMAT  cfANSI = 0;
    CLIPFORMAT  cfUNICODE = 0;
    DATA       *paData = NULL;
    long        lObjectFormat = 0;
    BOOL        fIsObject = FALSE;

    SnapInObjectFormatConstants  eObjectFormat = siObjectReference;

    // Make sure we received format

    if (NULL == Format)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the data is an object then check if we received the ObjectFormat
    // parameter that tells us how to respond to IDataObject::GetData

    if (::IsObject(Data))
    {
        fIsObject = TRUE;
        if (ISPRESENT(ObjectFormat))
        {
            if (S_OK != ::ConvertToLong(ObjectFormat, &lObjectFormat))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }

            if (siObjectReference == static_cast<SnapInObjectFormatConstants>(lObjectFormat))
            {
                eObjectFormat = siObjectReference;
            }
            else if (siPersistedObject == static_cast<SnapInObjectFormatConstants>(lObjectFormat))
            {
                eObjectFormat = siPersistedObject;
            }
            else
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
        }
    }

    // Make sure data contains a data type we support

    switch (Data.vt)
    {
        case VT_UI1:
        case VT_I4:
        case VT_I2:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_DATE:
        case VT_CY:
        case VT_BSTR:
        case VT_UNKNOWN:
        case VT_DISPATCH:
            break;

        case VT_ARRAY | VT_UI1:
        case VT_ARRAY | VT_BSTR:
            if (1 != ::SafeArrayGetDim(Data.parray))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            break;

        default:
            hr = SID_E_INVALID_RAW_DATA_TYPE;
            EXCEPTION_CHECK_GO(hr);
    }

    // Check whether the format is already present. If so we need to replace it.

    IfFailGo(RegisterClipboardFormat(Format, &cfANSI, ANSI));
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(RegisterClipboardFormat(Format, &cfUNICODE, UNICODE));
    }

    if (GetFormatIndex(cfANSI, &iFormat))
    {
        // VariantCopy() will call VariantClear() on the destination before
        // copying so we don't need to explicitly do that to the old data.

        hr = ::VariantCopy(&m_paData[iFormat].varData, &Data);
        m_paData[iFormat].ObjectFormat = eObjectFormat;
        EXCEPTION_CHECK_GO(hr);
        goto Cleanup;
    }

    // Format is not present. Need to reallocate arrays.
    // Make room for format name and copy it.

    IfFailGo(ReallocFormats(&m_pcfFormatsANSI));
    m_pcfFormatsANSI[m_cFormats] = cfANSI;
    if (m_fUsingUNICODEFormats)
    {
        IfFailGo(ReallocFormats(&m_pcfFormatsUNICODE));
        m_pcfFormatsUNICODE[m_cFormats] = cfUNICODE;
    }

    m_pcfFormatsANSI[m_cFormats] = cfANSI;

    // Make room for data and copy it.

    if (NULL == m_paData)
    {
        paData = (DATA *)::CtlAllocZero(static_cast<DWORD>(sizeof(DATA)));
    }
    else
    {
        paData = (DATA *)::CtlReAllocZero(m_paData,
                           static_cast<DWORD>((m_cFormats + 1) * sizeof(DATA)));
    }

    if (NULL == paData)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    m_paData = paData;
    ::VariantInit(&m_paData[m_cFormats].varData);
    m_paData[m_cFormats].ObjectFormat = siObjectReference;

    m_cFormats++; // increment here so further SetData calls will
                  // have correct data array size even if VariantCopy() fails

    hr = ::VariantCopy(&m_paData[m_cFormats - 1].varData, &Data);
    EXCEPTION_CHECK_GO(hr);
    m_paData[m_cFormats - 1].ObjectFormat = eObjectFormat;

Cleanup:
Error:

    RRETURN(hr);
}


HRESULT CMMCDataObject::ReallocFormats(CLIPFORMAT **ppcfFormats)
{
    HRESULT     hr = S_OK;
    CLIPFORMAT *pcfFormats = NULL;

    if (NULL == *ppcfFormats)
    {
        pcfFormats = (CLIPFORMAT *)::CtlAllocZero(
                                       static_cast<DWORD>(sizeof(CLIPFORMAT)));
    }
    else
    {
        pcfFormats = (CLIPFORMAT *)::CtlReAllocZero(*ppcfFormats,
                    static_cast<DWORD>((m_cFormats + 1) * sizeof(CLIPFORMAT)));
    }

    if (NULL == pcfFormats)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppcfFormats = pcfFormats;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::FormatData
(
    VARIANT                Data,
    long                   StartingIndex,
    SnapInFormatConstants  Format,
    VARIANT               *BytesUsed,
    VARIANT               *pvarFormattedData
)
{
    HRESULT hr = S_OK;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(m_pSnapIn->FormatData(Data, StartingIndex, Format, BytesUsed,
                                   pvarFormattedData));
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IDataObject Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CMMCDataObject::GetData
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium
)
{
    HRESULT    hr = S_OK;
    HGLOBAL    hGlobal = NULL;
    IStream   *piStream = NULL;
    FORMATETC  FmtEtc = *pFormatEtc;
    STGMEDIUM  StgMed = *pmedium;

    // We only support stream and HGLOBAL for GetData

    IfFalseGo( ((TYMED_ISTREAM == pFormatEtc->tymed) ||
                (TYMED_HGLOBAL == pFormatEtc->tymed)), DV_E_TYMED);

    // Create a stream and call GetDataHere() to do the actual work
    
    hr = ::CreateStreamOnHGlobal(NULL,
                                 FALSE, // don't free buffer on final release
                                 &piStream);
    EXCEPTION_CHECK_GO(hr);

    FmtEtc.tymed = TYMED_ISTREAM;
    StgMed.tymed = TYMED_ISTREAM;
    StgMed.pstm = piStream;

    IfFailGo(GetDataHere(&FmtEtc, &StgMed));

    // We have the data. Now return it in the requested format.

    if (TYMED_ISTREAM == pFormatEtc->tymed)
    {
        piStream->AddRef();
        pmedium->tymed = TYMED_ISTREAM;
        pmedium->pstm = piStream;
    }
    else
    {
        // TYMED_HGLOBAL - need to get the HGLOBAL from the stream.

        hr = ::GetHGlobalFromStream(piStream, &hGlobal);
        EXCEPTION_CHECK_GO(hr);

        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = hGlobal;
    }

Error:
    if ( FAILED(hr) && (NULL != piStream) )
    {
        // Need to free the memory because we specified don't free on final
        // release above

        if (SUCCEEDED(::GetHGlobalFromStream(piStream, &hGlobal)))
        {
            (void)::GlobalFree(hGlobal);
        }
    }
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}



STDMETHODIMP CMMCDataObject::GetDataHere
(
    FORMATETC *pFormatEtc,
    STGMEDIUM *pmedium
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pThis = this;
    IStream        *piStream = NULL;
    BSTR            bstrNodeTypeGUID = NULL; // Not allocated, don't free

    // If this data object is not connected to the snap-in then we can't
    // suppply the data. This error code is a lie but we don't want to cause
    // gyrations within MMC due to an unexpected return code here. If the format
    // is required for the operation and we return FORMATETC MMC will
    // abort the operation.
    
    IfFalseGo(NULL != m_pSnapIn, DV_E_CLIPFORMAT);

    // We only support stream and HGLOBAL for GetDataHere

    IfFalseGo( ((TYMED_ISTREAM == pFormatEtc->tymed) ||
                (TYMED_HGLOBAL == pFormatEtc->tymed)), DV_E_TYMED);

    // Either way get an IStream pointer to work with

    if (TYMED_HGLOBAL == pFormatEtc->tymed)
    {
        IfFalseGo(NULL != pmedium->hGlobal, E_INVALIDARG);
        hr = ::CreateStreamOnHGlobal(pmedium->hGlobal,
                                     FALSE, // don't free buffer on final release
                                     &piStream);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        IfFalseGo(NULL != pmedium->pstm, E_INVALIDARG);
        piStream = pmedium->pstm;

        // AddRef so release at func exit will be OK for both stream & HGLOBAL
        piStream->AddRef(); 
    }

    // Check the format and write the data to the stream

    if (pFormatEtc->cfFormat == m_cfDisplayName)
    {
        IfFailGo(WriteDisplayNameToStream(piStream));
    }
    else if ( (pFormatEtc->cfFormat == m_cfNodeType) ||
              (pFormatEtc->cfFormat == m_cfSzNodeType) )
    {
        if (ScopeItem == m_Type)
        {
            if (m_pScopeItem->IsStaticNode())
            {
                bstrNodeTypeGUID = m_pSnapIn->GetNodeTypeGUID();
            }
            else
            {
                bstrNodeTypeGUID = m_pScopeItem->GetScopeNode()->GetNodeTypeGUID();
            }
        }
        else if (ListItem == m_Type)
        {
            bstrNodeTypeGUID = m_pListItem->GetNodeTypeGUID();
        }
        else
        {
            hr = DV_E_CLIPFORMAT;
        }

        if (SUCCEEDED(hr))
        {
            if (pFormatEtc->cfFormat == m_cfNodeType)
            {
                IfFailGo(WriteGUIDToStream(piStream, bstrNodeTypeGUID));
            }
            else
            {
                IfFailGo(WriteWideStrToStream(piStream, bstrNodeTypeGUID));
            }
        }
    }
    else if (pFormatEtc->cfFormat == m_cfSnapinClsid)
    {
        IfFailGo(WriteSnapInCLSIDToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfDyanmicExtensions)
    {
        IfFailGo(WriteDynamicExtensionsToStream(piStream));
    }
    else if ( (pFormatEtc->cfFormat == m_cfWindowTitle) &&
              (NULL != m_bstrCaption) )
    {
        IfFailGo(WriteWideStrToStream(piStream, m_bstrCaption));
    }
    else if (pFormatEtc->cfFormat == m_cfSnapInPreloads)
    {
        IfFailGo(WritePreloadsToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfObjectTypesInMultiSelect)
    {
        IfFailGo(WriteObjectTypesToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfSnapInInstanceID)
    {
        IfFailGo(WriteSnapInInstanceIDToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfThisPointer)
    {
        IfFailGo(WriteToStream(piStream, &pThis, sizeof(this)));
    }
    else if (pFormatEtc->cfFormat == m_cfNodeID)
    {
        IfFailGo(WriteNodeIDToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfNodeID2)
    {
        IfFailGo(WriteNodeID2ToStream(piStream));
    }
    else if (pFormatEtc->cfFormat == m_cfColumnSetID)
    {
        IfFailGo(WriteColumnSetIDToStream(piStream));
    }
    else
    {
        IfFailGo(GetSnapInData(pFormatEtc->cfFormat, piStream));
    }

Error:
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::QueryGetData(FORMATETC *pFormatEtc)
{
    HRESULT hr = DV_E_CLIPFORMAT;
    ULONG   iFormat = 0;

    try
    {
        IfFalseGo( ((TYMED_ISTREAM == pFormatEtc->tymed) ||
                    (TYMED_HGLOBAL == pFormatEtc->tymed)), DV_E_FORMATETC);

        if ( (pFormatEtc->cfFormat == m_cfDisplayName)              ||
             (pFormatEtc->cfFormat == m_cfNodeType)                 ||
             (pFormatEtc->cfFormat == m_cfSzNodeType)               ||
             (pFormatEtc->cfFormat == m_cfSnapinClsid)              ||
             (pFormatEtc->cfFormat == m_cfSnapInPreloads)           ||
             (pFormatEtc->cfFormat == m_cfObjectTypesInMultiSelect) ||
             (pFormatEtc->cfFormat == m_cfNodeID)                   ||

             ( (pFormatEtc->cfFormat == m_cfColumnSetID) &&
               (ScopeItem == m_Type) )                              ||

              ( (pFormatEtc->cfFormat == m_cfWindowTitle) &&
                (NULL != m_bstrCaption) )                           ||

             (GetFormatIndex(pFormatEtc->cfFormat, &iFormat))
           )
        {
            hr = S_OK;
        }
        else if (pFormatEtc->cfFormat == m_cfDyanmicExtensions)
        {
            if (ScopeItem == m_Type)
            {
                if (NULL != m_pScopeItem->GetDynamicExtensions())
                {
                    hr = S_OK;
                }
            }
            else if (ListItem == m_Type)
            {
                if (NULL != m_pListItem->GetDynamicExtensions())
                {
                    hr = S_OK;
                }
            }
        }
    }
    catch(...)
    {
        hr = E_INVALIDARG;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCDataObject::GetCanonicalFormatEtc
(
    FORMATETC *pformatectIn,
    FORMATETC *pformatetcOut
)
{
    return E_NOTIMPL;
}


STDMETHODIMP CMMCDataObject::SetData
(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL       fRelease
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMMCDataObject::EnumFormatEtc
(
    DWORD            dwDirection,
    IEnumFORMATETC **ppenumFormatEtc
)
{
    return E_NOTIMPL;
}


STDMETHODIMP CMMCDataObject::DAdvise
(
    FORMATETC   *pformatetc,
    DWORD        advf,
    IAdviseSink *pAdvSink,
    DWORD       *pdwConnection
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMMCDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMMCDataObject::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCDataObject::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCDataObject == riid)
    {
        *ppvObjOut = static_cast<IMMCDataObject *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IDataObject == riid)
    {
        *ppvObjOut = static_cast<IDataObject *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobj.h ===
//=--------------------------------------------------------------------------=
// dataobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObject class definition - implements MMCDataObject
//
//=--------------------------------------------------------------------------=

#ifndef _DATAOBJECT_DEFINED_
#define _DATAOBJECT_DEFINED_

#include "snapin.h"
#include "scopitem.h"
#include "listitem.h"

class CSnapIn;
class CScopeItem;
class CMMCListItem;

//=--------------------------------------------------------------------------=
//
// class CMMCDataObject
//
// Implements MMCDataObject for VB and implements IDataObject for external
// clients (MMC and extension snap-ins)
//
// Note: all of the #if defined(USING_SNAPINDATA) code is not used. That was
// from an old plan to have default data formats and use XML to describe them.
//=--------------------------------------------------------------------------=
class CMMCDataObject : public CSnapInAutomationObject,
                       public IMMCDataObject,
                       public IDataObject
{
    public:
        CMMCDataObject(IUnknown *punkOuter);
        ~CMMCDataObject();
        static IUnknown *Create(IUnknown *punkOuter);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    private:

    // IDataObject
        STDMETHOD(GetData)(FORMATETC *pFormatEtcIn, STGMEDIUM *pmedium);
        STDMETHOD(GetDataHere)(FORMATETC *pFormatEtc, STGMEDIUM *pmedium);
        STDMETHOD(QueryGetData)(FORMATETC *pFormatEtc);
        STDMETHOD(GetCanonicalFormatEtc)(FORMATETC *pFormatEtcIn,
                                         FORMATETC *pFormatEtcOut);
        STDMETHOD(SetData)(FORMATETC *pFormatEtc,
                           STGMEDIUM *pmedium,
                           BOOL fRelease);
        STDMETHOD(EnumFormatEtc)(DWORD            dwDirection,
                                 IEnumFORMATETC **ppenumFormatEtc);
        STDMETHOD(DAdvise)(FORMATETC   *pFormatEtc,
                           DWORD        advf,
                           IAdviseSink *pAdvSink,
                           DWORD       *pdwConnection);
        STDMETHOD(DUnadvise)(DWORD dwConnection);
        STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise);


    // IMMCDataObject

        SIMPLE_PROPERTY_RW(CMMCDataObject, Index, long, DISPID_DATAOBJECT_INDEX);
        BSTR_PROPERTY_RW(CMMCDataObject,   Key, DISPID_DATAOBJECT_KEY);

#if defined(USING_SNAPINDATA)
        OBJECT_PROPERTY_RO(CMMCDataObject, DefaultFormat, ISnapInData, DISPID_VALUE);
#endif

        STDMETHOD(get_ObjectTypes)(SAFEARRAY **ppsaObjectTypes);
        STDMETHOD(Clear)();

#if defined(USING_SNAPINDATA)
        STDMETHOD(GetData)(BSTR Format, ISnapInData **ppiSnapInData);
        STDMETHOD(GetRawData)(BSTR Format, VARIANT *pvarData);
#else
        STDMETHOD(GetData)(BSTR     Format,
                           VARIANT  MaximumLength,
                           VARIANT *pvarData);
#endif

        STDMETHOD(GetFormat)(BSTR Format, VARIANT_BOOL *pfvarHaveFormat);

#if defined(USING_SNAPINDATA)
        STDMETHOD(SetData)(ISnapInData *Data, BSTR Format);
        STDMETHOD(SetRawData)(VARIANT Data, BSTR Format);
#else
        STDMETHOD(SetData)(VARIANT Data, BSTR Format, VARIANT ObjectFormat);
#endif
        STDMETHOD(FormatData)(VARIANT                Data,
                              long                   StartingIndex,
                              SnapInFormatConstants  Format,
                              VARIANT               *BytesUsed,
                              VARIANT               *pvarFormattedData);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:

    // Non-interface public methods
        void SetSnapIn(CSnapIn *pSnapIn);
        
        enum Type
        {
            ScopeItem,      // Data object holds a single scope item
            ListItem,       // Data object holds a single list item
            MultiSelect,    // Data object holds multiple list and/or scope items
            Foreign,        // Data object is from another snap-in or from MMC
            WindowTitle,    // Data object holds MMC's CCF_WINDOW_TITLE
            CutOrMove       // Data object holds MMC_CUT_OR_MOVE data (this is
                            // set by target snap-in to return to source in a
                            // format defined by the source)
        };

        void SetType(Type type);
        Type GetType();

        void SetScopeItems(CScopeItems *pScopeItems);
        CScopeItems *GetScopeItems();

        void SetScopeItem(CScopeItem *pScopeItem);
        CScopeItem *GetScopeItem();
        
        void SetListItems(CMMCListItems *pListItems);
        CMMCListItems *GetListItems();

        void SetListItem(CMMCListItem *pListItem);
        CMMCListItem *GetListItem();

        HRESULT SetCaption(BSTR bstrCaption);

        void SetForeignData(IDataObject *piDataObject);

        void SetContext(DATA_OBJECT_TYPES Context) { m_Context = Context; }
        DATA_OBJECT_TYPES GetContext() { return m_Context; }

        DWORD GetSnapInInstanceID();

        static HRESULT RegisterClipboardFormats();

        // Public methods to get registered clipboard formats
        
        static CLIPFORMAT GetcfSzNodeType() { return m_cfSzNodeType; }
        static CLIPFORMAT GetcfDisplayName() { return m_cfDisplayName; }
        static CLIPFORMAT GetcfMultiSelectSnapIns() { return m_cfMultiSelectSnapIns; }
        static CLIPFORMAT GetcfMultiSelectDataObject() { return m_cfMultiSelectDataObject; }
        static CLIPFORMAT GetcfSnapInInstanceID() { return m_cfSnapInInstanceID; }
        static CLIPFORMAT GetcfThisPointer() { return m_cfThisPointer; }

    private:

        void InitMemberVariables();
        HRESULT WriteDisplayNameToStream(IStream *piStream);
        HRESULT WriteSnapInCLSIDToStream(IStream *piStream);
        HRESULT WriteDynamicExtensionsToStream(IStream *piStream);
        HRESULT WritePreloadsToStream(IStream *piStream);
        HRESULT WriteSnapInInstanceIDToStream(IStream *piStream);
        HRESULT WriteObjectTypesToStream(IStream *piStream);
        HRESULT WriteNodeIDToStream(IStream *piStream);
        HRESULT WriteNodeID2ToStream(IStream *piStream);
        HRESULT WriteColumnSetIDToStream(IStream *piStream);
        HRESULT WriteGUIDToStream(IStream *piStream, OLECHAR *pwszGUID);
        HRESULT WriteWideStrToStream(IStream *piStream, WCHAR *pwszString);
        HRESULT WriteStringArrayToStream(IStream *piStream, SAFEARRAY *psaStrings);
        HRESULT WriteToStream(IStream *piStream, void *pvBuffer, ULONG cbToWrite);
        enum FormatType { ANSI, UNICODE };
        static HRESULT RegisterClipboardFormat(WCHAR      *pwszFormatName,
                                               CLIPFORMAT *puiFormat,
                                               FormatType  Type);
        BOOL GetFormatIndex(CLIPFORMAT cfFormat, ULONG *piFormat);
        HRESULT GetSnapInData(CLIPFORMAT cfFormat, IStream *piStream);
        HRESULT GetObjectTypes();
        HRESULT GetOurObjectTypes();
        HRESULT GetForeignObjectTypes();
        void AddGuid(SMMCObjectTypes *pMMCObjectTypes, GUID *pguid);
        HRESULT ReallocFormats(CLIPFORMAT **ppcfFormats);

        // Registered clipboard formats kept here

        static CLIPFORMAT   m_cfDisplayName;
        static CLIPFORMAT   m_cfNodeType;
        static CLIPFORMAT   m_cfSzNodeType;
        static CLIPFORMAT   m_cfSnapinClsid;
        static CLIPFORMAT   m_cfWindowTitle;
        static CLIPFORMAT   m_cfDyanmicExtensions;
        static CLIPFORMAT   m_cfSnapInPreloads;
        static CLIPFORMAT   m_cfObjectTypesInMultiSelect;
        static CLIPFORMAT   m_cfMultiSelectSnapIns;
        static CLIPFORMAT   m_cfMultiSelectDataObject;
        static CLIPFORMAT   m_cfSnapInInstanceID;
        static CLIPFORMAT   m_cfThisPointer;
        static CLIPFORMAT   m_cfNodeID;
        static CLIPFORMAT   m_cfNodeID2;
        static CLIPFORMAT   m_cfColumnSetID;
        static BOOL         m_ClipboardFormatsRegistered;
        static BOOL         m_fUsingUNICODEFormats;

        CSnapIn            *m_pSnapIn;             // Owning CSnapIn
        CScopeItems        *m_pScopeItems;         // ScopeItems in data object
        CScopeItem         *m_pScopeItem;          // Single ScopeItem in data object
        CMMCListItems      *m_pListItems;          // ListItems in data object
        CMMCListItem       *m_pListItem;           // Single ListItem in data object
        BSTR                m_bstrCaption;         // Caption for CCF_WINDOW_TITLE
        IDataObject        *m_piDataObjectForeign; // If MMCDataObject represents
                                                   // a foreign data object (from
                                                   // an extension or an extendee)
                                                   // then this holds its
                                                   // IDataObject
        Type                m_Type;                // See enum above
        DATA_OBJECT_TYPES   m_Context;             // From MMC
        SMMCObjectTypes    *m_pMMCObjectTypes;     // for CCF_OBJECT_TYPES_IN_MULTI_SELECT

        ULONG               m_cFormats;            // # of data formats exported
                                                   // by the owning snap-in
        CLIPFORMAT         *m_pcfFormatsANSI;      // ANSI registered clipformat
        CLIPFORMAT         *m_pcfFormatsUNICODE;   // UNICODE registered clipformat

        // This struct holds the data passed to MMCDataObject.SetData
        
        typedef struct
        {
            VARIANT                     varData;
            SnapInObjectFormatConstants ObjectFormat;
        } DATA;

        // Array of data passed to MMCDataObject.SetData
        
        DATA *m_paData;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCDataObject,           // name
                                &CLSID_MMCDataObject,    // clsid
                                "MMCDataObject",         // objname
                                "MMCDataObject",         // lblname
                                &CMMCDataObject::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IMMCDataObject,     // dispatch IID
                                NULL,                    // event IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _DATAOBJECT_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobjs.h ===
//=--------------------------------------------------------------------------=
// dataobjs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObjects class definition - implements MMCDataObjects collection
//
//=--------------------------------------------------------------------------=

#ifndef _DATAOBJS_DEFINED_
#define _DATAOBJS_DEFINED_

#include "collect.h"

class CMMCDataObjects : public CSnapInCollection<IMMCDataObject, MMCDataObject, IMMCDataObjects>
{
    protected:
        CMMCDataObjects(IUnknown *punkOuter);
        ~CMMCDataObjects();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCDataObjects,           // name
                                &CLSID_MMCDataObjects,    // clsid
                                "MMCDataObjects",         // objname
                                "MMCDataObjects",         // lblname
                                NULL,                     // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCDataObjects,     // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _DATAOBJS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dataobjs.cpp ===
//=--------------------------------------------------------------------------=
// dataobjs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCDataObjects class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "dataobjs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCDataObjects::CMMCDataObjects(IUnknown *punkOuter) :
    CSnapInCollection<IMMCDataObject, MMCDataObject, IMMCDataObjects>(punkOuter,
                                           OBJECT_TYPE_MMCDATAOBJECTS,
                                           static_cast<IMMCDataObjects *>(this),
                                           static_cast<CMMCDataObjects *>(this),
                                           CLSID_MMCDataObject,
                                           OBJECT_TYPE_MMCDATAOBJECT,
                                           IID_IMMCDataObject,
                                           NULL)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCDataObjects::~CMMCDataObjects()
{
}

IUnknown *CMMCDataObjects::Create(IUnknown * punkOuter)
{
    CMMCDataObjects *pMMCDataObjects = New CMMCDataObjects(punkOuter);
    if (NULL == pMMCDataObjects)
    {
        return NULL;
    }
    else
    {
        return pMMCDataObjects->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCDataObjects::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IMMCDataObjects == riid)
    {
        *ppvObjOut = static_cast<IMMCDataObjects *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCDataObject, MMCDataObject, IMMCDataObjects>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dlregdes.cpp ===
//=--------------------------------------------------------------------------------------
// dlregdes.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// DllRegisterDesigner and DllUnregisterDesigner
//=-------------------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"

// for ASSERT and FAIL
//
SZTHISFILE

// Local utility function prototypes


enum ProcessingType { Register, Unregister };

HRESULT ProcessRegistration(DESIGNERREGINFO* pdri, ProcessingType Processing);

HRESULT LoadRegInfo(IRegInfo **ppiRegInfo, BYTE *rgbRegInfo);

HRESULT CreateKey(HKEY  hkeyParent,
                  char *pszKeyName,
                  char *pszDefaultValue,
                  HKEY *phKey);

HRESULT ProcessSnapInKeys(IRegInfo       *piRegInfo,
                          char           *pszClsid,
                          char           *pszDisplayName,
                          ProcessingType  Processing);

HRESULT ProcessNodeType(HKEY            hkeyNodeTypes,
                        INodeType      *piNodeType,
                        ProcessingType  Processing);

HRESULT CreateNodeTypesKey(BSTR  bstrNodeTypeGUID,
                           char *pszNodeTypeName,
                           HKEY *phKey);

HRESULT DeleteKey(HKEY hkey, char *pszSubKey);

HRESULT ProcessExtensions(IRegInfo       *piRegInfo,
                           char           *pszClsid,
                           char           *pszDisplayName,
                           ProcessingType  Processing);

HRESULT ProcessExtendedSnapIn(IExtendedSnapIn *piExtendedSnapIn,
                              char            *pszClsid,
                              char            *pszDisplayName,
                              ProcessingType   Processing);

HRESULT ProcessExtension(HKEY            hkeyExtensions,
                         char           *pszKeyName,
                         char           *pszClsid,
                         char           *pszDisplayName,
                         ProcessingType  Processing);

HRESULT SetValue(HKEY hkey, char *pszName, char *pszData);

HRESULT ProcessCLSID(IRegInfo       *piRegInfo,
                     char           *pszClsid,
                     ProcessingType  Processing);



//=--------------------------------------------------------------------------=
// DllRegisterDesigner
//=--------------------------------------------------------------------------=
//
// Parameters:
//      DESIGNERREGINFO* pdri [in] registration info saved at design time
//                            in IDesignerRegistration::GetRegistrationInfo
//
// Output:
//      HRESULT
//
// Notes:
//
// This method is called by the VB runtime when the snap-in's DLL is registered.
// It is passed the regsitration info that was saved by the design time in
// its IDesignerRegistration::GetRegistrationInfo method (see
// CSnapInDesigner::GetRegistrationInfo in mssnapd\desreg.cpp).
//

STDAPI DllRegisterDesigner(DESIGNERREGINFO* pdri)
{
    RRETURN(::ProcessRegistration(pdri, Register));
}


//=--------------------------------------------------------------------------=
// DllUnregisterDesigner
//=--------------------------------------------------------------------------=
//
// Parameters:
//      DESIGNERREGINFO* pdri [in] registration info saved at design time
//                            in IDesignerRegistration::GetRegistrationInfo
//
// Output:
//      HRESULT
//
// Notes:
//
// This method is called by the VB runtime when the snap-in's DLL is unregistered.
// It is passed the regsitration info that was saved by the design time in
// its IDesignerRegistration::GetRegistrationInfo method (see
// CSnapInDesigner::GetRegistrationInfo in mssnapd\desreg.cpp).
//

STDAPI DllUnregisterDesigner(DESIGNERREGINFO* pdri)
{
    RRETURN(::ProcessRegistration(pdri, Unregister));
}



//=--------------------------------------------------------------------------=
// ProcessRegistration
//=--------------------------------------------------------------------------=
//
// Parameters:
//      DESIGNERREGINFO* pdri [in] registration info saved at design time
//                            in IDesignerRegistration::GetRegistrationInfo
//      ProcessingType Processing [in] Register or Unregister
//
// Output:
//      HRESULT
//
// Notes:
//
// This function either registers or unregisters the snap-in based on the
// Processing parameter.
//
// See mssnapd\desreg.cpp for how the registration info was saved.
//
// The registation info is copied to a GlobalAlloc()ed buffer and converted
// to a stream. A RegInfo object is loaded from the stream.
//
// The snap-in is registered/unregistered under MMC's "SnapIns" key as follows:
// 
// HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns\pdri->clsid
//  NameString:      REG_SZ RegInfo.DisplayName
//  About:           REG_SZ pdri->clsid
//  StandAlone:      added if RegInfo.Standalone is VARIANT_TRUE
//  NodeTypes:
//      RegInfo.NodeType(0).GUID
//      RegInfo.NodeType(1).GUID
//      etc.
// 
// The MMC NodeTypes key is populated/depopulated from RegInfo.NodeTypes
// 
// HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\RegInfo.NodeTypes(i).GUID=RegInfo.NodeTypes(i).Name
//
// If the snap-in extends other snap-ins then the appropriate entries are
// addded/removed under
// HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<other snap-in GUID>.
//
//
// An additional key is created/removed:
// HKEY_LOCAL_MACHINE\Software\Microsoft\Visual Basic\6.0\SnapIns\<node type guid>
// with default REG_SZ value of snap-in CLSID. Runtime uses this to get
// the snap-in's CLSID needed for CCF_SNAPIN_CLSID data object queries
// from MMC. If all snap-ins were extensible then this key wouldn't be necessary
// as the runtime could just query the static node type key but as we cannot
// guarantee extensibility (it is a design time choice made in the designer) we
// need to use this extra key.
   

HRESULT ProcessRegistration(DESIGNERREGINFO* pdri, ProcessingType Processing)
{
    HRESULT   hr = S_OK;
    IRegInfo *piRegInfo = NULL;
    BSTR      bstrDisplayName = NULL;
    char     *pszDisplayName = NULL;
    char     *pszClsid = NULL;
    WCHAR     wszClsid[64];
    ::ZeroMemory(wszClsid, sizeof(wszClsid));

    IfFalseGo(0 != ::StringFromGUID2(pdri->clsid, wszClsid,
                                     sizeof(wszClsid) / sizeof(wszClsid[0])),
              E_FAIL);

    IfFailGo(::ANSIFromWideStr(wszClsid, &pszClsid));

    IfFailGo(::LoadRegInfo(&piRegInfo, pdri->rgbRegInfo));

    IfFailGo(piRegInfo->get_DisplayName(&bstrDisplayName));
    IfFailGo(::ANSIFromWideStr(bstrDisplayName, &pszDisplayName));

    IfFailGo(::ProcessSnapInKeys(piRegInfo, pszClsid, pszDisplayName, Processing));
    IfFailGo(::ProcessExtensions(piRegInfo, pszClsid, pszDisplayName, Processing));
    IfFailGo(::ProcessCLSID(piRegInfo, pszClsid, Processing));

Error:
    if (NULL != pszDisplayName)
    {
        ::CtlFree(pszDisplayName);
    }
    FREESTRING(bstrDisplayName);
    QUICK_RELEASE(piRegInfo);
    if (NULL != pszClsid)
    {
        ::CtlFree(pszClsid);
    }
    RRETURN(hr);
}



static HRESULT LoadRegInfo
(
    IRegInfo **ppiRegInfo,
    BYTE      *rgbRegInfo
)
{
    HRESULT  hr = S_OK;
    ULONG    cbBuffer = *((ULONG *)(rgbRegInfo));
    HGLOBAL  hglobal = NULL;
    BYTE    *pbBuffer = NULL;
    IStream *piStream = NULL;

    // GlobalAlloc() a buffer and copy the reg info to it

    hglobal = ::GlobalAlloc(GMEM_MOVEABLE, (DWORD)cbBuffer);
    IfFalseGo(NULL != hglobal, HRESULT_FROM_WIN32(::GetLastError()));

    pbBuffer = (BYTE *)::GlobalLock(hglobal);
    IfFalseGo(NULL != pbBuffer, HRESULT_FROM_WIN32(::GetLastError()));

    ::memcpy(pbBuffer, rgbRegInfo + sizeof(ULONG), cbBuffer);

    IfFalseGo(!::GlobalUnlock(hglobal), HRESULT_FROM_WIN32(::GetLastError()));
    IfFalseGo(::GetLastError() == NOERROR, HRESULT_FROM_WIN32(::GetLastError()));

    // Create stream on HGLOBAL and load the RegInfo object
    hr = ::CreateStreamOnHGlobal(hglobal, // Allocate buffer
                                 TRUE,    // Free buffer on release
                                 &piStream);
    IfFailGo(hr);

    IfFailGo(::OleLoadFromStream(piStream, IID_IRegInfo,
                                 reinterpret_cast<void **>(ppiRegInfo)));

Error:
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}



static HRESULT ProcessSnapInKeys
(
    IRegInfo       *piRegInfo,
    char           *pszClsid,
    char           *pszDisplayName,
    ProcessingType  Processing
)
{
    HRESULT       hr = S_OK;
    char         *pszSnapInsKey = NULL;
    HKEY          hkeySnapIns = NULL;
    HKEY          hkeySnapInNodeTypes = NULL;
    VARIANT_BOOL  fStandAlone = VARIANT_FALSE;
    INodeTypes   *piNodeTypes = NULL;
    INodeType    *piNodeType = NULL;
    long          cNodeTypes = 0;
    long          lRc = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Create key: HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\SnapIns\<clsid>

    IfFailGo(::CreateKeyName(MMCKEY_SNAPINS, MMCKEY_SNAPINS_LEN,
                             pszClsid, ::strlen(pszClsid), &pszSnapInsKey));

    IfFailGo(::CreateKey(HKEY_LOCAL_MACHINE, pszSnapInsKey, NULL, &hkeySnapIns));

    if (Register == Processing)
    {
        // Add the NameString value and set it to the display name

        IfFailGo(::SetValue(hkeySnapIns, MMCKEY_NAMESTRING, pszDisplayName));

        // Add the About value and set its to the snap-in's CLSID

        IfFailGo(::SetValue(hkeySnapIns, MMCKEY_ABOUT, pszClsid));
    }

    // Process the StandAlone key if applicable

    IfFailGo(piRegInfo->get_StandAlone(&fStandAlone));
    if (VARIANT_TRUE == fStandAlone)
    {
        if (Register == Processing)
        {
            IfFailGo(::CreateKey(hkeySnapIns, MMCKEY_STANDALONE, NULL, NULL));
        }
        else
        {
            IfFailGo(::DeleteKey(hkeySnapIns, MMCKEY_STANDALONE));
        }
    }

    // Process node types if applicable

    IfFailGo(piRegInfo->get_NodeTypes(&piNodeTypes));
    IfFailGo(piNodeTypes->get_Count(&cNodeTypes));

    if (0 != cNodeTypes)
    {
        IfFailGo(::CreateKey(hkeySnapIns, MMCKEY_SNAPIN_NODETYPES, NULL,
                             &hkeySnapInNodeTypes));

        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;

        while (varIndex.lVal <= cNodeTypes)
        {
            IfFailGo(piNodeTypes->get_Item(varIndex, &piNodeType));
            IfFailGo(::ProcessNodeType(hkeySnapInNodeTypes, piNodeType, Processing));
            RELEASE(piNodeType);
            varIndex.lVal++;
        }

        // If unregistering then remove NodeTypes key now after all node types
        // have been removed as NT does not allow deleting a key that has subkeys
        if (Unregister == Processing)
        {
            IfFailGo(::DeleteKey(hkeySnapIns, MMCKEY_SNAPIN_NODETYPES));
        }
    }

    // If unregistering then remove SnapIns key now after all subkeys are gone

    if (Unregister == Processing)
    {
        IfFailGo(::DeleteKey(HKEY_LOCAL_MACHINE, pszSnapInsKey));
    }

Error:
    QUICK_RELEASE(piNodeTypes);
    QUICK_RELEASE(piNodeType);
    if (NULL != hkeySnapIns)
    {
        (void)::RegCloseKey(hkeySnapIns);
    }
    if (NULL != hkeySnapInNodeTypes)
    {
        (void)::RegCloseKey(hkeySnapInNodeTypes);
    }
    if (NULL != pszSnapInsKey)
    {
        ::CtlFree(pszSnapInsKey);
    }
    RRETURN(hr);
}





static HRESULT CreateKey
(
    HKEY  hkeyParent,
    char *pszKeyName,
    char *pszDefaultValue,
    HKEY *phKey
)
{
    HRESULT hr = S_OK;
    long    lRc = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DWORD   dwActionTaken = REG_CREATED_NEW_KEY;

    lRc = ::RegCreateKeyEx(hkeyParent,              // parent key
                           pszKeyName,              // name of new sub-key
                           0,                       // reserved
                           "",                      // class
                           REG_OPTION_NON_VOLATILE, // options
                           KEY_WRITE |              // access
                           KEY_ENUMERATE_SUB_KEYS,  // need enum for deletion
                           NULL,                    // use inherited security
                           &hKey,                   // new key returned here
                           &dwActionTaken);         // action returned here

    IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));

    IfFalseGo(NULL != pszDefaultValue, S_OK);

    lRc = ::RegSetValueEx(hKey,                           // key
                          NULL,                           // set default value
                          0,                              // reserved
                          REG_SZ,                         // string type
                          (CONST BYTE *)pszDefaultValue,  // data
                          ::strlen(pszDefaultValue) + 1); // length of data

    IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));

Error:
    if (NULL != hKey)
    {
        if (SUCCEEDED(hr) && (NULL != phKey))
        {
            *phKey = hKey;
        }
        else
        {
            (void)::RegCloseKey(hKey);
        }
    }
    RRETURN(hr);
}



static HRESULT ProcessNodeType
(
    HKEY            hkeySnapInNodeTypes,
    INodeType      *piNodeType,
    ProcessingType  Processing
)
{
    HRESULT  hr = S_OK;
    char    *pszNodeTypeGUID = NULL;
    BSTR     bstrNodeTypeGUID = NULL;
    char    *pszNodeTypeName = NULL;
    BSTR     bstrNodeTypeName = NULL;
    char    *pszNodeTypeKeyName = NULL;
    HKEY     hkeyNodeTypes = NULL;
    long     lRc = 0;

    // Add the node type GUID as a sub-key of the snap-in's NodeTypes sub key

    IfFailGo(piNodeType->get_GUID(&bstrNodeTypeGUID));
    
    IfFailGo(::ANSIFromWideStr(bstrNodeTypeGUID, &pszNodeTypeGUID));

    IfFailGo(piNodeType->get_Name(&bstrNodeTypeName));

    IfFailGo(::ANSIFromWideStr(bstrNodeTypeName, &pszNodeTypeName));

    if (Register == Processing)
    {
        IfFailGo(::CreateKey(hkeySnapInNodeTypes, pszNodeTypeGUID,
                             pszNodeTypeName, NULL));

        // Create the key under MMC's NodeTypes:
        // HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<node type GUID>

        IfFailGo(::CreateNodeTypesKey(bstrNodeTypeGUID, pszNodeTypeName,
                                      &hkeyNodeTypes));
    }
    else
    {
        IfFailGo(::DeleteKey(hkeySnapInNodeTypes, pszNodeTypeGUID));

        IfFailGo(::CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                                bstrNodeTypeGUID, &pszNodeTypeKeyName));

        IfFailGo(::DeleteKey(HKEY_LOCAL_MACHINE, pszNodeTypeKeyName));
    }

Error:
    FREESTRING(bstrNodeTypeGUID);
    if (NULL != pszNodeTypeGUID)
    {
        ::CtlFree(pszNodeTypeGUID);
    }
    FREESTRING(bstrNodeTypeName);
    if (NULL != pszNodeTypeName)
    {
        ::CtlFree(pszNodeTypeName);
    }
    if (NULL != hkeyNodeTypes)
    {
        (void)::RegCloseKey(hkeyNodeTypes);
    }
    if (NULL != pszNodeTypeKeyName)
    {
        ::CtlFree(pszNodeTypeKeyName);
    }
    RRETURN(hr);
}


static HRESULT CreateNodeTypesKey
(
    BSTR            bstrNodeTypeGUID,
    char           *pszNodeTypeName,
    HKEY           *phKey
)
{
    HRESULT  hr = S_OK;
    char    *pszNodeTypeKeyName = NULL;
    size_t   cbNodeTypeGUID = 0;

    IfFailGo(::CreateKeyNameW(MMCKEY_NODETYPES, MMCKEY_NODETYPES_LEN,
                              bstrNodeTypeGUID, &pszNodeTypeKeyName));

    IfFailGo(::CreateKey(HKEY_LOCAL_MACHINE, pszNodeTypeKeyName,
                         pszNodeTypeName, phKey));

Error:
    if (NULL != pszNodeTypeKeyName)
    {
        ::CtlFree(pszNodeTypeKeyName);
    }
    RRETURN(hr);
}


static HRESULT DeleteKey(HKEY hkey, char *pszSubKey)
{
    HKEY    hkeySub = NULL;
    HRESULT hr = S_OK;
    char    szNextSubKey[MAX_PATH + 1] = "";
    long    lRc = 0;

    IfFailGo(::CreateKey(hkey, pszSubKey, NULL, &hkeySub));

    // We continually re-enumerate from zero because we are deleting the
    // keys as we go. If we don't do that then NT gets confused and says
    // there are no more keys.

    lRc = ::RegEnumKey(hkeySub, 0, szNextSubKey, sizeof(szNextSubKey));
    while (ERROR_SUCCESS == lRc)
    {
        IfFailGo(::DeleteKey(hkeySub, szNextSubKey));
        lRc = ::RegEnumKey(hkeySub, 0, szNextSubKey, sizeof(szNextSubKey));
    }

    IfFalseGo(ERROR_NO_MORE_ITEMS == lRc, HRESULT_FROM_WIN32(lRc));

    lRc = ::RegDeleteKey(hkey, pszSubKey);
    IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));

Error:
    if (NULL != hkeySub)
    {
        (void)::RegCloseKey(hkeySub);
    }
    RRETURN(hr);
}


static HRESULT ProcessExtensions
(
    IRegInfo       *piRegInfo,
    char           *pszClsid,
    char           *pszDisplayName,
    ProcessingType  Processing
)
{
    HRESULT           hr = S_OK;
    IExtendedSnapIns *piExtendedSnapIns = NULL;
    IExtendedSnapIn  *piExtendedSnapIn = NULL;
    long              cExtendedSnapIns = 0;
    VARIANT           varIndex;
    ::VariantInit(&varIndex);

    // Get the collection of extended snap-ins

    IfFailGo(piRegInfo->get_ExtendedSnapIns(&piExtendedSnapIns));
    IfFailGo(piExtendedSnapIns->get_Count(&cExtendedSnapIns));
    IfFalseGo(0 != cExtendedSnapIns, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    // Add the supported extensions to each snap-in's node types key

    while (varIndex.lVal <= cExtendedSnapIns)
    {
        IfFailGo(piExtendedSnapIns->get_Item(varIndex, &piExtendedSnapIn));
        IfFailGo(::ProcessExtendedSnapIn(piExtendedSnapIn, pszClsid,
                                         pszDisplayName, Processing));
        RELEASE(piExtendedSnapIn);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piExtendedSnapIns);
    QUICK_RELEASE(piExtendedSnapIn);
    RRETURN(hr);
}



static HRESULT ProcessExtendedSnapIn
(
    IExtendedSnapIn *piExtendedSnapIn,
    char            *pszClsid,
    char            *pszDisplayName,
    ProcessingType   Processing
)
{
    HRESULT      hr = S_OK;
    long         lRc = ERROR_SUCCESS;
    HKEY         hkeyNodeTypes = NULL;
    HKEY         hkeyExtensions = NULL;
    HKEY         hkeyDynamicExtensions = NULL;
    BSTR         bstrNodeTypeGUID = NULL;
    VARIANT_BOOL fExtends = VARIANT_FALSE;
    VARIANT_BOOL fDynamic = VARIANT_FALSE;

    // Create or open key:
    // HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<node type GUID>

    IfFailGo(piExtendedSnapIn->get_NodeTypeGUID(&bstrNodeTypeGUID));
    IfFailGo(::CreateNodeTypesKey(bstrNodeTypeGUID, NULL, &hkeyNodeTypes));

    // Create/open Extensions Key

    IfFailGo(::CreateKey(hkeyNodeTypes, MMCKEY_EXTENSIONS, NULL, &hkeyExtensions));

    // Check the extension types and add keys and values as needed

    IfFailGo(piExtendedSnapIn->get_ExtendsNewMenu(&fExtends));
    if (VARIANT_FALSE == fExtends)
    {
        IfFailGo(piExtendedSnapIn->get_ExtendsTaskMenu(&fExtends));
    }
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_CONTEXTMENU, pszClsid,
                                    pszDisplayName, Processing));
    }
    
    IfFailGo(piExtendedSnapIn->get_ExtendsPropertyPages(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_PROPERTYSHEET,
                                    pszClsid, pszDisplayName, Processing));
    }
    
    IfFailGo(piExtendedSnapIn->get_ExtendsToolbar(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_TOOLBAR, pszClsid,
                                    pszDisplayName, Processing));
    }

    IfFailGo(piExtendedSnapIn->get_ExtendsTaskpad(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_TASK, pszClsid,
                                    pszDisplayName, Processing));
    }

    IfFailGo(piExtendedSnapIn->get_ExtendsNameSpace(&fExtends));
    if (VARIANT_TRUE == fExtends)
    {
        IfFailGo(::ProcessExtension(hkeyExtensions, MMCKEY_NAMESPACE, pszClsid,
                                    pszDisplayName, Processing));
    }

    // If the snap-in extends this node type dynamically then add/delete a value
    // to the DynamicExtensions sub-key:
    // HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\<node type GUID>\Dynamic Extensions
    //
    // The value is the same form as for the Extensions sub-keys:
    // <CLSID>=<DisplayName>

    IfFailGo(piExtendedSnapIn->get_Dynamic(&fDynamic));
    IfFalseGo(VARIANT_TRUE == fDynamic, S_OK);

    IfFailGo(::CreateKey(hkeyNodeTypes, MMCKEY_DYNAMIC_EXTENSIONS, NULL,
                         &hkeyDynamicExtensions));

    if (Register == Processing)
    {
        IfFailGo(::SetValue(hkeyDynamicExtensions, pszClsid, pszDisplayName));
    }
    else
    {
        lRc = ::RegDeleteValue(hkeyDynamicExtensions, pszClsid);
        if (ERROR_FILE_NOT_FOUND == lRc) // If the value is not there then 
        {                                // ignore the error
            lRc = ERROR_SUCCESS;
        }
        IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));
    }

Error:
    FREESTRING(bstrNodeTypeGUID);
    if (NULL != hkeyNodeTypes)
    {
        (void)::RegCloseKey(hkeyNodeTypes);
    }
    if (NULL != hkeyExtensions)
    {
        (void)::RegCloseKey(hkeyExtensions);
    }
    if (NULL != hkeyDynamicExtensions)
    {
        (void)::RegCloseKey(hkeyDynamicExtensions);
    }
    RRETURN(hr);
}



static HRESULT ProcessExtension
(
    HKEY            hkeyExtensions,
    char           *pszKeyName,
    char           *pszClsid,
    char           *pszDisplayName,
    ProcessingType  Processing
)
{
    HRESULT hr = S_OK;
    HKEY    hkeyExtension = NULL;
    long    lRc = 0;

    IfFailGo(::CreateKey(hkeyExtensions, pszKeyName, NULL, &hkeyExtension));

    if (Register == Processing)
    {
        IfFailGo(::SetValue(hkeyExtension, pszClsid, pszDisplayName));
    }
    else
    {
        lRc = ::RegDeleteValue(hkeyExtension, pszClsid);
        if (ERROR_FILE_NOT_FOUND == lRc) // If the value is not there then 
        {                                // ignore the error
            lRc = ERROR_SUCCESS;
        }
        IfFalseGo(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));
    }

Error:
    if (NULL != hkeyExtension)
    {
        (void)::RegCloseKey(hkeyExtension);
    }
    RRETURN(hr);
}


static HRESULT SetValue
(
    HKEY  hKey,
    char *pszName,
    char *pszData
)
{
    long lRc = ::RegSetValueEx(hKey,                   // key
                               pszName,                // value name
                               0,                      // reserved
                               REG_SZ,                 // string type
                               (CONST BYTE *)pszData,  // data
                               ::strlen(pszData) + 1); // data length

    IfFalseRet(ERROR_SUCCESS == lRc, HRESULT_FROM_WIN32(lRc));
    return S_OK;
}



static HRESULT ProcessCLSID
(
    IRegInfo       *piRegInfo,
    char           *pszClsid,
    ProcessingType  Processing
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrGUID = NULL;
    char    *pszKeyName = NULL;

    // Create key:
    // HKEY_LOCAL_MACHINE\Software\Microsoft\Visual Basic\6.0\SnapIns\<node type guid>
    // with default REG_SZ value of snap-in CLSID. Runtime uses this to get
    // the snap-in's CLSID needed for CCF_SNAPIN_CLSID data object queries
    // from MMC

    IfFailGo(piRegInfo->get_StaticNodeTypeGUID(&bstrGUID));
    IfFailGo(::CreateKeyNameW(KEY_SNAPIN_CLSID, KEY_SNAPIN_CLSID_LEN, bstrGUID,
                              &pszKeyName));
    if (Register == Processing)
    {
        IfFailGo(::CreateKey(HKEY_LOCAL_MACHINE, pszKeyName, pszClsid, NULL));
    }
    else
    {
        IfFailGo(::DeleteKey(HKEY_LOCAL_MACHINE, pszKeyName));
    }

Error:
    FREESTRING(bstrGUID);
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\dispid.h ===
//=--------------------------------------------------------------------------------------
// dispid.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//  
//=--------------------------------------------------------------------------=
//
//  Notes
//      Contains defintions of all the dispids used in the snap-in
//      designer type library
//
//=--------------------------------------------------------------------------=

// This is the lowest DISPID for dynamic snap-in properties (toolbars, image
// lists and menus.

#define DISPID_DYNAMIC_BASE                                     1000

// ISnapIn
#define DISPID_SNAPIN_NAME                                      DISPID_VALUE
#define DISPID_SNAPIN_NODE_TYPE_NAME                            1
#define DISPID_SNAPIN_NODE_TYPE_GUID                            2
#define DISPID_SNAPIN_DISPLAY_NAME                              3
#define DISPID_SNAPIN_TYPE                                      4
#define DISPID_SNAPIN_DESCRIPTION                               5
#define DISPID_SNAPIN_PROVIDER                                  6
#define DISPID_SNAPIN_VERSION                                   7
#define DISPID_SNAPIN_SMALL_FOLDERS                             8
#define DISPID_SNAPIN_SMALL_FOLDERS_OPEN                        9
#define DISPID_SNAPIN_LARGE_FOLDERS                             10
#define DISPID_SNAPIN_ICON                                      11
#define DISPID_SNAPIN_WATERMARK                                 12
#define DISPID_SNAPIN_HEADER                                    13
#define DISPID_SNAPIN_PALETTE                                   14
#define DISPID_SNAPIN_STRETCH_WATERMARK                         15
#define DISPID_SNAPIN_STATIC_FOLDER                             16
#define DISPID_SNAPIN_SCOPEITEMS                                17
#define DISPID_SNAPIN_VIEWS                                     18
#define DISPID_SNAPIN_SCOPE_PANE_ITEMS                          19
#define DISPID_SNAPIN_RESULT_VIEWS                              20
#define DISPID_SNAPIN_CLIPBOARD                                 21
#define DISPID_SNAPIN_HELP_FILE                                 22
#define DISPID_SNAPIN_RUNTIME_MODE                              23
#define DISPID_SNAPIN_TASKPAD_VIEW_PREFERRED                    24
#define DISPID_SNAPIN_REQUIRED_EXTENSIONS                       25
#define DISPID_SNAPIN_CONSOLE_MSGBOX                            26
#define DISPID_SNAPIN_SHOW_HELP_TOPIC                           27
#define DISPID_SNAPIN_EXTENSION_SNAPIN                          28
#define DISPID_SNAPIN_TRACE                                     29
#define DISPID_SNAPIN_FIRE_CONFIG_COMPLETE                      30
#define DISPID_SNAPIN_PRELOAD                                   31
#define DISPID_SNAPIN_STRINGTABLE                               32
#define DISPID_SNAPIN_FORMAT_DATA                               33
#define DISPID_SNAPIN_LINKED_TOPICS                             34
#define DISPID_SNAPIN_CURRENT_VIEW                              35
#define DISPID_SNAPIN_CURRENT_SCOPEPANEITEM                     36
#define DISPID_SNAPIN_CURRENT_SCOPEITEM                         37
#define DISPID_SNAPIN_CURRENT_RESULTVIEW                        38
#define DISPID_SNAPIN_CURRENT_LISTVIEW                          39
#define DISPID_SNAPIN_MMC_COMMAND_LINE                          40

// DSnapInEvents
#define DISPID_SNAPIN_EVENT_LOAD                                1
#define DISPID_SNAPIN_EVENT_UNLOAD                              2
#define DISPID_SNAPIN_EVENT_HELP                                3
#define DISPID_SNAPIN_EVENT_WRITE_PROPERTIES                    4
#define DISPID_SNAPIN_EVENT_READ_PROPERTIES                     5
#define DISPID_SNAPIN_EVENT_QUERY_CONFIGURATION_WIZARD          6
#define DISPID_SNAPIN_EVENT_CREATE_CONFIGURATION_WIZARD         7
#define DISPID_SNAPIN_EVENT_CONFIGURATION_COMPLETE              8
#define DISPID_SNAPIN_EVENT_PRELOAD                             9


// DExtensionSnapInEvents
#define DISPID_EXTENSIONSNAPIN_EVENT_EXPAND                     1
#define DISPID_EXTENSIONSNAPIN_EVENT_EXPAND_SYNC                2
#define DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE                   3
#define DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE_SYNC              4
#define DISPID_EXTENSIONSNAPIN_EVENT_SET_CONTROLBAR             5
#define DISPID_EXTENSIONSNAPIN_EVENT_UPDATE_CONTROLBAR          6
#define DISPID_EXTENSIONSNAPIN_EVENT_ADD_NEW_MENU_ITEMS         7
#define DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASK_MENU_ITEMS        8
#define DISPID_EXTENSIONSNAPIN_EVENT_CREATE_PROPERTY_PAGES      9
#define DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASKS                  10
#define DISPID_EXTENSIONSNAPIN_EVENT_TASK_CLICK                 11

// IScopeItems
#define DISPID_SCOPEITEMS_ITEM                                  DISPID_VALUE
#define DISPID_SCOPEITEMS_COUNT                                 1
#define DISPID_SCOPEITEMS_ADD                                   2
#define DISPID_SCOPEITEMS_ADD_PREDEFINED                        3
#define DISPID_SCOPEITEMS_REMOVE                                4

// DScopeItemsEvents
#define DISPID_SCOPEITEMS_EVENT_INITIALIZE                      1
#define DISPID_SCOPEITEMS_EVENT_TERMINATE                       2
#define DISPID_SCOPEITEMS_EVENT_GET_DISPLAY_INFO                3
#define DISPID_SCOPEITEMS_EVENT_EXPAND                          4
#define DISPID_SCOPEITEMS_EVENT_EXPAND_SYNC                     5
#define DISPID_SCOPEITEMS_EVENT_COLLAPSE                        6
#define DISPID_SCOPEITEMS_EVENT_COLLAPSE_SYNC                   7
#define DISPID_SCOPEITEMS_EVENT_RENAME                          8
#define DISPID_SCOPEITEMS_EVENT_DELETE                          9
#define DISPID_SCOPEITEMS_EVENT_REMOVE_CHILDREN                 10
#define DISPID_SCOPEITEMS_EVENT_PROPERTY_CHANGE                 11
#define DISPID_SCOPEITEMS_EVENT_HELP                            12
#define DISPID_SCOPEITEMS_EVENT_PROPERTY_CHANGED                13

// IScopeItem
#define DISPID_SCOPEITEM_NAME                                   DISPID_VALUE
#define DISPID_SCOPEITEM_INDEX                                  1
#define DISPID_SCOPEITEM_KEY                                    2
#define DISPID_SCOPEITEM_FOLDER                                 3
#define DISPID_SCOPEITEM_DATA                                   4
#define DISPID_SCOPEITEM_DEFAULT_DATA_FORMAT                    5
#define DISPID_SCOPEITEM_DYNAMIC_EXTENSIONS                     6
#define DISPID_SCOPEITEM_SLOW_RETRIEVAL                         7
#define DISPID_SCOPEITEM_NODE_ID                                8
#define DISPID_SCOPEITEM_TAG                                    9
#define DISPID_SCOPEITEM_SCOPENODE                              10
#define DISPID_SCOPEITEM_PASTED                                 11
#define DISPID_SCOPEITEM_UPDATE_ALL_VIEWS                       12
#define DISPID_SCOPEITEM_COLUMN_HEADERS                         13
#define DISPID_SCOPEITEM_SUBITEMS                               14
#define DISPID_SCOPEITEM_LIST_SUBITEMS                          15
#define DISPID_SCOPEITEM_BOLD                                   16
#define DISPID_SCOPEITEM_PROPERTY_CHANGED                       17
#define DISPID_SCOPEITEM_REMOVE_CHILDREN                        18

// IScopeNode
#define DISPID_SCOPENODE_NODE_TYPE_NAME                         1
#define DISPID_SCOPENODE_NODE_TYPE_GUID                         2
#define DISPID_SCOPENODE_DISPLAY_NAME                           3
#define DISPID_SCOPENODE_PARENT                                 4
#define DISPID_SCOPENODE_HAS_CHILDREN                           5
#define DISPID_SCOPENODE_CHILD                                  6
#define DISPID_SCOPENODE_FIRST_SIBLING                          7  
#define DISPID_SCOPENODE_NEXT                                   8
#define DISPID_SCOPENODE_LAST_SIBLING                           9 
#define DISPID_SCOPENODE_EXPANDEDONCE                           10
#define DISPID_SCOPENODE_OWNED                                  11
#define DISPID_SCOPENODE_EXPAND_IN_NAMESPACE                    12

// IViews
#define DISPID_VIEWS_ITEM                                       DISPID_VALUE
#define DISPID_VIEWS_COUNT                                      1
#define DISPID_VIEWS_CURRENT_VIEW                               2
#define DISPID_VIEWS_ADD                                        3
#define DISPID_VIEWS_CLEAR                                      4
#define DISPID_VIEWS_REMOVE                                     5

// DViewsEvents
#define DISPID_VIEWS_EVENT_INITIALIZE                           1
#define DISPID_VIEWS_EVENT_TERMINATE                            2
#define DISPID_VIEWS_EVENT_ACTIVATE                             3
#define DISPID_VIEWS_EVENT_DEACTIVATE                           4
#define DISPID_VIEWS_EVENT_MINIMIZE                             5
#define DISPID_VIEWS_EVENT_MAXIMIZE                             6
#define DISPID_VIEWS_EVENT_SET_CONTROL_BAR                      7
#define DISPID_VIEWS_EVENT_UPDATE_CONTROLBAR                    8
#define DISPID_VIEWS_EVENT_SELECT                               9
#define DISPID_VIEWS_EVENT_ADD_TOP_MENU_ITEMS                   10
#define DISPID_VIEWS_EVENT_ADD_NEW_MENU_ITEMS                   11
#define DISPID_VIEWS_EVENT_ADD_TASK_MENU_ITEMS                  12
#define DISPID_VIEWS_EVENT_ADD_VIEW_MENU_ITEMS                  13
#define DISPID_VIEWS_EVENT_GET_MULTISELECT_DATA                 14
#define DISPID_VIEWS_EVENT_QUERY_PASTE                          15
#define DISPID_VIEWS_EVENT_PASTE                                16
#define DISPID_VIEWS_EVENT_CUT                                  17
#define DISPID_VIEWS_EVENT_DELETE                               18
#define DISPID_VIEWS_EVENT_QUERY_PAGES_FOR                      19
#define DISPID_VIEWS_EVENT_CREATE_PROPERTY_PAGES                20
#define DISPID_VIEWS_EVENT_REFRESH                              21
#define DISPID_VIEWS_EVENT_PRINT                                22
#define DISPID_VIEWS_EVENT_SPECIAL_PROPERTIES_CLICK             23
#define DISPID_VIEWS_EVENT_LOAD                                 24
#define DISPID_VIEWS_EVENT_WRITE_PROPERTIES                     25
#define DISPID_VIEWS_EVENT_READ_PROPERTIES                      26


// IView
#define DISPID_VIEW_NAME                                        DISPID_VALUE
#define DISPID_VIEW_INDEX                                       1
#define DISPID_VIEW_KEY                                         2
#define DISPID_VIEW_SCOPEPANEITEMS                              3
#define DISPID_VIEW_TAG                                         4
#define DISPID_VIEW_CAPTION                                     5
#define DISPID_VIEW_SET_STATUS_BAR_TEXT                         6
#define DISPID_VIEW_CONTEXT_MENU_PROVIDER                       7
#define DISPID_VIEW_PROPERTY_SHEET_PROVIDER                     8
#define DISPID_VIEW_MMC_MAJOR_VERSION                           9
#define DISPID_VIEW_MMC_MINOR_VERSION                           10
#define DISPID_VIEW_SELECT_SCOPE_ITEM                           11
#define DISPID_VIEW_POPUP_MENU                                  12
#define DISPID_VIEW_COLUMN_SETTINGS                             13
#define DISPID_VIEW_SORT_SETTINGS                               14
#define DISPID_VIEW_EXPAND_IN_TREEVIEW                          15
#define DISPID_VIEW_COLLAPSE_IN_TREEVIEW                        16
#define DISPID_VIEW_NEW_WINDOW                                  17

// IScopePaneItems
#define DISPID_SCOPEPANEITEMS_ITEM                              DISPID_VALUE
#define DISPID_SCOPEPANEITEMS_COUNT                             1
#define DISPID_SCOPEPANEITEMS_SELECTED_ITEM                     2
#define DISPID_SCOPEPANEITEMS_PARENT                            3

// DScopePaneItemsEvents
#define DISPID_SCOPEPANEITEMS_EVENT_INITIALIZE                      1
#define DISPID_SCOPEPANEITEMS_EVENT_TERMINATE                       2
#define DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW_INFO             3
#define DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW                  4
#define DISPID_SCOPEPANEITEMS_EVENT_GET_COLUMN_SET_ID               5

// IScopePaneItem
#define DISPID_SCOPEPANEITEM_NAME                                   DISPID_VALUE
#define DISPID_SCOPEPANEITEM_INDEX                                  1
#define DISPID_SCOPEPANEITEM_KEY                                    2
#define DISPID_SCOPEPANEITEM_SCOPEITEM                              3
#define DISPID_SCOPEPANEITEM_RESULTVIEW_TYPE                        4
#define DISPID_SCOPEPANEITEM_DISPLAY_STRING                         5
#define DISPID_SCOPEPANEITEM_HAS_LISTVIEWS                          6
#define DISPID_SCOPEPANEITEM_RESULTVIEW                             7
#define DISPID_SCOPEPANEITEM_RESULTVIEWS                            8
#define DISPID_SCOPEPANEITEM_PARENT                                 9
#define DISPID_SCOPEPANEITEM_TAG                                    10
#define DISPID_SCOPEPANEITEM_DISPLAY_NEW_RESULTVIEW                 11
#define DISPID_SCOPEPANEITEM_COLUMN_SET_ID                          12
#define DISPID_SCOPEPANEITEM_DISPLAY_MESSAGEVIEW                    13

// IResultViews
#define DISPID_RESULTVIEWS_ITEM                                 DISPID_VALUE
#define DISPID_RESULTVIEWS_COUNT                                1
#define DISPID_RESULTVIEWS_ADD                                  2
#define DISPID_RESULTVIEWS_CLEAR                                3
#define DISPID_RESULTVIEWS_REMOVE                               4

// DResultViewsEvents
#define DISPID_RESULTVIEWS_EVENT_INITIALIZE                     1
#define DISPID_RESULTVIEWS_EVENT_INITIALIZE_CONTROL             2
#define DISPID_RESULTVIEWS_EVENT_TERMINATE                      3
#define DISPID_RESULTVIEWS_EVENT_GET_DISPLAY_INFO               4
#define DISPID_RESULTVIEWS_EVENT_HELP                           5
#define DISPID_RESULTVIEWS_EVENT_LISTITEM_DBLCLICK              6
#define DISPID_RESULTVIEWS_EVENT_SCOPEITEM_DBLCLICK             7
#define DISPID_RESULTVIEWS_EVENT_PROPERTY_CHANGE                8
#define DISPID_RESULTVIEWS_EVENT_ITEM_RENAME                    9
#define DISPID_RESULTVIEWS_EVENT_ACTIVATE                       10
#define DISPID_RESULTVIEWS_EVENT_DEACTIVATE                     11
#define DISPID_RESULTVIEWS_EVENT_ITEM_VIEW_CHANGE               12
#define DISPID_RESULTVIEWS_EVENT_COLUMN_CLICK                   13
#define DISPID_RESULTVIEWS_EVENT_DESELECT_ALL                   14
#define DISPID_RESULTVIEWS_EVENT_COMPARE_ITEMS                  15
#define DISPID_RESULTVIEWS_EVENT_FIND_ITEM                      16
#define DISPID_RESULTVIEWS_EVENT_CACHE_HINT                     17
#define DISPID_RESULTVIEWS_EVENT_SORT_ITEMS                     18
#define DISPID_RESULTVIEWS_EVENT_TASK_CLICK                     19
#define DISPID_RESULTVIEWS_EVENT_LISTPAD_BUTTON_CLICK           20
#define DISPID_RESULTVIEWS_EVENT_TASK_NOTIFY                    21
#define DISPID_RESULTVIEWS_EVENT_PROPERTY_CHANGED               22
#define DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DATA          23
#define DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DISPLAY_INFO  24
#define DISPID_RESULTVIEWS_EVENT_COLUMNS_CHANGED                25
#define DISPID_RESULTVIEWS_EVENT_FILTER_CHANGE                  26
#define DISPID_RESULTVIEWS_EVENT_FILTER_BUTTON_CLICK            27


// IResultView
#define DISPID_RESULTVIEW_NAME                                  DISPID_VALUE
#define DISPID_RESULTVIEW_INDEX                                 1
#define DISPID_RESULTVIEW_KEY                                   2
#define DISPID_RESULTVIEW_SCOPEPANEITEM                         3
#define DISPID_RESULTVIEW_CONTROL                               4
#define DISPID_RESULTVIEW_ADD_TO_VIEW_MENU                      5
#define DISPID_RESULTVIEW_VIEW_MENU_TEXT                        6
#define DISPID_RESULTVIEW_DATA                                  7
#define DISPID_RESULTVIEW_TYPE                                  8
#define DISPID_RESULTVIEW_DISPLAY_STRING                        9
#define DISPID_RESULTVIEW_LISTVIEW                              10
#define DISPID_RESULTVIEW_TASKPAD                               11
#define DISPID_RESULTVIEW_MESSAGEVIEW                           12
#define DISPID_RESULTVIEW_TAG                                   13
#define DISPID_RESULTVIEW_DEFAULT_ITEM_TYPE_GUID                14
#define DISPID_RESULTVIEW_DEFAULT_DATA_FORMAT                   15
#define DISPID_RESULTVIEW_ALWAYS_CREATE_NEW_OCX                 16
#define DISPID_RESULTVIEW_SET_DESCBAR_TEXT                      17

// IMMCImageList
#define DISPID_IMAGELIST_NAME                                   DISPID_VALUE
#define DISPID_IMAGELIST_INDEX                                  1
#define DISPID_IMAGELIST_KEY                                    2
#define DISPID_IMAGELIST_TAG                                    3
#define DISPID_IMAGELIST_MASK_COLOR                             4
#define DISPID_IMAGELIST_LIST_IMAGES                            5

// IMMCImages
#define DISPID_IMAGES_ITEM                                      DISPID_VALUE
#define DISPID_IMAGES_COUNT                                     1
#define DISPID_IMAGES_ADD                                       2
#define DISPID_IMAGES_CLEAR                                     3
#define DISPID_IMAGES_REMOVE                                    4

// IMMCImage
#define DISPID_IMAGE_INDEX                                      1
#define DISPID_IMAGE_KEY                                        2
#define DISPID_IMAGE_TAG                                        3
#define DISPID_IMAGE_PICTURE                                    4

// IMMCListView
#define DISPID_LISTVIEW_COLUMN_HEADERS                          1
#define DISPID_LISTVIEW_ICONS                                   2
#define DISPID_LISTVIEW_LIST_ITEMS                              3
#define DISPID_LISTVIEW_SELECTED_ITEMS                          4
#define DISPID_LISTVIEW_SMALL_ICONS                             5
#define DISPID_LISTVIEW_SORTED                                  6
#define DISPID_LISTVIEW_SORT_KEY                                7
#define DISPID_LISTVIEW_SORT_ORDER                              8
#define DISPID_LISTVIEW_VIEW                                    9
#define DISPID_LISTVIEW_VIRTUAL                                 10
#define DISPID_LISTVIEW_USE_FONT_LINKING                        11
#define DISPID_LISTVIEW_MULTI_SELECT                            12
#define DISPID_LISTVIEW_HIDE_SELECTION                          13
#define DISPID_LISTVIEW_SORT_HEADER                             14
#define DISPID_LISTVIEW_SORT_ICON                               15
#define DISPID_LISTVIEW_FILTER_CHANGE_TIMEOUT                   16
#define DISPID_LISTVIEW_SHOW_CHILD_SCOPEITEMS                   17
#define DISPID_LISTVIEW_LEXICAL_SORT                            18
#define DISPID_LISTVIEW_TAG                                     19
#define DISPID_LISTVIEW_SET_SCOPE_ITEM_STATE                    20

// IMMCListItems
#define DISPID_LISTITEMS_ITEM                                   DISPID_VALUE
#define DISPID_LISTITEMS_COUNT                                  1
#define DISPID_LISTITEMS_ADD                                    2
#define DISPID_LISTITEMS_CLEAR                                  3
#define DISPID_LISTITEMS_REMOVE                                 4
#define DISPID_LISTITEMS_SET_ITEM_COUNT                         5

// IMMCListItem
#define DISPID_LISTITEM_TEXT                                    DISPID_VALUE
#define DISPID_LISTITEM_INDEX                                   1
#define DISPID_LISTITEM_KEY                                     2
#define DISPID_LISTITEM_ID                                      3
#define DISPID_LISTITEM_TAG                                     4
#define DISPID_LISTITEM_ICON                                    5
#define DISPID_LISTITEM_SMALL_ICON                              6
#define DISPID_LISTITEM_SELECTED                                7
#define DISPID_LISTITEM_CUT                                     8
#define DISPID_LISTITEM_DROPHILITED                             9
#define DISPID_LISTITEM_FOCUSED                                 10
#define DISPID_LISTITEM_PASTED                                  11
#define DISPID_LISTITEM_SUBITEMS                                12
#define DISPID_LISTITEM_LIST_SUBITEMS                           13
#define DISPID_LISTITEM_DYNAMIC_EXTENSIONS                      14
#define DISPID_LISTITEM_UPDATE                                  15
#define DISPID_LISTITEM_DATA                                    16
#define DISPID_LISTITEM_UPDATE_ALL_VIEWS                        17
#define DISPID_LISTITEM_ITEM_TYPE_GUID                          18
#define DISPID_LISTITEM_DEFAULT_DATA_FORMAT                     19
#define DISPID_LISTITEM_PROPERTY_CHANGED                        20

// IMMCListSubItems
#define DISPID_LISTSUBITEMS_ITEM                                DISPID_VALUE
#define DISPID_LISTSUBITEMS_COUNT                               1
#define DISPID_LISTSUBITEMS_ADD                                 2
#define DISPID_LISTSUBITEMS_CLEAR                               3
#define DISPID_LISTSUBITEMS_REMOVE                              4

// IMMCListSubItem
#define DISPID_LISTSUBITEM_TEXT                                 DISPID_VALUE
#define DISPID_LISTSUBITEM_INDEX                                1
#define DISPID_LISTSUBITEM_KEY                                  2
#define DISPID_LISTSUBITEM_TAG                                  3

// IMMCColumnHeaders
#define DISPID_COLUMNHEADERS_ITEM                               DISPID_VALUE
#define DISPID_COLUMNHEADERS_COUNT                              1
#define DISPID_COLUMNHEADERS_ADD                                2
#define DISPID_COLUMNHEADERS_CLEAR                              3
#define DISPID_COLUMNHEADERS_REMOVE                             4

// IMMCColumnHeaders
#define DISPID_COLUMNHEADER_TEXT                                DISPID_VALUE
#define DISPID_COLUMNHEADER_INDEX                               1
#define DISPID_COLUMNHEADER_KEY                                 2
#define DISPID_COLUMNHEADER_TAG                                 3
#define DISPID_COLUMNHEADER_WIDTH                               4
#define DISPID_COLUMNHEADER_ALIGNMENT                           5
#define DISPID_COLUMNHEADER_HIDDEN                              6
#define DISPID_COLUMNHEADER_POSITION                            7
#define DISPID_COLUMNHEADER_TEXT_FILTER                         8
#define DISPID_COLUMNHEADER_NUMERIC_FILTER                      9
#define DISPID_COLUMNHEADER_TEXT_FILTER_MAX_LEN                 10

// IColumnSettings
#define DISPID_COLUMNSETTINGS_ITEM                              DISPID_VALUE
#define DISPID_COLUMNSETTINGS_COLUMN_SET_ID                     1
#define DISPID_COLUMNSETTINGS_COUNT                             2
#define DISPID_COLUMNSETTINGS_ADD                               3
#define DISPID_COLUMNSETTINGS_CLEAR                             4
#define DISPID_COLUMNSETTINGS_REMOVE                            5
#define DISPID_COLUMNSETTINGS_PERSIST                           6

// IColumnSetting
#define DISPID_COLUMNSETTING_INDEX                              1
#define DISPID_COLUMNSETTING_KEY                                2
#define DISPID_COLUMNSETTING_WIDTH                              3
#define DISPID_COLUMNSETTING_HIDDEN                             4
#define DISPID_COLUMNSETTING_POSITION                           5

// ISortKeys
#define DISPID_SORTKEYS_ITEM                                    DISPID_VALUE
#define DISPID_SORTKEYS_COLUMN_SET_ID                           2
#define DISPID_SORTKEYS_COUNT                                   3
#define DISPID_SORTKEYS_ADD                                     4
#define DISPID_SORTKEYS_CLEAR                                   5
#define DISPID_SORTKEYS_REMOVE                                  6
#define DISPID_SORTKEYS_PERSIST                                 7

// ISortKey
#define DISPID_SORTKEY_INDEX                                    1
#define DISPID_SORTKEY_KEY                                      2
#define DISPID_SORTKEY_COLUMN                                   3
#define DISPID_SORTKEY_SORTORDER                                4
#define DISPID_SORTKEY_SORTICON                                 5

// ISnapInData
#define DISPID_SNAPINDATA_ITEM                                  DISPID_VALUE
#define DISPID_SNAPINDATA_CLEAR                                 1
#define DISPID_SNAPINDATA_REMOVE                                2

// IMMCDataObjects
#define DISPID_DATAOBJECTS_ITEM                                 DISPID_VALUE
#define DISPID_DATAOBJECTS_COUNT                                1
#define DISPID_DATAOBJECTS_ADD                                  2
#define DISPID_DATAOBJECTS_CLEAR                                3
#define DISPID_DATAOBJECTS_REMOVE                               4

// IMMCDataObject
#define DISPID_DATAOBJECT_DEFAULT_DATA_FORMAT                   DISPID_VALUE
#define DISPID_DATAOBJECT_INDEX                                 1
#define DISPID_DATAOBJECT_KEY                                   2
#define DISPID_DATAOBJECT_OBJECT_TYPES                          3
#define DISPID_DATAOBJECT_CLEAR                                 4
#define DISPID_DATAOBJECT_GET_DATA                              5
#define DISPID_DATAOBJECT_GET_RAW_DATA                          6
#define DISPID_DATAOBJECT_GET_FORMAT                            7
#define DISPID_DATAOBJECT_SET_DATA                              8
#define DISPID_DATAOBJECT_SET_RAW_DATA                          9
#define DISPID_DATAOBJECT_FORMAT_DATA                           10

// IMMCClipboard
#define DISPID_CLIPBOARD_SELECTION_TYPE                         1
#define DISPID_CLIPBOARD_SCOPEITEMS                             2
#define DISPID_CLIPBOARD_LISTITEMS                              3
#define DISPID_CLIPBOARD_DATAOBJECTS                            4

// IMMCMenu
#define DISPID_MENU_NAME                                        DISPID_VALUE
#define DISPID_MENU_INDEX                                       1
#define DISPID_MENU_KEY                                         2
#define DISPID_MENU_CAPTION                                     3
#define DISPID_MENU_VISIBLE                                     4
#define DISPID_MENU_CHECKED                                     5
#define DISPID_MENU_ENABLED                                     6
#define DISPID_MENU_GRAYED                                      7
#define DISPID_MENU_MENU_BREAK                                  8
#define DISPID_MENU_MENU_BAR_BREAK                              9
#define DISPID_MENU_TAG                                         10
#define DISPID_MENU_STATUS_BAR_TEXT                             11
#define DISPID_MENU_CHILDREN                                    12
#define DISPID_MENU_DEFAULT                                     13

// DMMCMenuEvents
#define DISPID_MENU_EVENT_CLICK                                 1

// IMMCMenus
#define DISPID_MENUS_COUNT                                      1
#define DISPID_MENUS_ADD                                        2
#define DISPID_MENUS_ADD_EXISTING                               3
#define DISPID_MENUS_CLEAR                                      4
#define DISPID_MENUS_REMOVE                                     5
#define DISPID_MENUS_SWAP                                       6

// IContextMenu
#define DISPID_CONTEXTMENU_ADD_MENU                             1

// IMMCContextMenuProvider
#define DISPID_CONTEXTMENUPROVIDER_ADD_SNAPIN_ITEMS             1
#define DISPID_CONTEXTMENUPROVIDER_ADD_EXTENSION_ITEMS          2
#define DISPID_CONTEXTMENUPROVIDER_ADD_SHOW_CONTEXT_MENU        3
#define DISPID_CONTEXTMENUPROVIDER_CLEAR                        4

// IPropertySheet
#define DISPID_PROPERTYSHEET_ADD_PAGE                           1
#define DISPID_PROPERTYSHEET_ADD_WIZARD_PAGE                    2
#define DISPID_PROPERTYSHEET_ADD_PAGE_PROVIDER                  3
#define DISPID_PROPERTYSHEET_CHANGE_CANCEL_TO_CLOSE             4
#define DISPID_PROPERTYSHEET_INSERT_PAGE                        5
#define DISPID_PROPERTYSHEET_PRESS_BUTTON                       6
#define DISPID_PROPERTYSHEET_RECALC_PAGE_SIZES                  7
#define DISPID_PROPERTYSHEET_REMOVE_PAGE                        8
#define DISPID_PROPERTYSHEET_ACTIVATE_PAGE                      9
#define DISPID_PROPERTYSHEET_SET_FINISH_BUTTON_TEXT             10
#define DISPID_PROPERTYSHEET_SET_TITLE                          11
#define DISPID_PROPERTYSHEET_SET_WIZARD_BUTTONS                 12
#define DISPID_PROPERTYSHEET_GET_PAGE_POSITION                  13
#define DISPID_PROPERTYSHEET_RESTART_WINDOWS                    14
#define DISPID_PROPERTYSHEET_REBOOT_SYSTEM                      15


// IMMCPropertySheetProvider
#define DISPID_PROPERTYSHEETPROVIDER_CREATE_PROPERTY_SHEET      1
#define DISPID_PROPERTYSHEETPROVIDER_ADD_PRIMARY_PAGES          2
#define DISPID_PROPERTYSHEETPROVIDER_ADD_EXTENSION_ITEMS        3
#define DISPID_PROPERTYSHEETPROVIDER_FIND_PROPERTY_SHEET        4
#define DISPID_PROPERTYSHEETPROVIDER_SHOW                       5
#define DISPID_PROPERTYSHEETPROVIDER_CLEAR                      6

// IControlBar
#define DISPID_CONTROLBAR_ATTACH                                1
#define DISPID_CONTROLBAR_DETACH                                2

// IConsoleVerbs
#define DISPID_CONSOLEVERBS_ITEM                                DISPID_VALUE
#define DISPID_CONSOLEVERBS_COUNT                               1
#define DISPID_CONSOLEVERBS_DEFAULT_VERB                        2

// IConsoleVerb
#define DISPID_CONSOLEVERB_INDEX                                1
#define DISPID_CONSOLEVERB_KEY                                  2
#define DISPID_CONSOLEVERB_VERB                                 3
#define DISPID_CONSOLEVERB_ENABLED                              4
#define DISPID_CONSOLEVERB_CHECKED                              5
#define DISPID_CONSOLEVERB_HIDDEN                               6
#define DISPID_CONSOLEVERB_INDETERMINATE                        7
#define DISPID_CONSOLEVERB_BUTTON_PRESSED                       8
#define DISPID_CONSOLEVERB_DEFAULT                              9

// IMMCToolbar
#define DISPID_TOOLBAR_NAME                                     DISPID_VALUE
#define DISPID_TOOLBAR_INDEX                                    1
#define DISPID_TOOLBAR_KEY                                      2
#define DISPID_TOOLBAR_BUTTONS                                  3
#define DISPID_TOOLBAR_IMAGE_LIST                               4
#define DISPID_TOOLBAR_TAG                                      5

// DMMCToolbarEvents
#define DISPID_TOOLBAR_EVENT_BUTTON_CLICK                       1
#define DISPID_TOOLBAR_EVENT_BUTTON_DROPDOWN                    2
#define DISPID_TOOLBAR_EVENT_BUTTON_MENU_CLICK                  3

// IMMCButtons
#define DISPID_BUTTONS_ITEM                                     DISPID_VALUE
#define DISPID_BUTTONS_COUNT                                    1
#define DISPID_BUTTONS_ADD                                      2
#define DISPID_BUTTONS_CLEAR                                    3
#define DISPID_BUTTONS_REMOVE                                   4

// IMMCButton
#define DISPID_BUTTON_BUTTON_MENUS                              1
#define DISPID_BUTTON_CAPTION                                   2
#define DISPID_BUTTON_ENABLED                                   3
#define DISPID_BUTTON_IMAGE                                     4
#define DISPID_BUTTON_INDEX                                     5
#define DISPID_BUTTON_KEY                                       6
#define DISPID_BUTTON_MIXEDSTATE                                7
#define DISPID_BUTTON_STYLE                                     8
#define DISPID_BUTTON_TAG                                       9
#define DISPID_BUTTON_TOOLTIP_TEXT                              10
#define DISPID_BUTTON_VALUE                                     11
#define DISPID_BUTTON_VISIBLE                                   12

// IMMCButtonMenus
#define DISPID_BUTTONMENUS_ITEM                                 DISPID_VALUE
#define DISPID_BUTTONMENUS_COUNT                                1
#define DISPID_BUTTONMENUS_PARENT                               2
#define DISPID_BUTTONMENUS_ADD                                  3
#define DISPID_BUTTONMENUS_CLEAR                                4
#define DISPID_BUTTONMENUS_REMOVE                               5

// IMMCButtonMenu
#define DISPID_BUTTONMENU_ENABLED                               1
#define DISPID_BUTTONMENU_INDEX                                 2
#define DISPID_BUTTONMENU_KEY                                   3
#define DISPID_BUTTONMENU_PARENT                                4
#define DISPID_BUTTONMENU_TAG                                   5
#define DISPID_BUTTONMENU_TEXT                                  6
#define DISPID_BUTTONMENU_VISIBLE                               7
#define DISPID_BUTTONMENU_CHECKED                               8
#define DISPID_BUTTONMENU_GRAYED                                9
#define DISPID_BUTTONMENU_SEPARATOR                             10
#define DISPID_BUTTONMENU_MENU_BREAK                            11
#define DISPID_BUTTONMENU_MENU_BAR_BREAK                        12


// ITaskPad
#define DISPID_TASKPAD_NAME                                     DISPID_VALUE
#define DISPID_TASKPAD_TYPE                                     1
#define DISPID_TASKPAD_TITLE                                    2
#define DISPID_TASKPAD_DESCRIPTIVE_TEXT                         3
#define DISPID_TASKPAD_URL                                      4
#define DISPID_TASKPAD_BACKGROUND_TYPE                          5
#define DISPID_TASKPAD_MOUSE_OVER_IMAGE                         6
#define DISPID_TASKPAD_MOUSE_OFF_IMAGE                          7
#define DISPID_TASKPAD_FONT_FAMILY                              8
#define DISPID_TASKPAD_EOT_FILE                                 9
#define DISPID_TASKPAD_SYMBOL_STRING                            10
#define DISPID_TASKPAD_LISTPAD_STYLE                            11
#define DISPID_TASKPAD_LISTPAD_TITLE                            12
#define DISPID_TASKPAD_LISTPAD_HAS_BUTTON                       13
#define DISPID_TASKPAD_LISTPAD_BUTTON_TEXT                      14
#define DISPID_TASKPAD_LISTVIEW                                 15
#define DISPID_TASKPAD_TASKS                                    16

// ITasks
#define DISPID_TASKS_ITEM                                       DISPID_VALUE
#define DISPID_TASKS_COUNT                                      1
#define DISPID_TASKS_ADD                                        2
#define DISPID_TASKS_CLEAR                                      3
#define DISPID_TASKS_REMOVE                                     4

// ITask
#define DISPID_TASK_TEXT                                        DISPID_VALUE
#define DISPID_TASK_INDEX                                       1
#define DISPID_TASK_KEY                                         2
#define DISPID_TASK_VISIBLE                                     3
#define DISPID_TASK_TAG                                         4
#define DISPID_TASK_IMAGE_TYPE                                  5
#define DISPID_TASK_MOUSE_OVER_IMAGE                            6
#define DISPID_TASK_MOUSE_OFF_IMAGE                             7
#define DISPID_TASK_FONT_FAMILY                                 8
#define DISPID_TASK_EOT_FILE                                    9
#define DISPID_TASK_SYMBOL_STRING                               10
#define DISPID_TASK_HELP_STRING                                 11
#define DISPID_TASK_ACTION_TYPE                                 12
#define DISPID_TASK_URL                                         13
#define DISPID_TASK_SCRIPT                                      14

// IMMCMessageView
#define DISPID_MESSAGEVIEW_TITLE_TEXT                           1
#define DISPID_MESSAGEVIEW_BODY_TEXT                            2
#define DISPID_MESSAGEVIEW_ICON_TYPE                            3
#define DISPID_MESSAGEVIEW_CLEAR                                4

// IExtensions
#define DISPID_EXTENSIONS_ITEM                                  DISPID_VALUE
#define DISPID_EXTENSIONS_COUNT                                 1
#define DISPID_EXTENSIONS_ENABLE_ALL                            2
#define DISPID_EXTENSIONS_ENABLE_ALL_STATIC                     3

// IExtension
#define DISPID_EXTENSION_INDEX                                  1
#define DISPID_EXTENSION_KEY                                    2
#define DISPID_EXTENSION_CLSID                                  3
#define DISPID_EXTENSION_NAME                                   4
#define DISPID_EXTENSION_TYPE                                   5
#define DISPID_EXTENSION_EXTENDS_NAME_SPACE                     6
#define DISPID_EXTENSION_EXTENDS_CONTEXT_MENU                   7
#define DISPID_EXTENSION_EXTENDS_TOOLBAR                        8
#define DISPID_EXTENSION_EXTENDS_PROPERTY_SHEET                 9
#define DISPID_EXTENSION_EXTENDS_TASKPAD                        10
#define DISPID_EXTENSION_ENABLED                                11
#define DISPID_EXTENSION_NAMESPACE_ENABLED                      12

// IMMCStringTable
#define DISPID_MMCSTRINGTABLE_ADD                               1
#define DISPID_MMCSTRINGTABLE_FIND                              2
#define DISPID_MMCSTRINGTABLE_REMOVE                            3
#define DISPID_MMCSTRINGTABLE_CLEAR                             4

//=-------------------------------------------------------------------------=
//
//                  Extensibility Object Model DISPIDs
//
//=-------------------------------------------------------------------------=

// ISnapInDesignerDef
#define DISPID_SNAPINDESIGNERDEF_SNAPINDEF                         1
#define DISPID_SNAPINDESIGNERDEF_EXTENSIONDEFS                     2
#define DISPID_SNAPINDESIGNERDEF_AUTOCREATE_NODES                  3
#define DISPID_SNAPINDESIGNERDEF_OTHER_NODES                       4
#define DISPID_SNAPINDESIGNERDEF_IMAGELISTS                        5
#define DISPID_SNAPINDESIGNERDEF_MENUS                             6
#define DISPID_SNAPINDESIGNERDEF_TOOLBARS                          7
#define DISPID_SNAPINDESIGNERDEF_VIEWDEFS                          8
#define DISPID_SNAPINDESIGNERDEF_DATA_FORMATS                      9
#define DISPID_SNAPINDESIGNERDEF_REGINFO                           10
#define DISPID_SNAPINDESIGNERDEF_TYPEINFO_COOKIE                   11
#define DISPID_SNAPINDESIGNERDEF_PROJECTNAME                       12

// IViewDefs
#define DISPID_VIEWDEFS_LIST_VIEWS                              1
#define DISPID_VIEWDEFS_OCX_VIEWS                               2
#define DISPID_VIEWDEFS_URL_VIEWS                               3
#define DISPID_VIEWDEFS_TASKPAD_VIEWS                           4

// ISnapInDef
#define DISPID_SNAPINDEF_NAME                                   DISPID_VALUE
#define DISPID_SNAPINDEF_NODE_TYPE_NAME                         1
#define DISPID_SNAPINDEF_NODE_TYPE_GUID                         2
#define DISPID_SNAPINDEF_DISPLAY_NAME                           3
#define DISPID_SNAPINDEF_TYPE                                   4
#define DISPID_SNAPINDEF_HELP_FILE                              5
#define DISPID_SNAPINDEF_DESCRIPTION                            6
#define DISPID_SNAPINDEF_PROVIDER                               7
#define DISPID_SNAPINDEF_VERSION                                8
#define DISPID_SNAPINDEF_SMALL_FOLDERS                          9
#define DISPID_SNAPINDEF_SMALL_FOLDERS_OPEN                     10
#define DISPID_SNAPINDEF_LARGE_FOLDERS                          11
#define DISPID_SNAPINDEF_ICON                                   12
#define DISPID_SNAPINDEF_WATERMARK                              13
#define DISPID_SNAPINDEF_HEADER                                 14
#define DISPID_SNAPINDEF_PALETTE                                15
#define DISPID_SNAPINDEF_STRETCH_WATERMARK                      16
#define DISPID_SNAPINDEF_STATIC_FOLDER                          17
#define DISPID_SNAPINDEF_CAPTION                                18
#define DISPID_SNAPINDEF_DEFAULTVIEW                            19
#define DISPID_SNAPINDEF_EXTENSIBLE                             20
#define DISPID_SNAPINDEF_VIEWDEFS                               21
#define DISPID_SNAPINDEF_CHILDREN                               22
#define DISPID_SNAPINDEF_IID                                    23
#define DISPID_SNAPINDEF_PRELOAD                                24
#define DISPID_SNAPINDEF_LINKED_TOPICS                          25

// IExtensionDefs
#define DISPID_EXTENSIONDEFS_NAME                               0
#define DISPID_EXTENSIONDEFS_EXTENDS_NEW_MENU                   1
#define DISPID_EXTENSIONDEFS_EXTENDS_TASK_MENU                  2
#define DISPID_EXTENSIONDEFS_EXTENDS_TOP_MENU                   3
#define DISPID_EXTENSIONDEFS_EXTENDS_VIEW_MENU                  4
#define DISPID_EXTENSIONDEFS_EXTENDS_PROPERTYPAGES              5
#define DISPID_EXTENSIONDEFS_EXTENDS_TOOLBAR                    6
#define DISPID_EXTENSIONDEFS_EXTENDS_NAMESPACE                  7
#define DISPID_EXTENSIONDEFS_EXTENDED_SNAPINS                   8

// IExtendedSnapIn
#define DISPID_EXTENDEDSNAPIN_NAME                              DISPID_VALUE
#define DISPID_EXTENDEDSNAPIN_INDEX                             1
#define DISPID_EXTENDEDSNAPIN_KEY                               2
#define DISPID_EXTENDEDSNAPIN_NODE_TYPE_GUID                    3
#define DISPID_EXTENDEDSNAPIN_NODE_TYPE_NAME                    4
#define DISPID_EXTENDEDSNAPIN_DYNAMIC                           5
#define DISPID_EXTENDEDSNAPIN_EXTENDS_NAMESPACE                 6
#define DISPID_EXTENDEDSNAPIN_EXTENDS_NEW_MENU                  7
#define DISPID_EXTENDEDSNAPIN_EXTENDS_TASK_MENU                 8
#define DISPID_EXTENDEDSNAPIN_EXTENDS_PROPERTYPAGES             9
#define DISPID_EXTENDEDSNAPIN_EXTENDS_TOOLBAR                   10
#define DISPID_EXTENDEDSNAPIN_EXTENDS_TASKPAD                   11

// IScopeItemDef
#define DISPID_SCOPEITEMDEF_NAME                                DISPID_VALUE
#define DISPID_SCOPEITEMDEF_INDEX                               1
#define DISPID_SCOPEITEMDEF_KEY                                 2
#define DISPID_SCOPEITEMDEF_NODE_TYPE_NAME                      3
#define DISPID_SCOPEITEMDEF_NODE_TYPE_GUID                      4
#define DISPID_SCOPEITEMDEF_DISPLAY_NAME                        5
#define DISPID_SCOPEITEMDEF_FOLDER                              6
#define DISPID_SCOPEITEMDEF_DEFAULT_DATA_FORMAT                 7
#define DISPID_SCOPEITEMDEF_AUTOCREATE                          8
#define DISPID_SCOPEITEMDEF_DEFAULTVIEW                         9
#define DISPID_SCOPEITEMDEF_EXTENSIBLE                          10
#define DISPID_SCOPEITEMDEF_HAS_CHILDREN                        11
#define DISPID_SCOPEITEMDEF_VIEWDEFS                            12
#define DISPID_SCOPEITEMDEF_CHILDREN                            13
#define DISPID_SCOPEITEMDEF_TAG                                 14
#define DISPID_SCOPEITEMDEF_COLUMN_HEADERS                      15

// INodeType
#define DISPID_NODETYPE_INDEX                                   1
#define DISPID_NODETYPE_KEY                                     2
#define DISPID_NODETYPE_NAME                                    3
#define DISPID_NODETYPE_GUID                                    4

// INodeTypes
#define DISPID_NODETYPES_COUNT                                  1
#define DISPID_NODETYPES_ADD                                    2
#define DISPID_NODETYPES_CLEAR                                  3
#define DISPID_NODETYPES_REMOVE                                 4

// IRegInfo
#define DISPID_REGINFO_DISPLAY_NAME                             1
#define DISPID_REGINFO_STATIC_NODE_TYPE_GUID                    2
#define DISPID_REGINFO_STANDALONE                               3
#define DISPID_REGINFO_NODETYPES                                4
#define DISPID_REGINFO_EXTENDED_SNAPINS                         5

// IListViewDef
#define DISPID_LISTVIEWDEF_NAME                                 DISPID_VALUE
#define DISPID_LISTVIEWDEF_INDEX                                1
#define DISPID_LISTVIEWDEF_KEY                                  2
#define DISPID_LISTVIEWDEF_TAG                                  3
#define DISPID_LISTVIEWDEF_ADD_TO_VIEW_MENU                     4
#define DISPID_LISTVIEWDEF_VIEW_MENU_TEXT                       5
#define DISPID_LISTVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT            6
#define DISPID_LISTVIEWDEF_DEFAULT_ITEM_TYPE_GUID               7
#define DISPID_LISTVIEWDEF_EXTENSIBLE                           8
#define DISPID_LISTVIEWDEF_MULTI_SELECT                         9
#define DISPID_LISTVIEWDEF_HIDE_SELECTION                       10
#define DISPID_LISTVIEWDEF_SORT_HEADER                          11
#define DISPID_LISTVIEWDEF_SORT_ICON                            12
#define DISPID_LISTVIEWDEF_SORTED                               13
#define DISPID_LISTVIEWDEF_SORT_KEY                             14
#define DISPID_LISTVIEWDEF_SORT_ORDER                           15
#define DISPID_LISTVIEWDEF_VIEW                                 16
#define DISPID_LISTVIEWDEF_VIRTUAL                              17
#define DISPID_LISTVIEWDEF_USE_FONT_LINKING                     18
#define DISPID_LISTVIEWDEF_FILTER_CHANGE_TIMEOUT                19
#define DISPID_LISTVIEWDEF_SHOW_CHILD_SCOPEITEMS                20
#define DISPID_LISTVIEWDEF_LEXICAL_SORT                         21
#define DISPID_LISTVIEWDEF_LISTVIEW                             22


// IOCXViewDef
#define DISPID_OCXVIEWDEF_NAME                                  DISPID_VALUE
#define DISPID_OCXVIEWDEF_INDEX                                 1
#define DISPID_OCXVIEWDEF_KEY                                   2
#define DISPID_OCXVIEWDEF_TAG                                   3
#define DISPID_OCXVIEWDEF_ADD_TO_VIEW_MENU                      4
#define DISPID_OCXVIEWDEF_VIEW_MENU_TEXT                        5
#define DISPID_OCXVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT             6
#define DISPID_OCXVIEWDEF_PROGID                                7
#define DISPID_OCXVIEWDEF_ALWAYS_CREATE_NEW_OCX                 8

// IURLViewDef
#define DISPID_URLVIEWDEF_NAME                                  DISPID_VALUE
#define DISPID_URLVIEWDEF_INDEX                                 1
#define DISPID_URLVIEWDEF_KEY                                   2
#define DISPID_URLVIEWDEF_TAG                                   3
#define DISPID_URLVIEWDEF_ADD_TO_VIEW_MENU                      4
#define DISPID_URLVIEWDEF_VIEW_MENU_TEXT                        5
#define DISPID_URLVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT             6
#define DISPID_URLVIEWDEF_URL                                   7

// ITaskpadViewDef
#define DISPID_TASKPADVIEWDEF_NAME                              DISPID_VALUE
#define DISPID_TASKPADVIEWDEF_INDEX                             1
#define DISPID_TASKPADVIEWDEF_KEY                               2
#define DISPID_TASKPADVIEWDEF_ADD_TO_VIEW_MENU                  3
#define DISPID_TASKPADVIEWDEF_VIEW_MENU_TEXT                    4
#define DISPID_TASKPADVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT         5
#define DISPID_TASKPADVIEWDEF_USE_WHEN_TASKPAD_VIEW_PREFERRED   6
#define DISPID_TASKPADVIEWDEF_TASKPAD                           7

// IScopeItemsDefs
#define DISPID_SCOPEITEMDEFS_COUNT                              1
#define DISPID_SCOPEITEMDEFS_CLEAR                              2
#define DISPID_SCOPEITEMDEFS_REMOVE                             3
#define DISPID_SCOPEITEMDEFS_ADD                                4

// IExtendedSnapIns
#define DISPID_EXTENDEDSNAPINS_COUNT                            1
#define DISPID_EXTENDEDSNAPINS_CLEAR                            2
#define DISPID_EXTENDEDSNAPINS_REMOVE                           3
#define DISPID_EXTENDEDSNAPINS_ADD                              4

// IMMCImageLists
#define DISPID_MMCIMAGELISTS_COUNT                              1
#define DISPID_MMCIMAGELISTS_CLEAR                              2
#define DISPID_MMCIMAGELISTS_REMOVE                             3
#define DISPID_MMCIMAGELISTS_ADD                                4

// IMMCMenuDef
#define DISPID_MMCMENUDEF_INDEX                                 1
#define DISPID_MMCMENUDEF_KEY                                   2
#define DISPID_MMCMENUDEF_MENU                                  3
#define DISPID_MMCMENUDEF_CHILDREN                              4

// IMMCMenuDefs
#define DISPID_MMCMENUDEFS_COUNT                                1
#define DISPID_MMCMENUDEFS_ADD                                  2
#define DISPID_MMCMENUDEFS_ADD_EXISTING                         3
#define DISPID_MMCMENUDEFS_CLEAR                                4
#define DISPID_MMCMENUDEFS_REMOVE                               5
#define DISPID_MMCMENUDEFS_SWAP                                 6

// IMMCToolbars
#define DISPID_MMCTOOLBARS_COUNT                                1
#define DISPID_MMCTOOLBARS_CLEAR                                2
#define DISPID_MMCTOOLBARS_REMOVE                               3
#define DISPID_MMCTOOLBARS_ADD                                  4

// IListViewDefs
#define DISPID_LISTVIEWDEFS_COUNT                               1
#define DISPID_LISTVIEWDEFS_CLEAR                               2
#define DISPID_LISTVIEWDEFS_REMOVE                              3
#define DISPID_LISTVIEWDEFS_ADD                                 4
#define DISPID_LISTVIEWDEFS_ADD_FROM_MASTER                     5

// IOCXViewDefs
#define DISPID_OCXVIEWDEFS_COUNT                                1
#define DISPID_OCXVIEWDEFS_CLEAR                                2
#define DISPID_OCXVIEWDEFS_REMOVE                               3
#define DISPID_OCXVIEWDEFS_ADD                                  4
#define DISPID_OCXVIEWDEFS_ADD_FROM_MASTER                      5

// IURLViewDefs
#define DISPID_URLVIEWDEFS_COUNT                                1
#define DISPID_URLVIEWDEFS_CLEAR                                2
#define DISPID_URLVIEWDEFS_REMOVE                               3
#define DISPID_URLVIEWDEFS_ADD                                  4
#define DISPID_URLVIEWDEFS_ADD_FROM_MASTER                      5

// ITaskpadViewDefs
#define DISPID_TASKPADVIEWDEFS_COUNT                            1
#define DISPID_TASKPADVIEWDEFS_CLEAR                            2
#define DISPID_TASKPADVIEWDEFS_REMOVE                           3
#define DISPID_TASKPADVIEWDEFS_ADD                              4
#define DISPID_TASKPADVIEWDEFS_ADD_FROM_MASTER                  5

// IDataFormat
#define DISPID_DATAFORMAT_NAME                                  DISPID_VALUE
#define DISPID_DATAFORMAT_INDEX                                 1  
#define DISPID_DATAFORMAT_KEY                                   2    
#define DISPID_DATAFORMAT_FILENAME                              3

// IDataFormats
#define DISPID_DATAFORMATS_COUNT                                1 
#define DISPID_DATAFORMATS_ADD                                  2   
#define DISPID_DATAFORMATS_CLEAR                                3 
#define DISPID_DATAFORMATS_REMOVE                               4

// IWizardPage
#define DISPID_WIZARD_PAGE_ACTIVATE                             1
#define DISPID_WIZARD_PAGE_BACK                                 2
#define DISPID_WIZARD_PAGE_NEXT                                 3
#define DISPID_WIZARD_PAGE_FINISH                               4

// IMMCPropertyPage
#define DISPID_PROPERTYPAGE_INITIALIZE                          1
#define DISPID_PROPERTYPAGE_HELP                                2
#define DISPID_PROPERTYPAGE_GET_DIALOG_UNIT_SIZE                3
#define DISPID_PROPERTYPAGE_PAGE_QUERY_CANCEL                   4
#define DISPID_PROPERTYPAGE_PAGE_CANCEL                         5
#define DISPID_PROPERTYPAGE_PAGE_CLOSE                          6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\enumtask.h ===
//=--------------------------------------------------------------------------=
// enumtask.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CEnumTask class definition - implements IEnumTASK interface
//
//=--------------------------------------------------------------------------=

#ifndef _ENUMTASK_DEFINED_
#define _ENUMTASK_DEFINED_

#include "tasks.h"
#include "task.h"
#include "snapin.h"

//=--------------------------------------------------------------------------=
//
// class CEnumTask
// 
// Implements IEnumTASK interface. Used by CView to respond to
// IExtendTaskpad::EnumTasks
//
//=--------------------------------------------------------------------------=
class CEnumTask : public CSnapInAutomationObject,
                  public IEnumTASK
{
    private:
        CEnumTask(IUnknown *punkOuter);
        virtual ~CEnumTask();
    
    public:
        static IUnknown *Create(IUnknown * punk);
        void SetTasks(ITasks *piTasks);
        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    private:

    // IEnumTASK

        STDMETHOD(Next)(ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
        STDMETHOD(Skip)(ULONG celt);
        STDMETHOD(Reset)();
        STDMETHOD(Clone)(IEnumTASK **ppEnumTASK);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT GetEnumVARIANT();

        ITasks       *m_piTasks;        // Taskpad.Tasks collection
        IEnumVARIANT *m_piEnumVARIANT;  // IEnumVARIANT on that collection
        CSnapIn      *m_pSnapIn;        // Back pointer to owning CSnapIn
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(EnumTask,           // name
                                NULL,               // clsid
                                NULL,               // objname
                                NULL,               // lblname
                                NULL,               // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_IEnumTASK,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _ENUMTASK_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\enumtask.cpp ===
//=--------------------------------------------------------------------------=
// enumtask.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CEnumTask class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "enumtask.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CEnumTask::CEnumTask(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_ENUM_TASK,
                            static_cast<IEnumTASK *>(this),
                            static_cast<CEnumTask *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CEnumTask::~CEnumTask()
{
    RELEASE(m_piTasks);
    RELEASE(m_piEnumVARIANT);
    InitMemberVariables();
}

void CEnumTask::InitMemberVariables()
{
    m_piTasks = NULL;
    m_piEnumVARIANT = NULL;
    m_pSnapIn = NULL;
}

IUnknown *CEnumTask::Create(IUnknown * punkOuter)
{
    CEnumTask *pTask = New CEnumTask(punkOuter);
    if (NULL == pTask)
    {
        return NULL;
    }
    else
    {
        return pTask->PrivateUnknown();
    }
}


void CEnumTask::SetTasks(ITasks *piTasks)
{
    RELEASE(m_piTasks);
    if (NULL != piTasks)
    {
        piTasks->AddRef();
    }
    m_piTasks = piTasks;
}

HRESULT CEnumTask::GetEnumVARIANT()
{
    HRESULT   hr = S_OK;
    IUnknown *punkNewEnum = NULL;

    // If we didn't get our task collection then that is a bug
    
    IfFalseGo(NULL != m_piTasks, SID_E_INTERNAL);

    // If we already got the IEnumVARIANT from the tasks collection then there's
    // nothing to do.
    
    IfFalseGo(NULL == m_piEnumVARIANT, S_OK);

    IfFailGo(m_piTasks->get__NewEnum(&punkNewEnum));

    IfFailGo(punkNewEnum->QueryInterface(IID_IEnumVARIANT,
                                   reinterpret_cast<void **>(&m_piEnumVARIANT)));

Error:
    QUICK_RELEASE(punkNewEnum);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IEnumTASK Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CEnumTask::Next
(
    ULONG     celt,
    MMC_TASK *rgelt,
    ULONG    *pceltFetched
)
{
    HRESULT                  hr = S_OK;
    ITask                   *piTask = NULL;
    CTask                   *pTask = NULL;
    ULONG                    i = 0;
    ULONG                    cFetched = 0;
    ULONG                    cTotalFetched = 0;
    MMC_TASK                *pMMCTask = rgelt;
    MMC_TASK_DISPLAY_OBJECT *pDispObj = NULL;

    VARIANT varTask;
    ::VariantInit(&varTask);

    // Zero the out parameters

    ::ZeroMemory(pMMCTask, sizeof(*pMMCTask) * celt);

    *pceltFetched = 0;

    // Get the IEnumVARIANT on the tasks collection

    IfFailGo(GetEnumVARIANT());

    // Fetch the task(s). We do these one at a time because MMC documents that
    // it will only request them that way. This loop (in theory) should never run
    // more than once so we do not allocate the VARIANT array and ask for celt
    // items in one shot in order to avoid the extra allocation (not that it will
    // help much given all the others that will occur in the loop).

    for (i = 0; i < celt; i++)
    {
        // Get a CTask * on the next visible task

        do
        {
            RELEASE(piTask);

            // Get the next task.

            IfFailGo(m_piEnumVARIANT->Next(1L, &varTask, &cFetched));

            // If there are no more then we're done

            IfFalseGo(S_OK == hr, hr);

            // Make sure we got exactly 1 task back

            IfFalseGo(1L == cFetched, SID_E_INTERNAL);

            // Get an ITask on it and release the IDispatch in the VARIANT

            IfFailGo(varTask.pdispVal->QueryInterface(IID_ITask,
                                          reinterpret_cast<void **>(&piTask)));
            hr = ::VariantClear(&varTask);
            EXCEPTION_CHECK_GO(hr);

            // Get the CTask from it so we can use direct-dial property fetch
            // routines rather than automation BSTR fetches.

            IfFailGo(CSnapInAutomationObject::GetCxxObject(piTask, &pTask));

        } while (!pTask->Visible());

        // Fill in the MMC_TASK from the Task object's properties
        // Do the display object first.

        pDispObj = &pMMCTask->sDisplayObject;

        switch (pTask->GetImageType())
        {
            case siVanillaGIF:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_VANILLA_GIF;
                break;

            case siChocolateGIF:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF;
                break;

            case siBitmap:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
                break;

            case siSymbol:
                pDispObj->eDisplayType = MMC_TASK_DISPLAY_TYPE_SYMBOL;

                if (ValidBstr(pTask->GetFontfamily()))
                {
                    IfFailGo(::CoTaskMemAllocString(pTask->GetFontfamily(),
                                           &pDispObj->uSymbol.szFontFamilyName));
                }

                if (ValidBstr(pTask->GetEOTFile()))
                {
                    IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetEOTFile(),
                                                &pDispObj->uSymbol.szURLtoEOT));
                }

                if (ValidBstr(pTask->GetSymbolString()))
                {
                    IfFailGo(::CoTaskMemAllocString(pTask->GetSymbolString(),
                                             &pDispObj->uSymbol.szSymbolString));
                }
                break;

            default:
                IfFailGo(SID_E_INTERNAL);
                break;
        }

        if (siSymbol != pTask->GetImageType())
        {
            if (ValidBstr(pTask->GetMouseOverImage()))
            {
                IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetMouseOverImage(),
                                         &pDispObj->uBitmap.szMouseOverBitmap));
            }

            if (ValidBstr(pTask->GetMouseOffImage()))
            {
                IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetMouseOffImage(),
                                         &pDispObj->uBitmap.szMouseOffBitmap));
            }
        }

        // Do text and helpstring

        IfFailGo(::CoTaskMemAllocString(pTask->GetText(), &pMMCTask->szText));

        IfFailGo(::CoTaskMemAllocString(pTask->GetHelpString(),
                                        &pMMCTask->szHelpString));

        // Get the action type

        switch (pTask->GetActionType())
        {
            case siNotify:
                // The user wants a ResultViews_TaskClick event. Set the command
                // ID to the one-based index of the task in its collection.
                pMMCTask->eActionType = MMC_ACTION_ID;
                pMMCTask->nCommandID = pTask->GetIndex();
                break;

            case siURL:
                // The user want the result pane to navigate to this URL when the
                // task is clicked.
                pMMCTask->eActionType = MMC_ACTION_LINK;
                IfFailGo(m_pSnapIn->ResolveResURL(pTask->GetURL(),
                                                &pMMCTask->szActionURL));
                break;
                
            case siScript:
                // The user wants to run the specied DHTML script when the task
                // is clicked.
                pMMCTask->eActionType = MMC_ACTION_SCRIPT;
                IfFailGo(::CoTaskMemAllocString(pTask->GetScript(),
                                                &pMMCTask->szScript));
                break;

            default:
                IfFailGo(SID_E_INTERNAL);
                break;
        }

        RELEASE(piTask);
        pMMCTask++;
        cTotalFetched++;
    }

    if (NULL != pceltFetched)
    {
        *pceltFetched = cTotalFetched;
    }

Error:
    (void)::VariantClear(&varTask);
    if (SID_E_INTERNAL == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    QUICK_RELEASE(piTask);
    RRETURN(hr);
}



STDMETHODIMP CEnumTask::Skip(ULONG celt)
{
    HRESULT hr = S_OK;

    IfFailGo(GetEnumVARIANT());
    IfFailGo(m_piEnumVARIANT->Skip(celt));

Error:
    RRETURN(hr);
}




STDMETHODIMP CEnumTask::Reset()
{
    HRESULT hr = S_OK;

    IfFailGo(GetEnumVARIANT());
    IfFailGo(m_piEnumVARIANT->Reset());

Error:
    if (SID_E_INTERNAL == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


STDMETHODIMP CEnumTask::Clone(IEnumTASK **ppEnumTASK)
{
    HRESULT    hr = S_OK;
    IUnknown  *punkEnumTask = CEnumTask::Create(NULL);
    CEnumTask *pEnumTask = NULL;

    IfFailGo(GetEnumVARIANT());

    if (NULL == pEnumTask)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkEnumTask, &pEnumTask));
    pEnumTask->SetTasks(m_piTasks);

    IfFailGo(pEnumTask->QueryInterface(IID_IEnumTASK,
                                       reinterpret_cast<void **>(ppEnumTASK)));

Error:
    QUICK_RELEASE(punkEnumTask);
    if (SID_E_INTERNAL == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CEnumTask::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IEnumTASK == riid)
    {
        *ppvObjOut = static_cast<IEnumTASK *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\error.cpp ===
//=--------------------------------------------------------------------------=
// error.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CError class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "error.h"

// for ASSERT and FAIL
//
SZTHISFILE


CError::CError(CAutomationObject *pao)
{
    m_pao = pao;
}

CError::CError()
{
    m_pao = NULL;
}

CError::~CError()
{
    m_pao = NULL;
}

static HRESULT BuildDescription
(
    HRESULT  hrException,
    va_list  pArgList,
    DWORD   *pdwHelpID,
    LPWSTR  *ppwszDescription
)
{
    HRESULT hr = S_OK;
    DWORD   cchMsg = 0;
    SCODE   scode = HRESULT_CODE(hrException);
    char   *pszFormatted = NULL;

    char    szFormatString[512];
    ::ZeroMemory(szFormatString, sizeof(szFormatString));

    static const size_t cchMaxMsg = 1024; // max possible formatted msg size

    *pdwHelpID = 0;
    *ppwszDescription = NULL;
    
    // Check whether this is a designer error (from errors.h and mssnapr.id)
    // or a foreign error (e.g. system error). The error range for the designer
    // is hard coded in mssnapr.id and it is based on VB's error range scheme.
    // For information contact Stephen Weatherford (StephWe)
    // There is no define for this.

    if ( (scode >= 9500) && (scode <= 9749) )
    {
        // It's one of our ours. Load the string from the RC

        *pdwHelpID = (DWORD)scode; // UNDONE check that this how helpfile numbers errors

        if (0 != ::LoadString(::GetResourceHandle(), (UINT)scode,
                              szFormatString, sizeof(szFormatString)))
        {
            // Format it.
            cchMsg = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_STRING,
                                     (LPCVOID)szFormatString,
                                     0, // don't need msg ID
                                     0, // don't need lang ID
                                     (LPTSTR)&pszFormatted,
                                     1, // minimum buffer to allocate in chars
                                     &pArgList);
        }
    }
    else
    {
        // It is a system or other foreign error. Ask FormatMessage() to
        // produce the error message. If it can't then use a generic message.

        *pdwHelpID = HID_mssnapr_err_SystemError;

        cchMsg = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                 FORMAT_MESSAGE_FROM_SYSTEM     |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                                 NULL,      // no source
                                 hrException,
                                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 (LPTSTR)&pszFormatted,
                                 0,
                                 NULL);
    }

    // At this point we might have a formatted message. If not then use
    // a generic one. If that won't load then use a hard coded message.

    if ( (0 == cchMsg) || (NULL == pszFormatted) )
    {
        if (0 == ::LoadString(GetResourceHandle(), IDS_GENERIC_ERROR_MSG,
                              szFormatString, sizeof(szFormatString)))
        {
            ::strcpy(szFormatString, "Snap-in designer runtime error: 0x%08.8X");
        }
        pszFormatted = (char *)::LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cchMaxMsg);
        IfFalseGo(NULL != pszFormatted, E_OUTOFMEMORY);
        cchMsg = (DWORD)((UINT)::_snprintf(pszFormatted, cchMaxMsg,
                                           szFormatString, hrException));
        IfFalseGo(0 != cchMsg, E_FAIL);
    }

    // If we made it to here then we have a message. Now we need to convert it
    // to UNICODE.

    IfFailGo(::WideStrFromANSI(pszFormatted, ppwszDescription));

Error:
    if (NULL != pszFormatted)
    {
        ::LocalFree(pszFormatted);
    }
    RRETURN(hr);
}


static void SetExceptionInfo
(
    LPWSTR  pwszDescription,
    DWORD   dwHelpContextID
)
{
    HRESULT           hr = S_OK;
    ICreateErrorInfo *piCreateErrorInfo;
    IErrorInfo       *piErrorInfo;

    // Get the CreateErrorInfo object.

    IfFailGo(::CreateErrorInfo(&piCreateErrorInfo));

    // Put in all the exception information

    IfFailGo(piCreateErrorInfo->SetGUID(GUID_NULL));
    IfFailGo(piCreateErrorInfo->SetHelpFile(HELP_FILENAME_WIDE));
    IfFailGo(piCreateErrorInfo->SetHelpContext(dwHelpContextID));
    IfFailGo(piCreateErrorInfo->SetDescription(pwszDescription));
    IfFailGo(piCreateErrorInfo->SetSource(L"SnapInDesignerRuntime.SnapIn"));

    // Set the ErrorInfo object in the system

    IfFailGo(piCreateErrorInfo->QueryInterface(IID_IErrorInfo,
                                      reinterpret_cast<void **>(&piErrorInfo)));
    IfFailGo(::SetErrorInfo(0, piErrorInfo));

Error:
    QUICK_RELEASE(piErrorInfo);
    QUICK_RELEASE(piCreateErrorInfo);
}




void cdecl CError::GenerateExceptionInfo(HRESULT hrException, ...)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszDescription = NULL;
    DWORD   dwHelpID = 0;
    va_list pArgList;
    va_start(pArgList, hrException);

    // Build the description string and determine the help context ID

    IfFailGo(::BuildDescription(hrException, pArgList, &dwHelpID, &pwszDescription));

    // Pass it on to CAutomationObject if we have one or generate
    // our own error.

    if (NULL == m_pao)
    {
        ::SetExceptionInfo(pwszDescription, dwHelpID);
    }
    else
    {
        (void)m_pao->Exception(hrException, pwszDescription, dwHelpID);
    }

Error:
    if (NULL != pwszDescription)
    {
        ::CtlFree(pwszDescription);
    }
}

void cdecl CError::GenerateInternalExceptionInfo(HRESULT hrException, ...)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszDescription = NULL;
    DWORD   dwHelpID = 0;
    va_list pArgList;
    va_start(pArgList, hrException);

    // Build the description string and determine the help context ID

    IfFailGo(::BuildDescription(hrException, pArgList, &dwHelpID, &pwszDescription));

    // Set the ErrorInfo stuff

    ::SetExceptionInfo(pwszDescription, dwHelpID);

Error:
    if (NULL != pwszDescription)
    {
        ::CtlFree(pwszDescription);
    }
}

void CError::DisplayErrorInfo()
{
// UNDONE
}

void cdecl CError::WriteEventLog(UINT idMessage, ...)
{
// UNDONE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\errors.h ===
//=--------------------------------------------------------------------------=
// errors.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Error Codes Defined by the Designer Runtime
//
//=--------------------------------------------------------------------------=


#ifndef _ERRORS_DEFINED_
#define _ERRORS_DEFINED_

#include "mssnapr_helpids.h"

// Replacements for framework's macros.h stuff that does not work in header
// files.

#if defined(DEBUG)
extern HRESULT HrDebugTraceReturn(HRESULT hr, char *szFile, int iLine);
#define H_RRETURN(hr) return HrDebugTraceReturn(hr, __FILE__, __LINE__)
#else
#define H_RRETURN(hr) return (hr)
#endif

#if defined(DEBUG)
#define H_FAILEDHR(HR) _H_FAILEDHR(HR, __FILE__, __LINE__)

inline BOOL _H_FAILEDHR(HRESULT hr, char* pszFile, unsigned int uiLine)
{
    if (FAILED(hr))
    {
        HrDebugTraceReturn(hr, pszFile, uiLine);
    }
    return FAILED(hr);
}
#else
#define H_FAILEDHR(HR) FAILED(HR)
#endif

#if defined(DEBUG)

#define H_ASSERT(fTest, szMsg)                                  \
    if (!(fTest))                                               \
    {                                                           \
        static char szMsgCode[] = szMsg;                        \
        static char szAssert[] = #fTest;                        \
        DisplayAssert(szMsgCode, szAssert, __FILE__, __LINE__); \
    }

#else
#define H_ASSERT(fTest, err)
#endif


#define H_IfFailGoto(EXPR, LABEL) \
    { hr = (EXPR); if(H_FAILEDHR(hr)) goto LABEL; }

#define H_IfFailRet(EXPR) \
    { hr = (EXPR); if(H_FAILEDHR(hr)) H_RRETURN(hr); }

#define H_IfFailGo(EXPR) H_IfFailGoto(EXPR, Error)

#define H_IfFalseGoto(EXPR, HR, LABEL) \
   { if(!(EXPR)) { hr = (HR); goto LABEL; } }

#define H_IfFalseGo(EXPR, HR) H_IfFalseGoto(EXPR, HR, Error)

#define H_IfFalseRet(EXPR, HR) \
    { if(!(EXPR)) H_RRETURN(HR); }

// Macro to create a return code from an error name in the ID file.
// See below for examples of usage.

#define _MKERR(x)   MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, x)
#define MKERR(x)    _MKERR(HID_mssnapr_err_##x)


//---------------------------------------------------------------------------
//
// HOW TO ADD A NEW ERROR
//
//
// 1) Add the error to mssnapr.id. Both design time and runtime errors should
//    be defined in this file.
//    Do *not* use devid to determine the help context id, but rather use
//    the error number itself
// 2) Add a define below for the error, using the MKERR macro
// 3) You may only return Win32 error codes and snap-in defined SID_E_XXXX
//    error codes. Do not use OLE E_XXX error codes directly as the
//    system message table does not have description strings for all of these
//    errors. If any OLE E_XXXX, CO_E_XXX, CTL_E_XXX or other such errors are
//    needed then add them as SID_E errors using the procedure described
//    above. If an error comes from an outside source and you are not sure
//    if error information is available for it then return SIR_E_EXTERNAL
//    and write the error to the event log using CError::WriteEventLog (see
//    error.h).
// 4) Add an entry to the SnapInErrorConstants section in mssnapr.idl
// 5) Check out mmcvbderr.csf from VSS. Contact Gary Kraut for this (a-GaryK).
//    Add an explanation for the new error and then ask Gary to update the
//    footnotes and the ALIAS and MAP sections in the HHP file for the snap-in
//    docs.
//---------------------------------------------------------------------------

// Errors defined by the snap-in designer

#define SID_E_EXCEPTION                     MKERR(Exception)
#define SID_E_OUTOFMEMORY                   MKERR(OutOfMemory)
#define SID_E_INVALIDARG                    MKERR(InvalidArg)
#define SID_E_CONSOLEERROR                  MKERR(ConsoleError)
#define SID_E_UNKNOWNFORMAT                 MKERR(UnknownFormat)
#define SID_E_TEXT_SERIALIZATION            MKERR(TextSerialzation)
#define SID_E_INTERNAL                      MKERR(InternalError)
#define SID_E_UNSUPPORTED_STGMEDIUM         MKERR(UnsupportedStgMedium)
#define SID_E_INCOMPLETE_WRITE              MKERR(IncompleteWrite)
#define SID_E_INCOMPLETE_READ               MKERR(IncompleteRead)
#define SID_E_UNSUPPORTED_TYPE              MKERR(UnsupportedType)
#define SID_E_KEY_NOT_UNIQUE                MKERR(KeyNotUnique)
#define SID_E_ELEMENT_NOT_FOUND             MKERR(ElementNotFound)
#define SID_E_CLIPFORMATS_NOT_REGISTERED    MKERR(ClipformatsNotRegistered)
#define SID_E_INVALID_IMAGE_TYPE            MKERR(InvalidImageType)
#define SID_E_DETACHED_OBJECT               MKERR(DetachedObject)
#define SID_E_TOOLBAR_HAS_NO_IMAGELIST      MKERR(ToolbarHasNoImageList)
#define SID_E_TOOLBAR_HAS_NO_IMAGES         MKERR(ToolbarHasNoImages)
#define SID_E_TOOLBAR_IMAGE_NOT_FOUND       MKERR(ToolbarImageNotFound)
#define SID_E_SYSTEM_ERROR                  MKERR(SystemError)
#define SID_E_TOO_MANY_MENU_ITEMS           MKERR(TooManyMenuItems)
#define SID_E_READ_ONLY_AT_RUNTIME          MKERR(ReadOnlyAtRuntime);
#define SID_E_MENUTOPLEVEL                  MKERR(MenuItemDistinct);
#define SID_E_DUPLICATEMENU                 MKERR(DuplicateMenu);
#define SID_E_INVALIDIDENTIFIER             MKERR(InvalidIdentifier);
#define SID_E_INVALID_PROPERTY_PAGE_NAME    MKERR(InvalidPropertyPageName);
#define SID_E_INVALID_VARIANT               MKERR(InvalidVariant)
#define SID_E_OBJECT_NOT_PERSISTABLE        MKERR(ObjectNotPersistable);
#define SID_E_OBJECT_NOT_PUBLIC_CREATABLE   MKERR(ObjectNotPublicCreatable);
#define SID_E_UNKNOWN_LISTVIEW              MKERR(UnknownListView)
#define SID_E_INVALID_RAW_DATA_TYPE         MKERR(InvalidRawDataType)
#define SID_E_FORMAT_NOT_AVAILABLE          MKERR(FormatNotAvailable);
#define SID_E_NOT_EXTENSIBLE                MKERR(NotExtensible);
#define SID_E_SERIALIZATION_CORRUPT         MKERR(SerialzationCorrupt);
#define SID_E_CANT_REMOVE_STATIC_NODE       MKERR(CantRemoveStaticNode);
#define SID_E_CANT_CHANGE_UNOWNED_SCOPENODE MKERR(CantChangeUnownedScopeNode)
#define SID_E_UNSUPPORTED_ON_VIRTUAL_LIST   MKERR(UnsupportedOnVirtualList)
#define SID_E_NO_KEY_ON_VIRTUAL_ITEMS       MKERR(NoKeyOnVirtualItems)
#define SID_E_INDEX_OUT_OF_RANGE            MKERR(IndexOutOfRange)
#define SID_E_NOT_CONNECTED_TO_MMC          MKERR(NotConnectedToMMC)
#define SID_E_DATA_NOT_AVAILABLE_IN_HGLOBAL MKERR(DataNotAvailableInHglobal)
#define SID_E_CANT_DELETE_PICTURE           MKERR(CantDeletePicture)
#define SID_E_CONTROLBAR_NOT_AVAILABLE      MKERR(ControlbarNotAvailable)
#define SID_E_COLLECTION_READONLY           MKERR(CollectionReadOnly)
#define SID_E_INVALID_COLUMNSETID           MKERR(InvalidColumnSetID)
#define SID_E_MMC_FEATURE_NOT_AVAILABLE     MKERR(MMCFeatureNotAvailable)
#define SID_E_COLUMNS_NOT_PERSISTED         MKERR(ColumnsNotPersisted)
#define SID_E_ICON_REQUIRED                 MKERR(IconRequired)
#define SID_E_CANT_DELETE_ICON              MKERR(CantDeleteIcon)
#define SID_E_TOOLBAR_INCONSISTENT          MKERR(ToolbarInconsistent)
#define SID_E_UNSUPPORTED_TYMED             MKERR(UnsupportedDataMedium)
#define SID_E_DATA_TOO_LARGE                MKERR(DataTooLarge)
#define SID_E_MMC_VERSION_NOT_AVAILABLE     MKERR(MMCVersionNotAvailable)
#define SID_E_SORT_SETTINGS_NOT_PERSISTED   MKERR(SortSettingsNotPersisted)
#define SID_E_SCOPE_NODE_NOT_CONNECTED      MKERR(ScopeNodeNotConnectedToMMC)
#define SID_E_NO_SCOPEITEMS_IN_VIRTUAL_LIST MKERR(NoScopeItemsInVirtualList)
#define SID_E_CANT_ALTER_PAGE_COUNT         MKERR(CantAlterPageCount)

#endif // _ERRORS_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\error.h ===
//=--------------------------------------------------------------------------=
// error.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CError class definition
//
//=--------------------------------------------------------------------------=


#ifndef _ERROR_DEFINED_
#define _ERROR_DEFINED_


//---------------------------------------------------------------------------
//
//                      How to Use the CError Class
//                      ===========================
//
// Classes that derive from Framework CAutomationXxxx classes should also
// derive from CError. This gives CError access to the various bits of
// information it needs to generate rich error info. To generate error
// info call GenerateExceptionInfo(hr, ...). Error messages use FormatMessage
// replacement syntax and replacement parameters may be of any type.
// 
// Classes that are not automation objects may use the static
// method GenerateInternalExceptionInfo().
//
// Note that the excpetion info generation methods may be called at any level
// of depth in UI, extensibility, or programming model code. For
// extensibility and programming model the error info will optionally be
// retrieved by the client code if desired. For UI, the UI entry point (e.g.
// mouse click handler) should call the static method DisplayErrorInfo().
//
// Exception info should be generated at the point at which the error occurs.
// For example, if CoCreateInstance() returns an error then the exception
// info should be generated at that point because you know that
// CoCreateInstance() will not generate it. On the other hand, if you call
// into a lower level of designer code and it returns an error then you can
// assume that the exception info was generated.
//
//---------------------------------------------------------------------------


#if defined(MSSNAPR_BUILD)
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT __declspec(dllimport)
#endif

// Some useful macros to insert at the end of a function if not explicitly
// generating an exception with specific arguments.

#if defined(DEBUG)

#define EXCEPTION_CHECK(hr)             if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); }

#define EXCEPTION_CHECK_GO(hr)          if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); goto Error; }

#define GLOBAL_EXCEPTION_CHECK(hr)    if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); }

#define GLOBAL_EXCEPTION_CHECK_GO(hr) if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); ::HrDebugTraceReturn(hr, __FILE__, __LINE__); goto Error; }

#else

#define EXCEPTION_CHECK(hr)             if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); }

#define EXCEPTION_CHECK_GO(hr)          if (FAILED(hr)) { (static_cast<CError *>(this))->GenerateExceptionInfo(hr); goto Error; }

#define GLOBAL_EXCEPTION_CHECK(hr)    if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); }

#define GLOBAL_EXCEPTION_CHECK_GO(hr) if (FAILED(hr)) { CError::GenerateInternalExceptionInfo(hr); goto Error; }

#endif

class DLLEXPORT CError
{
    public:
        CError(CAutomationObject *pao);
        CError();
        ~CError();

        void cdecl GenerateExceptionInfo(HRESULT hr, ...);
        static void cdecl GenerateInternalExceptionInfo(HRESULT hr, ...);
        static void DisplayErrorInfo();
        static void cdecl WriteEventLog(UINT idMessage, ...);

    private:
        CAutomationObject *m_pao;
};

#endif // _ERRORS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extdefs.h ===
//=--------------------------------------------------------------------------=
// extdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionDefs class definition - design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _EXTENSIONDEFS_DEFINED_
#define _EXTENSIONDEFS_DEFINED_


class CExtensionDefs : public CSnapInAutomationObject,
                       public CPersistence,
                       public IExtensionDefs
{
    private:
        CExtensionDefs(IUnknown *punkOuter);
        ~CExtensionDefs();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IExtensionDefs

        BSTR_PROPERTY_RO(CExtensionDefs,   Name, DISPID_VALUE);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsNewMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_NEW_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsTaskMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_TASK_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsTopMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_TOP_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsViewMenu, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_VIEW_MENU);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsPropertyPages, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_PROPERTYPAGES);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsToolbar, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_TOOLBAR);
        SIMPLE_PROPERTY_RW(CExtensionDefs, ExtendsNameSpace, VARIANT_BOOL, DISPID_EXTENSIONDEFS_EXTENDS_NAMESPACE);
        OBJECT_PROPERTY_RW(CExtensionDefs, ExtendedSnapIns, IExtendedSnapIns, DISPID_EXTENSIONDEFS_EXTENDED_SNAPINS);
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtensionDefs,              // name
                                &CLSID_ExtensionDefs,       // clsid
                                "ExtensionDefs",            // objname
                                "ExtensionDefs",            // lblname
                                &CExtensionDefs::Create,    // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IExtensionDefs,        // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _EXTENSIONDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extdefs.cpp ===
//=--------------------------------------------------------------------------=
// extdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "extdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CExtensionDefs::CExtensionDefs(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_EXTENSIONDEFS,
                            static_cast<IExtensionDefs *>(this),
                            static_cast<CExtensionDefs *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ExtensionDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtensionDefs::~CExtensionDefs()
{
    FREESTRING(m_bstrName);
    RELEASE(m_piExtendedSnapIns);
    InitMemberVariables();
}

void CExtensionDefs::InitMemberVariables()
{
    m_bstrName = NULL;
    m_ExtendsNewMenu = VARIANT_FALSE;
    m_ExtendsTaskMenu = VARIANT_FALSE;
    m_ExtendsTopMenu = VARIANT_FALSE;
    m_ExtendsViewMenu = VARIANT_FALSE;
    m_ExtendsPropertyPages = VARIANT_FALSE;
    m_ExtendsNameSpace = VARIANT_FALSE;
    m_ExtendsToolbar = VARIANT_FALSE;
    m_piExtendedSnapIns = NULL;
}

IUnknown *CExtensionDefs::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;
    char    szName[512];
    
    CExtensionDefs *pExtensionDefs = New CExtensionDefs(punkOuter);
    if (NULL == pExtensionDefs)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (0 == ::LoadString(::GetResourceHandle(), IDS_EXTENSIONDEFS_NAME,
                          szName, sizeof(szName)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(BSTRFromANSI(szName, &pExtensionDefs->m_bstrName));

Error:
    if (FAILED(hr))
    {
        if (NULL != pExtensionDefs)
        {
            delete pExtensionDefs;
        }
        return NULL;
    }
    else
    {
        return pExtensionDefs->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionDefs::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_ExtendsNewMenu, VARIANT_FALSE, OLESTR("ExtendsNewMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsTaskMenu, VARIANT_FALSE, OLESTR("ExtendsTaskMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsTopMenu, VARIANT_FALSE, OLESTR("ExtendsTopMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsViewMenu, VARIANT_FALSE, OLESTR("ExtendsViewMenu")));

    IfFailRet(PersistSimpleType(&m_ExtendsPropertyPages, VARIANT_FALSE, OLESTR("ExtendsPropertyPages")));

    IfFailRet(PersistSimpleType(&m_ExtendsToolbar, VARIANT_FALSE, OLESTR("ExtendsToolbar")));

    IfFailRet(PersistSimpleType(&m_ExtendsNameSpace, VARIANT_FALSE, OLESTR("ExtendsNameSpace")));

    IfFailRet(PersistObject(&m_piExtendedSnapIns, CLSID_ExtendedSnapIns,
                            OBJECT_TYPE_EXTENDEDSNAPINS, IID_IExtendedSnapIns,
                            OLESTR("ExtendedSnapIns")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IExtensionDefs == riid)
    {
        *ppvObjOut = static_cast<IExtensionDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionDefs::OnSetHost()
{
    RRETURN(SetObjectHost(m_piExtendedSnapIns));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\help.h ===
//---------------------------------------------------------------------------
// help.h
//---------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
//
// Contains help info needed by the .IDL file and the
// DEFINE_AUTOMATIONOBJECTWEVENTS2 structure.  Define everything here once
// so we keep both items in sync. 
//

#ifndef _HELP_H
#define _HELP_H

#define HELP_FILENAME "VBSnapInsGuide.chm"
#define HELP_DLLFILENAME "MSSNAPR.DLL"
#define HELP_PPFILENAME HELP_FILENAME // Property page filename

#define merge(a,b) a ## b
#define WIDESTRINGCONSTANT(x) merge(L,x)
#define HELP_FILENAME_WIDE WIDESTRINGCONSTANT(HELP_FILENAME)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extsnap.h ===
//=--------------------------------------------------------------------------=
// extsnap.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionSnapIn class definition - implements ExtensionSnapIn object
//
//=--------------------------------------------------------------------------=

#ifndef _EXTSNAP_DEFINED_
#define _EXTSNAP_DEFINED_

#include "snapin.h"

class CExtensionSnapIn : public CSnapInAutomationObject,
                         public IExtensionSnapIn
{
    private:
        CExtensionSnapIn(IUnknown *punkOuter);
        ~CExtensionSnapIn();
    
    public:
        static IUnknown *Create(IUnknown * punk);
        void SetSnapIn(CSnapIn *pSnapIn);

        void FireAddNewMenuItems(IMMCDataObjects *piMMCDataObjects,
                                 IContextMenu    *piContextMenu);

        void FireAddTaskMenuItems(IMMCDataObjects *piMMCDataObjects,
                                  IContextMenu    *piContextMenu);

        void FireCreatePropertyPages(IMMCDataObject    *piMMCDataObject,
                                     IMMCPropertySheet *piMMCPropertySheet);

        void FireSetControlbar(IMMCControlbar *piControlbar);

        void FireUpdateControlbar(VARIANT_BOOL     fvarSelectionInScopePane,
                                  VARIANT_BOOL     fvarSelected,
                                  IMMCDataObjects *piMMCDataObjects,
                                  IMMCControlbar  *piMMCControlbar);

        void FireAddTasks(IMMCDataObject *piMMCDataObject,
                          BSTR            bstrGroupName,
                          ITasks         *piTasks);

        void FireTaskClick(IMMCDataObject *piMMCDataObject, ITask *piTask);

        void FireExpand(IMMCDataObject *piMMCDataObject, IScopeNode *piScopeNode);
        void FireCollapse(IMMCDataObject *piMMCDataObject, IScopeNode *piScopeNode);
        void FireExpandSync(IMMCDataObject *piMMCDataObject,
                            IScopeNode     *piScopeNode,
                            BOOL           *pfHandled);
        void FireCollapseSync(IMMCDataObject *piMMCDataObject,
                              IScopeNode     *piScopeNode,
                              BOOL           *pfHandled);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CSnapIn *m_pSnapIn; // back pointer to CSnapIn

        // Event parameter definitions

        static VARTYPE   m_rgvtAddNewMenuItems[2];
        static EVENTINFO m_eiAddNewMenuItems;

        static VARTYPE   m_rgvtAddTaskMenuItems[2];
        static EVENTINFO m_eiAddTaskMenuItems;

        static VARTYPE   m_rgvtCreatePropertyPages[2];
        static EVENTINFO m_eiCreatePropertyPages;

        static VARTYPE   m_rgvtSetControlbar[1];
        static EVENTINFO m_eiSetControlbar;

        static VARTYPE   m_rgvtUpdateControlbar[4];
        static EVENTINFO m_eiUpdateControlbar;

        static VARTYPE   m_rgvtAddTasks[3];
        static EVENTINFO m_eiAddTasks;

        static VARTYPE   m_rgvtTaskClick[2];
        static EVENTINFO m_eiTaskClick;

        static VARTYPE   m_rgvtExpand[2];
        static EVENTINFO m_eiExpand;

        static VARTYPE   m_rgvtCollapse[2];
        static EVENTINFO m_eiCollapse;

        static VARTYPE   m_rgvtExpandSync[3];
        static EVENTINFO m_eiExpandSync;

        static VARTYPE   m_rgvtCollapseSync[3];
        static EVENTINFO m_eiCollapseSync;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ExtensionSnapIn,                // name
                                &CLSID_ExtensionSnapIn,         // clsid
                                "ExtensionSnapIn",              // objname
                                "ExtensionSnapIn",              // lblname
                                &CExtensionSnapIn::Create,      // creation function
                                TLIB_VERSION_MAJOR,             // major version
                                TLIB_VERSION_MINOR,             // minor version
                                &IID_IExtensionSnapIn,          // dispatch IID
                                &DIID_DExtensionSnapInEvents,   // event IID
                                HELP_FILENAME,                  // help file
                                TRUE);                          // thread safe


#endif // _EXTSNAP_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\image.h ===
//=--------------------------------------------------------------------------=
// image.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImage class definition - implements MMCImage object
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGE_DEFINED_
#define _IMAGE_DEFINED_


class CMMCImage : public CSnapInAutomationObject,
                  public CPersistence,
                  public IMMCImage
{
    private:
        CMMCImage(IUnknown *punkOuter);
        ~CMMCImage();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCImage

        SIMPLE_PROPERTY_RW(CMMCImage,     Index, long, DISPID_IMAGE_INDEX);
        BSTR_PROPERTY_RW(CMMCImage,       Key, DISPID_IMAGE_KEY);
        VARIANTREF_PROPERTY_RW(CMMCImage, Tag, DISPID_IMAGE_TAG);
        OBJECT_PROPERTY_RW(CMMCImage,     Picture, IPictureDisp, DISPID_IMAGE_PICTURE);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // Public utility functions
    public:
        BSTR GetKeyPtr() { return m_bstrKey; }
        IPictureDisp *GetPicture() { return m_piPicture; }
        HRESULT GetPictureHandle(short TypeNeeded, OLE_HANDLE *phPicture);

    private:

        void InitMemberVariables();
        HBITMAP m_hBitmap; // for bitmaps, bitmap is cached here to improve
                           // performance of multiple fetches
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImage,           // name
                                &CLSID_MMCImage,    // clsid
                                "MMCImage",         // objname
                                "MMCImage",         // lblname
                                &CMMCImage::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_IMMCImage,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _IMAGE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\extsnap.cpp ===
//=--------------------------------------------------------------------------=
// extsnap.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtensionSnapIn class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "extsnap.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CExtensionSnapIn::m_rgvtAddNewMenuItems[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiAddNewMenuItems =
{
    DISPID_EXTENSIONSNAPIN_EVENT_ADD_NEW_MENU_ITEMS,
    sizeof(m_rgvtAddNewMenuItems) / sizeof(m_rgvtAddNewMenuItems[0]),
    m_rgvtAddNewMenuItems
};


VARTYPE CExtensionSnapIn::m_rgvtAddTaskMenuItems[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiAddTaskMenuItems =
{
    DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASK_MENU_ITEMS,
    sizeof(m_rgvtAddTaskMenuItems) / sizeof(m_rgvtAddTaskMenuItems[0]),
    m_rgvtAddTaskMenuItems
};


VARTYPE CExtensionSnapIn::m_rgvtCreatePropertyPages[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiCreatePropertyPages =
{
    DISPID_EXTENSIONSNAPIN_EVENT_CREATE_PROPERTY_PAGES,
    sizeof(m_rgvtCreatePropertyPages) / sizeof(m_rgvtCreatePropertyPages[0]),
    m_rgvtCreatePropertyPages
};


VARTYPE CExtensionSnapIn::m_rgvtSetControlbar[1] =
{
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiSetControlbar =
{
    DISPID_EXTENSIONSNAPIN_EVENT_SET_CONTROLBAR,
    sizeof(m_rgvtSetControlbar) / sizeof(m_rgvtSetControlbar[0]),
    m_rgvtSetControlbar
};


VARTYPE CExtensionSnapIn::m_rgvtUpdateControlbar[4] =
{
    VT_BOOL,
    VT_BOOL,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiUpdateControlbar =
{
    DISPID_EXTENSIONSNAPIN_EVENT_UPDATE_CONTROLBAR,
    sizeof(m_rgvtUpdateControlbar) / sizeof(m_rgvtUpdateControlbar[0]),
    m_rgvtUpdateControlbar
};


VARTYPE CExtensionSnapIn::m_rgvtTaskClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiTaskClick =
{
    DISPID_EXTENSIONSNAPIN_EVENT_TASK_CLICK,
    sizeof(m_rgvtTaskClick) / sizeof(m_rgvtTaskClick[0]),
    m_rgvtTaskClick
};


VARTYPE CExtensionSnapIn::m_rgvtAddTasks[3] =
{
    VT_UNKNOWN,
    VT_BSTR,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiAddTasks =
{
    DISPID_EXTENSIONSNAPIN_EVENT_ADD_TASKS,
    sizeof(m_rgvtAddTasks) / sizeof(m_rgvtAddTasks[0]),
    m_rgvtAddTasks
};


VARTYPE CExtensionSnapIn::m_rgvtExpand[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiExpand =
{
    DISPID_EXTENSIONSNAPIN_EVENT_EXPAND,
    sizeof(m_rgvtExpand) / sizeof(m_rgvtExpand[0]),
    m_rgvtExpand
};


VARTYPE CExtensionSnapIn::m_rgvtCollapse[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CExtensionSnapIn::m_eiCollapse =
{
    DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE,
    sizeof(m_rgvtCollapse) / sizeof(m_rgvtCollapse[0]),
    m_rgvtCollapse
};


VARTYPE CExtensionSnapIn::m_rgvtExpandSync[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CExtensionSnapIn::m_eiExpandSync =
{
    DISPID_EXTENSIONSNAPIN_EVENT_EXPAND_SYNC,
    sizeof(m_rgvtExpandSync) / sizeof(m_rgvtExpandSync[0]),
    m_rgvtExpandSync
};


VARTYPE CExtensionSnapIn::m_rgvtCollapseSync[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CExtensionSnapIn::m_eiCollapseSync =
{
    DISPID_EXTENSIONSNAPIN_EVENT_COLLAPSE_SYNC,
    sizeof(m_rgvtCollapseSync) / sizeof(m_rgvtCollapseSync[0]),
    m_rgvtCollapseSync
};



#pragma warning(disable:4355)  // using 'this' in constructor

CExtensionSnapIn::CExtensionSnapIn(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_EXTENSIONSNAPIN,
                           static_cast<IExtensionSnapIn *>(this),
                           static_cast<CExtensionSnapIn *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CExtensionSnapIn::~CExtensionSnapIn()
{
    InitMemberVariables();
}

void CExtensionSnapIn::InitMemberVariables()
{
    m_pSnapIn = NULL;
}

IUnknown *CExtensionSnapIn::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkExtensionSnapIn = NULL;

    CExtensionSnapIn *pExtensionSnapIn = New CExtensionSnapIn(punkOuter);

    if (NULL == pExtensionSnapIn)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    punkExtensionSnapIn = pExtensionSnapIn->PrivateUnknown();

Error:
    return punkExtensionSnapIn;
}


void CExtensionSnapIn::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}



void CExtensionSnapIn::FireAddNewMenuItems
(
    IMMCDataObjects *piMMCDataObjects,
    IContextMenu    *piContextMenu
)
{
    DebugPrintf("Firing ExtensionSnapIn_AddNewMenuItems\r\n");

    FireEvent(&m_eiAddNewMenuItems, piMMCDataObjects, piContextMenu);

}


void CExtensionSnapIn::FireAddTaskMenuItems
(
    IMMCDataObjects *piMMCDataObjects,
    IContextMenu    *piContextMenu
)
{
    DebugPrintf("Firing ExtensionSnapIn_AddTaskMenuItems\r\n");

    FireEvent(&m_eiAddTaskMenuItems, piMMCDataObjects, piContextMenu);
}


void CExtensionSnapIn::FireCreatePropertyPages
(
    IMMCDataObject    *piMMCDataObject,
    IMMCPropertySheet *piMMCPropertySheet
)
{
    DebugPrintf("Firing ExtensionSnapIn_CreatePropertyPages\r\n");

    FireEvent(&m_eiCreatePropertyPages, piMMCDataObject, piMMCPropertySheet);
}


void CExtensionSnapIn::FireSetControlbar
(
    IMMCControlbar *piControlbar
)
{
    DebugPrintf("Firing ExtensionSnapIn_SetControlbar\r\n");

    FireEvent(&m_eiSetControlbar, piControlbar);

}


void CExtensionSnapIn::FireUpdateControlbar
(
    VARIANT_BOOL     fvarSelectionInScopePane,
    VARIANT_BOOL     fvarSelected,
    IMMCDataObjects *piMMCDataObjects,
    IMMCControlbar  *piMMCControlbar
)
{
    DebugPrintf("Firing ExtensionSnapIn_UpdateControlbar\r\n");

    FireEvent(&m_eiUpdateControlbar, fvarSelectionInScopePane, fvarSelected,
              piMMCDataObjects, piMMCControlbar);
}



void CExtensionSnapIn::FireTaskClick
(
    IMMCDataObject  *piMMCDataObject,
    ITask           *piTask
)
{
    DebugPrintf("Firing ExtensionSnapIn_TaskClick\r\n");

    FireEvent(&m_eiTaskClick, piMMCDataObject, piTask);
}


void CExtensionSnapIn::FireAddTasks
(
    IMMCDataObject *piMMCDataObject,
    BSTR            bstrGroupName,
    ITasks         *piTasks
)
{
    DebugPrintf("Firing ExtensionSnapIn_AddTasks\r\n");

    FireEvent(&m_eiAddTasks, piMMCDataObject, bstrGroupName, piTasks);
}



void CExtensionSnapIn::FireExpand
(
    IMMCDataObject  *piMMCDataObject,
    IScopeNode      *piScopeNode
)
{
    DebugPrintf("Firing ExtensionSnapIn_Expand\r\n");

    FireEvent(&m_eiExpand, piMMCDataObject, piScopeNode);
}


void CExtensionSnapIn::FireCollapse
(
    IMMCDataObject  *piMMCDataObject,
    IScopeNode      *piScopeNode
)
{
    DebugPrintf("Firing ExtensionSnapIn_Collapse\r\n");

    FireEvent(&m_eiCollapse, piMMCDataObject, piScopeNode);
}


void CExtensionSnapIn::FireExpandSync
(
    IMMCDataObject *piMMCDataObject,
    IScopeNode     *piScopeNode,
    BOOL           *pfHandled
)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);

    DebugPrintf("Firing ExtensionSnapIn_ExpandSync\r\n");

    FireEvent(&m_eiExpandSync, piMMCDataObject, piScopeNode, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


void CExtensionSnapIn::FireCollapseSync
(
    IMMCDataObject *piMMCDataObject,
    IScopeNode     *piScopeNode,
    BOOL           *pfHandled
)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);

    DebugPrintf("Firing ExtensionSnapIn_CollapseSync\r\n");

    FireEvent(&m_eiCollapseSync, piMMCDataObject, piScopeNode, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CExtensionSnapIn::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IExtensionSnapIn == riid)
    {
        *ppvObjOut = static_cast<IExtensionSnapIn *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\image.cpp ===
//=--------------------------------------------------------------------------=
// image.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImage class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "image.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImage::CMMCImage(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCIMAGE,
                            static_cast<IMMCImage *>(this),
                            static_cast<CMMCImage *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImage,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImage::~CMMCImage()
{
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piPicture);
    if (NULL != m_hBitmap)
    {
        (void)::DeleteObject(m_hBitmap);
    }
    InitMemberVariables();
}

void CMMCImage::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    ::VariantInit(&m_varTag);
    m_piPicture = NULL;
    m_hBitmap = NULL;
}

IUnknown *CMMCImage::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;
    CMMCImage *pMMCImage = New CMMCImage(punkOuter);
    if (NULL == pMMCImage)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        // Start out with an empty bitmap so that the VB code will always
        // run even if the picture hasn't been set.
        hr = ::CreateEmptyBitmapPicture(&pMMCImage->m_piPicture);
    }
Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCImage)
        {
            delete pMMCImage;
        }
        return NULL;
    }
    else
    {
        return pMMCImage->PrivateUnknown();
    }
}


HRESULT CMMCImage::GetPictureHandle(short TypeNeeded, OLE_HANDLE *phPicture)
{
    HRESULT hr = S_OK;

    // If a bitmap is requested and we have already cached it then return it

    if ( (PICTYPE_BITMAP == TypeNeeded) && (NULL != m_hBitmap) )
    {
        *phPicture = reinterpret_cast<OLE_HANDLE>(m_hBitmap);
    }
    else
    {
        // Get the handle from the picture object

        IfFailGo(::GetPictureHandle(m_piPicture, TypeNeeded, phPicture));

        // If it's not a bitmap then we're done

        IfFalseGo(PICTYPE_BITMAP == TypeNeeded, S_OK);

        // It is a bitmap. Make a copy and cache it. We do the copying in 
        // order to upgrade the color table of bitmaps that use a lesser
        // number of colors than the screen. For example, a 16 color bitmap
        // on a 256 color string will display as a black box. The CopyBitmap()
        // function (rtutil.cpp) uses the Win32 APIs CreateCompatibleDC() and
        // CreateCompatibleBitmap() to create a new bitmap that is compatible
        // with the screen.

        IfFailGo(::CopyBitmap(reinterpret_cast<HBITMAP>(*phPicture), &m_hBitmap));

        *phPicture = reinterpret_cast<OLE_HANDLE>(m_hBitmap);
    }
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImage::Persist()
{
    HRESULT         hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistPicture(&m_piPicture, OLESTR("Picture")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImage::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCImage == riid)
    {
        *ppvObjOut = static_cast<IMMCImage *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\images.h ===
//=--------------------------------------------------------------------------=
// images.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImages class definition - implements MMCImages collection
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGES_DEFINED_
#define _IMAGES_DEFINED_

#include "collect.h"

class CMMCImages : public CSnapInCollection<IMMCImage, MMCImage, IMMCImages>,
                   public CPersistence
{
    protected:
        CMMCImages(IUnknown *punkOuter);
        ~CMMCImages();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCImages
        STDMETHOD(Add)(VARIANT    Index,
                       VARIANT    Key, 
                       VARIANT    Picture,
                       MMCImage **ppMMCImage);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImages,           // name
                                &CLSID_MMCImages,    // clsid
                                "MMCImages",         // objname
                                "MMCImages",         // lblname
                                &CMMCImages::Create, // creation function
                                TLIB_VERSION_MAJOR,  // major version
                                TLIB_VERSION_MINOR,  // minor version
                                &IID_IMMCImages,     // dispatch IID
                                NULL,                // no events IID
                                HELP_FILENAME,       // help file
                                TRUE);               // thread safe


#endif // _IMAGES_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\images.cpp ===
//=--------------------------------------------------------------------------=
// images.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImages class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "images.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImages::CMMCImages(IUnknown *punkOuter) :
    CSnapInCollection<IMMCImage, MMCImage, IMMCImages>(
                                             punkOuter,
                                             OBJECT_TYPE_MMCIMAGES,
                                             static_cast<IMMCImages *>(this),
                                             static_cast<CMMCImages *>(this),
                                             CLSID_MMCImage,
                                             OBJECT_TYPE_MMCIMAGE,
                                             IID_IMMCImage,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImages,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImages::~CMMCImages()
{
}

IUnknown *CMMCImages::Create(IUnknown * punkOuter)
{
    CMMCImages *pMMCImages = New CMMCImages(punkOuter);
    if (NULL == pMMCImages)
    {
        return NULL;
    }
    else
    {
        return pMMCImages->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IMMCImages Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCImages::Add
(
    VARIANT    Index,
    VARIANT    Key, 
    VARIANT    Picture,
    MMCImage **ppMMCImage
)
{
    HRESULT       hr = S_OK;
    IMMCImage    *piMMCImage = NULL;
    IPictureDisp *piPictureDisp = NULL;

    hr = CSnapInCollection<IMMCImage, MMCImage, IMMCImages>::Add(Index, Key, &piMMCImage);
    IfFailGo(hr);

    if (ISPRESENT(Picture))
    {
        if (VT_UNKNOWN == Picture.vt)
        {
            if (NULL == Picture.punkVal)
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            else
            {
                hr = Picture.punkVal->QueryInterface(IID_IPictureDisp, reinterpret_cast<void **>(&piPictureDisp));
                if (FAILEDHR(hr))
                {
                    hr = SID_E_INVALIDARG;
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else if (VT_DISPATCH == Picture.vt)
        {
            if (NULL == Picture.pdispVal)
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            else
            {
                hr = Picture.pdispVal->QueryInterface(IID_IPictureDisp, reinterpret_cast<void **>(&piPictureDisp));
                if (FAILEDHR(hr))
                {
                    hr = SID_E_INVALIDARG;
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(piMMCImage->putref_Picture(piPictureDisp));
    }

    *ppMMCImage = reinterpret_cast<MMCImage *>(piMMCImage);

Error:
    QUICK_RELEASE(piPictureDisp);
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCImage);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImages::Persist()
{
    HRESULT           hr = S_OK;
    IMMCImage  *piMMCImage = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCImage, MMCImage, IMMCImages>::Persist(piMMCImage);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImages::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCImages == riid)
    {
        *ppvObjOut = static_cast<IMMCImages *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCImage, MMCImage, IMMCImages>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglists.h ===
//=--------------------------------------------------------------------------=
// imglists.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageLists class definition - implements MMCImageLists collection
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGELISTS_DEFINED_
#define _IMAGELISTS_DEFINED_

#include "collect.h"

class CMMCImageLists : public CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>,
                       public CPersistence
{
    protected:
        CMMCImageLists(IUnknown *punkOuter);
        ~CMMCImageLists();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImageLists,           // name
                                &CLSID_MMCImageLists,    // clsid
                                "MMCImageLists",         // objname
                                "MMCImageLists",         // lblname
                                &CMMCImageLists::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IMMCImageLists,     // dispatch IID
                                NULL,                    // no events IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _IMAGELISTS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglist.cpp ===
//=--------------------------------------------------------------------------=
// imglist.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageList class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "imglist.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CMMCImageList::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_MMCImageListImagesPP,
    &CLSID_StockColorPage
};


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImageList::CMMCImageList(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCIMAGELIST,
                            static_cast<IMMCImageList *>(this),
                            static_cast<CMMCImageList *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImageList,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImageList::~CMMCImageList()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    RELEASE(m_piListImages);
    InitMemberVariables();
}

void CMMCImageList::InitMemberVariables()
{
    m_Index = 0;
    m_bstrName = NULL;
    m_bstrKey = NULL;
    m_MaskColor = 0;
    m_piListImages = NULL;
}

IUnknown *CMMCImageList::Create(IUnknown * punkOuter)
{
    CMMCImageList *pMMCImageList = New CMMCImageList(punkOuter);
    if (NULL == pMMCImageList)
    {
        return NULL;
    }
    else
    {
        return pMMCImageList->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageList::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistSimpleType(&m_MaskColor, (OLE_COLOR)0, OLESTR("MaskColor")));

    IfFailRet(PersistObject(&m_piListImages, CLSID_MMCImages,
                            OBJECT_TYPE_MMCIMAGES, IID_IMMCImages,
                            OLESTR("ListImages")));

    IfFailRet(PersistDISPID());

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageList::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCImageList == riid)
    {
        *ppvObjOut = static_cast<IMMCImageList *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglist.h ===
//=--------------------------------------------------------------------------=
// imglist.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageList class definition - implements MMCImageList
//
//=--------------------------------------------------------------------------=

#ifndef _IMAGELIST_DEFINED_
#define _IMAGELIST_DEFINED_


class CMMCImageList : public CSnapInAutomationObject,
                      public CPersistence,
                      public IMMCImageList
{
    private:
        CMMCImageList(IUnknown *punkOuter);
        ~CMMCImageList();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCImageList

        BSTR_PROPERTY_RW(CMMCImageList,         Name, DISPID_VALUE);
        SIMPLE_PROPERTY_RW(CMMCImageList,       Index, long, DISPID_IMAGELIST_INDEX);
        BSTR_PROPERTY_RW(CMMCImageList,         Key, DISPID_IMAGELIST_KEY);
        VARIANTREF_PROPERTY_RW(CMMCImageList,   Tag, DISPID_IMAGELIST_TAG);
        SIMPLE_PROPERTY_RW(CMMCImageList,       MaskColor, OLE_COLOR, DISPID_IMAGELIST_MASK_COLOR);
        COCLASS_PROPERTY_RW(CMMCImageList,      ListImages, MMCImages, IMMCImages, DISPID_IMAGELIST_LIST_IMAGES);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // Property page CLSIDs for ISpecifyPropertyPages support
        
        static const GUID *m_rgpPropertyPageCLSIDs[2];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCImageList,           // name
                                &CLSID_MMCImageList,    // clsid
                                "MMCImageList",         // objname
                                "MMCImageList",         // lblname
                                &CMMCImageList::Create, // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCImageList,     // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _IMAGELIST_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\imglists.cpp ===
//=--------------------------------------------------------------------------=
// imglists.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCImageLists class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "imglists.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCImageLists::CMMCImageLists(IUnknown *punkOuter) :
    CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>(
                                                     punkOuter,
                                                     OBJECT_TYPE_MMCIMAGELISTS,
                                                     static_cast<IMMCImageLists *>(this),
                                                     static_cast<CMMCImageLists *>(this),
                                                     CLSID_MMCImageList,
                                                     OBJECT_TYPE_MMCIMAGELIST,
                                                     IID_IMMCImageList,
                                                     static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCImageLists,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCImageLists::~CMMCImageLists()
{
}

IUnknown *CMMCImageLists::Create(IUnknown * punkOuter)
{
    CMMCImageLists *pMMCImageLists = New CMMCImageLists(punkOuter);
    if (NULL == pMMCImageLists)
    {
        return NULL;
    }
    else
    {
        return pMMCImageLists->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageLists::Persist()
{
    HRESULT           hr = S_OK;
    IMMCImageList  *piMMCImageList = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>::Persist(piMMCImageList);

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCImageLists::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCImageLists == riid)
    {
        *ppvObjOut = static_cast<IMMCImageLists *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCImageList, MMCImageList, IMMCImageLists>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitem.cpp ===
//=--------------------------------------------------------------------------=
// listitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "listitem.h"
#include "lsubitms.h"
#include "lsubitem.h"
#include "xtensons.h"


// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListItem::CMMCListItem(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCLISTITEM,
                            static_cast<IMMCListItem *>(this),
                            static_cast<CMMCListItem *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCListItem,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListItem::~CMMCListItem()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrID);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    (void)::VariantClear(&m_varIcon);
    RELEASE(m_piListSubItems);
    RELEASE(m_piDynamicExtensions);
    RELEASE(m_punkData);
    FREESTRING(m_bstrItemTypeGUID);
    FREESTRING(m_bstrDefaultDataFormat);
    RELEASE(m_piDynamicExtensions);
    (void)::VariantClear(&m_varHint);
    InitMemberVariables();
}



void CMMCListItem::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrID = NULL;

    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
    
    ::VariantInit(&m_varIcon);

    m_Pasted = VARIANT_FALSE;
    m_piListSubItems = NULL;
    m_piDynamicExtensions = NULL;
    m_punkData = NULL;
    m_bstrItemTypeGUID = NULL;
    m_bstrDefaultDataFormat = NULL;
    m_hri = NULL;
    m_fHaveHri = FALSE;
    m_pMMCListItems = NULL;
    m_pData = NULL;
    m_pSnapIn = NULL;
    m_piDynamicExtensions = NULL;
    m_fVirtual = VARIANT_FALSE;

    ::VariantInit(&m_varHint);
}



IUnknown *CMMCListItem::Create(IUnknown * punkOuter)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkMMCListSubItems = NULL;
    CMMCListItem   *pMMCListItem = New CMMCListItem(punkOuter);

    if (NULL == pMMCListItem)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Create all contained objects

    punkMMCListSubItems = CMMCListSubItems::Create(NULL);
    if (NULL == punkMMCListSubItems)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCListSubItems->QueryInterface(IID_IMMCListSubItems,
                    reinterpret_cast<void **>(&pMMCListItem->m_piListSubItems)));

    // Create the data object and aggregate it. This allows clients to hold
    // onto the list item or the data object and avoid a circular ref count
    // where each object would have to hold a ref on the other.
    
    pMMCListItem->m_punkData = CMMCDataObject::Create(pMMCListItem->PrivateUnknown());
    if (NULL == pMMCListItem->m_punkData)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(pMMCListItem->SetData());


Error:
    QUICK_RELEASE(punkMMCListSubItems);
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCListItem)
        {
            delete pMMCListItem;
        }
        return NULL;
    }
    else
    {
        return pMMCListItem->PrivateUnknown();
    }
}



void CMMCListItem::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    if (NULL != m_pData)
    {
        m_pData->SetSnapIn(pSnapIn);
    }
}



HRESULT CMMCListItem::SetData()
{
    HRESULT         hr = S_OK;
    IMMCDataObject *piMMCDataObject = NULL;
    
    if (NULL != m_punkData)
    {
        IfFailGo(m_punkData->QueryInterface(IID_IMMCDataObject,
                                  reinterpret_cast<void **>(&piMMCDataObject)));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCDataObject, &m_pData));
        m_pData->SetType(CMMCDataObject::ListItem);
        m_pData->SetListItem(this);
        m_pData->SetSnapIn(m_pSnapIn);
    }

Error:
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}



HRESULT CMMCListItem::GetItemState(UINT uiState, VARIANT_BOOL *pfvarOn)
{
    HRESULT          hr = S_OK;
    IResultData     *piResultData = NULL; // not AddRef()ed

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    IfFalseGo(NULL != pfvarOn, SID_E_INVALIDARG);

    *pfvarOn = VARIANT_FALSE;

    IfFailGo(GetIResultData(&piResultData, NULL));

    rdi.mask = RDI_STATE;

    if (m_fVirtual)
    {
        rdi.nIndex = static_cast<int>(m_Index - 1L);
    }
    else
    {
        rdi.itemID = m_hri;
    }

    IfFailGo(piResultData->GetItem(&rdi));

    if ( (rdi.nState & uiState) != 0 )
    {
        *pfvarOn = VARIANT_TRUE;
    }

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



HRESULT CMMCListItem::SetItemState(UINT uiState, VARIANT_BOOL fvarOn)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    IfFailGo(GetIResultData(&piResultData, NULL));

    // Get the current selection state of the item

    rdi.mask = RDI_STATE;

    if (m_fVirtual)
    {
        rdi.nIndex = static_cast<int>(m_Index - 1L);
    }
    else
    {
        rdi.itemID = m_hri;
    }

    IfFailGo(piResultData->GetItem(&rdi));

    // If the state is currently on

    if ( (rdi.nState & uiState) != 0 )
    {
        // If the user asked to turn it off

        if (VARIANT_FALSE == fvarOn)
        {
            // Turn it off
            IfFailGo(piResultData->ModifyItemState(rdi.nIndex, rdi.itemID,
                                                   0,         // add nothing
                                                   uiState)); // remove
                                                              // specified state
        }
    }
    else // the state is currently off
    {
        // If the user asked to turn it on

        if (VARIANT_TRUE == fvarOn)
        {
            // Turn it on
            IfFailGo(piResultData->ModifyItemState(rdi.nIndex, rdi.itemID,
                                                   uiState,// add specified state
                                                   0));    // remove nothing
        }
    }

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CMMCListItem::GetIResultData
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IResultData **ppiResultData [out] IResultData returned here if non-NULL
//   CView       **ppView        [out] CView returned here if non-NULL
//
// Output:
//    None
//
// Notes:
//
// An MMCListItem object has a back-pointer to its owning MMCListItems
// collection. That collection has a back-pointer to its owning MMCListView.
// The back-pointers continue up the object hierarchy to the View object that
// has the IResultData pointer. Although it would be simple to follow the chain
// and check for NULLs along the way, it would not handle the situation of an
// orphaned list item. A list item is orphaned when the list view that contains
// it is destroyed. This can happen easily if a user opens a property page for
// a list item and then selects a different node in the scope pane. The owning
// list view is destroyed but the property page is still running in the other
// thread and has a reference to the MMCListItem object in SelectedControls().
// The property page could call MMCListItem.Update in response to an Apply.
// Unforuntately, the MMCListItem object has a back-pointer and it has no way
// of knowing whether it is still good.
//
// To handle that situation, this function examines every existing list view
// in the snap-in, and checks for two conditions:
//
// 1) ListView.ListItems is the same pointer as this MMCListItem's back pointer
// 2) ListVIew.ListItems.ID is the same as this MMCListItem's ID.
//
// Each MMCListItems has a unique ID (see CMMCListItems ctor in listitms.cpp)
// and each MMCListItem in its collection receives the same ID. (The ID is not
// an exposed property to the VB code).
//
// The code below essentially does this (in VB syntax)
//
// For Each View In SnapIn.Views
//      For Each ScopePaneItem in View.ScopePaneItems
//          For Each ResultView in ScopePaneItem.ResultViews
//              If ResultView.ListView.ListItems = MMCListItem.ListItems And
//                 ResultView.ListView.ListItems.ID = MMCListItem.ID Then
//                      This is match and we can use the View's IResultData
// 
//
HRESULT CMMCListItem::GetIResultData
(
    IResultData **ppiResultData,
    CView       **ppView
)
{
    HRESULT         hr = SID_E_DETACHED_OBJECT;
    CMMCListView   *pMMCListView = NULL;
    CMMCListItems  *pMMCListItems = NULL;

    CViews          *pViews = NULL;
    CView           *pView = NULL;
    long             cViews = 0;

    CScopePaneItems *pScopePaneItems = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    long             cScopePaneItems = 0;

    CResultViews    *pResultViews = NULL;
    CResultView     *pResultView = NULL;
    long             cResultViews = 0;

    long i, j, k = 0;

    if (NULL != ppiResultData)
    {
        *ppiResultData = NULL;
    }
    if (NULL != ppView)
    {
        *ppView = NULL;
    }

    IfFalseGo(NULL != m_pSnapIn, SID_E_DETACHED_OBJECT);
    IfFalseGo(NULL != m_pMMCListItems, SID_E_DETACHED_OBJECT);

    pViews = m_pSnapIn->GetViews();
    IfFalseGo(NULL != pViews, SID_E_DETACHED_OBJECT);

    cViews = pViews->GetCount();
    for (i = 0; i < cViews; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(pViews->GetItemByIndex(i),
                                                       &pView));
        
        pScopePaneItems = pView->GetScopePaneItems();
        if (NULL == pScopePaneItems)
        {
            continue;
        }

        cScopePaneItems = pScopePaneItems->GetCount();
        for (j = 0; j < cScopePaneItems; j++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                             pScopePaneItems->GetItemByIndex(j),
                                             &pScopePaneItem));
            if (!pScopePaneItem->Active())
            {
                continue;
            }

            pResultViews = pScopePaneItem->GetResultViews();
            if (NULL == pResultViews)
            {
                continue;
            }

            cResultViews = pResultViews->GetCount();
            for (k = 0; k < cResultViews; k++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                                pResultViews->GetItemByIndex(k),
                                                &pResultView));
                pMMCListView = pResultView->GetListView();
                if (NULL == pMMCListView)
                {
                    continue;
                }
                
                pMMCListItems = pMMCListView->GetMMCListItems();

                if (NULL == pMMCListItems)
                {
                    continue;
                }

                if ( (pMMCListItems == m_pMMCListItems) &&
                     (pMMCListItems->GetID() == m_pMMCListItems->GetID()) )
                {
                    if (NULL != ppiResultData)
                    {
                        *ppiResultData = pView->GetIResultData();
                    }

                    if (NULL != ppView)
                    {
                        *ppView = pView;
                    }
                    goto Cleanup;
                }
            }
        }
    }


Cleanup:
Error:
    if (S_OK == hr)
    {
        hr = SID_E_DETACHED_OBJECT;
    }

    if (NULL != ppiResultData)
    {
        if (NULL != *ppiResultData)
        {
            hr = S_OK;
        }
    }

    if (NULL != ppView)
    {
        if (NULL != *ppView)
        {
            hr = S_OK;
        }
    }

    if (SID_E_DETACHED_OBJECT == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IMMCListItem Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CMMCListItem::get_Data(MMCDataObject **ppMMCDataObject)
{
    HRESULT hr = S_OK;

    *ppMMCDataObject = NULL;

    if (NULL == m_punkData)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_punkData->QueryInterface(IID_IMMCDataObject,
                                   reinterpret_cast<void **>(ppMMCDataObject)));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::get_Text(BSTR *pbstrText)
{
    RRETURN(GetBstr(pbstrText, m_bstrText));
}



STDMETHODIMP CMMCListItem::put_Text(BSTR bstrText)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    CView       *pView = NULL;

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    // Set the property

    IfFailGo(SetBstr(bstrText, &m_bstrText, DISPID_LISTITEM_TEXT));

    // If we are in a live, non-virtual listview then change it in MMC too

    IfFalseGo(!m_fVirtual, S_OK);
    IfFalseGo(m_fHaveHri, S_OK);
    IfFalseGo(NULL != m_pMMCListItems, S_OK);
    IfFailGo(GetIResultData(&piResultData, &pView));

    // Get the current selection state of the item

    rdi.mask = RDI_STR;
    rdi.str = MMC_CALLBACK;
    rdi.itemID = m_hri;

    IfFailGo(piResultData->SetItem(&rdi));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::get_Icon(VARIANT *pvarIcon)
{
    RRETURN(GetVariant(pvarIcon, m_varIcon));
}


STDMETHODIMP CMMCListItem::put_Icon(VARIANT varIcon)
{
    HRESULT      hr = S_OK;
    int          nImage = 0;
    IResultData *piResultData = NULL; // not AddRef()ed
    CView       *pView = NULL;

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    // Check for a good VT

    if ( (!IS_VALID_INDEX_TYPE(varIcon)) && (!ISEMPTY(varIcon)) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the new value is an empty string or a NULL string then change that to
    // VT_EMPTY as they mean the same thing.

    if (VT_BSTR == varIcon.vt)
    {
        if (NULL == varIcon.bstrVal)
        {
            varIcon.vt = VT_EMPTY;
        }
        else if (0 == ::wcslen(varIcon.bstrVal))
        {
            varIcon.vt = VT_EMPTY;
        }
    }

    IfFailGo(SetVariant(varIcon, &m_varIcon, DISPID_LISTITEM_ICON));

    // If being set to Empty then nothing else to do.

    IfFalseGo(!ISEMPTY(varIcon), S_OK);

    // If we are in a live, non-virtual listview then change it in MMC too

    IfFalseGo(!m_fVirtual, S_OK);
    IfFalseGo(m_fHaveHri, S_OK);
    IfFalseGo(NULL != m_pMMCListItems, S_OK);
    IfFailGo(GetIResultData(&piResultData, &pView));

    // Get the numerical index of the image from MMCListView.Icons.ListImages

    hr = ::GetImageIndex(m_pMMCListItems->GetListView(), varIcon, &nImage);

    // If it is a bad index then return invalid arg.

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Check for other possible errors

    IfFailGo(hr);

    // Index is good. Change it in the console.

    rdi.nImage = nImage;
    rdi.mask = RDI_IMAGE;
    rdi.itemID = m_hri;

    hr = piResultData->SetItem(&rdi);
    EXCEPTION_CHECK_GO(hr);
    
Error:
    RRETURN(hr);
}




STDMETHODIMP CMMCListItem::get_Selected(VARIANT_BOOL *pfvarSelected)
{
    RRETURN(GetItemState(LVIS_SELECTED, pfvarSelected));
}

STDMETHODIMP CMMCListItem::put_Selected(VARIANT_BOOL fvarSelected)
{
    RRETURN(SetItemState(LVIS_SELECTED, fvarSelected));
}




STDMETHODIMP CMMCListItem::get_Focused(VARIANT_BOOL *pfvarFocused)
{
    RRETURN(GetItemState(LVIS_FOCUSED, pfvarFocused));
}

STDMETHODIMP CMMCListItem::put_Focused(VARIANT_BOOL fvarFocused)
{
    RRETURN(SetItemState(LVIS_FOCUSED, fvarFocused));
}




STDMETHODIMP CMMCListItem::get_DropHilited(VARIANT_BOOL *pfvarDropHilited)
{
    RRETURN(GetItemState(LVIS_DROPHILITED, pfvarDropHilited));
}

STDMETHODIMP CMMCListItem::put_DropHilited(VARIANT_BOOL fvarDropHilited)
{
    RRETURN(SetItemState(LVIS_DROPHILITED, fvarDropHilited));
}




STDMETHODIMP CMMCListItem::get_Cut(VARIANT_BOOL *pfvarCut)
{
    RRETURN(GetItemState(LVIS_CUT, pfvarCut));
}

STDMETHODIMP CMMCListItem::put_Cut(VARIANT_BOOL fvarCut)
{
    RRETURN(SetItemState(LVIS_CUT, fvarCut));
}




STDMETHODIMP CMMCListItem::get_SubItems
(
    short Index,
    BSTR *pbstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex,
                                        reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->get_Text(pbstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}

STDMETHODIMP CMMCListItem::put_SubItems
(
    short Index,
    BSTR  bstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex,
                                        reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->put_Text(bstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::Update()
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    HRESULTITEM  hri = 0;
    CView       *pView = NULL;

    IfFalseGo(NULL != m_pMMCListItems, SID_E_DETACHED_OBJECT);
    IfFailGo(GetIResultData(&piResultData, &pView));

    if (m_fVirtual)
    {
        hri = static_cast<HRESULTITEM>(m_Index - 1L);

        // Tell the owning view about the update so it can check whether it
        // needs to invalidate its cache.
        pView->ListItemUpdate(this);
    }
    else
    {
        hri = m_hri;
    }

    IfFailGo(piResultData->UpdateItem(hri));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



STDMETHODIMP CMMCListItem::UpdateAllViews
(
    VARIANT Hint
)
{
    HRESULT  hr = S_OK;
    CView   *pView = NULL;

    IfFalseGo(NULL != m_pMMCListItems, SID_E_DETACHED_OBJECT);
    IfFailGo(GetIResultData(NULL, &pView));

    // Copy the VARIANT (if it was passed) so it can be retrieved by the
    // receiving views. VariantCopy() will first call VariantClear() on the
    // destination so any old hint will be released.

    if (ISPRESENT(Hint))
    {
        IfFailGo(::VariantCopy(&m_varHint, &Hint));
    }
    else
    {
        // Snap-in didn't pass Hint, set our hint holder to an empty VARIANT
        // so when it is passed to ResultViews_ItemViewChange it will have been
        // initialized to VT_EMPTY.

        IfFailGo(::VariantClear(&m_varHint));
    }

    // Call MMC and use data to hold the index of the MMCListItem

    IfFailGo(pView->GetIConsole2()->UpdateAllViews(
                               static_cast<IDataObject *>(m_pData), m_Index, 0));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItem::PropertyChanged(VARIANT Data)
{
    HRESULT       hr = S_OK;
    CResultView  *pResultView = NULL;
    IResultData  *piResultData = NULL;

    IfFalseGo(NULL != m_pSnapIn, SID_E_DETACHED_OBJECT);

    if (SUCCEEDED(GetIResultData(&piResultData, NULL)))
    {
        pResultView = m_pMMCListItems->GetListView()->GetResultView();
    }
    
    // The snap-in has the hidden global ResultViews collection where events
    // are fired. Fire ResultViews_PropertyChanged for this list item passing the
    // specified data.

    m_pSnapIn->GetResultViews()->FirePropertyChanged(
                                        static_cast<IResultView *>(pResultView),
                                        static_cast<IMMCListItem *>(this),
                                        Data);
    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CMMCListItem::get_DynamicExtensions                          [IMMCListItem]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IExtensions **ppiExtenions [out] dynamic extensions collection
//
// Output:
//      HRESULT
//
// Notes:
//
// CONSIDER: potential perf improvement by caching dynamic extension
// collections for item type GUIDs.
//

STDMETHODIMP CMMCListItem::get_DynamicExtensions(Extensions **ppExtensions)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkExtensions = NULL;
    CExtensions  *pExtensions = NULL;
    IExtension   *piExtension = NULL;
    VARIANT_BOOL  fvarExtensible = VARIANT_FALSE;

    // If we already built the collection then just return it.

    IfFalseGo(NULL == m_piDynamicExtensions, S_OK);

    // This is the first GET on this property so we need to build the collection
    // by examining the registry for all extensions of this snap-in.

    punkExtensions = CExtensions::Create(NULL);
    if (NULL == punkExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkExtensions, &pExtensions));
    IfFailGo(pExtensions->Populate(m_bstrItemTypeGUID, CExtensions::Dynamic));
    IfFailGo(punkExtensions->QueryInterface(IID_IExtensions,
                             reinterpret_cast<void **>(&m_piDynamicExtensions)));

Error:

    if (SUCCEEDED(hr))
    {
        m_piDynamicExtensions->AddRef();
        *ppExtensions = reinterpret_cast<Extensions *>(m_piDynamicExtensions);
    }

    QUICK_RELEASE(punkExtensions);
    RRETURN(hr);
}


HRESULT CMMCListItem::GetColumnTextPtr(long lColumn, OLECHAR **ppwszText)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    CMMCListSubItem *pMMCListSubItem = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);


    *ppwszText = NULL;

    varIndex.vt = VT_I4;
    varIndex.lVal = lColumn;
    IfFailGo(m_piListSubItems->get_Item(varIndex,
                                        reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListSubItem,
                                                   &pMMCListSubItem));
    *ppwszText = pMMCListSubItem->GetTextPtr();

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListItem::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrID, L"", OLESTR("ID")));

    // We don't persist the tag because it may contain a non-persistable
    // object. Any runtime code that needs to clone a listitem using
    // persistence must copy the tag.

    if (InitNewing())
    {
        IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));
    }
    
    IfFailGo(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailGo(PersistVariant(&m_varIcon, varDefault, OLESTR("Icon")));

    IfFailGo(PersistSimpleType(&m_Pasted, VARIANT_FALSE, OLESTR("Pasted")));

    IfFailGo(PersistObject(&m_piListSubItems, CLSID_MMCListSubItems,
                           OBJECT_TYPE_MMCLISTSUBITEMS, IID_IMMCListSubItems,
                           OLESTR("ListSubItems")));

    // This serialization is no longer used and the DynamicExtensions property is not
    // always created so this line is left disabled. If serialization is every needed
    // for a listitem then the DynamicExtensions collection will need to be created
    // when the listitem is created.
    
    // IfFailGo(PersistObject(&m_piDynamicExtensions, CLSID_Extensions, OBJECT_TYPE_EXTENSIONS, IID_IExtensions, OLESTR("DynamicExtensions")));

    // NOTE: we don't persist data because there is no way to guarantee that
    // all objects in there are persistable. Any runtime code that needs to
    // clone a listitem using persistence must copy the tag.

    IfFailGo(PersistBstr(&m_bstrItemTypeGUID, L"", OLESTR("ItemTypeGUID")));

    IfFailGo(PersistBstr(&m_bstrDefaultDataFormat, L"", OLESTR("DefaultDataFormat")));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCListItem == riid)
    {
        *ppvObjOut = static_cast<IMMCListItem *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if ( ( (IID_IDataObject == riid) || (IID_IMMCDataObject == riid) ) &&
              (NULL != m_punkData)
            )
    {
        return m_punkData->QueryInterface(riid, ppvObjOut);
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitem.h ===
//=--------------------------------------------------------------------------=
// listitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItem class definition - implements MMCListItem object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTITEM_DEFINED_
#define _LISTITEM_DEFINED_

#include "listitms.h"
#include "dataobj.h"

class CMMCListItems;
class CMMCDataObject;

class CMMCListItem : public CSnapInAutomationObject,
                     public CPersistence,
                     public IMMCListItem
{
    private:
        CMMCListItem(IUnknown *punkOuter);
        ~CMMCListItem();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListItem

        SIMPLE_PROPERTY_RW(CMMCListItem,        Index, long, DISPID_LISTITEM_INDEX);
        BSTR_PROPERTY_RW(CMMCListItem,          Key, DISPID_LISTITEM_KEY);
        BSTR_PROPERTY_RW(CMMCListItem,          ID, DISPID_LISTITEM_ID);
        VARIANTREF_PROPERTY_RW(CMMCListItem,    Tag, DISPID_LISTITEM_TAG);

        STDMETHOD(get_Text)(BSTR *pbstrText);
        STDMETHOD(put_Text)(BSTR bstrText);

        STDMETHOD(put_Icon)(VARIANT varIcon);
        STDMETHOD(get_Icon)(VARIANT *pvarIcon);

        STDMETHOD(get_Selected)(VARIANT_BOOL *pfvarSelected);
        STDMETHOD(put_Selected)(VARIANT_BOOL fvarSelected);

        STDMETHOD(get_Focused)(VARIANT_BOOL *pfvarFocused);
        STDMETHOD(put_Focused)(VARIANT_BOOL fvarFocused);

        STDMETHOD(get_DropHilited)(VARIANT_BOOL *pfvarDropHilited);
        STDMETHOD(put_DropHilited)(VARIANT_BOOL fvarDropHilited);

        STDMETHOD(get_Cut)(VARIANT_BOOL *pfvarCut);
        STDMETHOD(put_Cut)(VARIANT_BOOL fvarCut);

        SIMPLE_PROPERTY_RW(CMMCListItem,        Pasted, VARIANT_BOOL, DISPID_LISTITEM_PASTED);

        STDMETHOD(get_SubItems)(short Index, BSTR *pbstrItem);
        STDMETHOD(put_SubItems)(short Index, BSTR bstrItem);

        COCLASS_PROPERTY_RW(CMMCListItem,       ListSubItems, MMCListSubItems, IMMCListSubItems, DISPID_LISTITEM_LIST_SUBITEMS);

        STDMETHOD(get_DynamicExtensions)(Extensions **ppExtensions);
        STDMETHOD(get_Data)(MMCDataObject **ppMMCDataObject);

        BSTR_PROPERTY_RW(CMMCListItem,          ItemTypeGUID, DISPID_LISTITEM_ITEM_TYPE_GUID);
        BSTR_PROPERTY_RW(CMMCListItem,          DefaultDataFormat, DISPID_LISTITEM_DEFAULT_DATA_FORMAT);

        STDMETHOD(Update)();
        STDMETHOD(UpdateAllViews)(VARIANT Hint);
        STDMETHOD(PropertyChanged)(VARIANT Data);

    // Public utility methods

        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        CMMCDataObject *GetData() { return m_pData; }
        void SetHRESULTITEM(HRESULTITEM hri) { m_hri = hri; m_fHaveHri = TRUE; }
        void RemoveHRESULTITEM() { m_hri = NULL; m_fHaveHri = FALSE; }
        HRESULTITEM GetHRESULTITEM() { return m_hri; }
        void SetListItems(CMMCListItems *pMMCListItems) { m_pMMCListItems = pMMCListItems; }
        CMMCListItems *GetListItems() { return m_pMMCListItems; }
        LPOLESTR GetTextPtr() { return static_cast<LPOLESTR>(m_bstrText); }
        HRESULT GetColumnTextPtr(long lColumn, OLECHAR **ppwszText);
        BSTR GetNodeTypeGUID() { return m_bstrItemTypeGUID; }
        BSTR GetKey() { return m_bstrKey; }
        long GetIndex() { return m_Index; }
        void SetIndex(long lIndex) { m_Index = lIndex; }
        IExtensions *GetDynamicExtensions() { return m_piDynamicExtensions; }
        VARIANT GetHint() { return m_varHint; }
        void ClearHint() { (void)::VariantClear(&m_varHint); }
        void SetVirtual() { m_fVirtual = TRUE; }
        BOOL IsVirtual() { return m_fVirtual; }
        BSTR GetID() { return m_bstrID; }
        
    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT GetItemState(UINT uiState, VARIANT_BOOL *pfvarOn);
        HRESULT SetItemState(UINT uiState, VARIANT_BOOL fvarOn);
        HRESULT SetData();
        HRESULT GetIResultData(IResultData **ppiResultData, CView **ppView);

        HRESULTITEM     m_hri;          // item ID when in result pane
        BOOL            m_fHaveHri;     // TRUE=we have an item ID
        CMMCListItems  *m_pMMCListItems;// owning collection
        CMMCDataObject *m_pData;        // data associated with listitem
        IUnknown       *m_punkData;     // associated data obj's inner IUnknown
        CSnapIn        *m_pSnapIn;      // back pointer to owning snap-in
        VARIANT         m_varHint;      // holds UpdateAllViews() Hint param
        BSTR            m_bstrText;     // holds Text property
        VARIANT         m_varIcon;      // holds Icon property
        BOOL            m_fVirtual;     // TRUE-virtual list item

        IExtensions    *m_piDynamicExtensions; // dynamic extension collection
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListItem,           // name
                                &CLSID_MMCListItem,    // clsid
                                "MMCListItem",         // objname
                                "MMCListItem",         // lblname
                                &CMMCListItem::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IMMCListItem,     // dispatch IID
                                NULL,                  // event IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _LISTITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitms.cpp ===
//=--------------------------------------------------------------------------=
// listitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "listitms.h"
#include "listitem.h"

// for ASSERT and FAIL
//
SZTHISFILE

LONG CMMCListItems::m_NextID = 0;

#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListItems::CMMCListItems(IUnknown *punkOuter) :
    CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>(
                                                   punkOuter,
                                                   OBJECT_TYPE_MMCLISTITEMS,
                                                   static_cast<IMMCListItems *>(this),
                                                   static_cast<CMMCListItems *>(this),
                                                   CLSID_MMCListItem,
                                                   OBJECT_TYPE_MMCLISTITEM,
                                                   IID_IMMCListItem,
                                                   NULL)
{
    InitMemberVariables();

    // Get a unique ID for this colleciton. We use InterlockedExchangeAdd()
    // because InterlockedIncrement() does not have a guranateed return value
    // under Win95.
    
    m_ID = ::InterlockedExchangeAdd(&m_NextID, 1L) + 1L;
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListItems::~CMMCListItems()
{
    // We need to call our own clear (rather than waiting for the
    // CSnapInCollection destructor because we have our own processing to
    // do when a list item is removed from the collection.
    Clear();
    InitMemberVariables();
}

void CMMCListItems::InitMemberVariables()
{
    m_pMMCListView = NULL;
    m_lCount = 0;
    m_ID = 0;
}


IUnknown *CMMCListItems::Create(IUnknown * punkOuter)
{
    CMMCListItems *pMMCListItems = New CMMCListItems(punkOuter);
    if (NULL == pMMCListItems)
    {
        return NULL;
    }
    else
    {
        return pMMCListItems->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
// CMMCListItems::GetIResultData
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IResultData **ppiResultData [out] if non-NULL IResultData returned here
//                                        NOT AddRef()ed
//                                        DO NOT call Release on the returned
//                                        interface pointer
//      CView       **ppView        [out] if non-NULL owning CView returned here
//
// Output:
//      HRESULT
//
// Notes:
//
// As we are only a lowly list item collection and the IResultData pointer
// is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated listitems collection
// created  by the user or if any object up the hierarchy is isolated then we
// will return SID_E_DETACHED_OBJECT
//

HRESULT CMMCListItems::GetIResultData
(
    IResultData **ppiResultData,
    CView       **ppView
)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pMMCListView, hr);

    pResultView = m_pMMCListView->GetResultView();
    IfFalseGo(NULL != pResultView, hr);

    pScopePaneItem = pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);
    IfFalseGo(pScopePaneItem->Active(), hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    if (NULL != ppiResultData)
    {
        *ppiResultData = pView->GetIResultData();
        IfFalseGo(NULL != *ppiResultData, hr);
    }

    if (NULL != ppView)
    {
        *ppView = pView;
    }

    hr = S_OK;

Error:
    RRETURN(hr);
}



HRESULT CMMCListItems::InitializeListItem(CMMCListItem *pMMCListItem)
{
    HRESULT      hr = S_OK;
    CResultView *pResultView = NULL;

    if (NULL != m_pMMCListView)
    {
        pResultView = m_pMMCListView->GetResultView();
        if (NULL != pResultView)
        {
            IfFailGo(pMMCListItem->put_ItemTypeGUID(pResultView->GetDefaultItemTypeGUID()));
            pMMCListItem->SetSnapIn(pResultView->GetSnapIn());
        }
    }
    pMMCListItem->SetListItems(this);

    IfFailGo(pMMCListItem->put_ID(pMMCListItem->GetKey()));

Error:
    RRETURN(hr);
}

HRESULT CMMCListItems::InternalRemove(VARIANT Index, RemovalOption Option)
{
    HRESULT          hr = S_OK;
    IMMCListItem    *piMMCListItem = NULL;
    CMMCListItem    *pMMCListItem = NULL;
    IResultData     *piResultData = NULL; // Not AddRef()ed
    BOOL             fVirtual = FALSE;
    long             lIndex = 0;
    HRESULTITEM      hri = 0;

    // Check whether the collection is read-only. This is possible when the
    // collection is part of a clipboard.

    if (ReadOnly())
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    if (NULL != m_pMMCListView)
    {
        fVirtual = m_pMMCListView->IsVirtual();
    }

    if (!fVirtual)
    {
        // First get the listitem so we can get its HRESULTITEM if needed

        IfFailGo(get_Item(Index, reinterpret_cast<MMCListItem **>(&piMMCListItem)));

        // Remove it from the collection if requested (we still have a ref)

        if (RemoveFromCollection == Option)
        {
            hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::Remove(Index);
            IfFailGo(hr);
        }

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                       &pMMCListItem));

        hri = pMMCListItem->GetHRESULTITEM();
    }
    else
    {
        // For virtual list items the index must be numerical and must be within
        // the range specified by a prior call to SetItemCount

        if FAILED(::ConvertToLong(Index, &lIndex))
        {
            hr = SID_E_NO_KEY_ON_VIRTUAL_ITEMS;
            EXCEPTION_CHECK_GO(hr);
        }

        if (lIndex > m_lCount)
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            EXCEPTION_CHECK_GO(hr);
        }

        hri = static_cast<HRESULTITEM>(lIndex - 1L);
    }

    // If we are connected to a live listview then remove it from there. Need to
    // crawl up the food chain to the view because it has the IResultData.

    IfFalseGo(SUCCEEDED(GetIResultData(&piResultData, NULL)), S_OK);

    hr = piResultData->DeleteItem(hri, 0);
    EXCEPTION_CHECK_GO(hr);

    // If it succeeded and this list item is not virtual then we need to release
    // the reference that we held for presence in the MMC listview. (See
    // CView::InsertListItem()). Also tell the list item it no longer has
    // a valid HRESULTITEM.

    if (!fVirtual)
    {
        piMMCListItem->Release();
        pMMCListItem->RemoveHRESULTITEM();
    }

Error:

    QUICK_RELEASE(piMMCListItem);
    RRETURN(hr);
}


HRESULT CMMCListItems::SetListView(CMMCListView *pMMCListView)
{
    HRESULT        hr = S_OK;
    long           cListItems = GetCount();
    long           i = 0;
    CMMCListItems *pMMCListItems = NULL;
    CMMCListItem  *pMMCListItem = NULL;

    m_pMMCListView = pMMCListView;

    // If the ListView is orphaning this collection then we need to orphan
    // the list items. If not, then we need to give the list items their
    // back pointer.

    if (NULL != pMMCListView)
    {
        pMMCListItems = this;
    }
    
    for (i = 0; i < cListItems; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                       &pMMCListItem));
        pMMCListItem->SetListItems(pMMCListItems);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IMMCListItems Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CMMCListItems::get_Item                                     [IMMCListItems]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   VARIANT Index [in] Numerical index or string key of item to retrieve
//                      For virtual lists this must be numerical and within
//                      range specified by a previous call to SetItemCount
//
//   IMMCListItem **ppiMMCListItem [out] item returned here. Caller must Release.
//
// Output:
//      HRESULT
//
// Notes:
//
// For virtual lists a detached MMCListItem is created and initialized. For
// non-virtual lists this is a normal collection get_Item
//


STDMETHODIMP CMMCListItems::get_Item
(
    VARIANT       Index,
    MMCListItem **ppMMCListItem
)
{
    HRESULT       hr = S_OK;
    long          lIndex = 0;
    BOOL          fVirtual = FALSE;
    IUnknown     *punkMMCListItem = NULL;
    IMMCListItem *piMMCListItem = NULL;
    CMMCListItem *pMMCListItem = NULL;

    VARIANT varStringIndex;
    ::VariantInit(&varStringIndex);

    if (NULL != m_pMMCListView)
    {
        fVirtual = m_pMMCListView->IsVirtual();
    }

    if (!fVirtual)
    {
        hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::get_Item(Index, ppMMCListItem);
        IfFailGo(hr);
    }
    else
    {
        // Make sure we received a numerical index. Can't use a key on a virtual
        // list item because the collection doesn't actually contain the item.
        // It is only used as an access mechanism to the console and to contain
        // properties needed for the console (text, icon, etc.)

        if FAILED(::ConvertToLong(Index, &lIndex))
        {
            hr = SID_E_NO_KEY_ON_VIRTUAL_ITEMS;
            EXCEPTION_CHECK_GO(hr);
        }

        // Check that the index is within the range specified by a prior call
        // to SetItemCount.

        if (lIndex > m_lCount)
        {
            hr = SID_E_INDEX_OUT_OF_RANGE;
            EXCEPTION_CHECK_GO(hr);
        }

        punkMMCListItem = CMMCListItem::Create(NULL);
        if (NULL == punkMMCListItem)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCListItem,
                                                       &pMMCListItem));
        IfFailGo(InitializeListItem(pMMCListItem));

        // Set MMCListItem.ID to the index as a string

        IfFailGo(::VariantChangeType(&varStringIndex, &Index, 0, VT_BSTR));
        IfFailGo(pMMCListItem->put_ID(varStringIndex.bstrVal));

        IfFailGo(punkMMCListItem->QueryInterface(IID_IMMCListItem,
                                    reinterpret_cast<void **>(&piMMCListItem)));

        // Set the list item's index  mark it as virtual
        pMMCListItem->SetIndex(lIndex);
        pMMCListItem->SetVirtual();

        *ppMMCListItem = reinterpret_cast<MMCListItem *>(piMMCListItem);
    }


Error:
    QUICK_RELEASE(punkMMCListItem);
    (void)::VariantClear(&varStringIndex);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CMMCListItems::SetItemCount                                 [IMMCListItems]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long    lCount  [in]           new count for virtual list
//   VARIANT Repaint [in, optional] False sets MMCLV_UPDATE_NOINVALIDATEALL
//                                  default is True
//   VARIANT Scroll  [in, optional] False sets MMCLV_UPDATE_NOSCROLL
//                                  default is True
//
// Output:
//      HRESULT
//
// Notes:
//
// Calls IResultData::SetItemCount()
//

STDMETHODIMP CMMCListItems::SetItemCount(long Count, VARIANT Repaint, VARIANT Scroll)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL;
    DWORD        dwOptions = 0;

    hr = GetIResultData(&piResultData, NULL);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(Repaint))
    {
        if (VT_BOOL != Repaint.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        else if (VARIANT_FALSE == Repaint.boolVal)
        {
            dwOptions |= MMCLV_UPDATE_NOINVALIDATEALL;
        }
    }

    if (ISPRESENT(Scroll))
    {
        if (VT_BOOL != Scroll.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        else if (VARIANT_FALSE == Scroll.boolVal)
        {
            dwOptions |= MMCLV_UPDATE_NOSCROLL;
        }
    }

    hr = piResultData->SetItemCount(static_cast<int>(Count), dwOptions);
    EXCEPTION_CHECK_GO(hr);

    // Record count so we can check against it in get_Item()
    m_lCount = Count;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListItems::Add
( 
    VARIANT       Index,
    VARIANT       Key, 
    VARIANT       Text,
    VARIANT       Icon,
    MMCListItem **ppMMCListItem
)
{
    HRESULT       hr = S_OK;
    IMMCListItem *piMMCListItem = NULL;
    CMMCListItem *pMMCListItem = NULL;
    CResultView  *pResultView = NULL;
    IResultData  *piResultData = NULL; // Not AddRef()ed
    CView        *pView = NULL;

    VARIANT varText;
    ::VariantInit(&varText);

    if (NULL != m_pMMCListView)
    {
        if (m_pMMCListView->IsVirtual())
        {
            hr = SID_E_UNSUPPORTED_ON_VIRTUAL_LIST;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::Add(Index, Key, &piMMCListItem);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varText, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCListItem->put_Text(varText.bstrVal));
    }
    if (ISPRESENT(Icon))
    {
        IfFailGo(piMMCListItem->put_Icon(Icon));
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem, &pMMCListItem));

    IfFailGo(InitializeListItem(pMMCListItem));

    // If we are attached to a live listview, and we are not in the middle of
    // ResultViews_Initialize or ResultViews_Activate then add it there as well

    IfFalseGo(SUCCEEDED(GetIResultData(&piResultData, &pView)), S_OK);
    IfFalseGo(!m_pMMCListView->GetResultView()->InInitialize(), S_OK);
    IfFalseGo(!m_pMMCListView->GetResultView()->InActivate(), S_OK);

    IfFailGo(pView->InsertListItem(pMMCListItem));


Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCListItem);
    }
    else
    {
        *ppMMCListItem = reinterpret_cast<MMCListItem *>(piMMCListItem);
    }
    (void)::VariantClear(&varText);
    RRETURN(hr);
}


STDMETHODIMP CMMCListItems::Remove(VARIANT Index)
{
    RRETURN(InternalRemove(Index, RemoveFromCollection));
}


STDMETHODIMP CMMCListItems::Clear()
{
    HRESULT hr = S_OK;
    long    cListItems = GetCount();

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Iterate and call InternalRemove because that function knows how to
    // remove a list item from MMC

    varIndex.vt = VT_I4;

    for (varIndex.lVal = 1L; varIndex.lVal <= cListItems; varIndex.lVal++)
    {
        IfFailGo(InternalRemove(varIndex, DontRemoveFromCollection));
    }

    // Now call CSnapInCollection::Clear() to release the refs on all the
    // list items.

    hr = CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::Clear();
    IfFailGo(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IMMCListItems == riid)
    {
        *ppvObjOut = static_cast<IMMCListItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listitms.h ===
//=--------------------------------------------------------------------------=
// listitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListItems class definition - implements MMCListItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _LISTITEMS_DEFINED_
#define _LISTITEMS_DEFINED_

#include "collect.h"
#include "listview.h"
#include "view.h"

class CView;
class CMMCListView;

class CMMCListItems : public CSnapInCollection<IMMCListItem, MMCListItem, IMMCListItems>
{
    protected:
        CMMCListItems(IUnknown *punkOuter);
        ~CMMCListItems();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListItems
        STDMETHOD(SetItemCount)(long Count, VARIANT Repaint, VARIANT Scroll);
        STDMETHOD(Add)(VARIANT       Index,
                       VARIANT       Key, 
                       VARIANT       Text,
                       VARIANT       Icon,
                       MMCListItem **ppMMCListItem);
        STDMETHOD(get_Item)(VARIANT Index, MMCListItem **ppMMCListItem);
        STDMETHOD(Remove)(VARIANT Index);
        STDMETHOD(Clear)();


    // Public utility methods

    public:

        HRESULT SetListView(CMMCListView *pMMCListView);
        CMMCListView *GetListView() { return m_pMMCListView; }
        LONG GetID() { return m_ID; }

        HRESULT GetIResultData(IResultData **ppiResultData, CView **ppView);

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT InitializeListItem(CMMCListItem *pMMCListItem);

        enum RemovalOption { RemoveFromCollection, DontRemoveFromCollection };
        HRESULT InternalRemove(VARIANT Index, RemovalOption Option);

        long          m_lCount;       // Count of items in virtual lists only

        LONG          m_ID;           // Unique number assigned to every
                                      // CMMCListItems object. Used by orphaned
                                      // list items to identify their parent
                                      // collections. See
                                      // CMMCListItem::GetIResultData in
                                      // listitem.cpp

        static LONG   m_NextID;       // Unique numbers generated from here.

        CMMCListView *m_pMMCListView; // Back pointer to owning list view

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListItems,           // name
                                &CLSID_MMCListItems,    // clsid
                                "MMCListItems",         // objname
                                "MMCListItems",         // lblname
                                &CMMCListItems::Create, // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMMCListItems,     // dispatch IID
                                NULL,                   // no events IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _LISTITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listview.h ===
//=--------------------------------------------------------------------------=
// listview.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListView class definition - implements MMCListView object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTVIEW_DEFINED_
#define _LISTVIEW_DEFINED_

#include "resview.h"
#include "view.h"
#include "colhdrs.h"

class CResultView;
class CView;
class CMMCColumnHeaders;

class CMMCListView : public CSnapInAutomationObject,
                     public CPersistence,
                     public IMMCListView
{
    private:
        CMMCListView(IUnknown *punkOuter);
        ~CMMCListView();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListView

        COCLASS_PROPERTY_RW(CMMCListView, ColumnHeaders, MMCColumnHeaders, IMMCColumnHeaders, DISPID_LISTVIEW_COLUMN_HEADERS);

        STDMETHOD(get_Icons)(MMCImageList **ppMMCImageList);
        STDMETHOD(putref_Icons)(MMCImageList *pMMCImageList);

        STDMETHOD(get_SmallIcons)(MMCImageList **ppMMCImageList);
        STDMETHOD(putref_SmallIcons)(MMCImageList *pMMCImageList);

        COCLASS_PROPERTY_RO(CMMCListView, ListItems, MMCListItems, IMMCListItems, DISPID_LISTVIEW_LIST_ITEMS);

        STDMETHOD(get_SelectedItems)(MMCClipboard **ppMMCClipboard);

        STDMETHOD(get_Sorted)(VARIANT_BOOL *pfvarSorted);
        STDMETHOD(put_Sorted)(VARIANT_BOOL fvarSorted);
        
        STDMETHOD(get_SortKey)(short *psSortKey);
        STDMETHOD(put_SortKey)(short sSortKey);

        STDMETHOD(get_SortIcon)(VARIANT_BOOL *pfvarSortIcon);
        STDMETHOD(put_SortIcon)(VARIANT_BOOL fvarSortIcon);

        STDMETHOD(get_SortOrder)(SnapInSortOrderConstants *pSortOrder);
        STDMETHOD(put_SortOrder)(SnapInSortOrderConstants SortOrder);

        STDMETHOD(get_View)(SnapInViewModeConstants *pView);
        STDMETHOD(put_View)(SnapInViewModeConstants View);

        SIMPLE_PROPERTY_RW(CMMCListView, Virtual, VARIANT_BOOL, DISPID_LISTVIEW_VIRTUAL);
        SIMPLE_PROPERTY_RW(CMMCListView, UseFontLinking, VARIANT_BOOL, DISPID_LISTVIEW_USE_FONT_LINKING);
        SIMPLE_PROPERTY_RW(CMMCListView, MultiSelect, VARIANT_BOOL, DISPID_LISTVIEW_MULTI_SELECT);
        SIMPLE_PROPERTY_RW(CMMCListView, HideSelection, VARIANT_BOOL, DISPID_LISTVIEW_HIDE_SELECTION);
        SIMPLE_PROPERTY_RW(CMMCListView, SortHeader, VARIANT_BOOL, DISPID_LISTVIEW_SORT_HEADER);
        SIMPLE_PROPERTY_RW(CMMCListView, ShowChildScopeItems, VARIANT_BOOL, DISPID_LISTVIEW_SHOW_CHILD_SCOPEITEMS);
        SIMPLE_PROPERTY_RW(CMMCListView, LexicalSort, VARIANT_BOOL, DISPID_LISTVIEW_LEXICAL_SORT);

        STDMETHOD(put_FilterChangeTimeOut)(long lTimeout);
        STDMETHOD(get_FilterChangeTimeOut)(long *plTimeout);

        VARIANTREF_PROPERTY_RW(CMMCListView, Tag, DISPID_LISTVIEW_TAG);

        STDMETHOD(SetScopeItemState)(ScopeItem                    *ScopeItem, 
                                     SnapInListItemStateConstants  State,
                                     VARIANT_BOOL                  Value);


    // Public utility methods

        void SetResultView(CResultView *pResultView) { m_pResultView = pResultView; }
        CResultView *GetResultView() { return m_pResultView; }
        BOOL IsVirtual() { return VARIANTBOOL_TO_BOOL(m_Virtual); }
        void SetVirtual(BOOL fVirtual) { m_Virtual = BOOL_TO_VARIANTBOOL(fVirtual); }
        BOOL UseFontLinking() { return VARIANTBOOL_TO_BOOL(m_UseFontLinking); }
        void SetMultiSelect(BOOL fMultiSelect) { m_MultiSelect = BOOL_TO_VARIANTBOOL(fMultiSelect); }
        IMMCListItems *GetListItems() { return m_piListItems; }
        CMMCListItems *GetMMCListItems() { return m_pListItems; }
        SnapInViewModeConstants GetView() { return m_View; }
        BOOL MultiSelect() { return VARIANTBOOL_TO_BOOL(m_MultiSelect); }
        BOOL HideSelection() { return VARIANTBOOL_TO_BOOL(m_HideSelection); }
        BOOL SortHeader() { return VARIANTBOOL_TO_BOOL(m_SortHeader); }
        BOOL SortIcon() { return VARIANTBOOL_TO_BOOL(m_SortIcon); }
        BOOL ShowChildScopeItems() { return VARIANTBOOL_TO_BOOL(m_ShowChildScopeItems); }
        BOOL LexicalSort() { return VARIANTBOOL_TO_BOOL(m_LexicalSort); }
        BOOL Sorted() { return VARIANTBOOL_TO_BOOL(m_fvarSorted); }
        SnapInSortOrderConstants GetSortOrder() { return m_SortOrder; }
        short GetSortKey() { return m_sSortKey; }
        CMMCColumnHeaders *GetColumnHeaders() { return m_pMMCColumnHeaders; }
        long GetFilterChangeTimeout() { return m_lFilterChangeTimeout; }

    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        HRESULT GetIResultData(IResultData **ppiResultData, CView **ppView);

        // Variables that hold values of properties that have customer get/put
        // functions
        
        IMMCImageList           *m_piIcons;
        IMMCImageList           *m_piSmallIcons;
        IMMCListItems           *m_piSelectedItems;
        CMMCListItems           *m_pListItems;
        VARIANT_BOOL             m_fvarSorted;
        SnapInViewModeConstants  m_View;
        BSTR                     m_bstrIconsKey;
        BSTR                     m_bstrSmallIconsKey;
        CResultView             *m_pResultView;
        CMMCColumnHeaders       *m_pMMCColumnHeaders;
        short                    m_sSortKey;
        long                     m_lFilterChangeTimeout;
        BOOL                     m_fHaveFilterChangeTimeout;
        SnapInSortOrderConstants m_SortOrder;
        VARIANT_BOOL             m_SortIcon;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListView,           // name
                                &CLSID_MMCListView,    // clsid
                                "MMCListView",         // objname
                                "MMCListView",         // lblname
                                &CMMCListView::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IMMCListView,     // dispatch IID
                                NULL,                  // event IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _LISTVIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\listview.cpp ===
//=--------------------------------------------------------------------------=
// listview.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListView class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "listview.h"
#include "colhdrs.h"
#include "colhdr.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListView::CMMCListView(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCLISTVIEW,
                            static_cast<IMMCListView *>(this),
                            static_cast<CMMCListView *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCListView,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListView::~CMMCListView()
{
    RELEASE(m_piColumnHeaders);
    RELEASE(m_piIcons);
    RELEASE(m_piSmallIcons);
    if (NULL != m_pListItems)
    {
        (void)m_pListItems->SetListView(NULL);
    }
    RELEASE(m_piListItems);
    RELEASE(m_piSelectedItems);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrIconsKey);
    FREESTRING(m_bstrSmallIconsKey);
    InitMemberVariables();
    m_pMMCColumnHeaders = NULL;
}

void CMMCListView::InitMemberVariables()
{
    m_piColumnHeaders = NULL;
    m_piIcons = NULL;
    m_piSmallIcons = NULL;
    m_piListItems = NULL;
    m_pListItems = NULL;
    m_piSelectedItems = NULL;
    m_fvarSorted = VARIANT_FALSE;
    m_sSortKey = 1;
    m_SortOrder = siAscending;
    m_View = siIcon;
    m_Virtual = VARIANT_FALSE;
    m_UseFontLinking = VARIANT_FALSE;
    m_MultiSelect = VARIANT_FALSE;
    m_HideSelection = VARIANT_FALSE;
    m_SortHeader = VARIANT_TRUE;
    m_SortIcon = VARIANT_TRUE;
    m_ShowChildScopeItems = VARIANT_TRUE;
    m_LexicalSort = VARIANT_FALSE;
    m_lFilterChangeTimeout = DEFAULT_FILTER_CHANGE_TIMEOUT;

    ::VariantInit(&m_varTag);

    m_bstrIconsKey = NULL;
    m_bstrSmallIconsKey = NULL;
    m_pResultView = NULL;
}

IUnknown *CMMCListView::Create(IUnknown * punkOuter)
{
    HRESULT            hr = S_OK;
    CMMCListView      *pMMCListView = New CMMCListView(punkOuter);

    if (NULL == pMMCListView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Create all non-persisted objects that are not created during InitNew

    IfFailGo(CreateObject(OBJECT_TYPE_MMCLISTITEMS,
                          IID_IMMCListItems, &pMMCListView->m_piListItems));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pMMCListView->m_piListItems,
                                                 &pMMCListView->m_pListItems));
    IfFailGo(pMMCListView->m_pListItems->SetListView(pMMCListView));

    IfFailGo(CreateObject(OBJECT_TYPE_MMCLISTITEMS,
                          IID_IMMCListItems, &pMMCListView->m_piSelectedItems));

    // Need to create column headers even though it is persisted because
    // a new MMCListView created at runtime will not have InitNew called.
    // If InitNew is later called then the column headers collection created
    // here will be released.

    IfFailGo(CreateObject(OBJECT_TYPE_MMCCOLUMNHEADERS,
                      IID_IMMCColumnHeaders, &pMMCListView->m_piColumnHeaders));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pMMCListView->m_piColumnHeaders,
                                                   &pMMCListView->m_pMMCColumnHeaders));
    pMMCListView->m_pMMCColumnHeaders->SetListView(pMMCListView);

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCListView)
        {
            delete pMMCListView;
        }
        return NULL;
    }
    else
    {
        return pMMCListView->PrivateUnknown();
    }
}




//=--------------------------------------------------------------------------=
// CMMCListView::GetIResultData
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IResultData **ppiResultData [out] Owning View's IResultData returned here
//   IDataObject **ppiDataObject [out] Owning View returned here if non-NULL
//
// Output:
//
// Notes:
//
// As we are only a lowly listview and the IResultData pointer we need
// to set our selection state is owned by the View object, we need
// to crawl up the hierarchy. If we are an isolated listview created
// by the user or if any object up the hierarchy is isolated then we
// will return an error. Returned IResultData pointer is NOT AddRef()ed.


HRESULT CMMCListView::GetIResultData
(
     IResultData **ppiResultData,
     CView       **ppView
)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;

    IfFalseGo(NULL != m_pResultView, hr);

    pScopePaneItem = m_pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    *ppiResultData = pView->GetIResultData();
    IfFalseGo(NULL != *ppiResultData, hr);

    if (NULL != ppView)
    {
        *ppView = pView;
    }

    hr = S_OK;

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                       IMMCListView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCListView::get_Icons(MMCImageList **ppMMCImageList)
{
    RRETURN(GetImages(reinterpret_cast<IMMCImageList **>(ppMMCImageList),
                      m_bstrIconsKey, &m_piIcons));
}


STDMETHODIMP CMMCListView::putref_Icons(MMCImageList *pMMCImageList)
{
    RRETURN(SetImages(reinterpret_cast<IMMCImageList *>(pMMCImageList),
                      &m_bstrIconsKey, &m_piIcons));
}



STDMETHODIMP CMMCListView::get_SmallIcons(MMCImageList **ppMMCImageList)
{
    RRETURN(GetImages(reinterpret_cast<IMMCImageList **>(ppMMCImageList),
                      m_bstrSmallIconsKey, &m_piSmallIcons));
}


STDMETHODIMP CMMCListView::putref_SmallIcons(MMCImageList *pMMCImageList)
{
    RRETURN(SetImages(reinterpret_cast<IMMCImageList *>(pMMCImageList),
                      &m_bstrSmallIconsKey, &m_piSmallIcons));
}


STDMETHODIMP CMMCListView::get_SelectedItems(MMCClipboard **ppMMCClipboard)
{
    HRESULT      hr = S_OK;
    CView       *pView = NULL;
    IResultData *piResultData = NULL; // Not AddRef()ed

    if (NULL == ppMMCClipboard)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = GetIResultData(&piResultData, &pView);

    if (SUCCEEDED(hr))
    {
        // If we are in the middle of ResultViews_Activate then there are no
        // selected items yet so return an empty collection.

        IfFalseGo(!m_pResultView->InActivate(), S_OK);
    }
    else
    {
        // If this is a detached object then just return an empty collection
        IfFalseGo(SID_E_DETACHED_OBJECT != hr, S_OK);

        // Otherwise return the error
        IfFailGo(hr);
    }

    // OK, this is a live listview and we can examine it in MMC.

    IfFailGo(pView->GetCurrentListViewSelection(
                     reinterpret_cast<IMMCClipboard **>(ppMMCClipboard), NULL));

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::get_Sorted(VARIANT_BOOL *pfvarSorted)
{
    HRESULT            hr = S_OK;

    if (NULL == pfvarSorted)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarSorted = m_fvarSorted;


Error:
    RRETURN(hr);
}

STDMETHODIMP CMMCListView::put_Sorted(VARIANT_BOOL fvarSorted)
{
    HRESULT            hr = S_OK;
    IResultData       *piResultData = NULL; // not AddRef()ed
    DWORD              dwSortOptions = 0;

    m_fvarSorted = fvarSorted;

    // If we are not sorting then there is nothing to do.
    IfFalseGo(VARIANT_TRUE == fvarSorted, S_OK);

    IfFailGo(GetIResultData(&piResultData, NULL));

    // If we are attached to a live result view and not currently in the middle
    // of a ResultViews_Activate event then ask MMC to sort.
    // If we are in ResultViews_Activate then our local property value will
    // be set and MMC's will be asked to sort after
    // the event completes. See CView::OnShow() and CView::PopulateListView()
    // in view.cpp.

    IfFalseGo(NULL != piResultData, S_OK);

    IfFalseGo(!m_pResultView->InActivate(), S_OK);

    if (siDescending == m_SortOrder)
    {
        dwSortOptions = RSI_DESCENDING;
    }

    if (VARIANT_FALSE == m_SortIcon)
    {
        dwSortOptions |= RSI_NOSORTICON;
    }

    // Ask MMC to sort. Pass zero as user param because we don't
    // need it.
    // Adjust the sort key to zero based

    hr = piResultData->Sort(static_cast<int>(m_sSortKey - 1),
                            dwSortOptions, 0);
    if (FAILED(hr))
    {
        m_fvarSorted = VARIANT_FALSE;
    }
    EXCEPTION_CHECK_GO(hr);

Error:

    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::put_SortKey(short sSortKey)
{
    RRETURN(SetSimpleType(sSortKey, &m_sSortKey, DISPID_LISTVIEW_SORT_KEY));
}


STDMETHODIMP CMMCListView::get_SortKey(short *psSortKey)
{
    HRESULT            hr = S_OK;

    if (NULL == psSortKey)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *psSortKey = m_sSortKey;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::put_SortOrder(SnapInSortOrderConstants SortOrder)
{
    RRETURN(SetSimpleType(SortOrder, &m_SortOrder, DISPID_LISTVIEW_SORT_ORDER));
}


STDMETHODIMP CMMCListView::get_SortOrder(SnapInSortOrderConstants *pSortOrder)
{
    HRESULT            hr = S_OK;

    if (NULL == pSortOrder)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pSortOrder = m_SortOrder;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::put_SortIcon(VARIANT_BOOL fvarSortIcon)
{
    RRETURN(SetSimpleType(fvarSortIcon, &m_SortIcon, DISPID_LISTVIEW_SORT_ICON));
}


STDMETHODIMP CMMCListView::get_SortIcon(VARIANT_BOOL *pfvarSortIcon)
{
    HRESULT            hr = S_OK;

    if (NULL == pfvarSortIcon)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarSortIcon = m_SortIcon;

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCListView::get_View(SnapInViewModeConstants *pView)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    long         MMCViewMode = MMCLV_VIEWSTYLE_ICON;

    *pView = m_View;

    // If we are attached to a live result view and not currently in the middle
    // of a ResultViews_Activate event then ask MMC for the view mode.

    hr = GetIResultData(&piResultData, NULL);

    if (SUCCEEDED(hr))
    {
        if ( (!m_pResultView->InInitialize()) && (!m_pResultView->InActivate()) )
        {
            hr = piResultData->GetViewMode(&MMCViewMode);
            EXCEPTION_CHECK_GO(hr);

            // Convert and record the view mode from MMC. Return it to caller.

            ::MMCViewModeToVBViewMode(MMCViewMode, &m_View);

            *pView = m_View;
        }
    }
    else if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    else
    {
        IfFailGo(hr);
    }

Error:
    RRETURN(hr);
}

STDMETHODIMP CMMCListView::put_View(SnapInViewModeConstants View)
{
    HRESULT      hr = S_OK;
    IResultData *piResultData = NULL; // not AddRef()ed
    long         MMCViewMode = MMCLV_VIEWSTYLE_ICON;

    // Convert to an MMC view mode contant

    ::VBViewModeToMMCViewMode(View, &MMCViewMode);

    // If we are attached to a live result view and not currently in the middle
    // of a ResultViews_Activate event then ask MMC to change the view mode.
    // If we are in ResultViews_Activate then our local property value will
    // be set and MMC's view mode will be changed using this value after
    // the event completes. See CView::OnShow() and CView::PopulateListView()
    // in view.cpp.

    hr = GetIResultData(&piResultData, NULL);

    if (SUCCEEDED(hr))
    {
        // If MMC >= 1.2 then we can use a filtered view, otherwise return an
        // error. This long gnarly statement will work because GetIResultData
        // succeeded meaning that everyone has backpointers all the way up
        // the hierarchy to the owning view.

        if ( (siFiltered == View) &&
             (NULL == m_pResultView->GetScopePaneItem()->GetParent()->GetParentView()->GetIColumnData())
           )
        {
            hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
            EXCEPTION_CHECK_GO(hr);
        }

        if ( (!m_pResultView->InInitialize()) && (!m_pResultView->InActivate()) )
        {
            hr = piResultData->SetViewMode(MMCViewMode);
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    else
    {
        IfFailGo(hr);
    }

    // Change was successful. Record the new view mode so a get on
    // MMCListView.View will return correct information.
    
    m_View = View;

Error:
    RRETURN(hr);
}




STDMETHODIMP CMMCListView::put_FilterChangeTimeOut(long lTimeout)
{
    HRESULT       hr = S_OK;
    IHeaderCtrl2 *piHeaderCtrl2 = NULL; // Not AddRef()ed

    // Set the property value.

    IfFailGo(SetSimpleType(lTimeout, &m_lFilterChangeTimeout, DISPID_LISTVIEW_FILTER_CHANGE_TIMEOUT));

    // Get IHeaderCtrl2

    IfFalseGo(NULL != m_pMMCColumnHeaders, SID_E_DETACHED_OBJECT);

    IfFailGo(m_pMMCColumnHeaders->GetIHeaderCtrl2(&piHeaderCtrl2));

    hr = piHeaderCtrl2->SetChangeTimeOut(lTimeout);
    EXCEPTION_CHECK_GO(hr);
    
Error:
    // If we're not connected to MMC then this is not an error. This could
    // happen at design time or in snap-in code.

    if (SID_E_DETACHED_OBJECT == hr)
    {
        hr = S_OK;
    }
    RRETURN(hr);
}

STDMETHODIMP CMMCListView::get_FilterChangeTimeOut(long *plTimeout)
{
    *plTimeout = m_lFilterChangeTimeout;

    return S_OK;
}

STDMETHODIMP CMMCListView::SetScopeItemState
(
    ScopeItem                    *ScopeItem, 
    SnapInListItemStateConstants  State,
    VARIANT_BOOL                  Value
)
{
    HRESULT      hr = S_OK;
    CScopeItem  *pScopeItem = NULL;
    BOOL         fFound = FALSE;
    int          nState = 0;
    IResultData *piResultData = NULL; // Not AddRef()ed

    RESULTDATAITEM rdi;
    ::ZeroMemory(&rdi, sizeof(rdi));

    if (NULL == ScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If this is a virtual list view then there are no child scope items

    if (VARIANT_TRUE == m_Virtual)
    {
        hr = SID_E_NO_SCOPEITEMS_IN_VIRTUAL_LIST;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are not connected to a live list view then return an error

    if (FAILED(GetIResultData(&piResultData, NULL)))
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Find the scope item in the list view

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                      reinterpret_cast<IScopeItem *>(ScopeItem),
                                      &pScopeItem));

    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;

    hr = piResultData->GetNextItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

    while ( (-1 != rdi.nIndex) && (!fFound) )
    {
        if ( (rdi.bScopeItem) &&
             (rdi.lParam == reinterpret_cast<LPARAM>(pScopeItem)) )
        {
            fFound = TRUE;
        }
        else
        {
            hr = piResultData->GetNextItem(&rdi);
            EXCEPTION_CHECK_GO(hr);
        }
    }

    if (!fFound)
    {
        hr = SID_E_ELEMENT_NOT_FOUND;
        EXCEPTION_CHECK_GO(hr);
    }

    switch (State)
    {
        case siSelected:
            nState = LVIS_SELECTED;
            break;

        case siDropHilited:
            nState = LVIS_DROPHILITED;
            break;

        case siFocused:
            nState = LVIS_FOCUSED;
            break;

        case siCutHilited:
            nState = LVIS_CUT;
            break;

    }

    if (VARIANT_TRUE == Value)
    {
        rdi.nState |= nState;
    }
    else
    {
        rdi.nState &= ~nState;
    }
    
    hr = piResultData->SetItem(&rdi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListView::Persist()
{
    HRESULT            hr = S_OK;

    VARIANT varDefault;
    VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistObject(&m_piColumnHeaders, CLSID_MMCColumnHeaders,
                           OBJECT_TYPE_MMCCOLUMNHEADERS, IID_IMMCColumnHeaders,
                           OLESTR("ColumnHeaders")));

    // If this is an InitNew or load operation then the ColumnHeaders collection
    // was just created so set its back pointer to us.
    
    if ( InitNewing() || Loading() )
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piColumnHeaders,
                                                       &m_pMMCColumnHeaders));
        m_pMMCColumnHeaders->SetListView(this);
    }

    IfFailGo(PersistBstr(&m_bstrIconsKey, L"", OLESTR("Icons")));
    IfFailGo(PersistBstr(&m_bstrSmallIconsKey, L"", OLESTR("SmallIcons")));

    if (InitNewing())
    {
        RELEASE(m_piIcons);
        RELEASE(m_piSmallIcons);
    }

    IfFailGo(PersistSimpleType(&m_fvarSorted, VARIANT_FALSE, OLESTR("Sorted")));

    IfFailGo(PersistSimpleType(&m_sSortKey, (short)0, OLESTR("SortKey")));

    IfFailGo(PersistSimpleType(&m_SortOrder, siAscending, OLESTR("SortOrder")));

    IfFailGo(PersistSimpleType(&m_View, siIcon, OLESTR("View")));

    IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailGo(PersistSimpleType(&m_Virtual, VARIANT_FALSE, OLESTR("Virtual")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 7) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_UseFontLinking, VARIANT_FALSE, OLESTR("UseFontLinking")));
    }

    IfFailGo(PersistSimpleType(&m_MultiSelect, VARIANT_FALSE, OLESTR("MultiSelect")));

    IfFailGo(PersistSimpleType(&m_HideSelection, VARIANT_FALSE, OLESTR("HideSelection")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 10) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_SortHeader, VARIANT_TRUE, OLESTR("SortHeader")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 11) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_SortIcon, VARIANT_TRUE, OLESTR("SortIcon")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 5) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_lFilterChangeTimeout, DEFAULT_FILTER_CHANGE_TIMEOUT, OLESTR("FilterChangeTimeout")));
    }

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 9) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_ShowChildScopeItems, VARIANT_TRUE, OLESTR("ShowChildScopeItems")));
        IfFailGo(PersistSimpleType(&m_LexicalSort, VARIANT_FALSE, OLESTR("LexicalSort")));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCListView == riid)
    {
        *ppvObjOut = static_cast<IMMCListView *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitem.cpp ===
//=--------------------------------------------------------------------------=
// lsubitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lsubitem.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListSubItem::CMMCListSubItem(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCLISTSUBITEM,
                            static_cast<IMMCListSubItem *>(this),
                            static_cast<CMMCListSubItem *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_MMCListSubItem,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListSubItem::~CMMCListSubItem()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    InitMemberVariables();
}

void CMMCListSubItem::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;

    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
}

IUnknown *CMMCListSubItem::Create(IUnknown * punkOuter)
{
    CMMCListSubItem *pMMCListSubItem = New CMMCListSubItem(punkOuter);
    if (NULL == pMMCListSubItem)
    {
        return NULL;
    }
    else
    {
        return pMMCListSubItem->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItem::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailGo(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCListSubItem == riid)
    {
        *ppvObjOut = static_cast<IMMCListSubItem *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\localobj.h ===
//=--------------------------------------------------------------------------=
// localobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// This file is used by automation servers to delcare things that their objects
// need other parts of the server to see.
//
#ifndef _LOCALOBJECTS_H_

//=--------------------------------------------------------------------------=
// these constants are used in conjunction with the g_ObjectInfo table that
// each inproc server defines.  they are used to identify a given  object
// within the server.
//
// **** ADD ALL NEW OBJECTS TO THIS LIST ****
//

#define _LOCALOBJECTS_H_

#define OBJECT_TYPE_SNAPIN                  0
#define OBJECT_TYPE_SCOPEITEMS              1
#define OBJECT_TYPE_SNAPINDESIGNERDEF       2
#define OBJECT_TYPE_SNAPINDEF               3
#define OBJECT_TYPE_MMCMENU                 4
#define OBJECT_TYPE_MMCMENUDEFS             5
#define OBJECT_TYPE_EXTENSIONDEFS           6
#define OBJECT_TYPE_EXTENDEDSNAPINS         7
#define OBJECT_TYPE_EXTENDEDSNAPIN          8
#define OBJECT_TYPE_SCOPEITEMDEFS           9 
#define OBJECT_TYPE_SCOPEITEMDEF            10
#define OBJECT_TYPE_VIEWDEFS                11
#define OBJECT_TYPE_LISTVIEWDEFS            12
#define OBJECT_TYPE_LISTVIEWDEF             13
#define OBJECT_TYPE_MMCLISTVIEW             14
#define OBJECT_TYPE_MMCLISTITEMS            15
#define OBJECT_TYPE_MMCLISTITEM             16
#define OBJECT_TYPE_MMCLISTSUBITEMS         17
#define OBJECT_TYPE_MMCLISTSUBITEM          18
#define OBJECT_TYPE_MMCCOLUMNHEADERS        19
#define OBJECT_TYPE_MMCCOLUMNHEADER         20
#define OBJECT_TYPE_MMCIMAGELISTS           21
#define OBJECT_TYPE_MMCIMAGELIST            22
#define OBJECT_TYPE_MMCIMAGES               23
#define OBJECT_TYPE_MMCIMAGE                24
#define OBJECT_TYPE_MMCTOOLBARS             25
#define OBJECT_TYPE_MMCTOOLBAR              26
#define OBJECT_TYPE_OCXVIEWDEFS             27
#define OBJECT_TYPE_OCXVIEWDEF              28
#define OBJECT_TYPE_URLVIEWDEFS             29
#define OBJECT_TYPE_URLVIEWDEF              30
#define OBJECT_TYPE_TASKPADVIEWDEFS         31
#define OBJECT_TYPE_TASKPADVIEWDEF          32
#define OBJECT_TYPE_MMCBUTTONS              33
#define OBJECT_TYPE_MMCBUTTON               34
#define OBJECT_TYPE_MMCBUTTONMENUS          35
#define OBJECT_TYPE_MMCBUTTONMENU           36
#define OBJECT_TYPE_TASKPAD                 37
#define OBJECT_TYPE_TASKS                   38
#define OBJECT_TYPE_TASK                    39
#define OBJECT_TYPE_MMCDATAOBJECT           40
#define OBJECT_TYPE_NODETYPES               41
#define OBJECT_TYPE_NODETYPE                42
#define OBJECT_TYPE_REGINFO                 43
#define OBJECT_TYPE_VIEWS                   44
#define OBJECT_TYPE_VIEW                    45
#define OBJECT_TYPE_SCOPEITEM               46
#define OBJECT_TYPE_SCOPENODE               47
#define OBJECT_TYPE_SCOPEPANEITEMS          48
#define OBJECT_TYPE_SCOPEPANEITEM           49
#define OBJECT_TYPE_RESULTVIEWS             50
#define OBJECT_TYPE_RESULTVIEW              51
#define OBJECT_TYPE_EXTENSIONSNAPIN         52
#define OBJECT_TYPE_MMCCLIPBOARD            53
#define OBJECT_TYPE_MMCDATAOBJECTS          54
#define OBJECT_TYPE_MMCMENUDEF              55
#define OBJECT_TYPE_CONTEXTMENU             56
#define OBJECT_TYPE_DATAFORMAT              57
#define OBJECT_TYPE_DATAFORMATS             58
#define OBJECT_TYPE_MMCCONSOLEVERB          59
#define OBJECT_TYPE_MMCCONSOLEVERBS         60
#define OBJECT_TYPE_PROPERTYSHEET           61
#define OBJECT_TYPE_PROPERTYPAGEWRAPPER     62
#define OBJECT_TYPE_ENUM_TASK               63
#define OBJECT_TYPE_CONTROLBAR              64
#define OBJECT_TYPE_EXTENSIONS              65
#define OBJECT_TYPE_EXTENSION               66
#define OBJECT_TYPE_STRINGTABLE             67
#define OBJECT_TYPE_ENUMSTRINGTABLE         68
#define OBJECT_TYPE_CONTEXTMENUPROVIDER     69
#define OBJECT_TYPE_PROPERTYSHEETPROVIDER   70
#define OBJECT_TYPE_MMCMENUS                71
#define OBJECT_TYPE_MESSAGEVIEW             72
#define OBJECT_TYPE_COLUMNSETTINGS          73
#define OBJECT_TYPE_COLUMNSETTING           74
#define OBJECT_TYPE_SORTKEYS                75
#define OBJECT_TYPE_SORTKEY                 76
#define OBJECT_TYPE_SNAPINDATA              77
#endif // _LOCALOBJECTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitms.cpp ===
//=--------------------------------------------------------------------------=
// lsubitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lsubitms.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCListSubItems::CMMCListSubItems(IUnknown *punkOuter) :
    CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>(
                      punkOuter,
                      OBJECT_TYPE_MMCLISTSUBITEMS,
                      static_cast<IMMCListSubItems *>(this),
                      static_cast<CMMCListSubItems *>(this),
                      CLSID_MMCListSubItem,
                      OBJECT_TYPE_MMCLISTSUBITEM,
                      IID_IMMCListSubItem,
                      static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_MMCListSubItems,
                g_dwVerMajor,
                g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCListSubItems::~CMMCListSubItems()
{
}

IUnknown *CMMCListSubItems::Create(IUnknown * punkOuter)
{
    CMMCListSubItems *pMMCListSubItems = New CMMCListSubItems(punkOuter);
    if (NULL == pMMCListSubItems)
    {
        return NULL;
    }
    else
    {
        return pMMCListSubItems->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      IMMCListSubItems Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCListSubItems::Add
(
    VARIANT          Index,
    VARIANT          Key, 
    VARIANT          Text,
    MMCListSubItem **ppMMCListSubItem
)
{
    HRESULT hr = S_OK;
    VARIANT varText;
    ::VariantInit(&varText);
    IMMCListSubItem *piMMCListSubItem = NULL;

    hr = CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>::Add(Index, Key, &piMMCListSubItem);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varText, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCListSubItem->put_Text(varText.bstrVal));
    }

    *ppMMCListSubItem = reinterpret_cast<MMCListSubItem *>(piMMCListSubItem);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCListSubItem);
    }
    (void)::VariantClear(&varText);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItems::Persist()
{
    HRESULT         hr = S_OK;
    IMMCListSubItem  *piMMCListSubItem = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>::Persist(piMMCListSubItem);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCListSubItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCListSubItems == riid)
    {
        *ppvObjOut = static_cast<IMMCListSubItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitms.h ===
//=--------------------------------------------------------------------------=
// lsubitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItems class definition - implements MMCListSubItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _LISTSUBITEMS_DEFINED_
#define _LISTSUBITEMS_DEFINED_

#include "collect.h"

class CMMCListSubItems :
    public CSnapInCollection<IMMCListSubItem, MMCListSubItem, IMMCListSubItems>,
    public CPersistence
{
    protected:
        CMMCListSubItems(IUnknown *punkOuter);
        ~CMMCListSubItems();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListSubItems
        STDMETHOD(Add)(VARIANT         Index,
                       VARIANT         Key, 
                       VARIANT         Text,
                       MMCListSubItem **ppMMCListSubItem);


    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListSubItems,           // name
                                &CLSID_MMCListSubItems,    // clsid
                                "MMCListSubItems",         // objname
                                "MMCListSubItems",         // lblname
                                &CMMCListSubItems::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IMMCListSubItems,     // dispatch IID
                                NULL,                      // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _LISTSUBITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lsubitem.h ===
//=--------------------------------------------------------------------------=
// lsubitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCListSubItem class definition - implements MMCListSubItem object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTSUBITEM_DEFINED_
#define _LISTSUBITEM_DEFINED_


class CMMCListSubItem : public CSnapInAutomationObject,
                        public CPersistence,
                        public IMMCListSubItem
{
    private:
        CMMCListSubItem(IUnknown *punkOuter);
        ~CMMCListSubItem();
    
    public:
        static IUnknown *Create(IUnknown * punk);
        LPOLESTR GetTextPtr() { return static_cast<LPOLESTR>(m_bstrText); }

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCListSubItem

        SIMPLE_PROPERTY_RW(CMMCListSubItem,     Index, long, DISPID_LISTSUBITEM_INDEX);
        BSTR_PROPERTY_RW(CMMCListSubItem,       Key, DISPID_LISTSUBITEM_KEY);
        VARIANTREF_PROPERTY_RW(CMMCListSubItem, Tag, DISPID_LISTSUBITEM_TAG);
        BSTR_PROPERTY_RW(CMMCListSubItem,       Text, DISPID_LISTSUBITEM_TEXT);
      
    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCListSubItem,           // name
                                &CLSID_MMCListSubItem,    // clsid
                                "MMCListSubItem",         // objname
                                "MMCListSubItem",         // lblname
                                &CMMCListSubItem::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCListSubItem,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _LISTSUBITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdef.h ===
//=--------------------------------------------------------------------------=
// lvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTVIEWDEF_DEFINED_
#define _LISTVIEWDEF_DEFINED_


class CListViewDef : public CSnapInAutomationObject,
                     public CPersistence,
                     public IListViewDef,
                     public IPropertyNotifySink
{
    private:
        CListViewDef(IUnknown *punkOuter);
        ~CListViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IListViewDef

    // This object uses the X_PROPERTY_RW macros to expose properties of its
    // contained ListViewDef.ListView object as its own properties. That allows
    // the user to change ListViewDef.ListView properties in the list view 
    // property pages. The final argumentto the X_PROPERTY_RW macro is the contained
    // object that really exposes the property. In this case that is ListView.
    // See siautobj.h for the definition of X_PROPERTY_RW.

        BSTR_PROPERTY_RW(CListViewDef,   Name,  DISPID_LISTVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(CListViewDef, Index, long, DISPID_LISTVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(CListViewDef,   Key, DISPID_LISTVIEWDEF_KEY);
        X_PROPERTY_RW(CListViewDef,      Tag, VARIANT, DISPID_LISTVIEWDEF_TAG, ListView);
        SIMPLE_PROPERTY_RW(CListViewDef, AddToViewMenu, VARIANT_BOOL, DISPID_LISTVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CListViewDef,   ViewMenuText, DISPID_LISTVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(CListViewDef,   ViewMenuStatusBarText, DISPID_LISTVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        BSTR_PROPERTY_RW(CListViewDef,   DefaultItemTypeGUID, DISPID_LISTVIEWDEF_DEFAULT_ITEM_TYPE_GUID);
        SIMPLE_PROPERTY_RW(CListViewDef, Extensible,  VARIANT_BOOL, DISPID_LISTVIEWDEF_EXTENSIBLE);
        X_PROPERTY_RW(CListViewDef,      MultiSelect, VARIANT_BOOL, DISPID_LISTVIEWDEF_MULTI_SELECT, ListView);
        X_PROPERTY_RW(CListViewDef,      HideSelection, VARIANT_BOOL, DISPID_LISTVIEWDEF_HIDE_SELECTION, ListView);
        X_PROPERTY_RW(CListViewDef,      SortHeader, VARIANT_BOOL, DISPID_LISTVIEWDEF_SORT_HEADER, ListView);
        X_PROPERTY_RW(CListViewDef,      SortIcon, VARIANT_BOOL, DISPID_LISTVIEWDEF_SORT_ICON, ListView);
        X_PROPERTY_RW(CListViewDef,      Sorted, VARIANT_BOOL, DISPID_LISTVIEWDEF_SORTED, ListView);
        X_PROPERTY_RW(CListViewDef,      SortKey, short, DISPID_LISTVIEWDEF_SORT_KEY, ListView);
        X_PROPERTY_RW(CListViewDef,      SortOrder, SnapInSortOrderConstants, DISPID_LISTVIEWDEF_SORT_ORDER, ListView);
        X_PROPERTY_RW(CListViewDef,      View, SnapInViewModeConstants, DISPID_LISTVIEWDEF_VIEW, ListView);
        X_PROPERTY_RW(CListViewDef,      Virtual, VARIANT_BOOL, DISPID_LISTVIEWDEF_VIRTUAL, ListView);
        X_PROPERTY_RW(CListViewDef,      UseFontLinking, VARIANT_BOOL, DISPID_LISTVIEWDEF_USE_FONT_LINKING, ListView);
        X_PROPERTY_RW(CListViewDef,      FilterChangeTimeOut, long, DISPID_LISTVIEWDEF_FILTER_CHANGE_TIMEOUT, ListView);
        X_PROPERTY_RW(CListViewDef,      ShowChildScopeItems, VARIANT_BOOL, DISPID_LISTVIEWDEF_SHOW_CHILD_SCOPEITEMS, ListView);
        X_PROPERTY_RW(CListViewDef,      LexicalSort, VARIANT_BOOL, DISPID_LISTVIEWDEF_LEXICAL_SORT, ListView);
        OBJECT_PROPERTY_RO(CListViewDef, ListView, IMMCListView, DISPID_LISTVIEWDEF_LISTVIEW);

    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        BOOL Extensible() { return VARIANTBOOL_TO_BOOL(m_Extensible); }
        BSTR GetItemTypeGUID() { return m_bstrDefaultItemTypeGUID; }

    protected:
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

    // IPropertyNotifySink methods
        STDMETHOD(OnChanged)(DISPID dispID);
        STDMETHOD(OnRequestEdit)(DISPID dispID);

        void InitMemberVariables();
        HRESULT SetSink();
        HRESULT RemoveSink();

        DWORD    m_dwCookie;   // IConnectionPoint advise cookie
        BOOL     m_fHaveSink;  // TRUE=have IConnectionPoint advise

        // Proeprty page CLSIDs for ISpecifyPropertyPages

        static const GUID *m_rgpPropertyPageCLSIDs[4];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ListViewDef,           // name
                                &CLSID_ListViewDef,    // clsid
                                "ListViewDef",         // objname
                                "ListViewDef",         // lblname
                                &CListViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IListViewDef,     // dispatch IID
                                NULL,                  // event IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _LISTVIEWDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdef.cpp ===
//=--------------------------------------------------------------------------=
// lvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CListViewDef::m_rgpPropertyPageCLSIDs[4] =
{ &CLSID_ListViewDefGeneralPP,
  &CLSID_ListViewDefImgLstsPP,
  &CLSID_ListViewDefSortingPP,
  &CLSID_ListViewDefColHdrsPP
};


#pragma warning(disable:4355)  // using 'this' in constructor

CListViewDef::CListViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_LISTVIEWDEF,
                            static_cast<IListViewDef *>(this),
                            static_cast<CListViewDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ListViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CListViewDef::~CListViewDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    FREESTRING(m_bstrDefaultItemTypeGUID);
    (void)RemoveSink();
    RELEASE(m_piListView);
    InitMemberVariables();
}

void CListViewDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrName = NULL;
    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_bstrDefaultItemTypeGUID = NULL;
    m_Extensible = VARIANT_TRUE;
    m_piListView = NULL;
    m_dwCookie = 0;
    m_fHaveSink = FALSE;
}

IUnknown *CListViewDef::Create(IUnknown * punkOuter)
{
    HRESULT       hr = S_OK;
    CListViewDef *pListViewDef = New CListViewDef(punkOuter);

    if (NULL == pListViewDef)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pListViewDef)
        {
            delete pListViewDef;
        }
        return NULL;
    }
    else
    {
        return pListViewDef->PrivateUnknown();
    }
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDef::Persist()
{
    HRESULT  hr = S_OK;
    BSTR     bstrNewGUID = NULL;
    WCHAR    wszNewGUID[64] = L"";
    GUID     guidNew = GUID_NULL;

    if (InitNewing())
    {
        hr = ::CoCreateGuid(&guidNew);
        EXCEPTION_CHECK_GO(hr);

        if (0 == ::StringFromGUID2(guidNew, wszNewGUID,
                                   sizeof(wszNewGUID) / sizeof(wszNewGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailGo(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailGo(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailGo(PersistBstr(&m_bstrDefaultItemTypeGUID, wszNewGUID, OLESTR("DefaultItemTypeGUID")));

    IfFailGo(PersistSimpleType(&m_Extensible, VARIANT_TRUE, OLESTR("Extensible")));

    IfFailGo(PersistObject(&m_piListView, CLSID_MMCListView,
                           OBJECT_TYPE_MMCLISTVIEW, IID_IMMCListView,
                           OLESTR("ListView")));

    // If InitNew then set advise on IPropertyNotifySink connection point so we
    // know when the listview's properties have been changed through its
    // property pages. Need to do
    // this to keep duplicate properties in sync.

    if (InitNewing())
    {
        IfFailGo(SetSink());
    }

Error:
    RRETURN(hr);
}


HRESULT CListViewDef::SetSink()
{
    HRESULT                    hr = S_OK;
    IConnectionPoint          *pCP = NULL;
    IConnectionPointContainer *pCPC = NULL;

    IfFailGo(RemoveSink());
    IfFailGo(m_piListView->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void**>(&pCPC)));
    IfFailGo(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
    IfFailGo(pCP->Advise(static_cast<IUnknown *>(static_cast<IPropertyNotifySink *>(this)), &m_dwCookie));
    m_fHaveSink = TRUE;

Error:
    QUICK_RELEASE(pCP);
    QUICK_RELEASE(pCPC);
    RRETURN(hr);
}

HRESULT CListViewDef::RemoveSink()
{
    HRESULT                    hr = S_OK;
    IConnectionPoint          *pCP = NULL;
    IConnectionPointContainer *pCPC = NULL;

    IfFalseGo(m_fHaveSink, S_OK);

    IfFailGo(m_piListView->QueryInterface(IID_IConnectionPointContainer, reinterpret_cast<void**>(&pCPC)));
    IfFailGo(pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP));
    IfFailGo(pCP->Unadvise(m_dwCookie));
    m_fHaveSink = FALSE;
    m_dwCookie = 0;

Error:
    QUICK_RELEASE(pCP);
    QUICK_RELEASE(pCPC);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IPropertyNotifySink Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CListViewDef::OnChanged(DISPID dispid)
{
    HRESULT hr = S_OK;

    // This method is called from the list view object when the user has
    // changed its properties by clicking Apply in the list view property
    // pages in the designer.
    //
    // For a given ListViewDef.ListView property that has changed, generate
    // a corresponding IPropertyNotifySink::OnChanged for this object. That
    // will cause the VB property browser to do a get on the property and
    // update its listbox.

    switch (dispid)
    {
        case DISPID_LISTVIEW_TAG:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_TAG);
            break;

        case DISPID_LISTVIEW_MULTI_SELECT:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_MULTI_SELECT);
            break;

        case DISPID_LISTVIEW_HIDE_SELECTION:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_HIDE_SELECTION);
            break;

        case DISPID_LISTVIEW_SORT_HEADER:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_HEADER);
            break;

        case DISPID_LISTVIEW_SORT_ICON:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_ICON);
            break;

        case DISPID_LISTVIEW_SORTED:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORTED);
            break;

        case DISPID_LISTVIEW_SORT_KEY:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_KEY);
            break;

        case DISPID_LISTVIEW_SORT_ORDER:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SORT_ORDER);
            break;

        case DISPID_LISTVIEW_VIEW:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_VIEW);
            break;

        case DISPID_LISTVIEW_VIRTUAL:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_VIRTUAL);
            break;

        case DISPID_LISTVIEW_USE_FONT_LINKING:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_USE_FONT_LINKING);
            break;

        case DISPID_LISTVIEW_FILTER_CHANGE_TIMEOUT:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_FILTER_CHANGE_TIMEOUT);
            break;

        case DISPID_LISTVIEW_SHOW_CHILD_SCOPEITEMS:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_SHOW_CHILD_SCOPEITEMS);
            break;

        case DISPID_LISTVIEW_LEXICAL_SORT:
            hr = PropertyChanged(DISPID_LISTVIEWDEF_LEXICAL_SORT);
            break;
    }

    RRETURN(hr);
}

STDMETHODIMP CListViewDef::OnRequestEdit(DISPID dispid)
{
    return S_OK;
}



//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CListViewDef::OnSetHost                  [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
//
//

//=--------------------------------------------------------------------------=
// CListViewDef::OnSetHost                  [CSnapInAutomationObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// If the host is being removed the removes the IPropertyNotifySink on the
// contained listview. We do this here because otherwise our ref count would
// never hit zero. This will occur when we are about to be destroyed.
//
//

HRESULT CListViewDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piListView));
    if (NULL == GetHost())
    {
        hr = RemoveSink();
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPropertyNotifySink == riid)
    {
        *ppvObjOut = static_cast<IPropertyNotifySink *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IListViewDef == riid)
    {
        *ppvObjOut = static_cast<IListViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdefs.cpp ===
//=--------------------------------------------------------------------------=
// lvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "lvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CListViewDefs::CListViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>(
                                             punkOuter,
                                             OBJECT_TYPE_LISTVIEWDEFS,
                                             static_cast<IListViewDefs *>(this),
                                             static_cast<CListViewDefs *>(this),
                                             CLSID_ListViewDef,
                                             OBJECT_TYPE_LISTVIEWDEF,
                                             IID_IListViewDef,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ListViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CListViewDefs::~CListViewDefs()
{
}

IUnknown *CListViewDefs::Create(IUnknown * punkOuter)
{
    CListViewDefs *pListViewDefs = New CListViewDefs(punkOuter);
    if (NULL == pListViewDefs)
    {
        return NULL;
    }
    else
    {
        return pListViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDefs::Persist()
{
    HRESULT   hr = S_OK;
    IListViewDef *piListViewDef = NULL;

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>::Persist(piListViewDef);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CListViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IListViewDefs == riid)
    {
        *ppvObjOut = static_cast<IListViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>::GetMaster(IListViewDefs **ppiMasterListViewDefs)
{
    RRETURN(GetListViewDefs(ppiMasterListViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\lvdefs.h ===
//=--------------------------------------------------------------------------=
// lvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CListViewDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _LISTVIEWDEFS_DEFINED_
#define _LISTVIEWDEFS_DEFINED_

#define MASTER_COLLECTION
#include "collect.h"

class CListViewDefs : public CSnapInCollection<IListViewDef, ListViewDef, IListViewDefs>,
                      public CPersistence
{
    protected:
        CListViewDefs(IUnknown *punkOuter);
        ~CListViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT GetMaster(IListViewDefs **ppiMasterListViewDefs);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ListViewDefs,           // name
                                &CLSID_ListViewDefs,    // clsid
                                "ListViewDefs",         // objname
                                "ListViewDefs",         // lblname
                                &CListViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IListViewDefs,     // dispatch IID
                                NULL,                   // no events IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _LISTVIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbutton.cpp ===
//=--------------------------------------------------------------------------=
// mbutton.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenu class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "mbutton.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButtonMenu::CMMCButtonMenu(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCBUTTONMENU,
                            static_cast<IMMCButtonMenu *>(this),
                            static_cast<CMMCButtonMenu *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButtonMenu,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButtonMenu::~CMMCButtonMenu()
{
    FREESTRING(m_bstrKey);
    RELEASE(m_piParent);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    InitMemberVariables();
}

void CMMCButtonMenu::InitMemberVariables()
{
    m_Enabled = VARIANT_TRUE;
    m_Index = 0;
    m_bstrKey = NULL;
    m_piParent = NULL;
 
    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
    m_Visible = VARIANT_TRUE;
    m_Checked = VARIANT_FALSE;
    m_Grayed = VARIANT_FALSE;
    m_Separator = VARIANT_FALSE;
    m_MenuBreak = VARIANT_FALSE;
    m_MenuBarBreak = VARIANT_FALSE;

    m_pMMCToolbar = NULL;
}

IUnknown *CMMCButtonMenu::Create(IUnknown * punkOuter)
{
    CMMCButtonMenu *pMMCButtonMenu = New CMMCButtonMenu(punkOuter);
    if (NULL == pMMCButtonMenu)
    {
        return NULL;
    }
    else
    {
        return pMMCButtonMenu->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenu::Persist()
{
    HRESULT hr = S_OK;
    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Enabled, VARIANT_TRUE, OLESTR("Enabled")));

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailRet(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailRet(PersistSimpleType(&m_Visible, VARIANT_TRUE, OLESTR("Visible")));

    IfFailRet(PersistSimpleType(&m_Checked, VARIANT_FALSE, OLESTR("Checked")));

    IfFailRet(PersistSimpleType(&m_Grayed, VARIANT_FALSE, OLESTR("Grayed")));

    IfFailRet(PersistSimpleType(&m_Separator, VARIANT_FALSE, OLESTR("Separator")));

    IfFailRet(PersistSimpleType(&m_MenuBreak, VARIANT_FALSE, OLESTR("MenuBreak")));

    IfFailRet(PersistSimpleType(&m_MenuBarBreak, VARIANT_FALSE, OLESTR("MenuBarBreak")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenu::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IMMCButtonMenu == riid)
    {
        *ppvObjOut = static_cast<IMMCButtonMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbutton.h ===
//=--------------------------------------------------------------------------=
// mbutton.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenu class definition - implements MMCButtonMenu object
//
//=--------------------------------------------------------------------------=

#ifndef _MBUTTON_DEFINED_
#define _MBUTTON_DEFINED_

#include "toolbar.h"

class CMMCButtonMenu : public CSnapInAutomationObject,
                       public CPersistence,
                       public IMMCButtonMenu
{
    private:
        CMMCButtonMenu(IUnknown *punkOuter);
        ~CMMCButtonMenu();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButtonMenu
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Enabled, VARIANT_BOOL, DISPID_BUTTONMENU_ENABLED);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Index, long, DISPID_BUTTONMENU_INDEX);
        BSTR_PROPERTY_RW(CMMCButtonMenu,       Key, DISPID_BUTTONMENU_KEY);
        COCLASS_PROPERTY_RO(CMMCButtonMenu,    Parent, MMCButton, IMMCButton, DISPID_BUTTONMENU_PARENT);
        OBJECT_PROPERTY_WO(CMMCButtonMenu,     Parent, IMMCButton, DISPID_BUTTONMENU_PARENT);
        VARIANTREF_PROPERTY_RW(CMMCButtonMenu, Tag, DISPID_BUTTONMENU_TAG);
        BSTR_PROPERTY_RW(CMMCButtonMenu,       Text, DISPID_BUTTONMENU_TEXT);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Visible, VARIANT_BOOL, DISPID_BUTTONMENU_VISIBLE);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Checked, VARIANT_BOOL, DISPID_BUTTONMENU_CHECKED);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Grayed, VARIANT_BOOL, DISPID_BUTTONMENU_GRAYED);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     Separator, VARIANT_BOOL, DISPID_BUTTONMENU_SEPARATOR);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     MenuBreak, VARIANT_BOOL, DISPID_BUTTONMENU_MENU_BREAK);
        SIMPLE_PROPERTY_RW(CMMCButtonMenu,     MenuBarBreak, VARIANT_BOOL, DISPID_BUTTONMENU_MENU_BAR_BREAK);
        
    // Public utility methods

    public:
        void SetToolbar(CMMCToolbar *pMMCToolbar) { m_pMMCToolbar = pMMCToolbar; }
        CMMCToolbar *GetToolbar() { return m_pMMCToolbar; }
        BSTR GetText() { return m_bstrText; }
        BOOL GetEnabled() { return VARIANTBOOL_TO_BOOL(m_Enabled); }
        BOOL GetVisible() { return VARIANTBOOL_TO_BOOL(m_Visible); }
        BOOL GetChecked() { return VARIANTBOOL_TO_BOOL(m_Checked); }
        BOOL GetGrayed() { return VARIANTBOOL_TO_BOOL(m_Grayed); }
        BOOL GetSeparator() { return VARIANTBOOL_TO_BOOL(m_Separator); }
        BOOL GetMenuBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBreak); }
        BOOL GetMenuBarBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBarBreak); }

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CMMCToolbar *m_pMMCToolbar; // Back pointer to owning toolbar

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButtonMenu,                   // name
                                &CLSID_MMCButtonMenu,            // clsid
                                "MMCButtonMenu",                 // objname
                                "MMCButtonMenu",                 // lblname
                                &CMMCButtonMenu::Create,         // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCButtonMenu,             // dispatch IID
                                NULL,                        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _MBUTTON_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbuttons.h ===
//=--------------------------------------------------------------------------=
// mbuttons.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenus class definition - implements MMCButtonMenus collection
//
//=--------------------------------------------------------------------------=

#ifndef _MBUTTONS_DEFINED_
#define _MBUTTONS_DEFINED_

#include "collect.h"

class CMMCButtonMenus : public CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>,
                        public CPersistence
{
    protected:
        CMMCButtonMenus(IUnknown *punkOuter);
        ~CMMCButtonMenus();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCButtonMenus
        STDMETHOD(putref_Parent)(IMMCButton *piParentButton);
        STDMETHOD(Add)(VARIANT         Index,
                       VARIANT         Key, 
                       VARIANT         Text,
                       MMCButtonMenu **ppMMCButtonMenu);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        IMMCButton *m_piParentButton;

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCButtonMenus,             // name
                                &CLSID_MMCButtonMenus,      // clsid
                                "MMCButtonMenus",           // objname
                                "MMCButtonMenus",           // lblname
                                &CMMCButtonMenus::Create,   // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCButtonMenus,       // dispatch IID
                                NULL,                       // no events IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _MBUTTONS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mbuttons.cpp ===
//=--------------------------------------------------------------------------=
// mbuttons.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCButtonMenus class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "mbuttons.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCButtonMenus::CMMCButtonMenus(IUnknown *punkOuter) :
    CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>(
                      punkOuter,
                      OBJECT_TYPE_MMCBUTTONMENUS,
                      static_cast<IMMCButtonMenus *>(this),
                      static_cast<CMMCButtonMenus *>(this),
                      CLSID_MMCButtonMenu,
                      OBJECT_TYPE_MMCBUTTONMENU,
                      IID_IMMCButtonMenu,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCButtonMenus,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCButtonMenus::~CMMCButtonMenus()
{
    RELEASE(m_piParentButton);
    InitMemberVariables();
}


void CMMCButtonMenus::InitMemberVariables()
{
    m_piParentButton = NULL;
}

IUnknown *CMMCButtonMenus::Create(IUnknown * punkOuter)
{
    CMMCButtonMenus *pMMCButtonMenus = New CMMCButtonMenus(punkOuter);
    if (NULL == pMMCButtonMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCButtonMenus->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         IMMCButtonMenus Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCButtonMenus::putref_Parent(IMMCButton *piParentButton)
{
    HRESULT         hr = S_OK;
    long            lCount = 0;
    IMMCButtonMenu *piMMCButtonMenu = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // UNDONE: This must be causing a circular ref count because the button has
    // a ref on this collection. The same problem must also be occurring between
    // the ButtonMenu objects and this collection. Need to use C++ back pointers.

    RELEASE(m_piParentButton);
    if (NULL != piParentButton)
    {
        piParentButton->AddRef();
        m_piParentButton = piParentButton;
    }

    IfFailGo(get_Count(&lCount));
    IfFalseGo(lCount > 0, S_OK);

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= lCount)
    {
        IfFailGo(get_Item(varIndex, &piMMCButtonMenu));
        IfFailGo(piMMCButtonMenu->putref_Parent(m_piParentButton));
        RELEASE(piMMCButtonMenu);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piMMCButtonMenu);
    RRETURN(hr);
}



STDMETHODIMP CMMCButtonMenus::Add
(
    VARIANT         Index,
    VARIANT         Key, 
    VARIANT         Text,
    MMCButtonMenu **ppMMCButtonMenu
)
{
    HRESULT         hr = S_OK;
    IMMCButtonMenu *piMMCButtonMenu = NULL;
    VARIANT         varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>::Add(Index, Key, &piMMCButtonMenu);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varCoerced, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piMMCButtonMenu->put_Text(varCoerced.bstrVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    IfFailGo(piMMCButtonMenu->putref_Parent(m_piParentButton));

    *ppMMCButtonMenu = reinterpret_cast<MMCButtonMenu *>(piMMCButtonMenu);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCButtonMenu);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenus::Persist()
{
    HRESULT         hr = S_OK;
    IMMCButtonMenu *piMMCButtonMenu = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>::Persist(piMMCButtonMenu);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCButtonMenus::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCButtonMenus == riid)
    {
        *ppvObjOut = static_cast<IMMCButtonMenus *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCButtonMenu, MMCButtonMenu, IMMCButtonMenus>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menu.h ===
//=--------------------------------------------------------------------------=
// menu.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenu class definition - implements MMCMenu object
//
//=--------------------------------------------------------------------------=

#ifndef _MENU_DEFINED_
#define _MENU_DEFINED_

#include "menus.h"

class CMMCMenus;

class CMMCMenu : public CSnapInAutomationObject,
                 public CPersistence,
                 public IMMCMenu
{
    private:
        CMMCMenu(IUnknown *punkOuter);
        ~CMMCMenu();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenu

        BSTR_PROPERTY_RW(CMMCMenu,          Name,                           DISPID_MENU_NAME);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Index,          long,           DISPID_MENU_INDEX);
        BSTR_PROPERTY_RW(CMMCMenu,          Key,                            DISPID_MENU_KEY);
        BSTR_PROPERTY_RW(CMMCMenu,          Caption,                        DISPID_MENU_CAPTION);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Visible,        VARIANT_BOOL,   DISPID_MENU_VISIBLE);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Checked,        VARIANT_BOOL,   DISPID_MENU_CHECKED);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Enabled,        VARIANT_BOOL,   DISPID_MENU_ENABLED);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Grayed,         VARIANT_BOOL,   DISPID_MENU_GRAYED);
        SIMPLE_PROPERTY_RW(CMMCMenu,        MenuBreak,      VARIANT_BOOL,   DISPID_MENU_MENU_BREAK);
        SIMPLE_PROPERTY_RW(CMMCMenu,        MenuBarBreak,   VARIANT_BOOL,   DISPID_MENU_MENU_BAR_BREAK);
        SIMPLE_PROPERTY_RW(CMMCMenu,        Default,        VARIANT_BOOL,   DISPID_MENU_DEFAULT);
        VARIANTREF_PROPERTY_RW(CMMCMenu,    Tag,                            DISPID_MENU_TAG);
        BSTR_PROPERTY_RW(CMMCMenu,          StatusBarText,                  DISPID_MENU_STATUS_BAR_TEXT);
        COCLASS_PROPERTY_RO(CMMCMenu,       Children, MMCMenus, IMMCMenus,  DISPID_MENU_CHILDREN);
        
    // Public utility methods
    public:

        void FireClick(long lIndex, IMMCClipboard *piSelection);
        
        void SetCollection(CMMCMenus *pMMCMenus) { m_pMMCMenus = pMMCMenus; }
        CMMCMenus *GetCollection() { return m_pMMCMenus; };

        BSTR GetName() { return m_bstrName; }
        LPWSTR GetCaption() { return static_cast<LPWSTR>(m_bstrCaption); }
        BOOL GetVisible() { return VARIANTBOOL_TO_BOOL(m_Visible); }
        BOOL GetChecked() { return VARIANTBOOL_TO_BOOL(m_Checked); }
        BOOL GetEnabled() { return VARIANTBOOL_TO_BOOL(m_Enabled); }
        BOOL GetGrayed() { return VARIANTBOOL_TO_BOOL(m_Grayed); }
        BOOL GetMenuBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBreak); }
        BOOL GetMenuBarBreak() { return VARIANTBOOL_TO_BOOL(m_MenuBarBreak); }
        BOOL GetDefault() { return VARIANTBOOL_TO_BOOL(m_Default); }
        VARIANT GetTag() { return m_varTag; }
        long GetIndex() { return m_Index; }
        void SetIndex(long lIndex) { m_Index = lIndex; }
        LPWSTR GetStatusBarText() { return static_cast<LPWSTR>(m_bstrStatusBarText); }
        BOOL IsAutoViewMenuItem() { return m_fAutoViewMenuItem; }
        void SetAutoViewMenuItem() { m_fAutoViewMenuItem = TRUE; }
        BSTR GetResultViewDisplayString() { return m_bstrResultViewDisplayString; }
        HRESULT SetResultViewDisplayString(BSTR bstrDisplayString);
        
    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        CMMCMenus *m_pMMCMenus;   // back ptr to collection containing menu

        // When an MMCMenu object is used to hold an automatically added
        // view menu item this variable holds the display string.
        
        BSTR m_bstrResultViewDisplayString;

        // This flag determines whether the MMCMenu object is being used
        // for an automatically added view menu item.
        
        BOOL m_fAutoViewMenuItem;

        // Click event parameters definition

        static VARTYPE   m_rgvtClick[2];
        static EVENTINFO m_eiClick;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenu,                     // name
                                &CLSID_MMCMenu,              // clsid
                                "MMCMenu",                   // objname
                                "MMCMenu",                   // lblname
                                &CMMCMenu::Create,           // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCMenu,               // dispatch IID
                                &DIID_DMMCMenuEvents,        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _MENU_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\main.cpp ===
//=--------------------------------------------------------------------------=
// main.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//      Implements DLL initialization and exported registration functions
//


#include "pch.h"

#include <initguid.h>              // define all the guids.
#define INITOBJECTS                // define AUTOMATIONOBJECTINFO structs
#include "common.h"

#include "button.h"
#include "buttons.h"
#include "clipbord.h"
#include "colhdr.h"
#include "colhdrs.h"
#include "colsets.h"
#include "colset.h"
#include "converb.h"
#include "converbs.h"
#include "ctlbar.h"
#include "ctxtmenu.h"
#include "ctxtprov.h"
#include "datafmt.h"
#include "datafmts.h"
#include "dataobj.h"
#include "dataobjs.h"
#include "enumtask.h"
#include "extdefs.h"
#include "extsnap.h"
#include "image.h"
#include "images.h"
#include "imglist.h"
#include "imglists.h"
#include "listitem.h"
#include "listitms.h"
#include "listview.h"
#include "lsubitem.h"
#include "lsubitms.h"
#include "lvdef.h"
#include "lvdefs.h"
#include "mbutton.h"
#include "mbuttons.h"
#include "menu.h"
#include "menus.h"
#include "menudef.h"
#include "menudefs.h"
#include "msgview.h"
#include "nodetype.h"
#include "nodtypes.h"
#include "ocxvdef.h"
#include "ocxvdefs.h"
#include "ppgwrap.h"
#include "prpsheet.h"
#include "pshtprov.h"
#include "reginfo.h"
#include "resview.h"
#include "resviews.h"
#include "scitdef.h"
#include "scitdefs.h"
#include "scopitem.h"
#include "scopitms.h"
#include "scopnode.h"
#include "sidesdef.h"
#include "snapin.h"
//#include "snapdata.h"
#include "snapindef.h"
#include "sortkeys.h"
#include "sortkey.h"
#include "spanitem.h"
#include "spanitms.h"
#include "strtable.h"
#include "task.h"
#include "taskpad.h"
#include "tasks.h"
#include "tls.h"
#include "toolbar.h"
#include "toolbars.h"
#include "tpdvdef.h"
#include "tpdvdefs.h"
#include "urlvdef.h"
#include "urlvdefs.h"
#include "view.h"
#include "viewdefs.h"
#include "views.h"
#include "xtdsnap.h"
#include "xtdsnaps.h"
#include "xtenson.h"
#include "xtensons.h"

// for ASSERT and FAIL
//
SZTHISFILE

const char g_szLibName[] = "SnapInDesignerRuntime";
const CLSID *g_pLibid = &LIBID_SnapInLib;

extern const CATID *g_rgCATIDImplemented[] = {NULL};
extern const int    g_ctCATIDImplemented   = 0;

extern const CATID *g_rgCATIDRequired[]    = {NULL};
extern const int    g_ctCATIDRequired      = 0;

HINSTANCE g_hInstanceDoc = NULL;
LCID g_lcidDoc = 0;
CRITICAL_SECTION g_DllGetDocCritSection;

OBJECTINFO g_ObjectInfo[] =
{
    AUTOMATIONOBJECT(SnapIn),
    AUTOMATIONOBJECT(ScopeItems),
    AUTOMATIONOBJECT(SnapInDesignerDef),
    AUTOMATIONOBJECT(SnapInDef),
    AUTOMATIONOBJECT(MMCMenu),
    AUTOMATIONOBJECT(MMCMenuDefs),
    AUTOMATIONOBJECT(ExtensionDefs),
    AUTOMATIONOBJECT(ExtendedSnapIns),
    AUTOMATIONOBJECT(ExtendedSnapIn),
    AUTOMATIONOBJECT(ScopeItemDefs),
    AUTOMATIONOBJECT(ScopeItemDef),
    AUTOMATIONOBJECT(ViewDefs),
    AUTOMATIONOBJECT(ListViewDefs),
    AUTOMATIONOBJECT(ListViewDef),
    AUTOMATIONOBJECT(MMCListView),
    AUTOMATIONOBJECT(MMCListItems),
    AUTOMATIONOBJECT(MMCListItem),
    AUTOMATIONOBJECT(MMCListSubItems),
    AUTOMATIONOBJECT(MMCListSubItem),
    AUTOMATIONOBJECT(MMCColumnHeaders),
    AUTOMATIONOBJECT(MMCColumnHeader),
    AUTOMATIONOBJECT(MMCImageLists),
    AUTOMATIONOBJECT(MMCImageList),
    AUTOMATIONOBJECT(MMCImages),
    AUTOMATIONOBJECT(MMCImage),
    AUTOMATIONOBJECT(MMCToolbars),
    AUTOMATIONOBJECT(MMCToolbar),
    AUTOMATIONOBJECT(OCXViewDefs),
    AUTOMATIONOBJECT(OCXViewDef),
    AUTOMATIONOBJECT(URLViewDefs),
    AUTOMATIONOBJECT(URLViewDef),
    AUTOMATIONOBJECT(TaskpadViewDefs),
    AUTOMATIONOBJECT(TaskpadViewDef),
    AUTOMATIONOBJECT(MMCButtons),
    AUTOMATIONOBJECT(MMCButton),
    AUTOMATIONOBJECT(MMCButtonMenus),
    AUTOMATIONOBJECT(MMCButtonMenu),
    AUTOMATIONOBJECT(Taskpad),
    AUTOMATIONOBJECT(Tasks),
    AUTOMATIONOBJECT(Task),
    AUTOMATIONOBJECT(MMCDataObject),
    AUTOMATIONOBJECT(NodeTypes),
    AUTOMATIONOBJECT(NodeType),
    AUTOMATIONOBJECT(RegInfo),
    AUTOMATIONOBJECT(Views),
    AUTOMATIONOBJECT(View),
    AUTOMATIONOBJECT(ScopeItem),
    AUTOMATIONOBJECT(ScopeNode),
    AUTOMATIONOBJECT(ScopePaneItems),
    AUTOMATIONOBJECT(ScopePaneItem),
    AUTOMATIONOBJECT(ResultViews),
    AUTOMATIONOBJECT(ResultView),
    AUTOMATIONOBJECT(ExtensionSnapIn),
    AUTOMATIONOBJECT(MMCClipboard),
    AUTOMATIONOBJECT(MMCDataObjects),
    AUTOMATIONOBJECT(MMCMenuDef),
    AUTOMATIONOBJECT(ContextMenu),
    AUTOMATIONOBJECT(DataFormat),
    AUTOMATIONOBJECT(DataFormats),
    AUTOMATIONOBJECT(MMCConsoleVerb),
    AUTOMATIONOBJECT(MMCConsoleVerbs),
    AUTOMATIONOBJECT(PropertySheet),
    AUTOMATIONOBJECT(PropertyPageWrapper),
    AUTOMATIONOBJECT(EnumTask),
    AUTOMATIONOBJECT(Controlbar),
    AUTOMATIONOBJECT(Extensions),
    AUTOMATIONOBJECT(Extension),
    AUTOMATIONOBJECT(StringTable),
    AUTOMATIONOBJECT(EnumStringTable),
    AUTOMATIONOBJECT(MMCContextMenuProvider),
    AUTOMATIONOBJECT(MMCPropertySheetProvider),
    AUTOMATIONOBJECT(MMCMenus),
    AUTOMATIONOBJECT(MessageView),
    AUTOMATIONOBJECT(ColumnSettings),
    AUTOMATIONOBJECT(ColumnSetting),
    AUTOMATIONOBJECT(SortKeys),
    AUTOMATIONOBJECT(SortKey),
//    AUTOMATIONOBJECT(SnapInData),
    EMPTYOBJECT
};


// Need this to satisfy framework references

WNDPROC g_ParkingWindowProc = NULL;

//=--------------------------------------------------------------------------=
// Localization Information
//
// We need the following two pieces of information:
//    a. whether or not this DLL uses satellite DLLs for localization.  if
//       not, then the lcidLocale is ignored, and we just always get resources
//       from the server module file.
//    b. the ambient LocaleID for this in-proc server.  Controls calling
//       GetResourceHandle() will set this up automatically, but anybody
//       else will need to be sure that it's set up properly.
//
extern const VARIANT_BOOL g_fSatelliteLocalization =  TRUE;
LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

//=--------------------------------------------------------------------------=
// TODO: 
//
// Setting this flag to TRUE will cause your control to be created using
// its runtime license key even if it's created as part of a composite
// control (ie: a VB5-built UserControl) in a design environment.  A user
// of the composite control does not need to acquire or purchase your design-time
// license in order to use the composite control.
//
// The current setting of FALSE means that in order for your control to 
// load as part of a composite control (in a design-time environment), 
// the composite control user will need to acquire or purchase your 
// control's design-time license.  This setting is more restrictive 
// in terms of control distribution and licensing when compared to 
// setting this to TRUE. 
//
extern const BOOL g_fUseRuntimeLicInCompositeCtl = FALSE;






void InitializeLibrary
(
    void
)
{
    ::InitializeCriticalSection(&g_DllGetDocCritSection);
    CTls::Initialize();
}

void UninitializeLibrary
(
    void
)
{
    ::DeleteCriticalSection(&g_DllGetDocCritSection);
    CTls::Destroy();
}

//=--------------------------------------------------------------------------=
// RegisterData
//=--------------------------------------------------------------------------=
// lets the inproc server writer register any data in addition to that in
// any other objects.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL RegisterData(void)
{

    // TODO: register any additional data here that you might wish to.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterData
//=--------------------------------------------------------------------------=
// inproc server writers should unregister anything they registered in
// RegisterData() here.
//
// Output:
//    BOOL            - false means failure.
//
// Notes:
//
BOOL UnregisterData
(
    void
)
{
    // TODO: any additional registry cleanup that you might wish to do.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CheckForLicense
//=--------------------------------------------------------------------------=
// users can implement this if they wish to support Licensing.  otherwise,
// they can just return TRUE all the time.
//
// Parameters:
//    none
//
// Output:
//    BOOL            - TRUE means the license exists, and we can proceed
//                      FALSE means we're not licensed and cannot proceed
//
// Notes:
//    - implementers should use g_wszLicenseKey and g_wszLicenseLocation
//      from the top of this file to define their licensing [the former
//      is necessary, the latter is recommended]
//
BOOL CheckForLicense
(
    void
)
{
    // TODO: decide whether or not your server is licensed in this function.
    // people who don't want to bother with licensing should just return
    // true here always.  g_wszLicenseKey and g_wszLicenseLocation are
    // used by IClassFactory2 to do some of the licensing work.
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// CheckLicenseKey
//=--------------------------------------------------------------------------=
// when IClassFactory2::CreateInstanceLic is called, a license key is passed
// in, and then passed on to this routine.  users should return a boolean 
// indicating whether it is a valid license key or not
//
// Parameters:
//    LPWSTR          - [in] the key to check
//
// Output:
//    BOOL            - false means it's not valid, true otherwise
//
// Notes:
//
BOOL CheckLicenseKey
(
    LPWSTR pwszKey
)
{
        // Check for the unique license key (key2) or VB4 compatible key (Key1)
    //
    return TRUE;
}

//=--------------------------------------------------------------------------=
// GetLicenseKey
//=--------------------------------------------------------------------------=
// returns our current license key that should be saved out, and then passed
// back to us in IClassFactory2::CreateInstanceLic
//
// Parameters:
//    none
//
// Output:
//    BSTR                 - key or NULL if Out of memory
//
// Notes:
//
BSTR GetLicenseKey
(
    void
)
{
    // Return our control unique license key
    //
    return SysAllocString(L"");
}


extern "C" HRESULT DLLGetDocumentation
(
    ITypeLib  *ptlib,
    ITypeInfo *ptinfo,
    LCID	   lcid,
    DWORD	   dwHelpStringContextId,
    BSTR*	   pbstrHelpString
)
{
    HRESULT hr = S_OK;
    char szBuffer[512];
    int	cBytes;
    BSTR bstrHelpString = NULL;

    *pbstrHelpString = NULL;

    // Do this in a critical section to protect global data
    //
    EnterCriticalSection(&g_DllGetDocCritSection);
    {
        // Reuse cached module handle if possible. Otherwise, free old handle
        //
        if ( (lcid != g_lcidDoc) || (g_hInstanceDoc == NULL) )
        {
            if ( (NULL != g_hInstanceDoc)                &&
                 (g_hInstanceDoc != GetResourceHandle()) &&
                 (g_hInstanceDoc != g_hInstance)
               )
            {
                ::FreeLibrary(g_hInstanceDoc);
                g_hInstanceDoc = NULL;
            }

            // Load new module containing localized resource strings
            //
            g_hInstanceDoc = GetResourceHandle(lcid);
            g_lcidDoc      = lcid;
        }

        IfFalseGo(g_hInstanceDoc != NULL, SID_E_INTERNAL);
    }
    LeaveCriticalSection(&g_DllGetDocCritSection);

    // Load the string. Note that the build process masks help context ids
    // in the satellite DLL to 16 bits, so we must do the same here.
    //
    cBytes = ::LoadString(g_hInstanceDoc,
                          dwHelpStringContextId & 0xffff,
                          szBuffer, sizeof (szBuffer));

    IfFalseGo(cBytes > 0, SID_E_INTERNAL);
    IfFailGo(BSTRFromANSI(szBuffer, &bstrHelpString));
    *pbstrHelpString = bstrHelpString;

Error:
    RRETURN(hr);
}


#if defined(DEBUG)

extern "C" DWORD RetLastError() { return ::GetLastError(); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menu.cpp ===
//=--------------------------------------------------------------------------=
// menu.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenu class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menu.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CMMCMenu::m_rgvtClick[2] = { VT_I4, VT_UNKNOWN };

EVENTINFO CMMCMenu::m_eiClick =
{
    DISPID_MENU_EVENT_CLICK,
    sizeof(m_rgvtClick) / sizeof(m_rgvtClick[0]),
    m_rgvtClick
};

#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenu::CMMCMenu(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCMENU,
                            static_cast<IMMCMenu *>(this),
                            static_cast<CMMCMenu *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenu,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCMenu::~CMMCMenu()
{
    FREESTRING(m_bstrCaption);
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrStatusBarText);
    FREESTRING(m_bstrResultViewDisplayString);
    RELEASE(m_piChildren);
    (void)::VariantClear(&m_varTag);
    InitMemberVariables();
}

void CMMCMenu::InitMemberVariables()
{
    m_Index = 0;
    m_bstrName = NULL;
    m_bstrKey = NULL;
    m_bstrCaption = NULL;
    m_Visible = VARIANT_TRUE;
    m_Checked = VARIANT_FALSE;
    m_Enabled = VARIANT_TRUE;
    m_Grayed = VARIANT_FALSE;
    m_MenuBreak = VARIANT_FALSE;
    m_MenuBarBreak = VARIANT_FALSE;
    m_Default = VARIANT_FALSE;

    ::VariantInit(&m_varTag);

    m_bstrStatusBarText = NULL;
    m_piChildren = NULL;
    m_pMMCMenus = NULL;
    m_fAutoViewMenuItem = FALSE;
    m_bstrResultViewDisplayString = NULL;
    m_fAutoViewMenuItem = FALSE;
}

IUnknown *CMMCMenu::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;
    CMMCMenu  *pMMCMenu = New CMMCMenu(punkOuter);
    CMMCMenus *pMMCChildrenMenus = NULL;

    if (NULL == pMMCMenu)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Create the children menu collection. If this menu object is being
    // created during deserialization, then this collection will be released
    // and recreated in our Persist() method below but there is now way of
    // knowing that here. If the dev does Dim MyMenu As New MMCMenu then
    // they might call MyMenu.Children.Add so the collection must exist.

    IfFailGo(CreateObject(OBJECT_TYPE_MMCMENUS,
                          IID_IMMCMenus, &pMMCMenu->m_piChildren));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pMMCMenu->m_piChildren,
                                                   &pMMCChildrenMenus));
    pMMCChildrenMenus->SetParent(pMMCMenu);

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pMMCMenu)
        {
            delete pMMCMenu;
        }
        return NULL;
    }
    else
    {
        return pMMCMenu->PrivateUnknown();
    }
}


void CMMCMenu::FireClick(long lIndex, IMMCClipboard *piSelection)
{
    DebugPrintf("Firing Menu%ls_Click(%ld)\r\n", m_bstrName, lIndex);

    FireEvent(&m_eiClick, lIndex, piSelection);
}



HRESULT CMMCMenu::SetResultViewDisplayString(BSTR bstrDisplayString)
{
    HRESULT hr = S_OK;
    
    FREESTRING(m_bstrResultViewDisplayString);
    if (NULL != bstrDisplayString)
    {
        m_bstrResultViewDisplayString = ::SysAllocString(bstrDisplayString);
        if (NULL == m_bstrResultViewDisplayString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenu::Persist()
{
    HRESULT    hr = S_OK;
    CMMCMenus *pMMCChildrenMenus = NULL;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrCaption, L"", OLESTR("Caption")));

    IfFailGo(PersistSimpleType(&m_Visible, VARIANT_TRUE, OLESTR("Visible")));

    IfFailGo(PersistSimpleType(&m_Checked, VARIANT_FALSE, OLESTR("Checked")));

    IfFailGo(PersistSimpleType(&m_Enabled, VARIANT_TRUE, OLESTR("Enabled")));

    IfFailGo(PersistSimpleType(&m_Grayed, VARIANT_FALSE, OLESTR("Grayed")));

    IfFailGo(PersistSimpleType(&m_MenuBreak, VARIANT_FALSE, OLESTR("MenuBreak")));

    IfFailGo(PersistSimpleType(&m_MenuBarBreak, VARIANT_FALSE, OLESTR("MenuBarBreak")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 12) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_Default, VARIANT_FALSE, OLESTR("Default")));
    }

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistBstr(&m_bstrStatusBarText, L"", OLESTR("StatusBarText")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 8) )
    {
    }
    else
    {
        IfFailGo(PersistObject(&m_piChildren, CLSID_MMCMenus,
                               OBJECT_TYPE_MMCMENUS, IID_IMMCMenus,
                               OLESTR("Children")));

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piChildren,
                                                       &pMMCChildrenMenus));
        pMMCChildrenMenus->SetParent(this);

        IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));
    }
    IfFailGo(PersistDISPID());

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenu::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenu == riid)
    {
        *ppvObjOut = static_cast<IMMCMenu *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenu::OnSetHost()
{
    RRETURN(SetObjectHost(m_piChildren));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudef.cpp ===
//=--------------------------------------------------------------------------=
// menudef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menudef.h"
#include "menu.h"
#include "menudefs.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenuDef::CMMCMenuDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCMENUDEF,
                            static_cast<IMMCMenuDef *>(this),
                            static_cast<CMMCMenuDef *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenuDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCMenuDef::~CMMCMenuDef()
{
    FREESTRING(m_bstrKey);
    RELEASE(m_piMenu);
    RELEASE(m_piChildren);
    InitMemberVariables();
}

void CMMCMenuDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_piMenu = NULL;
    m_piChildren = NULL;
    m_pMMCMenuDefs = NULL;
}

IUnknown *CMMCMenuDef::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMMCMenuDef = NULL;

    CMMCMenuDef *pMMCMenuDef = New CMMCMenuDef(punkOuter);

    IfFalseGo(NULL != pMMCMenuDef, SID_E_OUTOFMEMORY);
    punkMMCMenuDef = pMMCMenuDef->PrivateUnknown();

Error:
    return punkMMCMenuDef;
}


void CMMCMenuDef::SetMenu(IMMCMenu *piMMCMenu)
{
    RELEASE(m_piMenu);
    if (NULL != piMMCMenu)
    {
        piMMCMenu->AddRef();
    }
    m_piMenu = piMMCMenu;
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDef::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistObject(&m_piMenu, CLSID_MMCMenu,
                           OBJECT_TYPE_MMCMENU, IID_IMMCMenu,
                           OLESTR("Menu")));

    IfFailGo(PersistObject(&m_piChildren, CLSID_MMCMenuDefs,
                           OBJECT_TYPE_MMCMENUDEFS, IID_IMMCMenuDefs,
                           OLESTR("Children")));
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenuDef == riid)
    {
        *ppvObjOut = static_cast<IMMCMenuDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piMenu));

    IfFailRet(SetObjectHost(m_piChildren));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudef.h ===
//=--------------------------------------------------------------------------=
// menudef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _MENUDEF_DEFINED_
#define _MENUDEF_DEFINED_

#include "menudefs.h"


class CMMCMenuDef : public CSnapInAutomationObject,
                    public CPersistence,
                    public IMMCMenuDef
{
    private:
        CMMCMenuDef(IUnknown *punkOuter);
        ~CMMCMenuDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenuDef
        SIMPLE_PROPERTY_RW(CMMCMenuDef,  Index,    long,            DISPID_MMCMENUDEF_INDEX);
        BSTR_PROPERTY_RW(CMMCMenuDef,    Key,                       DISPID_MMCMENUDEF_KEY);
        OBJECT_PROPERTY_RO(CMMCMenuDef,  Menu,     IMMCMenu,        DISPID_MMCMENUDEF_MENU);
        OBJECT_PROPERTY_RO(CMMCMenuDef,  Children, IMMCMenuDefs,    DISPID_MMCMENUDEF_CHILDREN);

    // Public utility methods
    public:
        void SetParent(CMMCMenuDefs *pMMCMenuDefs) { m_pMMCMenuDefs = pMMCMenuDefs; }
        CMMCMenuDefs *GetParent() { return m_pMMCMenuDefs; };

        void SetMenu(IMMCMenu *piMMCMenu);

        long GetIndex() { return m_Index; }
        BSTR GetKey() { return m_bstrKey; }
        
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CMMCMenuDefs *m_pMMCMenuDefs; //owning object
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenuDef,                  // name
                                &CLSID_MMCMenuDef,           // clsid
                                "MMCMenuDef",                // objname
                                "MMCMenuDef",                // lblname
                                &CMMCMenuDef::Create,        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCMenuDef,            // dispatch IID
                                NULL,                        // no event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _MENUDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mssnapr_i_wrap.c ===
#include "mssnapr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudefs.h ===
//=--------------------------------------------------------------------------=
// menudefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _MENUDEFS_DEFINED_
#define _MENUDEFS_DEFINED_

#include "collect.h"

class CMMCMenuDefs : public CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>,
                     public CPersistence
{
    protected:
        CMMCMenuDefs(IUnknown *punkOuter);
        ~CMMCMenuDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenuDefs
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, IMMCMenuDef **ppiMMCMenuDef);
        STDMETHOD(AddExisting)(IMMCMenuDef *piMMCMenuDef, VARIANT Index);

    // CPersistence overrides
    protected:
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        HRESULT SetBackPointers(IMMCMenuDef *piMMCMenuDef);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenuDefs,              // name
                                &CLSID_MMCMenuDefs,       // clsid
                                "MMCMenuDefs",            // objname
                                "MMCMenuDefs",            // lblname
                                &CMMCMenuDefs::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCMenuDefs,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _MENUDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menus.cpp ===
//=--------------------------------------------------------------------------=
// menus.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenus class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menus.h"
#include "menudef.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenus::CMMCMenus(IUnknown *punkOuter) :
    CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>(
                                           punkOuter,
                                           OBJECT_TYPE_MMCMENUS,
                                           static_cast<IMMCMenus *>(this),
                                           static_cast<CMMCMenus *>(this),
                                           CLSID_MMCMenu,
                                           OBJECT_TYPE_MMCMENU,
                                           IID_IMMCMenu,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenus,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CMMCMenus::InitMemberVariables()
{
    m_pMMCMenu = NULL;
}


CMMCMenus::~CMMCMenus()
{
    InitMemberVariables();
}

IUnknown *CMMCMenus::Create(IUnknown * punkOuter)
{
    CMMCMenus *pMMCMenus = New CMMCMenus(punkOuter);
    if (NULL == pMMCMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCMenus->PrivateUnknown();
    }
}


HRESULT CMMCMenus::SetBackPointers(IMMCMenu *piMMCMenu)
{
    HRESULT   hr = S_OK;
    CMMCMenu *pMMCMenu = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));
    pMMCMenu->SetCollection(this);
    
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CMMCMenus::Convert
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IMMCMenuDefs *piMMCMenuDefs [in] Old MenuDefs collection
//      IMMCMenus    *piMMCMenus    [out] new Menus collection populated from
//                                        from MenuDefs
//
// Output:
//      HRESULT
//
// Notes:
//
// This function takes an MMCMenuDefs collection and populates an MMCMenus
// collection from it. This is done to enable loading old snap-in projects
// before serialization version 0.8 where an object model change was made that
// made MMCMenuDefs obsolete.
//
// This function will call itself recursively to populate the children
// of menu items in the specified collections.

HRESULT CMMCMenus::Convert
(
    IMMCMenuDefs *piMMCMenuDefs,
    IMMCMenus    *piMMCMenus
)
{
    HRESULT       hr = S_OK;
    CMMCMenuDefs *pMMCMenuDefs = NULL;
    IMMCMenuDef  *piMMCMenuDef = NULL; // Not AddRef()ed
    CMMCMenuDef  *pMMCMenuDef = NULL;
    IMMCMenu     *piMMCNewMenu = NULL;
    IMMCMenu     *piMMCOldMenu = NULL;
    CMMCMenu     *pMMCOldMenu = NULL;
    IMMCMenuDefs *piMMCMenuDefChildren = NULL;
    IMMCMenus    *piMMCNewMenuChildren = NULL;
    long          cMMCMenuDefs = 0;
    long          i = 0;
    IObjectModel *piObjectModel = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);
    varKey.vt = VT_BSTR;

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuDefs, &pMMCMenuDefs));

    cMMCMenuDefs = pMMCMenuDefs->GetCount();

    for (i = 0; i < cMMCMenuDefs; i++)
    {
        // Get the next MMCMenuDef

        piMMCMenuDef = pMMCMenuDefs->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuDef, &pMMCMenuDef));

        // Create a new MMCMenu in the caller's collection. Use the old key but
        // not the index because they will be added in the order we find them.
        
        varKey.bstrVal = pMMCMenuDef->GetKey();
        IfFailGo(piMMCMenus->Add(varUnspecifiedIndex, varKey, &piMMCNewMenu));

        // Get the contained MMCMenu object from the old MMCMenuDef and copy
        // its properties to the new MMCMenu
        
        IfFailGo(piMMCMenuDef->get_Menu(&piMMCOldMenu));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCOldMenu, &pMMCOldMenu));

        IfFailGo(piMMCNewMenu->put_Name(pMMCOldMenu->GetName()));
        IfFailGo(piMMCNewMenu->put_Caption(pMMCOldMenu->GetCaption()));
        IfFailGo(piMMCNewMenu->put_Visible(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetVisible())));
        IfFailGo(piMMCNewMenu->put_Checked(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetChecked())));
        IfFailGo(piMMCNewMenu->put_Enabled(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetEnabled())));
        IfFailGo(piMMCNewMenu->put_Grayed(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetGrayed())));
        IfFailGo(piMMCNewMenu->put_MenuBreak(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetMenuBreak())));
        IfFailGo(piMMCNewMenu->put_MenuBarBreak(BOOL_TO_VARIANTBOOL(pMMCOldMenu->GetMenuBarBreak())));
        IfFailGo(piMMCNewMenu->put_Tag(pMMCOldMenu->GetTag()));
        IfFailGo(piMMCNewMenu->put_StatusBarText(pMMCOldMenu->GetStatusBarText()));

        IfFailGo(piMMCNewMenu->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));
        IfFailGo(piObjectModel->SetDISPID(pMMCOldMenu->GetDispid()));

        // Get the children of the old MMCMenuDef and the new MMCMenu and call
        // this function recursively to populate them.
        
        IfFailGo(piMMCMenuDef->get_Children(&piMMCMenuDefChildren));
        IfFailGo(piMMCNewMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCNewMenuChildren)));
        IfFailGo(Convert(piMMCMenuDefChildren, piMMCNewMenuChildren));

        RELEASE(piMMCMenuDefChildren);
        RELEASE(piMMCNewMenuChildren);
        RELEASE(piMMCNewMenu);
        RELEASE(piMMCOldMenu);
        RELEASE(piObjectModel);
    }

Error:
    QUICK_RELEASE(piMMCMenuDefChildren);
    QUICK_RELEASE(piMMCNewMenuChildren);
    QUICK_RELEASE(piMMCNewMenu);
    QUICK_RELEASE(piMMCOldMenu);
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IMMCMenus Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCMenus::Add
(
    VARIANT    Index,
    VARIANT    Key,
    IMMCMenu **ppiMMCMenu
)
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;

    // Add the item to the collection. Do not specify an index.

    hr = CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::Add(Index,
                                                              Key,
                                                              ppiMMCMenu);
    IfFailGo(hr);

    // Set the back pointer to this collection on the new MMCMenu

    IfFailGo(SetBackPointers(*ppiMMCMenu));
    
Error:
    QUICK_RELEASE(piMMCMenu);
    RRETURN(hr);
}



STDMETHODIMP CMMCMenus::AddExisting(IMMCMenu *piMMCMenu, VARIANT Index)
{
    HRESULT   hr = S_OK;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Use the menu's name as the key for the item in this collection.

    IfFailGo(piMMCMenu->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    // Add the item to the collection at the specified index.
    
    hr = CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::AddExisting(Index,
                                                                      varKey,
                                                                      piMMCMenu);
    IfFailGo(hr);

    // Set the back pointer to this collection on the MMCMenu

    IfFailGo(SetBackPointers(piMMCMenu));

Error:
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenus::Persist()
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;
    long      cMenus = 0;
    long      i = 0;

    // Do persistence operation

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::Persist(piMMCMenu);

    // If this is a load then set back pointers on each collection member

    if (Loading())
    {
        cMenus = GetCount();
        for (i = 0; i < cMenus; i++)
        {
            IfFailGo(SetBackPointers(GetItemByIndex(i)));
        }
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenus::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenus == riid)
    {
        *ppvObjOut = static_cast<IMMCMenus *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\mmcapi.cpp ===
//=--------------------------------------------------------------------------=
// mmcapi.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Exported functions that pass through calls to MMC API functions.
// VB code cannot call MMC API functions because they are in a static lib.
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"

// for ASSERT and FAIL
//
SZTHISFILE



extern "C" WINAPI MMCPropertyHelpPassThru(char *pszTopic)
{
    HRESULT  hr = S_OK;
    LPOLESTR pwszTopic = NULL;

    IfFailGo(::WideStrFromANSI(pszTopic, &pwszTopic));
    IfFailGo(::MMCPropertyHelp(pwszTopic));

Error:
    if (NULL != pwszTopic)
    {
        CtlFree(pwszTopic);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menudefs.cpp ===
//=--------------------------------------------------------------------------=
// menudefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenuDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "menudefs.h"
#include "menudef.h"
#include "menu.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCMenuDefs::CMMCMenuDefs(IUnknown *punkOuter) :
    CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>(
                                           punkOuter,
                                           OBJECT_TYPE_MMCMENUDEFS,
                                           static_cast<IMMCMenuDefs *>(this),
                                           static_cast<CMMCMenuDefs *>(this),
                                           CLSID_MMCMenuDef,
                                           OBJECT_TYPE_MMCMENUDEF,
                                           IID_IMMCMenuDef,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCMenuDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCMenuDefs::~CMMCMenuDefs()
{
}

IUnknown *CMMCMenuDefs::Create(IUnknown * punkOuter)
{
    CMMCMenuDefs *pMMCMenus = New CMMCMenuDefs(punkOuter);
    if (NULL == pMMCMenus)
    {
        return NULL;
    }
    else
    {
        return pMMCMenus->PrivateUnknown();
    }
}


HRESULT CMMCMenuDefs::SetBackPointers(IMMCMenuDef *piMMCMenuDef)
{
    HRESULT      hr = S_OK;
    CMMCMenuDef *pMMCMenuDef = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenuDef, &pMMCMenuDef));
    pMMCMenuDef->SetParent(this);
    
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                         IMMCMenuDefs Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCMenuDefs::Add
(
    VARIANT       Index,
    VARIANT       Key,
    IMMCMenuDef **ppiMMCMenuDef
)
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    // Add the item to the collection. Do not specify an index.

    hr = CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::Add(
                                                                 Index,
                                                                 Key,
                                                                 ppiMMCMenuDef);
    IfFailGo(hr);

    // Set the back pointer on the MMCMenu and on the MMCMenuDef

    IfFailGo(SetBackPointers(*ppiMMCMenuDef));
    
Error:
    QUICK_RELEASE(piMMCMenu);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}



STDMETHODIMP CMMCMenuDefs::AddExisting(IMMCMenuDef *piMMCMenuDef, VARIANT Index)
{
    HRESULT   hr = S_OK;
    IMMCMenu *piMMCMenu = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Use the menu's name as the key for the item in this collection.

    IfFailGo(piMMCMenuDef->get_Menu(&piMMCMenu));
    IfFailGo(piMMCMenu->get_Name(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    // Add the item to the collection at the specified index.
    
    hr = CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::AddExisting(
                                                                  Index,
                                                                  varKey,
                                                                  piMMCMenuDef);
    IfFailGo(hr);

    // Set the back pointer on the MMCMenu and on the MMCMenuDef

    IfFailGo(SetBackPointers(piMMCMenuDef));

Error:
    QUICK_RELEASE(piMMCMenu);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDefs::Persist()
{
    HRESULT      hr = S_OK;
    IMMCMenuDef *piMMCMenuDef = NULL;
    long         cMenuDefs = 0;
    long         i = 0;

    // Do persistence operation

    IfFailGo(CPersistence::Persist());
    hr = CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::Persist(piMMCMenuDef);

    // If this is a load then set back pointers on each collection member

    if (Loading())
    {
        cMenuDefs = GetCount();
        for (i = 0; i < cMenuDefs; i++)
        {
            IfFailGo(SetBackPointers(GetItemByIndex(i)));
        }
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCMenuDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCMenuDefs == riid)
    {
        *ppvObjOut = static_cast<IMMCMenuDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCMenuDef, MMCMenuDef, IMMCMenuDefs>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\menus.h ===
//=--------------------------------------------------------------------------=
// menus.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCMenus class definition - implements MMCMenus collection
//
//=--------------------------------------------------------------------------=

#ifndef _MENUS_DEFINED_
#define _MENUS_DEFINED_

#include "collect.h"
#include "menu.h"

class CMMCMenu;

class CMMCMenus : public CSnapInCollection<IMMCMenu, MMCMenu, IMMCMenus>,
                  public CPersistence
{
    protected:
        CMMCMenus(IUnknown *punkOuter);
        ~CMMCMenus();

    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMenus
        STDMETHOD(Add)(VARIANT Index, VARIANT Key, IMMCMenu **ppiMMCMenu);
        STDMETHOD(AddExisting)(IMMCMenu *piMMCMenu, VARIANT Index);

    // Public utility methods
        CMMCMenu *GetParent() { return m_pMMCMenu; }
        void SetParent(CMMCMenu *pMMCMenu) { m_pMMCMenu = pMMCMenu; }

        // Used for upgrades from pre-beta code to convert MMCMenuDefs
        // collection to MMCMenus

        static HRESULT Convert(IMMCMenuDefs *piMMCMenuDefs, IMMCMenus *piMMCMenus);

    // CPersistence overrides
    protected:
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        HRESULT SetBackPointers(IMMCMenu *piMMCMenu);

        CMMCMenu *m_pMMCMenu; //owning menu object
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCMenus,              // name
                                &CLSID_MMCMenus,       // clsid
                                "MMCMenus",            // objname
                                "MMCMenus",            // lblname
                                &CMMCMenus::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCMenus,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _MENUS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\msgview.cpp ===
//=--------------------------------------------------------------------------=
// msgview.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CExtension class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "msgview.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CMessageView::CMessageView(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MESSAGEVIEW,
                            static_cast<IMMCMessageView *>(this),
                            static_cast<CMessageView *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            NULL) // no persistence

{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMessageView::~CMessageView()
{
    FREESTRING(m_bstrTitleText);
    FREESTRING(m_bstrBodyText);
    InitMemberVariables();
}

void CMessageView::InitMemberVariables()
{
    m_bstrTitleText = NULL;
    m_bstrBodyText = NULL;
    m_IconType = siIconNone;
    m_pResultView = NULL;
}

IUnknown *CMessageView::Create(IUnknown *punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMessageView = NULL;

    CMessageView *pMessageView = New CMessageView(punkOuter);

    IfFalseGo(NULL != pMessageView, SID_E_OUTOFMEMORY);
    punkMessageView = pMessageView->PrivateUnknown();

Error:
    return punkMessageView;
}

IMessageView *CMessageView::GetMessageView()
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CResultView     *pResultView = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;
    IConsole2       *piConsole2 = NULL; // NotAddRef()ed
    IUnknown        *punkResultView = NULL;
    IMessageView    *piMessageView = NULL;

    IfFalseGo(NULL != m_pResultView, hr);

    pScopePaneItem = m_pResultView->GetScopePaneItem();
    IfFalseGo(NULL != pScopePaneItem, hr);

    pScopePaneItems = pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);

    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);

    piConsole2 = pView->GetIConsole2();
    IfFalseGo(NULL != piConsole2, hr);

    IfFailGo(piConsole2->QueryResultView(&punkResultView));
    IfFailGo(punkResultView->QueryInterface(IID_IMessageView,
                                   reinterpret_cast<void **>(&piMessageView)));

Error:
    QUICK_RELEASE(punkResultView);
    return piMessageView;
}


HRESULT CMessageView::Populate()
{
    HRESULT hr = S_OK;

    IfFailGo(SetTitle());
    IfFailGo(SetBody());
    IfFailGo(SetIcon());

Error:
    RRETURN(hr);
}


HRESULT CMessageView::SetTitle()
{
    HRESULT       hr = S_OK;
    IMessageView *piMessageView = GetMessageView();

    IfFalseGo(NULL != m_pResultView, S_OK);
    IfFalseGo(!m_pResultView->InActivate(), S_OK);
    IfFalseGo(NULL != piMessageView, S_OK);

    hr = piMessageView->SetTitleText(static_cast<LPCOLESTR>(m_bstrTitleText));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}

HRESULT CMessageView::SetBody()
{
    HRESULT       hr = S_OK;
    IMessageView *piMessageView = GetMessageView();

    IfFalseGo(NULL != m_pResultView, S_OK);
    IfFalseGo(!m_pResultView->InActivate(), S_OK);
    IfFalseGo(NULL != piMessageView, S_OK);

    hr = piMessageView->SetBodyText(static_cast<LPCOLESTR>(m_bstrBodyText));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}


HRESULT CMessageView::SetIcon()
{
    HRESULT        hr = S_OK;
    IMessageView  *piMessageView = GetMessageView();
    IconIdentifier IconID = Icon_None;

    IfFalseGo(NULL != m_pResultView, S_OK);
    IfFalseGo(!m_pResultView->InActivate(), S_OK);
    IfFalseGo(NULL != piMessageView, S_OK);

    switch (m_IconType)
    {
        case siIconNone:
            IconID = Icon_None;
            break;

        case siIconError:
            IconID = Icon_Error;
            break;

        case siIconQuestion:
            IconID = Icon_Question;
            break;

        case siIconWarning:
            IconID = Icon_Warning;
            break;

        case siIconInformation:
            IconID = Icon_Information;
            break;

        default:
            break;
    }
    hr = piMessageView->SetIcon(IconID);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                         IMessageView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMessageView::put_TitleText(BSTR bstrText)
{
    HRESULT hr = S_OK;

    IfFailGo(SetBstr(bstrText, &m_bstrTitleText, DISPID_MESSAGEVIEW_TITLE_TEXT));
    IfFailGo(SetTitle());

Error:
    RRETURN(hr);
}

STDMETHODIMP CMessageView::put_BodyText(BSTR bstrText)
{
    HRESULT hr = S_OK;

    IfFailGo(SetBstr(bstrText, &m_bstrBodyText, DISPID_MESSAGEVIEW_BODY_TEXT));
    IfFailGo(SetBody());

Error:
    RRETURN(hr);
}

STDMETHODIMP CMessageView::put_IconType(SnapInMessageViewIconTypeConstants Type)
{
    HRESULT hr = S_OK;

    IfFailGo(SetSimpleType(Type, &m_IconType, DISPID_MESSAGEVIEW_ICON_TYPE));
    IfFailGo(SetIcon());

Error:
    RRETURN(hr);
}


STDMETHODIMP CMessageView::Clear()
{
    HRESULT       hr = S_OK;
    IMessageView *piMessageView = GetMessageView();

    // Clear out our properties

    IfFailGo(SetBstr(NULL, &m_bstrTitleText, DISPID_MESSAGEVIEW_TITLE_TEXT));
    IfFailGo(SetBstr(NULL, &m_bstrBodyText, DISPID_MESSAGEVIEW_BODY_TEXT));
    IfFailGo(SetSimpleType(siIconNone, &m_IconType, DISPID_MESSAGEVIEW_ICON_TYPE));

    // Ask MMC to clear out the message view
    
    IfFalseGo(NULL != piMessageView, S_OK);
    hr = piMessageView->Clear();
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMessageView);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMessageView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCMessageView == riid)
    {
        *ppvObjOut = static_cast<IMMCMessageView *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodetype.h ===
//=--------------------------------------------------------------------------=
// nodetype.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeType class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _NODETYPE_DEFINED_
#define _NODETYPE_DEFINED_


class CNodeType : public CSnapInAutomationObject,
                  public CPersistence,
                  public INodeType
{
    private:
        CNodeType(IUnknown *punkOuter);
        ~CNodeType();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // INodeType

        SIMPLE_PROPERTY_RW(CNodeType, Index, long, DISPID_NODETYPE_INDEX);
        BSTR_PROPERTY_RW(CNodeType,   Key, DISPID_NODETYPE_KEY);
        BSTR_PROPERTY_RW(CNodeType,   Name,  DISPID_NODETYPE_NAME);
        BSTR_PROPERTY_RW(CNodeType,   GUID,  DISPID_NODETYPE_GUID);

      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(NodeType,           // name
                                &CLSID_NodeType,    // clsid
                                "NodeType",         // objname
                                "NodeType",         // lblname
                                &CNodeType::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_INodeType,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _NODETYPE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodetype.cpp ===
//=--------------------------------------------------------------------------=
// nodetype.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeType class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "nodetype.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CNodeType::CNodeType(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_NODETYPE,
                            static_cast<INodeType *>(this),
                            static_cast<CNodeType *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_NodeType,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CNodeType::~CNodeType()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrGUID);
    FREESTRING(m_bstrName);
    InitMemberVariables();
}

void CNodeType::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrGUID = NULL;
    m_bstrName = NULL;
}

IUnknown *CNodeType::Create(IUnknown * punkOuter)
{
    CNodeType *pNodeType = New CNodeType(punkOuter);
    if (NULL == pNodeType)
    {
        return NULL;
    }
    else
    {
        return pNodeType->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeType::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistBstr(&m_bstrGUID, L"", OLESTR("GUID")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeType::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_INodeType == riid)
    {
        *ppvObjOut = static_cast<INodeType *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\msgview.h ===
//=--------------------------------------------------------------------------=
// msgview.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMessageView class definition - implements MMCMessageView object
//
//=--------------------------------------------------------------------------=

#ifndef _MESSAGEVIEW_DEFINED_
#define _MESSAGEVIEW_DEFINED_

#include "resview.h"

class CResultView;

class CMessageView : public CSnapInAutomationObject,
                     public IMMCMessageView
{
    private:
        CMessageView(IUnknown *punkOuter);
        ~CMessageView();
    
    public:
        static IUnknown *Create(IUnknown *punk);

        void SetResultView(CResultView *pResultView) { m_pResultView = pResultView; }

        // Sets MMC message view properties from this object's properties
        
        HRESULT Populate();

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCMessageView
        BSTR_PROPERTY_RO(CMessageView, TitleText, DISPID_MESSAGEVIEW_TITLE_TEXT);
        STDMETHOD(put_TitleText)(BSTR bstrText);

        BSTR_PROPERTY_RO(CMessageView, BodyText, DISPID_MESSAGEVIEW_BODY_TEXT);
        STDMETHOD(put_BodyText)(BSTR bstrText);

        SIMPLE_PROPERTY_RO(CMessageView, IconType, SnapInMessageViewIconTypeConstants, DISPID_MESSAGEVIEW_ICON_TYPE);
        STDMETHOD(put_IconType)(SnapInMessageViewIconTypeConstants Type);
      
        STDMETHOD(Clear)();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        IMessageView *GetMessageView();
        HRESULT SetTitle();
        HRESULT SetBody();
        HRESULT SetIcon();

        CResultView *m_pResultView; // back pointer to owning result view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MessageView,            // name
                                &CLSID_MMCMessageView,  // clsid
                                "MessageView",          // objname
                                "MessageView",          // lblname
                                &CMessageView::Create,  // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IMessageView,      // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _MESSAGEVIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodtypes.h ===
//=--------------------------------------------------------------------------=
// nodtype.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeTypes class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _NODETYPES_DEFINED_
#define _NODETYPES_DEFINED_

#include "collect.h"

class CNodeTypes : public CSnapInCollection<INodeType, NodeType, INodeTypes>,
                   public CPersistence
{
    protected:
        CNodeTypes(IUnknown *punkOuter);
        ~CNodeTypes();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(NodeTypes,           // name
                                &CLSID_NodeTypes,    // clsid
                                "NodeTypes",         // objname
                                "NodeTypes",         // lblname
                                &CNodeTypes::Create, // creation function
                                TLIB_VERSION_MAJOR,  // major version
                                TLIB_VERSION_MINOR,  // minor version
                                &IID_INodeTypes,     // dispatch IID
                                NULL,                // no events IID
                                HELP_FILENAME,       // help file
                                TRUE);               // thread safe


#endif // _NODETYPES_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdefs.cpp ===
//=--------------------------------------------------------------------------=
// ocxvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ocxvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

COCXViewDefs::COCXViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>(
                                                 punkOuter,
                                                 OBJECT_TYPE_OCXVIEWDEFS,
                                                 static_cast<IOCXViewDefs *>(this),
                                                 static_cast<COCXViewDefs *>(this),
                                                 CLSID_OCXViewDef,
                                                 OBJECT_TYPE_OCXVIEWDEF,
                                                 IID_IOCXViewDef,
                                                 static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_OCXViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


COCXViewDefs::~COCXViewDefs()
{
}

IUnknown *COCXViewDefs::Create(IUnknown * punkOuter)
{
    COCXViewDefs *pOCXViewDefs = New COCXViewDefs(punkOuter);
    if (NULL == pOCXViewDefs)
    {
        return NULL;
    }
    else
    {
        return pOCXViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDefs::Persist()
{
    HRESULT      hr = S_OK;
    IOCXViewDef *piOCXViewDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>::Persist(piOCXViewDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IOCXViewDefs == riid)
    {
        *ppvObjOut = static_cast<IOCXViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>::GetMaster(IOCXViewDefs **ppiMasterOCXViewDefs)
{
    H_RRETURN(GetOCXViewDefs(ppiMasterOCXViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdef.cpp ===
//=--------------------------------------------------------------------------=
// ocxvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ocxvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *COCXViewDef::m_rgpPropertyPageCLSIDs[1] = { &CLSID_OCXViewDefGeneralPP };


#pragma warning(disable:4355)  // using 'this' in constructor

COCXViewDef::COCXViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_OCXVIEWDEF,
                            static_cast<IOCXViewDef *>(this),
                            static_cast<COCXViewDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_OCXViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


COCXViewDef::~COCXViewDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    FREESTRING(m_bstrProgID);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    InitMemberVariables();
}

void COCXViewDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrName = NULL;

    ::VariantInit(&m_varTag);

    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_bstrProgID = NULL;
    m_AlwaysCreateNewOCX = VARIANT_FALSE;
    m_pwszActualDisplayString = NULL;
}

IUnknown *COCXViewDef::Create(IUnknown * punkOuter)
{
    COCXViewDef *pOCXViewDef = New COCXViewDef(punkOuter);
    if (NULL == pOCXViewDef)
    {
        return NULL;
    }
    else
    {
        return pOCXViewDef->PrivateUnknown();
    }
}



HRESULT COCXViewDef::SetActualDisplayString(OLECHAR *pwszString)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszString,
                                   &m_pwszActualDisplayString));
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDef::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailRet(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailRet(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailRet(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailRet(PersistBstr(&m_bstrProgID, L"", OLESTR("ProgID")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 7) )
    {
    }
    else
    {
        IfFailRet(PersistSimpleType(&m_AlwaysCreateNewOCX, VARIANT_FALSE, OLESTR("AlwaysCreateNewOCX")));
    }
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT COCXViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IOCXViewDef == riid)
    {
        *ppvObjOut = static_cast<IOCXViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdef.h ===
//=--------------------------------------------------------------------------=
// ocxvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _OCXVIEWDEF_DEFINED_
#define _OCXVIEWDEF_DEFINED_


class COCXViewDef : public CSnapInAutomationObject,
                    public CPersistence,
                    public IOCXViewDef
{
    private:
        COCXViewDef(IUnknown *punkOuter);
        ~COCXViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IOCXViewDef

        BSTR_PROPERTY_RW(COCXViewDef,       Name,  DISPID_OCXVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(COCXViewDef,     Index, long, DISPID_OCXVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(COCXViewDef,       Key, DISPID_OCXVIEWDEF_KEY);
        VARIANTREF_PROPERTY_RW(COCXViewDef, Tag, DISPID_OCXVIEWDEF_TAG);
        SIMPLE_PROPERTY_RW(COCXViewDef,     AddToViewMenu, VARIANT_BOOL, DISPID_OCXVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(COCXViewDef,       ViewMenuText, DISPID_OCXVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(COCXViewDef,       ViewMenuStatusBarText, DISPID_OCXVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        BSTR_PROPERTY_RW(COCXViewDef,       ProgID, DISPID_OCXVIEWDEF_PROGID);
        SIMPLE_PROPERTY_RW(COCXViewDef,     AlwaysCreateNewOCX, VARIANT_BOOL, DISPID_OCXVIEWDEF_ALWAYS_CREATE_NEW_OCX);
      
    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        HRESULT SetActualDisplayString(OLECHAR *pwszString);
        OLECHAR *GetActualDisplayString() { return m_pwszActualDisplayString; }

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        OLECHAR *m_pwszActualDisplayString; // At runtime this will contain the
                                            // actual display string returned
                                            // to MMC for this result view.

        // Property pages CLSID for ISpecifyPropertyPages

        static const GUID *m_rgpPropertyPageCLSIDs[1];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(OCXViewDef,           // name
                                &CLSID_OCXViewDef,    // clsid
                                "OCXViewDef",         // objname
                                "OCXViewDef",         // lblname
                                &COCXViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,   // major version
                                TLIB_VERSION_MINOR,   // minor version
                                &IID_IOCXViewDef,     // dispatch IID
                                NULL,                 // event IID
                                HELP_FILENAME,        // help file
                                TRUE);                // thread safe


#endif // _OCXVIEWDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\nodtypes.cpp ===
//=--------------------------------------------------------------------------=
// nodtypes.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CNodeTypes class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "nodtypes.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CNodeTypes::CNodeTypes(IUnknown *punkOuter) :
    CSnapInCollection<INodeType, NodeType, INodeTypes>(
                      punkOuter,
                      OBJECT_TYPE_NODETYPES,
                      static_cast<INodeTypes *>(this),
                      static_cast<CNodeTypes *>(this),
                      CLSID_NodeType,
                      OBJECT_TYPE_NODETYPE,
                      IID_INodeType,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_NodeTypes,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CNodeTypes::~CNodeTypes()
{
}

IUnknown *CNodeTypes::Create(IUnknown * punkOuter)
{
    CNodeTypes *pNodeTypes = New CNodeTypes(punkOuter);
    if (NULL == pNodeTypes)
    {
        return NULL;
    }
    else
    {
        return pNodeTypes->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeTypes::Persist()
{
    HRESULT     hr = S_OK;
    INodeType  *piNodeType = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<INodeType, NodeType, INodeTypes>::Persist(piNodeType);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CNodeTypes::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_INodeTypes == riid)
    {
        *ppvObjOut = static_cast<INodeTypes *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<INodeType, NodeType, INodeTypes>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\persobj.h ===
//=--------------------------------------------------------------------------=
// persobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPersistence class definition - implements persistence on behalf of all
// objects.
//
//=--------------------------------------------------------------------------=

#ifndef _PERSOBJ_DEFINED_
#define _PERSOBJ_DEFINED_

#include <ipserver.h>
#include "errors.h"
#include "error.h"

// These are the persistence version numbers written into the .DSR and into
// the runtime state. When changing the object model, these numbers must be
// incremented and persistence code that uses the changes must check the
// version number before attempting to read new properties.

const DWORD g_dwVerMajor = 0;
const DWORD g_dwVerMinor = 12;

// Need to disable the following warning:
//
// warning C4275: non dll-interface struct 'IPersistStreamInit' used as base
// for dll-interface class 'CPersistence'
//
// This occurs because the exported class CPersistence derives from a COM
// interface that is not exported. As a COM interface is a virtual base class
// that has no implementation this will not matter.

#pragma warning(disable:4275) 

class CPersistence : public IPersistStreamInit,
                     public IPersistStream,
                     public IPersistPropertyBag
{
    protected:

        CPersistence(const CLSID *pClsid,
                           DWORD  dwVerMajor,
                           DWORD  dwVerMinor);

        ~CPersistence();

        // Derived classes can use this utility function to test for
        // persistence interfaces requests in their QI methods.

        HRESULT QueryPersistenceInterface(REFIID riid, void **ppvInterface);

        // Derived classes must override this and make the appropriate
        // Persist() calls (see below)

        virtual HRESULT Persist();

        // Persistence helpers. These are called regardless of whether the
        // operation is InitNew, save, or load.

    public:

        HRESULT PersistBstr(BSTR *pbstrValue, WCHAR *pwszDefaultValue, LPCOLESTR pwszName);

        HRESULT PersistDouble(DOUBLE *pdblValue, DOUBLE dblDefaultValue, LPCOLESTR pwszName);

        HRESULT PersistDate(DATE *pdtValue, DATE dtDefaultValue,
                            LPCOLESTR  pwszName);

        HRESULT PersistCurrency(CURRENCY *pcyValue, CURRENCY cyDefaultValue,
                                LPCOLESTR  pwszName);

        HRESULT PersistVariant(VARIANT *pvarValue, VARIANT varDefaultValue, LPCOLESTR pwszName);

        HRESULT PersistPicture(IPictureDisp **ppiPictureDisp, LPCOLESTR pwszName);

        template <class SimpleType>
        HRESULT PersistSimpleType(SimpleType *pValue,
                                  SimpleType  DefaultValue,
                                  LPCOLESTR   pwszName)
        {
            HRESULT       hr = S_OK;
            unsigned long ulValue = 0;
            VARIANT       var;
            ::VariantInit(&var);

            if (sizeof(*pValue) > sizeof(long))
            {
                hr = SID_E_INTERNAL;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }

            if (m_fSaving)
            {
                if (m_fStream)
                {
                    hr = WriteToStream(pValue, sizeof(*pValue));
                }
                else if (m_fPropertyBag)
                {
                    var.vt = VT_I4;
                    ulValue = static_cast<unsigned long>(*pValue);
                    var.lVal = static_cast<long>(ulValue);
                    hr = m_piPropertyBag->Write(pwszName, &var);
                }
            }
            else if (m_fLoading)
            {
                if (m_fStream)
                {
                    hr = ReadFromStream(pValue, sizeof(*pValue));
                }
                else if (m_fPropertyBag)
                {
                    // Read the property from the bag

                    hr = m_piPropertyBag->Read(pwszName, &var, m_piErrorLog);
                    H_IfFailGo(hr);

                    // Coerce the type received into VT_I4. This is needed
                    // because the property bag will read the number from the
                    // text and convert it to a VT that fits. For example, "0"
                    // could be converted to VT_I2.

                    H_IfFailGo(::VariantChangeType(&var, &var, 0, VT_I4));

                    ulValue = static_cast<long>(var.lVal);
                    *pValue = static_cast<SimpleType>(ulValue);
                }
            }
            else if (m_fInitNew)
            {
                *pValue = DefaultValue;
            }

        Error:
            ::VariantClear(&var);
            H_RRETURN(hr);
        }
                
        template <class InterfaceType>
        HRESULT PersistObject(InterfaceType **ppiInterface,
                              REFCLSID        clsidObject,
                              UINT            idObject,
                              REFIID          iidInterface,
                              LPCOLESTR       pwszName)
        {
            return
            InternalPersistObject(reinterpret_cast<IUnknown **>(ppiInterface),
                                  clsidObject, idObject, iidInterface, pwszName);
        }


        // If the derived class needs to hand code part of the persistence
        // operation it can use these methods
        
        BOOL Loading();
        BOOL Saving();
        BOOL InitNewing();
        BOOL UsingPropertyBag();
        BOOL UsingStream();
        IStream *GetStream();
        BOOL GetClearDirty();


        // These methods are meant to be used by CStreamer (see below) users to
        // set up the base CPersistence class to save to a specified stream
        // outside of an actual persistence scenario.
        
        void SetStream(IStream *piStream);
        void SetSaving();

        // Use StreamVariant to write the VARIANT's data without prepending the
        // type. Use PersistVariant() to write the type followed by the data.
        
        HRESULT StreamVariant(VARTYPE vt, VARIANT *pvarValue, VARIANT varDefaultValue);

        // Version property access
        void SetMajorVersion(DWORD dwVerMajor);
        DWORD GetMajorVersion();
        void SetMinorVersion(DWORD dwVerMinor);
        DWORD GetMinorVersion();

    // Methods to manipulate the dirty flag.

        void SetDirty();
        void ClearDirty();


    // IPersistStream && IPersistStreamInit
    //
    protected:
        STDMETHOD(GetClassID)(CLSID *pCLSID);
        STDMETHOD(InitNew)();
        STDMETHOD(Load)(IStream *piStream);
        STDMETHOD(Save)(IStream *piStream, BOOL fClearDirty);
        STDMETHOD(IsDirty)();
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *puliSize);

    // IPersistPropertyBag
    //
        STDMETHOD(Load)(IPropertyBag *piPropertyBag, IErrorLog *piErrorLog);
        STDMETHOD(Save)(IPropertyBag *piPropertyBag, BOOL fClearDirty, BOOL fSaveAll);

    private:

        void InitMemberVariables();
        HRESULT InternalPersistObject(IUnknown **ppunkObject,
                                      REFCLSID   clsidObject,
                                      UINT       idObject,
                                      REFIID     iidInterface,
                                      LPCOLESTR  pwszName);
        HRESULT WriteToStream(void *pvBuffer, ULONG cbToWrite);
        HRESULT ReadFromStream(void *pvBuffer, ULONG cbToRead);
        HRESULT StreamObjectInVariant(IUnknown **ppunkObject,
                                      REFIID     iidInterface);

        DWORD            m_dwVerMajor;    // major persistence version of object
        DWORD            m_dwVerMinor;    // minor persistence version of object
        CLSID            m_Clsid;         // CLSID of object
        BOOL             m_fDirty;        // TRUE=object needs to be saved
        BOOL             m_fClearDirty;   // TRUE=in IPersistStreamIni::Save
                                          // with clear diry requested
        BOOL             m_fLoading;      // TRUE=in IPersistXxx::Load
        BOOL             m_fSaving;       // TRUE=in IPersistXxx::Save
        BOOL             m_fInitNew;      // TRUE=in IPersistXxx::InitNew
        BOOL             m_fStream;       // TRUE=doing IPersistStreamInit i/o
        BOOL             m_fPropertyBag;  // TRUE=doing IPersistPropertyBag i/o
        IStream         *m_piStream;      // Used for IPersistStreamInit i/o
        IPropertyBag    *m_piPropertyBag; // Used for IPersistPropertyBag i/o
        IErrorLog       *m_piErrorLog;    // Used for IPersistPropertyBag i/o
};

#pragma warning(default:4275) 

//=--------------------------------------------------------------------------=
// class CStreamer
// 
// This class is a simple derivation of CPersistence that allows using it
// as a utility for its ability to write all sorts of data types to a stream
// To use CStreamer, call New, and then SetStream() (a CPersistence method)
// passing your stream. You can then call all the CPersistence::PersistXxxx
// helper methods without being in an actual persistence scenario.
//
//=--------------------------------------------------------------------------=

class CStreamer : public CPersistence,
                  public CtlNewDelete
{
    public:
        CStreamer() : CPersistence(&CLSID_NULL, 0, 0) { SetSaving(); }
        virtual ~CStreamer() {}

    private:
       STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { return E_NOTIMPL; }
       STDMETHOD_(ULONG, AddRef)(void) { return 0; }
       STDMETHOD_(ULONG, Release)(void) { return 0; }
};

#endif // _PERSOBJ_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\pch.h ===
//=--------------------------------------------------------------------------------------
// pch.h
//=--------------------------------------------------------------------------------------
//
// Copyright  (c) 1999,  Microsoft Corporation.  
//                  All Rights Reserved.
//
// Information Contained Herein Is Proprietary and Confidential.
//=------------------------------------------------------------------------------------=
//
// Precompiled header files for mssnapr
//=-------------------------------------------------------------------------------------=

#include <ipserver.h>
#include <macros.h>
#include <MSStkPPg.h>
#include <comcat.h>
#include <util.h>
#include <commctrl.h>

#include <stdio.h>
#include <stdarg.h>

#include "localobj.h"
#define IID_IMMCListView My_IID_IMMCListView
#define IID_INodeType    My_IID_INodeType
#include "mssnapr.h"
#include "mmc.h"
#include "dispid.h"
#include "help.h"
#include "tlver.h"
#include "rtconst.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ppgwrap.h ===
//=--------------------------------------------------------------------------=
// ppgwrap.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertyPageWrapper class definition
//
// This class implements a dialog box wrapper around a COM property page. It
// parents the page within an empty dialog box and implements
// IPropertyPageSite for the page. WM_NOITFY messages with PSN_XXXX
// notifications are translated into IPropertyPage calls and passed on to
// the property page. If the page implements the IWizardPage interface (defined
// by us in mssnapr.idl) then it will also receive PSN_WIZXXX notifications.
//=--------------------------------------------------------------------------=

#ifndef _PPGWRAP_DEFINED_
#define _PPGWRAP_DEFINED_

#include "prpsheet.h"


class CPropertyPageWrapper : public CSnapInAutomationObject,
                             public IPropertyPageSite
{
    protected:
        CPropertyPageWrapper(IUnknown *punkOuter);
        ~CPropertyPageWrapper();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT CreatePage(CPropertySheet  *pPropertySheet,
                           CLSID            clsidPage,
                           BOOL             fWizard,
                           BOOL             fConfigWizard,
                           ULONG            cObjects,
                           IUnknown       **apunkObjects,
                           ISnapIn         *piSnapIn,
                           short            cxPage,
                           short            cyPage,
                           VARIANT          varInitData,
                           BOOL             fIsRemote,
                           DLGTEMPLATE    **ppTemplate);

        HWND GetSheetHWND() { return m_hwndSheet; }

        static BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg,
                                        WPARAM wParam, LPARAM lParam);

        static UINT CALLBACK PropSheetPageProc(HWND hwnd, UINT uMsg,
                                               PROPSHEETPAGE *pPropSheetPage);

    protected:

        // Dialog Message Handlers
        
        HRESULT OnInitDialog(HWND hwndDlg);
        HRESULT OnInitMsg();
        HRESULT OnApply(LRESULT *plresult);
        HRESULT OnSetActive(HWND hwndSheet, LRESULT *plresult);
        HRESULT OnKillActive(LRESULT *plresult);
        HRESULT OnWizBack(LRESULT *plresult);
        HRESULT OnWizNext(LRESULT *plresult);
        HRESULT OnWizFinish(LRESULT *plresult);
        HRESULT OnQueryCancel(LRESULT *plresult);
        HRESULT OnReset(BOOL fClickedXButton);
        HRESULT OnHelp();
        HRESULT OnSize();
        HRESULT OnDestroy();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

    // IPropertyPageSite
        STDMETHOD(OnStatusChange)(DWORD dwFlags);
        STDMETHOD(GetLocaleID)(LCID *pLocaleID);
        STDMETHOD(GetPageContainer)(IUnknown **ppunkContainer);
        STDMETHOD(TranslateAccelerator)(MSG *pMsg);

        void InitMemberVariables();
        HRESULT InitPage();
        HRESULT GetNextPage(long *lNextPage);
        HRESULT ActivatePage();
        HRESULT AddMsgFilterHook();
        HRESULT RemoveMsgFilterHook();
        static LRESULT CALLBACK MessageProc(int code,
                                            WPARAM wParam, LPARAM lParam);

        CPropertySheet     *m_pPropertySheet;     // cross-thread C++ pointer
        IMMCPropertySheet  *m_piMMCPropertySheet; // marshaled across threads
        IPropertyPage      *m_piPropertyPage;     // interface on VB prop page
        IMMCPropertyPage   *m_piMMCPropertyPage;  // interface on VB prop page
        IWizardPage        *m_piWizardPage;       // interface on VB prop page
        BOOL                m_fWizard;            // TRUE=this page is in a wizard
        BOOL                m_fConfigWizard;      // TRUE=this page is in a config wizard
        DLGTEMPLATE        *m_pTemplate;          // template for wrapper dialog
        HWND                m_hwndDlg;            // HWND of wrapper dialog
        HWND                m_hwndSheet;          // HWND of property sheet
        CLSID               m_clsidPage;          // CLSID of VB prop page
        ULONG               m_cObjects;           // no. of object for which props are being displayed
        IStream           **m_apiObjectStreams;   // stream for mashaling each object to MMC's property sheet thread
        IStream            *m_piSnapInStream;     // stream for mashaling ISnapIn to MMC's property sheet thread
        IStream            *m_piInitDataStream;   // stream for mashaling an object in MMCPropertySheet::AddPage's InitData param to MMC's property sheet thread
        IStream            *m_piMMCPropertySheetStream; // stream for mashaling IMMCPropertySheet to MMC's property sheet thread
        ISnapIn            *m_piSnapIn;           // back pointer to snap-in, marshaled across threads and processes
        IDispatch          *m_pdispConfigObject;  // Config object passed to MMCPropertySheet.AddWizardPage, marshaled across threads and processes
        VARIANT             m_varInitData;        // MMCPropertySheet::AddPage's InitData param
        BOOL                m_fNeedToRemoveHook;  // TRUE=MSGFILTER hook is installed
        BOOL                m_fIsRemote;          // TRUE=running in MMC remotely from VB during debugging session

        static const UINT CPropertyPageWrapper::m_RedrawMsg; // Message posted during WM_PAINT to generate a repaint when running under the debugger

        static const UINT CPropertyPageWrapper::m_InitMsg; // Message posted during WM_INITDIALOG so that IMMCPropertyPage_Initialize can be called

        static DLGTEMPLATE m_BaseDlgTemplate;     // Template used to create all dialog templates
};


DEFINE_AUTOMATIONOBJECTWEVENTS2(PropertyPageWrapper,    // name
                                NULL,                   // clsid
                                NULL,                   // objname
                                NULL,                   // lblname
                                NULL,                   // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_IUnknown,          // dispatch IID
                                NULL,                   // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe



#endif _PPGWRAP_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ocxvdefs.h ===
//=--------------------------------------------------------------------------=
// ocxvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _OCXVIEWDEFS_DEFINED_
#define _OCXVIEWDEFS_DEFINED_

#define MASTER_COLLECTION
#include "collect.h"

class COCXViewDefs : public CSnapInCollection<IOCXViewDef, OCXViewDef, IOCXViewDefs>,
                     public CPersistence
{
    protected:
        COCXViewDefs(IUnknown *punkOuter);
        ~COCXViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(OCXViewDefs,           // name
                                &CLSID_OCXViewDefs,    // clsid
                                "OCXViewDefs",         // objname
                                "OCXViewDefs",         // lblname
                                &COCXViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,    // major version
                                TLIB_VERSION_MINOR,    // minor version
                                &IID_IOCXViewDefs,     // dispatch IID
                                NULL,                  // no events IID
                                HELP_FILENAME,         // help file
                                TRUE);                 // thread safe


#endif // _OCXVIEWDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\ppgwrap.cpp ===
//=--------------------------------------------------------------------------=
// ppgwrap.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertyPageWrapper class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "ppgwrap.h"
#include "tls.h"

// for ASSERT and FAIL
//
SZTHISFILE

const UINT CPropertyPageWrapper::m_RedrawMsg = ::RegisterWindowMessage("Microsoft Visual Basic Snap-in Designer Property Page Redraw Message");
const UINT CPropertyPageWrapper::m_InitMsg = ::RegisterWindowMessage("Microsoft Visual Basic Snap-in Designer Property Page Init Message");
   
DLGTEMPLATE CPropertyPageWrapper::m_BaseDlgTemplate =
{
    WS_TABSTOP | WS_CHILD | DS_CONTROL, // DWORD style;
    WS_EX_CONTROLPARENT,                // DWORD dwExtendedStyle;
    0,          // WORD cdit; - no controls in this dialog box
    0,          // short x; dimensions are set per IPropertyPage::GetPageInfo()
    0,          // short y;
    0,          // short cx;
    0           // short cy;
};

#define MAX_DLGS 128

// Definition of data stored in TLS for each thread that displays property pages

typedef struct
{
    HHOOK                 hHook;        // HHOOK for this thread
    UINT                  cPages;       // number of existing property pages
    CPropertyPageWrapper *ppgActive;    // ptr to the currently active page
} TLSDATA;


// These resource IDs are taken from \nt\private\shell\comctl32\rcids.h.
// We need to know the IDs of the Back, Next and Finish buttons on a wizard
// or else we can't make tabbing work. This is a nasty dependency but there is
// no other way to handle this.

#define IDD_BACK		0x3023
#define IDD_NEXT		0x3024
#define IDD_FINISH		0x3025


#pragma warning(disable:4355)  // using 'this' in constructor

CPropertyPageWrapper::CPropertyPageWrapper(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_PROPERTYPAGEWRAPPER,
                           static_cast<IPropertyPageSite *>(this),
                           static_cast<CPropertyPageWrapper *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CPropertyPageWrapper::Create(IUnknown *punkOuter)
{
    HRESULT        hr = S_OK;
    CPropertyPageWrapper *pPropertyPage = New CPropertyPageWrapper(punkOuter);

    if (NULL == pPropertyPage)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if ( (0 == m_RedrawMsg) || (0 == m_InitMsg) )
    {
        hr = SID_E_SYSTEM_ERROR;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pPropertyPage)
        {
            delete pPropertyPage;
        }
        return NULL;
    }
    else
    {
        return pPropertyPage->PrivateUnknown();
    }
}

CPropertyPageWrapper::~CPropertyPageWrapper()
{
    ULONG     i = 0;
    IUnknown *punkObject = NULL; // Don't Release

    // Remove this dialog from the message hook TLS data. If there are
    // no more dialogs remaining then remove the hook. This should have happened
    // in OnDestroy during WM_DESTROY processing but just in case we double
    // check here.

    (void)RemoveMsgFilterHook();

    if (NULL != m_pPropertySheet)
    {
        m_pPropertySheet->Release();
    }

    if (NULL != m_pTemplate)
    {
        ::CtlFree(m_pTemplate);
    }

    // If the marshaling streams are still alive then we need to release
    // the marshal data. The easiest way to do this is to simply unmarshal
    // the interface pointer. We do this before releasing the held pointers
    // below. This case is actually not that rare because it can easily occur
    // if the user displays a multi-page property sheet and doesn't click
    // on all the tabs. In that case, the streams were created before the
    // pages were created but as no WM_INITDIALOG was received, they were
    // never unmarshaled. This can also occur in a wizard where the user
    // clicks cancel before visiting all of the pages in the wizard.

    if (NULL != m_apiObjectStreams)
    {
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != m_apiObjectStreams[i])
            {
                (void)::CoGetInterfaceAndReleaseStream(
                                        m_apiObjectStreams[i],
                                        IID_IUnknown,
                                        reinterpret_cast<void **>(&punkObject));
                m_apiObjectStreams[i] = NULL;
                RELEASE(punkObject);
            }
        }
        CtlFree(m_apiObjectStreams);
    }
    
    if (NULL != m_piSnapInStream)
    {
        (void)::CoGetInterfaceAndReleaseStream(m_piSnapInStream,
                                               IID_ISnapIn,
                                        reinterpret_cast<void **>(&m_piSnapIn));
        m_piSnapInStream = NULL;
    }

    if ( ISPRESENT(m_varInitData) && (NULL != m_piInitDataStream) )
    {
        if (VT_UNKNOWN == m_varInitData.vt)
        {
            m_varInitData.punkVal = NULL;
            (void)::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                                                   IID_IUnknown,
                             reinterpret_cast<void **>(&m_varInitData.punkVal));
        }
        else if (VT_DISPATCH == m_varInitData.vt)
        {
            m_varInitData.pdispVal = NULL;
            (void)::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                                                   IID_IDispatch,
                            reinterpret_cast<void **>(&m_varInitData.pdispVal));
        }
        m_piInitDataStream = NULL;
    }

    if (NULL != m_piMMCPropertySheetStream)
    {
        (void)::CoGetInterfaceAndReleaseStream(m_piMMCPropertySheetStream,
                                               IID_IMMCPropertySheet,
                              reinterpret_cast<void **>(&m_piMMCPropertySheet));
        m_piMMCPropertySheetStream = NULL;
    }

    RELEASE(m_piSnapIn);
    RELEASE(m_pdispConfigObject);
    RELEASE(m_piPropertyPage);
    RELEASE(m_piMMCPropertyPage);
    RELEASE(m_piMMCPropertySheet);
    RELEASE(m_piWizardPage);

    (void)::VariantClear(&m_varInitData);

    InitMemberVariables();
}



void CPropertyPageWrapper::InitMemberVariables()
{
    m_pPropertySheet = NULL;
    m_piPropertyPage = NULL;
    m_piMMCPropertyPage = NULL;
    m_piMMCPropertySheet = NULL;
    m_piWizardPage = NULL;
    m_fWizard = FALSE;
    m_cObjects = 0;
    m_apiObjectStreams = NULL;
    m_piSnapInStream = NULL;
    m_piInitDataStream = NULL;
    m_piMMCPropertySheetStream = NULL;
    m_piSnapIn = NULL;
    m_pdispConfigObject = NULL;
    m_pTemplate = NULL;
    m_hwndDlg = NULL;
    m_hwndSheet = NULL;
    m_clsidPage = CLSID_NULL;
    ::VariantInit(&m_varInitData);
    m_fIsRemote = FALSE;
    m_fNeedToRemoveHook = FALSE;
}



HRESULT CPropertyPageWrapper::CreatePage
(
    CPropertySheet  *pPropertySheet,
    CLSID            clsidPage,
    BOOL             fWizard,
    BOOL             fConfigWizard,
    ULONG            cObjects,
    IUnknown       **apunkObjects,
    ISnapIn         *piSnapIn,
    short            cxPage,
    short            cyPage,
    VARIANT          varInitData,
    BOOL             fIsRemote,
    DLGTEMPLATE    **ppTemplate
)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;

    // AddRef and store the owning property sheet pointer

    if (NULL != m_pPropertySheet)
    {
        m_pPropertySheet->Release();
    }
    if (NULL == pPropertySheet)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    pPropertySheet->AddRef();
    m_pPropertySheet = pPropertySheet;

    m_fWizard = fWizard;
    m_fConfigWizard = fConfigWizard;
    m_fIsRemote = fIsRemote;

    // Store the page's CLSID so that OnInitDialog() will have access to it
    // to create the real instance of the page. We cannot create the real
    // instance here because we are not running in the thread that will be used
    // for the property sheet. MMC will run the property sheet in a new thread
    // that it will create in order to keep it modeless and so that it will not
    // affect the console.

    m_clsidPage = clsidPage;

    // Create the dialog template and initialize it with common values

    m_pTemplate = (DLGTEMPLATE *)::CtlAllocZero(sizeof(m_BaseDlgTemplate) +
                                 (3 * sizeof(int))); // for menu, class, title

    if (NULL == m_pTemplate)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(m_pTemplate, &m_BaseDlgTemplate, sizeof(*m_pTemplate));

    m_pTemplate->cx = cxPage;
    m_pTemplate->cy = cyPage;

    // If this is a wizard then we have the ISnapIn so we can fire
    // ConfigurationComplete. Marshal the interface into a stream
    // and save the stream so that we can unmarshal it when the page is
    // created in MMC's property sheet thread. The returned IStream is free
    // threaded and can be kept in a member variable.

    if (NULL != piSnapIn)
    {
        hr = ::CoMarshalInterThreadInterfaceInStream(IID_ISnapIn,
                                                     piSnapIn,
                                                     &m_piSnapInStream);
        EXCEPTION_CHECK_GO(hr);
    }

    // Also need to marhshal the IMMCPropertySheet pointer that will be
    // passed to IMMCPropertyPage::Initialize as that call will occur during
    // WM_INITDIALOG which happens in MMC's property sheet thread.

    if (NULL != pPropertySheet)
    {
        hr = ::CoMarshalInterThreadInterfaceInStream(IID_IMMCPropertySheet,
                               static_cast<IMMCPropertySheet *>(pPropertySheet),
                               &m_piMMCPropertySheetStream);
        EXCEPTION_CHECK_GO(hr);
    }

    // Add a ref to ourselves. We need to do this because otherwise no one
    // else can be depended on to keep this object alive until the Win32
    // property page is created by MMC's PropertSheet() call.

    ExternalAddRef();

    // Marshal the objects' IUnknown pointers into streams. The returned
    // IStreams are free threaded and can be kept in a member variable.
    //
    // When the dialog is created, each IUnknown will be unmarshalled and passed
    // to the property page in IPropertyPage::SetObjects().
    //
    // We check for NULL because the object may have come from an
    // IPropertySheet:AddWizardPage() which allows the VB dev to specify the
    // object.

    IfFalseGo(NULL != apunkObjects, S_OK);

    m_apiObjectStreams = (IStream **)CtlAllocZero(cObjects * sizeof(IStream *));
    if (NULL == m_apiObjectStreams)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    m_cObjects = cObjects;

    for (i = 0; i < cObjects; i++)
    {
        hr = ::CoMarshalInterThreadInterfaceInStream(IID_IUnknown,
                                                     apunkObjects[i],
                                                     &m_apiObjectStreams[i]);
        EXCEPTION_CHECK_GO(hr);
    }

    // If there is an object in InitData then it also needs to be marshaled.

    if (VT_UNKNOWN == varInitData.vt)
    {
        m_varInitData.vt = VT_UNKNOWN;
        m_varInitData.punkVal = NULL;

        hr = ::CoMarshalInterThreadInterfaceInStream(IID_IUnknown,
                                                     varInitData.punkVal,
                                                     &m_piInitDataStream);
        EXCEPTION_CHECK_GO(hr);
    }
    else if (VT_DISPATCH == varInitData.vt)
    {
        m_varInitData.vt = VT_DISPATCH;
        m_varInitData.punkVal = NULL;

        hr = ::CoMarshalInterThreadInterfaceInStream(IID_IDispatch,
                                                     varInitData.pdispVal,
                                                     &m_piInitDataStream);
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        hr = ::VariantCopy(&m_varInitData, &varInitData);
        EXCEPTION_CHECK_GO(hr);
    }

Error:

    // We return the DLGTEMPLATE pointer to the caller even though we own it.
    // The caller must only use it as long as we are alive.
    
    *ppTemplate = m_pTemplate;

    RRETURN(hr);
}




BOOL CALLBACK CPropertyPageWrapper::DialogProc
(
    HWND   hwndDlg,
    UINT   uiMsg,
    WPARAM wParam,
    LPARAM lParam
)
{

    HRESULT               hr = S_OK;
    BOOL                  fDlgProcRet = FALSE;
    CPropertyPageWrapper *pPropertyPageWrapper = NULL;
    NMHDR                *pnmhdr = NULL;
    LRESULT               lresult = 0;

    if (WM_INITDIALOG == uiMsg)
    {
        if (NULL != hwndDlg)
        {
            fDlgProcRet = FALSE; // System should not set focus to any control

            // Get this pointer of CPropertyPageWrapper instance managing this
            // dialog. For property pages, lParam is a pointer to the
            // PROPSHEETPAGE used to define this page. The code in
            // CPropertySheet::AddPage put our this pointer into
            // PROPSHEETPAGE.lParam.

            PROPSHEETPAGE *pPropSheetPage =
                                       reinterpret_cast<PROPSHEETPAGE *>(lParam);
            pPropertyPageWrapper =
                reinterpret_cast<CPropertyPageWrapper *>(pPropSheetPage->lParam);

            IfFailGo(pPropertyPageWrapper->OnInitDialog(hwndDlg));

            // Post ourselves a message so that we can initialize the page
            // after the dialog creation has completed.
            
            (void)::PostMessage(hwndDlg, m_InitMsg, 0, 0);
        }
    }
    else if (m_RedrawMsg == uiMsg)
    {
        // See comment for WM_ERASEBKGND below. We don't really have access to
        // the property page's HWND because IPropertyPage does not allow that.
        // We do know that our dialog window contains no controls and we set it
        // as the parent of the property page so it must be our only child.
        // Generate an immediate redraw for the entire area of our child and all
        // of its children. Cancel any pending WM_ERASEBKGND messages by
        // specifying RDW_NOERASE.

        fDlgProcRet = TRUE;
        ::RedrawWindow(::GetWindow(hwndDlg, GW_CHILD), NULL, NULL,
                 RDW_INVALIDATE | RDW_NOERASE | RDW_UPDATENOW | RDW_ALLCHILDREN);
    }
    else
    {
        pPropertyPageWrapper = reinterpret_cast<CPropertyPageWrapper *>(
                                             ::GetWindowLong(hwndDlg, DWL_USER));
        IfFalseGo(NULL != pPropertyPageWrapper, SID_E_INTERNAL);

        if (m_InitMsg == uiMsg)
        {
            IfFailGo(pPropertyPageWrapper->OnInitMsg());
            goto Cleanup;
        }

        switch (uiMsg)
        {
            case WM_ERASEBKGND:
            {
                // Under a debug session property pages are erased and never
                // redrawn for some unknown reason. After much hair-pulling it
                // was determined that the work-around is to post ourselves a
                // message and force a redraw when that message is processed.

                (void)::PostMessage(hwndDlg, m_RedrawMsg, 0, 0);
            }
            break;

            case WM_SIZE:
            {
                fDlgProcRet = TRUE;
                IfFailGo(pPropertyPageWrapper->OnSize());
            }
            break;
            
            case WM_DESTROY:
            {
                fDlgProcRet = TRUE;
                IfFailGo(pPropertyPageWrapper->OnDestroy());
            }
            break;

            // Pass all CTLCOLOR messages to parent. This is what
            // OLE property frame does.

            case WM_CTLCOLORMSGBOX:
            case WM_CTLCOLOREDIT:
            case WM_CTLCOLORLISTBOX:
            case WM_CTLCOLORBTN:
            case WM_CTLCOLORDLG:
            case WM_CTLCOLORSCROLLBAR:
            case WM_CTLCOLORSTATIC:
            {
                fDlgProcRet = TRUE;
                ::SendMessage(::GetParent(hwndDlg), uiMsg, wParam, lParam);
            }
            break;

            case WM_NOTIFY:
            {
                pnmhdr = reinterpret_cast<NMHDR *>(lParam);
                IfFalseGo(NULL != pnmhdr, SID_E_SYSTEM_ERROR);

                // Check that the message is from the property sheet

                IfFalseGo(pnmhdr->hwndFrom == pPropertyPageWrapper->m_hwndSheet, S_OK);

                // Branch out to the appropriate handler

                switch (pnmhdr->code)
                {
                    case PSN_APPLY:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnApply(&lresult));
                        break;

                    case PSN_SETACTIVE:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnSetActive(
                                       ((PSHNOTIFY *)lParam)->hdr.hwndFrom, &lresult));
                        break;

                    case PSN_KILLACTIVE:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnKillActive(&lresult));
                        break;

                    case PSN_WIZBACK:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnWizBack(&lresult));
                        break;

                    case PSN_WIZNEXT:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnWizNext(&lresult));
                        break;

                    case PSN_WIZFINISH:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnWizFinish(&lresult));
                        break;

                    case PSN_QUERYCANCEL:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnQueryCancel(&lresult));
                        break;

                    case PSN_RESET:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnReset((BOOL)(((PSHNOTIFY *)lParam)->lParam)));
                        break;

                    case PSN_HELP:
                        fDlgProcRet = TRUE;
                        IfFailGo(pPropertyPageWrapper->OnHelp());
                        break;

                } // switch (pnmhdr->code)

            } // WM_NOTIFY
            break;

        } // switch(uiMsg)

    } // not WM_INITDIALOG

Cleanup:
Error:
    (void)::SetWindowLong(hwndDlg, DWL_MSGRESULT, static_cast<LONG>(lresult));
    return fDlgProcRet;
}


UINT CALLBACK CPropertyPageWrapper::PropSheetPageProc
(
    HWND hwnd,
    UINT uMsg,
    PROPSHEETPAGE *pPropSheetPage
)
{
    UINT uiRc = 0;

    if (PSPCB_CREATE == uMsg)
    {
        uiRc = 1; // allow the page to be created
    }
    else if (PSPCB_RELEASE == uMsg)
    {
        CPropertyPageWrapper *pPropertyPageWrapper =
               reinterpret_cast<CPropertyPageWrapper *>(pPropSheetPage->lParam);

        if (NULL != pPropertyPageWrapper)
        {
            // Release the ref on ourselves. This should result in this object
            // being destrotyed so do not reference any member variables after
            // this call

            pPropertyPageWrapper->ExternalRelease();
        }
    }
    return uiRc;
}



HRESULT CPropertyPageWrapper::OnInitDialog(HWND hwndDlg)
{
    HRESULT     hr = S_OK;
    IUnknown  **apunkObjects = NULL;
    ULONG       i = 0;
    IDispatch  *pdisp = NULL;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Store the hwnd and store our this pointer in the window words

    m_hwndDlg = hwndDlg;

    ::SetWindowLong(hwndDlg, DWL_USER, reinterpret_cast<LONG>(this));

    // Store the property sheet HWND. For now assume it is the parent of
    // the dialog. When we get PSN_SETACTIVE we'll update it with that value.
    // Technically we should not make this assumption but there is a ton of
    // Win32 code that does and we have no choice because we need the HWND
    // before PSN_SETACTIVE

    m_hwndSheet = ::GetParent(hwndDlg);

    // Give it to our owning CPropertySheet

    m_pPropertySheet->SetHWNDSheet(m_hwndSheet);

    // Create the page

    RELEASE(m_piPropertyPage); // should never be necessary, but just in case

    hr = ::CoCreateInstance(m_clsidPage,
                            NULL, // no aggregation,
                            CLSCTX_INPROC_SERVER,
                            IID_IPropertyPage,
                            reinterpret_cast<void **>(&m_piPropertyPage));
    EXCEPTION_CHECK_GO(hr);

    // Unmarshall the IMMCPropertySheet so we can pass it to 
    // IMMCPropertyPage::Initialize

    if (NULL != m_piMMCPropertySheetStream)
    {
        hr = ::CoGetInterfaceAndReleaseStream(m_piMMCPropertySheetStream,
                                              IID_IMMCPropertySheet,
                                              reinterpret_cast<void **>(&m_piMMCPropertySheet));
        m_piMMCPropertySheetStream = NULL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set this CPropertyPageWrapper object as the page site

    IfFailGo(m_piPropertyPage->SetPageSite(static_cast<IPropertyPageSite *>(this)));

    // Unmarshal the IUnknowns on the objects for which the page will be
    // displaying properties. This will also release the streams regardless of
    // whether it succeeds.

    if (NULL != m_apiObjectStreams)
    {
        apunkObjects = (IUnknown **)CtlAllocZero(m_cObjects * sizeof(IUnknown *));
        if (NULL == apunkObjects)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL == m_apiObjectStreams[i])
            {
                continue;
            }
            hr = ::CoGetInterfaceAndReleaseStream(
                m_apiObjectStreams[i],
                IID_IUnknown,
                reinterpret_cast<void **>(&apunkObjects[i]));
            m_apiObjectStreams[i] = NULL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // If this is a wizard then unmarshal the ISnapIn so we can fire
    // ConfigurationComplete.

    if (NULL != m_piSnapInStream)
    {
        hr = ::CoGetInterfaceAndReleaseStream(m_piSnapInStream,
                                              IID_ISnapIn,
                                              reinterpret_cast<void **>(&m_piSnapIn));
        m_piSnapInStream = NULL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Give the object to the page. Check for NULL because the snap-in
    // could have called PropertySheet.AddWizardPage passing Nothing
    // for its configuration object.

    if (NULL != apunkObjects)
    {
        IfFailGo(m_piPropertyPage->SetObjects(m_cObjects, apunkObjects));
    }

    // If this is a wizard then check whether the page supports our IWizardPage
    // interface. If it does not, that is not considered an error and it simply
    // won't get the next/back/finish etc. notifications.

    hr = m_piPropertyPage->QueryInterface(IID_IWizardPage,
                                    reinterpret_cast<void **>(&m_piWizardPage));
    if (FAILED(hr))
    {
        // Just to be extra sure, NULL our IWizardPage pointer
        m_piWizardPage = NULL;

        // If the error was anything other than E_NOINTERFACE then consider it
        // a real error.

        if (E_NOINTERFACE == hr)
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }
    else
    {
        // It should be a wizard. Store the object so we can pass it to the
        // snap-in when the Finish button is pressed (see OnWizFinish).
        if (NULL != apunkObjects)
        {
            if (NULL != apunkObjects[0])
            {
                IfFailGo(apunkObjects[0]->QueryInterface(IID_IDispatch,
                    reinterpret_cast<void **>(&m_pdispConfigObject)));
            }
        }
        else
        {
            m_pdispConfigObject = NULL;
        }
    }

    // Add the MSGFILTER hook so that we can call
    // IPropertyPage::TranslateAccelerator when the user hits a key in a control
    // on the page.

    IfFailGo(AddMsgFilterHook());

    // Activate the page and show it

    IfFailGo(ActivatePage());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    if (NULL != apunkObjects)
    {
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != apunkObjects[i])
            {
                apunkObjects[i]->Release();
            }
        }
        CtlFree(apunkObjects);
    }
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnInitMsg()
{
    HRESULT     hr = S_OK;

    // If the snap-in supports IMMCPropertyPage then call Initialize

    if (SUCCEEDED(m_piPropertyPage->QueryInterface(IID_IMMCPropertyPage,
                              reinterpret_cast<void **>(&m_piMMCPropertyPage))))
    {
        IfFailGo(InitPage());
    }
Error:
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::InitPage()
{
    HRESULT    hr = S_OK;

    VARIANT varProvider;
    ::VariantInit(&varProvider);

    // If the snap-in passed an object in the InitData parameter of
    // MMCPropertySheet.AddPage then unmarshal it.

    if (ISPRESENT(m_varInitData))
    {
        // If there is an object in InitData then it needs to be unmarshaled.

        if (VT_UNKNOWN == m_varInitData.vt)
        {
            m_varInitData.punkVal = NULL;
            hr = ::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                            IID_IUnknown,
                            reinterpret_cast<void **>(&m_varInitData.punkVal));
            m_piInitDataStream = NULL;
            EXCEPTION_CHECK_GO(hr);
        }
        else if (VT_DISPATCH == m_varInitData.vt)
        {
            m_varInitData.pdispVal = NULL;
            hr = ::CoGetInterfaceAndReleaseStream(m_piInitDataStream,
                            IID_IDispatch,
                            reinterpret_cast<void **>(&m_varInitData.pdispVal));
            m_piInitDataStream = NULL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // Call IMMCPropertyPage::Initialize
    
    IfFailGo(m_piMMCPropertyPage->Initialize(m_varInitData,
                   reinterpret_cast<MMCPropertySheet *>(m_piMMCPropertySheet)));

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::AddMsgFilterHook()
{
    HRESULT  hr = S_OK;
    TLSDATA *pTlsData = NULL;

    // If we are remote then don't install the hook. It doesn't work correctly
    // and there is no need to handle tabbing under the debugger.
    
    IfFalseGo(!m_fIsRemote, S_OK);

    // Check if TLS data is already there for this thread. If not there
    // then create it, add the hook, and set the TLS data. If it is there
    // then increment the ref count on the HHOOK.

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));

    if (NULL == pTlsData)
    {
        pTlsData = (TLSDATA *)CtlAllocZero(sizeof(TLSDATA));
        if (NULL == pTlsData)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        pTlsData->hHook = ::SetWindowsHookEx(WH_MSGFILTER,
                                             &MessageProc,
                                             GetResourceHandle(),
                                             ::GetCurrentThreadId());
        if (NULL == pTlsData->hHook)
        {
            CtlFree(pTlsData);
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if (FAILED(CTls::Set(TLS_SLOT_PPGWRAP, pTlsData)))
        {
            (void)::UnhookWindowsHookEx(pTlsData->hHook);
            CtlFree(pTlsData);
        }
    }

    // Increment the existing page count
    pTlsData->cPages++;

    m_fNeedToRemoveHook = TRUE;

Error:
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::RemoveMsgFilterHook()
{
    HRESULT  hr = S_OK;
    TLSDATA *pTlsData = NULL;
    UINT     i = 0;

    // If we already removed the hook then nothing to do

    IfFalseGo(m_fNeedToRemoveHook, S_OK);

    // Check if TLS data is already there for this thread. If it is,
    // then remove this dialog's hwnd from the TLS.

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));
    IfFalseGo(NULL != pTlsData, S_OK);

    pTlsData->cPages--;

    m_fNeedToRemoveHook = FALSE;

    // If there are no more existing pages then remove the hook and free the TLS

    if (0 == pTlsData->cPages)
    {
        if (NULL != pTlsData->hHook)
        {
            (void)::UnhookWindowsHookEx(pTlsData->hHook);
            pTlsData->hHook = NULL;
        }
        IfFailGo(CTls::Set(TLS_SLOT_PPGWRAP, NULL));
        CtlFree(pTlsData);
    }

Error:
    RRETURN(hr);
}


LRESULT CALLBACK CPropertyPageWrapper::MessageProc
(
    int code,       // hook code
    WPARAM wParam,  // not used
    LPARAM lParam   // message data
)
{
    HRESULT  hr = S_OK;
    LRESULT  lResult = 0; // default ret value is pass msg to wndproc
    MSG     *pMsg = reinterpret_cast<MSG *>(lParam);
    TLSDATA *pTlsData = NULL;
    HWND     hwndTab = NULL;
    HWND     hwndSheet = NULL;
    HWND     hwndBack = NULL;
    HWND     hwndNext = NULL;
    HWND     hwndFinish = NULL;
    HWND     hwndCancel = NULL;
    HWND     hwndHelp = NULL;
    BOOL     fTargetIsOnPage = FALSE;
    BOOL     fPassToPropertyPage = FALSE;

    // Get the TLS data in all cases because the HHOOK is in there and we need
    // that for CallNextHookEx.

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));

    // If input event did not occur in a dialog box then pass to CallNextHookEx

    IfFalseGo(code >= 0, S_OK);

    // If this is not a key down message then just pass to CallNextHookEx

    IfFalseGo( ((WM_KEYFIRST <= pMsg->message) && (WM_KEYLAST >= pMsg->message)), S_OK);

    // If there is no pointer to the active page in TLS then just pass to
    // CallNextHookeEx

    IfFalseGo(NULL != pTlsData, S_OK);
    IfFalseGo(NULL != pTlsData->ppgActive, S_OK);

    // Get the HWND of the tab control

    hwndSheet = pTlsData->ppgActive->m_hwndSheet;
    if (NULL != hwndSheet)
    {
        hwndTab = (HWND)::SendMessage(hwndSheet, PSM_GETTABCONTROL, 0, 0);
    }

    // Check if the target of the message is a decendant of the wrapper dialog
    // window. If so then it is a control on the VB property page.
    
    fTargetIsOnPage = ::IsChild(pTlsData->ppgActive->m_hwndDlg, pMsg->hwnd);

    // If a tab was hit outside of the page then in some cases we need to
    // let the page handle it.

    if ( (VK_TAB == pMsg->wParam) && (!fTargetIsOnPage) )
    {
        // If this is a back-tab
        if (::GetKeyState(VK_SHIFT) < 0)
        {
            // If the focus is on the OK button, let page handle shift-tab
            if (pMsg->hwnd == ::GetDlgItem(hwndSheet, IDOK))
            {
                fPassToPropertyPage = TRUE;
            }
            else if (pTlsData->ppgActive->m_fWizard)
            {
                // Determine which wizard buttons are enabled and handle
                // back tabs from the left-most enabled button.
                // Wizard buttons can be:
                // Back  | Next | Finish | Cancel | Help
                // The left-most enabled button could be Back, Next, Finish, or
                // Cancel
                // TODO: does this work on RTL locales such as Hebrew and Arabic?

                hwndBack = ::GetDlgItem(hwndSheet, IDD_BACK);
                hwndNext = ::GetDlgItem(hwndSheet, IDD_NEXT);
                hwndFinish = ::GetDlgItem(hwndSheet, IDD_FINISH);
                hwndCancel = ::GetDlgItem(hwndSheet, IDCANCEL);

                if (pMsg->hwnd == hwndBack)
                {
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndNext) &&
                          (!::IsWindowEnabled(hwndBack)) )
                {
                    // Back-tab is for Next button and Back button is disabled
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndFinish) &&
                          (!::IsWindowEnabled(hwndBack)) &&
                          (!::IsWindowEnabled(hwndNext)) )
                {
                    // Back-tab is for Finish button and Next and Back buttons
                    // are disabled
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndFinish) &&
                          (!::IsWindowEnabled(hwndBack)) &&
                          (!::IsWindowEnabled(hwndNext)) )
                {
                    // Back-tab is for Finish button and Next and Back buttons
                    // are disabled
                    fPassToPropertyPage = TRUE;
                }
            }
        }
        else // forward tab
        {
            // If the focus is on the tab control, let page handle tab
            if (hwndTab == pMsg->hwnd)
            {
                fPassToPropertyPage = TRUE;
            }
            else if (pTlsData->ppgActive->m_fWizard)
            {
                // Determine which wizard buttons are enabled and handle
                // back tabs from the right-most enabled button.
                // Wizard buttons can be:
                // Back  | Next | Finish | Cancel | Help
                // The right-most enabled button could be Cancel or Help
                // TODO: does this work on RTL locales such as Hebrew and Arabic?

                hwndCancel = ::GetDlgItem(hwndSheet, IDCANCEL);
                hwndHelp = ::GetDlgItem(hwndSheet, IDHELP);

                if (pMsg->hwnd == hwndHelp)
                {
                    fPassToPropertyPage = TRUE;
                }
                else if ( (pMsg->hwnd == hwndCancel) &&
                          ( (!::IsWindowEnabled(hwndHelp)) ||
                            (!::IsWindowVisible(hwndHelp)) )
                        )
                {
                    // Tab is for Cancel button and Help button is disabled
                    fPassToPropertyPage = TRUE;
                }
            }
        }
    }
    else if ( ( (VK_LEFT == pMsg->wParam) || (VK_RIGHT == pMsg->wParam) ||
                (VK_UP == pMsg->wParam)   || (VK_DOWN == pMsg->wParam)
              ) &&
              (!fTargetIsOnPage)
            )
    {
        fPassToPropertyPage = FALSE;
    }
    else // Not a tab, back-tab, or arrow key. Pass it to the page.
    {
        fPassToPropertyPage = TRUE;
    }

    if (fPassToPropertyPage)
    {
        if (S_OK == pTlsData->ppgActive->m_piPropertyPage->TranslateAccelerator(pMsg))
        {
            // Property page handled the key. Don't pass msg to wndproc
            // and to other hooks.
            lResult = (LRESULT)1;
        }
    }

Error:

    if ( (0 == lResult) && (NULL != pTlsData) )
    {
        // Pass the message to other hooks

        if (NULL != pTlsData->hHook)
        {
            lResult = ::CallNextHookEx(pTlsData->hHook, code, wParam, lParam);
        }
    }

    return lResult;
}


HRESULT CPropertyPageWrapper::ActivatePage()
{
    HRESULT  hr = S_OK;
    HWND     hwndPage = NULL;
    TLSDATA *pTlsData = NULL;
    HWND     hwndTab = NULL;
    HWND     hwndSheet = NULL;

    MSG msg;
    ::ZeroMemory(&msg, sizeof(msg));

    RECT rect;
    ::ZeroMemory(&rect, sizeof(rect));

    BYTE rgbKeys[256];
    ::ZeroMemory(rgbKeys, sizeof(rgbKeys));

    // Activate the property page.
    //
    // Use the dialog's hwnd as the parent.
    //
    // Set the rect to the dialog window's size
    //
    // Pass TRUE to indicate that the dialog box frame is modal. This is the
    // same way OleCreatePropertyFrame() and and OleCreatePropertyFrameIndirect()
    // work.

    GetClientRect(m_hwndDlg, &rect);

    IfFailGo(m_piPropertyPage->Activate(m_hwndDlg, &rect, TRUE));

    hwndPage = ::GetTopWindow(m_hwndDlg);
    if (NULL != hwndPage)
    {
        ::SetWindowLong(hwndPage, GWL_STYLE,
             ::GetWindowLong(hwndPage, GWL_STYLE) & ~(DS_CONTROL | WS_TABSTOP));
        ::SetWindowLong(hwndPage, GWL_EXSTYLE,
                 ::GetWindowLong(hwndPage, GWL_EXSTYLE) & ~WS_EX_CONTROLPARENT);
    }

    // Tell the page to show itself and set focus to the first property in its
    // tab order.

    IfFailGo(m_piPropertyPage->Show(SW_SHOW));

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));
    IfFalseGo(NULL != pTlsData, S_OK);

    pTlsData->ppgActive = this;

    // Fake a tab key to the property page so that the focus will move to
    // the first control in the page's tabbing order.

    // Ignore all return codes because if this doesn't work then it is not a
    // show-stopper. The user would simply have to tab to or click on the first
    // control.

    hwndTab = (HWND)::SendMessage(m_hwndSheet, PSM_GETTABCONTROL, 0, 0);
    IfFalseGo(NULL != hwndTab, S_OK);

    msg.hwnd = hwndTab;            // message intended for focused control
    msg.message = WM_KEYDOWN;      // key pressed
    msg.wParam = VK_TAB;           // tab key
    msg.lParam = 0x000F0001;       // tab key scan code with repeat count=1
    msg.time = ::GetTickCount();   // use current time
    (void)::GetCursorPos(&msg.pt); // use current cursor position

    // Make sure shift/ctrl/alt keys are not set, since property
    // pages will interpret the key wrong.

    (void)::GetKeyboardState(rgbKeys);
    rgbKeys[VK_SHIFT] &= 0x7F;      // remove hi bit (key down)
    rgbKeys[VK_CONTROL] &= 0x7F;    // remove hi bit (key down)
    rgbKeys[VK_MENU] &= 0x7F;       // remove hi bit (key down)
    (void)::SetKeyboardState(rgbKeys);

    (void)m_piPropertyPage->TranslateAccelerator(&msg);

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnSize()
{
    HRESULT   hr = S_OK;

    RECT rect;
    ::ZeroMemory(&rect, sizeof(rect));

    GetClientRect(m_hwndDlg, &rect);

    IfFailGo(m_piPropertyPage->Move(&rect));

Error:
    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnDestroy()
{
    HRESULT   hr = S_OK;
    IUnknown *punkThisObject = PrivateUnknown();

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Remove the selected objects. We should pass NULL here but in a debugging
    // session the proxy will return an error if we do. To get around this we
    // pass a pointer to our own IUnknown. VB will not do anything with it
    // because the object count is zero.

    IfFailGo(m_piPropertyPage->SetObjects(0, &punkThisObject));

    // Deactivate the property page.

    IfFailGo(m_piPropertyPage->Deactivate());

    // Set the site to NULL so it will remove its ref on us.

    IfFailGo(m_piPropertyPage->SetPageSite(NULL));

    // Release the property page

    RELEASE(m_piPropertyPage);

    // Remove this dialog from the message hook TLS data. If there are
    // no more dialogs remaining then remove the hook.
    
    IfFailGo(RemoveMsgFilterHook());
            
    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnApply(LRESULT *plresult)
{
    HRESULT hr = S_OK;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Tell the property page to apply its current values to the underlying
    // object.

    IfFailGo(m_piPropertyPage->Apply());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    if (FAILED(hr))
    {
        *plresult = PSNRET_INVALID_NOCHANGEPAGE;
    }
    else
    {
        *plresult = PSNRET_NOERROR;
    }
    RRETURN(hr);
}




HRESULT CPropertyPageWrapper::OnSetActive(HWND hwndSheet, LRESULT *plresult)
{
    HRESULT                    hr = S_OK;
    long                       lNextPage = 0;
    WizardPageButtonConstants  NextOrFinish = EnabledNextButton;
    VARIANT_BOOL               fvarEnableBack = VARIANT_TRUE;
    BSTR                       bstrFinishText = NULL;
    DWORD                      dwFlags = 0;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // Store the property sheet's HWND and give it to our owning CPropertySheet

    m_hwndSheet = hwndSheet;
    m_pPropertySheet->SetHWNDSheet(m_hwndSheet);

    // If the page is in a wizard then set the wizard buttons

    if (m_fWizard && (NULL != m_piWizardPage))
    {
        IfFailGo(m_piWizardPage->Activate(&fvarEnableBack,
                                          &NextOrFinish,
                                          &bstrFinishText));

        IfFailGo(m_pPropertySheet->SetWizardButtons(fvarEnableBack,
                                                    NextOrFinish));
        if (NULL != bstrFinishText)
        {
            IfFailGo(m_pPropertySheet->SetFinishButtonText(bstrFinishText));
        }
    }

    // Activate the page and show it

    IfFailGo(ActivatePage());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    FREESTRING(bstrFinishText);

    if (FAILED(hr))
    {
        // If anything failed then don't allow the operation.
        lNextPage = -1L;
    }

    *plresult = static_cast<LRESULT>(lNextPage);

    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnKillActive(LRESULT *plresult)
{
    HRESULT  hr = S_OK;
    TLSDATA *pTlsData = NULL;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    IfFailGo(CTls::Get(TLS_SLOT_PPGWRAP, reinterpret_cast<void **>(&pTlsData)));
    if (NULL != pTlsData)
    {
        pTlsData->ppgActive = NULL;
    }

    // Tell the property page to apply its current values to the underlying
    // object.

    IfFailGo(m_piPropertyPage->Apply());

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    if (FAILED(hr))
    {
        // Apply failed. Tell the property sheet to keep the page active

        *plresult = static_cast<LRESULT>(TRUE);
    }
    else
    {
        // Apply succeeded. Tell the property sheet it is OK to leave the page

        *plresult = static_cast<LRESULT>(FALSE);
    }
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnWizBack(LRESULT *plresult)
{
    HRESULT hr = S_OK;
    long    lNextPage = 0;

    // If the page doesn't support IWizardPage then allow the Back operation.

    IfFalseGo(NULL != m_piWizardPage, S_OK);

    IfFailGo(m_piWizardPage->Back(&lNextPage));

    if (0 < lNextPage)
    {
        // Page requested to move to another page. Get its DLGTEMPLATE pointer.
        IfFailGo(GetNextPage(&lNextPage));
    }

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Back operation.
        lNextPage = -1L;
    }

    *plresult = static_cast<LRESULT>(lNextPage);

    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnWizNext(LRESULT *plresult)
{
    HRESULT hr = S_OK;
    long    lNextPage = 0;

    // If the page doesn't support IWizardPage then allow the Next operation.

    IfFalseGo(NULL != m_piWizardPage, S_OK);

    IfFailGo(m_piWizardPage->Next(&lNextPage));

    if (0 < lNextPage)
    {
        // Page requested to move to another page. Get its DLGTEMPLATE pointer.
        IfFailGo(GetNextPage(&lNextPage));
    }

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Next operation.
        lNextPage = -1L;
    }

    *plresult = static_cast<LRESULT>(lNextPage);

    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnWizFinish(LRESULT *plresult)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarAllow = VARIANT_TRUE;

    // If the page doesn't support IWizardPage then allow the Finish operation.

    IfFalseGo(NULL != m_piWizardPage, S_OK);

    IfFailGo(m_piWizardPage->Finish(&fvarAllow));

    // If the finish is allowed and this is a configuration wizard then fire
    // SnapIn_ConfigurationComplete

    if ( (VARIANT_TRUE == fvarAllow) && (NULL != m_piSnapIn) && m_fConfigWizard)
    {
        IfFailGo(m_piSnapIn->FireConfigComplete(m_pdispConfigObject));
    }

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Finish operation.
        fvarAllow = VARIANT_FALSE;
    }
    else
    {
        if (VARIANT_TRUE == fvarAllow)
        {
            *plresult = 0; // Allow the property sheet to be destroyed
        }
        else
        {
            // Do not allow the property sheet to be destroyed
            *plresult = static_cast<LRESULT>(1);
        }
    }

    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnQueryCancel(LRESULT *plresult)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarAllow = VARIANT_TRUE;

    // If the page doesn't support IMMCPropertyPage then allow the Cancel
    // operation.

    IfFalseGo(NULL != m_piMMCPropertyPage, S_OK);

    IfFailGo(m_piMMCPropertyPage->QueryCancel(&fvarAllow));

Error:
    if (FAILED(hr))
    {
        // If anything failed then don't allow the Cancel operation.
        fvarAllow = VARIANT_FALSE;
    }
    else
    {
        if (VARIANT_TRUE == fvarAllow)
        {
             // Allow the cancel operation
            *plresult = static_cast<LRESULT>(FALSE);
        }
        else
        {
            // Do not allow the cancel operation
            *plresult = static_cast<LRESULT>(TRUE);
        }
    }

    RRETURN(hr);
}



HRESULT CPropertyPageWrapper::OnReset(BOOL fClickedXButton)
{
    HRESULT hr = S_OK;

    m_pPropertySheet->SetOKToAlterPageCount(FALSE);

    // If the page doesn't support IMMCPropertyPage then ignore this notification

    IfFalseGo(NULL != m_piMMCPropertyPage, S_OK);

    if (fClickedXButton)
    {
        IfFailGo(m_piMMCPropertyPage->Close());
    }
    else
    {
        IfFailGo(m_piMMCPropertyPage->Cancel());
    }

    m_pPropertySheet->SetOKToAlterPageCount(TRUE);

Error:
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::OnHelp()
{
    HRESULT hr = S_OK;
    
    // If the property page implements IMMCPropertyPage then call the Help
    // method otherwise call IPropertyPage::Help()

    if (NULL != m_piMMCPropertyPage)
    {
        hr = m_piMMCPropertyPage->Help();
    }
    else
    {
        // Call IPropertyPage::Help() on the page. We don't pass the help dir
        // because VB doesn't register it and it doesn't use it. See the VB
        // source in vbdev\ruby\deskpage.cpp, DESKPAGE::Help().
    
        hr = m_piPropertyPage->Help(NULL);
    }
    RRETURN(hr);
}


HRESULT CPropertyPageWrapper::GetNextPage(long *lNextPage)
{
    HRESULT      hr = S_OK;
    DLGTEMPLATE *pDlgTemplate = NULL;

    IfFalseGo(NULL != m_pPropertySheet, SID_E_INTERNAL);

    // The property sheet has the array of DLGTEMPLATE pointers. Ask it
    // for the one corresponding to the requested page.

    IfFailGo(m_pPropertySheet->GetTemplate(*lNextPage, &pDlgTemplate));
    *lNextPage = reinterpret_cast<long>(pDlgTemplate);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      IPropertyPageSite Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CPropertyPageWrapper::OnStatusChange(DWORD dwFlags)
{
    if ( PROPPAGESTATUS_DIRTY == (dwFlags & PROPPAGESTATUS_DIRTY) )
    {
        // Enables the apply button

        ::SendMessage(m_hwndSheet, PSM_CHANGED, (WPARAM)m_hwndDlg, 0);
    }
    else
    {
        // Disables the apply button. Occurs when page has returned to original
        // state. In a VB page, would set Changed = False.

        ::SendMessage(m_hwndSheet, PSM_UNCHANGED, (WPARAM)m_hwndDlg, 0);
    }
    return S_OK;
}

STDMETHODIMP CPropertyPageWrapper::GetLocaleID(LCID *pLocaleID)
{
    *pLocaleID = GetSystemDefaultLCID();
    RRETURN((0 == *pLocaleID) ? E_FAIL : S_OK);
}


STDMETHODIMP CPropertyPageWrapper::GetPageContainer(IUnknown **ppunkContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPropertyPageWrapper::TranslateAccelerator(MSG *pMsg)
{
    return S_FALSE;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CPropertyPageWrapper::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IPropertyPageSite == riid)
    {
        *ppvObjOut = static_cast<IPropertyPageSite *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpchars.h ===
//=--------------------------------------------------------------------------=
// prpchars.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Header for exported function GetPropSheetCharSizes() used by both
// design tiem and runtime when converting dialog units to pixels.
//
//=--------------------------------------------------------------------------=

#if defined(MSSNAPR_BUILD)
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT __declspec(dllimport)
#endif

// Returns the average width and height of a character in the font used by
// Win32 property sheets.

HRESULT DLLEXPORT GetPropSheetCharSizes
(
    UINT *pcxPropSheetChar,
    UINT *pcyPropSheetChar
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\persobj.cpp ===
//=--------------------------------------------------------------------------=
// persobj.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPersistence class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "error.h"

// for ASSERT and FAIL
//
SZTHISFILE


CPersistence::CPersistence
(
    const CLSID *pClsid,
          DWORD  dwVerMajor,
          DWORD  dwVerMinor
)
{
    InitMemberVariables();
    m_dwVerMajor = dwVerMajor;
    m_dwVerMinor = dwVerMinor;
    m_Clsid = *pClsid;
}

CPersistence::~CPersistence()
{
    InitMemberVariables();
}

void CPersistence::InitMemberVariables()
{
    m_fDirty = FALSE;
    m_fClearDirty = FALSE;
    m_fLoading = FALSE;
    m_fSaving = FALSE;
    m_fInitNew = FALSE;
    m_fStream = FALSE;
    m_fPropertyBag = FALSE;
    m_piStream = NULL;
    m_piPropertyBag = NULL;
    m_piErrorLog = NULL;
    m_Clsid = GUID_NULL;
}



HRESULT CPersistence::QueryPersistenceInterface
(
    REFIID   riid,
    void   **ppvInterface
)
{
    HRESULT hr = S_OK;

    if (IID_IPersistStreamInit == riid)
    {
        *ppvInterface = static_cast<IPersistStreamInit *>(this);
    }
    else if (IID_IPersistStream == riid)
    {
        *ppvInterface = static_cast<IPersistStream *>(this);
    }
    else if (IID_IPersistPropertyBag == riid)
    {
        *ppvInterface = static_cast<IPersistPropertyBag *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}


HRESULT CPersistence::Persist()
{
    DWORD   dwVerMajor = 0;
    DWORD   dwVerMinor = 0;
    HRESULT hr         = S_OK;

    static LPCOLESTR pszMajorVersion = OLESTR("Persistence.MajorVersion");
    static LPCOLESTR pszMinorVersion = OLESTR("Persistence.MinorVersion");

    // When loading do a version check. The major versions must be equal. The
    // minor version must be lower or equal. This means that we maintain
    // backward compatibility with prior minor versions only (e.g. a 1.1
    // designer can read the 1.0 format but not vice-versa). Objects that need
    // to load a prior version must check the version when loading and load only
    // the appropriate properties. To see examples of objects that do this grep
    // the source code for "GetMinorVersion()".

    if (m_fLoading)
    {
        IfFailGo(PersistSimpleType(&dwVerMajor, m_dwVerMajor, pszMajorVersion));

        IfFailGo(PersistSimpleType(&dwVerMinor, m_dwVerMinor, pszMinorVersion));

        IfFalseGo(dwVerMajor == m_dwVerMajor, SID_E_UNKNOWNFORMAT);
        m_dwVerMajor = dwVerMajor;

        IfFalseGo(dwVerMinor <= m_dwVerMinor, SID_E_UNKNOWNFORMAT);
        m_dwVerMinor = dwVerMinor;
    }
    else if (m_fSaving)
    {
        // Always save using the version numbers we compiled with (in persobj.h).
        // This means that loading an older project and then saving it
        // automatically upgrades it to the current version. Objects should
        // always save their state using the current version of their properties.

        dwVerMajor = g_dwVerMajor;
        dwVerMinor = g_dwVerMinor;
        
        IfFailGo(PersistSimpleType(&dwVerMajor, g_dwVerMajor, pszMajorVersion));

        IfFailGo(PersistSimpleType(&dwVerMinor, g_dwVerMinor, pszMinorVersion));
    }

Error:
    if (SID_E_UNKNOWNFORMAT == hr)
    {
        GLOBAL_EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}


HRESULT CPersistence::PersistBstr
(
    BSTR      *pbstrValue,
    WCHAR     *pwszDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;
    BSTR     bstrValue = NULL;
    BSTR     bstrEmpty = NULL;
    WCHAR   *pwszBstr = NULL;
    ULONG    cbBstr = 0;
    VARIANT  varBstr;
    ::VariantInit(&varBstr);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            if (NULL != *pbstrValue)
            {
                // Get the byte length excluding the terminating null
                cbBstr = (ULONG)::SysStringByteLen(*pbstrValue);
            }
            else
            {
                cbBstr = 0;
            }
            IfFailRet(WriteToStream(&cbBstr, sizeof(cbBstr)));
            if (0 != cbBstr)
            {
                IfFailRet(WriteToStream(*pbstrValue, cbBstr));
            }
        }
        else if (m_fPropertyBag)
        {
            varBstr.vt = VT_BSTR;
            if (NULL == *pbstrValue)
            {
                bstrEmpty = ::SysAllocString(L"");
                if (NULL == bstrEmpty)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
                varBstr.bstrVal = bstrEmpty;
            }
            else
            {
                varBstr.bstrVal = *pbstrValue;
            }
            hr = m_piPropertyBag->Write(pwszName, &varBstr);
            IfFailGo(hr);
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailRet(ReadFromStream(&cbBstr, sizeof(cbBstr)));
            if (0 == cbBstr)
            {
                bstrValue = ::SysAllocString(L"");
                if (NULL == bstrValue)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
            }
            else
            {
                // Allocate the total byte length + room for a null character
                pwszBstr = (WCHAR *)::CtlAllocZero(cbBstr + sizeof(*pwszBstr));
                if (NULL == pwszBstr)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
                IfFailGo(ReadFromStream(pwszBstr, cbBstr));

                // We create the null terminated string in the buffer and
                // then use SysAllocString() rather than using SysAllocStringLen()
                // so that SysStringLen() will return the number of characters
                // not including the terminating null. After allocating with
                // SysAllocStringLen() the value returned by SysStringLen() will
                // include the terminating null.

                bstrValue = ::SysAllocString(pwszBstr);
                if (NULL == bstrValue)
                {
                    hr = SID_E_OUTOFMEMORY;
                    GLOBAL_EXCEPTION_CHECK_GO(hr);
                }
            }
            FREESTRING(*pbstrValue);
            *pbstrValue = bstrValue;
        }
        else if (m_fPropertyBag)
        {
            hr = m_piPropertyBag->Read(pwszName, &varBstr, m_piErrorLog);
            IfFailGo(hr);
            if ( (VT_BSTR != varBstr.vt) || (NULL == varBstr.bstrVal) )
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            FREESTRING(*pbstrValue);
            *pbstrValue = varBstr.bstrVal;
        }
    }
    else if (m_fInitNew)
    {

        bstrValue = ::SysAllocString(pwszDefaultValue);
        if (NULL == bstrValue)
        {
            hr = SID_E_OUTOFMEMORY;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        FREESTRING(*pbstrValue);
        *pbstrValue = bstrValue;
    }

Error:
    if (FAILED(hr))
    {
        (void)::VariantClear(&varBstr);
    }
    FREESTRING(bstrEmpty);
    if (NULL != pwszBstr)
    {
        ::CtlFree(pwszBstr);
    }
    RRETURN(hr);
}

HRESULT CPersistence::PersistDouble
(
    DOUBLE    *pdblValue,
    DOUBLE     dblDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;

    VARIANT var;
    ::VariantInit(&var);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(WriteToStream(pdblValue, sizeof(*pdblValue)));
        }
        else if (m_fPropertyBag)
        {
            var.vt = VT_R8;
            var.dblVal = *pdblValue;
            IfFailGo(m_piPropertyBag->Write(pwszName, &var));
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailGo(ReadFromStream(pdblValue, sizeof(*pdblValue)));
        }
        else if (m_fPropertyBag)
        {
            IfFailGo(m_piPropertyBag->Read(pwszName, &var, m_piErrorLog));
            if (VT_R8 != var.vt)
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            *pdblValue = var.dblVal;
        }
    }
    else if (m_fInitNew)
    {
        *pdblValue = dblDefaultValue;
    }

Error:
    RRETURN(hr);
}



HRESULT CPersistence::PersistDate
(
    DATE      *pdtValue,
    DATE       dtDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;

    VARIANT var;
    ::VariantInit(&var);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(WriteToStream(pdtValue, sizeof(*pdtValue)));
        }
        else if (m_fPropertyBag)
        {
            var.vt = VT_DATE;
            var.date = *pdtValue;
            IfFailGo(m_piPropertyBag->Write(pwszName, &var));
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailGo(ReadFromStream(pdtValue, sizeof(*pdtValue)));
        }
        else if (m_fPropertyBag)
        {
            IfFailGo(m_piPropertyBag->Read(pwszName, &var, m_piErrorLog));
            if (VT_DATE != var.vt)
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            *pdtValue = var.date;
        }
    }
    else if (m_fInitNew)
    {
        *pdtValue = dtDefaultValue;
    }

Error:
    RRETURN(hr);
}


HRESULT CPersistence::PersistCurrency
(
    CURRENCY  *pcyValue,
    CURRENCY   cyDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;

    VARIANT var;
    ::VariantInit(&var);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(WriteToStream(pcyValue, sizeof(*pcyValue)));
        }
        else if (m_fPropertyBag)
        {
            var.vt = VT_DATE;
            var.cyVal = *pcyValue;
            IfFailGo(m_piPropertyBag->Write(pwszName, &var));
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailGo(ReadFromStream(pcyValue, sizeof(*pcyValue)));
        }
        else if (m_fPropertyBag)
        {
            IfFailGo(m_piPropertyBag->Read(pwszName, &var, m_piErrorLog));
            if (VT_DATE != var.vt)
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            *pcyValue = var.cyVal;
        }
    }
    else if (m_fInitNew)
    {
        *pcyValue = cyDefaultValue;
    }

Error:
    RRETURN(hr);
}


HRESULT CPersistence::WriteToStream
(
    void *pvBuffer,
    ULONG cbToWrite
)
{
    ULONG cbWritten = 0;
    HRESULT hr = m_piStream->Write(pvBuffer, cbToWrite, &cbWritten);
    GLOBAL_EXCEPTION_CHECK_GO(hr);
    if (cbWritten != cbToWrite)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK(hr);
    }
Error:
    RRETURN(hr);
}

HRESULT CPersistence::ReadFromStream
(
    void *pvBuffer,
    ULONG cbToRead
)
{
    ULONG cbRead = 0;
    HRESULT hr = m_piStream->Read(pvBuffer, cbToRead, &cbRead);
    GLOBAL_EXCEPTION_CHECK_GO(hr);
    if (cbRead != cbToRead)
    {
        hr = SID_E_INCOMPLETE_READ;
        GLOBAL_EXCEPTION_CHECK(hr);
    }
Error:
    RRETURN(hr);
}

HRESULT CPersistence::PersistVariant
(
    VARIANT   *pvarValue,
    VARIANT    varDefaultValue,
    LPCOLESTR  pwszName
)
{
    HRESULT  hr = S_OK;
    VARTYPE  vt = VT_EMPTY;

    VARIANT varNew;
    ::VariantInit(&varNew);

    if (m_fSaving)
    {
        if (m_fStream)
        {
            IfFailRet(PersistSimpleType(&pvarValue->vt, vt, NULL));

            // If the VARIANT is empty then don't write its value to the stream
            IfFalseGo(VT_EMPTY != pvarValue->vt, S_OK);
            hr = StreamVariant(pvarValue->vt, pvarValue, varDefaultValue);
        }
        else if (m_fPropertyBag)
        {
            // If the VARIANT is empty then don't write it to the property bag
            IfFalseGo(VT_EMPTY != pvarValue->vt, S_OK);
            hr = m_piPropertyBag->Write(pwszName, pvarValue);
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            IfFailRet(PersistSimpleType(&vt, vt, NULL));

            // If the VARIANT is empty then don't read its value from the stream
            if (VT_EMPTY != vt)
            {
                IfFailRet(StreamVariant(vt, pvarValue, varDefaultValue));
            }
            pvarValue->vt = vt;
        }
        else if (m_fPropertyBag)
        {
            // If the property is not there then it is an empty VARIANT

            hr = m_piPropertyBag->Read(pwszName, &varNew, m_piErrorLog);
            if (E_INVALIDARG == hr)
            {
                // Property was not found, VARIANT must be empty. This could
                // also happen if the user hand edited the property in .DSR
                // file, deleted the .DCA file, and loaded the project.
                // varNew was already initialized to VT_EMPTY so the
                // VariantCopy() below will set the caller's VARIANT correctly.
                hr = S_OK;
            }
            IfFailGo(hr);
            hr = ::VariantCopy(pvarValue, &varNew);
            GLOBAL_EXCEPTION_CHECK(hr);
        }
    }
    else if (m_fInitNew)
    {
        hr = ::VariantCopy(pvarValue, &varDefaultValue);
        GLOBAL_EXCEPTION_CHECK(hr);
    }

Error:
    (void)::VariantClear(&varNew);
    RRETURN(hr);
}



HRESULT CPersistence::StreamVariant
(
    VARTYPE  vt,
    VARIANT *pvarValue,
    VARIANT  varDefaultValue
)
{
    HRESULT hr = S_OK;

    switch (vt)
    {
        case VT_I4:
            hr = PersistSimpleType(&pvarValue->lVal, varDefaultValue.lVal, NULL);
            break;

        case VT_UI1:
            hr = PersistSimpleType(&pvarValue->bVal, varDefaultValue.bVal, NULL);
            break;

        case VT_I2:
            hr = PersistSimpleType(&pvarValue->iVal, varDefaultValue.iVal, NULL);
            break;

        case VT_R4:
            hr = PersistSimpleType(&pvarValue->fltVal, varDefaultValue.fltVal, NULL);
            break;

        case VT_R8:
            hr = PersistDouble(&pvarValue->dblVal, varDefaultValue.dblVal, NULL);
            break;

        case VT_BOOL:
            hr = PersistSimpleType(&pvarValue->boolVal, varDefaultValue.boolVal, NULL);
            break;

        case VT_ERROR:
            hr = PersistSimpleType(&pvarValue->scode, varDefaultValue.scode, NULL);
            break;

        case VT_DATE:
            hr = PersistDate(&pvarValue->date, varDefaultValue.date, NULL);
            break;

        case VT_CY:
            hr = PersistCurrency(&pvarValue->cyVal, varDefaultValue.cyVal, NULL);
            break;

        case VT_BSTR:

            // If we are loading, there is no guarantee that the passed
            // VARIANT actually contains a BSTR. PersistBstr() will call
            // ::SysFreeString() on the current value of the property if
            // it is non-NULL. For a VARIANT initialized with ::VariantInit()
            // there could be junk in the bstrVal. So, we need to clear out
            // the VARIANT and set it to a VT_BSTR with a NULL bstrVal.

            if ( m_fLoading && (VT_BSTR != pvarValue->vt) )
            {
                hr = ::VariantClear(pvarValue);
                GLOBAL_EXCEPTION_CHECK_GO(hr);
                pvarValue->vt = VT_BSTR;
                pvarValue->bstrVal = NULL;
            }

            hr = PersistBstr(&pvarValue->bstrVal, varDefaultValue.bstrVal, NULL);
            break;

        case VT_UNKNOWN:
            hr = StreamObjectInVariant(&pvarValue->punkVal, IID_IUnknown);
            break;

        case VT_DISPATCH:
            hr = StreamObjectInVariant(
                            reinterpret_cast<IUnknown **>(&pvarValue->pdispVal),
                            IID_IDispatch);
            break;

        default:
            // We don't support any other types for VARIANT properties but this
            // is an internal programming error as the object should not have
            // allowed the property to be set to the unsupported type. Don't
            // return SID_E_INVALIDARG as it is not a user error.
            hr = SID_E_INTERNAL;
            GLOBAL_EXCEPTION_CHECK(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CPersistence::StreamObjectInVariant
(
    IUnknown **ppunkObject,
    REFIID     iidInterface
)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;
    IUnknown           *punkNewObject = NULL;
    CLSID               clsidObject = CLSID_NULL;

    if (m_fSaving)
    {
        if (NULL == *ppunkObject)
        {
            hr = SID_E_INVALID_VARIANT;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        hr = (*ppunkObject)->QueryInterface(IID_IPersistStreamInit,
                              reinterpret_cast<void **>(&piPersistStreamInit));
        if (FAILED(hr))
        {
            // If the object doesn't support IPersistStreamInit then change to
            // one of our errors that suggests checking the Persistable
            // property on VB implemented objects that might appear in a Tag
            // property.

            if (E_NOINTERFACE == hr)
            {
                hr = SID_E_OBJECT_NOT_PERSISTABLE;
            }
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        // Get the object's CLSID

        IfFailGo(piPersistStreamInit->GetClassID(&clsidObject));

        // We don't use OleSaveToStream() because it does not allow passing
        // the clear dirty flag

        hr = ::WriteClassStm(m_piStream, clsidObject);
        GLOBAL_EXCEPTION_CHECK_GO(hr);

        IfFailGo(piPersistStreamInit->Save(m_piStream, m_fClearDirty));
    }
    else if (m_fLoading)
    {
        // We can't use OleLoadFromStream() because we need some extra error
        // checking in case the object is not creatable. This would happen when
        // an object in a Tag property is VB implemented but not public and
        // creatable.

        // Load the CLSID

        hr = ::ReadClassStm(m_piStream, &clsidObject);
        GLOBAL_EXCEPTION_CHECK_GO(hr);

        // Create the object.
        
        hr = ::CoCreateInstance(clsidObject,
                                NULL, // no aggregation
                                CLSCTX_SERVER,
                                iidInterface,
                                reinterpret_cast<void **>(&punkNewObject));
        if (FAILED(hr))
        {
            // Translate "not registred" error to our own that suggests checking
            // the Instancing property on VB implemented objects.
            
            if (REGDB_E_CLASSNOTREG == hr)
            {
                hr = SID_E_OBJECT_NOT_PUBLIC_CREATABLE;
            }
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        // Attempt to load it from the stream.

        hr = punkNewObject->QueryInterface(IID_IPersistStreamInit,
                               reinterpret_cast<void **>(&piPersistStreamInit));
        if (FAILED(hr))
        {
            if (E_NOINTERFACE == hr)
            {
                hr = SID_E_OBJECT_NOT_PERSISTABLE;
            }
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(piPersistStreamInit->Load(m_piStream));

        QUICK_RELEASE(*ppunkObject);
        punkNewObject->AddRef();  // clean up below will call Release so add one
        *ppunkObject = punkNewObject;
    }
    else if (m_fInitNew)
    {
        *ppunkObject = NULL;
    }

Error:
    QUICK_RELEASE(piPersistStreamInit);
    QUICK_RELEASE(punkNewObject);
    RRETURN(hr);
}



HRESULT CPersistence::InternalPersistObject
(
    IUnknown  **ppunkObject,
    REFCLSID    clsidObject,
    UINT        idObject,
    REFIID      iidInterface,
    LPCOLESTR   pwszName
)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit *piPersistStreamInit = NULL;

    VARIANT varObject;
    ::VariantInit(&varObject);


    if ( m_fSaving && (NULL != *ppunkObject) )
    {
        if (m_fStream)
        {
            hr = (*ppunkObject)->QueryInterface(IID_IPersistStreamInit,
                               reinterpret_cast<void **>(&piPersistStreamInit));
            IfFailGo(hr);

            hr = piPersistStreamInit->Save(m_piStream, m_fClearDirty);
            IfFailGo(hr);
        }
        else if (m_fPropertyBag)
        {
            varObject.vt = VT_UNKNOWN;
            varObject.punkVal = *ppunkObject;
            hr = m_piPropertyBag->Write(pwszName, &varObject);
            IfFailGo(hr);
        }
    }
    else if (m_fLoading)
    {
        if (m_fStream)
        {
            // Create the object and get IPersistStreamInit on it

            IfFailGo(CreateObject(idObject,
                                  IID_IPersistStreamInit,
                                  &piPersistStreamInit));
            // Load the object
            
            IfFailGo(piPersistStreamInit->Load(m_piStream));

            // Get the requested interface to return to the caller

            QUICK_RELEASE(*ppunkObject);
            IfFailGo(piPersistStreamInit->QueryInterface(iidInterface,
                                        reinterpret_cast<void **>(ppunkObject)));
        }
        else if (m_fPropertyBag)
        {
            hr = m_piPropertyBag->Read(pwszName, &varObject, m_piErrorLog);
            IfFailGo(hr);
            if ( ((VT_UNKNOWN != varObject.vt) && (VT_DISPATCH != varObject.vt)) ||
                  (NULL == varObject.punkVal) )
            {
                hr = SID_E_TEXT_SERIALIZATION;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            QUICK_RELEASE(*ppunkObject);
            hr = varObject.punkVal->QueryInterface(iidInterface,
                                        reinterpret_cast<void **>(ppunkObject));
            varObject.punkVal->Release();
            IfFailGo(hr);
        }
    }
    else if (m_fInitNew)
    {
        // Create the object and get IPersistStreamInit on it

        IfFailGo(CreateObject(idObject,
                              IID_IPersistStreamInit,
                              &piPersistStreamInit));

        // Initialize the object
        
        hr = piPersistStreamInit->InitNew();
        IfFailGo(hr);

        QUICK_RELEASE(*ppunkObject);

        // Get the requested interface to return to the caller

        IfFailGo(piPersistStreamInit->QueryInterface(iidInterface,
                                        reinterpret_cast<void **>(ppunkObject)));
    }

Error:
    QUICK_RELEASE(piPersistStreamInit);
    RRETURN(hr);
}



HRESULT CPersistence::PersistPicture
(
    IPictureDisp **ppiPictureDisp,
    LPCOLESTR      pwszName
)
{
    HRESULT hr = S_OK;
    IPersistStream *piPersistStream = NULL;


    // The picture is not one of our objects and it is not co-creatable
    // so we can't use PersistObject(). If we are saving to
    // or loading from a property bag then PersistObject() can handle it. For
    // a stream we need to use IPersistStream::Save() and OleLoadPicture(). For
    // InitNew we create an empty bitmap so that the VB code will still run even
    // if the picture hasn't been set.

    if (InitNewing())
    {
        IfFailGo(::CreateEmptyBitmapPicture(ppiPictureDisp));
    }
    else
    {
        if (UsingPropertyBag())
        {
            hr = PersistObject(ppiPictureDisp, CLSID_NULL, 0, IID_IPictureDisp, pwszName);
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
        else if (UsingStream())
        {
            if (Saving())
            {
                IfFailGo((*ppiPictureDisp)->QueryInterface(IID_IPersistStream,
                                  reinterpret_cast<void **>(&piPersistStream)));
                hr = piPersistStream->Save(GetStream(), GetClearDirty());
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
            else
            {
                if (NULL != *ppiPictureDisp)
                {
                    (*ppiPictureDisp)->Release();
                    *ppiPictureDisp = NULL;
                }
                hr = ::OleLoadPicture(GetStream(), 0L, FALSE, IID_IPictureDisp, reinterpret_cast<void **>(ppiPictureDisp));
                GLOBAL_EXCEPTION_CHECK_GO(hr);
            }
        }
    }

Error:
    QUICK_RELEASE(piPersistStream);
    RRETURN(hr);
}




BOOL CPersistence::Loading()
{
    return m_fLoading;
}

BOOL CPersistence::Saving()
{
    return m_fSaving;
}

BOOL CPersistence::InitNewing()
{
    return m_fInitNew;
}

BOOL CPersistence::UsingPropertyBag()
{
    return m_fPropertyBag;
}

BOOL CPersistence::UsingStream()
{
    return m_fStream;
}

IStream *CPersistence::GetStream()
{
    return m_piStream;
}

BOOL CPersistence::GetClearDirty()
{
    return m_fClearDirty;
}

void CPersistence::SetDirty()
{
    m_fDirty = TRUE;
}

void CPersistence::ClearDirty()
{
    m_fDirty = FALSE;
}

void CPersistence::SetMajorVersion(DWORD dwVerMajor)
{
    m_dwVerMajor = dwVerMajor;
    m_fDirty = TRUE;
}

DWORD CPersistence::GetMajorVersion()
{
    return m_dwVerMajor;
}

void CPersistence::SetMinorVersion(DWORD dwVerMinor)
{
    m_dwVerMinor = dwVerMinor;
    m_fDirty = TRUE;
}

DWORD CPersistence::GetMinorVersion()
{
    return m_dwVerMinor;
}


void CPersistence::SetStream(IStream *piStream)
{
    RELEASE(m_piPropertyBag);
    RELEASE(m_piErrorLog);
    m_fPropertyBag = FALSE;

    RELEASE(m_piStream);
    if (NULL != piStream)
    {
        piStream->AddRef();
    }
    m_piStream = piStream;
    m_fStream = TRUE;
    m_fClearDirty = TRUE;
}

void CPersistence::SetSaving()
{
    m_fInitNew = FALSE;
    m_fLoading = FALSE;
    m_fSaving = TRUE;
}



//=--------------------------------------------------------------------------=
//                      IPersistStreamInit Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CPersistence::GetClassID(CLSID *pClsid)
{
    *pClsid = m_Clsid;
    return S_OK;
}


STDMETHODIMP CPersistence::InitNew()
{
    HRESULT hr = S_OK;

    m_fInitNew = TRUE;
    hr = Persist();
    m_fInitNew = FALSE;

    RRETURN(hr);
}

STDMETHODIMP CPersistence::Load(IStream *piStream)
{
    HRESULT hr = S_OK;

    m_fLoading = TRUE;
    m_fStream = TRUE;
    m_piStream = piStream;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        m_fDirty = FALSE;
    }
    m_fLoading = FALSE;
    m_fStream = FALSE;
    m_piStream = NULL;

    RRETURN(hr);
}



STDMETHODIMP CPersistence::Save(IStream *piStream, BOOL fClearDirty)
{
    HRESULT hr = S_OK;

    m_fSaving = TRUE;
    m_fStream = TRUE;
    m_fClearDirty = fClearDirty;
    m_piStream = piStream;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        if (fClearDirty)
        {
            m_fDirty = FALSE;
        }
    }
    m_fSaving = FALSE;
    m_fStream = FALSE;
    m_fClearDirty = FALSE;
    m_piStream = NULL;

    RRETURN(hr);
}



STDMETHODIMP CPersistence::IsDirty()
{
    return m_fDirty;
}

STDMETHODIMP CPersistence::GetSizeMax(ULARGE_INTEGER* puliSize)
{
    puliSize->LowPart = 0xFFFFFFFF;
    puliSize->HighPart = 0xFFFFFFFF;
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      IPersistPropertyBag Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CPersistence::Load
(
    IPropertyBag *piPropertyBag,
    IErrorLog    *piErrorLog
)
{
    HRESULT hr = S_OK;

    m_fLoading = TRUE;
    m_fPropertyBag = TRUE;
    m_piPropertyBag = piPropertyBag;
    m_piErrorLog = piErrorLog;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        m_fDirty = FALSE;
    }
    m_fLoading = FALSE;
    m_fPropertyBag = FALSE;
    m_piPropertyBag = NULL;
    m_piErrorLog = NULL;

    RRETURN(hr);
}


STDMETHODIMP CPersistence::Save
(
    IPropertyBag *piPropertyBag,
    BOOL          fClearDirty,
    BOOL          fSaveAll
)
{
    HRESULT hr = S_OK;

    m_fSaving = TRUE;
    m_fPropertyBag = TRUE;
    m_piPropertyBag = piPropertyBag;

    hr = Persist();

    if (SUCCEEDED(hr))
    {
        m_fDirty = FALSE;
    }
    m_fSaving = FALSE;
    m_fPropertyBag = FALSE;
    m_piPropertyBag = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpchars.cpp ===
//=--------------------------------------------------------------------------=
// prpchars.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// GetPropSheetCharSizes() implementation 
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "prpchars.h"

// for ASSERT and FAIL
//
SZTHISFILE


// Extended dialog templates (new in Win95). This is not defined in any
// header but we need it below in GetPropSheetFont()

#pragma pack(push, 1)
struct DLGTEMPLATEEX 
{
    WORD  dlgVer;
    WORD  signature;
    DWORD helpID;
    DWORD exStyle;
    DWORD style;
    WORD  cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
};
#pragma pack(pop)



//=--------------------------------------------------------------------------=
// GetPropSheetFont(HFONT *phFont)
//=--------------------------------------------------------------------------=
//
// Parameters:
//    HFONT *phFont  [out] HFONT of Win32 property sheet dialog font or
//                         reasonable equivalent. Can be NULL if font
//                         creation failed and function still returns S_OK.
//
// Output:
//
// Notes:
//
// This code is stolen from oleaut32.dll. The source is in
// e:\oa\src\stdtypes\oleframe.cpp. The routine is GetPropSheetFont().
//

static HRESULT GetPropSheetFont(HFONT *phFont)
{
    HRESULT      hr = S_OK;
    HINSTANCE    hInstComCtl32 = NULL;
    HRSRC        hResource = NULL;
    HGLOBAL      hTemplate = NULL;
    DLGTEMPLATE *pTemplate = NULL;
    BOOL         fDialogEx = NULL;
    WORD        *pWord = NULL;
    HDC          hdc = NULL;
    char        *pszFaceName = NULL;

    LOGFONT logfont;
    ::ZeroMemory(&logfont, sizeof(logfont));

    hInstComCtl32 = ::LoadLibrary("COMCTL32");
    IfFalseGo(NULL != hInstComCtl32, HRESULT_FROM_WIN32(::GetLastError()));

    // Find the dialog resource. The ID is hardcoded because as it is in
    // hte original code in oleaut32.dll. There is no Win32 header file that
    // contains this information.

    hResource = ::FindResource(hInstComCtl32, MAKEINTRESOURCE(1006), RT_DIALOG);
    IfFalseGo(NULL != hResource, HRESULT_FROM_WIN32(::GetLastError()));

    hTemplate = ::LoadResource(hInstComCtl32, hResource);
    IfFalseGo(NULL != hTemplate, HRESULT_FROM_WIN32(::GetLastError()));

    pTemplate = (DLGTEMPLATE *)::LockResource(hTemplate);
    IfFalseGo(NULL != pTemplate, HRESULT_FROM_WIN32(::GetLastError()));

    // Check that the style includes DS_SETFONT. This should be there but
    // if it is ever changed then there would not be any font info following
    // the template.

    IfFalseGo(DS_SETFONT == (pTemplate->style & DS_SETFONT), E_FAIL);

    // Now determine whether it is actually a DLGTEMPLATE or DLGTEMPLATEX and
    // get a pointer to the first word following the template.

    fDialogEx = ((pTemplate->style & 0xFFFF0000) == 0xFFFF0000);

    if (fDialogEx)
        pWord = (WORD *)((DLGTEMPLATEEX *)pTemplate + 1);
    else
        pWord = (WORD *)(pTemplate + 1);

    // At the end of the template we have the menu name, the window class name,
    // and the caption. Each of these is indicated by a WORD array as follows:
    // If the 1st WORD is 0 then the item is not present (e.g. there is
    // no class name).
    //
    // For the menu, if the 1st WORD is 0xFFFF then the 2nd WORD is an
    // identifier for a menu resource. If it is anything else then the 1st WORD
    // contains the 1st character of a null-terminated UNICODE string containing
    // the name of the menu resource.
    //
    // For the window class, if the 1st WORD is 0xFFFF then the 2nd WORD
    // contains a predefined system window class identifier. If the 1st
    // WORD is anything else then it is the first character of a null-terminated
    // UNICODE string containing the window class name.
    //
    // For the caption if the 1st WORD is not zero then it is the first
    // character in a null-terminated UNICODE string containing the window
    // class name.

    // Skip menu resource string or ID
    if (*pWord == (WORD)-1)
    {
        pWord += 2; // advance 2 WORDs
    }
    else
    {
        while (0 == *pWord)
        {
            pWord++;
        }
    }

    // Skip class name string or ID
    if (*pWord == (WORD)-1)
    {
        pWord += 2; // advance 2 WORDs
    }
    else
    {
        while (0 == *pWord)
        {
            pWord++;
        }
    }

    // Skip caption string
    while (0 == *pWord)
    {
        pWord++;
    }

    // At this point pWord points to the dialog font's point size. We need to
    // convert this value to logical units in order to create the font. The
    // formula is (DialogPointSize x VerticalPixelsPerInch) / PointsPerInch.
    //
    // LOGPIXELSY returns the number of pixels per inch along the screen
    // height. A point is 1/72 of an inch. We use the negation of the
    // calculation in order to tell the CreateFontIndirect() API that we want
    // the font mapper to convert it to device units and match the absolute
    // value against character height of available fonts. See the documentation
    // for LOGFONT in the Platform SDK for more info.

    // Get a screen DC
    hdc = ::GetDC(NULL);
    IfFalseGo(NULL != hdc, HRESULT_FROM_WIN32(::GetLastError()));

    logfont.lfHeight = -::MulDiv(*pWord, ::GetDeviceCaps(hdc, LOGPIXELSY), 72);

    // If this is a DLGTEMPLATEEX then the next 2 WORDs contain the weight and
    // italic flag.

    pWord += (fDialogEx ? 3 : 1);

    // At this point pWord points to a null-terminated UNICODE string containing
    // the font face name.

    IfFailGo(::ANSIFromWideStr((WCHAR *)pWord, &pszFaceName));
    ::strcpy(logfont.lfFaceName, pszFaceName);

Error:

    // If anything failed above then use a default font and height. This will
    // produce a reasonable result and allow the property page to be
    // displayed.

    if (FAILED(hr))
    {
        logfont.lfHeight = 8;
        ::strcpy(logfont.lfFaceName, "MS Sans Serif");
        hr = S_OK;
    }

    // Attempt to create the font and return the handle

    logfont.lfWeight = FW_NORMAL;
    logfont.lfCharSet = DEFAULT_CHARSET;

    *phFont = ::CreateFontIndirect(&logfont);

    if (NULL != hInstComCtl32)
    {
        ::FreeLibrary(hInstComCtl32);
    }
    if (NULL != pszFaceName)
    {
        CtlFree(pszFaceName);
    }
    if (NULL != hdc)
    {
        (void)::ReleaseDC(NULL, hdc);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// GetPropSheetCharSizes
//=--------------------------------------------------------------------------=
//
// Parameters:
//  UINT *pcxPropSheetChar  [out] average char width in a Win32 property sheet
//  UINT *pcyPropSheetChar  [out] average char height in a Win32 property sheet
//
// Output:
//
// Notes:
//
// This code is stolen from oleaut32.dll. The source is in
// e:\oa\src\stdtypes\oleframe.cpp. The main routine is
// CPageHolderTemplate::SetSize() and it calls one other function
// GetPropSheetFont().
//
// The size of the page returned from IPropertyPage::GetPageInfo() is in
// pixels. The size passed to the Win32 API CreatePropertySheetPage() must
// be in dialog units. Dialog units are based on the font used in the dialog
// and we have no way of knowing what the property page will be using. The only
// font we can be sure of is the one used by Win32 in the PropertySheet() API.
// This code loads comctl32.dll and loads the dialog resource used by Win32
// for the property sheet frame. It then interprets the DLGTEMLATE and related
// data to extract the font used. If any error occurs then it uses 8 point
// "MS Sans Serif" normal.

HRESULT DLLEXPORT GetPropSheetCharSizes
(
    UINT *pcxPropSheetChar,
    UINT *pcyPropSheetChar
)
{
    HRESULT      hr = S_OK;
    HDC          hdc = NULL;
    HFONT        hFont = NULL;
    HFONT        hfontOld = NULL;
    LONG         lSizes = 0;
    BOOL         fOK = FALSE;

    static BOOL fHaveCharSizes = FALSE;
    static UINT cxPropSheetChar = 0;
    static UINT cyPropSheetChar = 0;

    SIZE size;
    ::ZeroMemory(&size, sizeof(size));

    TEXTMETRIC tm;
    ::ZeroMemory(&tm, sizeof(tm));

    IfFalseGo(!fHaveCharSizes, S_OK);

    // Create the font and determine the average character height and width.
    // If font creation fails then use GetDialogBaseUnits() which will return
    // the average width and height of the system font.

    IfFailGo(GetPropSheetFont(&hFont));
    if (NULL != hFont)
    {
        // Get a screen DC
        hdc = ::CreateCompatibleDC(NULL);
        IfFalseGo(NULL != hdc, S_OK);

        hfontOld = (HFONT)::SelectObject(hdc, hFont);
        IfFalseGo(::GetTextMetrics(hdc, &tm), S_OK);
        fOK = ::GetTextExtentPointA(hdc,
                                    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
                                    52, &size);
        IfFalseGo(fOK, S_OK);

        // The cx calculation is done differently in OleCreatePropertyFrame()
        // and in MapDialogRect(). MapDialogRect() calls the internal
        // utility function GdiGetCharDimensions() in
        // nt\private\ntos\w32\ntgdi\client\cfont.c and that code does it
        // this way.
        
        cxPropSheetChar = ((size.cx / 26) + 1) / 2; // round up
        cyPropSheetChar = tm.tmHeight + tm.tmExternalLeading;
        fHaveCharSizes = TRUE;

        (void)::SelectObject(hdc, hfontOld);
    }

Error:

    if (!fHaveCharSizes)
    {
        // Could not create the font or some other failure above so just use
        // the system's values

        lSizes = ::GetDialogBaseUnits();
        cxPropSheetChar = LOWORD(lSizes);
        cyPropSheetChar = HIWORD(lSizes);
        fHaveCharSizes = TRUE;
    }

    *pcxPropSheetChar = cxPropSheetChar;
    *pcyPropSheetChar = cyPropSheetChar;

    if (NULL != hdc)
    {
        (void)::DeleteDC(hdc);
    }
    if (NULL != hFont)
    {
        (void)::DeleteObject((HGDIOBJ)hFont);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpsheet.h ===
//=--------------------------------------------------------------------------=
// prpsheet.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertySheet class definition - implements MMCPropertySheet object and
// IRemotePropertySheetManager used during debugging
//
//=--------------------------------------------------------------------------=

#ifndef _PRPSHEET_DEFINED_
#define _PRPSHEET_DEFINED_


class CPropertySheet : public CSnapInAutomationObject,
                       public IMMCPropertySheet,
                       public IRemotePropertySheetManager
{
    protected:
        CPropertySheet(IUnknown *punkOuter);
        ~CPropertySheet();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        void SetWizard() { m_fWizard = TRUE; }
        HRESULT SetCallback(IPropertySheetCallback *piPropertySheetCallback,
                            LONG_PTR                handle,
                            LPOLESTR                pwszProgIDStart,
                            IMMCClipboard          *piMMCClipboard,
                            ISnapIn                *piSnapIn,
                            BOOL                    fConfigWizard);

        HRESULT GetTemplate(long lNextPage, DLGTEMPLATE **ppDlgTemplate);

        void YouAreRemote() { m_fWeAreRemote = TRUE; }

        void SetHWNDSheet(HWND hwndSheet) { m_hwndSheet = hwndSheet; }

        // Set from CPropertyPageWrapper as it enters and leaves message
        // handlers during which property pages cannot call AddPage, InsertPage
        // RemovePage

        void SetOKToAlterPageCount(BOOL fOK) { m_fOKToAlterPageCount = fOK; }

        // Called during debugging to return property page definitions to proxy

        WIRE_PROPERTYPAGES *TakeWirePages();

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IMMCPropertySheet
    public:
        STDMETHOD(AddPage)(BSTR    PageName,
                           VARIANT Caption,
                           VARIANT UseHelpButton,
                           VARIANT RightToLeft,
                           VARIANT InitData);
        STDMETHOD(AddWizardPage)(BSTR       PageName,
                                 IDispatch *ConfigurationObject,
                                 VARIANT    UseHelpButton,
                                 VARIANT    RightToLeft,
                                 VARIANT    InitData,
                                 VARIANT    Caption);
        STDMETHOD(AddPageProvider)(BSTR               CLSIDPageProvider,
                                   long              *hwndSheet,
                                   IDispatch        **PageProvider);
        STDMETHOD(ChangeCancelToClose)();
        STDMETHOD(InsertPage)(short   Position,
                              BSTR    PageName,
                              VARIANT Caption,
                              VARIANT UseHelpButton,
                              VARIANT RightToLeft,
                              VARIANT InitData);
        STDMETHOD(PressButton)(SnapInPropertySheetButtonConstants Button);
        STDMETHOD(RecalcPageSizes)();
        STDMETHOD(RemovePage)(short Position);
        STDMETHOD(ActivatePage)(short Position);
        STDMETHOD(SetFinishButtonText)(BSTR Text);
        STDMETHOD(SetTitle)(BSTR Text, VARIANT_BOOL UsePropertiesForInTitle);
        STDMETHOD(SetWizardButtons)(VARIANT_BOOL              EnableBack,
                                    WizardPageButtonConstants NextOrFinish);
        STDMETHOD(GetPagePosition)(long hwndPage, short *psPosition);
        STDMETHOD(RestartWindows)();
        STDMETHOD(RebootSystem)();

    // IRemotePropertySheetManager
    private:
        STDMETHOD(CreateRemotePages)(IPropertySheetCallback *piPropertySheetCallback,
                                     LONG_PTR                handle,
                                     IDataObject            *piDataObject,
                                     WIRE_PROPERTYPAGES     *pPages);

        void InitMemberVariables();
        void ReleaseObjects();
        HRESULT GetPageCLSIDs();
        HRESULT InitializeRemotePages(WIRE_PROPERTYPAGES *pPages);
        HRESULT CopyPageInfosToWire(WIRE_PROPERTYPAGES *pPages);
        HRESULT CopyPageInfosFromWire(WIRE_PROPERTYPAGES *pPages);
        HRESULT GetCLSIDForPage(BSTR PageName, CLSID *clsidPage);
        HRESULT InternalAddPage(BSTR      PageName,
                                ULONG      cObjects,
                                IUnknown **apunkObjects,
                                VARIANT    Caption,
                                VARIANT    UseHelpButton,
                                VARIANT    RightToLeft,
                                VARIANT    InitData,
                                BOOL       fIsInsert,
                                short      sPosition);

        HRESULT AddLocalPage(CLSID      clsidPage,
                             DWORD      dwFlags,
                             short      cxPage,
                             short      cyPage,
                             LPOLESTR   pwszTitle,
                             ULONG      cObjects,
                             IUnknown **apunkObjects,
                             VARIANT    InitData,
                             BOOL       fIsRemote,
                             BOOL       fIsInsert,
                             short      sPosition);

        HRESULT AddRemotePage(CLSID      clsidPage,
                              DWORD      dwFlags,
                              short      cxPage,
                              short      cyPage,
                              LPOLESTR   pwszTitle,
                              ULONG      cObjects,
                              IUnknown **apunkObjects,
                              VARIANT    InitData);

        HRESULT GetPageInfo(CLSID     clsidPage,
                            short    *pcx,
                            short    *pcy,
                            LPOLESTR *ppwszTitle);

        HRESULT ConvertToDialogUnits(long   xPixels,
                                     long   yPixels,
                                     short *pxDlgUnits,
                                     short *pyDlgUnits);

        IPropertySheetCallback  *m_piPropertySheetCallback; // MMC interface

        LONG_PTR                 m_handle;          // MMC proppage handle
        long                     m_cPages;          // # of pages in sheet
        DLGTEMPLATE            **m_ppDlgTemplates;  // dlg templates for pages
        LPOLESTR                 m_pwszProgIDStart; // Left hand side of snap-in's
                                                    // ProgID (project name)
        IUnknown               **m_apunkObjects;    // objects for which props
                                                    // are being displayed
        ULONG                    m_cObjects;        // no. of those objects
        ISnapIn                 *m_piSnapIn;        // pointer to owning snap-in
        PAGEINFO                *m_paPageInfo;      // From IPropertyPage::GetPageInfo
        ULONG                    m_cPageInfos;      // # of PAGEINFOs in array
        BOOL                     m_fHavePageCLSIDs; // TRUE=ISpecifyPropertyPages
                                                    // called for all pages
        BOOL                     m_fWizard;         // TRUE=this is a wizard
        BOOL                     m_fConfigWizard;   // TRUE=this is config wizard
        WIRE_PROPERTYPAGES      *m_pWirePages;      // ptr to page defs for proxy
        HWND                     m_hwndSheet;       // Property sheet's hwnd
        BOOL                     m_fOKToAlterPageCount; // TRUE=prop pages can
                                                        // call AddPage, InsertPage
                                                        // RemovePage

        // Store the Win32 PropertSheet() font dimensions here. We only
        // get these for the first property sheet displayed for any snap-in
        // once the runtime is loaded into MMC.EXE.
        
        static UINT              m_cxPropSheetChar;
        static UINT              m_cyPropSheetChar;
        static BOOL              m_fHavePropSheetCharSizes;

        BOOL                     m_fWeAreRemote;    // indicates whether
                                                    // the snap-in is being
                                                    // run remotely (in an F5
                                                    // for source debugging)
};


DEFINE_AUTOMATIONOBJECTWEVENTS2(PropertySheet,                    // name
                                &CLSID_MMCPropertySheet,          // clsid
                                "PropertySheet",                  // objname
                                "PropertySheet",                  // lblname
                                &CPropertySheet::Create,          // creation function
                                TLIB_VERSION_MAJOR,               // major version
                                TLIB_VERSION_MINOR,               // minor version
                                &IID_IMMCPropertySheet,           // dispatch IID
                                NULL,                             // event IID
                                HELP_FILENAME,                    // help file
                                TRUE);                            // thread safe


#endif _PRPSHEET_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resource.h ===
//=--------------------------------------------------------------------------=
// resource.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
//      Snap-in designer runtime resource IDs
//


#define IDS_EXTENSIONDEFS_NAME 1
#define IDS_GENERIC_ERROR_MSG  2



// This is defined for all inproc servers that use satellite localization. It
// must be 1001
//
#define IDS_SERVERBASENAME              1001

#define IDB_BITMAP_LARGE_OPEN_FOLDER    1

#define IDI_ICON_DEFAULT                1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\reginfo.h ===
//=--------------------------------------------------------------------------=
// reginfo.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CRegInfo class definition - used to hold registry info gathered at design
// time and passed to DllRegisterDesigner (see dlregdes.cpp)
//
//=--------------------------------------------------------------------------=

#ifndef _REGINFO_DEFINED_
#define _REGINFO_DEFINED_


class CRegInfo : public CSnapInAutomationObject,
                 public CPersistence,
                 public IRegInfo
{
    private:
        CRegInfo(IUnknown *punkOuter);
        ~CRegInfo();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IRegInfo

        BSTR_PROPERTY_RW  (CRegInfo,   DisplayName,                           DISPID_REGINFO_DISPLAY_NAME);
        BSTR_PROPERTY_RW  (CRegInfo,   StaticNodeTypeGUID,                    DISPID_REGINFO_STATIC_NODE_TYPE_GUID);
        SIMPLE_PROPERTY_RW(CRegInfo,   StandAlone,        VARIANT_BOOL,       DISPID_REGINFO_STANDALONE);
        OBJECT_PROPERTY_RO(CRegInfo,   NodeTypes,         INodeTypes,         DISPID_REGINFO_NODETYPES);
        OBJECT_PROPERTY_RW(CRegInfo,   ExtendedSnapIns,   IExtendedSnapIns,   DISPID_REGINFO_EXTENDED_SNAPINS);

      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(RegInfo,           // name
                                &CLSID_RegInfo,    // clsid
                                "RegInfo",         // objname
                                "RegInfo",         // lblname
                                &CRegInfo::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_IRegInfo,     // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _REGINFO_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\pshtprov.cpp ===
//=--------------------------------------------------------------------------=
// pshtprov.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCPropertySheetProvider class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "pshtprov.h"
#include "scopitem.h"
#include "listitem.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


CMMCPropertySheetProvider::CMMCPropertySheetProvider(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                  OBJECT_TYPE_PROPERTYSHEETPROVIDER,
                                  static_cast<IMMCPropertySheetProvider *>(this),
                                  static_cast<CMMCPropertySheetProvider *>(this),
                                  0,    // no property pages
                                  NULL, // no property pages
                                  NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


IUnknown *CMMCPropertySheetProvider::Create(IUnknown *punkOuter)
{
    CMMCPropertySheetProvider *pPropertySheetProvider =
                                        New CMMCPropertySheetProvider(punkOuter);

    if (NULL == pPropertySheetProvider)
    {
        GLOBAL_EXCEPTION_CHECK(SID_E_OUTOFMEMORY);
        return NULL;
    }
    else
    {
        return pPropertySheetProvider->PrivateUnknown();
    }
}

CMMCPropertySheetProvider::~CMMCPropertySheetProvider()
{
    RELEASE(m_piPropertySheetProvider);
    RELEASE(m_punkView);
    RELEASE(m_piDataObject);
    RELEASE(m_piComponent);
    InitMemberVariables();
}

void CMMCPropertySheetProvider::InitMemberVariables()
{
    m_piPropertySheetProvider = NULL;
    m_pView = NULL;
    m_punkView = NULL;
    m_piDataObject = NULL;
    m_piComponent = NULL;
    m_fHaveSheet = FALSE;
    m_fWizard = FALSE;
}


HRESULT CMMCPropertySheetProvider::SetProvider
(
    IPropertySheetProvider *piPropertySheetProvider,
    CView                  *pView
)
{
    HRESULT hr = S_OK;

    RELEASE(m_piPropertySheetProvider);
    if (NULL != piPropertySheetProvider)
    {
        piPropertySheetProvider->AddRef();
    }
    m_piPropertySheetProvider = piPropertySheetProvider;

    m_pView = pView;
    RELEASE(m_punkView);
    RELEASE(m_piComponent);

    IfFalseGo(NULL != pView, S_OK);

    IfFailGo(pView->QueryInterface(IID_IUnknown,
                                   reinterpret_cast<void **>(&m_punkView)));
    
    IfFailGo(pView->QueryInterface(IID_IComponent,
                                   reinterpret_cast<void **>(&m_piComponent)));
Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IMMCPropertySheetProvider Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCPropertySheetProvider::CreatePropertySheet
(
    BSTR                              Title, 
    SnapInPropertySheetTypeConstants  Type,
    VARIANT                           Objects,
    VARIANT                           UsePropertiesForInTitle,
    VARIANT                           UseApplyButton
)
{
    HRESULT       hr = S_OK;
    IDataObject  *piDataObject = NULL;
    boolean       fIsPropertySheet = FALSE;
    DWORD         dwOptions = 0;
    MMC_COOKIE    cookie = 0;
    CScopeItem   *pScopeItem = NULL;
    IScopeItem   *piScopeItem = NULL;
    CMMCListItem *pMMCListItem = NULL;
    IMMCListItem *piMMCListItem = NULL;

    // Make sure this MMPropertySheetProvider object is connected to MMC.

    if (NULL == m_piPropertySheetProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the IDataObject and cookie for the specified object(s)

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    // Determine whether it is a property sheet or a wizard

    if (siPropertySheet == Type)
    {
        fIsPropertySheet = TRUE; // create a property sheet
        m_fWizard = FALSE;
    }
    else
    {
        fIsPropertySheet = FALSE; // create a wizard
        m_fWizard = TRUE;
    }

    // If it is a wizard and it is Wizard87 style then set that option bit

    if (siWizard97 == Type)
    {
        dwOptions |= MMC_PSO_NEWWIZARDTYPE;
    }

    // If it's a property sheet then determine whether to prepend
    // "Properties for" to the title bar

    if (fIsPropertySheet)
    {
        if (ISPRESENT(UsePropertiesForInTitle))
        {
            if (VT_BOOL != UsePropertiesForInTitle.vt)
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }

            if (VARIANT_FALSE == UsePropertiesForInTitle.boolVal)
            {
                dwOptions |= MMC_PSO_NO_PROPTITLE;
            }
        }
    }

    // Determine whether there should be an "Apply" button

    if (ISPRESENT(UseApplyButton))
    {
        if (VT_BOOL != UseApplyButton.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        if (VARIANT_FALSE == UseApplyButton.boolVal)
        {
            dwOptions |= MMC_PSO_NOAPPLYNOW;
        }
    }

    // Release any previously used sheet. MMC normally requires doing this
    // if a property sheet is created but never shown. We did it here just in
    // case that occurred previously.

    IfFailGo(Clear());

    // We need to add an extra ref to the data object here
    // because of NTBUGS 318357. MMC does not AddRef the data object. This should
    // be fixed in 1.2 but 1.1 was released with the bug.
    
    piDataObject->AddRef();
    m_piDataObject = piDataObject;

    // Create the new sheet.

    hr = m_piPropertySheetProvider->CreatePropertySheet(Title,  fIsPropertySheet,
                                                        cookie, piDataObject,
                                                        dwOptions);
    if (FAILED(hr))
    {
        RELEASE(m_piDataObject);
    }
    EXCEPTION_CHECK_GO(hr);

    m_fHaveSheet = TRUE;

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::AddPrimaryPages(VARIANT_BOOL InScopePane)
{
    HRESULT hr = S_OK;

    if ( (NULL == m_piPropertySheetProvider) || (NULL == m_punkView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piPropertySheetProvider->AddPrimaryPages(
                                               m_punkView,
                                               FALSE, // don't create handle
                                               NULL,
                                               VARIANTBOOL_TO_BOOL(InScopePane));

    // If the call failed then we need to tell MMC to release allocated resources
    
    if (FAILED(hr))
    {
        Clear();
    }
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::AddExtensionPages()
{
    HRESULT hr = S_OK;

    if (NULL == m_piPropertySheetProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piPropertySheetProvider->AddExtensionPages();

    // If the call failed then we need to tell MMC to release allocated resources

    if (FAILED(hr))
    {
        Clear();
    }

    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::Show
(
    int     Page,
    VARIANT hwnd
)
{
    HRESULT         hr = S_OK;
    long            lHwnd = NULL;
    BOOL            fRegisteredOurFilter = FALSE;
    IMessageFilter *piOldMessageFilter = NULL;
    IMessageFilter *piOurMessageFilter = NULL;

    if ( (NULL == m_piPropertySheetProvider) || (NULL == m_pView) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    if (ISPRESENT(hwnd))
    {
        lHwnd = hwnd.lVal;
    }
    else
    {
        hr = m_pView->GetIConsole2()->GetMainWindow(
                                               reinterpret_cast<HWND *>(&lHwnd));
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are remote and running a wizard then install our message filter for
    // IPropertySheetProvider->Show because VB's message filter will throw out
    // mouse and keyboard messages. This would not allow the developer to
    // enter input into a property page while debugging. OLE calls the message
    // filter because VB is in a pending remote call for the duration of the
    // wizard and clicking on a control in a property page generates a message
    // in VB's queue.

    if (m_fWizard && m_pView->GetSnapIn()->WeAreRemote())
    {
        hr = ::CoRegisterMessageFilter(static_cast<IMessageFilter *>(this),
                                       &piOldMessageFilter);
        EXCEPTION_CHECK_GO(hr);
        fRegisteredOurFilter = TRUE;
    }

    // We get the page number one-based so subtract one

    hr = m_piPropertySheetProvider->Show(lHwnd, Page - 1);

    // If the call failed then we need to tell MMC to release allocated resources

    if (FAILED(hr))
    {
        Clear();
    }

    // If this is a wizard then we can release the extra ref on the data object
    // because wizards are synchronous. (See CreatePropertySheet for why we need
    // this ref). If it is not a wizard, then we are going to leak.

    if (m_fWizard)
    {
        RELEASE(m_piDataObject);
    }

    // Either way, following Show MMC considers the sheet gone. Reset our flag
    // so any subsequent calls to MMCPropertySheetProvider.Clear() will not call
    // into MMC (such a call would fail after a succesful call to
    // IPropertySheetProvider::Show()).
    
    m_fHaveSheet = FALSE;

    EXCEPTION_CHECK_GO(hr);

Error:

    // If we registered a message filter then remove it here.
    
    if (fRegisteredOurFilter)
    {
        if (SUCCEEDED(::CoRegisterMessageFilter(piOldMessageFilter,
                                                &piOurMessageFilter)))
        {
            // If we got back a message filter then release it
            if (NULL != piOurMessageFilter)
            {
                piOurMessageFilter->Release();
            }
        }
        
        // If we got back a message filter before the Show call then release it
        if (NULL != piOldMessageFilter)
        {
            piOldMessageFilter->Release();
        }
    }
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::FindPropertySheet
(
    VARIANT       Objects,
    VARIANT_BOOL *pfvarFound
)
{
    HRESULT      hr = S_OK;
    MMC_COOKIE   cookie = 0;
    IDataObject *piDataObject = NULL;

    if (NULL == pfvarFound)
    {
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    *pfvarFound = VARIANT_FALSE;

    if ( (NULL == m_piPropertySheetProvider) || (NULL == m_piComponent) )
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the IDataObject and cookie for the specified object(s)

    IfFailGo(::DataObjectFromObjects(Objects, &cookie, &piDataObject));

    // Use IComponent in the FindPropertySheet call to MMC so that our
    // IComponent::CompareObjects()  will be called. This is necessary because
    // in the case of a multiselection CompareObjects() must manually compare
    // the elements in the data object's scope item and list item collections.
    // A simple cookie comparison cannot be used because all multi-select
    // property pages use MMC_MULTI_SELECT_COOKIE.

    hr = m_piPropertySheetProvider->FindPropertySheet(cookie,
                                                      m_piComponent,
                                                      piDataObject);

    // If the call failed then we need to tell MMC to release allocated resources

    if (FAILED(hr))
    {
        Clear();
    }

    EXCEPTION_CHECK_GO(hr);
    if (S_OK == hr)
    {
        *pfvarFound = VARIANT_TRUE;
    }

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


STDMETHODIMP CMMCPropertySheetProvider::Clear()
{
    HRESULT hr = S_OK;

    RELEASE(m_piDataObject);

    if (NULL == m_piPropertySheetProvider)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }
    if (m_fHaveSheet)
    {
        (void)m_piPropertySheetProvider->Show(-1, 0);
    }
    m_fHaveSheet = FALSE;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IMessageFilter Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP_(DWORD) CMMCPropertySheetProvider::HandleInComingCall
( 
    DWORD dwCallType,
    HTASK htaskCaller,
    DWORD dwTickCount,
    LPINTERFACEINFO lpInterfaceInfo
)
{
    // this should never be called as it is for servers and this filter is here
    // for handling a client side situation
    return SERVERCALL_ISHANDLED;
}

STDMETHODIMP_(DWORD) CMMCPropertySheetProvider::RetryRejectedCall( 
    HTASK htaskCallee,
    DWORD dwTickCount,
    DWORD dwRejectType)
{
    return (DWORD)1; // retry call immediately
}

STDMETHODIMP_(DWORD) CMMCPropertySheetProvider::MessagePending
( 
    HTASK htaskCallee,
    DWORD dwTickCount,
    DWORD dwPendingType
)
{

    BOOL fGotQuitMessage = FALSE;

    MSG msg;
    ::ZeroMemory(&msg, sizeof(msg));

    // Pump messages until queue is empty or we get a WM_QUIT. This will ensure
    // that mouse clicks and keys get to the property page.

    while ( (!fGotQuitMessage) && ::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
    {
        if (WM_QUIT == msg.message)
        {
            ::PostQuitMessage((int) msg.wParam);
            fGotQuitMessage = TRUE;
        }
        else
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }

    return PENDINGMSG_WAITNOPROCESS; // Tell OLE to keep the call alive
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCPropertySheetProvider::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCPropertySheetProvider == riid)
    {
        *ppvObjOut = static_cast<IMMCPropertySheetProvider *>(this);
        ExternalAddRef();
        return S_OK;
    }
    if (IID_IMessageFilter == riid)
    {
        *ppvObjOut = static_cast<IMMCPropertySheetProvider *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\prpsheet.cpp ===
//=--------------------------------------------------------------------------=
// prpsheet.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CPropertySheet class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "prpsheet.h"
#include "ppgwrap.h"
#include "scopitms.h"
#include "listitms.h"
#include "dataobjs.h"
#include "prpchars.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor


UINT CPropertySheet::m_cxPropSheetChar = 0;
UINT CPropertySheet::m_cyPropSheetChar = 0;
BOOL CPropertySheet::m_fHavePropSheetCharSizes = FALSE;

CPropertySheet::CPropertySheet(IUnknown *punkOuter) :
                    CSnapInAutomationObject(punkOuter,
                                         OBJECT_TYPE_PROPERTYSHEET,
                                         static_cast<IMMCPropertySheet *>(this),
                                         static_cast<CPropertySheet *>(this),
                                         0,    // no property pages
                                         NULL, // no property pages
                                         NULL) // no persistence



{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor



IUnknown *CPropertySheet::Create(IUnknown *punkOuter)
{
    HRESULT        hr = S_OK;
    CPropertySheet *pPropertySheet = New CPropertySheet(punkOuter);

    if (NULL == pPropertySheet)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pPropertySheet)
        {
            delete pPropertySheet;
        }
        return NULL;
    }
    else
    {
        return pPropertySheet->PrivateUnknown();
    }
}

CPropertySheet::~CPropertySheet()
{
    ULONG              i = 0;

    RELEASE(m_piPropertySheetCallback);
    if (NULL != m_ppDlgTemplates)
    {
        ::CtlFree(m_ppDlgTemplates);
    }

    if (NULL != m_paPageInfo)
    {
        for (i = 0; i < m_cPageInfos; i++)
        {
            if (NULL != m_paPageInfo[i].pwszTitle)
            {
                ::CoTaskMemFree(m_paPageInfo[i].pwszTitle);
            }
            if (NULL != m_paPageInfo[i].pwszProgID)
            {
                CtlFree(m_paPageInfo[i].pwszProgID);
            }
        }
        CtlFree(m_paPageInfo);
    }

    if (NULL != m_pwszProgIDStart)
    {
        ::CoTaskMemFree(m_pwszProgIDStart);
    }

    ReleaseObjects();
    RELEASE(m_piSnapIn);
    InitMemberVariables();
}

void CPropertySheet::ReleaseObjects()
{
    ULONG              i = 0;
    ULONG              j = 0;
    WIRE_PROPERTYPAGE *pPage = NULL;

    // Release the objects associated with the property pages

    if (NULL != m_apunkObjects)
    {
        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != m_apunkObjects[i])
            {
                m_apunkObjects[i]->Release();
            }
        }
        CtlFree(m_apunkObjects);
        m_apunkObjects = NULL;
        m_cObjects = 0;
    }

    // Free the WIRE_PROPERTYPAGES and all of its contents.

    if (NULL == m_pWirePages)
    {
        return;
    }

    for (i = 0, pPage = &m_pWirePages->aPages[0];
         i < m_pWirePages->cPages;
         i++, pPage++)
    {
        if (NULL != pPage->apunkObjects)
        {
            for (j = 0; j < pPage->cObjects; j++)
            {
                if (NULL != pPage->apunkObjects[j])
                {
                    pPage->apunkObjects[j]->Release();
                }
            }
            ::CoTaskMemFree(pPage->apunkObjects);
        }

        if (NULL != pPage->pwszTitle)
        {
            ::CoTaskMemFree(pPage->pwszTitle);
        }
    }

    if (NULL != m_pWirePages->punkExtra)
    {
        m_pWirePages->punkExtra->Release();
    }

    if (NULL != m_pWirePages->pwszProgIDStart)
    {
        ::CoTaskMemFree(m_pWirePages->pwszProgIDStart);
    }

    if (NULL != m_pWirePages->pPageInfos)
    {
        for (i = 0; i < m_pWirePages->pPageInfos->cPages; i++)
        {
            if (NULL != m_pWirePages->pPageInfos->aPageInfo[i].pwszTitle)
            {
                ::CoTaskMemFree(m_pWirePages->pPageInfos->aPageInfo[i].pwszTitle);
            }
            if (NULL != m_pWirePages->pPageInfos->aPageInfo[i].pwszProgID)
            {
                ::CoTaskMemFree(m_pWirePages->pPageInfos->aPageInfo[i].pwszProgID);
            }
        }
        ::CoTaskMemFree(m_pWirePages->pPageInfos);
    }

    // Free all of the objects associated with the sheet

    if (NULL != m_pWirePages->apunkObjects)
    {
        for (i = 0; i < m_pWirePages->cObjects; i++)
        {
            if (NULL != m_pWirePages->apunkObjects[i])
            {
                m_pWirePages->apunkObjects[i]->Release();
            }
        }
        CoTaskMemFree(m_pWirePages->apunkObjects);
    }


    ::CoTaskMemFree(m_pWirePages);
    m_pWirePages = NULL;

}


void CPropertySheet::InitMemberVariables()
{
    m_piPropertySheetCallback = NULL;
    m_handle = NULL;
    m_apunkObjects = NULL;
    m_cObjects = 0;
    m_piSnapIn = NULL;
    m_cPages = 0;
    m_ppDlgTemplates = NULL;
    m_pwszProgIDStart = NULL;
    m_paPageInfo = NULL;
    m_cPageInfos = NULL;
    m_fHavePageCLSIDs = FALSE;
    m_fWizard = FALSE;
    m_fConfigWizard = FALSE;
    m_fWeAreRemote = FALSE;
    m_pWirePages = NULL;
    m_hwndSheet = NULL;
    m_fOKToAlterPageCount = TRUE;
}



HRESULT CPropertySheet::SetCallback
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    LPOLESTR                pwszProgIDStart,
    IMMCClipboard          *piMMCClipboard,
    ISnapIn                *piSnapIn,
    BOOL                    fConfigWizard
)
{
    HRESULT          hr = S_OK;
    CMMCClipboard   *pMMCClipboard = NULL;
    CScopeItems     *pScopeItems;
    CMMCListItems   *pListItems;
    CMMCDataObjects *pDataObjects;
    long             cObjects = 0;
    long             i = 0;
    long             iNext = 0;

    RELEASE(m_piPropertySheetCallback);
    if (NULL != piPropertySheetCallback)
    {
        piPropertySheetCallback->AddRef();
    }
    m_piPropertySheetCallback = piPropertySheetCallback;

    m_handle = handle;
    m_fWizard = fConfigWizard;
    m_fConfigWizard = fConfigWizard;

    if (NULL != m_pwszProgIDStart)
    {
        ::CoTaskMemFree(m_pwszProgIDStart);
        m_pwszProgIDStart = NULL;
    }

    if (NULL != pwszProgIDStart)
    {
        IfFailGo(::CoTaskMemAllocString(pwszProgIDStart, &m_pwszProgIDStart));
    }

    RELEASE(m_piSnapIn);
    if (NULL != piSnapIn)
    {
        piSnapIn->AddRef();
    }
    m_piSnapIn = piSnapIn;

    IfFalseGo(NULL != piMMCClipboard, S_OK);

    // Release any currently held objects

    ReleaseObjects();

    // Create an array of IUnknown * with an element for each scope item, list
    // item and dataobject contained in the clipboard

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCClipboard,
                                                   &pMMCClipboard));

    pScopeItems = pMMCClipboard->GetScopeItems();
    pListItems = pMMCClipboard->GetListItems();
    pDataObjects = pMMCClipboard->GetDataObjects();

    m_cObjects = pScopeItems->GetCount() +
                 pListItems->GetCount() +
                 pDataObjects->GetCount();

    IfFalseGo(0 != m_cObjects, S_OK);

    m_apunkObjects = (IUnknown **)CtlAllocZero(m_cObjects * sizeof(IUnknown *));
    if (NULL == m_apunkObjects)
    {
        m_cObjects = 0;
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    iNext = 0;

    cObjects = pScopeItems->GetCount();
    for (i = 0; i < cObjects; i++)
    {
        IfFailGo(pScopeItems->GetItemByIndex(i)->QueryInterface(IID_IUnknown,
                             reinterpret_cast<void **>(&m_apunkObjects[iNext])));
        iNext++;
    }

    cObjects = pListItems->GetCount();
    for (i = 0; i < cObjects; i++)
    {
        IfFailGo(pListItems->GetItemByIndex(i)->QueryInterface(IID_IUnknown,
                             reinterpret_cast<void **>(&m_apunkObjects[iNext])));
        iNext++;
    }

    cObjects = pDataObjects->GetCount();
    for (i = 0; i < cObjects; i++)
    {
        IfFailGo(pDataObjects->GetItemByIndex(i)->QueryInterface(IID_IUnknown,
                             reinterpret_cast<void **>(&m_apunkObjects[iNext])));
        iNext++;
    }

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::GetTemplate
(
    long          lNextPage,
    DLGTEMPLATE **ppDlgTemplate
)
{
    HRESULT hr = S_OK;

    if ( (lNextPage < 1) || (lNextPage > m_cPages) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if (NULL == m_ppDlgTemplates)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppDlgTemplate = m_ppDlgTemplates[lNextPage - 1L];

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CPropertySheet::TakeWirePages
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//  WIRE_PROPERTYPAGES * - pointer to property page info accumulated from
//                         VB calls to AddPage and AddWizardPage. Caller takes
//                         ownership of this memory and must free its contents
//                         with CoTaskMemFree().
//
// Notes:
//
// This function is called from CSnapIn's and CView's
// IExtendPropertySheet2::CreatePropertyPages implementation when the snap-in
// is running remotely in a source debugging session. It returns this memory
// block to the stub so that it can be transmitted to the proxy where the
// real property pages will be created based on this information.
//

WIRE_PROPERTYPAGES *CPropertySheet::TakeWirePages()
{
    WIRE_PROPERTYPAGES *pPages = m_pWirePages;
    m_pWirePages = NULL;
    return pPages;
}



HRESULT CPropertySheet::GetPageCLSIDs()
{
    HRESULT                hr = S_OK;
    ISpecifyPropertyPages *piSpecifyPropertyPages = NULL;
    LPOLESTR               pwszCtlProgID = NULL;
    static WCHAR           wszSnapInControl[] = L"SnapInControl";
    CLSID                  clsidCtl = CLSID_NULL;
    DWORD                  cbSnapInControlProgID = 0;
    size_t                 cchProgIDStart = 0;
    size_t                 cbProgIDStart = 0;
    ULONG                  i = 0;
    WCHAR                  wszKey[64] = L"ClsID\\";
    char                  *pszKey = NULL;
    char                   szProgID[128] = "";
    char                  *pszProgIDAfterDot = NULL;
    HKEY                   hkey = NULL;
    DWORD                  dwType = REG_SZ;
    DWORD                  cbProgID = 0;
    long                   lRc = 0;

    CAUUID cauuid;
    ::ZeroMemory(&cauuid, sizeof(cauuid));

    // Concatenate the project's prog ID start (part before the dot) with
    // "SnapInControl" to form the control's prog ID.

    cchProgIDStart = ::wcslen(m_pwszProgIDStart);
    cbProgIDStart = cchProgIDStart * sizeof(WCHAR);
    cbSnapInControlProgID = (DWORD)(cbProgIDStart +
                                    sizeof(WCHAR) + // for the dot
                                    sizeof(wszSnapInControl));

    pwszCtlProgID = (LPOLESTR)::CtlAlloc(cbSnapInControlProgID);
    if (NULL == pwszCtlProgID)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Copy the part before the dot.

    ::memcpy(pwszCtlProgID, m_pwszProgIDStart, cbProgIDStart);

    // Add the dot

    pwszCtlProgID[cchProgIDStart] = L'.';

    // Add "SnapInControl"

    ::memcpy( &pwszCtlProgID[cchProgIDStart + 1],
              wszSnapInControl,
              sizeof(wszSnapInControl) );


    // Now we have the full progid of the SnapInControl. Get its CLSID,
    // create an instance of it, and get an ISpecifyPropertyPages on it.

    hr = ::CLSIDFromProgID(pwszCtlProgID, &clsidCtl);
    EXCEPTION_CHECK_GO(hr);

    hr = ::CoCreateInstance(clsidCtl,
                            NULL, // no aggregation,
                            CLSCTX_INPROC_SERVER,
                            IID_ISpecifyPropertyPages,
                            reinterpret_cast<void **>(&piSpecifyPropertyPages));
    EXCEPTION_CHECK_GO(hr);

    // Ask the control for the array of all of its property pages

    IfFailGo(piSpecifyPropertyPages->GetPages(&cauuid));

    // Make sure the control actually returned some CLSIDs. The most likely
    // cause of this error is that the user forgot to associate the property
    // page with SnapInControl.

    if ( (0 == cauuid.cElems) || (NULL == cauuid.pElems) )
    {
        hr = SID_E_INVALID_PROPERTY_PAGE_NAME;
        EXCEPTION_CHECK_GO(hr);
    }

    // Allocate the array of PAGEINFO structs

    m_paPageInfo = (PAGEINFO *)::CtlAllocZero(cauuid.cElems * sizeof(PAGEINFO));
    if (NULL == m_paPageInfo)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    m_cPageInfos = cauuid.cElems;

    // Look up the clsids in the registry under \HKEY_CLASSES_ROOT\ClsID
    // and get the default value for each one which is its prog id. Store the
    // right half (after the dot) of the prog IDs in the array so that
    // AddPage() can look them up.

    for (i = 0; i < cauuid.cElems; i++)
    {
        // Copy the page's CLSID

        m_paPageInfo[i].clsid = cauuid.pElems[i];

        // Create the key name by concatenting "ClsID\" with the CLSID

        if (0 == ::StringFromGUID2(cauuid.pElems[i], &wszKey[6], 40))
        {
            hr = SID_E_INTERNAL; // buffer is not long enough
            EXCEPTION_CHECK_GO(hr);
        }

        // Convert that to ANSI

        IfFailGo(::ANSIFromWideStr(wszKey, &pszKey));

        // Open the property page's CLSID key

        lRc = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, pszKey, 0, KEY_READ, &hkey);
        if (ERROR_SUCCESS != lRc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        ::CtlFree(pszKey);
        pszKey = NULL;

        // Read its default value which is the ProgID

        cbProgID = sizeof(szProgID);

        lRc = ::RegQueryValueEx(hkey,
                                NULL,       // get default value
                                NULL,       // reserved
                                &dwType,    // type returned here
                                reinterpret_cast<LPBYTE>(szProgID),
                                &cbProgID); // [in, out] buf size, actual size

        if (ERROR_SUCCESS != lRc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        if ( (REG_SZ != dwType) || (cbProgID < 4) ) // at least X.X + null byte
        {
            hr = SID_E_INTERNAL; // registration error
            EXCEPTION_CHECK_GO(hr);
        }

        // Store the right half of the ProgID as a UNICODE string in our array

        pszProgIDAfterDot = ::strchr(szProgID, '.');
        if (NULL == pszProgIDAfterDot)
        {
            hr = SID_E_INTERNAL; // registration error
        }
        pszProgIDAfterDot++;

        if ('\0' == pszProgIDAfterDot)
        {
            hr = SID_E_INTERNAL; // registration error
        }
        EXCEPTION_CHECK_GO(hr);

        IfFailGo(::WideStrFromANSI(pszProgIDAfterDot, &m_paPageInfo[i].pwszProgID));

        lRc = ::RegCloseKey(hkey);
        if (ERROR_SUCCESS != lRc)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        hkey = NULL;
    }

    m_fHavePageCLSIDs = TRUE;

Error:
    if (NULL != hkey)
    {
        (void)::RegCloseKey(hkey);
    }

    if (NULL != pwszCtlProgID)
    {
        ::CtlFree(pwszCtlProgID);
    }

    if (NULL != pszKey)
    {
        ::CtlFree(pszKey);
    }

    if ( (0 != cauuid.cElems) || (NULL != cauuid.pElems) )
    {
        ::CoTaskMemFree(cauuid.pElems);
    }

    QUICK_RELEASE(piSpecifyPropertyPages);
    RRETURN(hr);
}


HRESULT CPropertySheet::GetCLSIDForPage(BSTR PageName, CLSID *clsidPage)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;
    BOOL    fFound = FALSE;

    // If we don't yet have SnapInControl's array of property page CLSIDs
    // then get it.

    if (!m_fHavePageCLSIDs)
    {
        IfFailGo(GetPageCLSIDs());
    }

    // Look for a page name in the array created by GetPageCLSIDs() and
    // return the corresponding CLSID.

    for (i = 0; (i < m_cPageInfos) && (!fFound); i++)
    {
        if (0 == ::wcscmp(PageName, m_paPageInfo[i].pwszProgID))
        {
            *clsidPage = m_paPageInfo[i].clsid;
            fFound = TRUE;
        }
    }

    if (!fFound)
    {
        hr = SID_E_INVALID_PROPERTY_PAGE_NAME;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



HRESULT CPropertySheet::InternalAddPage
(
    BSTR       PageName,
    ULONG      cObjects,
    IUnknown **apunkObjects,
    VARIANT    Caption,
    VARIANT    UseHelpButton,
    VARIANT    RightToLeft,
    VARIANT    InitData,
    BOOL       fIsInsert,
    short      sPosition
)
{
    HRESULT  hr = S_OK;
    CLSID    clsidPage = CLSID_NULL;
    DWORD    dwFlags = 0;
    short    cxPage = 0;
    short    cyPage = 0;
    LPOLESTR pwszTitle = NULL;
    BOOL     fReceivedCaption = FALSE;

    if (NULL == PageName)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we are not remote or the property sheet is currentyl being displayed
    // then we are in the middle of an
    // IExtendPropertySheet2::CreatePropertyPages call and we must have the
    // IPropertySheetCallback pointer.

    if ( (!m_fWeAreRemote) && (NULL == m_hwndSheet) )
    {
        IfFalseGo(NULL != m_piPropertySheetCallback, SID_E_DETACHED_OBJECT);
    }

    // If the property sheet is currently being displayed then we need to
    // check whether it is OK to add pages at this time. See calls to
    // SetOKToAlterPageCount() in ppgwrap.cpp for when this happens.

    if ( (NULL != m_hwndSheet) && (!m_fOKToAlterPageCount) )
    {
        hr = SID_E_CANT_ALTER_PAGE_COUNT;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(GetCLSIDForPage(PageName, &clsidPage));

    // Determine flags for PROPSHEETPAGE from arguments

    if (ISPRESENT(UseHelpButton))
    {
        if (VT_BOOL != UseHelpButton.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        if (VARIANT_TRUE == UseHelpButton.boolVal)
        {
            dwFlags |= PSP_HASHELP;
        }
    }


    if (ISPRESENT(RightToLeft))
    {
        if (VT_BOOL != RightToLeft.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }

        if (VARIANT_TRUE == RightToLeft.boolVal)
        {
            dwFlags |= PSP_RTLREADING;
        }
    }

    if (ISPRESENT(InitData))
    {
        IfFailGo(CheckVariantForCrossThreadUsage(&InitData));
    }

    if (ISPRESENT(Caption))
    {
        if (VT_BSTR != Caption.vt)
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        pwszTitle = Caption.bstrVal;
        fReceivedCaption = TRUE;
    }

    // Get the page's preferred size. Get title string (for tab caption) if
    // none was passed as a parameter.

    IfFailGo(GetPageInfo(clsidPage, &cxPage, &cyPage,
                         fReceivedCaption ? NULL : &pwszTitle));

    // If we are a remote snap-in (will happen during source debugging) then
    // just accumulate the page data for now. CView::CreatePropertyPages or
    // CSnapIn::CreatePropertyPages will ask for it all when the VB code has
    // finished adding its pages.

    if (m_fWeAreRemote)
    {
        IfFailGo(AddRemotePage(clsidPage, dwFlags, cxPage, cyPage, pwszTitle,
                               cObjects, apunkObjects, InitData));
    }
    else
    {
        IfFailGo(AddLocalPage(clsidPage, dwFlags, cxPage, cyPage, pwszTitle,
                              cObjects, apunkObjects, InitData, FALSE,
                              fIsInsert, sPosition));
    }

Error:
    RRETURN(hr);
}




HRESULT CPropertySheet::AddLocalPage
(
    CLSID      clsidPage,
    DWORD      dwFlags,
    short      cxPage,
    short      cyPage,
    LPOLESTR   pwszTitle,
    ULONG      cObjects,
    IUnknown **apunkObjects,
    VARIANT    InitData,
    BOOL       fIsRemote,
    BOOL       fIsInsert,
    short      sPosition
)
{
    HRESULT                hr = S_OK;
    IUnknown              *punkPropertyPageWrapper = CPropertyPageWrapper::Create(NULL);
    CPropertyPageWrapper  *pPropertyPageWrapper = NULL;
    DLGTEMPLATE           *pDlgTemplate = NULL;
    DLGTEMPLATE          **ppDlgTemplates = NULL;
    HPROPSHEETPAGE         hPropSheetPage = NULL;
    char                  *pszTitle = NULL;

    PROPSHEETPAGE PropSheetPage;
    ::ZeroMemory(&PropSheetPage, sizeof(PropSheetPage));

    IfFalseGo(NULL != punkPropertyPageWrapper, SID_E_OUTOFMEMORY);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkPropertyPageWrapper,
                                                   &pPropertyPageWrapper));

    // CPropertyPage will get the COM property page parameters and return its
    // DLGTEMPLATE pointer.

    IfFailGo(pPropertyPageWrapper->CreatePage(this, clsidPage,
                                              m_fWizard,
                                              m_fConfigWizard,
                                              cObjects, apunkObjects,
                                              m_piSnapIn,
                                              cxPage, cyPage,
                                              InitData,
                                              fIsRemote,
                                              &pDlgTemplate));

    // Add the LPDLGTEMPLATE to our array.

    ppDlgTemplates =
          (DLGTEMPLATE **)::CtlAllocZero((m_cPages + 1) * sizeof(DLGTEMPLATE *));

    IfFalseGo(NULL != ppDlgTemplates, SID_E_OUTOFMEMORY);

    if (NULL != m_ppDlgTemplates)
    {
        ::memcpy(ppDlgTemplates, m_ppDlgTemplates,
                 m_cPages * sizeof(DLGTEMPLATE *));
        ::CtlFree(m_ppDlgTemplates);
    }
    m_ppDlgTemplates = ppDlgTemplates;
    m_ppDlgTemplates[m_cPages] = pDlgTemplate;
    m_cPages++;

    // Create the Win32 property page

    PropSheetPage.dwSize = sizeof(PropSheetPage);
    PropSheetPage.dwFlags = dwFlags;

    // Set additional flags
    // PSP_DLGINDIRECT: use DLGTEMPLATE in memory
    // PSP_USECALLBACK: use callback function (release ref when page is destroyed)

    PropSheetPage.dwFlags |= PSP_DLGINDIRECT | PSP_USECALLBACK;

    if (NULL != pwszTitle)
    {
        PropSheetPage.dwFlags |= PSP_USETITLE;
        IfFailGo(::ANSIFromWideStr(pwszTitle, &pszTitle));
        PropSheetPage.pszTitle = pszTitle;
    }

    if (m_fWizard)
    {
        PropSheetPage.dwFlags |= PSP_HIDEHEADER;
    }

    PropSheetPage.pResource = pDlgTemplate;

    PropSheetPage.pfnDlgProc =
                     reinterpret_cast<DLGPROC>(CPropertyPageWrapper::DialogProc);

    PropSheetPage.pfnCallback =
    reinterpret_cast<LPFNPSPCALLBACK >(CPropertyPageWrapper::PropSheetPageProc);

    PropSheetPage.lParam = reinterpret_cast<LPARAM>(pPropertyPageWrapper);

    hPropSheetPage = ::CreatePropertySheetPage(&PropSheetPage);
    if (NULL == hPropSheetPage)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    // Add the property page to MMC's property sheet or to the running property
    // sheet

    if (NULL != m_hwndSheet)
    {
        if (fIsInsert)
        {
            // Clear last error because we don't know if prop sheet will set it
            ::SetLastError(0);

            if (!::SendMessage(m_hwndSheet, PSM_INSERTPAGE,
                               static_cast<WPARAM>(sPosition - 1),
                               (LPARAM)hPropSheetPage))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                if (S_OK == hr) // didn't set last error
                {
                    hr = E_FAIL;
                }
                EXCEPTION_CHECK_GO(hr);
            }
        }
        else
        {
            ::SendMessage(m_hwndSheet, PSM_ADDPAGE, 0, (LPARAM)hPropSheetPage);
        }
    }
    else
    {
        hr = m_piPropertySheetCallback->AddPage(hPropSheetPage);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    // We release the property page wrapper here. It stays alive because
    // CPropertyPage::CreatePage AddRef()s itself. It removes that ref
    // when the dialog box is destroyed.

    QUICK_RELEASE(punkPropertyPageWrapper);

    if (NULL != pszTitle)
    {
        ::CtlFree(pszTitle);
    }

    if ( FAILED(hr) && (NULL != hPropSheetPage) )
    {
        (void)::DestroyPropertySheetPage(hPropSheetPage);
    }

    if ( (SID_E_DETACHED_OBJECT == hr) || (SID_E_OUTOFMEMORY == hr) )
    {
        EXCEPTION_CHECK(hr);
    }
    RRETURN(hr);
}




HRESULT CPropertySheet::AddRemotePage
(
    CLSID      clsidPage,
    DWORD      dwFlags,
    short      cxPage,
    short      cyPage,
    LPOLESTR   pwszTitle,
    ULONG      cObjects,
    IUnknown **apunkObjects,
    VARIANT    InitData
)
{
    HRESULT             hr = S_OK;
    ULONG               i = 0;
    ULONG               cPages = 0;
    ULONG               cbPages = 0;
    BOOL                fFirstRemotePage = FALSE;
    WIRE_PROPERTYPAGES *pPages = NULL;
    WIRE_PROPERTYPAGE  *pPage = NULL;

    // These variables allow us to determine the actual size of a single page
    // including any alignment padding.

    static WIRE_PROPERTYPAGE aSizingPages[2];
    static ULONG             cbOnePage = (ULONG)(sizeof(aSizingPages) / 2);

    if (NULL != m_pWirePages)
    {
        fFirstRemotePage = FALSE;
        cPages = m_pWirePages->cPages + 1L;
    }
    else
    {
        fFirstRemotePage = TRUE;
        cPages = 1L;
    }

    // Determine the new amount of memory needed and allocate a new block

    cbPages = sizeof(WIRE_PROPERTYPAGES) + (cPages * cbOnePage);

    pPages = (WIRE_PROPERTYPAGES *)::CoTaskMemRealloc(m_pWirePages, cbPages);

    if (NULL == pPages)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set our pages pointer to the newly (re)allocated block.

    m_pWirePages = pPages;

    // If this is the first one then fill in the common info

    if (fFirstRemotePage)
    {
        IfFailGo(InitializeRemotePages(pPages));
    }
    else
    {
        // Not the first time. Just increment the page count.
        pPages->cPages++;
    }

    // Fill in the new page's info

    pPage = &pPages->aPages[cPages - 1L];

    pPage->clsidPage = clsidPage;

    pPage->apunkObjects = (IUnknown **)::CoTaskMemAlloc(cObjects * sizeof(IUnknown));
    if (NULL == pPage->apunkObjects)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(pPage->apunkObjects, apunkObjects, cObjects * sizeof(IUnknown));

    for (i = 0; i < cObjects; i++)
    {
        if (NULL != pPage->apunkObjects[i])
        {
            pPage->apunkObjects[i]->AddRef();
        }
    }

    pPage->cObjects = cObjects;

    ::VariantInit(&pPage->varInitData);
    hr = ::VariantCopy(&pPage->varInitData, &InitData);
    EXCEPTION_CHECK_GO(hr);

    pPage->dwFlags = dwFlags;

    pPage->cx = cxPage;
    pPage->cy = cyPage;
    IfFailGo(::CoTaskMemAllocString(pwszTitle, &pPage->pwszTitle));

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::InitializeRemotePages(WIRE_PROPERTYPAGES *pPages)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;

    pPages->clsidRemotePropertySheetManager = CLSID_MMCPropertySheet;
    pPages->fWizard = m_fWizard;
    pPages->fConfigWizard = m_fConfigWizard;

    IfFailGo(::CoTaskMemAllocString(m_pwszProgIDStart,
                                    &pPages->pwszProgIDStart));
    pPages->cPages = 1L;

    // If this is a configuration wizard then pass the ISnapIn to the
    // remote side so it can fire SnapIn_ConfigurationComplete

    if ( (NULL != m_piSnapIn) && m_fConfigWizard )
    {
        IfFailGo(m_piSnapIn->QueryInterface(IID_IUnknown,
                                  reinterpret_cast<void **>(&pPages->punkExtra)));
    }
    else
    {
        pPages->punkExtra = NULL;
    }

    pPages->apunkObjects = (IUnknown **)::CoTaskMemAlloc(m_cObjects *
                                                         sizeof(IUnknown));
    if (NULL == pPages->apunkObjects)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(pPages->apunkObjects, m_apunkObjects, m_cObjects * sizeof(IUnknown));

    for (i = 0; i < m_cObjects; i++)
    {
        if (NULL != pPages->apunkObjects[i])
        {
            pPages->apunkObjects[i]->AddRef();
        }
    }
    pPages->cObjects = m_cObjects;

    IfFailGo(CopyPageInfosToWire(pPages));

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::CopyPageInfosToWire(WIRE_PROPERTYPAGES *pPages)
{
    HRESULT  hr = S_OK;
    ULONG    i = 0;
    ULONG    cb = 0;
    short    cx = 0;
    short    cy = 0;

    // Make sure we have full page info for all of the snap-in's property pages

    if (!m_fHavePageCLSIDs)
    {
        IfFailGo(GetPageCLSIDs());
    }

    for (i = 0; i < m_cPageInfos; i++)
    {
        IfFailGo(GetPageInfo(m_paPageInfo[i].clsid, &cx, &cy, NULL));
    }

    // Allocate the PAGEINFOs memory

    cb = sizeof(PAGEINFOS) + (sizeof(PAGEINFO) * (m_cPageInfos - 1));

    pPages->pPageInfos = (PAGEINFOS *)::CoTaskMemAlloc(cb);

    if (NULL == pPages->pPageInfos)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::ZeroMemory(pPages->pPageInfos, cb);
    pPages->pPageInfos->cPages = m_cPageInfos;


    // Copy each element from m_paPageInfo to the wire version

    for (i = 0; i < m_cPageInfos; i++)
    {
        // First do do a block copy

        ::memcpy(&pPages->pPageInfos->aPageInfo[i], &m_paPageInfo[i], sizeof(PAGEINFO));

        // NULL out the string pointers in case memory allocation fails so we'll
        // know what needs to be freed

        pPages->pPageInfos->aPageInfo[i].pwszProgID = NULL;
        pPages->pPageInfos->aPageInfo[i].pwszTitle = NULL;

        // Allocate memeory for the strings and copy them

        IfFailGo(::CoTaskMemAllocString(m_paPageInfo[i].pwszProgID,
                              &(pPages->pPageInfos->aPageInfo[i].pwszProgID)));

        IfFailGo(::CoTaskMemAllocString(m_paPageInfo[i].pwszTitle,
                                &(pPages->pPageInfos->aPageInfo[i].pwszTitle)));
    }

Error:
    RRETURN(hr);
}


HRESULT CPropertySheet::CopyPageInfosFromWire(WIRE_PROPERTYPAGES *pPages)
{
    HRESULT hr = S_OK;
    ULONG   i = 0;
    ULONG   cb = pPages->pPageInfos->cPages * sizeof(PAGEINFO);

    // Allocate memory for PAGEINFO array

    m_paPageInfo = (PAGEINFO *)::CtlAllocZero(cb);
    if (NULL == m_paPageInfo)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    m_cPageInfos = pPages->pPageInfos->cPages;

    // Cope each element

    for (i = 0; i < m_cPageInfos; i++)
    {
        // First do do a block copy

        ::memcpy(&m_paPageInfo[i], &pPages->pPageInfos->aPageInfo[i],
                 sizeof(PAGEINFO));

        // NULL out the string pointers in case memory allocation fails so we'll
        // know what needs to be freed

        m_paPageInfo[i].pwszProgID = NULL;
        m_paPageInfo[i].pwszTitle = NULL;

        // Allocate memeory for the strings and copy them. Use CoTaskMemAlloc
        // for title as in the non-remote case we would have received that
        // string from the property page and the destructor code uses
        // CoTaskMemFree.

        IfFailGo(::CoTaskMemAllocString(pPages->pPageInfos->aPageInfo[i].pwszTitle,
                                        &(m_paPageInfo[i].pwszTitle)));

        cb = (::wcslen(pPages->pPageInfos->aPageInfo[i].pwszProgID) + 1) * sizeof(WCHAR);
        m_paPageInfo[i].pwszProgID = (LPOLESTR)::CtlAllocZero(cb);
        if (NULL == m_paPageInfo[i].pwszProgID)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        ::memcpy(m_paPageInfo[i].pwszProgID,
                 pPages->pPageInfos->aPageInfo[i].pwszProgID, cb);

    }

Error:
    m_fHavePageCLSIDs = TRUE;
    RRETURN(hr);
}

HRESULT CPropertySheet::GetPageInfo
(
    CLSID     clsidPage,
    short    *pcx,
    short    *pcy,
    LPOLESTR *ppwszTitle
)
{
    HRESULT           hr = S_OK;
    IPropertyPage    *piPropertyPage = NULL;
    IMMCPropertyPage *piMMCPropertyPage = NULL;
    BOOL              fDlgUnitsSpecified = FALSE;
    ULONG             i = 0;
    BOOL              fFound = FALSE;
    PAGEINFO         *pPageInfo = NULL;

    VARIANT varX;
    ::VariantInit(&varX);

    VARIANT varY;
    ::VariantInit(&varY);

    PROPPAGEINFO PropPageInfo;
    ::ZeroMemory(&PropPageInfo, sizeof(PropPageInfo));

    // Search the PAGEINFO array and check if we already have the info for
    // this page.

    for (i = 0; (i < m_cPageInfos) & (!fFound); i++)
    {
        if (clsidPage == m_paPageInfo[i].clsid)
        {
            fFound = TRUE;
            pPageInfo = &m_paPageInfo[i];
        }
    }

    if (!fFound)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we already have the complete page info then we're done

    IfFalseGo(!pPageInfo->fHaveFullInfo, S_OK);

    // Create an instance of the page so we can get its page info

    hr = ::CoCreateInstance(clsidPage,
                            NULL, // no aggregation,
                            CLSCTX_INPROC_SERVER,
                            IID_IPropertyPage,
                            reinterpret_cast<void **>(&piPropertyPage));
    EXCEPTION_CHECK_GO(hr);


    // Get the page size and put it into the template. Need to set cb otherwise
    // VB will return E_UNEXPECTED.

    PropPageInfo.cb = sizeof(PropPageInfo);

    hr = piPropertyPage->GetPageInfo(&PropPageInfo);
    EXCEPTION_CHECK_GO(hr);

    pPageInfo->pwszTitle = PropPageInfo.pszTitle;

    // First check whether the property page would like to specify its size in
    // dialog units. If not then convert the size from GetPageInfo to dialog
    // units based on the font used by the PropertySheet API

    if (SUCCEEDED(piPropertyPage->QueryInterface(IID_IMMCPropertyPage,
                                reinterpret_cast<void **>(&piMMCPropertyPage))))
    {
        if (SUCCEEDED(piMMCPropertyPage->GetDialogUnitSize(&varY, &varX)))
        {
            if ( (!ISEMPTY(varX)) && (!ISEMPTY(varY)) )
            {
                if ( (SUCCEEDED(::VariantChangeType(&varX, &varX, 0, VT_I2))) &&
                     (SUCCEEDED(::VariantChangeType(&varY, &varY, 0, VT_I2))) )
                {
                    pPageInfo->cx = varX.iVal;
                    pPageInfo->cy = varY.iVal;
                    fDlgUnitsSpecified = TRUE;
                }
            }
        }
    }

    if (!fDlgUnitsSpecified)
    {
        IfFailGo(ConvertToDialogUnits(PropPageInfo.size.cx,
                                      PropPageInfo.size.cy,
                                      &pPageInfo->cx,
                                      &pPageInfo->cy));
    }

    pPageInfo->fHaveFullInfo = TRUE;

Error:
    if (SUCCEEDED(hr))
    {
        *pcx = pPageInfo->cx;
        *pcy = pPageInfo->cy;
        if (NULL != ppwszTitle)
        {
            *ppwszTitle = pPageInfo->pwszTitle;
        }
    }

    // Free any callee allocated memory from IPropertyPage::GetPageInfo() other
    // than the title which is freed by our caller (IPropertySheet::AddPage())

    if (NULL != PropPageInfo.pszDocString)
    {
        ::CoTaskMemFree(PropPageInfo.pszDocString);
    }
    if (NULL != PropPageInfo.pszHelpFile)
    {
        ::CoTaskMemFree(PropPageInfo.pszHelpFile);
    }

    QUICK_RELEASE(piPropertyPage);
    QUICK_RELEASE(piMMCPropertyPage);
    ::VariantClear(&varX);
    ::VariantClear(&varY);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CPropertySheet::ConvertToDialogUnits
//=--------------------------------------------------------------------------=
//
// Parameters:
//    long   xPixels        [in] page width in pixels
//    long   yPixels        [in] page height in pixels
//    short *pxDlgUnits     [out] page width in Win32 PropertySheet dialog units
//    short *pyDlgUnits     [out] page heigth in Win32 PropertySheet dialog units
//
// Output:
//
// Notes:
//
// The size of the page returned from IPropertyPage::GetPageInfo() is in
// pixels. The size passed to the Win32 API CreatePropertySheetPage() must
// be in dialog units. Dialog units are based on the font used in the dialog
// and we have no way of knowing what the property page will be using. The only
// font we can be sure of is the one used by Win32 in the PropertySheet() API.
// This code gets the average character height and width of the Win32 property
// sheet font to do its calculations.

HRESULT CPropertySheet::ConvertToDialogUnits
(
    long   xPixels,
    long   yPixels,
    short *pxDlgUnits,
    short *pyDlgUnits
)
{
    HRESULT      hr = S_OK;

    IfFalseGo(!m_fHavePropSheetCharSizes, S_OK);
    IfFailGo(::GetPropSheetCharSizes(&m_cxPropSheetChar, &m_cyPropSheetChar));
    m_fHavePropSheetCharSizes = TRUE;

Error:

    // Translate pixels to dialog units.
    // After the 1st time this function runs execution should fall through to
    // here every time.

    // Add 1 character to each dimension to account for rounding in the text metric
    // calculations above.

    *pxDlgUnits = static_cast<short>(::MulDiv(xPixels, 4, m_cxPropSheetChar)) + 4;
    *pyDlgUnits = static_cast<short>(::MulDiv(yPixels, 8, m_cyPropSheetChar)) + 8;

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                        IMMCPropertySheet Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CPropertySheet::AddPage
(
    BSTR    PageName,
    VARIANT Caption,
    VARIANT UseHelpButton,
    VARIANT RightToLeft,
    VARIANT InitData
)
{
    HRESULT hr = InternalAddPage(PageName, m_cObjects, m_apunkObjects,
                                 Caption, UseHelpButton, RightToLeft, InitData,
                                 FALSE, // append (don't insert)
                                 0);    // insertion position (not used))
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::AddWizardPage
(
    BSTR       PageName,
    IDispatch *ConfigurationObject,
    VARIANT    UseHelpButton,
    VARIANT    RightToLeft,
    VARIANT    InitData,
    VARIANT    Caption
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkConfigObject = static_cast<IUnknown *>(ConfigurationObject);

    m_fWizard = TRUE;

    hr = InternalAddPage(PageName, 1L, &punkConfigObject,
                         Caption, UseHelpButton, RightToLeft, InitData,
                         FALSE, // append (don't insert)
                         0);    // insertion position (not used))
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::AddPageProvider
(
    BSTR        CLSIDPageProvider,
    long       *hwndSheet,
    IDispatch **PageProvider
)
{
    HRESULT    hr = S_OK;
    BSTR       bstrCLSIDPageProvider = NULL; // Don't SysFreeString this
    CLSID      clsidPageProvider = CLSID_NULL;
    IDispatch *pdispPageProvider = NULL;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = ::CLSIDFromString(CLSIDPageProvider, &clsidPageProvider);
    EXCEPTION_CHECK_GO(hr);

    hr = ::CoCreateInstance(clsidPageProvider,
                            NULL, // no aggregation
                            CLSCTX_SERVER,
                            IID_IDispatch,
                            reinterpret_cast<void **>(&pdispPageProvider));
    EXCEPTION_CHECK_GO(hr);

    *hwndSheet = (long)m_hwndSheet;
    pdispPageProvider->AddRef();
    *PageProvider = pdispPageProvider;

Error:
    QUICK_RELEASE(pdispPageProvider);
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::ChangeCancelToClose()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!::PostMessage(m_hwndSheet, PSM_CANCELTOCLOSE, 0, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::InsertPage
(
    short   Position,
    BSTR    PageName,
    VARIANT Caption,
    VARIANT UseHelpButton,
    VARIANT RightToLeft,
    VARIANT InitData
)
{
    HRESULT hr = InternalAddPage(PageName, m_cObjects, m_apunkObjects,
                                 Caption, UseHelpButton, RightToLeft, InitData,
                                 TRUE, // insert (don't append)
                                 Position);
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::PressButton
(
    SnapInPropertySheetButtonConstants Button
)
{
    HRESULT hr = S_OK;
    WPARAM wpButton = PSBTN_BACK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    switch (Button)
    {
        case siApplyButton:
            wpButton = PSBTN_APPLYNOW;
            break;

        case siBackButton:
            wpButton = PSBTN_BACK;
            break;

        case siCancelButton:
            wpButton = PSBTN_CANCEL;
            break;

        case siFinishButton:
            wpButton = PSBTN_FINISH;
            break;

        case siHelpButton:
            wpButton = PSBTN_HELP;
            break;

        case siNextButton:
            wpButton = PSBTN_NEXT;
            break;

        case siOKButton:
            wpButton = PSBTN_OK;
            break;

        default:
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
            break;
    }

    if (!::PostMessage(m_hwndSheet, PSM_PRESSBUTTON, wpButton, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RecalcPageSizes()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Clear last error because we don't know if prop sheet will set it
    ::SetLastError(0);

    if (!::SendMessage(m_hwndSheet, PSM_RECALCPAGESIZES, 0, 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (S_OK == hr) // didn't set last error
        {
            hr = E_FAIL;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RemovePage(short Position)
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the property sheet is currently being displayed then we need to
    // check whether it is OK to remove pages at this time. See calls to
    // SetOKToAlterPageCount() in ppgwrap.cpp for when this happens.

    if (m_fOKToAlterPageCount)
    {
        hr = SID_E_CANT_ALTER_PAGE_COUNT;
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndSheet, PSM_REMOVEPAGE,
                  static_cast<WPARAM>(Position - 1), 0);

Error:
    RRETURN(hr);
}



STDMETHODIMP CPropertySheet::ActivatePage(short Position)
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!::SendMessage(m_hwndSheet, PSM_SETCURSEL,
                       static_cast<WPARAM>(Position - 1), 0))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (S_OK == hr) // didn't set last error
        {
            hr = E_FAIL;
        }
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::SetFinishButtonText(BSTR Text)
{
    HRESULT  hr = S_OK;
    char    *pszText = NULL;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::ANSIFromWideStr(Text, &pszText));

    ::SendMessage(m_hwndSheet, PSM_SETFINISHTEXT, 0, (LPARAM)pszText);

Error:
    if (NULL != pszText)
    {
        CtlFree(pszText);
    }
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::SetTitle
(
    BSTR         Text,
    VARIANT_BOOL UsePropertiesForInTitle
)
{
    HRESULT  hr = S_OK;
    char    *pszText = NULL;
    WPARAM   wParam = 0;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::ANSIFromWideStr(Text, &pszText));

    if (VARIANT_TRUE == UsePropertiesForInTitle)
    {
        wParam = PSH_PROPTITLE;
    }

    ::SendMessage(m_hwndSheet, PSM_SETTITLE, wParam, (LPARAM)pszText);

Error:
    if (NULL != pszText)
    {
        CtlFree(pszText);
    }
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::SetWizardButtons
(
    VARIANT_BOOL              EnableBack,
    WizardPageButtonConstants NextOrFinish
)
{
    HRESULT hr = S_OK;
    LPARAM  lParam = 0;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (VARIANT_TRUE == EnableBack)
    {
        lParam |= PSWIZB_BACK;
    }

    switch (NextOrFinish)
    {
        case EnabledNextButton:
            lParam |= PSWIZB_NEXT;
            break;

        case EnabledFinishButton:
            lParam |= PSWIZB_FINISH;
            break;

        case DisabledFinishButton:
            lParam |= PSWIZB_DISABLEDFINISH;
            break;
    }

    if (!::PostMessage(m_hwndSheet, PSM_SETWIZBUTTONS, 0, (LPARAM)lParam))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::GetPagePosition(long hwndPage, short *psPosition)
{
    HRESULT hr = S_OK;
    LRESULT lrIndex = 0;

    *psPosition = 0;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Clear last error because we don't know if prop sheet will set it
    ::SetLastError(0);

    lrIndex = ::SendMessage(m_hwndSheet, PSM_HWNDTOINDEX,
                            (WPARAM)::GetParent((HWND)hwndPage), 0);
    if ((LRESULT)-1 == lrIndex)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (S_OK == hr) // didn't set last error
        {
            hr = E_INVALIDARG; // most likely reason for failure
        }
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        *psPosition = (short)lrIndex + 1;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RestartWindows()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndSheet, PSM_RESTARTWINDOWS, 0, 0);

Error:
    RRETURN(hr);
}


STDMETHODIMP CPropertySheet::RebootSystem()
{
    HRESULT hr = S_OK;

    if (NULL == m_hwndSheet)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    ::SendMessage(m_hwndSheet, PSM_REBOOTSYSTEM, 0, 0);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                  IRemotePropertySheetManager Methods
//=--------------------------------------------------------------------------=



//=--------------------------------------------------------------------------=
// CPropertySheet::CreateRemotePages             [IRemotePropertySheetManager]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IPropertySheetCallback *piPropertySheetCallback [in] These 3 params are
//   LONG_PTR                handle,                 [in] all from MMC's
//   IDataObject            *piDataObject,           [in] CreatePropertyPages
//                                                        call to the proxy
//
//   WIRE_PROPERTYPAGES     *pPages                  [in] This is returned
//                                                        from the remote snap-in
//
// Output:
//
// Notes:
//
// This class does double duty. When not running under source debugging, it
// implements our IMMCPropertSheet interface. When under source debugging it also
// serves as the remote property sheet manager required by the proxy. The proxy
// receives the CLSID of an object that implements this interface and it will
// CoCreateInstance that object. It makes this call passing the accumulated
// page descriptors that the remote snap-in collected from all of the VB code's
// PropertySheet.AddPage (or PropertySheet.AddWizardPage) calls. In this case
// this class will be running as an in=proc standalone object without the rest
// of the runtime. This method will make the AddPage (or AddWizardPage) calls
// on the proxy side (in the MMC process) so that the IPropertySheetCallback
// calls will be made in the right place. The objects passed to
// IPropertPage::SetObjects (see ppgwrap.cpp) will be remoted as well. When
// CPropertyPageWrapper::CreatePage CoCreateInstances the VB property page
// that will be handled by the class factory registered by VB in the IDE.
//
//

STDMETHODIMP CPropertySheet::CreateRemotePages
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    IDataObject            *piDataObject,
    WIRE_PROPERTYPAGES     *pPages
)
{
    HRESULT            hr = S_OK;
    ULONG              i = 0;
    ULONG              cb = 0;
    WIRE_PROPERTYPAGE *pPage = NULL;

    // Check for NULL as the snap-in may not have added any pages.

    IfFalseGo(NULL != pPages, S_FALSE);

    // Copy the ProgIDStart which will be used to find the CLSID of any
    // pages added while the sheet is displayed if the property page
    // calls MMCPropertySheet.AddPage or MMCPropertySheet.InsertPage.

    if (NULL != pPages->pwszProgIDStart)
    {
        IfFailGo(::CoTaskMemAllocString(pPages->pwszProgIDStart,
                                        &m_pwszProgIDStart));
    }

    // Copy the objects for which the sheet is being displayed

    if (NULL != pPages->apunkObjects)
    {
        cb = pPages->cObjects * sizeof(IUnknown);
        m_apunkObjects = (IUnknown **)CtlAllocZero(cb);
        if (NULL == m_apunkObjects)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        m_cObjects = pPages->cObjects;

        ::memcpy(m_apunkObjects, pPages->apunkObjects, cb);

        for (i = 0; i < m_cObjects; i++)
        {
            if (NULL != m_apunkObjects[i])
            {
                m_apunkObjects[i]->AddRef();
            }
        }
    }

    // Copy the CLSIDs and ProgIDs of all of the snap-in's property pages.
    // These will be used to find the the CLSID of any
    // pages added while the sheet is displayed if the property page
    // calls MMCPropertySheet.AddPage or MMCPropertySheet.InsertPage.

    IfFailGo(CopyPageInfosFromWire(pPages));

    // Get ISnapIn on the remote snap-in if available. If this is not a wizard
    // then it won't be there.

    if (NULL != pPages->punkExtra)
    {
        IfFailGo(pPages->punkExtra->QueryInterface(IID_ISnapIn,
                                         reinterpret_cast<void**>(&m_piSnapIn)));
    }

    // Store the callback for now. We'll release it at the end of this function

    RELEASE(m_piPropertySheetCallback);
    piPropertySheetCallback->AddRef();
    m_piPropertySheetCallback = piPropertySheetCallback;

    // Store the handle

    m_handle = handle;

    // Determine whether we are managing a wizard and whether is ia
    // configuration wizard (as opposed to a wizard invoked programmtically
    // by the snap-in using View.PropertySheetProvider

    m_fWizard = pPages->fWizard;
    m_fConfigWizard = pPages->fConfigWizard;

    // Create all of the pages and add them to MMC's property sheet

    for (i = 0, pPage = &pPages->aPages[0]; i < pPages->cPages; i++, pPage++)
    {
        IfFailGo(AddLocalPage(pPage->clsidPage,
                              pPage->dwFlags,
                              pPage->cx,
                              pPage->cy,
                              pPage->pwszTitle,
                              pPage->cObjects,
                              pPage->apunkObjects,
                              pPage->varInitData,
                              TRUE,  // remote
                              FALSE, // append (don't insert)
                              0));   // insertion position (not used)
    }

Error:
    RELEASE(m_piPropertySheetCallback);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CPropertySheet::InternalQueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IID_IMMCPropertySheet == riid)
    {
        *ppvObjOut = static_cast<IMMCPropertySheet *>(this);
        ExternalAddRef();
        return S_OK;
    }
    if (IID_IRemotePropertySheetManager == riid)
    {
        *ppvObjOut = static_cast<IRemotePropertySheetManager *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\reginfo.cpp ===
//=--------------------------------------------------------------------------=
// reginfo.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CRegInfo class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "reginfo.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CRegInfo::CRegInfo(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_REGINFO,
                            static_cast<IRegInfo *>(this),
                            static_cast<CRegInfo *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_RegInfo,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CRegInfo::~CRegInfo()
{
    FREESTRING(m_bstrDisplayName);
    FREESTRING(m_bstrStaticNodeTypeGUID);
    RELEASE(m_piNodeTypes);
    RELEASE(m_piExtendedSnapIns);
    InitMemberVariables();
}

void CRegInfo::InitMemberVariables()
{
    m_bstrDisplayName = NULL;
    m_bstrStaticNodeTypeGUID = NULL;
    m_StandAlone = VARIANT_FALSE;
    m_piNodeTypes = NULL;
    m_piExtendedSnapIns = NULL;
}

IUnknown *CRegInfo::Create(IUnknown * punkOuter)
{
    CRegInfo *pRegInfo = New CRegInfo(punkOuter);
    if (NULL == pRegInfo)
    {
        return NULL;
    }
    else
    {
        return pRegInfo->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CRegInfo::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    IfFailRet(PersistBstr(&m_bstrStaticNodeTypeGUID, L"", OLESTR("StaticNodeTypeGUID")));

    IfFailRet(PersistSimpleType(&m_StandAlone, VARIANT_FALSE, OLESTR("StandAlone")));

    IfFailRet(PersistObject(&m_piNodeTypes, CLSID_NodeTypes,
                            OBJECT_TYPE_NODETYPES, IID_INodeTypes,
                            OLESTR("NodeTypes")));

    IfFailRet(PersistObject(&m_piExtendedSnapIns, CLSID_ExtendedSnapIns,
                            OBJECT_TYPE_EXTENDEDSNAPINS, IID_IExtendedSnapIns,
                            OLESTR("ExtendedSnapIns")));
    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CRegInfo::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IRegInfo == riid)
    {
        *ppvObjOut = static_cast<IRegInfo *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\pshtprov.h ===
//=--------------------------------------------------------------------------=
// pshtprov.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCPropertySheetProvider class definition - implements
// MMCPropertySheetProvider object
//
//=--------------------------------------------------------------------------=

#ifndef _PSHTPROV_DEFINED_
#define _PSHTPROV_DEFINED_

#include "view.h"

class CMMCPropertySheetProvider : public CSnapInAutomationObject,
                                  public IMMCPropertySheetProvider,
                                  public IMessageFilter
{
    protected:
        CMMCPropertySheetProvider(IUnknown *punkOuter);
        ~CMMCPropertySheetProvider();

    public:
        static IUnknown *Create(IUnknown * punk);
        
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        HRESULT SetProvider(IPropertySheetProvider *piPropertySheetProvider,
                            CView                  *pView);

    // IMMCPropertySheetProvider
    protected:
        STDMETHOD(CreatePropertySheet)(
                           BSTR                              Title, 
                           SnapInPropertySheetTypeConstants  Type,
                           VARIANT                           Objects,
                           VARIANT                           UsePropertiesForInTitle,
                           VARIANT                           UseApplyButton);

        STDMETHOD(AddPrimaryPages)(VARIANT_BOOL InScopePane);
        STDMETHOD(AddExtensionPages)();
        STDMETHOD(FindPropertySheet)(VARIANT       Objects,
                                     VARIANT_BOOL *pfvarFound);
        STDMETHOD(Show)(int     Page,
                        VARIANT hwnd);
        STDMETHOD(Clear)();

    // IMessageFilter
    // An OLE message filter is used during debugging in order to allow keys
    // and mouse clicks to pass between processes. See pshtprov.cpp for more info.
        
        STDMETHOD_(DWORD, HandleInComingCall)( 
            /* [in] */ DWORD dwCallType,
            /* [in] */ HTASK htaskCaller,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ LPINTERFACEINFO lpInterfaceInfo);

        STDMETHOD_(DWORD, RetryRejectedCall)( 
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwRejectType);

        STDMETHOD_(DWORD, MessagePending)( 
            /* [in] */ HTASK htaskCallee,
            /* [in] */ DWORD dwTickCount,
            /* [in] */ DWORD dwPendingType);

    // CUnknownObject overrides
    protected:
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IPropertySheet
    private:

        void InitMemberVariables();

        IPropertySheetProvider *m_piPropertySheetProvider; // MMC interface

        IUnknown               *m_punkView;     // IUnknown of CView
        IDataObject            *m_piDataObject; // IDataObject of objects for
                                                // which sheet is displayed
        IComponent             *m_piComponent;  // IComponent of CView
        CView                  *m_pView;        // ptr to CView
        BOOL                    m_fHaveSheet;   // TRUE=CreatePropertySheet was
                                                // called and succeeded
        BOOL                    m_fWizard;      // TRUE=this is a wizard
};



DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCPropertySheetProvider,       // name
                                NULL,                           // clsid
                                NULL,                           // objname
                                NULL,                           // lblname
                                NULL,                           // creation function
                                TLIB_VERSION_MAJOR,             // major version
                                TLIB_VERSION_MINOR,             // minor version
                                &IID_IMMCPropertySheetProvider, // dispatch IID
                                NULL,                           // event IID
                                HELP_FILENAME,                  // help file
                                TRUE);                          // thread safe


#endif _PSHTPROV_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resview.cpp ===
//=--------------------------------------------------------------------------=
// resview.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultView class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "resview.h"
#include "snapin.h"
#include "views.h"
#include "dataobj.h"
#include "taskpad.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CResultView::CResultView(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_RESULTVIEW,
                           static_cast<IResultView *>(this),
                           static_cast<CResultView *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CResultView::~CResultView()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_pdispControl);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrDisplayString);
    RELEASE(m_piListView);
    RELEASE(m_piTaskpad);
    RELEASE(m_piMessageView);
    FREESTRING(m_bstrDefaultItemTypeGUID);
    FREESTRING(m_bstrDefaultDataFormat);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    
    InitMemberVariables();
}

void CResultView::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_piScopePaneItem = NULL;
    m_pdispControl = NULL;
    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_Type = siUnknown;
    m_bstrDisplayString = NULL;
    m_piListView = NULL;
    m_piTaskpad = NULL;
    m_piMessageView = NULL;

    ::VariantInit(&m_varTag);

    m_bstrDefaultItemTypeGUID = NULL;
    m_bstrDefaultDataFormat = NULL;
    m_AlwaysCreateNewOCX = VARIANT_FALSE;
    m_pSnapIn = NULL;
    m_pScopePaneItem = NULL;
    m_pMMCListView = NULL;
    m_pMessageView = NULL;
    m_fInActivate = FALSE;
    m_fInInitialize = FALSE;
    m_ActualResultViewType = siUnknown;
    m_pwszActualDisplayString = NULL;
}

IUnknown *CResultView::Create(IUnknown * punkOuter)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkResultView = NULL;
    IUnknown     *punkListView = NULL;
    IUnknown     *punkTaskpad = NULL;
    IUnknown     *punkMessageView = NULL;

    CResultView *pResultView = New CResultView(punkOuter);

    if (NULL == pResultView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    punkResultView = pResultView->PrivateUnknown();

    // Create contained objects

    punkListView = CMMCListView::Create(NULL);
    if (NULL == punkListView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkListView->QueryInterface(IID_IMMCListView,
                        reinterpret_cast<void **>(&pResultView->m_piListView)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pResultView->m_piListView, &pResultView->m_pMMCListView));
    pResultView->m_pMMCListView->SetResultView(pResultView);

    punkTaskpad = CTaskpad::Create(NULL);
    if (NULL == punkTaskpad)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkTaskpad->QueryInterface(IID_ITaskpad,
                         reinterpret_cast<void **>(&pResultView->m_piTaskpad)));

    punkMessageView = CMessageView::Create(NULL);
    if (NULL == punkMessageView)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMessageView->QueryInterface(IID_IMMCMessageView,
                    reinterpret_cast<void **>(&pResultView->m_piMessageView)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pResultView->m_piMessageView,
                                                   &pResultView->m_pMessageView));
    pResultView->m_pMessageView->SetResultView(pResultView);

Error:
    QUICK_RELEASE(punkListView);
    QUICK_RELEASE(punkTaskpad);
    QUICK_RELEASE(punkMessageView);
    if (FAILED(hr))
    {
        RELEASE(punkResultView);
    }
    return punkResultView;
}


void CResultView::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}

void CResultView::SetScopePaneItem(CScopePaneItem *pScopePaneItem)
{
    m_pScopePaneItem = pScopePaneItem;
    m_piScopePaneItem = static_cast<IScopePaneItem *>(pScopePaneItem);
}


HRESULT CResultView::SetControl(IUnknown *punkControl)
{
    HRESULT hr = S_OK;
    
    RELEASE(m_pdispControl);
    IfFailGo(punkControl->QueryInterface(IID_IDispatch,
                                         reinterpret_cast<void **>(&m_pdispControl)));
    m_pSnapIn->GetResultViews()->FireInitializeControl(static_cast<IResultView *>(this));

Error:
    RRETURN(hr);
}

HRESULT CResultView::SetActualDisplayString
(
    LPOLESTR pwszDisplayString
)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszDisplayString,
                                   &m_pwszActualDisplayString));
}

//=--------------------------------------------------------------------------=
//                          IResultView Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CResultView::get_Control(IDispatch **ppiDispatch)
{
    HRESULT          hr = S_OK;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;
    IUnknown        *punkControl = NULL;
    IConsole2       *piConsole2 = NULL; // Not AddRef()ed

    if (NULL == m_pdispControl)
    {
        // Control is not cached. This could happen if the snap-in is requesting
        // it too early, in a non-OCX ResultView, or because MMC did not send
        // MMCN_INITOCX because it has cached the control so CView never called
        // CResultView::SetControl() to pass us the IUnknown. In this case we
        // need to ask MMC for the control's IUnknown.

        hr = SID_E_INTERNAL; // Assume error getting IConsole2 from owning CView

        IfFalseGo(NULL != m_pScopePaneItem, hr);
        pScopePaneItems = m_pScopePaneItem->GetParent();
        IfFalseGo(NULL != pScopePaneItems, hr);
        pView = pScopePaneItems->GetParentView();
        IfFalseGo(NULL != pView, hr);
        piConsole2 = pView->GetIConsole2();
        IfFalseGo(NULL != piConsole2, hr);

        IfFailGo(piConsole2->QueryResultView(&punkControl));
        IfFailGo(punkControl->QueryInterface(IID_IDispatch,
                                   reinterpret_cast<void **>(&m_pdispControl)));
    }

    m_pdispControl->AddRef();
    *ppiDispatch = m_pdispControl;
    
Error:
    EXCEPTION_CHECK(hr);
    QUICK_RELEASE(punkControl);
    RRETURN(hr);
}


STDMETHODIMP CResultView::SetDescBarText(BSTR Text)
{
    HRESULT          hr = SID_E_DETACHED_OBJECT;
    CScopePaneItems *pScopePaneItems = NULL;
    CView           *pView = NULL;
    IResultData     *piResultData = NULL; // Not AddRef()ed

    IfFalseGo(NULL != m_pScopePaneItem, hr);
    pScopePaneItems = m_pScopePaneItem->GetParent();
    IfFalseGo(NULL != pScopePaneItems, hr);
    pView = pScopePaneItems->GetParentView();
    IfFalseGo(NULL != pView, hr);
    piResultData = pView->GetIResultData();
    IfFalseGo(NULL != piResultData, hr);

    if (NULL == Text)
    {
        Text = L"";
    }

    hr = piResultData->SetDescBarText(static_cast<LPOLESTR>(Text));

Error:
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CResultView::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IResultView == riid)
    {
        *ppvObjOut = static_cast<IResultView *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CResultView::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piListView));
    IfFailRet(SetObjectHost(m_piTaskpad));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resviews.cpp ===
//=--------------------------------------------------------------------------=
// resviews.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultViews class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "resviews.h"

// for ASSERT and FAIL
//
SZTHISFILE

VARTYPE CResultViews::m_rgvtInitialize[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiInitialize =
{
    DISPID_RESULTVIEWS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};

VARTYPE CResultViews::m_rgvtTerminate[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiTerminate =
{
    DISPID_RESULTVIEWS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};

VARTYPE CResultViews::m_rgvtInitializeControl[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiInitializeControl =
{
    DISPID_RESULTVIEWS_EVENT_INITIALIZE_CONTROL,
    sizeof(m_rgvtInitializeControl) / sizeof(m_rgvtInitializeControl[0]),
    m_rgvtInitializeControl
};


VARTYPE CResultViews::m_rgvtActivate[1] = { VT_UNKNOWN };

EVENTINFO CResultViews::m_eiActivate =
{
    DISPID_RESULTVIEWS_EVENT_ACTIVATE,
    sizeof(m_rgvtActivate) / sizeof(m_rgvtActivate[0]),
    m_rgvtActivate
};

VARTYPE CResultViews::m_rgvtDeactivate[2] =
{
    VT_UNKNOWN,
    VT_BOOL | VT_BYREF
};

EVENTINFO CResultViews::m_eiDeactivate =
{
    DISPID_RESULTVIEWS_EVENT_DEACTIVATE,
    sizeof(m_rgvtDeactivate) / sizeof(m_rgvtDeactivate[0]),
    m_rgvtDeactivate
};



VARTYPE CResultViews::m_rgvtColumnClick[3] =
{
    VT_UNKNOWN,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiColumnClick =
{
    DISPID_RESULTVIEWS_EVENT_COLUMN_CLICK,
    sizeof(m_rgvtColumnClick) / sizeof(m_rgvtColumnClick[0]),
    m_rgvtColumnClick
};


VARTYPE CResultViews::m_rgvtListItemDblClick[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CResultViews::m_eiListItemDblClick =
{
    DISPID_RESULTVIEWS_EVENT_LISTITEM_DBLCLICK,
    sizeof(m_rgvtListItemDblClick) / sizeof(m_rgvtListItemDblClick[0]),
    m_rgvtListItemDblClick
};


VARTYPE CResultViews::m_rgvtScopeItemDblClick[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BYREF | VT_BOOL
};

EVENTINFO CResultViews::m_eiScopeItemDblClick =
{
    DISPID_RESULTVIEWS_EVENT_SCOPEITEM_DBLCLICK,
    sizeof(m_rgvtScopeItemDblClick) / sizeof(m_rgvtScopeItemDblClick[0]),
    m_rgvtScopeItemDblClick
};


VARTYPE CResultViews::m_rgvtPropertyChanged[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_VARIANT
};

EVENTINFO CResultViews::m_eiPropertyChanged =
{
    DISPID_RESULTVIEWS_EVENT_PROPERTY_CHANGED,
    sizeof(m_rgvtPropertyChanged) / sizeof(m_rgvtPropertyChanged[0]),
    m_rgvtPropertyChanged
};


VARTYPE CResultViews::m_rgvtTaskClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiTaskClick =
{
    DISPID_RESULTVIEWS_EVENT_TASK_CLICK,
    sizeof(m_rgvtTaskClick) / sizeof(m_rgvtTaskClick[0]),
    m_rgvtTaskClick
};


VARTYPE CResultViews::m_rgvtListpadButtonClick[1] =
{
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiListpadButtonClick =
{
    DISPID_RESULTVIEWS_EVENT_LISTPAD_BUTTON_CLICK,
    sizeof(m_rgvtListpadButtonClick) / sizeof(m_rgvtListpadButtonClick[0]),
    m_rgvtListpadButtonClick
};


VARTYPE CResultViews::m_rgvtTaskNotify[3] =
{
    VT_UNKNOWN,
    VT_VARIANT,
    VT_VARIANT
};

EVENTINFO CResultViews::m_eiTaskNotify =
{
    DISPID_RESULTVIEWS_EVENT_TASK_NOTIFY,
    sizeof(m_rgvtTaskNotify) / sizeof(m_rgvtTaskNotify[0]),
    m_rgvtTaskNotify
};


VARTYPE CResultViews::m_rgvtHelp[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiHelp =
{
    DISPID_RESULTVIEWS_EVENT_HELP,
    sizeof(m_rgvtHelp) / sizeof(m_rgvtHelp[0]),
    m_rgvtHelp
};


VARTYPE CResultViews::m_rgvtItemRename[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_BSTR
};

EVENTINFO CResultViews::m_eiItemRename =
{
    DISPID_RESULTVIEWS_EVENT_ITEM_RENAME,
    sizeof(m_rgvtItemRename) / sizeof(m_rgvtItemRename[0]),
    m_rgvtItemRename
};


VARTYPE CResultViews::m_rgvtItemViewChange[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_VARIANT
};

EVENTINFO CResultViews::m_eiItemViewChange =
{
    DISPID_RESULTVIEWS_EVENT_ITEM_VIEW_CHANGE,
    sizeof(m_rgvtItemViewChange) / sizeof(m_rgvtItemViewChange[0]),
    m_rgvtItemViewChange
};


VARTYPE CResultViews::m_rgvtFindItem[7] =
{
    VT_UNKNOWN,
    VT_BSTR,
    VT_I4,
    VT_BOOL,
    VT_BOOL,
    VT_BYREF | VT_BOOL,
    VT_BYREF | VT_I4
};

EVENTINFO CResultViews::m_eiFindItem =
{
    DISPID_RESULTVIEWS_EVENT_FIND_ITEM,
    sizeof(m_rgvtFindItem) / sizeof(m_rgvtFindItem[0]),
    m_rgvtFindItem
};


VARTYPE CResultViews::m_rgvtCacheHint[3] =
{
    VT_UNKNOWN,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiCacheHint =
{
    DISPID_RESULTVIEWS_EVENT_CACHE_HINT,
    sizeof(m_rgvtCacheHint) / sizeof(m_rgvtCacheHint[0]),
    m_rgvtCacheHint
};


VARTYPE CResultViews::m_rgvtSortItems[3] =
{
    VT_UNKNOWN,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiSortItems =
{
    DISPID_RESULTVIEWS_EVENT_SORT_ITEMS,
    sizeof(m_rgvtSortItems) / sizeof(m_rgvtSortItems[0]),
    m_rgvtSortItems
};


VARTYPE CResultViews::m_rgvtDeselectAll[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiDeselectAll =
{
    DISPID_RESULTVIEWS_EVENT_DESELECT_ALL,
    sizeof(m_rgvtDeselectAll) / sizeof(m_rgvtDeselectAll[0]),
    m_rgvtDeselectAll
};


VARTYPE CResultViews::m_rgvtCompareItems[5] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_I4,
    VT_BYREF | VT_VARIANT
};

EVENTINFO CResultViews::m_eiCompareItems =
{
    DISPID_RESULTVIEWS_EVENT_COMPARE_ITEMS,
    sizeof(m_rgvtCompareItems) / sizeof(m_rgvtCompareItems[0]),
    m_rgvtCompareItems
};


VARTYPE CResultViews::m_rgvtGetVirtualItemData[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiGetVirtualItemData =
{
    DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DATA,
    sizeof(m_rgvtGetVirtualItemData) / sizeof(m_rgvtGetVirtualItemData[0]),
    m_rgvtGetVirtualItemData
};


VARTYPE CResultViews::m_rgvtGetVirtualItemDisplayInfo[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CResultViews::m_eiGetVirtualItemDisplayInfo =
{
    DISPID_RESULTVIEWS_EVENT_GET_VIRTUAL_ITEM_DISPLAY_INFO,
    sizeof(m_rgvtGetVirtualItemDisplayInfo) / sizeof(m_rgvtGetVirtualItemDisplayInfo[0]),
    m_rgvtGetVirtualItemDisplayInfo
};



VARTYPE CResultViews::m_rgvtColumnsChanged[3] =
{
    VT_UNKNOWN,
    VT_VARIANT,
    VT_BOOL | VT_BYREF
};

EVENTINFO CResultViews::m_eiColumnsChanged =
{
    DISPID_RESULTVIEWS_EVENT_COLUMNS_CHANGED,
    sizeof(m_rgvtColumnsChanged) / sizeof(m_rgvtColumnsChanged[0]),
    m_rgvtColumnsChanged
};



VARTYPE CResultViews::m_rgvtFilterChange[3] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_I4
};

EVENTINFO CResultViews::m_eiFilterChange =
{
    DISPID_RESULTVIEWS_EVENT_FILTER_CHANGE,
    sizeof(m_rgvtFilterChange) / sizeof(m_rgvtFilterChange[0]),
    m_rgvtFilterChange
};



VARTYPE CResultViews::m_rgvtFilterButtonClick[6] =
{
    VT_UNKNOWN,
    VT_UNKNOWN,
    VT_I4,
    VT_I4,
    VT_I4,
    VT_I4
};

EVENTINFO CResultViews::m_eiFilterButtonClick =
{
    DISPID_RESULTVIEWS_EVENT_FILTER_BUTTON_CLICK,
    sizeof(m_rgvtFilterButtonClick) / sizeof(m_rgvtFilterButtonClick[0]),
    m_rgvtFilterButtonClick
};




#pragma warning(disable:4355)  // using 'this' in constructor

CResultViews::CResultViews(IUnknown *punkOuter) :
   CSnapInCollection<IResultView, ResultView, IResultViews>(
                     punkOuter,
                     OBJECT_TYPE_RESULTVIEWS,
                     static_cast<IResultViews *>(this),
                     static_cast<CResultViews *>(this),
                     CLSID_ResultView,
                     OBJECT_TYPE_RESULTVIEW,
                     IID_IResultView,
                     NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CResultViews::InitMemberVariables()
{
    m_pSnapIn = NULL;
    m_pScopePaneItem = NULL;
}

CResultViews::~CResultViews()
{
    InitMemberVariables();
}

IUnknown *CResultViews::Create(IUnknown * punkOuter)
{
    CResultViews *pResultViews = New CResultViews(punkOuter);
    if (NULL == pResultViews)
    {
        return NULL;
    }
    else
    {
        return pResultViews->PrivateUnknown();
    }
}


void CResultViews::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}

void CResultViews::SetScopePaneItem(CScopePaneItem *pScopePaneItem)
{
    m_pScopePaneItem = pScopePaneItem;
}

void CResultViews::FireInitialize(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_Initialize\r\n");

    FireEvent(&m_eiInitialize, piResultView);
}

void CResultViews::FireTerminate(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_Terminate\r\n");

    FireEvent(&m_eiTerminate, piResultView);
}

void CResultViews::FireInitializeControl(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_InitializeControl\r\n");

    FireEvent(&m_eiInitializeControl, piResultView);
}

void CResultViews::FireActivate(IResultView *piResultView)
{
    DebugPrintf("Firing ResultViews_Activate\r\n");

    FireEvent(&m_eiActivate, piResultView);
}

void CResultViews::FireDeactivate(IResultView *piResultView, BOOL *pfKeep)
{
    VARIANT_BOOL fvarKeep = VARIANT_FALSE;

    DebugPrintf("Firing ResultViews_Deactivate\r\n");

    FireEvent(&m_eiDeactivate, piResultView, &fvarKeep);

    if (VARIANT_TRUE == fvarKeep)
    {
        *pfKeep = TRUE;
    }
    else
    {
        *pfKeep = FALSE;
    }
}



void CResultViews::FireColumnClick(IResultView              *piResultView,
                                   long                      lColumn,
                                   SnapInSortOrderConstants  SortOption)
{
    DebugPrintf("Firing ResultViews_ColumnClick\r\n");

    FireEvent(&m_eiColumnClick, piResultView, lColumn, SortOption);
}


void CResultViews::FireListItemDblClick(IResultView  *piResultView,
                                        IMMCListItem *piMMCListItem,
                                        BOOL         *pfDoDefault)
{
    VARIANT_BOOL varfDoDefault = (*pfDoDefault) ? VARIANT_TRUE : VARIANT_FALSE;

    DebugPrintf("Firing ResultViews_ListItemDblClick\r\n");

    FireEvent(&m_eiListItemDblClick, piResultView, piMMCListItem, &varfDoDefault);

    *pfDoDefault = (VARIANT_TRUE == varfDoDefault) ? TRUE : FALSE;
}


void CResultViews::FireScopeItemDblClick(IResultView *piResultView,
                                         IScopeItem  *piScopeItem,
                                         BOOL        *pfDoDefault)
{
    VARIANT_BOOL varfDoDefault = (*pfDoDefault) ? VARIANT_TRUE : VARIANT_FALSE;

    DebugPrintf("Firing ResultViews_ScopeItemDblClick\r\n");

    FireEvent(&m_eiScopeItemDblClick, piResultView, piScopeItem, &varfDoDefault);

    *pfDoDefault = (VARIANT_TRUE == varfDoDefault) ? TRUE : FALSE;
}


void CResultViews::FirePropertyChanged
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem,
    VARIANT       Data
)
{
    DebugPrintf("Firing ResultViews_PropertyChanged\r\n");

    FireEvent(&m_eiPropertyChanged, piResultView, piMMCListItem, Data);
}


void CResultViews::FireTaskClick
(
    IResultView  *piResultView,
    ITask        *piTask
)
{
    DebugPrintf("Firing ResultViews_TaskClicked\r\n");

    FireEvent(&m_eiTaskClick, piResultView, piTask);
}


void CResultViews::FireListpadButtonClick
(
    IResultView  *piResultView
)
{
    DebugPrintf("Firing ResultViews_FireListpadButtonClick\r\n");

    FireEvent(&m_eiListpadButtonClick, piResultView);
}


void CResultViews::FireTaskNotify
(
    IResultView  *piResultView,
    VARIANT       arg,
    VARIANT       param
)
{
    DebugPrintf("Firing ResultViews_TaskNotify\r\n");

    FireEvent(&m_eiTaskNotify, piResultView, arg, param);
}



void CResultViews::FireHelp
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem
)
{
    DebugPrintf("Firing ResultViews_Help\r\n");

    FireEvent(&m_eiHelp, piResultView, piMMCListItem);
}


void CResultViews::FireItemRename
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem,
    BSTR          bstrNewName
)
{
    DebugPrintf("Firing ResultViews_ItemRename\r\n");

    FireEvent(&m_eiItemRename, piResultView, piMMCListItem, bstrNewName);
}


void CResultViews::FireItemViewChange
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem,
    VARIANT       varHint
)
{
    DebugPrintf("Firing ResultViews_ItemViewChange\r\n");

    FireEvent(&m_eiItemViewChange, piResultView, piMMCListItem, varHint);
}



void CResultViews::FireFindItem
(
    IResultView *piResultView,
    BSTR         bstrName,
    long         lStart,
    VARIANT_BOOL fvarPartial,
    VARIANT_BOOL fvarWrap,
    VARIANT_BOOL *pfvarFound,
    long         *plIndex
)
{
    DebugPrintf("Firing ResultViews_FindItem: Name=%ls Start=%ld Partial=%s Wrap=%s\r\n", bstrName, lStart, (VARIANT_TRUE == fvarPartial) ? "True" : "Not True", (VARIANT_TRUE == fvarWrap) ? "True" : "Not True");

    FireEvent(&m_eiFindItem, piResultView, bstrName, lStart, fvarPartial,
             fvarWrap, pfvarFound, plIndex);

    DebugPrintf("ResultViews_FindItem Complete Found=%s Index=%ld\r\n", (VARIANT_TRUE == *pfvarFound) ? "True" : "Not True", *plIndex);
}



void CResultViews::FireCacheHint
(
    IResultView *piResultView,
    long         lStart,
    long         lEnd
)
{
    DebugPrintf("Firing ResultViews_CacheHint\r\n");

    FireEvent(&m_eiCacheHint, piResultView, lStart, lEnd);
}


void CResultViews::FireSortItems
(
    IResultView              *piResultView,
    long                      lColumn,
    SnapInSortOrderConstants  Order
)
{
    DebugPrintf("Firing ResultViews_SortItems\r\n");

    FireEvent(&m_eiSortItems, piResultView, lColumn, Order);
}



void CResultViews::FireDeselectAll
(
    IResultView      *piResultView,
    IMMCConsoleVerbs *piMMCConsoleVerbs,
    IMMCControlbar   *piMMCControlbar
)
{
    DebugPrintf("Firing ResultViews_DeselectAll\r\n");

    FireEvent(&m_eiDeselectAll, piResultView, piMMCConsoleVerbs, piMMCControlbar);
}


void CResultViews::FireCompareItems
(
    IResultView  *piResultView,
    IDispatch    *piObject1,
    IDispatch    *piObject2,
    long          lColumn,
    VARIANT      *pvarResult
)
{
    DebugPrintf("Firing ResultViews_CompareItems\r\n");

    FireEvent(&m_eiCompareItems, piResultView, piObject1, piObject2,
              lColumn, pvarResult);
}


void CResultViews::FireGetVirtualItemData
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem
)
{
    DebugPrintf("Firing ResultViews_GetVirtualItemData\r\n");

    FireEvent(&m_eiGetVirtualItemData, piResultView, piMMCListItem);
}


void CResultViews::FireGetVirtualItemDisplayInfo
(
    IResultView  *piResultView,
    IMMCListItem *piMMCListItem
)
{
    DebugPrintf("Firing ResultViews_GetVirtualItemDisplayInfo\r\n");

    FireEvent(&m_eiGetVirtualItemDisplayInfo, piResultView, piMMCListItem);
}


void CResultViews::FireColumnsChanged
(
    IResultView  *piResultView,
    VARIANT       Columns,
    VARIANT_BOOL *pfvarPersist
)
{
    DebugPrintf("Firing ResultViews_ColumnsChanged\r\n");

    FireEvent(&m_eiColumnsChanged, piResultView, Columns, pfvarPersist);
}


void CResultViews::FireFilterChange
(
    IResultView                     *piResultView, 
    IMMCColumnHeader                *piMMCColumnHeader,
    SnapInFilterChangeTypeConstants  Type
)
{
    DebugPrintf("Firing ResultViews_FilterChange\r\n");

    FireEvent(&m_eiFilterChange, piResultView, piMMCColumnHeader, Type);
}


void CResultViews::FireFilterButtonClick
(
    IResultView      *piResultView,
    IMMCColumnHeader *piMMCColumnHeader,
    long              Left,
    long              Top,
    long              Height,
    long              Width
)
{
    DebugPrintf("Firing ResultViews_FilterButtonClick\r\n");

    FireEvent(&m_eiFilterButtonClick, piResultView, piMMCColumnHeader, Left, Top, Height, Width);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CResultViews::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IResultViews == riid)
    {
        *ppvObjOut = static_cast<IResultViews *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInCollection<IResultView, ResultView, IResultViews>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\rtutil.cpp ===
//=--------------------------------------------------------------------------=
// rtutil.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Runtime Utility Functions
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "errors.h"
#include "images.h"
#include "listitem.h"
#include "clipbord.h"
#include "scopitms.h"
#include "listitms.h"
#include "image.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// IsString
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT   var       [in] Variant to check
//      BSTR     *pbstr     [out] BSTR contained in VARIANT
//
// Output:
//      BOOL TRUE - VARIANT contains an string
//           FALSE - VARIANT does not contain a string
//
// Notes:
//
// The returned BSTR should NOT be passed to SysFreeString()
//

BOOL IsString(VARIANT var, BSTR *pbstr)
{
    BOOL fIsString = TRUE;

    if (VT_BSTR == var.vt)
    {
        *pbstr = var.bstrVal;
    }
    else if ( (VT_BSTR | VT_BYREF) == var.vt )
    {
        *pbstr = *var.pbstrVal;
    }
    else if ( ((VT_BYREF | VT_VARIANT) == var.vt) &&
              (VT_BSTR == var.pvarVal->vt))
    {
        *pbstr = var.pvarVal->bstrVal;
    }
    else
    {
        fIsString = FALSE;
    }
    return fIsString;
}


//=--------------------------------------------------------------------------=
// IsObject
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  var        [in] Variant to check
//
// Output:
//      BOOL TRUE - VARIANT contains an object
//           FALSE - VARIANT does not contain an object
//
// Notes:
//
//

BOOL IsObject(VARIANT var)
{
    VARIANT *pvar = &var;
    VARTYPE  vt = VT_EMPTY;

    if (pvar->vt == (VT_BYREF | VT_VARIANT)) 
    {
        // Handle case like  x As Variant : Set x = Obj : Ctl.Add(x, ...)
        pvar = pvar->pvarVal;
    }

    vt = pvar->vt;
    vt &= VT_TYPEMASK;

    return ( (vt == VT_DISPATCH) || (vt == VT_UNKNOWN) );
}



//=--------------------------------------------------------------------------=
// ConvertToLong
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  var        [in] Variant to convert
//      long    *plNewIndex [out] converted value
//
// Output:
//      HRESULT S_OK - converted successfully
//              S_FALSE - cannot be converted
//
// Notes:
//
// Objects will not be converted. They could be converted by getting the default
// property (DISPID_VALUE) and attempting a conversion but this could be
// confusing to the VB developer when passing an object as a collection index.
// It will be clearer to refuse an object as an index.
//

HRESULT ConvertToLong(VARIANT var, long *pl)
{
    HRESULT hr = S_OK;
    VARIANT varLong;
    ::VariantInit(&varLong);

    IfFalseRet(!IsObject(var), S_FALSE);

    // VariantChangeType() will return successfully when asking it to convert
    // VT_EMPTY to VT_I4. It sets lval=0. For our purposes, an empty VARIANT
    // does not have meaning as a long.
    
    IfFalseRet(VT_EMPTY != var.vt, S_FALSE);

    IfFailRet(::VariantChangeType(&varLong, &var, 0, VT_I4));
    *pl = varLong.lVal;

    return S_OK;
}


HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi)
{
    HRESULT hr = S_OK;
    int     cchWideStr = 0;
    int     cchConverted = 0;
    int     cchAnsi = 0;

    *ppszAnsi = NULL;

    if (NULL != pwszWideStr)
    {
        cchWideStr = (int)::wcslen(pwszWideStr);
    }

    // If string is not zero length then get required buffer length

    if (0 != cchWideStr)
    {
        cchAnsi = ::WideCharToMultiByte(CP_ACP,      // code page - ANSI code page
                                        0,           // performance and mapping flags 
                                        pwszWideStr, // address of wide-character string 
                                        cchWideStr,  // number of characters in string 
                                        NULL,        // address of buffer for new string 
                                        0,           // size of buffer 
                                        NULL,        // address of default for unmappable characters
                                        NULL         // address of flag set when default char. used
                                       );
        if (cchAnsi == 0)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the ANSI string
    *ppszAnsi = static_cast<char *>(::CtlAlloc(cchAnsi + 1));
    if (*ppszAnsi == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // now convert the string and copy it to the buffer
    if (0 != cchWideStr)
    {
        cchConverted = ::WideCharToMultiByte(CP_ACP,               // code page - ANSI code page
                                             0,                    // performance and mapping flags 
                                             pwszWideStr,          // address of wide-character string 
                                             cchWideStr,           // number of characters in string 
                                             *ppszAnsi,             // address of buffer for new string 
                                             cchAnsi,              // size of buffer 
                                             NULL,                 // address of default for unmappable characters 
                                             NULL                  // address of flag set when default char. used 
                                            );
        if (cchConverted != cchAnsi)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null byte

    *((*ppszAnsi) + cchAnsi) = '\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppszAnsi)
        {
            ::CtlFree(*ppszAnsi);
            *ppszAnsi = NULL;
        }
    }

    RRETURN(hr);
}


HRESULT WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr)
{
    HRESULT    hr = S_OK;
    int        cchANSI = 0;
    int        cchConverted = 0;
    int        cchWideStr = 0;

    *ppwszWideStr = NULL;

    if (NULL != pszAnsi)
    {
        cchANSI = ::strlen(pszAnsi);
    }

    // If string is not zero length then get required buffer length

    if (0 != cchANSI)
    {
        cchWideStr = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                           0,                    // performance and mapping flags 
                                           pszAnsi,              // address of multibyte string 
                                           cchANSI,              // number of characters in string 
                                           NULL,                 // address of buffer for new string 
                                           0                     // size of buffer 
                                          );
        if (0 == cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // allocate a buffer for the WCHAR *
    *ppwszWideStr = static_cast<WCHAR *>(::CtlAlloc(sizeof(WCHAR) * (cchWideStr + 1)));
    if (ppwszWideStr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // now convert the string and copy it to the buffer
    if (0 != cchANSI)
    {
        cchConverted = ::MultiByteToWideChar(CP_ACP,               // code page - ANSI code page
                                             0,                    // performance and mapping flags 
                                             pszAnsi,              // address of multibyte string 
                                             cchANSI,              // number of characters in string 
                                             *ppwszWideStr,         // address of buffer for new string 
                                             cchWideStr            // size of buffer 
                                            );
        if (cchConverted != cchWideStr)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

    // add terminating null character
    *((*ppwszWideStr) + cchWideStr) = L'\0';

Error:
    if (FAILED(hr))
    {
        if (NULL != *ppwszWideStr)
        {
            ::CtlFree(*ppwszWideStr);
            *ppwszWideStr = NULL;
        }
    }

    RRETURN(hr);
}


HRESULT BSTRFromANSI(char *pszAnsi, BSTR *pbstr)
{
    HRESULT  hr = S_OK;
    WCHAR   *pwszWideStr = NULL;

    // convert to a wide string first
    hr = ::WideStrFromANSI(pszAnsi, &pwszWideStr);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // allocate a BSTR and copy it
    *pbstr = ::SysAllocStringLen(pwszWideStr, ::wcslen(pwszWideStr));
    if (*pbstr == NULL)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pwszWideStr)
    {
        ::CtlFree(pwszWideStr);
    }
    if (FAILED(hr))
    {
        if (NULL != *pbstr)
        {
            ::SysFreeString(*pbstr);
            *pbstr = NULL;
        }
    }

    RRETURN(hr);
}


HRESULT CoTaskMemAllocString(WCHAR *pwszString, LPOLESTR *ppwszOut)
{
    HRESULT   hr = S_OK;
    size_t    cbString = 0;
    LPOLESTR  pwszOut = NULL;

    if (NULL != pwszString)
    {
        cbString = ::wcslen(pwszString) * sizeof(OLECHAR);
    }

    pwszOut = (LPOLESTR)(::CoTaskMemAlloc(cbString + sizeof(OLECHAR)));

    if (NULL == pwszOut)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    if (cbString > 0)
    {
        ::memcpy(pwszOut, pwszString, cbString);
    }
    *(OLECHAR *)(((char *)pwszOut) + cbString) = L'\0';
    
Error:
    if (SUCCEEDED(hr))
    {
        *ppwszOut = pwszOut;
    }
    else
    {
        *ppwszOut = NULL;
    }
    RRETURN(hr);
}




HRESULT CreateKeyName
(
    char    *pszPrefix,
    size_t   cbPrefix,
    char    *pszSuffix,
    size_t   cbSuffix,
    char   **ppszKeyName
)
{
    HRESULT  hr = S_OK;
    char    *pszKeyName = (char *)::CtlAlloc(cbPrefix + cbSuffix + 1);

    IfFalseGo(NULL != pszKeyName, SID_E_OUTOFMEMORY);

    ::memcpy(pszKeyName, pszPrefix, cbPrefix);
    ::memcpy(&pszKeyName[cbPrefix], pszSuffix, cbSuffix);
    pszKeyName[cbPrefix + cbSuffix] = '\0';
    *ppszKeyName = pszKeyName;

Error:
    if (FAILED(hr))
    {
        *ppszKeyName = NULL;
    }
    RRETURN(hr);
}




HRESULT CreateKeyNameW
(
    char   *pszPrefix,
    size_t  cbPrefix,
    WCHAR  *pwszSuffix,
    char  **ppszKeyName
)
{
    HRESULT  hr = S_OK;
    char    *pszSuffix = NULL;

    IfFailGo(::ANSIFromWideStr(pwszSuffix, &pszSuffix));
    hr = CreateKeyName(pszPrefix, cbPrefix,
                       pszSuffix, ::strlen(pszSuffix), ppszKeyName);

Error:

    if (NULL != pszSuffix)
    {
        ::CtlFree(pszSuffix);
    }
    RRETURN(hr);
}


HRESULT GetPicture
(
    IMMCImages *piMMCImages,
    VARIANT     varIndex,
    short       TypeNeeded,
    OLE_HANDLE *phPicture
)
{
    HRESULT    hr = S_OK;
    IMMCImage *piMMCImage = NULL;
    CMMCImage *pMMCImage = NULL;

    *phPicture = NULL;

    IfFailGo(piMMCImages->get_Item(varIndex, reinterpret_cast<MMCImage **>(&piMMCImage)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImage, &pMMCImage));
    IfFailGo(pMMCImage->GetPictureHandle(TypeNeeded, phPicture));

Error:
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


HRESULT GetPictureHandle
(
    IPictureDisp *piPictureDisp,
    short         TypeNeeded,
    OLE_HANDLE   *phPicture
)
{
    HRESULT       hr = S_OK;
    IPicture     *piPicture = NULL;
    short         ActualType = PICTYPE_UNINITIALIZED;

    IfFailGo(piPictureDisp->QueryInterface(IID_IPicture,
                                           reinterpret_cast<void **>(&piPicture)));

    IfFailGo(piPicture->get_Type(&ActualType));
    if (TypeNeeded != ActualType)
    {
        hr = SID_E_INVALID_IMAGE_TYPE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(piPicture->get_Handle(phPicture));

Error:
    QUICK_RELEASE(piPicture);
    RRETURN(hr);
}


HRESULT CreateEmptyBitmapPicture(IPictureDisp **ppiPictureDisp)
{
    HRESULT  hr = S_OK;
    WORD     bits = 0;
    PICTDESC desc;
    ::ZeroMemory(&desc, sizeof(desc));

    if (NULL != *ppiPictureDisp)
    {
        (*ppiPictureDisp)->Release();
        *ppiPictureDisp = NULL;
    }

    // Create a 1x1 bitmap with 1 plane and 1 bit per pixel

    desc.cbSizeofstruct = sizeof(desc);
    desc.picType = PICTYPE_BITMAP;
    desc.bmp.hbitmap = ::CreateBitmap(1,1,1,1, &bits);
    if (NULL == desc.bmp.hbitmap)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::CreatePicture(ppiPictureDisp, &desc));

Error:
    RRETURN(hr);
}

HRESULT CreateIconPicture(IPictureDisp **ppiPictureDisp, HICON hicon)
{
    HRESULT  hr = S_OK;

    PICTDESC desc;
    ::ZeroMemory(&desc, sizeof(desc));

    if (NULL != *ppiPictureDisp)
    {
        (*ppiPictureDisp)->Release();
        *ppiPictureDisp = NULL;
    }

    desc.cbSizeofstruct = sizeof(desc);
    desc.picType = PICTYPE_ICON;
    desc.icon.hicon = hicon;

    IfFailGo(::CreatePicture(ppiPictureDisp, &desc));

Error:
    RRETURN(hr);
}

HRESULT CreatePicture(IPictureDisp **ppiPictureDisp, PICTDESC *pDesc)
{
    HRESULT  hr = S_OK;

    if (NULL != *ppiPictureDisp)
    {
        (*ppiPictureDisp)->Release();
        *ppiPictureDisp = NULL;
    }

    hr = ::OleCreatePictureIndirect(pDesc,
                                    IID_IPictureDisp,
                                    TRUE,                  // Picture owns handle
                                    reinterpret_cast<void **>(ppiPictureDisp));
    GLOBAL_EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


HRESULT CopyBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy)
{
    HRESULT hr = S_OK;
    BOOL	fBltOK = FALSE;;
    HBITMAP	hbmCopy = NULL;
    HBITMAP	hbmOldSrc = NULL;
    HBITMAP	hbmOldDst = NULL;
    HDC     hdcSrc = NULL;
    HDC     hdcDst = NULL;
    HDC     hdcScreen = NULL;
    int     cBytes = 0;

    BITMAP bm;
    ::ZeroMemory(&bm, sizeof(bm));

    *phbmCopy = NULL;

    // Base the DC and bitmaps on the screen so that any low fidelity bitmaps
    // will be upgraded to the screen's color depth. For example, a 16 bit color
    // bitmap copied for a 24 bit color screen will upgrade the bitmap to 24
    // bit color.

    hdcScreen = GetDC(NULL);
    IfFalseGo(NULL != hdcScreen, E_FAIL);

    // Need a memory DC for the source bitmap

    hdcSrc = CreateCompatibleDC(hdcScreen);
    IfFalseGo(NULL != hdcSrc, HRESULT_FROM_WIN32(::GetLastError()));

    // Use a memory DC to generate the copy bitmap

    hdcDst = CreateCompatibleDC(hdcScreen);
    IfFalseGo(NULL != hdcDst, HRESULT_FROM_WIN32(::GetLastError()));

    // Get the BITMAP structure for the source to determine its height and width
    
    cBytes = ::GetObject (hbmSrc, sizeof(BITMAP), &bm);
    IfFalseGo(0 != cBytes, HRESULT_FROM_WIN32(::GetLastError()));

    // Create an empty bitmap in the destination DC

    hbmCopy = ::CreateCompatibleBitmap(hdcScreen, bm.bmWidth, bm.bmHeight);
    IfFalseGo(NULL != hbmCopy, HRESULT_FROM_WIN32(::GetLastError()));

    // Select the source bitmap into the source DC

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmSrc));
    IfFalseGo(NULL != hbmOldSrc, HRESULT_FROM_WIN32(::GetLastError()));

    // Select the empty bitmap into the destination DC

    hbmOldDst = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmCopy));
    IfFalseGo(NULL != hbmOldDst, HRESULT_FROM_WIN32(::GetLastError()));

    // Blt from the source bitmap into the new destination bitmap

    fBltOK = ::StretchBlt(hdcDst, 0, 0, bm.bmWidth, bm.bmHeight, hdcSrc, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
    IfFalseGo(fBltOK, HRESULT_FROM_WIN32(::GetLastError()));

    // Restore the original bitmap into the source DC

    hbmOldSrc = static_cast<HBITMAP>(::SelectObject(hdcSrc, hbmOldSrc));
    IfFalseGo(NULL != hbmOldSrc, HRESULT_FROM_WIN32(::GetLastError()));

    // Restore the original bitmap into the destination DC and get the completed
    // copy

    hbmCopy = static_cast<HBITMAP>(::SelectObject(hdcDst, hbmOldDst));
    IfFalseGo(NULL != hbmCopy, HRESULT_FROM_WIN32(::GetLastError()));

    *phbmCopy = hbmCopy;

Error:
    if (FAILED(hr) && (NULL != hbmCopy))
    {
        (void)::DeleteObject(hbmCopy);
    }

    if (NULL != hdcScreen)
    {
        (void)::ReleaseDC(NULL, hdcScreen);
    }

    if (NULL != hdcSrc)
    {
        (void)::DeleteDC(hdcSrc);
    }

    if (NULL != hdcDst)
    {
        (void)::DeleteDC(hdcDst);
    }

    RRETURN(hr);
}



HRESULT CloneObject(IUnknown *punkSrc, IUnknown *punkDest)
{
    HRESULT hr = S_OK;

    IPersistStreamInit *piPersistStreamInitSrc = NULL;
    IPersistStreamInit *piPersistStreamInitDest = NULL;
    IStream            *piStream = NULL;
    LARGE_INTEGER       li;
    ::ZeroMemory(&li, sizeof(li));

    // Save the source object to a stream

    IfFailGo(punkSrc->QueryInterface(IID_IPersistStreamInit,
                           reinterpret_cast<void **>(&piPersistStreamInitSrc)));

    hr = ::CreateStreamOnHGlobal(NULL, // stream should allocate buffer
                                 TRUE, // stream should free buffer on release
                                 &piStream);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    IfFailGo(piPersistStreamInitSrc->Save(piStream, FALSE)); // don't clear dirty

    // Rewind the stream

    hr = piStream->Seek(li, STREAM_SEEK_SET, NULL);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Load the destination object from that stream

    IfFailGo(punkDest->QueryInterface(IID_IPersistStreamInit,
                          reinterpret_cast<void **>(&piPersistStreamInitDest)));

    IfFailGo(piPersistStreamInitDest->Load(piStream));
    
Error:
    QUICK_RELEASE(piPersistStreamInitSrc);
    QUICK_RELEASE(piPersistStreamInitDest);
    QUICK_RELEASE(piStream);
    RRETURN(hr);
}






void VBViewModeToMMCViewMode
(
    SnapInViewModeConstants  VBViewMode,
    long                    *pMMCViewMode
)
{
    switch (VBViewMode)
    {
        case siIcon:
            *pMMCViewMode = MMCLV_VIEWSTYLE_ICON;;
            break;

        case siSmallIcon:
            *pMMCViewMode = MMCLV_VIEWSTYLE_SMALLICON;
            break;

        case siList:
            *pMMCViewMode = MMCLV_VIEWSTYLE_LIST;
            break;

        case siReport:
            *pMMCViewMode = MMCLV_VIEWSTYLE_REPORT;
            break;

        case siFiltered:
            *pMMCViewMode = MMCLV_VIEWSTYLE_FILTERED;
            break;

        default:
            ASSERT(FALSE, "SnapInViewModeConstants param has bad value");
            *pMMCViewMode = MMCLV_VIEWSTYLE_ICON;;
            break;
    }
}


void MMCViewModeToVBViewMode
(
    long                     MMCViewMode,
    SnapInViewModeConstants *pVBViewMode
)
{
    switch (MMCViewMode)
    {
        case MMCLV_VIEWSTYLE_ICON:
            *pVBViewMode = siIcon;
            break;

        case MMCLV_VIEWSTYLE_SMALLICON:
            *pVBViewMode = siSmallIcon;
            break;

        case MMCLV_VIEWSTYLE_LIST:
            *pVBViewMode = siList;
            break;

        case MMCLV_VIEWSTYLE_REPORT:
            *pVBViewMode = siReport;
            break;

        case MMCLV_VIEWSTYLE_FILTERED:
            *pVBViewMode = siFiltered;
            break;

        default:
            ASSERT(FALSE, "MMCViewMode param has bad value");
            *pVBViewMode = siIcon;
            break;
    }
}



//=--------------------------------------------------------------------------=
// CreateSelection
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject    [in]  data object from MMC representing
//                                            current selection. This is pane
//                                            independent.
//      IMMCClipboard **ppiMMCClipboard [out] MMCClipboard object containing
//                                            the selected items
//      CSnapIn        *pSnapIn         [in]  pointer to owning snap-in
//
//      SnapInSelectionTypeConstants *pSelectionType [out] clipboard selection
//                                                         type returned here
//
// Output:
//      HRESULT
//
// Notes:
//
// This function interprets the contents of the data object from MMC and breaks
// it down into three collections within a newly created MMCClipboard object.
//
// UNDONE: next coment says that we hold foreign VB snap-in items natively in
// the clipboard. Recheck this after multi-selection is done.
//
// MMCClipboard.ScopeItems contains scope items owned either by the snap-in or
// by other VB implemented snap-ins. The snap-in can discern by checking
// ScopeItem.ScopeNode.Owned. 
//
// MMCClipboard.ListItems contains list items owned either by the snap-in or
// by other VB implemented snap-ins. The snap-in can discern by checking
// ListItem.Owned.
//
// MMCClipboard.DataObject contains MMCDataObjects representing data exported
// by other snap-ins not implemented in VB.
//
// If there is nothing currently selected (NULL IDataObject) then all of the
// collections will be empty.
//

HRESULT CreateSelection
(
    IDataObject                   *piDataObject, 
    IMMCClipboard                **ppiMMCClipboard,
    CSnapIn                       *pSnapIn,      
    SnapInSelectionTypeConstants  *pSelectionType
)
{
    HRESULT        hr = S_OK;
    IUnknown      *punkClipboard = NULL;
    IMMCClipboard *piMMCClipboard = NULL;
    CMMCClipboard *pMMCClipboard = NULL;

    *ppiMMCClipboard = NULL;
    *pSelectionType = siEmpty;

    // Create a clipboard object to hold the selection

    punkClipboard = CMMCClipboard::Create(NULL);
    if (NULL == punkClipboard)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkClipboard->QueryInterface(IID_IMMCClipboard,
                                    reinterpret_cast<void **>(&piMMCClipboard)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCClipboard, &pMMCClipboard));

    IfFailGo(::InterpretDataObject(piDataObject, pSnapIn, pMMCClipboard));

    // If this is a special data object then set the MMCClipboard.SelectionType
    // to the corresponding special type.

    if (IS_SPECIAL_DATAOBJECT(piDataObject))
    {
        if (DOBJ_NULL == piDataObject)
        {
            pMMCClipboard->SetSelectionType(siEmpty);
        }
        else if (DOBJ_CUSTOMOCX == piDataObject)
        {
            pMMCClipboard->SetSelectionType(siSpecialOcx);
        }
        else if (DOBJ_CUSTOMWEB == piDataObject)
        {
            pMMCClipboard->SetSelectionType(siSpecialWeb);
        }
        else
        {
            ASSERT(FALSE, "Received unknown DOBJ_XXX type");
            pMMCClipboard->SetSelectionType(siEmpty);
        }
    }
    else
    {
        // Ask the MMCClipboard to figure out the selection type based on
        // the objects it contains

        IfFailGo(pMMCClipboard->DetermineSelectionType());
    }

    // Make the clipboard read-only so the snap-in cannot alter its collections

    pMMCClipboard->SetReadOnly(TRUE);

Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(piMMCClipboard);
    }
    else
    {
        *ppiMMCClipboard = piMMCClipboard;
        *pSelectionType = pMMCClipboard->GetSelectionType();
    }
    QUICK_RELEASE(punkClipboard);
    RRETURN(hr);
}


HRESULT InterpretDataObject
(
    IDataObject   *piDataObject,
    CSnapIn       *pSnapIn,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    CScopeItems    *pScopeItems = NULL;
    CScopeItem     *pScopeItem = NULL;
    CMMCListItems  *pListItems = NULL;
    CMMCListItem   *pListItem = NULL;
    BOOL            fNotFromThisSnapIn = FALSE;
    BOOL            fMultiSelect = FALSE;
    long            i = 0;
    long            cScopeItems = 0;
    long            cListItems = 0;

    // Check for special case dataobjects. For all of these we don't add anything
    // to the MMCClipboard

    // Dataobject can be NULL when in an empty result pane (listview with
    // no items) and the user clicks a toolbar button.

    // Dataobject can be DOBJ_CUSTOMWEB when clicking a toolbar button or
    // dropping a menu button when the result pane contains a listpad,
    // a url view, or a taskpad.

    // Dataobject can be DOBJ_CUSTOMOCX in the same cases when displaying an
    // OCX view.

    IfFalseGo(!IS_SPECIAL_DATAOBJECT(piDataObject), S_OK );

    ::IdentifyDataObject(piDataObject, pSnapIn,
                         &pMMCDataObject, &fNotFromThisSnapIn);

    if (fNotFromThisSnapIn)
    {
        // This is either data from another snap-in or a multiple selection
        // format. Make that determination first.

        IfFailGo(::IsMultiSelect(piDataObject, &fMultiSelect));

        if (fMultiSelect)
        {
            IfFailGo(::InterpretMultiSelect(piDataObject, pSnapIn, pMMCClipboard));
        }
        else
        {
            IfFailGo(::AddForeignDataObject(piDataObject, pMMCClipboard, pSnapIn));
        }
    }
    else
    {
        // This snap-in owns the data object.
        // It represents either a single scope item (that can
        // be either in the scope or result pane), a single list item, or
        // multiples of one or both.

        if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
        {
            IfFailGo(::AddScopeItemToClipboard(pMMCDataObject->GetScopeItem(),
                                               pMMCClipboard));
        }
        else if (CMMCDataObject::ListItem == pMMCDataObject->GetType())
        {
            IfFailGo(::AddListItemToClipboard(pMMCDataObject->GetListItem(),
                                              pMMCClipboard));
        }
        else if (CMMCDataObject::MultiSelect == pMMCDataObject->GetType())
        {
            // Add each element in the data object's ScopeItems and
            // MMCListItems collections to the clipboard

            pScopeItems = pMMCDataObject->GetScopeItems();
            cScopeItems = pScopeItems->GetCount();
            for (i = 0; i < cScopeItems; i++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                   pScopeItems->GetItemByIndex(i), &pScopeItem));
                IfFailGo(::AddScopeItemToClipboard(pScopeItem, pMMCClipboard));
            }

            pListItems = pMMCDataObject->GetListItems();
            cListItems = pListItems->GetCount();
            for (i = 0; i < cListItems; i++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                     pListItems->GetItemByIndex(i), &pListItem));
                IfFailGo(::AddListItemToClipboard(pListItem, pMMCClipboard));
            }
        }
        else
        {
            ASSERT(FALSE, "CMMCDataObject in selection should not be foreign");
        }
    }

Error:
    RRETURN(hr);
}




void IdentifyDataObject
(
    IDataObject     *piDataObject,
    CSnapIn         *pSnapIn,
    CMMCDataObject **ppMMCDataObject,
    BOOL            *pfNotFromThisSnapIn
 
)
{
    CMMCDataObject  *pMMCDataObject = NULL;
    HGLOBAL          hGlobal = NULL;
    DWORD           *pdwInstanceID = 0;
    CMMCDataObject **ppThis = NULL;

    *ppMMCDataObject = NULL;
    *pfNotFromThisSnapIn = TRUE;
    
    if (SUCCEEDED(CSnapInAutomationObject::GetCxxObject(piDataObject,
                                                        &pMMCDataObject)))
    {
        if (pMMCDataObject->GetSnapInInstanceID() == pSnapIn->GetInstanceID())
        {
            *pfNotFromThisSnapIn = FALSE;
            *ppMMCDataObject = pMMCDataObject;
        }
    }
    else
    {
        // This could be a clipboard data object from MMC. In this case MMC's
        // data object holds an IDataObject to our data object and will forward
        // GetData calls to it. So, ask the data object for its snap-in instance
        // ID and, if it matches, then ask it for its this pointer.

        if (SUCCEEDED(::GetData(piDataObject,
                                CMMCDataObject::GetcfSnapInInstanceID(),
                                &hGlobal)))
        {
            pdwInstanceID = (DWORD *)::GlobalLock(hGlobal);
            if ( (NULL != pdwInstanceID) &&
                 (::GlobalSize(hGlobal) >= sizeof(*pdwInstanceID)) )
            {
                if (*pdwInstanceID == pSnapIn->GetInstanceID())
                {
                    (void)::GlobalUnlock(hGlobal);
                    (void)::GlobalFree(hGlobal);
                    hGlobal = NULL;
                    if (SUCCEEDED(::GetData(piDataObject,
                                            CMMCDataObject::GetcfThisPointer(),
                                            &hGlobal)))
                    {
                        ppThis = (CMMCDataObject **)::GlobalLock(hGlobal);
                        if ( (NULL != ppThis) &&
                             (::GlobalSize(hGlobal) >= sizeof(*ppThis)) )
                        {
                            *ppMMCDataObject = *ppThis;
                            *pfNotFromThisSnapIn = FALSE;
                        }
                    }
                }
            }
        }
    }
            
    if (NULL != hGlobal)
    {
        (void)::GlobalUnlock(hGlobal);
        (void)::GlobalFree(hGlobal);
    }
}


HRESULT IsMultiSelect(IDataObject *piDataObject, BOOL *pfMultiSelect)
{
    HRESULT  hr = S_OK;
    DWORD   *pdwMultiSelect = NULL;
    BOOL     fGotData = FALSE;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    *pfMultiSelect = FALSE;

    FmtEtc.cfFormat = CMMCDataObject::GetcfMultiSelectDataObject();
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->GetData(&FmtEtc, &StgMed);
    if (SUCCEEDED(hr))
    {
        fGotData = TRUE;
    }
    else if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) || (E_NOTIMPL == hr) )
    {
        hr = S_OK;
    }
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    if (fGotData)
    {
        pdwMultiSelect = (DWORD *)::GlobalLock(StgMed.hGlobal);

        if (static_cast<DWORD>(1) == *pdwMultiSelect)
        {
            *pfMultiSelect = TRUE;
        }
    }

Error:
    if (NULL != pdwMultiSelect)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ::ReleaseStgMedium(&StgMed);
    }
    RRETURN(hr);
}




HRESULT InterpretMultiSelect
(
    IDataObject   *piDataObject,
    CSnapIn       *pSnapIn,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT          hr = S_OK;
    SMMCDataObjects *pMMCDataObjects = NULL;
    BOOL             fGotData = FALSE;
    size_t           cbObjectTypes = 0;
    DWORD            i = 0;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    // Get the SMMCDataObjects structure from MMC

    FmtEtc.cfFormat = CMMCDataObject::GetcfMultiSelectSnapIns();
    FmtEtc.dwAspect  = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;

    hr = piDataObject->GetData(&FmtEtc, &StgMed);
    if ( (DV_E_FORMATETC == hr) || (DV_E_CLIPFORMAT == hr) )
    {
        hr = SID_E_FORMAT_NOT_AVAILABLE;
    }
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    fGotData = TRUE;

    pMMCDataObjects = (SMMCDataObjects *)::GlobalLock(StgMed.hGlobal);
    if (NULL == pMMCDataObjects)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // For each data object in the array check whether it is owned by this
    // snap-in or not and add it to the corresponding collection in
    // MMCClipboard. Note that we do not call Release on the IDataObject
    // pointers extracted from the HGLOBAL block because MMC does not AddRef()
    // them.

    for (i = 0; i < pMMCDataObjects->count; i++)
    {
        IfFailGo(::InterpretDataObject(pMMCDataObjects->lpDataObject[i],
                                       pSnapIn,
                                       pMMCClipboard));
    }

Error:
    if (NULL != pMMCDataObjects)
    {
        (void)::GlobalUnlock(StgMed.hGlobal);
    }

    if (fGotData)
    {
        ::ReleaseStgMedium(&StgMed);
    }

    RRETURN(hr);
}




HRESULT AddForeignDataObject
(
    IDataObject   *piDataObject,
    CMMCClipboard *pMMCClipboard,
    CSnapIn       *pSnapIn
)
{
    HRESULT          hr = S_OK;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    CMMCDataObject  *pMMCDataObject  = NULL;

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    IfFailGo(pMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));

    IfFailGo(piMMCDataObjects->Add(varUnspecified, varUnspecified,
                         reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCDataObject,
                                                   &pMMCDataObject));
    pMMCDataObject->SetType(CMMCDataObject::Foreign);
    pMMCDataObject->SetForeignData(piDataObject);
    pMMCDataObject->SetSnapIn(pSnapIn);

Error:
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// AddListItemToClipboard
//=--------------------------------------------------------------------------=
//
// Parameters:
//      CMMCListItem  *pMMCListItem   [in] list item to be added
//      CMMCClipboard *pMMCClipboard [in] clipboard to which it should be added
//
// Output:
//      HRESULT
//
// Notes:
//
// This function adds the specified list item the clipboard's MMCListItems
// collection. The list item's index property will not correspond to its
// position in the clipboard's collection as it represents the position in the
// list item's owning collection.
//

HRESULT AddListItemToClipboard
(
    CMMCListItem  *pMMCListItem,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT        hr = S_OK;
    IMMCListItems *piMMCListItems = NULL;
    CMMCListItems *pMMCListItems = NULL;
    long           lIndex = pMMCListItem->GetIndex();

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    DebugPrintf("Adding list item to selection: %ld %ls\r\n", pMMCListItem->GetIndex(), (pMMCListItem->GetTextPtr() != NULL) ? pMMCListItem->GetTextPtr() : L"<Virtual List Item>");

    IfFailGo(pMMCClipboard->get_ListItems(reinterpret_cast<MMCListItems **>(&piMMCListItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItems, &pMMCListItems));

    varKey.bstrVal = pMMCListItem->GetKey();
    if (NULL != varKey.bstrVal)
    {
        varKey.vt = VT_BSTR;
    }
    else
    {
        UNSPECIFIED_PARAM(varKey);
    }

    hr = pMMCListItems->AddExisting(varUnspecifiedIndex, varKey,
                                    static_cast<IMMCListItem *>(pMMCListItem));

    ASSERT(SID_E_KEY_NOT_UNIQUE != hr, "Attempted to add non-unique key to MMCClipboard.ListItems");
    IfFailGo(hr);

    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this list item still belongs to its original owning collection.
    // Clipboard.ListItems is documented as having items with invalid index
    // properties.

    pMMCListItem->SetIndex(lIndex);

Error:
    QUICK_RELEASE(piMMCListItems);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// AddScopeItemToClipboard
//=--------------------------------------------------------------------------=
//
// Parameters:
//      CScopeItem    *pScopeItem     [in] Scope item to be added
//      CMMCClipboard *pMMCClipboard  [in] clipboard to which it should be added
//
// Output:
//      HRESULT
//
// Notes:
//
// This function adds the specified list item the clipboard's ScopeItems
// collection. The scope item's index property will not correspond to its
// position in the clipboard's collection as it represents the position in the
// SnapIn.ScopeItems (the owning collection).
//


HRESULT AddScopeItemToClipboard
(
    CScopeItem    *pScopeItem,
    CMMCClipboard *pMMCClipboard
)
{
    HRESULT      hr = S_OK;
    IScopeItems *piScopeItems = NULL;
    CScopeItems *pScopeItems = NULL;
    long         lIndex = pScopeItem->GetIndex();

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    IfFailGo(pMMCClipboard->get_ScopeItems(reinterpret_cast<ScopeItems **>(&piScopeItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItems, &pScopeItems));

    varKey.bstrVal = pScopeItem->GetKey();
    if (NULL != varKey.bstrVal)
    {
        varKey.vt = VT_BSTR;
    }
    else
    {
        UNSPECIFIED_PARAM(varKey);
    }

    hr = pScopeItems->AddExisting(varUnspecifiedIndex, varKey,
                                  static_cast<IScopeItem *>(pScopeItem));
    ASSERT(SID_E_KEY_NOT_UNIQUE != hr, "Attempted to add non-unique key to MMCClipboard.ScopeItems");
    IfFailGo(hr);

    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this list item still belongs to its original owning collection.
    // Clipboard.ScopeItems is documented as having items with invalid index
    // properties.

    pScopeItem->SetIndex(lIndex);

    DebugPrintf("Adding scope item to selection %ls\r\n", pScopeItem->GetDisplayNamePtr());

Error:
    QUICK_RELEASE(piScopeItems);
    RRETURN(hr);
}



static HRESULT GetObjectArray
(
    SAFEARRAY        *psaObjects,
    LONG             *pcObjects,
    IUnknown HUGEP ***pppunkObjects
)
{
    HRESULT          hr = S_OK;
    LONG             lUBound = 0;
    LONG             lLBound = 0;

    *pppunkObjects = NULL;
    *pcObjects = 0;

    // Check that we received a one-dimensional array of interface pointer sized
    // elements and that it contains IUnknown or IDispatch pointers.

    if ( (1 != ::SafeArrayGetDim(psaObjects)) ||
         (sizeof(IUnknown *) != ::SafeArrayGetElemsize(psaObjects)) ||
         (0 == (psaObjects->fFeatures & (FADF_UNKNOWN | FADF_DISPATCH)) )
       )
    {
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get access to the array data

    hr = ::SafeArrayAccessData(psaObjects,
                               reinterpret_cast<void HUGEP **>(pppunkObjects));
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Get the number of elements by doing the math on lower and upper bounds
    // on the first (and only) dimension of the array

    hr = ::SafeArrayGetLBound(psaObjects, 1, &lLBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(psaObjects, 1, &lUBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    *pcObjects = (lUBound - lLBound) + 1L;

Error:
    if ( FAILED(hr) && (NULL != *pppunkObjects) )
    {
        (void)::SafeArrayUnaccessData(psaObjects);
    }
    RRETURN(hr);
}



HRESULT DataObjectFromSingleObject
(
    IUnknown     *punkObject,
    MMC_COOKIE   *pCookie,
    IDataObject **ppiDataObject
)
{
    HRESULT       hr = S_OK;
    CMMCListItem *pMMCListItem = NULL;
    IMMCListItem *piMMCListItem = NULL;
    CScopeItem   *pScopeItem = NULL;
    IScopeItem   *piScopeItem = NULL;

    hr = punkObject->QueryInterface(IID_IScopeItem,
                                    reinterpret_cast<void **>(&piScopeItem));
    if (FAILED(hr))
    {
        hr = punkObject->QueryInterface(IID_IMMCListItem,
                                        reinterpret_cast<void **>(&piMMCListItem));
    }
    if (FAILED(hr))
    {
        // Not a scope item and not a list item. Can't use it.
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get the object's data object and cookie

    if (NULL != piScopeItem)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem,
                                                       &pScopeItem));
        *ppiDataObject = static_cast<IDataObject *>(pScopeItem->GetData());
        if (pScopeItem->IsStaticNode())
        {
            *pCookie = 0;
        }
        else
        {
            *pCookie = reinterpret_cast<MMC_COOKIE>(pScopeItem);
        }
    }
    else
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                       &pMMCListItem));
        *ppiDataObject = static_cast<IDataObject *>(pMMCListItem->GetData());
        *pCookie = reinterpret_cast<MMC_COOKIE>(pMMCListItem);
    }
    (*ppiDataObject)->AddRef();
    
Error:
    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(piMMCListItem);
    RRETURN(hr);
}


HRESULT DataObjectFromObjectArray
(
    IUnknown HUGEP **ppunkObjects,
    LONG             cObjects,
    MMC_COOKIE      *pCookie,
    IDataObject    **ppiDataObject
)
{
    HRESULT          hr = S_OK;
    IUnknown        *punkDataObject = CMMCDataObject::Create(NULL);
    CMMCDataObject  *pMMCDataObject = NULL;
    IUnknown        *punkScopeItems = CScopeItems::Create(NULL);
    CScopeItems     *pScopeItems = NULL;
    CScopeItem      *pScopeItem = NULL;
    IScopeItem      *piScopeItem = NULL;
    IUnknown        *punkListItems = CMMCListItems::Create(NULL);
    CMMCListItems   *pMMCListItems = NULL;
    CMMCListItem    *pMMCListItem = NULL;
    IMMCListItem    *piMMCListItem = NULL;
    long             lIndex = 0;
    LONG             i = 0;
    BOOL             fHaveArray = FALSE;
    CSnapIn         *pSnapIn = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varUnspecifiedIndex;
    UNSPECIFIED_PARAM(varUnspecifiedIndex);

    // Check that we created an MMCDataObject and the scope and list item
    // collections

    if ( (NULL == punkDataObject) || (NULL == punkScopeItems) ||
         (NULL == punkListItems) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Get C++ pointers for the data object and the collections

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkDataObject,
                                                  &pMMCDataObject));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkScopeItems,
                                                   &pScopeItems));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkListItems,
                                                   &pMMCListItems));

    // Iterate through the objects and build the scope item and list item
    // collections. When adding an item owned by another collection,
    // CSnapInCollection<IObject, ICollection>::AddExisting will set the index
    // to the position in the new collection. We need to revert to the original
    // value as this item still belongs to its original owning collection (either
    // SnapIn.ScopeItems or ResultView.ListView.ListItems)

    for (i = 0; i < cObjects; i++)
    {
        // Check for NULLs. This can happen when the snap-in does something like:
        //
        // Dim Objects(2) As Object
        // Set Object(1) = SomeScopeItem
        // Set Object(2) = SomeOtherScopeItem
        //
        // With the default option base of zero this is actually a 3 element
        // array where element zero has not been set (it will have default
        // initialization of zero).

        if (NULL == ppunkObjects[i])
        {
            continue;
        }

        // QI to determine whether this object is a scope item or a list item

        hr = ppunkObjects[i]->QueryInterface(IID_IScopeItem,
                                             reinterpret_cast<void **>(&piScopeItem));
        if (FAILED(hr))
        {
            hr = ppunkObjects[i]->QueryInterface(IID_IMMCListItem,
                                      reinterpret_cast<void **>(&piMMCListItem));
        }
        if (FAILED(hr))
        {
            // Not a scope item and not a list item. Can't use it.
            hr = SID_E_INVALIDARG;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }

        // Add the object to the appropriate collection

        if (NULL != piScopeItem)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem,
                                                           &pScopeItem));
            lIndex = pScopeItem->GetIndex();
            varKey.bstrVal = pScopeItem->GetKey();
            if (NULL != varKey.bstrVal)
            {
                varKey.vt = VT_BSTR;
            }
            else
            {
                UNSPECIFIED_PARAM(varKey);
            }
            IfFailGo(pScopeItems->AddExisting(varUnspecifiedIndex, varKey,
                                              piScopeItem));
            pScopeItem->SetIndex(lIndex);

            if (NULL == pSnapIn)
            {
                pSnapIn = pScopeItem->GetSnapIn();
            }
            RELEASE(piScopeItem);
        }
        else
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCListItem,
                                                           &pMMCListItem));
            lIndex = pMMCListItem->GetIndex();
            varKey.bstrVal = pMMCListItem->GetKey();
            if (NULL != varKey.bstrVal)
            {
                varKey.vt = VT_BSTR;
            }
            else
            {
                UNSPECIFIED_PARAM(varKey);
            }
            IfFailGo(pMMCListItems->AddExisting(varUnspecifiedIndex, varKey,
                                                piMMCListItem));
            pMMCListItem->SetIndex(lIndex);
            if (NULL == pSnapIn)
            {
                pSnapIn = pMMCListItem->GetSnapIn();
            }
            RELEASE(piMMCListItem);
        }
    }

    // Put the arrays of scopitems and listitems into the data object

    pMMCDataObject->SetScopeItems(pScopeItems);
    pMMCDataObject->SetListItems(pMMCListItems);

    // Set the dataobject type to multiselect because we populated its
    // collections rather than its individual scope or list item.

    pMMCDataObject->SetType(CMMCDataObject::MultiSelect);

    // Give the dataobject a pointer to the owning CSnapIn

    pMMCDataObject->SetSnapIn(pSnapIn);

    // Return the IDataObject

    IfFailGo(punkDataObject->QueryInterface(IID_IDataObject,
                                            reinterpret_cast<void **>(ppiDataObject)));

    // Return the cookie. This is exactly the same kind of data object that we
    // would return from IComponent::QueryDataObject(MMC_MULTI_SELECT_COOKIE) so
    // return that special cookie.

    *pCookie = MMC_MULTI_SELECT_COOKIE;

Error:
    QUICK_RELEASE(punkDataObject);
    QUICK_RELEASE(punkScopeItems);
    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(punkListItems);
    QUICK_RELEASE(piMMCListItem);
    RRETURN(hr);
}

HRESULT DataObjectFromObjects(VARIANT       varObjects,
                              MMC_COOKIE   *pCookie,
                              IDataObject **ppiDataObject)
{
    HRESULT          hr = S_OK;
    LONG             cObjects = 0;
    BOOL             fHaveArray = FALSE;
    IUnknown        *punkObject = NULL; // Not AddRef()ed
    IUnknown HUGEP **ppunkObjects = NULL;

    // Check that the variant contains one of the following:
    // IUnknown, IDispatch, array of IUnknown, array of IDispatch

    if ( (varObjects.vt == (VT_ARRAY | VT_UNKNOWN)) ||
         (varObjects.vt == (VT_ARRAY | VT_DISPATCH)) )
    {
        IfFailGo(::GetObjectArray(varObjects.parray, &cObjects, &ppunkObjects));
        fHaveArray = TRUE;
    }
    else if (varObjects.vt == VT_UNKNOWN)
    {
        punkObject = varObjects.punkVal;
    }
    else if (varObjects.vt == VT_DISPATCH)
    {
        punkObject = static_cast<IUnknown *>(varObjects.pdispVal);
    }
    else
    {
        hr = SID_E_INVALIDARG;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // If it is a single object then figure out which type and get its existing
    // data object

    if (NULL != punkObject)
    {
        IfFailGo(::DataObjectFromSingleObject(punkObject, pCookie, ppiDataObject));
    }
    else
    {
        // It is an array. Create a new multi-select data object for it
        IfFailGo(::DataObjectFromObjectArray(ppunkObjects, cObjects,
                                             pCookie, ppiDataObject));
    }

Error:
    if (fHaveArray)
    {
        (void)::SafeArrayUnaccessData(varObjects.parray);
    }
    RRETURN(hr);
}



HRESULT GetSnapInCLSID
(
    BSTR   bstrNodeTypeGUID,
    char   szClsid[],
    size_t cbClsid
)
{
    HRESULT  hr = S_OK;
    long     lRc = ERROR_SUCCESS;
    BSTR     bstrGUID = NULL;
    char    *pszKeyName = NULL;
    HKEY     hkey = NULL;
    WCHAR   *pwszClsid = NULL;
    DWORD    cbValue = cbClsid;

    IfFailGo(::CreateKeyNameW(KEY_SNAPIN_CLSID, KEY_SNAPIN_CLSID_LEN,
                              bstrNodeTypeGUID, &pszKeyName));

    lRc = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0, KEY_QUERY_VALUE,
                         &hkey);
    if (ERROR_SUCCESS == lRc)
    {
        // Read the key's default value
        lRc = ::RegQueryValueEx(hkey, NULL, NULL, NULL,
                                (LPBYTE)szClsid, &cbValue);
    }
    if (ERROR_SUCCESS != lRc)
    {
        hr = HRESULT_FROM_WIN32(lRc);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    else if (0 == ::strlen(szClsid))
    {
        hr = SID_E_INTERNAL;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    if (NULL != hkey)
    {
        (void)::RegCloseKey(hkey);
    }
    RRETURN(hr);
}



HRESULT GetData
(
    IDataObject *piDataObject,
    CLIPFORMAT   cf,
    HGLOBAL     *phData
)
{
    HRESULT hr = S_OK;
    HGLOBAL hGlobal = NULL;

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));

    hGlobal = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, 512);
    if (NULL == hGlobal)
    {
        hr = HRESULT_FROM_WIN32(hr);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    FmtEtc.cfFormat = cf;
    FmtEtc.dwAspect = DVASPECT_CONTENT;
    FmtEtc.lindex = -1L;
    FmtEtc.tymed = TYMED_HGLOBAL;
    StgMed.tymed = TYMED_HGLOBAL;
    StgMed.hGlobal = hGlobal;

    hr = piDataObject->GetDataHere(&FmtEtc, &StgMed);
    if (SUCCEEDED(hr))
    {
        *phData = StgMed.hGlobal;
    }

Error:
    if ( FAILED(hr) && (NULL != hGlobal) )
    {
        (void)::GlobalFree(hGlobal);
    }
    RRETURN(hr);
}


HRESULT GetStringData
(
    IDataObject *piDataObject,
    CLIPFORMAT   cf,
    BSTR        *pbstrData
)
{
    HGLOBAL  hGlobal = NULL;
    HRESULT  hr = ::GetData(piDataObject, cf, &hGlobal);
    OLECHAR *pwszData = NULL;

    if (SUCCEEDED(hr))
    {
        pwszData = (OLECHAR *)::GlobalLock(hGlobal);
        if (NULL != pwszData)
        {
            *pbstrData = ::SysAllocString(pwszData);
            if (NULL == *pbstrData)
            {
                hr = SID_E_OUTOFMEMORY;
            }
            (void)::GlobalUnlock(hGlobal);
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    if (NULL != hGlobal)
    {
        (void)::GlobalFree(hGlobal);
    }
    RRETURN(hr);
}


HRESULT WriteSafeArrayToStream
(
    SAFEARRAY             *psa,
    IStream               *piStream,
    WriteSafeArrayOptions  Option
)
{
    HRESULT     hr = S_OK;
    ULONG       cbToWrite = 0;
    ULONG       cbWritten = 0;
    LONG        lUBound = 0;
    LONG        lLBound = 0;
    void HUGEP *pvArrayData = NULL;

    hr = ::SafeArrayAccessData(psa, &pvArrayData);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Get its size. As we only allow one-dimensional Byte arrays, the lower
    // and upper bounds of the 1st dimension will give us the size in bytes.

    hr = ::SafeArrayGetLBound(psa, 1, &lLBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(psa, 1, &lUBound);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Write the bytes to the stream.

    cbToWrite = (lUBound - lLBound) + 1L;

    // If requested write the length to the stream

    if (WriteLength == Option)
    {
        hr = piStream->Write(&cbToWrite, sizeof(cbToWrite), &cbWritten);
        GLOBAL_EXCEPTION_CHECK_GO(hr);
        if (cbWritten != sizeof(cbToWrite))
        {
            hr = SID_E_INCOMPLETE_WRITE;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }
    
    hr = piStream->Write(pvArrayData, cbToWrite, &cbWritten);
    GLOBAL_EXCEPTION_CHECK_GO(hr);
    if (cbWritten != cbToWrite)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(psa);
    }

    RRETURN(hr);
}


HRESULT GetImageIndex
(
    IMMCListView *piMMCListView,
    VARIANT       varIndex,
    int          *pnIndex
)
{
    HRESULT        hr = S_OK;
    long           lIndex = 0;
    IMMCImageList *piMMCImageList = NULL;
    IMMCImages    *piMMCImages = NULL;
    IMMCImage     *piMMCImage = NULL;

    // Look up the image in ListView.Icons.ListImages and get its index property.

    IfFailGo(piMMCListView->get_Icons(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
    IfFalseGo(NULL != piMMCImageList, S_OK);
    IfFailGo(piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(piMMCImages->get_Item(varIndex, reinterpret_cast<MMCImage **>(&piMMCImage)));
    IfFailGo(piMMCImage->get_Index(&lIndex));
    *pnIndex = static_cast<int>(lIndex);

Error:
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CheckVariantForCrossThreadUsage
//=--------------------------------------------------------------------------=
//
// Parameters:
//      VARIANT  *pvar        [in, out] Variant to check
//
// Output:
//      If VARIANT is object, array or VARIANT BYREF then element is
//      dereferenced and VT_BYREF is removed.
//
//      Checks for supported types and array types. Unsupported types
//      will return SID_E_INVALIDARG. See switch statements for supported
//      types.
//
//
// Notes:
//
// VT_UNKNOWN and VT_DISPATCH are supported types. If present the caller must
// marshal the interface pointers. Anything else is usable across threads
// providing there are no problems of simultaneous access.
//

HRESULT CheckVariantForCrossThreadUsage(VARIANT *pvar)
{
    HRESULT hr = S_OK;

    // Dereference the complex VARIANT types

    if (0 != (pvar->vt & VT_BYREF))
    {
        switch (pvar->vt & ~VT_BYREF)
        {
            case VT_UNKNOWN:
                pvar->punkVal = *(pvar->ppunkVal);
                pvar->vt = VT_UNKNOWN;
                break;

            case VT_DISPATCH:
                pvar->pdispVal = *(pvar->ppdispVal);
                pvar->vt = VT_DISPATCH;
                break;

            case VT_ARRAY:
                pvar->parray = *(pvar->pparray);
                pvar->vt = VT_ARRAY;
                break;

            case VT_VARIANT:
                *pvar = *(pvar->pvarVal);
                pvar->vt = VT_VARIANT;
                break;

            default:
                break;
        }
    }

    // Weed out unsupported base types

    switch (pvar->vt & ~VT_ARRAY)
    {
        case VT_UI1:
        case VT_I2:
        case VT_I4:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_DATE:
        case VT_CY:
        case VT_BSTR:
        case VT_UNKNOWN:
        case VT_DISPATCH:
            break;

        default:
            hr = SID_E_INVALIDARG;
            GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Weed out unsupported array types

    if ( (pvar->vt & VT_ARRAY) != 0 )
    {
        switch (pvar->vt)
        {
            case VT_I4:
            case VT_UI1:
            case VT_I2:
            case VT_R4:
            case VT_R8:
            case VT_BOOL:
            case VT_ERROR:
            case VT_DATE:
            case VT_CY:
            case VT_BSTR:
                break;

            default:
                hr = SID_E_INVALIDARG;
                GLOBAL_EXCEPTION_CHECK_GO(hr);
        }
    }
Error:
    RRETURN(hr);
}


HRESULT GetColumnSetID
(
    BSTR           bstrColSetID,
    SColumnSetID **ppSColumnSetID
)
{
    HRESULT hr = S_OK;
    DWORD   cbColSetID = 0;

    *ppSColumnSetID = NULL;

    if (!ValidBstr(bstrColSetID))
    {
        hr = SID_E_INVALID_COLUMNSETID;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    cbColSetID = ::wcslen(bstrColSetID) * sizeof(WCHAR);
    *ppSColumnSetID = (SColumnSetID *)CtlAllocZero(sizeof(SColumnSetID) + cbColSetID);

    if (NULL == *ppSColumnSetID)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    (*ppSColumnSetID)->dwFlags = 0;
    (*ppSColumnSetID)->cBytes = cbColSetID;
    ::memcpy((*ppSColumnSetID)->id, bstrColSetID, cbColSetID);

Error:
    RRETURN(hr);
}


HRESULT PropertyBagFromStream
(
    IStream       *piStream,
    _PropertyBag **pp_PropertyBag
)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;
    ULONG         cbRead = 0;
    ULONG         cbToRead = 0;
    void HUGEP   *pvArrayData = NULL;

    VARIANT var;
    ::VariantInit(&var);

    // Read the array length from the stream

    hr = piStream->Read(&cbToRead, sizeof(cbToRead), &cbRead);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    if (cbRead != sizeof(cbToRead))
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Allocate a SafeArray of VT_UI1 of that size and access its data

    var.parray = ::SafeArrayCreateVector(VT_UI1, 1, cbToRead);
    if (NULL == var.parray)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    var.vt = VT_ARRAY | VT_UI1;

    hr = ::SafeArrayAccessData(var.parray, &pvArrayData);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Read the data from the stream

    hr = piStream->Read(pvArrayData, cbToRead, &cbRead);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    if (cbRead != cbToRead)
    {
        hr = SID_E_INCOMPLETE_WRITE;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // Unaccess the SafeArray so it can be cleaned up in VariantClear() below

    hr = ::SafeArrayUnaccessData(var.parray);
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    pvArrayData = NULL;

    // Create a VBPropertyBag object

    hr = ::CoCreateInstance(CLSID_PropertyBag,
                            NULL, // no aggregation
                            CLSCTX_INPROC_SERVER,
                            IID__PropertyBag,
                            reinterpret_cast<void **>(&p_PropertyBag));
    GLOBAL_EXCEPTION_CHECK_GO(hr);

    // Set its contents from the data

    IfFailGo(p_PropertyBag->put_Contents(var));

    // Return it to the caller

    p_PropertyBag->AddRef();
    *pp_PropertyBag = p_PropertyBag;

Error:
    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(var.parray);
    }
    (void)::VariantClear(&var);
    QUICK_RELEASE(p_PropertyBag)
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\rtutil.h ===
//=--------------------------------------------------------------------------=
// rtutil.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Runtime Utility Functions
//
//=--------------------------------------------------------------------------=

#ifndef _RTUTIL_DEFINED_
#define _RTUTIL_DEFINED_


class CMMCListItems;
class CMMCListItem;
class CScopeItem;
class CSnapIn;
class CMMCClipboard;
class CMMCDataObject;
class CScopePaneItem;

struct IMMCListItem;
struct IMMCListItems;
struct IMMCImages;
struct IMMCClipboard;

// Test whether a VARIANT contains an object

BOOL IsObject(VARIANT var);

// Test whether a VARIANT contains a string and return the BSTR

BOOL IsString(VARIANT var, BSTR *pbstr);

// Convert a VARIANT to a long

HRESULT ConvertToLong(VARIANT var, long *pl);

// String conversion routines. Returned buffer is freed using CtlFree().

HRESULT ANSIFromWideStr(WCHAR *pwszWideStr, char **ppszAnsi);
HRESULT WideStrFromANSI(char *pszAnsi, WCHAR **ppwszWideStr);
HRESULT BSTRFromANSI(char *pszAnsi, BSTR *pbstr);

// Allocate a buffer using CoTaskMemAlloc() and copy a string to it

HRESULT CoTaskMemAllocString(WCHAR *pwszString, LPOLESTR *ppszOut);

// Create registry key names using a prefix and suffix. These routines
// concatenate the two strings into a buffer allocated with CtlAlloc()

HRESULT CreateKeyName(char *pszPrefix, size_t cbPrefix,
                      char *pszSuffix, size_t cbSuffix,
                      char **ppszKeyName);

HRESULT CreateKeyNameW(char *pszPrefix, size_t cbPrefix,
                       WCHAR *pwszSuffix,
                       char  **ppszKeyName);


// Get HBITMAP or HICON out of an image list item

HRESULT GetPicture(IMMCImages *piMMCImages,
                   VARIANT     varIndex,
                   short       TypeNeeded,
                   OLE_HANDLE *phPicture);


// Get HBITMAP or HICON out of an IPictureDisp

HRESULT GetPictureHandle(IPictureDisp *piPictureDisp,
                         short         TypeNeeded,
                         OLE_HANDLE   *phPicture);


// Set a picture object with an empty bitmap

HRESULT CreateEmptyBitmapPicture(IPictureDisp **ppiPictureDisp);
HRESULT CreateIconPicture(IPictureDisp **ppiPictureDisp, HICON hicon);
HRESULT CreatePicture(IPictureDisp **ppiPictureDisp, PICTDESC *pDesc);


// Create a copy of a bitmap

HRESULT CopyBitmap(HBITMAP hbmSrc, HBITMAP *phbmCopy);

// Clone a persistable object using serialization to a stream on an HGLOBAL

HRESULT CloneObject(IUnknown *punkSrc, IUnknown *punkDest);

// Clone a list item (uses CloneObject)

HRESULT CloneListItem(CMMCListItem *pMMCListItemSrc,
                      IMMCListItem **ppiMMCListItemClone);

// Clones a list item and adds it a specified collection

HRESULT CloneListItemIntoCollection(CMMCListItem  *pListItemSrc,
                                    IMMCListItems *piMMCListItems);


// Convert SnapInViewModeConstants to MMC_VIEW_STYLE_XXXX contants and vice-versa

void VBViewModeToMMCViewMode(SnapInViewModeConstants  VBViewMode,
                             long                    *pMMCViewMode);

void MMCViewModeToVBViewMode(long                     MMCViewMode,
                             SnapInViewModeConstants *pVBViewMode);


// Create an MMCClipboard object holding the selection represented by
// an IDataObject received from MMC

HRESULT CreateSelection(IDataObject                   *piDataObject, 
                        IMMCClipboard                **ppiMMCClipboard,
                        CSnapIn                       *pSnapIn,      
                        SnapInSelectionTypeConstants  *pSelectionType);

// Clones a single list item into MMCClipboard.ListItems

HRESULT AddListItemToClipboard(CMMCListItem  *pMMCListItem,
                               CMMCClipboard *pMMCClipboard);

// Clones a single scope item into MMCClipboard.ScopeItems

HRESULT AddScopeItemToClipboard(CScopeItem    *pScopeItem,
                                CMMCClipboard *pMMCClipboard);

// Extracts the snap-in's CLSID from
// HKEY_LOCAL_MACHINE\Software\Microsoft\Visual Basic\6.0\SnapIns\<node type GUID>

HRESULT GetSnapInCLSID(BSTR bstrNodeTypeGUID, char szClsid[], size_t cbClsid);


// Extract the specified data using IDataObject->GetDataHere() with TYMED_HGLOBAL

HRESULT GetData(IDataObject *piDataObject, CLIPFORMAT cf, HGLOBAL *phData);


// Extract the specified string data using IDataObject->GetDataHere() with
// TYMED_HGLOBAL and copy it to a newly allocated BSTR

HRESULT GetStringData(IDataObject *piDataObject, CLIPFORMAT cf, BSTR *pbstrData);


// Write the contents of a one-dimensional VT_UI1 SafeArray to a stream.
// Optionally write the length of the array before the data.

enum WriteSafeArrayOptions { WriteLength, DontWriteLength };

HRESULT WriteSafeArrayToStream(SAFEARRAY             *psa,
                               IStream               *piStream,
                               WriteSafeArrayOptions  Option);


// Look up an image in MMCListView.Icons.ListImages and get its index property.
   
HRESULT GetImageIndex(IMMCListView *piMMCListView,
                      VARIANT       varIndex,
                      int          *pnIndex);


// Given a data object, check whether it represents a multiple selection
// i.e. supports CCF_MMC_MULTISELECT_DATAOBJECT(TRUE)

HRESULT IsMultiSelect(IDataObject *piDataObject, BOOL *pfMultiSelect);


// Given a multi-select data object from MMC (i.e. supports
// CCF_MMC_MULTISELECT_DATAOBJECT(TRUE) and CCF_MULTI_SELECT_SNAPINS), add the
// contained data objects to an MMCClipboard

HRESULT InterpretMultiSelect(IDataObject   *piDataObject,
                             CSnapIn       *pSnapIn,
                             CMMCClipboard *pMMCClipboard);


// Add a foreign data object to an MMCClipboard object

HRESULT AddForeignDataObject(IDataObject   *piDataObject,
                             CMMCClipboard *pMMCClipboard,
                             CSnapIn       *pSnapIn);


// Determine whether an IDataObject belongs to the snap-in.

void IdentifyDataObject(IDataObject     *piDataObject,
                        CSnapIn         *pSnapIn,
                        CMMCDataObject **ppMMCDataObject,
                        BOOL            *pfNotFromThisSnapIn);


// Add the contents of a data object to an MMCClipboard

HRESULT InterpretDataObject(IDataObject   *piDataObject,
                            CSnapIn       *pSnapIn,
                            CMMCClipboard *pMMCClipboard);

// Create an instance of a CSnapInAutomationObject derived class

template <class InterfaceType>
HRESULT CreateObject
(
    UINT            idObject,
    REFIID          iidObject,
    InterfaceType **ppiInterface
)
{
    HRESULT   hr = S_OK;
    IUnknown *punkObject = NULL;

    // Double check that the create function exists

    if (NULL == CREATEFNOFOBJECT(idObject))
    {
        hr = SID_E_INTERNAL;
        GLOBAL_EXCEPTION_CHECK(hr);
    }

    // Create the object

    punkObject = CREATEFNOFOBJECT(idObject)(NULL);
    IfFalseGo(NULL != punkObject, SID_E_OUTOFMEMORY);

    // Get IPersistStreamInit on the object and load it

    H_IfFailGo(punkObject->QueryInterface(iidObject,
                                       reinterpret_cast<void **>(ppiInterface)));

Error:
    QUICK_RELEASE(punkObject);
    H_RRETURN(hr);
}
                     

// Get an MMCDataObject and a cookie for a VARIANT containing either a single
// ScopeItem, a single MMCListItem, or an array of Object containing ScopeItems
// and/or MMCListItems

HRESULT DataObjectFromObjects(VARIANT       varObjects,
                              MMC_COOKIE   *pCookie,
                              IDataObject **ppiDataObject);

// Get an MMCDataObject and a cookie for an IUnknown* on either a ScopeItem or
// an MMCListItem

HRESULT DataObjectFromSingleObject(IUnknown     *punkObject,
                                   MMC_COOKIE   *pCookie,
                                   IDataObject **ppiDataObject);

// Get an MMCDataObject and a cookie for an array of IUnknown*s on ScopeItems
// and/or MMCListItems

HRESULT DataObjectFromObjectArray(IUnknown HUGEP **ppunkObjects,
                                  LONG             cObjects,
                                  MMC_COOKIE      *pCookie,
                                  IDataObject    **ppiDataObject);

// Checks for supported types when using a VARIANT across threads.

HRESULT CheckVariantForCrossThreadUsage(VARIANT *pvar);

// Allocates an SNodeID2 structure and fills it with the specified column set
// ID string. Caller must free returned pointer with CtlFree().

HRESULT GetColumnSetID(BSTR           bstrColSetID, SColumnSetID **ppColumnSetID);

// Creates a property bag and fills it with the contents of a stream that
// contains the previously saved contents of a property bag

HRESULT PropertyBagFromStream(IStream *piStream, _PropertyBag **pp_PropertyBag);


#endif // _RTUTIL_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdef.h ===
//=--------------------------------------------------------------------------=
// scitdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEITEMDEF_DEFINED_
#define _SCOPEITEMDEF_DEFINED_


class CScopeItemDef : public CSnapInAutomationObject,
                      public CPersistence,
                      public IScopeItemDef
{
    private:
        CScopeItemDef(IUnknown *punkOuter);
        ~CScopeItemDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopeItemDef

        BSTR_PROPERTY_RW(CScopeItemDef,         Name,  DISPID_SCOPEITEMDEF_NAME);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       Index, long, DISPID_SCOPEITEMDEF_INDEX);
        BSTR_PROPERTY_RW(CScopeItemDef,         Key, DISPID_SCOPEITEMDEF_KEY);
        BSTR_PROPERTY_RW(CScopeItemDef,         NodeTypeName, DISPID_SCOPEITEMDEF_NODE_TYPE_NAME);
        BSTR_PROPERTY_RO(CScopeItemDef,         NodeTypeGUID, DISPID_SCOPEITEMDEF_NODE_TYPE_GUID);
        BSTR_PROPERTY_RW(CScopeItemDef,         DisplayName,  DISPID_SCOPEITEMDEF_DISPLAY_NAME);

        VARIANT_PROPERTY_RO(CScopeItemDef,      Folder, DISPID_SCOPEITEMDEF_FOLDER);
        STDMETHOD(put_Folder)(VARIANT varFolder);
        
        BSTR_PROPERTY_RW(CScopeItemDef,         DefaultDataFormat,  DISPID_SCOPEITEMDEF_DEFAULT_DATA_FORMAT);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       AutoCreate, VARIANT_BOOL, DISPID_SCOPEITEMDEF_AUTOCREATE);
        BSTR_PROPERTY_RW(CScopeItemDef,         DefaultView,  DISPID_SCOPEITEMDEF_DEFAULTVIEW);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       Extensible,  VARIANT_BOOL, DISPID_SCOPEITEMDEF_EXTENSIBLE);
        SIMPLE_PROPERTY_RW(CScopeItemDef,       HasChildren,  VARIANT_BOOL, DISPID_SCOPEITEMDEF_HAS_CHILDREN);
        OBJECT_PROPERTY_RO(CScopeItemDef,       ViewDefs, IViewDefs, DISPID_SCOPEITEMDEF_VIEWDEFS);
        OBJECT_PROPERTY_RO(CScopeItemDef,       Children, IScopeItemDefs, DISPID_SCOPEITEMDEF_CHILDREN);
        VARIANTREF_PROPERTY_RW(CScopeItemDef,   Tag, DISPID_SCOPEITEMDEF_TAG);
        OBJECT_PROPERTY_RW(CScopeItemDef,       ColumnHeaders, IMMCColumnHeaders, DISPID_SCOPEITEMDEF_COLUMN_HEADERS);

    // Public Utility Methods

    public:
        BOOL Extensible() { return VARIANTBOOL_TO_BOOL(m_Extensible); }
        BSTR GetNodeTypeGUID() { return m_bstrNodeTypeGUID; }

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[2];
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItemDef,           // name
                                &CLSID_ScopeItemDef,    // clsid
                                "ScopeItemDef",         // objname
                                "ScopeItemDef",         // lblname
                                &CScopeItemDef::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IScopeItemDef,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _SCOPEITEMDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resview.h ===
//=--------------------------------------------------------------------------=
// resview.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultView class definition - implements ResultView object
//
//=--------------------------------------------------------------------------=

#ifndef _RESVIEW_DEFINED_
#define _RESVIEW_DEFINED_

#include "dataobj.h"
#include "spanitem.h"
#include "listview.h"
#include "msgview.h"

class CScopePaneItem;
class CMMCListView;
class CMessageView;

class CResultView : public CSnapInAutomationObject,
                    public IResultView
{
    private:
        CResultView(IUnknown *punkOuter);
        ~CResultView();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IResultView
        BSTR_PROPERTY_RW(CResultView,        Name,                       DISPID_RESULTVIEW_NAME);
        SIMPLE_PROPERTY_RW(CResultView,      Index,                      long, DISPID_RESULTVIEW_INDEX);
        BSTR_PROPERTY_RW(CResultView,        Key,                        DISPID_RESULTVIEW_KEY);
        COCLASS_PROPERTY_RO(CResultView,     ScopePaneItem,              ScopePaneItem, IScopePaneItem, DISPID_RESULTVIEW_SCOPEPANEITEM);

        STDMETHOD(get_Control)(IDispatch **ppiDispatch);

        SIMPLE_PROPERTY_RW(CResultView,      AddToViewMenu,              VARIANT_BOOL, DISPID_RESULTVIEW_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CResultView,        ViewMenuText,               DISPID_RESULTVIEW_VIEW_MENU_TEXT);
        SIMPLE_PROPERTY_RW(CResultView,      Type,                       SnapInResultViewTypeConstants, DISPID_RESULTVIEW_TYPE);
        BSTR_PROPERTY_RW(CResultView,        DisplayString,              DISPID_RESULTVIEW_DISPLAY_STRING);
        COCLASS_PROPERTY_RO(CResultView,     ListView,                   MMCListView, IMMCListView, DISPID_RESULTVIEW_LISTVIEW);
        COCLASS_PROPERTY_RO(CResultView,     Taskpad,                    Taskpad, ITaskpad, DISPID_RESULTVIEW_TASKPAD);
        COCLASS_PROPERTY_RO(CResultView,     MessageView,                MMCMessageView, IMMCMessageView, DISPID_RESULTVIEW_MESSAGEVIEW);
        VARIANTREF_PROPERTY_RW(CResultView,  Tag,                        DISPID_RESULTVIEW_TAG);
        BSTR_PROPERTY_RW(CResultView,        DefaultItemTypeGUID,        DISPID_RESULTVIEW_DEFAULT_ITEM_TYPE_GUID);
        BSTR_PROPERTY_RW(CResultView,        DefaultDataFormat,          DISPID_RESULTVIEW_DEFAULT_DATA_FORMAT);
        SIMPLE_PROPERTY_RW(CResultView,      AlwaysCreateNewOCX,         VARIANT_BOOL, DISPID_RESULTVIEW_ALWAYS_CREATE_NEW_OCX);
        STDMETHOD(SetDescBarText)(BSTR Text);

    // Public utility methods
        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        void SetScopePaneItem(CScopePaneItem *pScopePaneItem);
        CScopePaneItem *GetScopePaneItem() { return m_pScopePaneItem; }
        CMMCListView *GetListView() { return m_pMMCListView; }
        CMessageView *GetMessageView() { return m_pMessageView; }
        HRESULT SetControl(IUnknown *punkControl);

        void SetInActivate(BOOL fInActivate) { m_fInActivate = fInActivate; }
        BOOL InActivate() { return m_fInActivate; }

        void SetInInitialize(BOOL fInInitialize) { m_fInInitialize = fInInitialize; }
        BOOL InInitialize() { return m_fInInitialize; }

        LPOLESTR GetActualDisplayString() { return m_pwszActualDisplayString; }
        HRESULT SetActualDisplayString(LPOLESTR pwszDisplayString);

        SnapInResultViewTypeConstants GetActualType() { return m_ActualResultViewType; }
        void SetActualType(SnapInResultViewTypeConstants Type) { m_ActualResultViewType = Type; }

        BSTR GetDisplayString() { return m_bstrDisplayString; }
        BSTR GetDefaultItemTypeGUID() { return m_bstrDefaultItemTypeGUID; }

        BOOL AlwaysCreateNewOCX() { return VARIANTBOOL_TO_BOOL(m_AlwaysCreateNewOCX); }
        void SetAlwaysCreateNewOCX(VARIANT_BOOL fCreate) { m_AlwaysCreateNewOCX = fCreate; }

    // CSnapInAutomationObject overrides
        HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        CSnapIn                       *m_pSnapIn;        // Owning snap-in
        CScopePaneItem                *m_pScopePaneItem; // ResultView.ScopePaneItem
        CMMCListView                  *m_pMMCListView;   // ResultView.ListView
        CMessageView                  *m_pMessageView;   // ResultView.MessageView
        BOOL                           m_fInActivate;    // TRUE=this object in the middle of a ResultViews_Activate event
        BOOL                           m_fInInitialize;  // TRUE=this object in the middle of a ResultViews_Initialize event

        // This variable holds the real result view type. When using a predefined
        // result view (ResultView.Type = siPredefined) this says what it really
        // is (e.g. siURLView, siListView etc.)

        SnapInResultViewTypeConstants  m_ActualResultViewType;

        // Same deal for display string
        
        LPOLESTR                       m_pwszActualDisplayString;

        // For OCX views, control's IDispatch is cached here
        
        IDispatch                     *m_pdispControl;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ResultView,                // name
                                &CLSID_ResultView,         // clsid
                                "ResultView",              // objname
                                "ResultView",              // lblname
                                &CResultView::Create,      // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IResultView,          // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _RESVIEW_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\resviews.h ===
//=--------------------------------------------------------------------------=
// resviews.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CResultViews class definition - implements ResultViews collection
//
//=--------------------------------------------------------------------------=

#ifndef _RESULTVIEWS_DEFINED_
#define _RESULTVIEWS_DEFINED_

#include "collect.h"
#include "spanitem.h"
#include "snapin.h"

class CSnapIn;
class CScopePaneItem;

class CResultViews : public CSnapInCollection<IResultView, ResultView, IResultViews>
{
    protected:
        CResultViews(IUnknown *punkOuter);
        ~CResultViews();

    public:
        static IUnknown *Create(IUnknown * punk);

        void SetSnapIn(CSnapIn *pSnapIn);
        void SetScopePaneItem(CScopePaneItem *pScopePaneItem);
        void FireInitialize(IResultView *piResultView);
        void FireTerminate(IResultView *piResultView);
        void FireInitializeControl(IResultView *piResultView);
        void FireActivate(IResultView *piResultView);
        void FireDeactivate(IResultView *piResultView, BOOL *pfKeep);
        void FireColumnClick(IResultView              *piResultView,
                             long                      lColumn,
                             SnapInSortOrderConstants  SortOption);
        void FireListItemDblClick(IResultView  *piResultView,
                                  IMMCListItem *piMMCListItem,
                                  BOOL         *pfDoDefault);
        void FireScopeItemDblClick(IResultView *piResultView,
                                   IScopeItem  *piScopeItem,
                                   BOOL        *pfDoDefault);
        void FirePropertyChanged(IResultView    *piResultView,
                                 IMMCListItem   *piMMCListItem,
                                 VARIANT         Data);
        void FireTaskClick(IResultView *piResultView, ITask *piTask);
        void FireListpadButtonClick(IResultView *piResultView);
        void FireTaskNotify(IResultView *piResultView,
                            VARIANT Arg, VARIANT Param);
        void FireHelp(IResultView *piResultView, IMMCListItem *piMMCListItem);
        void FireItemRename(IResultView *piResultView,
                            IMMCListItem *piMMCListItem, BSTR bstrNewName);
        void FireItemViewChange(IResultView *piResultView,
                                IMMCListItem *piMMCListItem, VARIANT varHint);
        void FireFindItem(IResultView *piResultView,
                          BSTR         bstrName,
                          long         lStart,
                          VARIANT_BOOL fvarPartial,
                          VARIANT_BOOL fvarWrap,
                          VARIANT_BOOL *pfvarFound,
                          long         *plIndex);
        void FireCacheHint(IResultView *piResultView,
                           long         lStart,
                           long         lEnd);
        void FireSortItems(IResultView              *piResultView,
                           long                      lColumn,
                           SnapInSortOrderConstants  Order);
        void FireDeselectAll(IResultView      *piResultView,
                             IMMCConsoleVerbs *piMMCConsoleVerbs,
                             IMMCControlbar   *piMMCControlbar);
        void FireCompareItems(IResultView  *piResultView,
                              IDispatch    *piObject1,
                              IDispatch    *piObject2,
                              long          lColumn,
                              VARIANT      *pvarResult);
        void FireGetVirtualItemData(IResultView  *piResultView,
                                    IMMCListItem *piMMCListItem);
        void FireGetVirtualItemDisplayInfo(IResultView  *piResultView,
                                           IMMCListItem *piMMCListItem);
        void FireColumnsChanged(IResultView *piResultView,
                                VARIANT      Columns,
                                VARIANT_BOOL *pfvarPersist);
        void FireFilterChange(IResultView                     *piResultView, 
                              IMMCColumnHeader                *piMMCColumnHeader,
                              SnapInFilterChangeTypeConstants  Type);
        void FireFilterButtonClick(IResultView      *piResultView,
                                   IMMCColumnHeader *piMMCColumnHeader,
                                   long              Left,
                                   long              Top,
                                   long              Height,
                                   long              Width);


        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        CSnapIn        *m_pSnapIn;          // owning snap-in
        CScopePaneItem *m_pScopePaneItem;   // owning ScopePaneItem

        // Event parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtInitializeControl[1];
        static EVENTINFO m_eiInitializeControl;

        static VARTYPE   m_rgvtActivate[1];
        static EVENTINFO m_eiActivate;

        static VARTYPE   m_rgvtDeactivate[2];
        static EVENTINFO m_eiDeactivate;

        static VARTYPE   m_rgvtColumnClick[3];
        static EVENTINFO m_eiColumnClick;

        static VARTYPE   m_rgvtListItemDblClick[3];
        static EVENTINFO m_eiListItemDblClick;

        static VARTYPE   m_rgvtScopeItemDblClick[3];
        static EVENTINFO m_eiScopeItemDblClick;

        static VARTYPE   m_rgvtPropertyChanged[3];
        static EVENTINFO m_eiPropertyChanged;

        static VARTYPE   m_rgvtTaskClick[2];
        static EVENTINFO m_eiTaskClick;

        static VARTYPE   m_rgvtListpadButtonClick[1];
        static EVENTINFO m_eiListpadButtonClick;

        static VARTYPE   m_rgvtTaskNotify[3];
        static EVENTINFO m_eiTaskNotify;

        static VARTYPE   m_rgvtHelp[2];
        static EVENTINFO m_eiHelp;

        static VARTYPE   m_rgvtItemRename[3];
        static EVENTINFO m_eiItemRename;

        static VARTYPE   m_rgvtItemViewChange[3];
        static EVENTINFO m_eiItemViewChange;

        static VARTYPE   m_rgvtFindItem[7];
        static EVENTINFO m_eiFindItem;

        static VARTYPE   m_rgvtCacheHint[3];
        static EVENTINFO m_eiCacheHint;

        static VARTYPE   m_rgvtSortItems[3];
        static EVENTINFO m_eiSortItems;

        static VARTYPE   m_rgvtDeselectAll[3];
        static EVENTINFO m_eiDeselectAll;

        static VARTYPE   m_rgvtCompareItems[5];
        static EVENTINFO m_eiCompareItems;

        static VARTYPE   m_rgvtGetVirtualItemDisplayInfo[2];
        static EVENTINFO m_eiGetVirtualItemDisplayInfo;

        static VARTYPE   m_rgvtGetVirtualItemData[2];
        static EVENTINFO m_eiGetVirtualItemData;

        static VARTYPE   m_rgvtColumnsChanged[3];
        static EVENTINFO m_eiColumnsChanged;

        static VARTYPE   m_rgvtColumnsSet[1];
        static EVENTINFO m_eiColumnsSet;

        static VARTYPE   m_rgvtFilterChange[3];
        static EVENTINFO m_eiFilterChange;

        static VARTYPE   m_rgvtFilterButtonClick[6];
        static EVENTINFO m_eiFilterButtonClick;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ResultViews,                // name
                                &CLSID_ResultViews,         // clsid
                                "ResultViews",              // objname
                                "ResultViews",              // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IResultViews,          // dispatch IID
                                &DIID_DResultViewsEvents,   // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _RESULTVIEWS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\rtconst.h ===
//=--------------------------------------------------------------------------=
// rtconst.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Designer Runtime Constants
//
//=--------------------------------------------------------------------------=

#ifndef _RTCONST_DEFINED_
#define _RTCONST_DEFINED_

// MMC Registry Key Names

#define MMCKEY_SNAPINS              "Software\\Microsoft\\MMC\\SnapIns\\"
#define MMCKEY_SNAPINS_LEN          (sizeof(MMCKEY_SNAPINS) - 1)

#define MMCKEY_NAMESTRING           "NameString"

#define MMCKEY_ABOUT                "About"

#define MMCKEY_STANDALONE           "StandAlone"

#define MMCKEY_NODETYPES            "Software\\Microsoft\\MMC\\NodeTypes\\"
#define MMCKEY_NODETYPES_LEN        (sizeof(MMCKEY_NODETYPES) - 1)

#define MMCKEY_SNAPIN_NODETYPES     "NodeTypes"
#define MMCKEY_SNAPIN_NODETYPES_LEN (sizeof(MMCKEY_SNAPIN_NODETYPES) - 1)

#define MMCKEY_EXTENSIONS           "Extensions"
#define MMCKEY_EXTENSIONS_LEN       (sizeof(MMCKEY_EXTENSIONS_LEN) - 1)

#define MMCKEY_NAMESPACE            "NameSpace"
#define MMCKEY_NAMESPACE_LEN        (sizeof(MMCKEY_NAMESPACE) - 1)

#define MMCKEY_CONTEXTMENU          "ContextMenu"
#define MMCKEY_CONTEXTMENU_LEN      (sizeof(MMCKEY_CONTEXTMENU) - 1)

#define MMCKEY_TOOLBAR              "Toolbar"
#define MMCKEY_TOOLBAR_LEN          (sizeof(MMCKEY_TOOLBAR) - 1)

#define MMCKEY_PROPERTYSHEET        "PropertySheet"
#define MMCKEY_PROPERTYSHEET_LEN    (sizeof(MMCKEY_PROPERTYSHEET) - 1)

#define MMCKEY_TASK                 "Task"
#define MMCKEY_TASK_LEN             (sizeof(MMCKEY_TASK) - 1)

#define MMCKEY_DYNAMIC_EXTENSIONS     "Dynamic Extensions"
#define MMCKEY_DYNAMIC_EXTENSIONS_LEN (sizeof(MMCKEY_DYNAMIC_EXTENSIONS) - 1)

// Same keys with leading backslash

#define MMCKEY_S_EXTENSIONS           "\\Extensions"
#define MMCKEY_S_EXTENSIONS_LEN       (sizeof(MMCKEY_S_EXTENSIONS) - 1)

#define MMCKEY_S_NAMESPACE            "\\NameSpace"
#define MMCKEY_S_NAMESPACE_LEN        (sizeof(MMCKEY_S_NAMESPACE) - 1)

#define MMCKEY_S_CONTEXTMENU          "\\ContextMenu"
#define MMCKEY_S_CONTEXTMENU_LEN      (sizeof(MMCKEY_S_CONTEXTMENU) - 1)

#define MMCKEY_S_TOOLBAR              "\\Toolbar"
#define MMCKEY_S_TOOLBAR_LEN          (sizeof(MMCKEY_S_TOOLBAR) - 1)

#define MMCKEY_S_PROPERTYSHEET        "\\PropertySheet"
#define MMCKEY_S_PROPERTYSHEET_LEN    (sizeof(MMCKEY_S_PROPERTYSHEET) - 1)

#define MMCKEY_S_TASK                 "\\Task"
#define MMCKEY_S_TASK_LEN             (sizeof(MMCKEY_S_TASK) - 1)

#define MMCKEY_S_DYNAMIC_EXTENSIONS     "\\Dynamic Extensions"
#define MMCKEY_S_DYNAMIC_EXTENSIONS_LEN (sizeof(MMCKEY_S_DYNAMIC_EXTENSIONS) - 1)

// Private Registry Keys

#define KEY_SNAPIN_CLSID            "Software\\Microsoft\\Visual Basic\\6.0\\SnapIns\\"
#define KEY_SNAPIN_CLSID_LEN        (sizeof(KEY_SNAPIN_CLSID) - 1)

// Key of static node in scope item collection

#define STATIC_NODE_KEY             L"Static Node"

// res:// URL prefix

#define RESURL                      L"res://"
#define CCH_RESURL                  ((sizeof(RESURL) / sizeof(WCHAR)) - 1)

// default taskpad names

#define DEFAULT_TASKPAD             L"/default.htm"
#define CCH_DEFAULT_TASKPAD         ((sizeof(DEFAULT_TASKPAD) / sizeof(WCHAR)) - 1)

#define LISTPAD                     L"/listpad.htm"
#define CCH_LISTPAD                 ((sizeof(LISTPAD) / sizeof(WCHAR)) - 1)

#define LISTPAD_HORIZ               L"/horizontal.htm"
#define CCH_LISTPAD_HORIZ           ((sizeof(LISTPAD_HORIZ) / sizeof(WCHAR)) - 1)

// Default taskpad names that may appear in an MMCN_RESTORE_VIEW notification

#define DEFAULT_TASKPAD2            L"/reload.htm"
#define CCH_DEFAULT_TASKPAD2        ((sizeof(DEFAULT_TASKPAD2) / sizeof(WCHAR)) - 1)

#define LISTPAD2                    L"/reload2.htm"
#define CCH_LISTPAD2                ((sizeof(LISTPAD2) / sizeof(WCHAR)) - 1)

#define LISTPAD3                    L"/reload3.htm"
#define CCH_LISTPAD3                ((sizeof(LISTPAD3) / sizeof(WCHAR)) - 1)


// Default value for filter change timeout in a filtered listview

#define DEFAULT_FILTER_CHANGE_TIMEOUT   1000L

#endif // _RTCONST_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdef.cpp ===
//=--------------------------------------------------------------------------=
// scitdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "scitdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CScopeItemDef::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_ScopeItemDefGeneralPP,
    &CLSID_ScopeItemDefColHdrsPP
};


#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItemDef::CScopeItemDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_SCOPEITEMDEF,
                            static_cast<IScopeItemDef *>(this),
                            static_cast<CScopeItemDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ScopeItemDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeItemDef::~CScopeItemDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    (void)::VariantClear(&m_varFolder);
    FREESTRING(m_bstrDefaultDataFormat);
    FREESTRING(m_bstrDefaultView);
    RELEASE(m_piViewDefs);
    RELEASE(m_piChildren);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piColumnHeaders);
    InitMemberVariables();
}

void CScopeItemDef::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;

    ::VariantInit(&m_varFolder);

    m_bstrDefaultDataFormat = NULL;
    m_AutoCreate = VARIANT_FALSE;
    m_bstrDefaultView = NULL;
    m_HasChildren = VARIANT_TRUE;
    m_Extensible = VARIANT_TRUE;
    m_piViewDefs = NULL;
    m_piChildren = NULL;

    ::VariantInit(&m_varTag);

    m_piColumnHeaders = NULL;
}

IUnknown *CScopeItemDef::Create(IUnknown * punkOuter)
{
    CScopeItemDef *pScopeItemDef = New CScopeItemDef(punkOuter);
    if (NULL == pScopeItemDef)
    {
        return NULL;
    }
    else
    {
        return pScopeItemDef->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                          IScopeItemDef Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeItemDef::put_Folder(VARIANT varFolder)
{
    HRESULT hr = S_OK;
    long    lFolder = 0;

    // This property can be entered in the property browser at design time.
    // Its default value is an empty string. If the user types in a number
    // then VB will convert it to a string. If the user does not use the
    // same number as the key of the image, then the runtime won't find the
    // image. To prevent this, we check if the property is a string, and if so,
    // then we check if it is only digits. If it is only digits then we convert
    // it to VT_I4.

    if (VT_BSTR == varFolder.vt)
    {
        hr = ::ConvertToLong(varFolder, &lFolder);
        if (S_OK == hr)
        {
            varFolder.vt = VT_I4;
            varFolder.lVal = lFolder;
        }
    }
    IfFailGo(SetVariant(varFolder, &m_varFolder, DISPID_SCOPEITEMDEF_FOLDER));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=


HRESULT CScopeItemDef::OnSetHost()
{
    HRESULT hr = S_OK;
    IfFailRet(SetObjectHost(m_piChildren));
    IfFailRet(SetObjectHost(m_piViewDefs));
    return S_OK;
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDef::Persist()
{
    HRESULT hr = S_OK;
    GUID    NodeTypeGUID = GUID_NULL;

    WCHAR   wszNodeTypeGUID[64];
    ::ZeroMemory(wszNodeTypeGUID, sizeof(wszNodeTypeGUID));

    VARIANT varTagDefault;
    VariantInit(&varTagDefault);

    VARIANT varFolderDefault;
    VariantInit(&varFolderDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("NodeTypeName")));

    // On InitNew generate a node type GUID

    if (InitNewing())
    {
        IfFailGo(::CoCreateGuid(&NodeTypeGUID));
        if (0 ==::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                                  sizeof(wszNodeTypeGUID) /
                                  sizeof(wszNodeTypeGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(PersistBstr(&m_bstrNodeTypeGUID, wszNodeTypeGUID, OLESTR("NodeTypeGUID")));

    IfFailGo(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    IfFailGo(PersistVariant(&m_varFolder, varFolderDefault, OLESTR("Folder")));

    IfFailGo(PersistBstr(&m_bstrDefaultDataFormat, L"", OLESTR("DefaultDataFormat")));

    IfFailGo(PersistSimpleType(&m_AutoCreate, VARIANT_FALSE, OLESTR("AutoCreate")));

    IfFailGo(PersistBstr(&m_bstrDefaultView, L"", OLESTR("DefaultView")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 6) )
    {
    }
    else
    {
        IfFailGo(PersistSimpleType(&m_HasChildren, VARIANT_TRUE, OLESTR("HasChildren")));
    }

    IfFailGo(PersistSimpleType(&m_Extensible, VARIANT_TRUE, OLESTR("Extensible")));

    IfFailGo(PersistObject(&m_piViewDefs, CLSID_ViewDefs,
                           OBJECT_TYPE_VIEWDEFS, IID_IViewDefs,
                           OLESTR("ViewDefs")));

    IfFailGo(PersistObject(&m_piChildren, CLSID_ScopeItemDefs,
                           OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                           OLESTR("Children")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistObject(&m_piColumnHeaders, CLSID_MMCColumnHeaders,
                           OBJECT_TYPE_MMCCOLUMNHEADERS, IID_IMMCColumnHeaders,
                           OLESTR("ColumnHeaders")));

    // Tell ViewDefs that all collections should serialize keys only as the
    // actual objects are stored in the master collections owned by
    // SnapInDesignerDef. We only need to serialize the view names. 

    if (InitNewing())
    {
        IfFailGo(UseKeysOnly(m_piViewDefs));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IScopeItemDef == riid)
    {
        *ppvObjOut = static_cast<IScopeItemDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdefs.h ===
//=--------------------------------------------------------------------------=
// scitdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDefs class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEITEMDEFS_DEFINED_
#define _SCOPEITEMDEFS_DEFINED_

#include "collect.h"

class CScopeItemDefs : public CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>,
                       public CPersistence
{
    protected:
        CScopeItemDefs(IUnknown *punkOuter);
        ~CScopeItemDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItemDefs,           // name
                                &CLSID_ScopeItemDefs,    // clsid
                                "ScopeItemDefs",         // objname
                                "ScopeItemDefs",         // lblname
                                &CScopeItemDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,      // major version
                                TLIB_VERSION_MINOR,      // minor version
                                &IID_IScopeItemDefs,     // dispatch IID
                                NULL,                    // no events IID
                                HELP_FILENAME,           // help file
                                TRUE);                   // thread safe


#endif // _SCOPEITEMDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitem.cpp ===
//=--------------------------------------------------------------------------=
// scopitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "snapin.h"
#include "views.h"
#include "dataobj.h"
#include "scopitem.h"
#include "scopnode.h"
#include "colhdrs.h"
#include "lsubitms.h"
#include "xtensons.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItem::CScopeItem(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SCOPEITEM,
                           static_cast<IScopeItem *>(this),
                           static_cast<CScopeItem *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_ScopeItem,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeItem::~CScopeItem()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varFolder);
    RELEASE(m_piData);
    FREESTRING(m_bstrDefaultDataFormat);
    RELEASE(m_piDynamicExtensions);
    (void)::VariantClear(&m_varTag);
    RELEASE(m_piScopeNode);
    RELEASE(m_piColumnHeaders);
    RELEASE(m_piListSubItems);
    RELEASE(m_piScopeItemDef);
    RELEASE(m_piDynamicExtensions);
    FREESTRING(m_bstrNodeID);
    InitMemberVariables();
}

void CScopeItem::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;

    ::VariantInit(&m_varFolder);

    m_piData = NULL;
    m_bstrDefaultDataFormat = NULL;
    m_piDynamicExtensions = NULL;
    m_SlowRetrieval = VARIANT_FALSE;
    m_bstrNodeID = NULL;

    ::VariantInit(&m_varTag);

    m_piScopeNode = NULL;
    m_Pasted = VARIANT_FALSE;
    m_piColumnHeaders = NULL;
    m_piListSubItems = NULL;

    m_fIsStatic = FALSE;
    m_pSnapIn = NULL;
    m_pScopeNode = NULL;
    m_piScopeItemDef = NULL;
    m_pData = NULL;
    m_piDynamicExtensions = NULL;
    m_Bold = VARIANT_FALSE;
}

IUnknown *CScopeItem::Create(IUnknown * punkOuter)
{
    HRESULT          hr = S_OK;
    IUnknown        *punkScopeItem = NULL;
    IUnknown        *punkScopeNode = NULL;
    IUnknown        *punkMMCColumnHeaders = NULL;
    IUnknown        *punkMMCListSubItems = NULL;
    IUnknown        *punkMMCDataObject = NULL;

    CScopeItem *pScopeItem = New CScopeItem(punkOuter);

    IfFalseGo(NULL != pScopeItem, SID_E_OUTOFMEMORY);
    punkScopeItem = pScopeItem->PrivateUnknown();

    // Create contained objects

    punkScopeNode = CScopeNode::Create(NULL);
    if (NULL == punkScopeNode)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopeNode->QueryInterface(IID_IScopeNode,
                                           reinterpret_cast<void **>(&pScopeItem->m_piScopeNode)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pScopeItem->m_piScopeNode, &pScopeItem->m_pScopeNode));
    pScopeItem->m_pScopeNode->SetScopeItem(pScopeItem);

    punkMMCColumnHeaders = CMMCColumnHeaders::Create(NULL);
    if (NULL == punkMMCColumnHeaders)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCColumnHeaders->QueryInterface(IID_IMMCColumnHeaders,
                    reinterpret_cast<void **>(&pScopeItem->m_piColumnHeaders)));

    punkMMCListSubItems = CMMCListSubItems::Create(NULL);
    if (NULL == punkMMCListSubItems)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCListSubItems->QueryInterface(IID_IMMCListSubItems,
                     reinterpret_cast<void **>(&pScopeItem->m_piListSubItems)));

    punkMMCDataObject = CMMCDataObject::Create(NULL);
    if (NULL == punkMMCDataObject)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCDataObject->QueryInterface(IID_IMMCDataObject,
                              reinterpret_cast<void **>(&pScopeItem->m_piData)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(pScopeItem->m_piData, &pScopeItem->m_pData));
    pScopeItem->m_pData->SetType(CMMCDataObject::ScopeItem);
    pScopeItem->m_pData->SetScopeItem(pScopeItem);

Error:
    QUICK_RELEASE(punkScopeNode);
    QUICK_RELEASE(punkMMCColumnHeaders);
    QUICK_RELEASE(punkMMCListSubItems);
    QUICK_RELEASE(punkMMCDataObject);
    if (FAILED(hr))
    {
        RELEASE(punkScopeItem);
    }
    return punkScopeItem;
}

LPOLESTR CScopeItem::GetDisplayNamePtr()
{
    return m_pScopeNode->GetDisplayNamePtr();
}

void CScopeItem::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    m_pData->SetSnapIn(pSnapIn);
}

void CScopeItem::SetScopeItemDef(IScopeItemDef *piScopeItemDef)
{
    RELEASE(m_piScopeItemDef);
    if (NULL != piScopeItemDef)
    {
        piScopeItemDef->AddRef();
    }
    m_piScopeItemDef = piScopeItemDef;
}

void CScopeItem::SetData(IMMCDataObject *piMMCDataObject)
{
    RELEASE(m_piData);
    if (NULL != piMMCDataObject)
    {
        piMMCDataObject->AddRef();
    }
    m_piData = piMMCDataObject;
}

HRESULT CScopeItem::GetImageIndex(int *pnImage)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;
    IMMCImages    *piMMCImages = NULL;
    IMMCImage     *piMMCImage = NULL;
    long           lIndex = 0;

    *pnImage = 0;

    IfFalseGo(NULL != m_pSnapIn, S_OK);

    IfFalseGo(VT_EMPTY != m_varFolder.vt, S_OK);

    IfFailGo(m_pSnapIn->get_SmallFolders(reinterpret_cast<MMCImageList **>(&piMMCImageList)));

    // If there is an image list then get the item and return its index

    if (NULL != piMMCImageList)
    {
        IfFailGo(piMMCImageList->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
        IfFailGo(piMMCImages->get_Item(m_varFolder, reinterpret_cast<MMCImage **>(&piMMCImage)));
        IfFailGo(piMMCImage->get_Index(&lIndex));
        *pnImage = static_cast<int>(lIndex);
    }

Error:
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


HRESULT CScopeItem::RemoveChild(IScopeNode *piScopeNode)
{
    HRESULT       hr = S_OK;
    VARIANT_BOOL  fvarOwned = VARIANT_FALSE;
    CScopeNode   *pScopeNode = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));

    IfFailGo(piScopeNode->get_Owned(&fvarOwned));

    if (VARIANT_TRUE == fvarOwned)
    {
        IfFailGo(m_pSnapIn->GetScopeItems()->Remove(
                                      pScopeNode->GetScopeItem()->GetNamePtr()));
    }
    else
    {
        // This case would occur for a child belonging to a namespace extension
        // of the snap-in

        hr = m_pSnapIn->GetIConsoleNameSpace2()->DeleteItem(
                                              pScopeNode->GetHSCOPEITEM(), TRUE);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CScopeItem::GiveHSCOPITEMToDynamicExtensions(HSCOPEITEM hsi)
{
    HRESULT      hr = S_OK;
    CExtensions *pExtensions = NULL;

    // If we have not yet populated ScopeItem.DynamicExtensions then there
    // is nothing to do.

    IfFalseGo(NULL != m_piDynamicExtensions, S_OK);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piDynamicExtensions,
                                                  &pExtensions));
    IfFailGo(pExtensions->SetHSCOPEITEM(hsi));

Error:
    RRETURN(hr);
}

HRESULT CScopeItem::SetFolder(VARIANT varFolder)
{
    HRESULT  hr = S_OK;
    int      nImage = 0;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    // Check for a good VT

    if ( (!IS_VALID_INDEX_TYPE(varFolder)) && (!ISEMPTY(varFolder)) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the new value is an empty string or a NULL string then change that to
    // VT_EMPTY as they mean the same thing.

    if (VT_BSTR == varFolder.vt)
    {
        if (NULL == varFolder.bstrVal)
        {
            varFolder.vt = VT_EMPTY;
        }
        else if (0 == ::wcslen(varFolder.bstrVal))
        {
            varFolder.vt = VT_EMPTY;
        }
    }

    // Set ScopeItem.Folder

    IfFailGo(SetVariant(varFolder, &m_varFolder, DISPID_SCOPEITEM_FOLDER));

    // If being set to Empty then nothing else to do.

    IfFalseGo(!ISEMPTY(varFolder), S_OK);

    // If ScopeItem is disconnected (user created it with Dim) or this
    // is the static node, then we're done

    IfFalseGo(NULL != m_pSnapIn, S_OK);

    // Make sure we have the HSCOPEITEM. The static node scope item is
    // created before the HSCOPEITEM is available.

    IfFalseGo(m_pScopeNode->HaveHsi(), S_OK);

    // OK, this is a real scope item. If the snap-in has scope pane image
    // lists then we need to change the image index in the console.

    // Check if the index is valid in the snap-in scope pane image lists.

    hr = GetImageIndex(&nImage);

    // If it is a bad index then return invalid arg.

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Check for other possible errors

    IfFailGo(hr);

    // Index is good. Change it in the console.
    // Adjust the open image index by the total images. See
    // CSnapIn::AddScopeItemImages() in snapin.cpp for explanation.

    sdi.nImage = nImage;
    sdi.nOpenImage = nImage + static_cast<int>(m_pSnapIn->GetImageCount());
    sdi.mask = SDI_IMAGE | SDI_OPENIMAGE;
    sdi.ID = m_pScopeNode->GetHSCOPEITEM();

    hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

Error:

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          IScopeItem Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeItem::put_Folder(VARIANT varFolder)
{
    HRESULT  hr = S_OK;

    IfFailGo(SetFolder(varFolder));

    // If this is the static node then set SnapIn.StaticFolder too

    if ( m_fIsStatic && (NULL != m_pSnapIn) )
    {
        IfFailGo(m_pSnapIn->SetStaticFolder(varFolder));
    }

Error:

    RRETURN(hr);
}


STDMETHODIMP CScopeItem::get_Folder(VARIANT *pvarFolder)
{
    RRETURN(GetVariant(pvarFolder, m_varFolder));
}


STDMETHODIMP CScopeItem::get_SubItems
(
    short Index,
    BSTR *pbstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex, reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->get_Text(pbstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}

STDMETHODIMP CScopeItem::put_SubItems
(
    short Index,
    BSTR  bstrItem
)
{
    HRESULT          hr = S_OK;
    IMMCListSubItem *piMMCListSubItem = NULL;
    VARIANT          varIndex;
    ::VariantInit(&varIndex);

    if (NULL == m_piListSubItems)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I2;
    varIndex.iVal = Index;
    IfFailGo(m_piListSubItems->get_Item(varIndex, reinterpret_cast<MMCListSubItem **>(&piMMCListSubItem)));
    IfFailGo(piMMCListSubItem->put_Text(bstrItem));

Error:
    QUICK_RELEASE(piMMCListSubItem);
    RRETURN(hr);
}



STDMETHODIMP CScopeItem::PropertyChanged(VARIANT Data)
{
    HRESULT      hr = S_OK;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    // Fire ScopeItems_PropertyChanged for this scope item with the specified
    // data.
    
    m_pSnapIn->GetScopeItems()->FirePropertyChanged(
                                                 static_cast<IScopeItem *>(this),
                                                 Data);

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeItem::RemoveChildren()
{
    HRESULT      hr = S_OK;
    IScopeNode  *piChild = NULL;
    IScopeNode  *piNextChild = NULL;
    CScopeNode  *pChild = NULL;
    CScopeItems *pScopeItems = NULL;
    CScopeItem  *pScopeItem = NULL;
    long         cScopeItems = 0;
    long         i = 0;


    // If this is a ScopeItem a user created with Dim As New then return an error

    if ( (NULL == m_pScopeNode) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_pScopeNode->HaveHsi())
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    // The call to IConsoleNameSpace2::DeleteItem will generate
    // MMCN_REMOVE_CHILDREN notifications for the children of this node but
    // not for this node itself so we need to remove its children.
    // Unfortunately, after the DeleteItem call, we can no longer navigate
    // the scope tree to find this node's children because MMC will have
    // deleted them even though we still have the ScopeItems for them. The
    // solution is to enumerate the children first and mark each one for
    // removal. After the DeleteItem call we will then traverse the collection
    // and remove each marked ScopeItem.

    IfFailGo(m_pScopeNode->get_Child(reinterpret_cast<ScopeNode **>(&piChild)));

    while (NULL != piChild)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piChild, &pChild));
        pChild->MarkForRemoval();
        IfFailGo(piChild->get_Next(reinterpret_cast<ScopeNode **>(&piNextChild)));
        RELEASE(piChild);
        piChild = piNextChild;
        piNextChild = NULL;
    }

    // Tell MMC to delete the children of this item.

    hr = m_pSnapIn->GetIConsoleNameSpace2()->DeleteItem(m_pScopeNode->GetHSCOPEITEM(),
                                                        FALSE);
    EXCEPTION_CHECK_GO(hr);

    // Remove all of the marked child  scope items
    pScopeItems = m_pSnapIn->GetScopeItems();
    cScopeItems = pScopeItems->GetCount();

    i = 0;
    while (i < cScopeItems)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                  pScopeItems->GetItemByIndex(i), &pScopeItem));
        if (pScopeItem->GetScopeNode()->MarkedForRemoval())
        {
            // This function will also remove all of the corresponding
            // ScopePaneItems in all of the existing Views.
            
            IfFailGo(pScopeItems->RemoveByNode(pScopeItem->GetScopeNode(), FALSE));

            // Update the count of ScopeItems because it just changed when we
            // removed this ScopeItem.
            cScopeItems = pScopeItems->GetCount();
        }
        else
        {
            // We only increment the index when we don't remove a ScopeItem.
            // When a ScopeItem is removed, the indexes of all ScopeItems
            // after it are decremented.
            i++;
        }
    }

Error:
    QUICK_RELEASE(piChild);
    QUICK_RELEASE(piNextChild);
    RRETURN(hr);
}





STDMETHODIMP CScopeItem::get_DynamicExtensions(Extensions **ppExtensions)
{
    HRESULT       hr = S_OK;
    IUnknown     *punkExtensions = NULL;
    CExtensions  *pExtensions = NULL;
    IExtension   *piExtension = NULL;
    VARIANT_BOOL  fvarExtensible = VARIANT_TRUE;

    // If the node is not extensible then return an error.

    if (m_fIsStatic)
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_Extensible(&fvarExtensible));
    }
    else if (NULL != m_piScopeItemDef)
    {
        IfFailGo(m_piScopeItemDef->get_Extensible(&fvarExtensible));
    }

    if (VARIANT_FALSE == fvarExtensible)
    {
        hr = SID_E_NOT_EXTENSIBLE;
        EXCEPTION_CHECK_GO(hr);
    }

    // If we already built the collection then just return it.

    IfFalseGo(NULL == m_piDynamicExtensions, S_OK);

    // This is the first GET on this property so we need to build the collection
    // by examining the registry for all extensions of this snap-in.

    punkExtensions = CExtensions::Create(NULL);
    if (NULL == punkExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkExtensions, &pExtensions));

    IfFailGo(pExtensions->Populate(m_pScopeNode->GetNodeTypeGUID(),
                                   CExtensions::Dynamic));


    // Give the extension's a back pointer to the snap-in and our HSCOPEITEM
    // if we have it. For all ScopeItems except the static node we should
    // have the HSCOPEITEM by the time a snap-in can call this method (i.e.
    // access ScopeItem.DynamicExtensions). For the static node, the snap-in
    // will receive ScopeItems_Initialize before MMC has given us its HSCOPEITEM.
    
    IfFailGo(pExtensions->SetSnapIn(m_pSnapIn));

    if (m_pScopeNode->HaveHsi())
    {
        IfFailGo(pExtensions->SetHSCOPEITEM(m_pScopeNode->GetHSCOPEITEM()));
    }

    IfFailGo(punkExtensions->QueryInterface(IID_IExtensions,
                             reinterpret_cast<void **>(&m_piDynamicExtensions)));

Error:

    if (SUCCEEDED(hr))
    {
        m_piDynamicExtensions->AddRef();
        *ppExtensions = reinterpret_cast<Extensions *>(m_piDynamicExtensions);
    }

    QUICK_RELEASE(punkExtensions);
    RRETURN(hr);
}




STDMETHODIMP CScopeItem::put_Bold(VARIANT_BOOL fvarBold)
{
    HRESULT hr = S_OK;
    UINT    nCurrentState = 0;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    if ( (NULL == m_pScopeNode) || (NULL == m_pSnapIn) )
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    m_Bold = fvarBold;

    IfFalseGo(m_pScopeNode->HaveHsi(), S_OK);

    sdi.mask = SDI_STATE;
    sdi.ID = m_pScopeNode->GetHSCOPEITEM();
    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

    nCurrentState = sdi.nState;
    
    if (VARIANT_TRUE == fvarBold)
    {
        sdi.nState &= ~MMC_SCOPE_ITEM_STATE_NORMAL;
        sdi.nState |= MMC_SCOPE_ITEM_STATE_BOLD;
    }
    else
    {
        sdi.nState |= MMC_SCOPE_ITEM_STATE_NORMAL;
        sdi.nState &= ~MMC_SCOPE_ITEM_STATE_BOLD;
    }

    if (nCurrentState != sdi.nState)
    {
        hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItem::Persist()
{
    HRESULT hr = S_OK;
    BSTR    bstrImagesKey = NULL;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistVariant(&m_varFolder, varDefault, OLESTR("Folder")));

    // NOTE: we don't persist data because there is no way to guarantee that
    // all objects in there are persistable

    IfFailGo(PersistBstr(&m_bstrDefaultDataFormat, L"", OLESTR("DefaultDataFormat")));

    IfFailGo(PersistObject(&m_piDynamicExtensions, CLSID_Extensions, OBJECT_TYPE_EXTENSIONS, IID_IExtensions, OLESTR("DynamicExtensions")));

    IfFailGo(PersistSimpleType(&m_SlowRetrieval, VARIANT_FALSE, OLESTR("SlowRetrieval")));

    // We don't persist the tag because it may contain a non-persistable
    // object. Any runtime code that needs to clone a scopeitem using
    // persistence must copy the tag.

    if (InitNewing())
    {
        IfFailGo(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));
    }

    IfFailGo(PersistObject(&m_piScopeNode, CLSID_ScopeNode,
                           OBJECT_TYPE_SCOPENODE, IID_IScopeNode,
                           OLESTR("ScopeNode")));

    IfFailGo(PersistSimpleType(&m_Pasted, VARIANT_FALSE, OLESTR("Pasted")));

    IfFailGo(PersistObject(&m_piColumnHeaders, CLSID_MMCColumnHeaders,
                           OBJECT_TYPE_MMCCOLUMNHEADERS, IID_IMMCColumnHeaders,
                           OLESTR("ColumnHeaders")));

    IfFailGo(PersistObject(&m_piListSubItems, CLSID_MMCListSubItems,
                           OBJECT_TYPE_MMCLISTSUBITEMS, IID_IMMCListSubItems,
                           OLESTR("ListSubItems")));

    IfFailGo(PersistSimpleType(&m_Bold, VARIANT_FALSE, OLESTR("Bold")));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IScopeItem == riid)
    {
        *ppvObjOut = static_cast<IScopeItem *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scitdefs.cpp ===
//=--------------------------------------------------------------------------=
// scitdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItemDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "scitdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItemDefs::CScopeItemDefs(IUnknown *punkOuter) :
    CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>(
                      punkOuter,
                      OBJECT_TYPE_SCOPEITEMDEFS,
                      static_cast<IScopeItemDefs *>(this),
                      static_cast<CScopeItemDefs *>(this),
                      CLSID_ScopeItemDef,
                      OBJECT_TYPE_SCOPEITEMDEF,
                      IID_IScopeItemDef,
                      static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ScopeItemDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeItemDefs::~CScopeItemDefs()
{
}

IUnknown *CScopeItemDefs::Create(IUnknown * punkOuter)
{
    CScopeItemDefs *pScopeItemDefs = New CScopeItemDefs(punkOuter);
    if (NULL == pScopeItemDefs)
    {
        return NULL;
    }
    else
    {
        return pScopeItemDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDefs::Persist()
{
    HRESULT         hr = S_OK;
    IScopeItemDef  *piScopeItemDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>::Persist(piScopeItemDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItemDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IScopeItemDefs == riid)
    {
        *ppvObjOut = static_cast<IScopeItemDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IScopeItemDef, ScopeItemDef, IScopeItemDefs>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitms.cpp ===
//=--------------------------------------------------------------------------=
// scopitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "scopitms.h"
#include "scopnode.h"
#include "scitdefs.h"
#include "scitdef.h"

// for ASSERT and FAIL
//
SZTHISFILE;

VARTYPE CScopeItems::m_rgvtInitialize[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiInitialize =
{
    DISPID_SCOPEITEMS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};

VARTYPE CScopeItems::m_rgvtTerminate[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiTerminate =
{
    DISPID_SCOPEITEMS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};



VARTYPE CScopeItems::m_rgvtExpand[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiExpand =
{
    DISPID_SCOPEITEMS_EVENT_EXPAND,
    sizeof(m_rgvtExpand) / sizeof(m_rgvtExpand[0]),
    m_rgvtExpand
};


VARTYPE CScopeItems::m_rgvtCollapse[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiCollapse =
{
    DISPID_SCOPEITEMS_EVENT_COLLAPSE,
    sizeof(m_rgvtCollapse) / sizeof(m_rgvtCollapse[0]),
    m_rgvtCollapse
};



VARTYPE CScopeItems::m_rgvtExpandSync[2] = { VT_UNKNOWN, VT_BYREF | VT_BOOL };

EVENTINFO CScopeItems::m_eiExpandSync =
{
    DISPID_SCOPEITEMS_EVENT_EXPAND_SYNC,
    sizeof(m_rgvtExpandSync) / sizeof(m_rgvtExpandSync[0]),
    m_rgvtExpandSync
};


VARTYPE CScopeItems::m_rgvtCollapseSync[2] = { VT_UNKNOWN, VT_BYREF | VT_BOOL };

EVENTINFO CScopeItems::m_eiCollapseSync =
{
    DISPID_SCOPEITEMS_EVENT_COLLAPSE_SYNC,
    sizeof(m_rgvtCollapseSync) / sizeof(m_rgvtCollapseSync[0]),
    m_rgvtCollapseSync
};



VARTYPE CScopeItems::m_rgvtGetDisplayInfo[1] = { VT_UNKNOWN };

EVENTINFO CScopeItems::m_eiGetDisplayInfo =
{
    DISPID_SCOPEITEMS_EVENT_GET_DISPLAY_INFO,
    sizeof(m_rgvtGetDisplayInfo) / sizeof(m_rgvtGetDisplayInfo[0]),
    m_rgvtGetDisplayInfo
};


VARTYPE CScopeItems::m_rgvtPropertyChanged[2] =
{
    VT_UNKNOWN,
    VT_VARIANT
};

EVENTINFO CScopeItems::m_eiPropertyChanged =
{
    DISPID_SCOPEITEMS_EVENT_PROPERTY_CHANGED,
    sizeof(m_rgvtPropertyChanged) / sizeof(m_rgvtPropertyChanged[0]),
    m_rgvtPropertyChanged
};


VARTYPE CScopeItems::m_rgvtRename[2] =
{
    VT_UNKNOWN,
    VT_BSTR
};

EVENTINFO CScopeItems::m_eiRename =
{
    DISPID_SCOPEITEMS_EVENT_RENAME,
    sizeof(m_rgvtRename) / sizeof(m_rgvtRename[0]),
    m_rgvtRename
};


VARTYPE CScopeItems::m_rgvtHelp[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopeItems::m_eiHelp =
{
    DISPID_SCOPEITEMS_EVENT_HELP,
    sizeof(m_rgvtHelp) / sizeof(m_rgvtHelp[0]),
    m_rgvtHelp
};


VARTYPE CScopeItems::m_rgvtRemoveChildren[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopeItems::m_eiRemoveChildren =
{
    DISPID_SCOPEITEMS_EVENT_REMOVE_CHILDREN,
    sizeof(m_rgvtRemoveChildren) / sizeof(m_rgvtRemoveChildren[0]),
    m_rgvtRemoveChildren
};



#pragma warning(disable:4355)  // using 'this' in constructor

CScopeItems::CScopeItems(IUnknown *punkOuter) :
   CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>(
                                              punkOuter,
                                              OBJECT_TYPE_SCOPEITEMS,
                                              static_cast<IScopeItems *>(this),
                                              static_cast<CScopeItems *>(this),
                                              CLSID_ScopeItem,
                                              OBJECT_TYPE_SCOPEITEM,
                                              IID_IScopeItem,
                                              NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CScopeItems::InitMemberVariables()
{
    m_pSnapIn = NULL;
}

CScopeItems::~CScopeItems()
{
    InitMemberVariables();
}

IUnknown *CScopeItems::Create(IUnknown * punkOuter)
{
    CScopeItems *pScopeItems = New CScopeItems(punkOuter);
    if (NULL == pScopeItems)
    {
        return NULL;
    }
    else
    {
        return pScopeItems->PrivateUnknown();
    }
}


HRESULT CScopeItems::CreateScopeItem
(
    BSTR         bstrName,
    IScopeItem **ppiScopeItem
)
{
    HRESULT     hr = S_OK;
    IScopeItem *piScopeItem = NULL;
    IUnknown   *punkScopeItem = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    punkScopeItem = CScopeItem::Create(NULL);
    if (NULL == punkScopeItem)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopeItem->QueryInterface(IID_IScopeItem,
                                           reinterpret_cast<void **>(&piScopeItem)));

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrName;
    hr = CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::AddExisting(
                                                                   varIndex,
                                                                   varKey,
                                                                   piScopeItem);
    IfFailGo(hr);
    IfFailGo(piScopeItem->put_Name(bstrName));

Error:
    if (SUCCEEDED(hr))
    {
        *ppiScopeItem = piScopeItem;
    }
    else
    {
        QUICK_RELEASE(piScopeItem);
        *ppiScopeItem = NULL;
    }

    QUICK_RELEASE(punkScopeItem);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveScopeItemByName(BSTR bstrName)
{
    HRESULT hr = S_OK;

    VARIANT varKey;
    ::VariantInit(&varKey);

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrName;
    hr = RemoveScopeItemByKey(varKey);

    RRETURN(hr);
}

HRESULT CScopeItems::RemoveScopeItemByKey(VARIANT varKey)
{
    HRESULT          hr = S_OK;
    CViews          *pViews = m_pSnapIn->GetViews();
    CView           *pView = NULL;
    long             cViews = 0;
    long             i = 0;
    CScopePaneItems *pScopePaneItems = NULL;
    CScopePaneItem  *pScopePaneItem = NULL;
    IScopePaneItem  *piScopePaneItem = NULL;
    IScopeItem      *piScopeItem = NULL;
    CScopeItem      *pScopeItem = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Get the ScopeItem to make sure it exists

    IfFailGo(get_Item(varKey, &piScopeItem));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));

    cViews = pViews->GetCount();

    // Remove the ScopeItem from all Views' ScopePaneItem collections

    for (i = 0; i < cViews; i++)
    {
        // Get the next View
        
        IfFailGo(CSnapInAutomationObject::GetCxxObject(pViews->GetItemByIndex(i),
                                                       &pView));
        pScopePaneItems = pView->GetScopePaneItems();

        // Check if View.ScopePaneItems has a member for this ScopeItem
        
        hr = pScopePaneItems->GetItemByName(pScopeItem->GetNamePtr(),
                                            &piScopePaneItem);
        if (SUCCEEDED(hr))
        {
            // There is a member. Remove it from View.ScopePaneItems
            
            IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem,
                                                           &pScopePaneItem));
            varIndex.vt = VT_I4;;
            varIndex.lVal = pScopePaneItem->GetIndex();
            IfFailGo(pScopePaneItems->Remove(varIndex));
            RELEASE(piScopePaneItem);
        }
        else
        {
            if (SID_E_ELEMENT_NOT_FOUND == hr)
            {
                hr = S_OK;
            }
            IfFailGo(hr);
        }
    }

    // Remove it from the ScopeItem collection

    hr = CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::Remove(varKey);
    IfFailGo(hr);

Error:
    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}



HRESULT CScopeItems::AddStaticNode(CScopeItem **ppScopeItem)
{
    HRESULT        hr = S_OK;
    IScopeItem    *piScopeItem = NULL;
    CScopeItem    *pScopeItem = NULL;
    IScopeNode    *piScopeNode = NULL;
    CScopeNode    *pScopeNode = NULL;
    BSTR           bstrProp = NULL;

    VARIANT        varProp;
    ::VariantInit(&varProp);

    BSTR bstrName = ::SysAllocString(STATIC_NODE_KEY);

    // Create the scope item

    if (NULL == bstrName)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CreateScopeItem(bstrName, &piScopeItem));

    // Set its properties from the snap-in definiton

    IfFailGo(m_pSnapIn->get_StaticFolder(&varProp));
    if (VT_EMPTY != varProp.vt)
    {
        IfFailGo(piScopeItem->put_Folder(varProp));
    }
    (void)::VariantClear(&varProp);

    // Set ScopeNode properties too

    IfFailGo(piScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));

    IfFailGo(m_pSnapIn->get_NodeTypeName(&bstrProp));
    IfFailGo(piScopeNode->put_NodeTypeName(bstrProp));
    FREESTRING(bstrProp);

    IfFailGo(m_pSnapIn->get_NodeTypeGUID(&bstrProp));
    IfFailGo(piScopeNode->put_NodeTypeGUID(bstrProp));
    IfFailGo(piScopeItem->put_NodeID(bstrProp));
    FREESTRING(bstrProp);

    IfFailGo(m_pSnapIn->get_DisplayName(&bstrProp));
    IfFailGo(piScopeNode->put_DisplayName(bstrProp));
    FREESTRING(bstrProp);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
    pScopeItem->SetStaticNode();
    pScopeItem->SetSnapIn(m_pSnapIn);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));
    pScopeNode->SetSnapIn(m_pSnapIn);

    *ppScopeItem = pScopeItem;

    // Tell the snap-in that a scope item was born.

    FireInitialize(piScopeItem);

Error:

    // Note: the returned C++ pointer is not AddRef()ed. At this point
    // the collection has the only ref on the scope item.

    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(bstrName);
    }

    QUICK_RELEASE(piScopeItem);
    QUICK_RELEASE(piScopeNode);
    FREESTRING(bstrName);
    FREESTRING(bstrProp);
    (void)::VariantClear(&varProp);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveStaticNode(CScopeItem *pScopeItem)
{
    HRESULT     hr = S_OK;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Fire ScopeItems_Terminate

    FireTerminate(pScopeItem);

    // Tell the scope item to remove its ref on its IMMCDataObject to avoid
    // a circular ref count because its data object also has a ref on it
    pScopeItem->SetData(NULL);

    // Remove it from the collection

    varIndex.vt = VT_I4;
    varIndex.lVal = pScopeItem->GetIndex();

    IfFailGo(RemoveScopeItemByKey(varIndex));

Error:
    RRETURN(hr);
}


void CScopeItems::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}


void CScopeItems::FireInitialize(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Initialize(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiInitialize, piScopeItem);
}


void CScopeItems::FireTerminate(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Terminate(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiTerminate, piScopeItem);
}


void CScopeItems::FireExpand(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Expand(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiExpand, piScopeItem);
}


void CScopeItems::FireCollapse(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_Collapse(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiCollapse, piScopeItem);
}


void CScopeItems::FireExpandSync(IScopeItem *piScopeItem, BOOL *pfHandled)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);
    
    DebugPrintf("Firing ScopeItems_ExpandSync(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiExpandSync, piScopeItem, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


void CScopeItems::FireCollapseSync(IScopeItem *piScopeItem, BOOL *pfHandled)
{
    VARIANT_BOOL fvarHandled = BOOL_TO_VARIANTBOOL(*pfHandled);

    DebugPrintf("Firing ScopeItems_CollapseSync(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiCollapseSync, piScopeItem, &fvarHandled);

    *pfHandled = VARIANTBOOL_TO_BOOL(fvarHandled);
}


void CScopeItems::FireGetDisplayInfo(IScopeItem *piScopeItem)
{
    DebugPrintf("Firing ScopeItems_GetDisplayInfo(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiGetDisplayInfo, piScopeItem);
}


void CScopeItems::FirePropertyChanged
(
    IScopeItem *piScopeItem,
    VARIANT     Data
)
{
    DebugPrintf("Firing ScopeItems_PropertyChanged(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiPropertyChanged, piScopeItem, Data);
}


void CScopeItems::FireRename
(
    IScopeItem *piScopeItem,
    BSTR        bstrNewName
)
{
    DebugPrintf("Firing ScopeItems_Rename(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiRename, piScopeItem, bstrNewName);
}


void CScopeItems::FireHelp
(
    IScopeItem *piScopeItem
)
{
    DebugPrintf("Firing ScopeItems_Help(%ls)\r\n", (static_cast<CScopeItem *>(piScopeItem))->GetDisplayNamePtr() );

    FireEvent(&m_eiHelp, piScopeItem);
}



void CScopeItems::FireRemoveChildren
(
    IScopeNode *piScopeNode
)
{
    DebugPrintf("Firing ScopeItems_RemoveChildren\r\n");

    FireEvent(&m_eiRemoveChildren, piScopeNode);
}



HRESULT CScopeItems::InternalAddNew
(
    BSTR                              bstrName,
    BSTR                              bstrDisplayName,
    BSTR                              bstrNodeTypeName,
    BSTR                              bstrNodeTypeGUID,
    IScopeNode                       *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    BOOL                              fHasChildren,
    IScopeItem                      **ppiScopeItem
)
{
    HRESULT     hr = S_OK;
    CScopeItem *pScopeItem = NULL;
    IScopeItem *piScopeItem = NULL;
    IScopeNode *piScopeNode = NULL;
    CScopeNode *pScopeNode = NULL;
    CScopeNode *pScopeNodeRelative = NULL;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    hr = CreateScopeItem(bstrName, &piScopeItem);
    IfFailGo(hr);

    // Set default values for properties

    IfFailGo(piScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));

    IfFailGo(piScopeNode->put_NodeTypeName(bstrNodeTypeName));
    IfFailGo(piScopeNode->put_NodeTypeGUID(bstrNodeTypeGUID));
    IfFailGo(piScopeNode->put_DisplayName(bstrDisplayName));

    // The Node ID defaults to the node type GUID
    
    IfFailGo(piScopeItem->put_NodeID(bstrNodeTypeGUID));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
    pScopeItem->SetSnapIn(m_pSnapIn);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));
    pScopeNode->SetSnapIn(m_pSnapIn);

    // Now add the scope item to the scope pane

    IfFailGo(CSnapInAutomationObject::GetCxxObject(ScopeNodeRelative, &pScopeNodeRelative));

    
    sdi.mask = SDI_STR | SDI_PARAM | SDI_CHILDREN;

    switch (RelativeRelationship)
    {
        case siParent:
            sdi.mask |= SDI_PARENT;
            break;

        case siPrevious:
            sdi.mask |= SDI_PREVIOUS;
            break;

        case siNext:
            sdi.mask |= SDI_NEXT;
            break;

        case siFirst:
            sdi.mask |= SDI_FIRST;
            break;
    }

    sdi.displayname = MMC_CALLBACK;
    sdi.lParam = reinterpret_cast<LPARAM>(pScopeItem);
    sdi.relativeID = pScopeNodeRelative->GetHSCOPEITEM();
    sdi.cChildren = fHasChildren ? 1 : 0;

    // scope pane holds a ref - it will be released when the scope item is removed
    pScopeItem->AddRef();


    // Check whether we already have IConsoleNameSpace2 from MMC. This could
    // happen if the snap-in calls ScopeItems.Add/Predefined during
    // ScopeItems_Initialize for the static node. That event is fired when
    // the snap-in first gets IComponentData::QueryDataObject() for the zero
    // cookie which is before IComponentData::Initialize. (See
    // CSnapIn::QueryDataObject() in snapin.cpp).
    
    if (NULL == m_pSnapIn->GetIConsoleNameSpace2())
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pSnapIn->GetIConsoleNameSpace2()->InsertItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

    // Store the HSCOPEITEM returned from MMC

    pScopeNode->SetHSCOPEITEM(sdi.ID);

    *ppiScopeItem = piScopeItem;

Error:
    QUICK_RELEASE(piScopeNode);
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(bstrName);
        piScopeItem->Release();
    }
    RRETURN(hr);
}


HRESULT CScopeItems::InternalAddPredefined
(
    BSTR                              bstrName,
    IScopeItemDef                    *piScopeItemDef,
    IScopeNode                       *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    VARIANT                           HasChildren,
    IScopeItem                      **ppiScopeItem
)
{
    HRESULT            hr = S_OK;
    IScopeItem        *piScopeItem = NULL;
    CScopeItem        *pScopeItem = NULL;
    BSTR               bstrNodeTypeName = NULL;
    BSTR               bstrDisplayName = NULL;
    BSTR               bstrNodeTypeGUID = NULL;
    BSTR               bstrDefaultDataFormat = NULL;
    VARIANT_BOOL       fvarHasChildren = VARIANT_FALSE;
    IMMCColumnHeaders *piDefColHdrs = NULL;
    IMMCColumnHeaders *piItemColHdrs = NULL;

    VARIANT         varProp;
    ::VariantInit(&varProp);

    // Get relevant properties and add the scope item.
    // If name is unspecified then use node type name as name

    IfFailGo(piScopeItemDef->get_NodeTypeName(&bstrNodeTypeName));
    if (NULL == bstrName)
    {
        bstrName = bstrNodeTypeName;
    }
    IfFailGo(piScopeItemDef->get_NodeTypeGUID(&bstrNodeTypeGUID));
    IfFailGo(piScopeItemDef->get_DisplayName(&bstrDisplayName));

    // If the caller passed the option HasChildren parameter then use it
    // otherwise use the design time setting.

    if (ISPRESENT(HasChildren))
    {
        if (VT_BOOL == HasChildren.vt)
        {
            fvarHasChildren = HasChildren.boolVal;
        }
        else
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    else
    {
        IfFailGo(piScopeItemDef->get_HasChildren(&fvarHasChildren));
    }

    IfFailGo(InternalAddNew(bstrName,
                            bstrDisplayName,
                            bstrNodeTypeName,
                            bstrNodeTypeGUID,
                            ScopeNodeRelative,
                            RelativeRelationship,
                            VARIANTBOOL_TO_BOOL(fvarHasChildren),
                            &piScopeItem));

    // Set remaining properties from definition

    IfFailGo(piScopeItemDef->get_Folder(&varProp));
    IfFailGo(piScopeItem->put_Folder(varProp));
    (void)::VariantClear(&varProp);

    IfFailGo(piScopeItemDef->get_Tag(&varProp));
    IfFailGo(piScopeItem->put_Tag(varProp));
    (void)::VariantClear(&varProp);

#if defined(USING_SNAPINDATA)

    IfFailGo(piScopeItemDef->get_DefaultDataFormat(&bstrDefaultDataFormat));
    IfFailGo(piScopeItem->put_DefaultDataFormat(bstrDefaultDataFormat));

#endif

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
    pScopeItem->SetScopeItemDef(piScopeItemDef);

    // For column headers the easiest way is to use serialization. We save
    // the headers from the definition into a stream and then load the new
    // scope item's headers from that stream

    IfFailGo(piScopeItemDef->get_ColumnHeaders(&piDefColHdrs));
    IfFailGo(piScopeItem->get_ColumnHeaders(reinterpret_cast<MMCColumnHeaders **>(&piItemColHdrs)));
    IfFailGo(::CloneObject(piDefColHdrs, piItemColHdrs));

    FireInitialize(piScopeItem);

    *ppiScopeItem = piScopeItem;

Error:
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(bstrName);
        piScopeItem->Release();
    }
    QUICK_RELEASE(piDefColHdrs);
    QUICK_RELEASE(piItemColHdrs);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrDisplayName);
    FREESTRING(bstrNodeTypeGUID);
    FREESTRING(bstrDefaultDataFormat);
    (void)::VariantClear(&varProp);
    RRETURN(hr);
}


HRESULT CScopeItems::AddAutoCreateChildren
(
    IScopeItemDefs *piScopeItemDefs,
    IScopeItem     *piParentScopeItem
)
{
    HRESULT         hr = S_OK;
    IScopeItemDef  *piChildScopeItemDef = NULL;
    IScopeNode     *piParentScopeNode = NULL;
    IScopeItem     *piChildScopeItem = NULL;
    IScopeItem     *piExistingChild = NULL;
    long            cChildren = 0;
    VARIANT_BOOL    fvarAutoCreate = VARIANT_FALSE;
    BSTR            bstrName = NULL;
    BSTR            bstrNodeTypeName = NULL;
    BSTR            bstrParentName = NULL;
    size_t          cchNodeTypeName = 0;;
    size_t          cchParentName = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varHasChildren;
    UNSPECIFIED_PARAM(varHasChildren);

    IfFailGo(piScopeItemDefs->get_Count(&cChildren));
    IfFalseGo(cChildren != 0, S_OK);
    IfFailGo(piParentScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piParentScopeNode)));

    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;

    while (varIndex.lVal <= cChildren)
    {
        IfFailGo(piScopeItemDefs->get_Item(varIndex, &piChildScopeItemDef));
        IfFailGo(piChildScopeItemDef->get_AutoCreate(&fvarAutoCreate));

        if (VARIANT_TRUE == fvarAutoCreate)
        {
            // NTBUGS 350731
            // Check if there already is a node using the node type name. If
            // so then the snap-in has called ScopeItems.AddPredefined more
            // than once for the same node type. In that case we prefix the
            // node type name with the parent's ScopeItem.Name

            IfFailGo(piChildScopeItemDef->get_NodeTypeName(&bstrNodeTypeName));

            varKey.vt = VT_BSTR;
            varKey.bstrVal = bstrNodeTypeName;
            hr = get_Item(varKey, &piExistingChild);

            if (FAILED(hr))
            {
                if (SID_E_ELEMENT_NOT_FOUND == hr)
                {
                    // This is the first call for this node type. Use the
                    // node type name for ScopeItem.Name

                    hr = S_OK;
                    bstrName = bstrNodeTypeName;
                    bstrNodeTypeName = NULL; // Set NULL so we don't free it
                }
                IfFailGo(hr);
            }
            else
            {
                // Child does exist. Create the child's name by concatenating
                // <Parent Name>.<Child Node Type Name>

                IfFailGo(piParentScopeItem->get_Name(&bstrParentName));

                cchNodeTypeName = ::wcslen(bstrNodeTypeName);
                cchParentName = ::wcslen(bstrParentName);

                bstrName = ::SysAllocStringLen(NULL,
                                               cchNodeTypeName +
                                               1 + // for .
                                               cchParentName +
                                               1); // for terminating null char
                if (NULL == bstrName)
                {
                    hr = SID_E_OUTOFMEMORY;
                    EXCEPTION_CHECK_GO(hr);
                }

                ::memcpy(bstrName, bstrParentName,
                         cchParentName * sizeof(WCHAR));
                
                bstrName[cchParentName] = L'.';

                ::memcpy(&bstrName[cchParentName + 1],
                         bstrNodeTypeName, (cchNodeTypeName + 1) * sizeof(WCHAR));
            }
            
            IfFailGo(InternalAddPredefined(bstrName,
                                           piChildScopeItemDef,
                                           piParentScopeNode,
                                           siParent,
                                           varHasChildren,
                                           &piChildScopeItem));
            RELEASE(piChildScopeItem);
        }

        FREESTRING(bstrName);
        FREESTRING(bstrNodeTypeName);
        RELEASE(piExistingChild);
        RELEASE(piChildScopeItemDef);
        varIndex.lVal++;
    }

Error:
    QUICK_RELEASE(piChildScopeItemDef);
    QUICK_RELEASE(piParentScopeNode);
    QUICK_RELEASE(piChildScopeItem);
    QUICK_RELEASE(piExistingChild);
    FREESTRING(bstrNodeTypeName);
    FREESTRING(bstrParentName);
    FREESTRING(bstrName);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveChildrenOfNode(IScopeNode *piScopeNode)
{
    HRESULT     hr = S_OK;
    IScopeNode *piChild1 = NULL;
    IScopeNode *piChild2 = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Get each child of the specified node and remove it. RemoveByNode() will
    // recursively call back in here to remove the child's children.

    IfFailGo(piScopeNode->get_Child(reinterpret_cast<ScopeNode **>(&piChild1)));

    while (NULL != piChild1)
    {
        IfFailGo(piChild1->get_Next(reinterpret_cast<ScopeNode **>(&piChild2)));
        IfFailGo(RemoveByNode(piChild1, TRUE));
        RELEASE(piChild1);
        if (NULL != piChild2)
        {
            IfFailGo(piChild2->get_Next(reinterpret_cast<ScopeNode **>(&piChild1)));
            IfFailGo(RemoveByNode(piChild2, TRUE));
            RELEASE(piChild2);
        }
    }

Error:
    QUICK_RELEASE(piChild1);
    QUICK_RELEASE(piChild2);
    RRETURN(hr);
}


HRESULT CScopeItems::RemoveByNode(IScopeNode *piScopeNode, BOOL fRemoveChildren)
{
    HRESULT       hr = S_OK;
    VARIANT_BOOL  fvarOwned = VARIANT_FALSE;
    CScopeNode   *pScopeNode = NULL;
    CScopeItem   *pScopeItem = NULL;
    IScopeNode   *piChild1 = NULL;
    IScopeNode   *piChild2 = NULL;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // If the node is not ours then don't do anything

    IfFailGo(piScopeNode->get_Owned(&fvarOwned));

    IfFalseGo(VARIANT_TRUE == fvarOwned, S_OK);

    // Remove the node's children if requested

    if (fRemoveChildren)
    {
        IfFailGo(RemoveChildrenOfNode(piScopeNode));
    }
    
    // Fire ScopeItems_Terminate

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));
    pScopeItem = pScopeNode->GetScopeItem();

    FireTerminate(pScopeItem);

    // Remove it from the collection. This will remove the collection's ref on
    // the scope item.

    varIndex.vt = VT_I4;
    varIndex.lVal = pScopeItem->GetIndex();
    IfFailGo(RemoveScopeItemByKey(varIndex));

    // Tell the scope item to remove its ref on its IMMCDataObject to avoid
    // a circular ref count because its data object also has a ref on it

    pScopeItem->SetData(NULL);

    // Remove the ref we held for presence in MMC. The scope item should die
    // with this release but its ScopeNode is still alive because the caller
    // of this function has a ref on it.

    pScopeItem->Release(); 

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          IScopeItems Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeItems::get_Item(VARIANT Index, IScopeItem **ppiScopeItem)
{
    HRESULT     hr = S_OK;
    IScopeNode *piScopeNode = NULL;
    CScopeNode *pScopeNode = NULL;
    CScopeItem *pScopeItem = NULL;

    if (NULL == ppiScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If index is not an object then let CSnapInCollection handle it

    if ( (VT_UNKNOWN != Index.vt) && (VT_DISPATCH != Index.vt) )
    {
        hr = CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::get_Item(
                                                                  Index,
                                                                  ppiScopeItem);
        goto Error;
    }

    // If it is an object then it must support IScopeNode

    if ( (VT_UNKNOWN == Index.vt) && (NULL != Index.punkVal) )
    {
        hr = Index.punkVal->QueryInterface(IID_IScopeNode,
                                       reinterpret_cast<void **>(&piScopeNode));
    }
    else if ( (VT_DISPATCH == Index.vt) && (NULL != Index.pdispVal) )
    {
        hr = Index.pdispVal->QueryInterface(IID_IScopeNode,
                                       reinterpret_cast<void **>(&piScopeNode));
    }
    else
    {
        hr = SID_E_INVALIDARG;
    }

    // Translate E_NOINTERFACE to E_INVALIDARG because is it means they passed
    // us some other object

    if (FAILED(hr))
    {
        if (E_NOINTERFACE == hr)
        {
            hr = SID_E_INVALIDARG;
        }
        if (SID_E_INVALIDARG == hr)
        {
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // We have a valid IScopeNode. Now Get the CScopeNode and check if it has
    // a valid CScopeItem pointer.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));

    pScopeItem = pScopeNode->GetScopeItem();

    // If the ScopeItem pointer comes back NULL then this is disconnected
    // ScopeNode object that doesn't belong to a ScopeItem. The user could
    // create one of these by using Dim Node As New ScopeNode.

    if (NULL == pScopeItem)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // We're in business. AddRef the scope item and return it.

    pScopeItem->AddRef();
    *ppiScopeItem = static_cast<IScopeItem *>(pScopeItem);

Error:
    QUICK_RELEASE(piScopeNode);
    RRETURN(hr);
}


STDMETHODIMP CScopeItems::Add
(
    BSTR                              Name,
    ScopeNode                        *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    VARIANT                           HasChildren,
    ScopeItem                       **ppScopeItem
)
{
    HRESULT     hr = S_OK;
    GUID        NodeTypeGUID = GUID_NULL;
    BSTR        bstrNodeTypeGUID = NULL;
    BOOL        fHasChildren = TRUE;
    IScopeItem *piScopeItem = NULL;

    WCHAR wszNodeTypeGUID[64];
    ::ZeroMemory(wszNodeTypeGUID, sizeof(wszNodeTypeGUID));

    if ( (!ValidBstr(Name)) || (NULL == ScopeNodeRelative) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::CoCreateGuid(&NodeTypeGUID));
    if (0 == ::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                               sizeof(wszNodeTypeGUID) /
                               sizeof(wszNodeTypeGUID[0])))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    bstrNodeTypeGUID = ::SysAllocString(wszNodeTypeGUID);
    if (NULL == bstrNodeTypeGUID)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    if (ISPRESENT(HasChildren))
    {
        if (VT_BOOL == HasChildren.vt)
        {
            fHasChildren = VARIANTBOOL_TO_BOOL(HasChildren.boolVal);
        }
        else
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(InternalAddNew(Name,               // Name
                            Name,               // Display name
                            Name,               // Node type name
                            bstrNodeTypeGUID,
                            reinterpret_cast<IScopeNode *>(ScopeNodeRelative),
                            RelativeRelationship,
                            fHasChildren,
                            &piScopeItem));

    FireInitialize(piScopeItem);

    *ppScopeItem = reinterpret_cast<ScopeItem *>(piScopeItem);

Error:
    FREESTRING(bstrNodeTypeGUID);
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(Name);
        piScopeItem->Release();
    }
    RRETURN(hr);
}



STDMETHODIMP CScopeItems::AddPreDefined
(
    BSTR                              NodeTypeName,
    BSTR                              Name,
    ScopeNode                        *ScopeNodeRelative,
    SnapInNodeRelationshipConstants   RelativeRelationship,
    VARIANT                           HasChildren,
    ScopeItem                       **ppScopeItem
)
{
    HRESULT         hr = S_OK;
    IScopeItemDefs *piScopeItemDefs = NULL;
    CScopeItemDefs *pScopeItemDefs = NULL;
    IScopeItemDef  *piScopeItemDef = NULL;
    IScopeItem     *piScopeItem = NULL;
    BOOL            fHasChildren = FALSE;

    if ( (!ValidBstr(NodeTypeName)) || (!ValidBstr(Name)) ||
         (NULL == ScopeNodeRelative) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the scope item definiton. Check AutoCreate nodes first.

    IfFailGo(m_pSnapIn->GetSnapInDesignerDef()->get_AutoCreateNodes(&piScopeItemDefs));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDefs, &pScopeItemDefs));
    hr = pScopeItemDefs->GetItemByName(NodeTypeName, &piScopeItemDef);

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        // Not in AutoCreate, try other nodes
        RELEASE(piScopeItemDefs);
        IfFailGo(m_pSnapIn->GetSnapInDesignerDef()->get_OtherNodes(&piScopeItemDefs));
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDefs, &pScopeItemDefs));
        hr = pScopeItemDefs->GetItemByName(NodeTypeName, &piScopeItemDef);
    }

    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        // User passed a bad node type name
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        IfFailGo(hr);
    }
    RELEASE(piScopeItemDefs);

    IfFailGo(InternalAddPredefined(
                              Name,
                              piScopeItemDef,
                              reinterpret_cast<IScopeNode *>(ScopeNodeRelative),
                              RelativeRelationship,
                              HasChildren,
                              &piScopeItem));

    *ppScopeItem = reinterpret_cast<ScopeItem *>(piScopeItem);

Error:
    if ( FAILED(hr) && (NULL != piScopeItem) )
    {
        (void)RemoveScopeItemByName(Name);
        piScopeItem->Release();
    }
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piScopeItemDef);
    RRETURN(hr);
}



STDMETHODIMP CScopeItems::Remove(BSTR Name)
{
    HRESULT     hr = S_OK;
    IScopeItem *piScopeItem = NULL;
    CScopeItem *pScopeItem = NULL;
    HSCOPEITEM  hsi = NULL;
    
    VARIANT varIndex;
    ::VariantInit(&varIndex);

    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = Name;
   
    if (ReadOnly())
    {
        hr = SID_E_COLLECTION_READONLY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the scope item. This checks its existence and leaves a ref on it
    // so we can fire ScopeItems_Terminate.

    IfFailGo(get_Item(varIndex, &piScopeItem));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));

    // If this is the static node then don't allow the removal as MMC controls
    // its lifetime

    if (pScopeItem->IsStaticNode())
    {
        hr = SID_E_CANT_REMOVE_STATIC_NODE;
        EXCEPTION_CHECK_GO(hr);
    }

    // Remove it from MMC. Pass TRUE to indicate that this item should be
    // deleted along with all of its children.

    // NTBUGS 356327: We need to do this before removing the ScopeItem from the
    // collection because during the IConsoleNameSpace2::DeleteItem() call, MMC
    // could call IComponent::GetResultViewType(). If we delete the ScopeItem,
    // first, and it had a corresponding ScopePaneItem, then
    // CView::GetResultViewType()would create a new ScopePaneItem and attach
    // it to the ScopeItem that is about to be deleted. If the snap-in later
    // adds another ScopeItem using the same key, (e.g. FileExplorer refreshes
    // its drives under "My Computer" after running its config wizard), then
    // when the user selects that ScopeItem, CView will use the existing
    // ScopePaneItem which points to the old deleted ScopeItem.

    hsi = pScopeItem->GetScopeNode()->GetHSCOPEITEM();
    hr = m_pSnapIn->GetIConsoleNameSpace2()->DeleteItem(hsi, TRUE);
    EXCEPTION_CHECK_GO(hr);

    // Remove it from the collection. This will also remove any corresponding
    // ScopePaneItems in all views.

    IfFailGo(RemoveScopeItemByKey(varIndex));

    // Fire ScopeItems_Terminate

    FireTerminate(piScopeItem);

    // Tell the scope item to remove its ref on its IMMCDataObject to avoid
    // a circular ref count because its data object also has a ref on it
    pScopeItem->SetData(NULL);

    // Remove the ref we held for presence in MMC
    piScopeItem->Release(); 

Error:
    QUICK_RELEASE(piScopeItem); // if successful, ScopeItem should die here
    RRETURN(hr);
}


STDMETHODIMP CScopeItems::Clear()
{
    // Disallow this operation because it would remove the static node. MMC
    // controls the static node's lifetime.
    
    HRESULT hr = SID_E_CANT_REMOVE_STATIC_NODE;
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IScopeItems == riid)
    {
        *ppvObjOut = static_cast<IScopeItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitms.h ===
//=--------------------------------------------------------------------------=
// scopitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItems class definition - implements ScopeItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEITEMS_DEFINED_
#define _SCOPEITEMS_DEFINED_

#include "collect.h"
#include "scopitem.h"
#include "snapin.h"

class CSnapIn;
class CScopeItem;
class CSnapInCollection;
   
class CScopeItems : public CSnapInCollection<IScopeItem, ScopeItem, IScopeItems>
{
    protected:
        CScopeItems(IUnknown *punkOuter);
        ~CScopeItems();

    public:
        static IUnknown *Create(IUnknown * punk);

        void FireExpand(IScopeItem *piScopeItem);
        void FireCollapse(IScopeItem *piScopeItem);
        void FireExpandSync(IScopeItem *piScopeItem, BOOL *pfHandled);
        void FireCollapseSync(IScopeItem *piScopeItem, BOOL *pfHandled);
        void FireGetDisplayInfo(IScopeItem *piScopeItem);

        void FirePropertyChanged(IScopeItem *piScopeItem, VARIANT Data);
        void FireRename(IScopeItem *piScopeItem, BSTR bstrNewName);
        void FireHelp(IScopeItem *piScopeItem);
        void FireRemoveChildren(IScopeNode *piScopeNode);

        HRESULT AddStaticNode(CScopeItem **ppScopeItem);
        HRESULT RemoveStaticNode(CScopeItem *pScopeItem);
        HRESULT AddAutoCreateChildren(IScopeItemDefs *piScopeItemDefs,
                                      IScopeItem     *piParentScopeItem);
        void SetSnapIn(CSnapIn *pSnapIn);
        HRESULT RemoveChildrenOfNode(IScopeNode *piScopeNode);
        HRESULT RemoveByNode(IScopeNode *piScopeNode, BOOL fRemoveChildren);
        HRESULT RemoveScopeItemByKey(VARIANT varKey);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    public:

    // IScopeItems

        STDMETHOD(get_Item)(VARIANT Index, IScopeItem **ppiScopeItem);

        STDMETHOD(Add)(BSTR                              Name,
                       ScopeNode                        *ScopeNodeRelative,
                       SnapInNodeRelationshipConstants   RelativeRelationship,
                       VARIANT                           HasChildren,
                       ScopeItem                       **ppScopeItem);

        STDMETHOD(AddPreDefined)(BSTR                              NodeTypeName,
                                 BSTR                              Name,
                                 ScopeNode                        *ScopeNodeRelative,
                                 SnapInNodeRelationshipConstants   RelativeRelationship,
                                 VARIANT                           HasChildren,
                                 ScopeItem                       **ppScopeItem);

        STDMETHOD(Remove)(BSTR Name);
        STDMETHOD(Clear)();

    private:


        HRESULT CreateScopeItem(BSTR bstrName, IScopeItem **ppiScopeItem);
        HRESULT RemoveScopeItemByName(BSTR bstrName);
        HRESULT InternalAddNew(BSTR                              bstrName,
                               BSTR                              bstrDisplayName,
                               BSTR                              bstrNodeTypeName,
                               BSTR                              bstrNodeTypeGUID,
                               IScopeNode                       *ScopeNodeRelative,
                               SnapInNodeRelationshipConstants   RelativeRelationship,
                               BOOL                              fHasChildren,
                               IScopeItem                      **ppiScopeItem);
        HRESULT InternalAddPredefined(BSTR                              bstrName,
                                      IScopeItemDef                    *piScopeItemDef,
                                      IScopeNode                       *ScopeNodeRelative,
                                      SnapInNodeRelationshipConstants   RelativeRelationship,
                                      VARIANT                           HasChildren,
                                      IScopeItem                      **ppiScopeItem);
        void FireInitialize(IScopeItem *piScopeItem);
        void FireTerminate(IScopeItem *piScopeItem);
        void InitMemberVariables();

        CSnapIn *m_pSnapIn; // bakc ptr to snap-in

        // Event parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtExpand[1];
        static EVENTINFO m_eiExpand;

        static VARTYPE   m_rgvtCollapse[1];
        static EVENTINFO m_eiCollapse;

        static VARTYPE   m_rgvtExpandSync[2];
        static EVENTINFO m_eiExpandSync;

        static VARTYPE   m_rgvtCollapseSync[2];
        static EVENTINFO m_eiCollapseSync;

        static VARTYPE   m_rgvtGetDisplayInfo[1];
        static EVENTINFO m_eiGetDisplayInfo;

        static VARTYPE   m_rgvtQueryPagesFor[2];
        static EVENTINFO m_eiQueryPagesFor;

        static VARTYPE   m_rgvtCreatePropertyPages[2];
        static EVENTINFO m_eiCreatePropertyPages;

        static VARTYPE   m_rgvtPropertyChanged[2];
        static EVENTINFO m_eiPropertyChanged;

        static VARTYPE   m_rgvtRename[2];
        static EVENTINFO m_eiRename;

        static VARTYPE   m_rgvtHelp[1];
        static EVENTINFO m_eiHelp;

        static VARTYPE   m_rgvtRemoveChildren[1];
        static EVENTINFO m_eiRemoveChildren;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItems,                 // name
                                &CLSID_ScopeItems,          // clsid
                                "ScopeItems",               // objname
                                "ScopeItems",               // lblname
                                &CScopeItems::Create,       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IScopeItems,           // dispatch IID
                                &DIID_DScopeItemsEvents,    // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


#endif // _SCOPEITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopitem.h ===
//=--------------------------------------------------------------------------=
// scopitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeItem class definition - implements ScopeItem object
//
//=--------------------------------------------------------------------------=


#ifndef _SCOPITEM_DEFINED_
#define _SCOPITEM_DEFINED_

#include "dataobj.h"
#include "scopitms.h"
#include "scopnode.h"
#include "snapin.h"

class CSnapIn;
class CMMCDataObject;
class CScopeNode;

class CScopeItem : public CSnapInAutomationObject,
                   public CPersistence,
                   public IScopeItem
{
    private:
        CScopeItem(IUnknown *punkOuter);
        ~CScopeItem();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopeItem
        BSTR_PROPERTY_RW(CScopeItem,        Name,                       DISPID_SCOPEITEM_NAME);
        SIMPLE_PROPERTY_RW(CScopeItem,      Index,                      long, DISPID_SCOPEITEM_INDEX);
        BSTR_PROPERTY_RW(CScopeItem,        Key,                        DISPID_SCOPEITEM_KEY);

        STDMETHOD(put_Folder)(VARIANT varFolder);
        STDMETHOD(get_Folder)(VARIANT *pvarFolder);

        COCLASS_PROPERTY_RO(CScopeItem,     Data,                       MMCDataObject, IMMCDataObject, DISPID_SCOPEITEM_DATA);
        BSTR_PROPERTY_RW(CScopeItem,        DefaultDataFormat,          DISPID_SCOPEITEM_DEFAULT_DATA_FORMAT);

        STDMETHOD(get_DynamicExtensions)(Extensions **ppExtensions);

        SIMPLE_PROPERTY_RW(CScopeItem,      SlowRetrieval,              VARIANT_BOOL, DISPID_SCOPEITEM_SLOW_RETRIEVAL);
        BSTR_PROPERTY_RW(CScopeItem,        NodeID,                     DISPID_SCOPEITEM_NODE_ID);
        VARIANTREF_PROPERTY_RW(CScopeItem,  Tag,                        DISPID_SCOPEITEM_TAG);
        COCLASS_PROPERTY_RO(CScopeItem,     ScopeNode,                  ScopeNode, IScopeNode, DISPID_SCOPEITEM_SCOPENODE);
        SIMPLE_PROPERTY_RW(CScopeItem,      Pasted,                     VARIANT_BOOL, DISPID_SCOPEITEM_PASTED);
        COCLASS_PROPERTY_RW(CScopeItem,     ColumnHeaders,              MMCColumnHeaders, IMMCColumnHeaders, DISPID_SCOPEITEM_COLUMN_HEADERS);

        STDMETHOD(get_SubItems)(short Index, BSTR *pbstrItem);
        STDMETHOD(put_SubItems)(short Index, BSTR bstrItem);

        COCLASS_PROPERTY_RW(CScopeItem,     ListSubItems,               MMCListSubItems, IMMCListSubItems, DISPID_SCOPEITEM_LIST_SUBITEMS);

        SIMPLE_PROPERTY_RO(CScopeItem,      Bold,                       VARIANT_BOOL, DISPID_SCOPEITEM_BOLD);
        STDMETHOD(put_Bold)(VARIANT_BOOL fvarBold);

        STDMETHOD(PropertyChanged(VARIANT Data));
        STDMETHOD(RemoveChildren());

    // Public utility methods
        BOOL IsStaticNode() { return m_fIsStatic; }
        void SetStaticNode() { m_fIsStatic = TRUE; }
        void SetSnapIn(CSnapIn *pSnapIn);
        CSnapIn *GetSnapIn() { return m_pSnapIn; }
        BSTR GetNamePtr() { return m_bstrName; }
        LPOLESTR GetDisplayNamePtr();
        IScopeItemDef *GetScopeItemDef() { return m_piScopeItemDef; }
        void SetScopeItemDef(IScopeItemDef *piScopeItemDef);
        CScopeNode *GetScopeNode() { return m_pScopeNode; }
        void SetData(IMMCDataObject *piMMCDataObject);
        HRESULT GetImageIndex(int *pnImage);
        CMMCDataObject *GetData() { return m_pData; }
        IExtensions *GetDynamicExtensions() { return m_piDynamicExtensions; }
        long GetIndex() { return m_Index; }
        void SetIndex(long lIndex) { m_Index = lIndex; }
        BSTR GetKey() { return m_bstrKey; }
        BSTR GetNodeID() { return m_bstrNodeID; }
        BOOL SlowRetrieval() { return VARIANTBOOL_TO_BOOL(m_SlowRetrieval); }
        HRESULT GiveHSCOPITEMToDynamicExtensions(HSCOPEITEM hsi);
        HRESULT SetFolder(VARIANT varFolder);

     // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT RemoveChild(IScopeNode *piScopeNode);
                
        BOOL            m_fIsStatic;           // TRUE=ScopeItem is for static node
        CSnapIn        *m_pSnapIn;             // bakc ptr to snap-in
        CScopeNode     *m_pScopeNode;          // ScopeItem.ScopeNode
        IScopeItemDef  *m_piScopeItemDef;      // ptr to design time def
        IExtensions    *m_piDynamicExtensions; // ScopeItem.DynamicExtensions
        VARIANT         m_varFolder;           // ScopeItem.Folder
        CMMCDataObject *m_pData;               // ScopeItem.Data
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeItem,                 // name
                                &CLSID_ScopeItem,          // clsid
                                "ScopeItem",               // objname
                                "ScopeItem",               // lblname
                                CScopeItem::Create,        // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IScopeItem,           // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _SCOPITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopnode.cpp ===
//=--------------------------------------------------------------------------=
// scopnode.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeNode class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "views.h"
#include "scopnode.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CScopeNode::CScopeNode(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SCOPENODE,
                           static_cast<IScopeNode *>(this),
                           static_cast<CScopeNode *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_ScopeNode,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopeNode::~CScopeNode()
{
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    
    InitMemberVariables();
}

void CScopeNode::InitMemberVariables()
{
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;
    m_hsi = NULL;
    m_pSnapIn = NULL;
    m_pScopeItem = NULL;
    m_fHaveHsi = FALSE;
    m_fMarkedForRemoval = FALSE;
}

IUnknown *CScopeNode::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkScopeNode = NULL;

    CScopeNode *pScopeNode = New CScopeNode(punkOuter);

    IfFalseGo(NULL != pScopeNode, SID_E_OUTOFMEMORY);
    punkScopeNode = pScopeNode->PrivateUnknown();

Error:
    if (FAILED(hr))
    {
        QUICK_RELEASE(punkScopeNode);
    }
    return punkScopeNode;
}

HRESULT CScopeNode::GetScopeNode
(
    HSCOPEITEM   hsi,
    IDataObject *piDataObject,
    CSnapIn     *pSnapIn,
    IScopeNode **ppiScopeNode
)
{
    HRESULT      hr = S_OK;
    IUnknown    *punkScopeNode = NULL;
    CScopeNode  *pScopeNode = NULL;
    CScopeItems *pScopeItems = pSnapIn->GetScopeItems();
    long         cScopeItems = pScopeItems->GetCount();
    long         i = 0;
    IScopeItem  *piScopeItem = NULL; // not AddRef()ed
    CScopeItem  *pScopeItem = NULL;

    // Need to determine whether the HSCOPEITEM belongs to us or not.
    // Iterate through the ScopeItems collection and check the hsi
    // against each scope item's HSI.

    for (i = 0; i < cScopeItems; i++)
    {
        piScopeItem = pScopeItems->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItem, &pScopeItem));
        if (hsi == pScopeItem->GetScopeNode()->GetHSCOPEITEM())
        {
            // Matched. AddRef the scope node and return it.
            *ppiScopeNode = static_cast<IScopeNode *>(pScopeItem->GetScopeNode());
            (*ppiScopeNode)->AddRef();
            goto Cleanup;
        }
    }

    // The scope item is foreign. Create a ScopeNode for it.

    punkScopeNode = CScopeNode::Create(NULL);
    if (NULL == punkScopeNode)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkScopeNode, &pScopeNode));

    // Set the scope node's properties

    pScopeNode->SetHSCOPEITEM(hsi);
    pScopeNode->SetSnapIn(pSnapIn);

    // Note that we do not set its ScopeItem pointer because we don't own it.
    // If the user gets ScopeNode.Owned it will come back False because there
    // is no ScopeItem pointer.

    // Unfortunately, an IDataObject is needed to get the display name and
    // node type GUID. If we don't have one these properties will remain
    // NULL.

    if (NULL != piDataObject)
    {
        hr = ::GetStringData(piDataObject, CMMCDataObject::GetcfDisplayName(),
                             &pScopeNode->m_bstrDisplayName);
        if (DV_E_FORMATETC == hr)
        {
            hr = S_OK; // if the format was not available it is not an error
        }
        IfFailGo(hr);

        hr = ::GetStringData(piDataObject, CMMCDataObject::GetcfSzNodeType(),
                             &pScopeNode->m_bstrNodeTypeGUID);
        if (DV_E_FORMATETC == hr)
        {
            hr = S_OK;
        }
        IfFailGo(hr);
    }

    *ppiScopeNode = static_cast<IScopeNode *>(pScopeNode);
    (*ppiScopeNode)->AddRef();

Cleanup:
Error:
    QUICK_RELEASE(punkScopeNode);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                          IScopeNode Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CScopeNode::get_Parent(ScopeNode **ppParent)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiParent = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppParent = NULL;

    // Get the parent from MMC

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetParentItem(m_hsi, &hsiParent, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Now we have the parent's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it.

    IfFailGo(GetScopeNode(hsiParent, NULL, m_pSnapIn,
                          reinterpret_cast<IScopeNode **>(ppParent)));

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_HasChildren(VARIANT_BOOL *pfvarHasChildren)
{
    HRESULT     hr = S_OK;
    IScopeNode *piScopeNode = NULL;

    *pfvarHasChildren = VARIANT_FALSE;

    IfFailGo(get_Child(reinterpret_cast<ScopeNode **>(&piScopeNode)));
    if (NULL != piScopeNode)
    {
        *pfvarHasChildren = VARIANT_TRUE;
    }

Error:
    QUICK_RELEASE(piScopeNode);
    RRETURN(hr);
}

STDMETHODIMP CScopeNode::put_HasChildren(VARIANT_BOOL fvarHasChildren)
{
    HRESULT hr = S_OK;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    sdi.mask = SDI_CHILDREN;
    sdi.ID = m_hsi;

    if (VARIANT_TRUE == fvarHasChildren)
    {
        sdi.cChildren = 1;
    }
    else
    {
        sdi.cChildren = 0;
    }

    hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}

STDMETHODIMP CScopeNode::get_Child(ScopeNode **ppChild)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiChild = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppChild = NULL;

    // Get the Child from MMC

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetChildItem(m_hsi, &hsiChild, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Now we have the child item's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it. If there is no child item then MMC returns a
    // NULL HSCOPEITEM

    if (NULL != hsiChild)
    {
        IfFailGo(GetScopeNode(hsiChild, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppChild)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_FirstSibling(ScopeNode **ppFirstSibling)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiFirstSibling = NULL;
    HSCOPEITEM  hsiParent = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppFirstSibling = NULL;

    // MMC does not supply the first sibling so we need to get the parent
    // of this node and then get its child

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetParentItem(m_hsi, &hsiParent, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Parent could be NULL if the user crawled all the way up to the console
    // root. In that case we just return NULL as there is no first sibling.

    IfFalseGo(NULL != hsiParent, S_OK);

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetChildItem(hsiParent, &hsiFirstSibling, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // If this scope node is the first sibling then just return it

    if (m_hsi == hsiFirstSibling)
    {
        AddRef();
        *ppFirstSibling = reinterpret_cast<ScopeNode *>(static_cast<IScopeNode *>(this));
    }

    // Now we have the first sibling item's HSCOPEITEM and cookie but we need to
    // get a ScopeNode object for it. MMC should not have returned NULL but
    // we'll double check anyway.

    else if (NULL != hsiFirstSibling)
    {
        IfFailGo(GetScopeNode(hsiFirstSibling, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppFirstSibling)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_Next(ScopeNode **ppNext)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiNext = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppNext = NULL;

    // Get the next item from MMC

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetNextItem(m_hsi, &hsiNext, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    // Now we have the next item's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it. If there is no next item then MMC returns a
    // NULL HSCOPEITEM

    if (NULL != hsiNext)
    {
        IfFailGo(GetScopeNode(hsiNext, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppNext)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_LastSibling(ScopeNode **ppLastSibling)
{
    HRESULT     hr = S_OK;
    HSCOPEITEM  hsiNextSibling = NULL;
    HSCOPEITEM  hsiLastSibling = NULL;
    long        lCookie = 0;

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppLastSibling = NULL;

    // MMC does not supply the last sibling so we need to do GetNext until
    // we hit the last one.

    hsiLastSibling = m_hsi;

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetNextItem(m_hsi, &hsiNextSibling, &lCookie);
    EXCEPTION_CHECK_GO(hr);

    while (NULL != hsiNextSibling)
    {
        hsiLastSibling = hsiNextSibling;

        hr = m_pSnapIn->GetIConsoleNameSpace2()->GetNextItem(hsiLastSibling,
                                                             &hsiNextSibling,
                                                             &lCookie);
        EXCEPTION_CHECK_GO(hr);

    }

    // If this scope node is the last sibling then just return it

    if (m_hsi == hsiLastSibling)
    {
        AddRef();
        *ppLastSibling = reinterpret_cast<ScopeNode *>(static_cast<IScopeNode *>(this));
    }

    // Now we have the last sibling's HSCOPEITEM and cookie but we need to get a
    // ScopeNode object for it.

    else
    {
        IfFailGo(GetScopeNode(hsiLastSibling, NULL, m_pSnapIn,
                              reinterpret_cast<IScopeNode **>(ppLastSibling)));
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_ExpandedOnce(VARIANT_BOOL *pfvarExpandedOnce)
{
    HRESULT       hr = S_OK;
    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    *pfvarExpandedOnce = VARIANT_FALSE;

    // If we don't yet have the HSI then the node hasn't been expanded yet

    IfFalseGo(m_fHaveHsi, S_OK);

    sdi.mask = SDI_STATE;
    sdi.ID = m_hsi;

    hr = m_pSnapIn->GetIConsoleNameSpace2()->GetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

    if ( (sdi.nState & MMC_SCOPE_ITEM_STATE_EXPANDEDONCE) != 0 )
    {
        *pfvarExpandedOnce = VARIANT_TRUE;
    }

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopeNode::get_Owned(VARIANT_BOOL *pfvarOwned)
{
    if (NULL != m_pScopeItem)
    {
        *pfvarOwned = VARIANT_TRUE;
    }
    else
    {
        *pfvarOwned = VARIANT_FALSE;
    }

    return S_OK;
}


STDMETHODIMP CScopeNode::ExpandInNameSpace()
{
    HRESULT hr = S_OK;

    // Check passed pointer and check that this is not a disconnected or
    // foreign ScopeNode

    if (NULL == m_pSnapIn)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    if (!m_fHaveHsi)
    {
        hr = SID_E_SCOPE_NODE_NOT_CONNECTED;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_pSnapIn->GetIConsoleNameSpace2()->Expand(m_hsi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CScopeNode::get_DisplayName(BSTR *pbstrDisplayName)
{
    RRETURN(GetBstr(pbstrDisplayName, m_bstrDisplayName));
}


STDMETHODIMP CScopeNode::put_DisplayName(BSTR bstrDisplayName)
{
    HRESULT      hr = S_OK;
    VARIANT_BOOL fvarOwned = VARIANT_FALSE;

    SCOPEDATAITEM sdi;
    ::ZeroMemory(&sdi, sizeof(sdi));

    // If it is not one of ours then return an error.

    if (NULL == m_pScopeItem)
    {
        hr = SID_E_CANT_CHANGE_UNOWNED_SCOPENODE;
        EXCEPTION_CHECK_GO(hr);
    }

    // Set the property

    IfFailGo(SetBstr(bstrDisplayName, &m_bstrDisplayName,
                     DISPID_SCOPENODE_DISPLAY_NAME));

    // If this ScopeItem represents the static node then we also need to
    // change SnapIn.DisplayName as it also represents the display name
    // for the static node.
    
    if (m_pScopeItem->IsStaticNode())
    {
        IfFailGo(m_pSnapIn->SetDisplayName(bstrDisplayName));
    }

    // Tell MMC we're changing the display name
    // (if we already have our HSCOPEITEM)

    IfFalseGo(m_fHaveHsi, S_OK);
    
    sdi.mask = SDI_STR;

    if (m_pScopeItem->IsStaticNode())
    {
        // MMC allows passing the string for the static node
        sdi.displayname = m_bstrDisplayName;
    }
    else
    {
        // MMC requires using MMC_CALLBACK for dynamic nodes
        sdi.displayname = MMC_CALLBACK;
    }
    sdi.ID = m_hsi;

    hr = m_pSnapIn->GetIConsoleNameSpace2()->SetItem(&sdi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeNode::Persist()
{
    HRESULT hr = S_OK;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("NodeTypeName")));

    IfFailGo(PersistBstr(&m_bstrNodeTypeGUID, L"", OLESTR("NodeTypeGUID")));

    IfFailGo(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    // NOTE: we do not serialize any navigational properties such as parent,
    // first sibling etc. as these are all extracted from MMC calls.

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopeNode::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IScopeNode == riid)
    {
        *ppvObjOut = static_cast<IScopeNode *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\scopnode.h ===
//=--------------------------------------------------------------------------=
// scopnode.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopeNode class definition - implements ScopeNode object
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPENODE_DEFINED_
#define _SCOPENODE_DEFINED_

#include "dataobj.h"
#include "snapin.h"
#include "scopitem.h"

class CSnapIn;
class CScopeItem;


class CScopeNode : public CSnapInAutomationObject,
                   public CPersistence,
                   public IScopeNode
{
    private:
        CScopeNode(IUnknown *punkOuter);
        ~CScopeNode();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopeNode
        BSTR_PROPERTY_RW(CScopeNode, NodeTypeName, DISPID_SCOPENODE_NODE_TYPE_NAME);
        BSTR_PROPERTY_RW(CScopeNode, NodeTypeGUID, DISPID_SCOPENODE_NODE_TYPE_GUID);

        STDMETHOD(get_DisplayName)(BSTR *pbstrDisplayName);
        STDMETHOD(put_DisplayName)(BSTR bstrDisplayName);

        STDMETHOD(get_Parent)(ScopeNode **ppParent);

        STDMETHOD(get_HasChildren)(VARIANT_BOOL *pfvarHasChildren);
        STDMETHOD(put_HasChildren)(VARIANT_BOOL fvarHasChildren);

        STDMETHOD(get_Child)(ScopeNode **ppChild);
        STDMETHOD(get_FirstSibling)(ScopeNode **ppFirstSibling);
        STDMETHOD(get_Next)(ScopeNode **ppNext);
        STDMETHOD(get_LastSibling)(ScopeNode **ppLastSibling);
        STDMETHOD(get_ExpandedOnce)(VARIANT_BOOL *pfvarExpandedOnce);
        STDMETHOD(get_Owned)(VARIANT_BOOL *pfvarOwned);

        STDMETHOD(ExpandInNameSpace)();

    // Non-interface public utility methods

        void SetHSCOPEITEM(HSCOPEITEM hsi) { m_hsi = hsi; m_fHaveHsi = TRUE; }
        HSCOPEITEM GetHSCOPEITEM() { return m_hsi; }
        BOOL HaveHsi() { return m_fHaveHsi; }

        LPOLESTR GetDisplayNamePtr() { return static_cast<LPOLESTR>(m_bstrDisplayName); }

        BSTR GetNodeTypeGUID() { return m_bstrNodeTypeGUID; }

        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }

        void SetScopeItem(CScopeItem *pScopeItem) { m_pScopeItem = pScopeItem; }
        CScopeItem *GetScopeItem() { return m_pScopeItem; }

        void MarkForRemoval() { m_fMarkedForRemoval = TRUE; }
        BOOL MarkedForRemoval() { return m_fMarkedForRemoval; }

        static HRESULT GetScopeNode(HSCOPEITEM   hsi,
                                    IDataObject *piDataObject,
                                    CSnapIn     *pSnapIn,
                                    IScopeNode **ppiScopeNode);

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        HSCOPEITEM  m_hsi;               // HSCOPEITEM for node
        BOOL        m_fHaveHsi;          // TRUE=m_hsi contains HSCOPEITEM
        CSnapIn    *m_pSnapIn;           // back ptr to snap-in
        CScopeItem *m_pScopeItem;        // back ptr to ScopeItem
        BSTR        m_bstrDisplayName;   // ScopeNode.DisplayName
        BOOL        m_fMarkedForRemoval; // Used during MMCN_REMOVECHILDREN
                                         // to determine which nodes have to be
                                         // removed
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopeNode,                 // name
                                &CLSID_ScopeNode,          // clsid
                                "ScopeNode",               // objname
                                "ScopeNode",               // lblname
                                CScopeNode::Create,        // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IScopeNode,           // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _SCOPENODE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\siautobj.cpp ===
//=--------------------------------------------------------------------------=
// siautobj.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInAutomationObject class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "dataobj.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInAutomationObject::CSnapInAutomationObject
(
    IUnknown      *punkOuter,
    int            nObjectType,
    void          *piMainInterface,
    void          *pThis,
    ULONG          cPropertyPages,
    const GUID   **rgpPropertyPageCLSIDs,
    CPersistence  *pPersistence
) : CAutomationObjectWEvents(punkOuter,
                             nObjectType,
                             piMainInterface),
    CError(static_cast<CAutomationObject *>(this))
{
    InitMemberVariables();
    m_pPersistence = pPersistence;
    m_cPropertyPages = cPropertyPages;
    m_rgpPropertyPageCLSIDs = rgpPropertyPageCLSIDs;
    m_pThis = pThis;
}

#pragma warning(default:4355)  // using 'this' in constructor


void CSnapInAutomationObject::InitMemberVariables()
{
    m_Cookie = 0;
    m_DISPID = 0;
    m_fKeysOnly = FALSE;
    m_piObjectModelHost = NULL;
    m_pPersistence = NULL;
    m_cPropertyPages = 0;
    m_rgpPropertyPageCLSIDs = NULL;
    m_lUsageCount = 0;
}

CSnapInAutomationObject::~CSnapInAutomationObject()
{
    RELEASE(m_piObjectModelHost);
    InitMemberVariables();
}

HRESULT CSnapInAutomationObject::SetBstr
(
    BSTR    bstrNew,
    BSTR   *pbstrProperty,
    DISPID  dispid
)
{
    HRESULT hr = S_OK;
    BSTR    bstrNewCopy = NULL;
    BSTR    bstrOld = *pbstrProperty;

    // Copy the BSTR

    if (NULL != bstrNew)
    {
        bstrNewCopy = ::SysAllocString(bstrNew);
        IfFalseGo(NULL != bstrNewCopy, SID_E_OUTOFMEMORY);
    }

    // Set the property

    *pbstrProperty = bstrNewCopy;

    // Inform any interested parties of the change.
    
    IfFailGo(PropertyChanged(dispid));

    // Change was accepted. Free the old value.
    
    FREESTRING(bstrOld);

Error:
    if (FAILED(hr))
    {
        // Revert to original property value
        *pbstrProperty = bstrOld;

        // Free the copy if we made of the new value
        FREESTRING(bstrNewCopy);

        // If we generated the error then generate the exception info for it
        if (SID_E_OUTOFMEMORY == hr)
        {
            EXCEPTION_CHECK(hr);
        }
    }
    RRETURN(hr);
}

HRESULT CSnapInAutomationObject::GetBstr
(
    BSTR *pbstrOut,
    BSTR bstrProperty
)
{
    IfFalseRet(NULL != pbstrOut, SID_E_INVALIDARG);

    if (NULL != bstrProperty)
    {
        *pbstrOut = ::SysAllocString(bstrProperty);
        IfFalseRet(NULL != *pbstrOut, SID_E_OUTOFMEMORY);
    }
    else
    {
        *pbstrOut = NULL;
    }

    return S_OK;
}


HRESULT CSnapInAutomationObject::SetVariant
(
    VARIANT  varNew,
    VARIANT *pvarProperty,
    DISPID   dispid
)
{
    HRESULT hr = S_OK;

    VARIANT varNewCopy;
    ::VariantInit(&varNewCopy);

    VARIANT varOld;
    ::VariantInit(&varOld);

    // Make a copy of the old property value. We will need this in order to
    // revert in the case where the change was refused by the object model host.

    varOld = *pvarProperty;

    // Check if the variant type is supported. We accept all of these types
    // and arrays of these types.
    // NTBUGS 354572 Allow arrays as well as simple type

    switch (varNew.vt & (~VT_ARRAY))
    {
        case VT_I4:
        case VT_UI1:
        case VT_I2:
        case VT_R4:
        case VT_R8:
        case VT_BOOL:
        case VT_ERROR:
        case VT_CY:
        case VT_DATE:
        case VT_BSTR:
        case VT_UNKNOWN:
        case VT_DISPATCH:
        case VT_EMPTY:
            break;

        default:
            hr = SID_E_UNSUPPORTED_TYPE;
            EXCEPTION_CHECK_GO(hr);
    }

    // Make a local copy of the new VARIANT first. We need to do this
    // because VariantCopy() first calls VariantClear() on the destination
    // and then attempts to copy the source. If the source cannot be copied
    // we do not want to free the destination.
    
    hr = ::VariantCopy(&varNewCopy, &varNew);
    EXCEPTION_CHECK_GO(hr);

    // Copy in the new value

    *pvarProperty = varNewCopy;

    // Inform the object model host and VB of the change.

    IfFailGo(PropertyChanged(dispid));

    // Property change was accepted. Free the old value. We don't error check
    // this call because if it fails then there is no way to roll back at this
    // point as the host/VB have already accepted the change. Also, a failure
    // would at most cause a leak.

    (void)::VariantClear(&varOld);

Error:
    if (FAILED(hr))
    {
        // Revert to the old property value
        *pvarProperty = varOld;

        // Free the copy of the new value if we made it.
        (void)::VariantClear(&varNewCopy);
    }
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetVariant
(
    VARIANT *pvarOut,
    VARIANT  varProperty
)
{
    // Call VariantInit() on the destination in case it is not initialized
    // because VariantCopy() will first call VariantClear() which requires
    // an initialized VARIANT.

    ::VariantInit(pvarOut);
    return ::VariantCopy(pvarOut, &varProperty);
}


HRESULT CSnapInAutomationObject::UIUpdate(DISPID dispid)
{
    if (NULL != m_piObjectModelHost)
    {
        RRETURN(m_piObjectModelHost->Update(m_Cookie, PrivateUnknown(), dispid));
    }
    else
    {
        return S_OK;
    }
}

HRESULT CSnapInAutomationObject::PropertyChanged(DISPID dispid)
{
    HRESULT hr = S_OK;

    // First ask the object model host if the change can be made. In practice
    // this should only be the designer checking that a name is unique for
    // objects that have typeinfo.
    
    IfFailGo(UIUpdate(dispid));

    // Mark the object dirty
    
    SetDirty();

    // Inform the IPropertyNotifySink guys. In practice that should be only in
    // the designer when the VB property browser monitors updates. It is also
    // used by CMMCListViewDef at design time to catch property updates to
    // its contained MMCListView object.
    
    m_cpPropNotify.DoOnChanged(dispid);

Error:
    RRETURN(hr);
}


STDMETHODIMP CSnapInAutomationObject::SetHost
(
    IObjectModelHost *piObjectModelHost
)
{
    RELEASE(m_piObjectModelHost);
    if (NULL != piObjectModelHost)
    {
        piObjectModelHost->AddRef();
        m_piObjectModelHost = piObjectModelHost;
    }
    RRETURN(OnSetHost());
}


STDMETHODIMP CSnapInAutomationObject::SetCookie(long Cookie)
{
    m_Cookie = Cookie;
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::GetCookie(long *pCookie)
{
    *pCookie = m_Cookie;
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::IncrementUsageCount()
{
    m_lUsageCount++;
    return S_OK;
}

STDMETHODIMP CSnapInAutomationObject::DecrementUsageCount()
{
    HRESULT hr = S_OK;

    if (m_lUsageCount > 0)
    {
        m_lUsageCount--;
    }
    else
    {
        ASSERT(FALSE, "Object usage count decremented past zero");
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    return hr;
}

STDMETHODIMP CSnapInAutomationObject::GetUsageCount(long *plCount)
{
    if (NULL != plCount)
    {
        *plCount = m_lUsageCount;
    }
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::SetDISPID(DISPID dispid)
{
    m_DISPID = dispid;
    return S_OK;
}


STDMETHODIMP CSnapInAutomationObject::GetDISPID(DISPID *pdispid)
{
    *pdispid = m_DISPID;
    return S_OK;
}

HRESULT CSnapInAutomationObject::PersistDISPID()
{
    HRESULT hr = S_OK;

    if (NULL == m_pPersistence)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_pPersistence->PersistSimpleType(&m_DISPID, (DISPID)0, OLESTR("DISPID")));

Error:
    RRETURN(hr);
}


STDMETHODIMP CSnapInAutomationObject::SerializeKeysOnly(BOOL fKeysOnly)
{
    m_fKeysOnly = fKeysOnly;
    if (m_fKeysOnly)
    {
        RRETURN(OnKeysOnly());
    }
    else
    {
        return S_OK;
    }
}


STDMETHODIMP_(void *) CSnapInAutomationObject::GetThisPointer()
{
    return m_pThis;
}

STDMETHODIMP CSnapInAutomationObject::GetSnapInDesignerDef
(
    ISnapInDesignerDef **ppiSnapInDesignerDef
)
{
    HRESULT hr = S_OK;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piObjectModelHost->GetSnapInDesignerDef(ppiSnapInDesignerDef);

Error:
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::OnSetHost()
{
    return S_OK;
}


void CSnapInAutomationObject::SetDirty()
{
    if (NULL != m_pPersistence)
    {
        m_pPersistence->SetDirty();
    }
}


HRESULT CSnapInAutomationObject::GetImages
(
    IMMCImageList **ppiMMCImageListOut,
    BSTR            bstrImagesKey,
    IMMCImageList **ppiMMCImageListProperty
)
{
    HRESULT hr = S_OK;

    // If there is no key then the image list has never been set

    if (NULL == bstrImagesKey)
    {
        *ppiMMCImageListOut = NULL;
        return S_OK;
    }
    else if (L'\0' == bstrImagesKey[0])
    {
        *ppiMMCImageListOut = NULL;
        return S_OK;
    }

    // If we have a key but no image list then we are after a load and haven't
    // yet retrieved the image list from the master ImageLists collection.

    if (NULL == *ppiMMCImageListProperty)
    {
        IfFailRet(GetImageList(bstrImagesKey, ppiMMCImageListProperty));
    }

    RRETURN(GetObject(ppiMMCImageListOut, *ppiMMCImageListProperty));
}

HRESULT CSnapInAutomationObject::SetImages
(
    IMMCImageList  *piMMCImageListIn,
    BSTR           *pbstrImagesKey,
    IMMCImageList **ppiMMCImageListProperty
)
{
    HRESULT         hr = S_OK;
    BSTR            bstrNewImagesKey = NULL;
    IMMCImageList  *piMMCImageListFromMaster = NULL;

    // If setting to nothing then release our key and image list.
    if (NULL == piMMCImageListIn)
    {
        if (NULL != *ppiMMCImageListProperty)
        {
            (*ppiMMCImageListProperty)->Release();
            *ppiMMCImageListProperty = NULL;
        }
        if (NULL != *pbstrImagesKey)
        {
            ::SysFreeString(*pbstrImagesKey);
            *pbstrImagesKey = NULL;
        }
        return S_OK;
    }

    // First get the key of the new list

    IfFailGo(piMMCImageListIn->get_Key(&bstrNewImagesKey));

    // Check if the new image list is already in the master collection. If not
    // then return an error.

    // UNDONE: this would preclude a runtime setting of an image list property
    // Maybe if not in master then add it to master

    hr = GetImageList(bstrNewImagesKey, &piMMCImageListFromMaster);
    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }
    else
    {
        IfFailGo(hr);
    }

    // Set our image list property and key

    if (NULL != *pbstrImagesKey)
    {
        ::SysFreeString(*pbstrImagesKey);
    }
    *pbstrImagesKey = bstrNewImagesKey;

    if (NULL != *ppiMMCImageListProperty)
    {
        (*ppiMMCImageListProperty)->Release();
    }
    piMMCImageListIn->AddRef();
    *ppiMMCImageListProperty = piMMCImageListIn;


Error:
    if (FAILED(hr))
    {
        FREESTRING(bstrNewImagesKey);
    }
    QUICK_RELEASE(piMMCImageListFromMaster);
    RRETURN(hr);
}



HRESULT CSnapInAutomationObject::GetToolbars
(
    IMMCToolbars **ppiMMCToolbars
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_Toolbars(ppiMMCToolbars));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}




HRESULT CSnapInAutomationObject::GetImageLists
(
    IMMCImageLists **ppiMMCImageLists
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ImageLists(ppiMMCImageLists));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetImageList
(
    BSTR            bstrKey,
    IMMCImageList **ppiMMCImageList
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;
    IMMCImageLists     *piMMCImageLists = NULL;
    VARIANT             varIndex;

    ::VariantInit(&varIndex);
    varIndex.vt = VT_BSTR;
    varIndex.bstrVal = bstrKey;
    
    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));
    hr = piMMCImageLists->get_Item(varIndex, ppiMMCImageList);
    
Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    QUICK_RELEASE(piMMCImageLists);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetSnapInViewDefs
(
    IViewDefs **ppiViewDefs
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;
    ISnapInDef         *piSnapInDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_SnapInDef(&piSnapInDef));
    IfFailGo(piSnapInDef->get_ViewDefs(ppiViewDefs));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    QUICK_RELEASE(piSnapInDef);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetViewDefs
(
    IViewDefs **ppiViewDefs
)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ViewDefs(ppiViewDefs));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}

HRESULT CSnapInAutomationObject::GetListViewDefs
(
    IListViewDefs **ppiListViewDefs
)
{
    HRESULT             hr = S_OK;
    IViewDefs          *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(ppiListViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetOCXViewDefs
(
    IOCXViewDefs **ppiOCXViewDefs
)
{
    HRESULT    hr = S_OK;
    IViewDefs *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_OCXViews(ppiOCXViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}

HRESULT CSnapInAutomationObject::GetURLViewDefs
(
    IURLViewDefs **ppiURLViewDefs
)
{
    HRESULT    hr = S_OK;
    IViewDefs *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_URLViews(ppiURLViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetTaskpadViewDefs
(
    ITaskpadViewDefs **ppiTaskpadViewDefs
)
{
    HRESULT    hr = S_OK;
    IViewDefs *piViewDefs = NULL;

    IfFailGo(GetViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_TaskpadViews(ppiTaskpadViewDefs));

Error:
    QUICK_RELEASE(piViewDefs);
    RRETURN(hr);
}



HRESULT CSnapInAutomationObject::GetAtRuntime(BOOL *pfRuntime)
{
    HRESULT hr = S_OK;

    if ( (NULL == m_piObjectModelHost) || (NULL == pfRuntime) )
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetRuntime(pfRuntime));

Error:
    if (FAILED(hr))
    {
        *pfRuntime = FALSE;
    }
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetProjectName(BSTR *pbstrProjectName)
{
    HRESULT             hr = S_OK;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    if (NULL == m_piObjectModelHost)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(m_piObjectModelHost->GetSnapInDesignerDef(&piSnapInDesignerDef));
    IfFailGo(piSnapInDesignerDef->get_ProjectName(pbstrProjectName));

Error:
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}




STDMETHODIMP CSnapInAutomationObject::GetPages(CAUUID *pPropertyPages)
{
    HRESULT  hr = S_OK;
    ULONG    i = 0;

    if (0 == m_cPropertyPages)
    {
        pPropertyPages->cElems = 0;
        pPropertyPages->pElems = NULL;
        goto Error;
    }

    pPropertyPages->pElems =
              (GUID *)::CoTaskMemAlloc(sizeof(GUID) * m_cPropertyPages);

    if (NULL == pPropertyPages->pElems)
    {
        pPropertyPages->cElems = 0;
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    pPropertyPages->cElems = m_cPropertyPages;

    for (i = 0; i < m_cPropertyPages; i++)
    {
        pPropertyPages->pElems[i] = *m_rgpPropertyPageCLSIDs[i];
    }
    

Error:
    RRETURN(hr);
}



HRESULT CSnapInAutomationObject::GetCxxObject
(
    IDataObject     *piDataObject,
    CMMCDataObject **ppMMCDataObject
)
{
    HRESULT         hr = S_OK;
    IMMCDataObject *piMMCDataObject = NULL;

    *ppMMCDataObject = NULL;

    IfFailGo(piDataObject->QueryInterface (IID_IMMCDataObject,
                                  reinterpret_cast<void **>(&piMMCDataObject)));

    IfFailGo(GetCxxObject(piMMCDataObject, ppMMCDataObject));

Error:
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}


HRESULT CSnapInAutomationObject::GetCxxObject
(
    IMMCDataObject  *piMMCDataObject,
    CMMCDataObject **ppMMCDataObject
)
{
    *ppMMCDataObject = static_cast<CMMCDataObject *>(piMMCDataObject);
    return S_OK;
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInAutomationObject::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_IObjectModel == riid)
    {
        *ppvObjOut = static_cast<IObjectModel *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ISupportErrorInfo == riid)
    {
        *ppvObjOut = static_cast<ISupportErrorInfo *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if ( (IID_ISpecifyPropertyPages == riid) && (0 != m_cPropertyPages) )
    {
        *ppvObjOut = static_cast<ISpecifyPropertyPages *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CAutomationObjectWEvents::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\siautobj.h ===
//=--------------------------------------------------------------------------=
// siautobj.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInAutomationObject class definition
//
//=--------------------------------------------------------------------------=

#ifndef _SIAUTOBJ_DEFINED_
#define _SIAUTOBJ_DEFINED_

class CMMCDataObject;

//=--------------------------------------------------------------------------=
//
//          Helper Macros for Defining Common Property Types
//
//=--------------------------------------------------------------------------=


#define BSTR_PROPERTY_RO(ClassName, PropertyName, dispid) \
        BSTR m_bstr##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(BSTR *pbstrValue) \
        { \
            return GetBstr(pbstrValue, m_bstr##PropertyName); \
        }

#define BSTR_PROPERTY_RW(ClassName, PropertyName, dispid) \
        BSTR_PROPERTY_RO(ClassName, PropertyName, dispid) \
        STDMETHODIMP ClassName##::put_##PropertyName(BSTR bstrNewValue) \
        { \
            return SetBstr(bstrNewValue, &m_bstr##PropertyName, dispid); \
        }


// Simple properties: long, short, enums, etc.

#define SIMPLE_PROPERTY_RO(ClassName, PropertyName, PropertyType, dispid) \
        PropertyType m_##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(PropertyType *pValue) \
        { \
            return GetSimpleType(pValue, m_##PropertyName); \
        }

#define SIMPLE_PROPERTY_RW(ClassName, PropertyName, PropertyType, dispid) \
        SIMPLE_PROPERTY_RO(ClassName, PropertyName, PropertyType, dispid) \
        STDMETHODIMP ClassName##::put_##PropertyName(PropertyType NewValue) \
        { \
            return SetSimpleType(NewValue, &m_##PropertyName, dispid); \
        }



#define VARIANT_PROPERTY_RO(ClassName, PropertyName, dispid) \
        VARIANT m_var##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(VARIANT *pvarValue) \
        { \
            return GetVariant(pvarValue, m_var##PropertyName); \
        }


#define VARIANT_PROPERTY_RW(ClassName, PropertyName, dispid) \
        VARIANT_PROPERTY_RO(ClassName, PropertyName, dispid) \
        STDMETHODIMP ClassName##::put_##PropertyName(VARIANT varNewValue) \
        { \
            return SetVariant(varNewValue, &m_var##PropertyName, dispid); \
        }



#define VARIANTREF_PROPERTY_RW(ClassName, PropertyName, dispid) \
        VARIANT_PROPERTY_RW(ClassName, PropertyName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(VARIANT varNewValue) \
        { \
            return SetVariant(varNewValue, &m_var##PropertyName, dispid); \
        }



#define OBJECT_PROPERTY_RO(ClassName, PropertyName, InterfaceName, dispid) \
        InterfaceName *m_pi##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(InterfaceName **ppiInterface) \
        { \
            return GetObject(ppiInterface, m_pi##PropertyName); \
        }



#define OBJECT_PROPERTY_RW(ClassName, PropertyName, InterfaceName, dispid) \
        OBJECT_PROPERTY_RO(ClassName, PropertyName, InterfaceName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(InterfaceName *piInterface) \
        { \
            return SetObject(piInterface,\
                             IID_##InterfaceName, \
                             &m_pi##PropertyName, \
                             dispid); \
        }


#define OBJECT_PROPERTY_WO(ClassName, PropertyName, InterfaceName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(InterfaceName *piInterface) \
        { \
            return SetObject(piInterface,\
                             IID_##InterfaceName, \
                             &m_pi##PropertyName, \
                             dispid); \
        }


#define COCLASS_PROPERTY_RO(ClassName, PropertyName, CoClassName, InterfaceName, dispid) \
        InterfaceName *m_pi##PropertyName; \
        STDMETHODIMP ClassName##::get_##PropertyName(CoClassName **ppCoClass) \
        { \
            InterfaceName *piInterface = NULL; \
            HRESULT        hr = GetObject(&piInterface, m_pi##PropertyName); \
            if (SUCCEEDED(hr)) \
            { \
                *ppCoClass = reinterpret_cast<CoClassName *>(piInterface); \
            } \
            else\
            { \
                *ppCoClass = NULL; \
            } \
            H_RRETURN(hr); \
        }

#define COCLASS_PROPERTY_RW(ClassName, PropertyName, CoClassName, InterfaceName, dispid) \
        COCLASS_PROPERTY_RO(ClassName, PropertyName, CoClassName, InterfaceName, dispid) \
        STDMETHODIMP ClassName##::putref_##PropertyName(CoClassName *pCoClass) \
        { \
            return SetObject(reinterpret_cast<InterfaceName *>(pCoClass),\
                             IID_##InterfaceName, \
                             &m_pi##PropertyName, \
                             dispid); \
        }

//=--------------------------------------------------------------------------=
//
//          Helper Macros for Defining Common Property Types that Map to
//          a Contained Object's Properties
//
//=--------------------------------------------------------------------------=

// This is used by CListViewDef that contains a ListView object and exposes
// its properties at design time

#define X_PROPERTY_RW(ClassName, PropertyName, PropertyType, dispid, ContainedObject) \
    STDMETHODIMP ClassName##::get_##PropertyName(PropertyType *pValue) \
    { \
        HRESULT hr = S_OK; \
        if (NULL == m_pi##ContainedObject) \
        { \
            hr = SID_E_INTERNAL; \
            EXCEPTION_CHECK_GO(hr); \
        } \
        H_IfFailRet(m_pi##ContainedObject->get_##PropertyName(pValue)); \
    Error: \
        H_RRETURN(hr); \
    } \
    STDMETHODIMP ClassName##::put_##PropertyName(PropertyType NewValue) \
    { \
        HRESULT hr = S_OK; \
        if (NULL == m_pi##ContainedObject) \
        { \
            hr = SID_E_INTERNAL; \
            EXCEPTION_CHECK_GO(hr); \
        } \
        H_IfFailGo(m_pi##ContainedObject->put_##PropertyName(NewValue)); \
        hr = PropertyChanged(dispid); \
    Error: \
        H_RRETURN(hr); \
    }

//=--------------------------------------------------------------------------=
//
//                  Helper Macros for VARIANT parameters
//
//=--------------------------------------------------------------------------=

// Detect if an optional parameter was passed

#define ISPRESENT(var) \
    ( !((VT_ERROR == (var).vt) && (DISP_E_PARAMNOTFOUND == (var).scode)) )


// Give a VARIANT the value of a missing optional parameter

#define UNSPECIFIED_PARAM(var) { ::VariantInit(&var); \
                                 var.vt = VT_ERROR; \
                                 var.scode = DISP_E_PARAMNOTFOUND; }

#define ISEMPTY(var) (VT_EMPTY == (var).vt)

//=--------------------------------------------------------------------------=
//
// Convert a VARIANT_BOOL to a BOOL
// (the opposite is available in vb98ctls\include\ipserver.h)
//
//=--------------------------------------------------------------------------=

#define VARIANTBOOL_TO_BOOL(f) (VARIANT_TRUE == (f)) ? TRUE : FALSE

//=--------------------------------------------------------------------------=
//
// Negate a VARIANT_BOOL
//
//=--------------------------------------------------------------------------=

#define NEGATE_VARIANTBOOL(f) (VARIANT_TRUE == (f)) ? VARIANT_FALSE : VARIANT_TRUE

//=--------------------------------------------------------------------------=
//
// Validate a BSTR
//
// Checks that the BSTR is not NULL and is not an empty string
//
//=--------------------------------------------------------------------------=

#define ValidBstr(bstr) ( (NULL != (bstr)) ? (0 != ::wcslen(bstr)) : FALSE )

//=--------------------------------------------------------------------------=
//
// class CSnapInAutomationObject
//
// This is the base class for all objects in the designer object model. It
// derives from the framework's CAutomationObjectWEvents. It implements
// interfaces needed by most objects and sends IPropertySinkNotify notifications
// when a property value is changed.
//
// Note: all classes deriving from CSnapInAutomationObject must use
// DEFINE_AUTOMATIONOBJECTWEVENTS2 even if they do not have an event interface.
// This is necessary because CSnapInAutomationObject derives from
// CAutomationObjectWEvents. If the object does not have events then specify
// NULL for its events IID.
// This was done for simplicity reasons even though CAutomationObjectWEvents
// requires some additional memory over CAutomationObject.
//
// This class implements IObjectModel for all classes. The constructor takes
// a C++ pointer to the derived-most class that is available at any time
// by calling CSnapInAutomationObject::GetCxxObject on any interface pointer
// on the object. This eliminates any potential casting errors.
//
// This class also implements ISpecifyPropertyPages for any object that needs
// it. A class that needs this interface need only pass an array of its
// property page CLSIDs to the CSnapInAutomationObject constructor.
//
//=--------------------------------------------------------------------------=

class CSnapInAutomationObject : public CAutomationObjectWEvents,
                                public IObjectModel,
                                public ISpecifyPropertyPages,
                                public ISupportErrorInfo,
                                public CError
{
    protected:

        CSnapInAutomationObject(IUnknown     *punkOuter,
                                int           nObjectType,
                                void         *piMainInterface,
                                void         *pThis,
                                ULONG         cPropertyPages,
                                const GUID  **rgpPropertyPageCLSIDs,
                                CPersistence *pPersistence);

        ~CSnapInAutomationObject();

        DECLARE_STANDARD_SUPPORTERRORINFO();

        // Property get/set helpers

        // Get/set BSTR
        
        HRESULT SetBstr(BSTR bstrNew, BSTR *pbstrProperty, DISPID dispid);

        HRESULT GetBstr(BSTR *pbstrOut, BSTR bstrProperty);

        // Get/set VARIANT

        HRESULT SetVariant(VARIANT varNew, VARIANT *pvarProperty, DISPID dispid);

        HRESULT GetVariant(VARIANT *pvarOut, VARIANT varProperty);

        // Get set simple types - C types and enumerations

        template <class SimpleType> HRESULT GetSimpleType(SimpleType *pOut,
                                                          SimpleType  Property)
        {
            *pOut = Property;
            return S_OK;
        }

        template <class SimpleType> HRESULT SetSimpleType(SimpleType  NewValue,
                                                          SimpleType *pProperty,
                                                          DISPID      dispid)
        {
            HRESULT    hr = S_OK;
            SimpleType OldValue = *pProperty;

            // We keep a copy of the old value in case the change notification
            // fails. See PropertyChanged() in siautobj.cpp for how that works.
            
            *pProperty = NewValue;
            H_IfFailGo(PropertyChanged(dispid));

        Error:
            if (FAILED(hr))
            {
                *pProperty = OldValue;
            }
            H_RRETURN(hr);
        }

        // Get/set interface pointers

        template <class IObjectInterface>
        HRESULT SetObject(IObjectInterface  *piInterface,
                          REFIID             iidInterface,
                          IObjectInterface **ppiInterface,
                          DISPID             dispid)
        {
            HRESULT           hr = S_OK;
            IObjectInterface *piRequestedInterface = NULL;
            IObjectInterface *piOldValue = *ppiInterface;

            // If the new value is non-NULL then QI it to be sure it supports
            // the specified interface.

            if (NULL != piInterface)
            {
                hr = piInterface->QueryInterface(iidInterface,
                               reinterpret_cast<void **>(&piRequestedInterface));
                H_IfFalseRet(SUCCEEDED(hr), SID_E_INVALIDARG);
            }

            // The new interface pointer supports the specified
            // interface and it can be used. We have stored the old value
            // of the property in case the change is not accepted. (See
            // PropertyChanged() in siautobj.cpp for how that works). Store
            // the new property value.

            *ppiInterface = piRequestedInterface;

            H_IfFailGo(PropertyChanged(dispid));

            // Change was accepted. Release the old interface pointer.

            QUICK_RELEASE(piOldValue);

        Error:
            if (FAILED(hr))
            {
                // Either the QI failed or the change was refused. Revert to
                // the old value.

                *ppiInterface = piOldValue;

                // If the QI succeeded then we need to release it.
                QUICK_RELEASE(piRequestedInterface);
            }
            H_RRETURN(hr);
        }

        template <class IObjectInterface>
        HRESULT GetObject(IObjectInterface **ppiInterface,
                          IObjectInterface  *piInterface)
        {
            if (NULL != piInterface)
            {
                piInterface->AddRef();
            }
            *ppiInterface = piInterface;
            return S_OK;
        }

        // Helpers to call IObjectModelHost methods

        // Use this method to set dirty flag, notify prop sink and notify UI
        // after property has changed.

        HRESULT PropertyChanged(DISPID dispid);

        // Use this method to notify UI that there has been a property change

        HRESULT UIUpdate(DISPID dispid);

        // Use this method to get a this pointer from an IUnknown

    public:

        // GetCxxObject: static method that returns a typed C++ this pointer
        // for the object.
        
        template <class CObject>
        static HRESULT GetCxxObject(IUnknown *punkObject, CObject **ppObject)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFailRet(punkObject->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            *ppObject = static_cast<CObject *>(piObjectModel->GetThisPointer());
            piObjectModel->Release();
            H_RRETURN(hr);
        }

        // Specializations of GetCxxObject

        static HRESULT GetCxxObject(IDataObject *piDataObject, CMMCDataObject **ppMMCDataObject);
        static HRESULT GetCxxObject(IMMCDataObject *piDataObject, CMMCDataObject **ppMMCDataObject);

    protected:

        // You must override this method to pass IObjectModel::SetHost
        // to contained objects.

        virtual HRESULT OnSetHost();

        // Use this method to pass SetHost notification to contained objects

        template <class IObjectInterface>
        HRESULT SetObjectHost(IObjectInterface *piInterface)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFalseRet(NULL != piInterface, S_OK);

            H_IfFailRet(piInterface->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            hr = piObjectModel->SetHost(m_piObjectModelHost);
            piObjectModel->Release();
            H_RRETURN(hr);
        }

        // Use this method to ask contained objects to release the host

        template <class IObjectInterface>
        HRESULT RemoveObjectHost(IObjectInterface *piInterface)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFalseRet(NULL != piInterface, S_OK);

            H_IfFailRet(piInterface->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            hr = piObjectModel->SetHost(NULL);
            piObjectModel->Release();
            H_RRETURN(hr);
        }

        // Use this method to get a non-AddRef()ed pointer to the host
        IObjectModelHost *GetHost() { return m_piObjectModelHost; }

        // Use this method in collections to notify the object model host of an
        // addition
        
        template <class IObjectInterface>
        HRESULT NotifyAdd(IObjectInterface *piInterface)
        {
            IUnknown *punkObject = NULL;
            HRESULT   hr = S_OK;

            H_IfFalseRet(NULL != m_piObjectModelHost, S_OK);
            H_IfFailRet(piInterface->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&punkObject)));
            hr = m_piObjectModelHost->Add(m_Cookie, punkObject);
            punkObject->Release();
            H_RRETURN(hr);
        }


        // Use this method in collections to notify the object model host of a
        // deletion

        template <class IObjectInterface>
        HRESULT NotifyDelete(IObjectInterface *piInterface)
        {
            HRESULT       hr = S_OK;
            IUnknown     *punkObject = NULL;
            IObjectModel *piObjectModel = NULL;
            long          Cookie = 0;

            H_IfFalseRet(NULL != m_piObjectModelHost, S_OK);
            H_IfFailRet(piInterface->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&punkObject)));
            H_IfFailGo(piInterface->QueryInterface(IID_IObjectModel, reinterpret_cast<void**>(&piObjectModel)));
            H_IfFailGo(piObjectModel->GetCookie(&Cookie));
            hr = m_piObjectModelHost->Delete(Cookie, punkObject);

        Error:
            QUICK_RELEASE(punkObject);
            QUICK_RELEASE(piObjectModel);
            H_RRETURN(hr);
        }

        // Helper methods for objects with ImageList properties
        HRESULT GetImages(IMMCImageList **ppiMMCImageListOut,
                          BSTR            bstrImagesKey,
                          IMMCImageList **ppiMMCImageListProperty);
        HRESULT SetImages(IMMCImageList  *pMMCImageListIn,
                          BSTR           *pbstrImagesKey,
                          IMMCImageList **ppiMMCImageListProperty);

        // These methods retrieve master collections held by SnapInDesignerDef

    public:
        HRESULT GetToolbars(IMMCToolbars **ppiMMCToolbars);
        HRESULT GetImageLists(IMMCImageLists **ppiMMCImageLists);
        HRESULT GetImageList(BSTR bstrKey, IMMCImageList **ppiMMCImageList);
        HRESULT GetSnapInViewDefs(IViewDefs **ppiViewDefs);
        HRESULT GetViewDefs(IViewDefs **ppiViewDefs);
        HRESULT GetListViewDefs(IListViewDefs **ppiListViewDefs);
        HRESULT GetOCXViewDefs(IOCXViewDefs **ppiOCXViewDefs);
        HRESULT GetURLViewDefs(IURLViewDefs **ppiURLViewDefs);
        HRESULT GetTaskpadViewDefs(ITaskpadViewDefs **ppiTaskpadViewDefs);
        HRESULT GetProjectName(BSTR *pbstrProjectName);

        // This method returns the runtime/designtime indicator from the
        // object model host

        HRESULT GetAtRuntime(BOOL *pfRuntime);

        // This method returns the DISPID set by IObjectModel::SetDISPID()

        DISPID GetDispid() { return m_DISPID; }

        // This method persists the DISPID

    protected:
        HRESULT PersistDISPID();

        // This method is used in collection persistence to determine
        // whether to serialize the whole object or just the key

        BOOL KeysOnly() { return m_fKeysOnly; }

        // This method allows an object to set its on KeysOnly
        
        void SetKeysOnly(BOOL fKeysOnly) { m_fKeysOnly = fKeysOnly; }

        // Override this method to set KeysOnly on contained objects. It is
        // called when an object as asked to serialize keys only. Call
        // UseKeysOnly() to pass on the request to contained objects.

        virtual HRESULT OnKeysOnly() { return S_OK; }

        // Use this method to tell a contained collection to serialize keys only

        template <class ICollectionObject>
        HRESULT UseKeysOnly(ICollectionObject *piCollectionObject)
        {
            IObjectModel *piObjectModel = NULL;
            HRESULT       hr = S_OK;

            H_IfFailGo(piCollectionObject->QueryInterface(IID_IObjectModel, reinterpret_cast<void **>(&piObjectModel)));
            hr = piObjectModel->SerializeKeysOnly(TRUE);

        Error:
            QUICK_RELEASE(piObjectModel);
            H_RRETURN(hr);
        }

    // ISpecifyPropertyPages
        STDMETHOD(GetPages(CAUUID *pPropertyPages));

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        // IObjectModel
        STDMETHOD(SetHost)(IObjectModelHost *piObjectModelHost);
        STDMETHOD(SetCookie)(long Cookie);
        STDMETHOD(GetCookie)(long *pCookie);
        STDMETHOD(IncrementUsageCount)();
        STDMETHOD(DecrementUsageCount)();
        STDMETHOD(GetUsageCount)(long *plCount);
        STDMETHOD(SetDISPID)(DISPID dispid);
        STDMETHOD(GetDISPID)(DISPID *pdispid);
        STDMETHOD(SerializeKeysOnly)(BOOL fKeysOnly);
        STDMETHOD_(void *, GetThisPointer)();
        STDMETHOD(GetSnapInDesignerDef)(ISnapInDesignerDef **ppiSnapInDesignerDef);
        
        long              m_Cookie;                 // IObjectModel cookie
        BOOL              m_fKeysOnly;              // TRUE=collection is keys-only
        IObjectModelHost *m_piObjectModelHost;      // ptr to object model host
        const GUID      **m_rgpPropertyPageCLSIDs;  // CLSID for ISpecifyPropertyPage
        ULONG             m_cPropertyPages;         // # of property pages
        DISPID            m_DISPID;                 // DISPID of object
        void             *m_pThis;                  // outermost class' this pointer

        long              m_lUsageCount; // Determines how many collections
                                         // the object belongs to. For
                                         // objects not in a collection may
                                         // be used for any reference counting
                                         // purpose that is separate from the
                                         // object's COM ref count.
                

        // Persistence stuff - needed to set dirty flag after property set
        CPersistence *m_pPersistence;
        void SetDirty();

        // Initialization
        void InitMemberVariables();

};

#endif // _SIAUTOBJ_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sidesdef.h ===
//=--------------------------------------------------------------------------=
// sidesdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDesignerDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPINDESIGNERDEF_DEFINED_
#define _SNAPINDESIGNERDEF_DEFINED_


class CSnapInDesignerDef : public CSnapInAutomationObject,
                           public CPersistence,
                           public ISnapInDesignerDef
{
    private:
        CSnapInDesignerDef(IUnknown *punkOuter);
        ~CSnapInDesignerDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISnapInDesignerDef

        OBJECT_PROPERTY_RO(CSnapInDesignerDef, SnapInDef,       ISnapInDef,     DISPID_SNAPINDESIGNERDEF_SNAPINDEF);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, ExtensionDefs,   IExtensionDefs, DISPID_SNAPINDESIGNERDEF_EXTENSIONDEFS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, AutoCreateNodes, IScopeItemDefs, DISPID_SNAPINDESIGNERDEF_AUTOCREATE_NODES);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, OtherNodes,      IScopeItemDefs, DISPID_SNAPINDESIGNERDEF_OTHER_NODES);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, ImageLists,      IMMCImageLists, DISPID_SNAPINDESIGNERDEF_IMAGELISTS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, Menus,           IMMCMenus,      DISPID_SNAPINDESIGNERDEF_MENUS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, Toolbars,        IMMCToolbars,   DISPID_SNAPINDESIGNERDEF_TOOLBARS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, ViewDefs,        IViewDefs,      DISPID_SNAPINDESIGNERDEF_VIEWDEFS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, DataFormats,     IDataFormats,   DISPID_SNAPINDESIGNERDEF_DATA_FORMATS);
        OBJECT_PROPERTY_RO(CSnapInDesignerDef, RegInfo,         IRegInfo,       DISPID_SNAPINDESIGNERDEF_REGINFO);
        SIMPLE_PROPERTY_RW(CSnapInDesignerDef, TypeinfoCookie,  long,           DISPID_SNAPINDESIGNERDEF_TYPEINFO_COOKIE);
        BSTR_PROPERTY_RW(CSnapInDesignerDef,   ProjectName,                     DISPID_SNAPINDESIGNERDEF_PROJECTNAME);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();
        
    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SnapInDesignerDef,           // name
                                &CLSID_SnapInDesignerDef,    // clsid
                                "SnapInDesignerDef",         // objname
                                "SnapInDesignerDef",         // lblname
                                &CSnapInDesignerDef::Create, // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_ISnapInDesignerDef,     // dispatch IID
                                NULL,                        // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _SNAPINDESIGNERDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sidesdef.cpp ===
//=--------------------------------------------------------------------------=
// sidesdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDesignerDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "sidesdef.h"
#include "menus.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInDesignerDef::CSnapInDesignerDef(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SNAPINDESIGNERDEF,
                           static_cast<ISnapInDesignerDef *>(this),
                           static_cast<CSnapInDesignerDef *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_SnapInDesignerDef,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CSnapInDesignerDef::~CSnapInDesignerDef()
{
    RELEASE(m_piSnapInDef);
    RELEASE(m_piExtensionDefs);
    RELEASE(m_piAutoCreateNodes);
    RELEASE(m_piOtherNodes);
    RELEASE(m_piImageLists);
    RELEASE(m_piMenus);
    RELEASE(m_piToolbars);
    RELEASE(m_piViewDefs);
    RELEASE(m_piDataFormats);
    RELEASE(m_piRegInfo);
    FREESTRING(m_bstrProjectName);
    InitMemberVariables();
}

void CSnapInDesignerDef::InitMemberVariables()
{
    m_piSnapInDef = NULL;
    m_piExtensionDefs = NULL;
    m_piAutoCreateNodes = NULL;
    m_piOtherNodes = NULL;
    m_piImageLists = NULL;
    m_piMenus = NULL;
    m_piToolbars = NULL;
    m_piViewDefs = NULL;
    m_piDataFormats = NULL;
    m_piRegInfo = NULL;
    m_TypeinfoCookie = 0;
    m_bstrProjectName = NULL;
}

IUnknown *CSnapInDesignerDef::Create(IUnknown * punkOuter)
{
    HRESULT hr = S_OK;

    CSnapInDesignerDef *pSnapInDesignerDef = New CSnapInDesignerDef(punkOuter);
    if (NULL == pSnapInDesignerDef)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // The RegInfo object is not serialized so need to create it now

    IfFailGo(CreateObject(OBJECT_TYPE_REGINFO,
                          IID_IRegInfo,
                          &pSnapInDesignerDef->m_piRegInfo));

Error:
    if (FAILEDHR(hr))
    {
        if (NULL != pSnapInDesignerDef)
        {
            delete pSnapInDesignerDef;
        }
        return NULL;
    }
    else
    {
        return pSnapInDesignerDef->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDesignerDef::Persist()
{
    HRESULT       hr = S_OK;
    IMMCMenuDefs *piMMCMenuDefs = NULL;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistObject(&m_piImageLists, CLSID_MMCImageLists,
                            OBJECT_TYPE_MMCIMAGELISTS, IID_IMMCImageLists,
                            OLESTR("ImageLists")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 8) )
    {
        // Project was created prior to menu object model change. Load it
        // and convert it to an MMCMenus collection.

        IfFailGo(PersistObject(&piMMCMenuDefs, CLSID_MMCMenuDefs,
                                OBJECT_TYPE_MMCMENUDEFS, IID_IMMCMenuDefs,
                                OLESTR("Menus")));
        RELEASE(m_piMenus);
        IfFailGo(CreateObject(OBJECT_TYPE_MMCMENUS, IID_IMMCMenus, &m_piMenus));
        IfFailGo(CMMCMenus::Convert(piMMCMenuDefs, m_piMenus));
    }
    else
    {
        IfFailGo(PersistObject(&m_piMenus, CLSID_MMCMenus,
                                OBJECT_TYPE_MMCMENUS, IID_IMMCMenus,
                                OLESTR("Menus")));
    }

    IfFailGo(PersistObject(&m_piToolbars, CLSID_MMCToolbars,
                            OBJECT_TYPE_MMCTOOLBARS, IID_IMMCToolbars,
                            OLESTR("Toolbars")));

    IfFailGo(PersistObject(&m_piViewDefs, CLSID_ViewDefs,
                            OBJECT_TYPE_VIEWDEFS, IID_IViewDefs,
                            OLESTR("ViewDefs")));

    IfFailGo(PersistObject(&m_piDataFormats, CLSID_DataFormats,
                            OBJECT_TYPE_DATAFORMATS, IID_IDataFormats,
                            OLESTR("DataFormats")));

    // Now persist nodes and extensions

    IfFailGo(PersistObject(&m_piSnapInDef, CLSID_SnapInDef,
                            OBJECT_TYPE_SNAPINDEF, IID_ISnapInDef,
                            OLESTR("SnapInDef")));

    IfFailGo(PersistObject(&m_piExtensionDefs, CLSID_ExtensionDefs,
                            OBJECT_TYPE_EXTENSIONDEFS, IID_IExtensionDefs,
                            OLESTR("ExtensionDefs")));

    IfFailGo(PersistObject(&m_piAutoCreateNodes, CLSID_ScopeItemDefs,
                            OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                            OLESTR("AutoCreateNodes")));

    IfFailGo(PersistObject(&m_piOtherNodes, CLSID_ScopeItemDefs,
                            OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                            OLESTR("OtherNodes")));

    IfFailGo(PersistSimpleType(&m_TypeinfoCookie, 0L, OLESTR("TypeinfoCookie")));

    IfFailGo(PersistBstr(&m_bstrProjectName, L"", OLESTR("ProjectName")));

    // Note: we do not serialize registation info because it is regenerated
    // every time VB calls IDesignerRegistration::GetRegistrationInfo()

Error:
    QUICK_RELEASE(piMMCMenuDefs);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDesignerDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ISnapInDesignerDef == riid)
    {
        *ppvObjOut = static_cast<ISnapInDesignerDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDesignerDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piSnapInDef));

    IfFailRet(SetObjectHost(m_piExtensionDefs));

    IfFailRet(SetObjectHost(m_piAutoCreateNodes));

    IfFailRet(SetObjectHost(m_piOtherNodes));

    IfFailRet(SetObjectHost(m_piImageLists));

    IfFailRet(SetObjectHost(m_piMenus));

    IfFailRet(SetObjectHost(m_piToolbars));

    IfFailRet(SetObjectHost(m_piViewDefs));

    IfFailRet(SetObjectHost(m_piDataFormats));

    IfFailRet(SetObjectHost(m_piRegInfo));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapin.cpp ===
//=--------------------------------------------------------------------------=
// snapin.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapIn class implementation
//
//=--------------------------------------------------------------------------=


// Need to define this because vb98ctls\include\debug.h has a switch that
// removes OutputDebugString calls in a release build. SnapIn.Trace needs
// to use OutputDebugString in a release build.

#define USE_OUTPUTDEBUGSTRING_IN_RETAIL

#include "pch.h"
#include "common.h"
#include <wininet.h>
#include "snapin.h"
#include "views.h"
#include "dataobj.h"
#include "view.h"
#include "scopnode.h"
#include "image.h"
#include "images.h"
#include "imglists.h"
#include "imglist.h"
#include "toolbars.h"
#include "toolbar.h"
#include "menu.h"
#include "menus.h"
#include "ctlbar.h"
#include "enumtask.h"
#include "clipbord.h"
#include "scitdefs.h"
#include "scitdef.h"
#include "lvdefs.h"
#include "lvdef.h"
#include "sidesdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

// Event parameter definitions
   
EVENTINFO CSnapIn::m_eiLoad =
{
    DISPID_SNAPIN_EVENT_LOAD,
    0,
    NULL
};

EVENTINFO CSnapIn::m_eiUnload =
{
    DISPID_SNAPIN_EVENT_UNLOAD,
    0,
    NULL
};


EVENTINFO CSnapIn::m_eiHelp =
{
    DISPID_SNAPIN_EVENT_HELP,
    0,
    NULL
};

VARTYPE CSnapIn::m_rgvtQueryConfigurationWizard[1] =
{
    VT_BYREF | VT_BOOL
};

EVENTINFO CSnapIn::m_eiQueryConfigurationWizard =
{
    DISPID_SNAPIN_EVENT_QUERY_CONFIGURATION_WIZARD,
    sizeof(m_rgvtQueryConfigurationWizard) / sizeof(m_rgvtQueryConfigurationWizard[0]),
    m_rgvtQueryConfigurationWizard
};


VARTYPE CSnapIn::m_rgvtCreateConfigurationWizard[1] =
{
    VT_UNKNOWN
};

EVENTINFO CSnapIn::m_eiCreateConfigurationWizard =
{
    DISPID_SNAPIN_EVENT_CREATE_CONFIGURATION_WIZARD,
    sizeof(m_rgvtCreateConfigurationWizard) / sizeof(m_rgvtCreateConfigurationWizard[0]),
    m_rgvtCreateConfigurationWizard
};



VARTYPE CSnapIn::m_rgvtConfigurationComplete[1] =
{
    VT_DISPATCH
};

EVENTINFO CSnapIn::m_eiConfigurationComplete =
{
    DISPID_SNAPIN_EVENT_CONFIGURATION_COMPLETE,
    sizeof(m_rgvtConfigurationComplete) / sizeof(m_rgvtConfigurationComplete[0]),
    m_rgvtConfigurationComplete
};


VARTYPE CSnapIn::m_rgvtWriteProperties[1] =
{
    VT_DISPATCH
};

EVENTINFO CSnapIn::m_eiWriteProperties =
{
    DISPID_SNAPIN_EVENT_WRITE_PROPERTIES,
    sizeof(m_rgvtWriteProperties) / sizeof(m_rgvtWriteProperties[0]),
    m_rgvtWriteProperties
};


VARTYPE CSnapIn::m_rgvtReadProperties[1] =
{
    VT_DISPATCH
};

EVENTINFO CSnapIn::m_eiReadProperties =
{
    DISPID_SNAPIN_EVENT_READ_PROPERTIES,
    sizeof(m_rgvtReadProperties) / sizeof(m_rgvtReadProperties[0]),
    m_rgvtReadProperties
};


EVENTINFO CSnapIn::m_eiPreload =
{
    DISPID_SNAPIN_EVENT_PRELOAD,
    0,
    NULL
};


// UNDONE: need to support GetIDsOfNames for dynamic properties in case
// VB code passes Me to another object as Object. In that case static properties
// would work but accessing a dynamic would give "object doesn't support that
// property or method".

#pragma warning(disable:4355)  // using 'this' in constructor

//=--------------------------------------------------------------------------=
// CSnapIn constructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkOuter [in] Outer unknown for aggregation
//
// Output:
//    None
//
// Notes:
//
CSnapIn::CSnapIn(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SNAPIN,
                           static_cast<ISnapIn *>(this),
                           static_cast<CSnapIn *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CSnapIn destructor
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    None
//
// Notes:
//
// Free all strings, release all interfaces
//
CSnapIn::~CSnapIn()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    FREESTRING(m_bstrHelpFile);
    FREESTRING(m_bstrLinkedTopics);
    FREESTRING(m_bstrDescription);
    FREESTRING(m_bstrProvider);
    FREESTRING(m_bstrVersion);
    RELEASE(m_piSmallFolders);
    RELEASE(m_piSmallFoldersOpen);
    RELEASE(m_piLargeFolders);
    RELEASE(m_piIcon);
    RELEASE(m_piWatermark);
    RELEASE(m_piHeader);
    RELEASE(m_piPalette);
    (void)::VariantClear(&m_varStaticFolder);
    RELEASE(m_piScopeItems);
    RELEASE(m_piViews);
    RELEASE(m_piExtensionSnapIn);
    RELEASE(m_piScopePaneItems);
    RELEASE(m_piResultViews);
    RELEASE(m_piRequiredExtensions);
    RELEASE(m_piSnapInDesignerDef);
    RELEASE(m_piSnapInDef);
    RELEASE(m_piOleClientSite);
    RELEASE(m_piMMCStringTable);

    if (NULL != m_pControlbar)
    {
        m_pControlbar->Release();
    }

    if (NULL != m_pContextMenu)
    {
        m_pContextMenu->Release();
    }

    if (NULL != m_pwszMMCEXEPath)
    {
        CtlFree(m_pwszMMCEXEPath);
    }

    if (NULL != m_pwszSnapInPath)
    {
        CtlFree(m_pwszSnapInPath);
    }
    if (NULL != m_pszMMCCommandLine)
    {
        CtlFree(m_pszMMCCommandLine);
    }
    ReleaseConsoleInterfaces();
    InitMemberVariables();
}

//=--------------------------------------------------------------------------=
// CSnapIn::ReleaseConsoleInterfaces
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    None
//
// Notes:
//
// Release all MMC interface pointers
//
void CSnapIn::ReleaseConsoleInterfaces()
{
    RELEASE(m_piConsole2);
    RELEASE(m_piConsoleNameSpace2);
    RELEASE(m_piImageList);
    RELEASE(m_piDisplayHelp);
    RELEASE(m_piStringTable);
}


//=--------------------------------------------------------------------------=
// CSnapIn::InitMemberVariables
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    None
//
// Notes:
//
//
void CSnapIn::InitMemberVariables()
{
    m_bstrName = NULL;
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;
    m_Type = siStandAlone;
    m_bstrHelpFile = NULL;
    m_bstrLinkedTopics = NULL;
    m_bstrDescription = NULL;
    m_bstrProvider = NULL;
    m_bstrVersion = NULL;
    m_piSmallFolders = NULL;
    m_piSmallFoldersOpen = NULL;
    m_piLargeFolders = NULL;
    m_piIcon = NULL;
    m_piWatermark = NULL;
    m_piHeader = NULL;
    m_piPalette = NULL;
    m_StretchWatermark = VARIANT_FALSE;
    ::VariantInit(&m_varStaticFolder);

    m_piScopeItems = NULL;
    m_piViews = NULL;
    m_piExtensionSnapIn = NULL;
    m_piScopePaneItems = NULL;
    m_piResultViews = NULL;
    m_RuntimeMode = siRTUnknown;
    m_piRequiredExtensions = NULL;
    m_Preload = VARIANT_FALSE;
    m_piSnapInDesignerDef = NULL;
    m_piSnapInDef = NULL;
    m_piOleClientSite = NULL;
    m_pScopeItems = NULL;
    m_pStaticNodeScopeItem = NULL;
    m_pExtensionSnapIn = NULL;
    m_pViews = NULL;
    m_pCurrentView = NULL;
    m_pScopePaneItems = NULL;
    m_pResultViews = NULL;
    m_piConsole2 = NULL;
    m_piConsoleNameSpace2 = NULL;
    m_piImageList = NULL;
    m_piDisplayHelp = NULL;
    m_piStringTable = NULL;
    m_hsiRootNode = NULL;
    m_fHaveStaticNodeHandle = FALSE;
    m_dwTypeinfoCookie = 0;
    m_cImages = 0;
    m_IID = IID_NULL;
    m_pControlbar = NULL;
    m_pContextMenu = NULL;
    m_fWeAreRemote = FALSE;
    ::ZeroMemory(m_szMMCEXEPath, sizeof(m_szMMCEXEPath));
    m_pwszMMCEXEPath = NULL;
    m_pwszSnapInPath = NULL;
    m_cbSnapInPath = 0;
    m_dwInstanceID = ::GetTickCount();
    m_iNextExtension = 0;
    m_piMMCStringTable = NULL;
    m_pControlbarCurrent = NULL;
    m_pszMMCCommandLine = NULL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Create
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkOuter [in] Outer unknown for aggregation
//
// Output:
//    IUnknown * on newly created CSnapIn object
//
// Notes:
//
// Called by the framework when the VB runtime CoCreates a snap-in. Creates
// a CSnapIn object and then all contained objects. Registers MMC clipformats.
//
IUnknown *CSnapIn::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkSnapIn = NULL;
    IUnknown *punk = NULL;

    CSnapIn *pSnapIn = New CSnapIn(punkOuter);

    IfFalseGo(NULL != pSnapIn, SID_E_OUTOFMEMORY);
    punkSnapIn = pSnapIn->PrivateUnknown();

    // Create contained objects
    punk = CViews::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IViews,
                               reinterpret_cast<void **>(&pSnapIn->m_piViews)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pViews));
    RELEASE(punk);

    punk = CScopeItems::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IScopeItems,
                          reinterpret_cast<void **>(&pSnapIn->m_piScopeItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pScopeItems));
    pSnapIn->m_pScopeItems->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CScopePaneItems::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IScopePaneItems,
                      reinterpret_cast<void **>(&pSnapIn->m_piScopePaneItems)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pScopePaneItems));
    pSnapIn->m_pScopePaneItems->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CResultViews::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IResultViews,
                                  reinterpret_cast<void **>(&pSnapIn->m_piResultViews)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pResultViews));
    pSnapIn->m_pResultViews->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CExtensionSnapIn::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(punk->QueryInterface(IID_IExtensionSnapIn,
                                  reinterpret_cast<void **>(&pSnapIn->m_piExtensionSnapIn)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pExtensionSnapIn));
    pSnapIn->m_pExtensionSnapIn->SetSnapIn(pSnapIn);
    RELEASE(punk);

    punk = CControlbar::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pControlbar));
    pSnapIn->m_pControlbar->SetSnapIn(pSnapIn);
    punk = NULL;

    punk = CContextMenu::Create(NULL);
    IfFalseGo(NULL != punk, SID_E_OUTOFMEMORY);
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punk, &pSnapIn->m_pContextMenu));
    pSnapIn->m_pContextMenu->SetSnapIn(pSnapIn);
    punk = NULL;

    // Make sure we have all clipboard formats so that all code can use them
    // freely without having to check if registration succeded.

    IfFailGo(CMMCDataObject::RegisterClipboardFormats());

Error:
    QUICK_RELEASE(punk);
    if (FAILED(hr))
    {
        RELEASE(punkSnapIn);
    }
    return punkSnapIn;
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetObjectModelHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkObject [in] Object on which to set object model host
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CSnapIn::SetObjectModelHost(IUnknown *punkObject)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    IfFailGo(punkObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));

    IfFailGo(piObjectModel->SetHost(static_cast<IObjectModelHost *>(this)));

Error:
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetObjectModelHostIfNotSet
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkObject [in] Object on which to set object model host
//    BOOL     *pfWasSet   [out] Returns flag indicating if object model host
//                               was already set
//
// Output:
//    HRESULT
//
// Notes:
//
// Checks whether the object already has the objet mode host, and if not then
// sets it.
//
HRESULT CSnapIn::SetObjectModelHostIfNotSet(IUnknown *punkObject, BOOL *pfWasSet)
{
    HRESULT             hr = S_OK;
    IObjectModel       *piObjectModel = NULL;
    ISnapInDesignerDef *piSnapInDesignerDef = NULL;

    *pfWasSet = FALSE;

    IfFailGo(punkObject->QueryInterface(IID_IObjectModel,
                                    reinterpret_cast<void **>(&piObjectModel)));

    if (SUCCEEDED(piObjectModel->GetSnapInDesignerDef(&piSnapInDesignerDef)))
    {
        *pfWasSet = TRUE;
    }
    else
    {
        IfFailGo(piObjectModel->SetHost(static_cast<IObjectModelHost *>(this)));
    }

Error:
    QUICK_RELEASE(piObjectModel);
    QUICK_RELEASE(piSnapInDesignerDef);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::RemoveObjectModelHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    IUnknown *punkObject [in] Object on which to remove object model host
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CSnapIn::RemoveObjectModelHost(IUnknown *punkObject)
{
    HRESULT       hr = S_OK;
    IObjectModel *piObjectModel = NULL;

    IfFailGo(punkObject->QueryInterface(IID_IObjectModel,
                                        reinterpret_cast<void **>(&piObjectModel)));

    IfFailGo(piObjectModel->SetHost(NULL));

Error:
    QUICK_RELEASE(piObjectModel);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetSnapInPropertiesFromState
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
//
// Sets snap-in properties from design time state
//
HRESULT CSnapIn::SetSnapInPropertiesFromState()
{
    HRESULT       hr = S_OK;
    unsigned long ulTICookie = 0;
    BSTR          bstrIID = NULL;

    IfFailGo(m_piSnapInDef->get_Name(&m_bstrName));
    IfFailGo(m_piSnapInDef->get_NodeTypeName(&m_bstrNodeTypeName));
    IfFailGo(m_piSnapInDef->get_NodeTypeGUID(&m_bstrNodeTypeGUID));
    IfFailGo(m_piSnapInDef->get_DisplayName(&m_bstrDisplayName));
    IfFailGo(m_piSnapInDef->get_Type(&m_Type));
    IfFailGo(m_piSnapInDef->get_HelpFile(&m_bstrHelpFile));
    IfFailGo(m_piSnapInDef->get_LinkedTopics(&m_bstrLinkedTopics));
    IfFailGo(m_piSnapInDef->get_Description(&m_bstrDescription));
    IfFailGo(m_piSnapInDef->get_Provider(&m_bstrProvider));
    IfFailGo(m_piSnapInDef->get_Version(&m_bstrVersion));

    IfFailGo(m_piSnapInDef->get_SmallFolders(&m_piSmallFolders));
    IfFailGo(m_piSnapInDef->get_SmallFoldersOpen(&m_piSmallFoldersOpen));
    IfFailGo(m_piSnapInDef->get_LargeFolders(&m_piLargeFolders));

    IfFailGo(m_piSnapInDef->get_Icon(&m_piIcon));
    IfFailGo(m_piSnapInDef->get_Watermark(&m_piWatermark));
    IfFailGo(m_piSnapInDef->get_Header(&m_piHeader));
    IfFailGo(m_piSnapInDef->get_Palette(&m_piPalette));
    IfFailGo(m_piSnapInDef->get_StretchWatermark(&m_StretchWatermark));
    IfFailGo(m_piSnapInDef->get_StaticFolder(&m_varStaticFolder));
    IfFailGo(m_piSnapInDef->get_Preload(&m_Preload));

    // Set the typeinfo cookie from the saved value. Don't read from long
    // property directly into a DWORD so as to avoid size assumptions.
    // If there is a size problem then the static cast will fail compilation.

    IfFailGo(m_piSnapInDesignerDef->get_TypeinfoCookie(reinterpret_cast<long *>(&ulTICookie)));
    m_dwTypeinfoCookie = static_cast<DWORD>(ulTICookie);

    // Get the dynamic IID created in the snap-in's type info.

    IfFailGo(m_piSnapInDef->get_IID(&bstrIID));
    hr = ::CLSIDFromString(bstrIID, static_cast<LPCLSID>(&m_IID));
    EXCEPTION_CHECK_GO(hr);

Error:
    FREESTRING(bstrIID);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapInPath
//=--------------------------------------------------------------------------=
//
// Parameters:
//    OLECHAR **ppwszPath     [out] ptr to full path of snap-in DLL. Caller
//                                  should not free this memory
//    size_t   *pcbSnapInPath [out] length of path in bytes, without terminating
//                                  NULL character
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CSnapIn::GetSnapInPath
(
    OLECHAR **ppwszPath,
    size_t   *pcbSnapInPath
)
{
    HRESULT  hr = S_OK;
    size_t   cbClsid = 0;
    char     szKeySuffix[256] = "";
    char     szPath[MAX_PATH] = "";
    DWORD    cbPath = sizeof(szPath);
    char    *pszKeyName = NULL;
    long     lRc = ERROR_SUCCESS;
    HKEY     hkey = NULL;

    static char   szClsidKey[] = "CLSID\\";
    static size_t cbClsidKey = sizeof(szClsidKey) - 1;

    static char   szInProcServer32[] = "\\InProcServer32";
    static size_t cbInProcServer32 = sizeof(szInProcServer32);

    // If we already got the snap-in path then just return it

    IfFalseGo(NULL == m_pwszSnapInPath, S_OK);

    // Get the snap-in's CLSID

    IfFailGo(::GetSnapInCLSID(m_bstrNodeTypeGUID,
                              szKeySuffix,
                              sizeof(szKeySuffix)));

    // Append "\InProcServer32". First ensure that there is enough room.

    cbClsid = ::strlen(szKeySuffix);

    if ( (cbClsid + cbInProcServer32) > sizeof(szKeySuffix) )
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    // Append it and then create the complete key name.
    
    ::memcpy(&szKeySuffix[cbClsid], szInProcServer32, cbInProcServer32);

    // Open HKEY_CLASSES_ROOT\CLSID\<snap-in clsid>\InProcServer32 and read its
    // default value which contains the full path to the snap-in.

    IfFailGo(::CreateKeyName(szClsidKey, cbClsidKey,
                             szKeySuffix, ::strlen(szKeySuffix),
                             &pszKeyName));

    lRc = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, pszKeyName, 0, KEY_QUERY_VALUE, &hkey);
    if (ERROR_SUCCESS == lRc)
    {
        // Read the key's default value
        lRc = ::RegQueryValueEx(hkey, NULL, NULL, NULL,
                                (LPBYTE)szPath, &cbPath);
    }
    if (ERROR_SUCCESS != lRc)
    {
        hr = HRESULT_FROM_WIN32(lRc);
        EXCEPTION_CHECK_GO(hr);
    }
    else if (0 == ::strlen(szPath))
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::WideStrFromANSI(szPath, &m_pwszSnapInPath));
    m_cbSnapInPath = ::wcslen(m_pwszSnapInPath) * sizeof(OLECHAR);

Error:
    if (NULL != pszKeyName)
    {
        ::CtlFree(pszKeyName);
    }
    if (NULL != hkey)
    {
        (void)::RegCloseKey(hkey);
    }
    *ppwszPath = m_pwszSnapInPath;
    *pcbSnapInPath = m_cbSnapInPath;
    RRETURN(hr);
}






//=--------------------------------------------------------------------------=
// CSnapIn::ResolveResURL
//=--------------------------------------------------------------------------=
//
// Parameters:
//      WCHAR    *pwszURL          [in] URL to be resolved
//      OLECHAR **ppwszResolvedURL [in] fully qualified URL
//
// Output:
//      HRESULT
//
// Notes:
//
// If the URL begins with any protocol specifier (e.g. http:// or res://) then
// it is copied as except for the special case of res://mmc.exe/. Anything that
// starts with the unqualified path to mmc.exe ("res://mmc.exe/") is resolved to
// the full path of mmc.exe in which the snap-in is running by calling
// GetModulesFileName(NULL). This is done to allow snap-ins to use resources
// supplied by MMC such as the GLYPH100 and GLYPH110 fonts. For example, the
// snap-in can specify "res://mmc.exe/glyph100.eot" and it will be resolved to
// "res://<full path>/mmc.exe/glyph100.eot".
//
// If a URL does not begin with a protocol specifier then a res:// URL is
// constructed using the complete path to the snap-in's DLL.
//
// 
// Returned URL is allocated with CoTaskMemAlloc(). Caller must free it.
//

HRESULT CSnapIn::ResolveResURL(WCHAR *pwszURL, OLECHAR **ppwszResolvedURL)
{
    HRESULT  hr = S_OK;
    char    *pszURL = NULL;
    OLECHAR *pwszResolvedURL = NULL;
    OLECHAR *pwszPath = NULL; // not allocated, no need to free
    size_t   cbPath = 0;
    size_t   cbURL = 0;
    BOOL     fUseMMCPath = FALSE;

    URL_COMPONENTS UrlComponents;
    ::ZeroMemory(&UrlComponents, sizeof(UrlComponents));

    static OLECHAR wszRes[] = L"res://";
    static size_t  cbRes = sizeof(wszRes) - sizeof(WCHAR);

    static OLECHAR wszMMCRes[] = L"res://mmc.exe/";
    static size_t  cchMMCRes = (sizeof(wszMMCRes) - sizeof(WCHAR)) / sizeof(WCHAR);

    // Check if it starts with letters followed by ://

    // Get the URL length

    cbURL = (::wcslen(pwszURL) + 1) * sizeof(WCHAR); // includes null character

    // Crack it - request only a pointer to the scheme

    UrlComponents.dwStructSize = sizeof(UrlComponents);
    UrlComponents.dwSchemeLength = static_cast<DWORD>(1);

    // Need an ANSI version of the URL.
    IfFailGo(::ANSIFromWideStr(pwszURL, &pszURL));

    if (::InternetCrackUrl(pszURL,
                            static_cast<DWORD>(::strlen(pszURL)),
                            0, // no flags
                            &UrlComponents))
    {
        if (NULL != UrlComponents.lpszScheme)
        {
            // The API found a scheme. If it is not res:// then just copy it
            // and return it unchanged.

            if (pwszURL != ::wcsstr(pwszURL, wszRes))
            {
                IfFailGo(::CoTaskMemAllocString(pwszURL, &pwszResolvedURL));
                goto Cleanup;
            }
        }
    }

    // Either there's no scheme or there is a res://. The API doesn't recognize
    // res:// when IE4 is installed so we need to check for it.

    if (cbURL > cbRes) // check > because cbURL includes null and cbRes doesn't
    {
        if (0 == ::memcmp(pwszURL, wszRes, cbRes))
        {
            // Does the URL start with "res://mmc.exe/"?
            if (pwszURL == ::wcsstr(pwszURL, wszMMCRes))
            {
                fUseMMCPath = TRUE;
                pwszURL += cchMMCRes;
            }
            else
            {
                // It starts with res::// and it does not reference mmc.exe so
                // just copy it.
                IfFailGo(::CoTaskMemAllocString(pwszURL, &pwszResolvedURL));
                goto Cleanup;
            }
        }
    }

    // No scheme, assume it's a relative URL. Need to build a res:// URL.
    // First, get the path.

    if (fUseMMCPath)
    {
        IfFalseGo(NULL != m_pwszMMCEXEPath, SID_E_INTERNAL);
        pwszPath = m_pwszMMCEXEPath;
        cbPath = m_cbMMCExePathW;
    }
    else
    {
        IfFailGo(GetSnapInPath(&pwszPath, &cbPath));
    }

    // Allocate the buffer.

    pwszResolvedURL = (OLECHAR *)::CoTaskMemAlloc(cbRes +
                                                  cbPath +
                                                  sizeof(WCHAR) + // for slash
                                                  cbURL);
    if (NULL == pwszResolvedURL)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Concatenate the pieces: res://, snap-in path, slash, and relative url
    // e.g. "res://c:\MyProject\MySnapIn.dll/#2/MyMouseOverBitmap"

    ::memcpy(pwszResolvedURL, wszRes, cbRes);

    ::memcpy(((BYTE *)pwszResolvedURL) + cbRes, pwszPath, cbPath);

    *(OLECHAR *)(((BYTE *)pwszResolvedURL) + cbRes + cbPath) = L'/';
    

    // Fix for Ntbug9#141998 - Yojain
    cbURL = (::wcslen(pwszURL) + 1) * sizeof(WCHAR); // includes null character


    ::memcpy(((BYTE *)pwszResolvedURL) + cbRes + cbPath + sizeof(WCHAR),
            pwszURL, cbURL);

    *ppwszResolvedURL = pwszResolvedURL;

Cleanup:
Error:
    if (FAILED(hr))
    {
        *ppwszResolvedURL = NULL;
    }
    else
    {
        *ppwszResolvedURL = pwszResolvedURL;
    }
    if (NULL != pszURL)
    {
        ::CtlFree(pszURL);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnExpand
//=--------------------------------------------------------------------------=
//
// Parameters:
//  ExpandType   Type         [in] Expand or ExpandSync
//  IDataObject *piDataObject [in] IDataObject from notification
//  BOOL         fExpanded    [in] TRUE=expanding, FALSE=collapsing
//  HSCOPEITEM   hsi          [in] HSCOPEITEM of node
//  BOOL        *pfHandled    [out] flag returned here indicating if event was
//                                  handled
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_EXPAND and MMCN_EXPANDSYNC handler for IComponentData::Notify
//

HRESULT CSnapIn::OnExpand
(
    ExpandType   Type,
    IDataObject *piDataObject,
    BOOL         fExpanded,
    HSCOPEITEM   hsi,
    BOOL        *pfHandled
)
{
    HRESULT          hr = S_OK;
    CMMCDataObject  *pMMCDataObject  = NULL;
    IMMCDataObjects *piMMCDataObjects  = NULL;
    IMMCDataObject  *piMMCDataObject  = NULL;
    CScopeItem      *pScopeItem = NULL;
    IScopeNode      *piScopeNode = NULL;
    CScopeNode      *pScopeNode = NULL;
    IScopeItemDefs  *piScopeItemDefs = NULL;
    IMMCClipboard   *piMMCClipboard = NULL;
    IScopeNode      *piScopeNodeFirstChild = NULL;
    BOOL             fNotFromThisSnapIn = FALSE;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    FORMATETC FmtEtc;
    ::ZeroMemory(&FmtEtc, sizeof(FmtEtc));

    STGMEDIUM StgMed;
    ::ZeroMemory(&StgMed, sizeof(StgMed));


    SnapInSelectionTypeConstants SelectionType = siEmpty;

    // Determine who owns the data object. Easiest way is to create an
    // MMCClipboard object with the selection as that code figures out all that
    // stuff.

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, this,
                               &SelectionType));


    // Handle the extension case first as it is simpler

    if (IsForeign(SelectionType))
    {
        // Set runtime mode as we now know that the snap-in was created as a
        // namespace extension.

        m_RuntimeMode = siRTExtension;
        
        // Get the 1st data object from MMCClipboard.DataObjects

        IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;
        IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

        // Create a ScopeNode object for the expandee

        IfFailGo(CScopeNode::GetScopeNode(hsi, piDataObject, this, &piScopeNode));

        // Fire ExtensionSnapIn_Expand/Sync or ExtensionSnapIn_Collapse/Sync

        if (fExpanded)
        {
            if (Expand == Type)
            {
                m_pExtensionSnapIn->FireExpand(piMMCDataObject, piScopeNode);
                *pfHandled = TRUE;
            }
            else
            {
                m_pExtensionSnapIn->FireExpandSync(piMMCDataObject, piScopeNode,
                                                   pfHandled);
            }
        }
        else
        {
            if (Expand == Type)
            {
                m_pExtensionSnapIn->FireCollapse(piMMCDataObject, piScopeNode);
                *pfHandled = TRUE;
            }
            else
            {
                m_pExtensionSnapIn->FireCollapseSync(piMMCDataObject, piScopeNode,
                                                     pfHandled);
            }
        }
        goto Cleanup;
    }

    // Its a scope item we own. Get the CMMCDataObject for it.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));
    

    if ( CMMCDataObject::ScopeItem == pMMCDataObject->GetType() ) 
    {
        pScopeItem = pMMCDataObject->GetScopeItem();
        IfFailGo(pScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));

        if (pScopeItem->IsStaticNode())
        {
            IfFailGo(StoreStaticHSI(pScopeItem, pMMCDataObject, hsi));
        }

        // If node is expanding and this is the first time then add any
        // auto-create children

        if (fExpanded)
        {
            // Check whether we have already expanded this node. This could happen
            // in the case where the snap-in did not handle MMCN_EXPANDSYNC and
            // we are coming through here a 2nd time for MMCN_EXPAND on the same
            // node. An important implication here is that the runtime always
            // expands the auto-creates on MMCN_EXPANDSYNC even if the snap-in
            // didn't handle it. Either way, the snap-in always knows that
            // auto-creates have been created before the ScopeItems_Expand or
            // ScopeItems_ExpandSync events are fired.

            // Unfortunately, at this point checking ScopeNode.ExpandedOnce won't
            // help because MMC sets that flag before sending the expand
            // notifications. We also can't check the ScopeNode.Children because
            // MMC doesn't properly support that (it would fail but it will
            // always come back as zero). The only thing left is to try getting
            // the first child of the expanding node. If it is not there then
            // assume it is the first time and add the auto-creates.

            IfFailGo(piScopeNode->get_Child(reinterpret_cast<ScopeNode **>(&piScopeNodeFirstChild)));
            if (NULL == piScopeNodeFirstChild)
            {
                if (pScopeItem->IsStaticNode())
                {
                    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs));
                }
                else
                {
                    if (NULL != pScopeItem->GetScopeItemDef())
                    {
                        IfFailGo(pScopeItem->GetScopeItemDef()->get_Children(&piScopeItemDefs));
                    }
                }
                if (NULL != piScopeItemDefs)
                {
                    IfFailGo(m_pScopeItems->AddAutoCreateChildren(piScopeItemDefs,
                                                                  pScopeItem));
                }
            }
        }

        // Fire the ScopeItems_Expand/Sync or ScopeItems_Collapse/Sync

        if (fExpanded)
        {
            if (Expand == Type)
            {
                m_pScopeItems->FireExpand(pScopeItem);
                *pfHandled = TRUE;
            }
            else
            {
                m_pScopeItems->FireExpandSync(pScopeItem, pfHandled);
            }

            // Check ScopeItem.DynamicExtensions for any that have
            // NameSpaceEnabled=True and call IConsoleNameSpace2::AddExtension
            // for them

            IfFailGo(AddDynamicNameSpaceExtensions(pScopeItem));
        }
        else
        {
            if (Expand == Type)
            {
                m_pScopeItems->FireCollapse(pScopeItem);
                *pfHandled = TRUE;
            }
            else
            {
                m_pScopeItems->FireCollapseSync(pScopeItem, pfHandled);
            }
        }
    }

Cleanup:
Error:
    QUICK_RELEASE(piScopeNode);
    QUICK_RELEASE(piScopeNodeFirstChild);
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCDataObject);
    QUICK_RELEASE(piMMCDataObjects);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::StoreStaticHSI
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CScopeItem     *pScopeItem     [in] scope item of static node
//  CMMCDataObject *pMMCDataObject [in] data object of static node
//  HSCOPEITEM      hsi            [in] HSCOPEITEM of static node
//
// Output:
//    HRESULT
//
// Notes:
// Called when the snap-in receives the HSCOPEITEM for the static node.
// See below for processing
//
HRESULT CSnapIn::StoreStaticHSI
(
    CScopeItem     *pScopeItem,
    CMMCDataObject *pMMCDataObject,
    HSCOPEITEM      hsi
)
{
    HRESULT hr = S_OK;

    // We have the static node HSCOPEITEM so we now know that the snap-in was
    // created as primary.

    m_RuntimeMode = siRTPrimary;

    // If this context is scope pane then store the static node handle
    // and set it in the scope node. Also use this opportunity to
    // add any auto-create children to the static node.

    if ( (CCT_SCOPE == pMMCDataObject->GetContext()) &&
         (!m_fHaveStaticNodeHandle) )
    {
        m_hsiRootNode = hsi;
        pScopeItem->GetScopeNode()->SetHSCOPEITEM(hsi);
        IfFailGo(pScopeItem->GiveHSCOPITEMToDynamicExtensions(hsi));
        m_fHaveStaticNodeHandle = TRUE;
    }
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnRename
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] data object of node
//  OLECHAR     *pwszNewName  [in] new name entered by user
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_RENAME handler for rename verb in scope pane (for IComponentData::Notify)
// See below for processing
//
HRESULT CSnapIn::OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject = NULL;
    BSTR            bstrNewName = NULL;
    CScopeItem     *pScopeItem = NULL;

    // If this is not our data object then ignore it (that should never be
    // the case)
    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
    IfFalseGo(SUCCEEDED(hr), S_OK);

    bstrNewName = ::SysAllocString(pwszNewName);
    if (NULL == bstrNewName)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    // The data object should definitely represent a scope item but we'll double
    // check

    if (CMMCDataObject::ScopeItem == pMMCDataObject->GetType())
    {
        pScopeItem = pMMCDataObject->GetScopeItem();
        m_pScopeItems->FireRename(static_cast<IScopeItem *>(pScopeItem),
                                  bstrNewName);
    }

Error:
    FREESTRING(bstrNewName);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnPreload
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] data object of node
//  HSCOPEITEM   hsi          [in] HSCOPEITEM of static node
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_PRELOAD handler for IComponentData::Notify
// See below for processing
//
HRESULT CSnapIn::OnPreload(IDataObject *piDataObject, HSCOPEITEM hsi)
{
    HRESULT          hr = S_OK;
    CMMCDataObject  *pMMCDataObject  = NULL;

    // The IDataObject should be for our static node so the next lines should
    // always succeed and execute

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject));

    if ( (CMMCDataObject::ScopeItem == pMMCDataObject->GetType()) &&
         pMMCDataObject->GetScopeItem()->IsStaticNode() )
    {
        IfFailGo(StoreStaticHSI(pMMCDataObject->GetScopeItem(),
                                pMMCDataObject, hsi));
    }

    // Fire SnapIn_Preload

    DebugPrintf("Firing SnapIn_Preload\r\n");

    FireEvent(&m_eiPreload);
        
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::AddDynamicNameSpaceExtensions
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CScopeItem *pScopeItem [in] Scope item for which dynamic namespace extensions
//                              need to be added
//
// Output:
//    HRESULT
//
// Notes:
// Calls IConsoleNameSpace2->AddExtension for all extensions in
// ScopeItem.DynamicExtensions that have NameSpaceEnabled=True
//
HRESULT CSnapIn::AddDynamicNameSpaceExtensions(CScopeItem *pScopeItem)
{
    HRESULT      hr = S_OK;
    IExtensions *piExtensions = NULL; // Not AddRef()ed
    CExtensions *pExtensions = NULL;
    CExtension  *pExtension = NULL;
    long         cExtensions = 0;
    long         i = 0;
    CLSID        clsid = CLSID_NULL;
    HSCOPEITEM   hsi = pScopeItem->GetScopeNode()->GetHSCOPEITEM();

    // Get ScopeItem.DynamicExtensions. If it is NULL then the user has not
    // populated it and there is nothing to do.

    piExtensions = pScopeItem->GetDynamicExtensions();
    IfFalseGo(NULL != piExtensions, S_OK);

    // If the collection is there but empty then there is still nothing to do.

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piExtensions, &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(cExtensions != 0, S_OK);

    // Iterate through the collection and check for items that have
    // NameSpaceEnabled=True. For each such item call
    // IConsoleNameSpace2::AddExtension()

    for (i = 0; i < cExtensions; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                   pExtensions->GetItemByIndex(i), &pExtension));

        if (pExtension->NameSpaceEnabled())
        {
            hr = ::CLSIDFromString(pExtension->GetCLSID(), &clsid);
            EXCEPTION_CHECK_GO(hr);

            hr = m_piConsoleNameSpace2->AddExtension(hsi, &clsid);
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::AddScopeItemImages
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//
// Output:
//    HRESULT
//
// Notes:
// 
// Adds images from SnapIn.SmallFolders, SnapIn.SmallFoldersOpen, and
// SnapIn.LargeFolders to scope pane image list.
//
// This only happens once during IComponentData::Initialize. The snap-in cannot
// dynamically add images to the scope pane image list after that time. If a
// snap-in has dynamic images, it must set them in these image lists
// SnapIn_Preload.
//
HRESULT CSnapIn::AddScopeItemImages()
{
    HRESULT     hr = S_OK;
    IMMCImages *piSmallImages = NULL;
    IMMCImages *piSmallOpenImages = NULL;
    IMMCImages *piLargeImages = NULL;
    CMMCImages *pSmallImages = NULL;
    CMMCImages *pSmallOpenImages = NULL;
    CMMCImages *pLargeImages = NULL;
    long        cImages = 0;
    HBITMAP     hbmSmall = NULL;
    HBITMAP     hbmSmallOpen = NULL;
    HBITMAP     hbmLarge = NULL;
    HBITMAP     hbmLargeOpen = NULL;
    OLE_COLOR   OleColorMask = 0;
    COLORREF    ColorRef = RGB(0x00,0x00,0x00);

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Make sure that all image lists are set

    IfFalseGo(NULL != m_piSmallFolders, S_OK);
    IfFalseGo(NULL != m_piSmallFoldersOpen, S_OK);
    IfFalseGo(NULL != m_piLargeFolders, S_OK);

    // Get their images collections

    IfFailGo(m_piSmallFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piSmallImages)));
    IfFailGo(m_piSmallFoldersOpen->get_ListImages(reinterpret_cast<MMCImages **>(&piSmallOpenImages)));
    IfFailGo(m_piLargeFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piLargeImages)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piSmallImages, &pSmallImages));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piSmallOpenImages, &pSmallOpenImages));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piLargeImages, &pLargeImages));

    // Make sure they contain images and that their counts all match
    // CONSIDER: log an error here if image counts don't match

    cImages = pSmallImages->GetCount();
    IfFalseGo(0 != cImages, S_OK);
    IfFalseGo(cImages == pSmallOpenImages->GetCount(), S_OK);
    IfFalseGo(cImages == pLargeImages->GetCount(), S_OK);
    
    // Use the mask color from SmallFolders. The other choice would have
    // been to add a mask color property to SnapIn which would have been
    // even more redundant.

    IfFailGo(m_piSmallFolders->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRef));

    // MMC requires a large open bitmap in the SetImageStrip but never actually
    // uses it. The user is not required to supply large open folders at design
    // time so we use a generic one stored in our RC.

    hbmLargeOpen = ::LoadBitmap(GetResourceHandle(),
                                MAKEINTRESOURCE(IDB_BITMAP_LARGE_OPEN_FOLDER));
    if (NULL == hbmLargeOpen)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

    varIndex.vt = VT_I4;

    // Now add the images to MMC's image list. To make life easier for the
    // VB developer, they define 3 image lists where the index is the same
    // in each one (small, small open, and large). MMC only has one image list
    // containing both small and large images so we use index + cImages for
    // the open folders. Images are added one at a time because we do not
    // want to combine all the bitmaps into a strip.

    for (varIndex.lVal = 1L; varIndex.lVal <= cImages; varIndex.lVal++)
    {
        IfFailGo(::GetPicture(piSmallImages, varIndex, PICTYPE_BITMAP,
                              reinterpret_cast<OLE_HANDLE *>(&hbmSmall)));

        IfFailGo(::GetPicture(piSmallOpenImages, varIndex, PICTYPE_BITMAP,
                              reinterpret_cast<OLE_HANDLE *>(&hbmSmallOpen)));

        IfFailGo(::GetPicture(piLargeImages, varIndex, PICTYPE_BITMAP,
                              reinterpret_cast<OLE_HANDLE *>(&hbmLarge)));

        IfFailGo(m_piImageList->ImageListSetStrip(
                                              reinterpret_cast<long*>(hbmSmall),
                                              reinterpret_cast<long*>(hbmLarge),
                                              varIndex.lVal,
                                              ColorRef));

        IfFailGo(m_piImageList->ImageListSetStrip(
                                          reinterpret_cast<long*>(hbmSmallOpen),
                                          reinterpret_cast<long*>(hbmLargeOpen),
                                          varIndex.lVal + cImages,
                                          ColorRef));
    }

    // Record the number of images so we can calculate the index when MMC asks
    // for it in IComponentData::GetDisplayInfo() (see CSnapIn::::GetDisplayInfo())

    m_cImages = cImages;

Error:
    if (NULL != hbmLargeOpen)
    {
        (void)::DeleteObject(hbmLargeOpen);
    }
    QUICK_RELEASE(piSmallImages);
    QUICK_RELEASE(piSmallOpenImages);
    QUICK_RELEASE(piLargeImages);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetScopeItemImage
//=--------------------------------------------------------------------------=
//
// Parameters:
//  VARIANT varImageIndex [in] Image index or key specified by the snap-in
//  int *pnIndex          [in] Actual index in image list
//
// Output:
//    HRESULT
//
// Notes:
// This function verifies that the specified VARIANT is a valid index or key
// for a scope item image and returns the index.
// VB pseudo code of what it does:
// *pnIndex = SnapIn.SmallFolders(varImageIndex).Index
//
// Using SnapIn.SmallFolders is arbitrary. As snap-ins must have the same
// images in all 3 image lists (SmallFolders, SmallFoldersOpen, and
// LargeFolders), any one is good enough. Techinically, we should check all
// 3 but the perf hit is not worth it.
//
HRESULT CSnapIn::GetScopeItemImage(VARIANT varImageIndex, int *pnIndex)
{
    HRESULT     hr = S_OK;
    IMMCImages *piMMCImages = NULL;
    IMMCImage  *piMMCImage = NULL;
    long        lIndex = 0;

    IfFalseGo(NULL != m_piSmallFolders, S_OK);
    IfFalseGo(VT_EMPTY != varImageIndex.vt, S_OK);
    
    IfFailGo(m_piSmallFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(piMMCImages->get_Item(varImageIndex, reinterpret_cast<MMCImage **>(&piMMCImage)));
    IfFailGo(piMMCImage->get_Index(&lIndex));
    *pnIndex = static_cast<int>(lIndex);

Error:
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetScopeItemExtensions
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CExtensions    *pExtensions     [in] Extensions collection to populate
//  IScopeItemDefs *piScopeItemDefs [in] Design time node definitions to
//                                       examine for extensibility
//
// Output:
//    HRESULT
//
// Notes:
// Iterates through the ScopeItemDefs collection and all of it children
// recursively. For each node that is extensible, Extension objects are added to
// the Extensions collection for each snap-in that extends the node type.
//
HRESULT CSnapIn::GetScopeItemExtensions
(
    CExtensions    *pExtensions,
    IScopeItemDefs *piScopeItemDefs
)
{
    HRESULT         hr = S_OK;
    CScopeItemDefs *pScopeItemDefs = NULL;
    IScopeItemDefs *piChildren = NULL;
    IScopeItemDef  *piScopeItemDef = NULL; // Not AddRef()ed
    CScopeItemDef  *pScopeItemDef = NULL;
    long            cScopeItemDefs = 0;
    long            i = 0;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDefs, &pScopeItemDefs));
    cScopeItemDefs = pScopeItemDefs->GetCount();
    IfFalseGo(0 != cScopeItemDefs, S_OK);

    // Go through the collection and get the extensions from the registry for
    // each scope item that is marked extensible.

    for (i = 0; i < cScopeItemDefs; i++)
    {
        piScopeItemDef = pScopeItemDefs->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeItemDef,
                                                       &pScopeItemDef));
       if (pScopeItemDef->Extensible())
       {
           IfFailGo(pExtensions->Populate(pScopeItemDef->GetNodeTypeGUID(),
                                          CExtensions::All));
       }

       // Do the same for the scope item's children
       IfFailGo(piScopeItemDef->get_Children(&piChildren));
       IfFailGo(GetScopeItemExtensions(pExtensions, piChildren));
       RELEASE(piChildren);
    }

    
Error:
    QUICK_RELEASE(piChildren);
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::GetListItemExtensions
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CExtensions   *pExtensions    [in] Extensions collection to populate
//  IListViewDefs *piListViewDefs [in] Design time list view definitions to
//                                       examine for extensibility
//
// Output:
//    HRESULT
//
// Notes:
// Iterates through the ListViewDefs collection.
// For each list view that is extensible, Extension objects are added to
// the Extensions collection for each snap-in that extends the node type.
//
HRESULT CSnapIn::GetListItemExtensions
(
    CExtensions   *pExtensions,
    IListViewDefs *piListViewDefs
)
{
    HRESULT        hr = S_OK;
    CListViewDefs *pListViewDefs = NULL;
    CListViewDef  *pListViewDef = NULL;
    long           cListViewDefs = 0;
    long           i = 0;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piListViewDefs, &pListViewDefs));
    cListViewDefs = pListViewDefs->GetCount();
    IfFalseGo(0 != cListViewDefs, S_OK);

    // Go through the collection and get the extensions from the registry for
    // each scope item that is marked extensible.

    for (i = 0; i < cListViewDefs; i++)
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                               pListViewDefs->GetItemByIndex(i), &pListViewDef));
        if (pListViewDef->Extensible())
        {
            IfFailGo(pExtensions->Populate(pListViewDef->GetItemTypeGUID(),
                                           CExtensions::All));
        }
    }

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
// CSnapIn::OnDelete
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] Data object for item user requested to delete
//
// Output:
//    HRESULT
//
// Notes:
// MMCN_DELETE handler for IComponentData::Notify
//
HRESULT CSnapIn::OnDelete(IDataObject *piDataObject)
{
    if (NULL != m_pCurrentView)
    {
        RRETURN(m_pCurrentView->OnDelete(piDataObject));
    }
    else
    {
        ASSERT(FALSE, "Received IComponentData::Notify(MMCN_DELETE) and there is no current view");
        return S_OK;
    }
}


//=--------------------------------------------------------------------------=
// CSnapIn::OnRemoveChildren
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] Data object for node whose children are
//                                 being removed
//  HSCOPEITEM   hsi          [in] HSCOPEITEM for node whose children are
//                                 being removed
// Output:
//    HRESULT
//
// Notes:
// MMCN_REMOVECHILDREN handler for IComponentData::Notify
//
HRESULT CSnapIn::OnRemoveChildren(IDataObject *piDataObject, HSCOPEITEM hsi)
{
    HRESULT     hr = S_OK;
    IScopeNode *piScopeNode = NULL;

    // Get a ScopeNode object for the parent

    IfFailGo(CScopeNode::GetScopeNode(hsi, piDataObject, this, &piScopeNode));

    // Fire ScopeItems_RemoveChildren

    m_pScopeItems->FireRemoveChildren(piScopeNode);
    
    // Traverse the tree and remove the ScopeItem object from our ScopeItems
    // collection for each node we own that is a descendant of the parent

    IfFailGo(m_pScopeItems->RemoveChildrenOfNode(piScopeNode));
    
Error:
    QUICK_RELEASE(piScopeNode);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::ExtractBSTR
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long  cBytes   [in] Maximum bytes to examine in buffer
//   BSTR  bstr     [in] Buffer pointer assumed to be a BSTR
//   BSTR *pbstrOut [out] Copy of BSTR returned here. Caller must SysFreeString
//   long *pcbUsed  [out] Bytes in BSTR (including terminating null char) 
//
// Output:
//    HRESULT
//
// Notes:
// Used when formatting raw BYTE arrays of data. The bstr parameter is assumed
// to point to a null-terminated BSTR. This function scans until it finds a
// null char or reaches the end of the buffer. If BSTR found, then copies
// it using SysAllocString and returns to caller
//
HRESULT CSnapIn::ExtractBSTR
(
    long  cBytes,
    BSTR  bstr,
    BSTR *pbstrOut,
    long *pcbUsed
)
{
    HRESULT hr = S_OK;
    long    i = 0;
    long    cChars = cBytes / sizeof(WCHAR);
    BOOL    fFound = FALSE;

    *pbstrOut = NULL;
    *pcbUsed = 0;

    if (cChars < 1)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    while ( (i < cChars) && (!fFound) )
    {
        if (L'\0' == bstr[i])
        {
            *pbstrOut = ::SysAllocString(bstr);
            if (NULL == *pbstrOut)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            *pcbUsed = (i + 1) * sizeof(WCHAR);
            fFound = TRUE;
        }
        else
        {
            i++;
        }
    }

    if (!fFound)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ExtractBSTR
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long  cBytes     [in] Maximum bytes to examine in buffer
//   BSTR  bstr       [in] Buffer pointer assumed to contain mulitple concatenated
//                         null-terminated BSTRs
//   VARIANT *pvarOut [out] Array of BSTR returned here. Caller must VariantClear
//   long *pcbUsed    [out] Total bytes in array
//
// Output:
//    HRESULT
//
// Notes:
// Used when formatting raw BYTE arrays of data. The bstr parameter is assumed
// to point to multiple concatenated null-terminated BSTRs. This function scans
// until it finds a double null char or reaches the end of the buffer. If BSTRs
// are found they are returned in a SafeArray inside the VARIANT.
//
HRESULT CSnapIn::ExtractBSTRs
(
    long     cBytes,
    BSTR     bstr,
    VARIANT *pvarOut,
    long    *pcbUsed
)
{
    HRESULT     hr = S_OK;
    SAFEARRAY  *psa = NULL;
    long        cBytesUsed = 0;
    long        cTotalBytesUsed = 0;
    long        cBytesLeft = cBytes;
    long        i = 0;
    long        cChars = cBytes / sizeof(WCHAR);
    BSTR        bstrNext = NULL;
    BSTR HUGEP *pbstr = NULL;
    BOOL        fFound = FALSE;

    SAFEARRAYBOUND sabound;
    ::ZeroMemory(&sabound, sizeof(sabound));

    ::VariantInit(pvarOut);
    *pcbUsed = NULL;

    // Create an empty array of strings. If the buffer starts with a double
    // null then this is what will be returned.
   
    sabound.cElements = 0;
    sabound.lLbound = 1L;
    psa = ::SafeArrayCreate(VT_BSTR, 1, &sabound);
    if (NULL == psa)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    while ( (i < cChars) && (!fFound) )
    {
        if (L'\0' == bstr[i])
        {
            // Double null found. End of the line.
            cTotalBytesUsed += sizeof(WCHAR);
            fFound = TRUE;
            break;
        }

        // Extract the next BSTR and adjust remaining byte counts

        IfFailGo(ExtractBSTR(cBytesLeft, &bstr[i], &bstrNext, &cBytesUsed));
        cTotalBytesUsed += cBytesUsed;
        i += (cBytesUsed / sizeof(WCHAR));
        cBytesLeft -= cBytesUsed;

        // ReDim the SafeArray and add the new BSTR
        
        sabound.cElements++;
        hr = ::SafeArrayRedim(psa, &sabound);
        EXCEPTION_CHECK_GO(hr);

        hr = ::SafeArrayAccessData(psa,
                                   reinterpret_cast<void HUGEP **>(&pbstr));
        EXCEPTION_CHECK_GO(hr);

        pbstr[sabound.cElements - 1L] = bstrNext;
        bstrNext = NULL;
        hr = ::SafeArrayUnaccessData(psa);
        EXCEPTION_CHECK_GO(hr);
        pbstr = NULL;
    }

    if (!fFound)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Return the SafeArray to the caller

    pvarOut->vt = VT_ARRAY | VT_BSTR;
    pvarOut->parray = psa;
    
    *pcbUsed = cTotalBytesUsed;

Error:
    FREESTRING(bstrNext);
    if (FAILED(hr))
    {
        if (NULL != pbstr)
        {
            (void)::SafeArrayUnaccessData(psa);
        }

        if (NULL != psa)
        {
            ::SafeArrayDestroy(psa);
        }
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ExtractObject
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long                    cBytes      [in]  Maximum bytes to examine in buffer
//   void                   *pvData      [in]  ptr to buffer
//   IUnknown              **ppunkObject [out] object's IUnknown returned here
//                                             caller must Release
//   long                   *pcbUsed     [out] Total bytes used in buffer to
//                                             extract object
//   SnapInFormatConstants   Format      [in]  siPersistedObject or
//                                             siObjectReference
//
// Output:
//    HRESULT
//
// Notes:
// Used when formatting raw BYTE arrays of data. The buffer is assumed to contain
// one of the two forms of an object. The persisted object contains the stream
// that the object saved itself to. The object reference contains the stream
// that the object's IUnknown was marshaled to.
//
HRESULT CSnapIn::ExtractObject
(
    long                    cBytes, 
    void                   *pvData,
    IUnknown              **ppunkObject,
    long                   *pcbUsed,
    SnapInFormatConstants   Format
)
{
    HRESULT  hr = S_OK;
    HGLOBAL  hglobal = NULL;
    IStream *piStream = NULL;

    LARGE_INTEGER li;
    ::ZeroMemory(&li, sizeof(li));

    ULARGE_INTEGER uli;
    ::ZeroMemory(&uli, sizeof(uli));

    // Copy the data to an HGLOBAL

    hglobal = ::GlobalAlloc(GMEM_FIXED, cBytes);
    if (NULL == hglobal)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(reinterpret_cast<void *>(hglobal), pvData, cBytes);

    // Create a stream on the HGLOBAL

    hr = ::CreateStreamOnHGlobal(hglobal,
                                 FALSE, // Don't call GlobalFree on release
                                 &piStream);
    EXCEPTION_CHECK_GO(hr);

    if (siObject == Format)
    {
        // Load the object from that stream

        hr = ::OleLoadFromStream(piStream, IID_IUnknown,
                                 reinterpret_cast<void **>(ppunkObject));
    }
    else
    {
        // Unmarshal the object from the stream

        hr = ::CoUnmarshalInterface(piStream, IID_IUnknown,
                                    reinterpret_cast<void **>(ppunkObject));
    }
    EXCEPTION_CHECK_GO(hr);

    // Get the current stream pointer to determine how many bytes were used

    hr = piStream->Seek(li, STREAM_SEEK_CUR, &uli);
    EXCEPTION_CHECK_GO(hr);

    *pcbUsed = uli.LowPart;
    
Error:
    QUICK_RELEASE(piStream);
    if (NULL != hglobal)
    {
        (void)::GlobalFree(hglobal);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::InternalCreatePropertyPages
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IPropertySheetCallback  *piPropertySheetCallback [in] MMC interface
//
//   LONG_PTR             handle       [in]  MMC propsheet handle (not used)
//
//   IDataObject         *piDataObject [in]  data object of item(s) for which
//                                           properties verb was invoked
//   WIRE_PROPERTYPAGES **ppPages      [out] If debugging, then property page
//                                           definitions returned here. Caller
//                                           does not free these as MIDL-
//                                           generated stub will free them.
//
// Output:
//    HRESULT
//
// Notes:
// Handles calls to IExtendPropertySheet2::CreatePropertyPages and
// IExtendPropertySheetRemote::CreatePropertyPageDefs (used when debugging).
//
HRESULT CSnapIn::InternalCreatePropertyPages
(
    IPropertySheetCallback  *piPropertySheetCallback,
    LONG_PTR                 handle,
    IDataObject             *piDataObject,
    WIRE_PROPERTYPAGES     **ppPages
)
{
    HRESULT          hr = S_OK;
    CMMCDataObject  *pMMCDataObject  = NULL;
    BSTR             bstrProjectName = NULL;
    CPropertySheet  *pPropertySheet = NULL;
    BOOL             fWizard = FALSE;
    IUnknown        *punkPropertySheet = CPropertySheet::Create(NULL);
    IMMCClipboard   *piMMCClipboard = NULL;
    IMMCDataObjects *piMMCDataObjects = NULL;
    IMMCDataObject  *piMMCDataObject = NULL;
    BOOL             fFiringEventHere = FALSE;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Check that we have a CPropertySheet and get its this pointer.

    if (NULL == punkPropertySheet)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkPropertySheet,
                                                   &pPropertySheet));

    // Get a clipboard object with the selection

    IfFailGo(::CreateSelection(piDataObject, &piMMCClipboard, this,
                               &SelectionType));

    // If this is not a foreign data object then this is a primary snap-in
    // being asked to create its pages for a configuration wizard or for
    // a properties verb invoked on a single scope item.

    if (!IsForeign(SelectionType))
    {
        hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
        IfFailGo(hr);

        // If this is a configuration wizard then tell the CPropertySheet

        if (CCT_SNAPIN_MANAGER == pMMCDataObject->GetContext())
        {
            fWizard = TRUE;
            pPropertySheet->SetWizard();
        }
    }

    // For configuration wizards and foreign data objects we will be firing
    // an event to allow the snap-in to add its pages. Prepare the
    // CPropertySheet to accept AddPage and AddWizardPage calls from the snap-in
    // during that event.

    if ( fWizard || (siSingleForeign == SelectionType) )
    {
        fFiringEventHere = TRUE;

        // If this is a remote call (will happen during source debugging) then
        // tell the CPropertySheet so it can accumulate the property page info
        // rather than calling IPropertySheetCallback::AddPage.

        if (NULL != ppPages)
        {
            pPropertySheet->YouAreRemote();
        }

        // Give the property sheet its callback, handle, the object, and the
        // project name which is the left hand portion of the prog ID. If this
        // is a configuration wizard then also pass our this pointer to that
        // the property page can ask us to fire ConfigurationComplete when the
        // user clicks the finish button. (See CPropertyPageWrapper::OnWizFinish()
        // in ppgwrap.cpp for how this is used).

        IfFailGo(m_piSnapInDesignerDef->get_ProjectName(&bstrProjectName));

        pPropertySheet->SetCallback(piPropertySheetCallback, handle,
                                    static_cast<LPOLESTR>(bstrProjectName),
                                    fWizard ? NULL : piMMCClipboard,
                                    fWizard ? static_cast<ISnapIn *>(this) : NULL,
                                    fWizard);
    }

    // Let the snap-in add its property pages. If this request is from the
    // snap-in manager then fire SnapIn_CreateConfigurationWizard. If it is not
    // a foreign data object then it must be for a single scope item in a loaded
    // primary snap-in so let the current view handle it. If it is a foreign
    // data object then fire ExtensionSnapIn_CreatePropertyPages.

    if (fWizard)
    {
        FireEvent(&m_eiCreateConfigurationWizard,
                  static_cast<IMMCPropertySheet *>(pPropertySheet));
    }
    else if (siSingleForeign == SelectionType)
    {
        IfFailGo(piMMCClipboard->get_DataObjects(reinterpret_cast<MMCDataObjects **>(&piMMCDataObjects)));
        varIndex.vt = VT_I4;
        varIndex.lVal = 1L;
        IfFailGo(piMMCDataObjects->get_Item(varIndex, reinterpret_cast<MMCDataObject **>(&piMMCDataObject)));

        m_pExtensionSnapIn->FireCreatePropertyPages(piMMCDataObject,
                               static_cast<IMMCPropertySheet *>(pPropertySheet));
    }
    else
    {
        if (NULL != m_pCurrentView)
        {
            IfFailGo(m_pCurrentView->InternalCreatePropertyPages(
                                                         piPropertySheetCallback,
                                                         handle,
                                                         piDataObject,
                                                         ppPages));
        }
        else
        {
            ASSERT(FALSE, "CSnapIn Received IExtendPropertySheet2::CreatePropertyPages() and there is no current view");
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    // If we fired the event here and we are remote then we need to ask
    // CPropertySheet for its accumulated property page descriptors to return to
    // the stub.

    if (fFiringEventHere)
    {
        if (NULL != ppPages)
        {
            *ppPages = pPropertySheet->TakeWirePages();
        }
    }

Error:
    if (NULL != pPropertySheet)
    {
        // Tell the property sheet to release its refs on all that stuff we
        // gave it above.

        (void)pPropertySheet->SetCallback(NULL, NULL, NULL, NULL, NULL, fWizard);
    }

    FREESTRING(bstrProjectName);

    // Release our ref on the property sheet as the individual pages will addref
    // it and then release it when they are destroyed. If the snap-in did not
    // add any pages then our release here will destroy the property sheet.

    QUICK_RELEASE(punkPropertySheet);

    QUICK_RELEASE(piMMCClipboard);
    QUICK_RELEASE(piMMCDataObjects);
    QUICK_RELEASE(piMMCDataObject);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetDisplayName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BSTR bstrDisplayName [in] new SnapIn.DisplayName value
//
// Output:
//    HRESULT
//
// Notes:
// Sets SnapIn.DisplayName
//
HRESULT CSnapIn::SetDisplayName(BSTR bstrDisplayName)
{
    RRETURN(SetBstr(bstrDisplayName, &m_bstrDisplayName,
                    DISPID_SNAPIN_DISPLAY_NAME));
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetMMCExePath
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
// If not running under the debugger then calls GetModuleFileName to set
// m_szMMCEXEPath, m_pwszMMCEXEPath, and m_cbMMCExePathW
//
HRESULT CSnapIn::SetMMCExePath()
{
    HRESULT hr = S_OK;
    DWORD   cbFileName = 0;

    // If we are remote then the proxy will call IMMCRemote::SetExePath() to
    // give us the path. If not, then we need to get it here.

    IfFalseGo((!m_fWeAreRemote), S_OK);

    cbFileName = ::GetModuleFileName(NULL,  // get executable that loaded us
                                     m_szMMCEXEPath,
                                     sizeof(m_szMMCEXEPath));
    if (0 == cbFileName)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        EXCEPTION_CHECK(hr);
    }

    // Get the wide version also as various parts of the code will need it.

    if (NULL != m_pwszMMCEXEPath)
    {
        CtlFree(m_pwszMMCEXEPath);
        m_pwszMMCEXEPath = NULL;
    }

    IfFailGo(::WideStrFromANSI(m_szMMCEXEPath, &m_pwszMMCEXEPath));
    m_cbMMCExePathW = ::wcslen(m_pwszMMCEXEPath) * sizeof(WCHAR);

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetDisplayName
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT varFolder [in] new SnapIn.StaticFolder value
//
// Output:
//    HRESULT
//
// Notes:
// Sets SnapIn.StaticFolder
//
HRESULT CSnapIn::SetStaticFolder(VARIANT varFolder)
{
    RRETURN(SetVariant(varFolder, &m_varStaticFolder, DISPID_SNAPIN_STATIC_FOLDER));
}



//=--------------------------------------------------------------------------=
// CSnapIn::CompareListItems
//=--------------------------------------------------------------------------=
//
// Parameters:
//   CMMCListItem *pMMCListItem1 [in] 1st list item to compare
//   CMMCListItem *pMMCListItem2 [in] 1st list item to compare
//   BOOL         *pfEqual       [out] TRUE returned here if equal
//
// Output:
//    HRESULT
//
// Notes:
// Determines whether two MMCListItem objects represent the same underlying data
//
HRESULT CSnapIn::CompareListItems
(
    CMMCListItem *pMMCListItem1,
    CMMCListItem *pMMCListItem2,
    BOOL         *pfEqual
)
{
    HRESULT hr = S_OK;

    *pfEqual = FALSE;

    // Simplest test: the pointers are equal
    if (pMMCListItem1 == pMMCListItem2)
    {
        *pfEqual = TRUE;
    }
    else
    {
        // Compare MMCListItem.ID. List items could be from different list views
        // or different instances of the same list view.
        IfFalseGo(ValidBstr(pMMCListItem1->GetID()), S_OK);
        IfFalseGo(ValidBstr(pMMCListItem2->GetID()), S_OK);

        if (::_wcsicmp(pMMCListItem1->GetID(), pMMCListItem2->GetID()) == 0)
        {
            *pfEqual = TRUE;
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetDesignerDefHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
// Sets object model host on m_piSnapInDesignerDef
//
HRESULT CSnapIn::SetDesignerDefHost()
{
    RRETURN(SetObjectModelHost(m_piSnapInDesignerDef));
}

//=--------------------------------------------------------------------------=
// CSnapIn::RemoveDesignerDefHost
//=--------------------------------------------------------------------------=
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
// Removes object model host from m_piSnapInDesignerDef
//
HRESULT CSnapIn::RemoveDesignerDefHost()
{
    RRETURN(RemoveObjectModelHost(m_piSnapInDesignerDef));
}


//=--------------------------------------------------------------------------=
//                          ISnapIn Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::put_StaticFolder                                         [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT varFolder [in] new value for SnapIn.StaticFolder
//
// Output:
//    HRESULT
//
// Notes:
// Implements setting of SnapIn.StaticFolder
//
STDMETHODIMP CSnapIn::put_StaticFolder(VARIANT varFolder)
{
    HRESULT hr = S_OK;

    // If there already is a static node scope item then change it there.
    // That method will call our SetStaticFolder in order to set the
    // value of SnapIn.StaticFolder

    if (NULL != m_pStaticNodeScopeItem)
    {
        IfFailGo(m_pStaticNodeScopeItem->put_Folder(varFolder));
    }
    else
    {
        IfFailGo(SetStaticFolder(varFolder));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::put_DisplayName                                          [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BSTR bstrDisplayName [in] new value for SnapIn.DisplayName
//
// Output:
//    HRESULT
//
// Notes:
// Implements setting of SnapIn.DisplayName
//
STDMETHODIMP CSnapIn::put_DisplayName(BSTR bstrDisplayName)
{
    HRESULT hr = S_OK;

    // If there already is a ScopeItem for the static node then
    // set its display name too as they must match. Setting
    // ScopeItem.ScopeNode.DisplayName will change it in MMC
    // by calling IConsoleNameSpace2::SetItem() and then call back into
    // CSnapIn::SetDisplayName() to set our local property

    if (NULL == m_pStaticNodeScopeItem)
    {
        // Set our local property value only

        IfFailGo(SetBstr(bstrDisplayName, &m_bstrDisplayName,
                         DISPID_SNAPIN_DISPLAY_NAME));
    }
    else
    {
        IfFailGo(m_pStaticNodeScopeItem->GetScopeNode()->put_DisplayName(bstrDisplayName));
    }
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_TaskpadViewPreferred                                 [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    VARIANT_BOOL *pfvarPreferred [out] MMC 1.1's taskpad view preferred option
//                                       returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.TaskpadViewPreferred
//
STDMETHODIMP CSnapIn::get_TaskpadViewPreferred(VARIANT_BOOL *pfvarPreferred)
{
    HRESULT hr = S_OK;

    if (NULL == m_piConsole2)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piConsole2->IsTaskpadViewPreferred();
    EXCEPTION_CHECK_GO(hr);

    if (S_OK == hr)
    {
        *pfvarPreferred = VARIANT_TRUE;
    }
    else
    {
        *pfvarPreferred = VARIANT_FALSE;
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_RequiredExtensions                                   [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    Extensions **ppExtensions [out] Extensions collection returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.RequiredExtensions
//
STDMETHODIMP CSnapIn::get_RequiredExtensions(Extensions **ppExtensions)
{
    HRESULT         hr = S_OK;
    IUnknown       *punkExtensions = NULL;
    CExtensions    *pExtensions = NULL;
    IScopeItemDefs *piScopeItemDefs = NULL;
    IViewDefs      *piViewDefs = NULL;
    IListViewDefs  *piListViewDefs = NULL;

    // If we already built the collection then just return it.

    IfFalseGo(NULL == m_piRequiredExtensions, S_OK);

    // This is the first GET on this property so we need to build the collection
    // by examining the registry for all extensions of this snap-in.

    punkExtensions = CExtensions::Create(NULL);
    if (NULL == punkExtensions)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkExtensions, &pExtensions));

    // Get the extensions from registry for the static node, for all extensible
    // scope items, and for all extensible list items.

    IfFailGo(pExtensions->Populate(m_bstrNodeTypeGUID, CExtensions::All));

    IfFailGo(m_piSnapInDesignerDef->get_AutoCreateNodes(&piScopeItemDefs));
    IfFailGo(GetScopeItemExtensions(pExtensions, piScopeItemDefs));

    RELEASE(piScopeItemDefs);
    
    IfFailGo(m_piSnapInDesignerDef->get_OtherNodes(&piScopeItemDefs));
    IfFailGo(GetScopeItemExtensions(pExtensions, piScopeItemDefs));

    IfFailGo(m_piSnapInDesignerDef->get_ViewDefs(&piViewDefs));
    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
    IfFailGo(GetListItemExtensions(pExtensions, piListViewDefs));

    IfFailGo(punkExtensions->QueryInterface(IID_IExtensions,
                            reinterpret_cast<void **>(&m_piRequiredExtensions)));
Error:

    if (SUCCEEDED(hr))
    {
        m_piRequiredExtensions->AddRef();
        *ppExtensions = reinterpret_cast<Extensions *>(m_piRequiredExtensions);
    }

    QUICK_RELEASE(punkExtensions);
    QUICK_RELEASE(piScopeItemDefs);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_Clipboard                                            [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    MMCClipboard **ppMMCClipboard [out] Clipboard object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.Clipboard
//
STDMETHODIMP CSnapIn::get_Clipboard(MMCClipboard **ppMMCClipboard)
{
    HRESULT      hr = S_OK;
    IDataObject *piDataObject = NULL;

    SnapInSelectionTypeConstants SelectionType = siEmpty;

    if (NULL == ppMMCClipboard)
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the dataobject currently on the system clipboard

    hr = ::OleGetClipboard(&piDataObject);
    EXCEPTION_CHECK_GO(hr);

    // Create the selection and return it to the caller.

    IfFailGo(::CreateSelection(piDataObject,
                               reinterpret_cast<IMMCClipboard **>(ppMMCClipboard),
                               this, &SelectionType));

Error:
    QUICK_RELEASE(piDataObject);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_StringTable                                          [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    MMCStringTable **ppMMCStringTable [out] StringTable object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.StringTable
//
STDMETHODIMP CSnapIn::get_StringTable(MMCStringTable **ppMMCStringTable)
{
    HRESULT          hr = S_OK;
    IUnknown        *punkMMCStringTable = NULL;
    CMMCStringTable *pMMCStringTable = NULL;

    // If we already created the object then just return it.

    IfFalseGo(NULL == m_piMMCStringTable, S_OK);

    // This is the first GET on this property so we need to create the object

    punkMMCStringTable = CMMCStringTable::Create(NULL);
    if (NULL == punkMMCStringTable)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkMMCStringTable->QueryInterface(IID_IMMCStringTable,
                                reinterpret_cast<void **>(&m_piMMCStringTable)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkMMCStringTable,
                                                   &pMMCStringTable));

    // Pass the object MMC's IStringTable
    
    pMMCStringTable->SetIStringTable(m_piStringTable);

Error:
    if (SUCCEEDED(hr))
    {
        m_piMMCStringTable->AddRef();
        *ppMMCStringTable = reinterpret_cast<MMCStringTable *>(m_piMMCStringTable);
    }

    QUICK_RELEASE(punkMMCStringTable);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentView                                          [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    View **ppView [out] Current View object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentView
//
STDMETHODIMP CSnapIn::get_CurrentView(View **ppView)
{
    HRESULT hr = S_OK;

    *ppView = NULL;

    if (NULL != m_pCurrentView)
    {
        IfFailGo(m_pCurrentView->QueryInterface(IID_IView,
                                           reinterpret_cast<void **>(ppView)));
    }
    
Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentScopePaneItem                                  [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ScopePaneItem **ppScopePaneItem [out] Current ScopePaneItem object
//                                          returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentScopePaneItem
//
STDMETHODIMP CSnapIn::get_CurrentScopePaneItem(ScopePaneItem **ppScopePaneItem)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppScopePaneItem = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->QueryInterface(IID_IScopePaneItem,
                                  reinterpret_cast<void **>(ppScopePaneItem)));
        }
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentScopeItem                                     [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ScopeItem **ppScopeItem [out] Current ScopeItem object
//                                  returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentScopeItem
//
STDMETHODIMP CSnapIn::get_CurrentScopeItem(ScopeItem **ppScopeItem)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppScopeItem = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->GetScopeItem()->QueryInterface(IID_IScopeItem,
                                      reinterpret_cast<void **>(ppScopeItem)));
        }
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentResultView                                    [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ResultView **ppResultView [out] Current ResultView object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentResultView
//
STDMETHODIMP CSnapIn::get_CurrentResultView(ResultView **ppResultView)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppResultView = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->GetResultView()->QueryInterface(IID_IResultView,
                                     reinterpret_cast<void **>(ppResultView)));
        }
    }

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::get_CurrentListView                                      [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    MMCListView **ppMMCListView [out] Current MMCListView object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.CurrentListView
//
STDMETHODIMP CSnapIn::get_CurrentListView(MMCListView **ppListView)
{
    HRESULT         hr = S_OK;
    CScopePaneItem *pSelected = NULL;

    *ppListView = NULL;

    if (NULL != m_pCurrentView)
    {
        pSelected = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
        if (NULL != pSelected)
        {
            IfFailGo(pSelected->GetResultView()->GetListView()->QueryInterface(
                                       IID_IMMCListView,
                                       reinterpret_cast<void **>(ppListView)));
        }
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::get_MMCCommandLine                                       [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BSTR *pbstrCmdLine  [out] MMC command line returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements getting of SnapIn.MMCCommandLine
//
STDMETHODIMP CSnapIn::get_MMCCommandLine(BSTR *pbstrCmdLine)
{
    HRESULT hr = S_OK;
    LPTSTR  pszCmdLine = NULL;

    *pbstrCmdLine = NULL;

    // If we are remote then m_pszMMCCommandLine might have been set by the
    // proxy during IComponentData::Initialize by calling
    // IMMCRemote::SetMMCCommandline (see CSnapIn::SetMMCCommandline)

    if (NULL != m_pszMMCCommandLine)
    {
        pszCmdLine = m_pszMMCCommandLine;
    }
    else
    {
        pszCmdLine = ::GetCommandLine();
    }

    if (NULL != pszCmdLine)
    {
        IfFailGo(::BSTRFromANSI(pszCmdLine, pbstrCmdLine));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ConsoleMsgBox                                            [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR     Prompt   [in] Message box text
//   VARIANT  Buttons  [in] Optional. Button constants (vbOKOnly etc.) These
//                          have the same values as the Win32 MB_OK etc.
//   VARIANT  Title    [in] Optional. Message box title
//   int     *pnResult [out] Iconsole2->MessageBox result returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.ConsoleMsgBox
//
STDMETHODIMP CSnapIn::ConsoleMsgBox(BSTR     Prompt,
                                    VARIANT  Buttons,
                                    VARIANT  Title,
                                    int     *pnResult)
{
    HRESULT hr = S_OK;
    LPCWSTR pwszTitle = static_cast<LPCWSTR>(m_bstrDisplayName);
    UINT    uiButtons = MB_OK;

    VARIANT varI4Buttons;
    ::VariantInit(&varI4Buttons);

    VARIANT varStringTitle;
    ::VariantInit(&varStringTitle);

    if (NULL == m_piConsole2)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    if (ISPRESENT(Buttons))
    {
        hr = ::VariantChangeType(&varI4Buttons, &Buttons, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        uiButtons = static_cast<UINT>(varI4Buttons.lVal);
    }

    if (ISPRESENT(Title))
    {
        hr = ::VariantChangeType(&varStringTitle, &Title, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        pwszTitle = static_cast<LPCWSTR>(varStringTitle.bstrVal);
    }
    else if (NULL == pwszTitle)
    {
        pwszTitle = L"";
    }
    
    if (NULL == Prompt)
    {
        Prompt = L"";
    }

    hr = m_piConsole2->MessageBox(static_cast<LPCWSTR>(Prompt),
                                  static_cast<LPCWSTR>(pwszTitle),
                                  static_cast<UINT>(uiButtons),
                                  pnResult);
    EXCEPTION_CHECK(hr);

Error:
    (void)::VariantClear(&varStringTitle);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ShowHelpTopic                                            [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR     Topic   [in] Help topic to display
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.ShowHelpTopic
//
STDMETHODIMP CSnapIn::ShowHelpTopic(BSTR Topic)
{
    HRESULT  hr = S_OK;
    LPOLESTR pwszTopic = NULL;

    if (NULL == m_piDisplayHelp)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
    }
    else
    {
        // MMC requires allocating a copy of the topic that it will free

        IfFailGo(::CoTaskMemAllocString(Topic, &pwszTopic));
        hr = m_piDisplayHelp->ShowTopic(pwszTopic);
    }

Error:

    // If IDisplayHelp::ShowTopic() failed then we need to free the string
    
    if ( FAILED(hr) && (NULL != pwszTopic) )
    {
        ::CoTaskMemFree(pwszTopic);
    }

    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Trace                                                    [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   BSTR     Message   [in] Message to pass to OutputDebugStringA
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.Trace
//
STDMETHODIMP CSnapIn::Trace(BSTR Message)
{
    HRESULT  hr = S_OK;
    char    *pszMessage = NULL;

    // Convert to ANSI so this will work on Win9x

    IfFailGo(::ANSIFromWideStr(Message, &pszMessage));

    ::OutputDebugStringA(pszMessage);
    ::OutputDebugStringA("\n\r");

Error:
     if (NULL != pszMessage)
     {
         ::CtlFree(pszMessage);
     }
     RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::FireConfigComplete                                       [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IDispatch *pdispConfigObject [in] Configuration object passed to
//                                     MMCPropertySheet.AddWizardPage
//
// Output:
//    HRESULT
//
// Notes:
// This is a hidden and restricted method of the ISnapIn interface used
// internally by property pages when the user clicks the Finish button on
// on a configuration wizard. Fires SnapIn_ConfigurationComplete. See
// CPropertyPageWrapper class in ppgwrap.cpp for more info.
//
STDMETHODIMP CSnapIn::FireConfigComplete(IDispatch *pdispConfigObject)
{
    FireEvent(&m_eiConfigurationComplete, pdispConfigObject);
    return S_OK;
}



//=--------------------------------------------------------------------------=
// CSnapIn::FormatData                                               [ISnapIn]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   VARIANT                Data              [in]  VARIANT containing BYTE
//                                                  array of raw data
//   long                   StartingIndex     [in]  One-based index to start
//                                                  extracting from in Data
//   SnapInFormatConstants  Format            [in]  Type of data to extract
//                                                  from Data
//   VARIANT               *BytesUsed         [in]  Bytes used within Data to
//                                                  extract requested type
//   VARIANT               *pvarFormattedData [out] Data type requested returned
//                                                  in this variant
//
// Output:
//    HRESULT
//
// Notes:
// Implements SnapIn.FormatData
//
STDMETHODIMP CSnapIn::FormatData
(
    VARIANT                Data,
    long                   StartingIndex,
    SnapInFormatConstants  Format,
    VARIANT               *BytesUsed,
    VARIANT               *pvarFormattedData
)
{
    HRESULT     hr = S_OK;
    LONG        lUBound = 0;
    LONG        lLBound = 0;
    LONG        cBytes = 0;
    LONG        cBytesUsed = 0;
    GUID        guid = GUID_NULL;
    void HUGEP *pvArrayData = NULL;

    WCHAR   wszGUID[64];
    ::ZeroMemory(wszGUID, sizeof(wszGUID));

    // If the data was in a Variant then VB will pass it as a pointer to
    // that Variant. That could easily happen if the snap-in does something like:
    //
    // Dim v As Variant
    // Dim l As Long
    // v = Data.GetData("SomeFormat")
    // l = FormatData(v, siLong)

    if ( (VT_BYREF | VT_VARIANT) == Data.vt )
    {
        // Just copy the referenced Variant into the passed Variant. We
        // have no need for the reference after this and the Data parameter
        // is read-only so we can clobber its contents safely.
        Data = *(Data.pvarVal);
    }

    // Now we have the real Variant. Is must contain a one-dimensional array of
    // Byte

    if ( (VT_ARRAY | VT_UI1) != Data.vt )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // If the caller wants bytes used returned then it should have been passed
    // as a pointer to a long

    if (ISPRESENT(*BytesUsed))
    {
        if ( (VT_BYREF | VT_I4) != BytesUsed->vt )
        {
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
        }
        *(BytesUsed->plVal) = 0;
    }

    
    if (1 != ::SafeArrayGetDim(Data.parray))
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    ::VariantInit(pvarFormattedData);

    hr = ::SafeArrayAccessData(Data.parray, &pvArrayData);
    EXCEPTION_CHECK_GO(hr);

    // Get its size. As we only allow one-dimensional Byte arrays, the lower
    // and upper bounds of the 1st dimension will give us the size in bytes.

    hr = ::SafeArrayGetLBound(Data.parray, 1, &lLBound);
    EXCEPTION_CHECK_GO(hr);

    hr = ::SafeArrayGetUBound(Data.parray, 1, &lUBound);
    EXCEPTION_CHECK_GO(hr);

    // Get the length of the array

    cBytes = (lUBound - lLBound) + 1L;

    // Check that StartingIndex is within bounds.

    if ( (StartingIndex < lLBound) || (StartingIndex > lUBound) )
    {
        hr = SID_E_INVALIDARG;
        EXCEPTION_CHECK_GO(hr);
    }

    // Increment the data pointer to the starting index.

    pvArrayData = ((BYTE HUGEP *)pvArrayData) + (StartingIndex - lLBound);

    // Decrement the available byte count by the starting index

    cBytes -= (StartingIndex - lLBound);

    // Convert the data to the correct format in the returned VARIANT

    switch (Format)
    {
        case siInteger:
            if (cBytes < sizeof(SHORT))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->iVal = *(SHORT *)pvArrayData;
            cBytesUsed = sizeof(SHORT);
            pvarFormattedData->vt = VT_I2;
            break;

        case siLong:
            if (cBytes < sizeof(LONG))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->lVal = *(LONG *)pvArrayData;
            cBytesUsed = sizeof(LONG);
            pvarFormattedData->vt = VT_I4;
            break;

        case siSingle:
            if (cBytes < sizeof(FLOAT))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->fltVal = *(FLOAT *)pvArrayData;
            cBytesUsed = sizeof(FLOAT);
            pvarFormattedData->vt = VT_R4;
            break;

        case siDouble:
            if (cBytes < sizeof(DOUBLE))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->dblVal = *(DOUBLE *)pvArrayData;
            cBytesUsed = sizeof(DOUBLE);
            pvarFormattedData->vt = VT_R8;
            break;

        case siBoolean:
            if (cBytes < sizeof(VARIANT_BOOL))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->boolVal = *(VARIANT_BOOL *)pvArrayData;
            cBytesUsed = sizeof(VARIANT_BOOL);
            pvarFormattedData->vt = VT_BOOL;
            break;

        case siCBoolean:
            if (cBytes < sizeof(BOOL))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->boolVal = BOOL_TO_VARIANTBOOL(*(BOOL *)pvArrayData);
            cBytesUsed = sizeof(BOOL);
            pvarFormattedData->vt = VT_BOOL;
            break;

        case siDate:
            if (cBytes < sizeof(DATE))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->date = *(DATE *)pvArrayData;
            cBytesUsed = sizeof(DATE);
            pvarFormattedData->vt = VT_DATE;
            break;

        case siCurrency:
            if (cBytes < sizeof(CY))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->cyVal = *(CY *)pvArrayData;
            cBytesUsed = sizeof(CY);
            pvarFormattedData->vt = VT_CY;
            break;

        case siGUID:
            if (cBytes < sizeof(GUID))
            {
                hr = SID_E_INVALIDARG;
                EXCEPTION_CHECK_GO(hr);
            }
            ::memcpy(&guid, pvArrayData, sizeof(GUID));
            if (0 == ::StringFromGUID2(guid, wszGUID,
                                       sizeof(wszGUID) / sizeof(wszGUID[0])))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->bstrVal = ::SysAllocString(wszGUID);
            if (NULL == pvarFormattedData->bstrVal)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
            pvarFormattedData->vt = VT_BSTR;
            cBytesUsed = sizeof(GUID);
            break;

        case siString:
            IfFailGo(ExtractBSTR(cBytes, (BSTR)pvArrayData, &pvarFormattedData->bstrVal,
                                 &cBytesUsed));
            pvarFormattedData->vt = VT_BSTR;
            break;

        case siMultiString:
            IfFailGo(ExtractBSTRs(cBytes, (BSTR)pvArrayData, pvarFormattedData,
                                  &cBytesUsed));
            pvarFormattedData->vt = VT_ARRAY | VT_BSTR;
            break;

        case siObject:
        case siObjectInstance:
            IfFailGo(ExtractObject(cBytes, pvArrayData, &pvarFormattedData->punkVal,
                                   &cBytesUsed, Format));
            pvarFormattedData->vt = VT_UNKNOWN;
            break;

        default:
            hr = SID_E_INVALIDARG;
            EXCEPTION_CHECK_GO(hr);
            break;
    }


Error:
    if (ISPRESENT(*BytesUsed) && SUCCEEDED(hr) )
    {
        *(BytesUsed->plVal) = cBytesUsed;
    }

    if (NULL != pvArrayData)
    {
        (void)::SafeArrayUnaccessData(Data.parray);
    }
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          ISnapinAbout Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapinDescription                                [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   LPOLESTR *ppszDescription [out] SnapIn.Description returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetSnapinDescription
//
STDMETHODIMP CSnapIn::GetSnapinDescription(LPOLESTR *ppszDescription)
{
    RRETURN(::CoTaskMemAllocString(m_bstrDescription, ppszDescription));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetProvider                                         [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   LPOLESTR *ppszName [out] SnapIn.Provider returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetProvider
//
STDMETHODIMP CSnapIn::GetProvider(LPOLESTR *ppszName)
{
    RRETURN(::CoTaskMemAllocString(m_bstrProvider, ppszName));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapinVersion                                    [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   LPOLESTR *ppszVersion [out] SnapIn.Version returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetSnapinVersion
//
STDMETHODIMP CSnapIn::GetSnapinVersion(LPOLESTR *ppszVersion)
{
    RRETURN(::CoTaskMemAllocString(m_bstrVersion, ppszVersion));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapinImage                                      [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   HICON *phAppIcon [out] SnapIn.Icon returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetSnapinImage
//
STDMETHODIMP CSnapIn::GetSnapinImage(HICON *phAppIcon)
{
    HRESULT hr = S_OK;
    HICON   hAppIcon = NULL;

    *phAppIcon = NULL;

    IfFalseGo(NULL != m_piIcon, S_OK);

    hr = ::GetPictureHandle(m_piIcon, PICTYPE_ICON,
                            reinterpret_cast<OLE_HANDLE *>(&hAppIcon));
    EXCEPTION_CHECK_GO(hr);

    // BUGBUG: Fix this after MMC is fixed.
    // Due to a bug in MMC 1.1 we need to make a copy of the icon
    // and return it. If not, MMC will release the snap-in and then use
    // the icon. Releasing the snap-in will cause the picture object to be
    // freed and the icon destroyed. By making a copy the snap-in will
    // leak this resources. Use GDI function to copy icon.

    *phAppIcon = ::CopyIcon(hAppIcon);
    if (NULL == *phAppIcon)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::GetStaticFolderImage                                [ISnapinAbout]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   HBITMAP  *phSmallImage     [out] SnapIn.SmallFolders(StaticFolder)
//   HBITMAP  *phSmallImageOpen [out] SnapIn.SmallFoldersOpen(StaticFolder)
//   HBITMAP  *phLargeImage     [out] SnapIn.LargeFolders(StaticFolder)
//   COLORREF *pclrMask         [out] SnapIn.SmallFolders.MaskColor
//
// Output:
//    HRESULT
//
// Notes:
// Implements ISnapInAbout::GetStaticFolderImage
//
STDMETHODIMP CSnapIn::GetStaticFolderImage(HBITMAP  *phSmallImage,
                                           HBITMAP  *phSmallImageOpen,
                                           HBITMAP  *phLargeImage,
                                           COLORREF *pclrMask)
{
    HRESULT     hr = S_OK;
    HBITMAP     hSmallImage = NULL;
    HBITMAP     hSmallImageOpen = NULL;
    HBITMAP     hLargeImage = NULL;
    IMMCImages *piMMCImages = NULL;
    OLE_COLOR   OleColorMask = 0;
    COLORREF    ColorRef = RGB(0x00,0x00,0x00);

    *phSmallImage = NULL;
    *phSmallImageOpen = NULL;
    *phLargeImage = NULL;
    *pclrMask = 0;

    IfFalseGo(NULL != m_piSmallFolders, S_OK);
    IfFalseGo(NULL != m_piSmallFoldersOpen, S_OK);
    IfFalseGo(NULL != m_piLargeFolders, S_OK);
    IfFalseGo(VT_EMPTY != m_varStaticFolder.vt, S_OK);
    
    IfFailGo(m_piSmallFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(::GetPicture(piMMCImages, m_varStaticFolder, PICTYPE_BITMAP,
                          reinterpret_cast<OLE_HANDLE *>(&hSmallImage)));
    RELEASE(piMMCImages);

    IfFailGo(m_piSmallFoldersOpen->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(::GetPicture(piMMCImages, m_varStaticFolder, PICTYPE_BITMAP,
                          reinterpret_cast<OLE_HANDLE *>(&hSmallImageOpen)));
    RELEASE(piMMCImages);

    IfFailGo(m_piLargeFolders->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(::GetPicture(piMMCImages, m_varStaticFolder, PICTYPE_BITMAP,
                          reinterpret_cast<OLE_HANDLE *>(&hLargeImage)));

    // Due to a bug in MMC 1.1 we need to make copies of these bitmaps
    // and return them. If not, MMC 1.1 will release the snap-in and then use
    // the bitmaps. Releasing the snap-in will cause the image lists to be
    // freed and the bitmaps destroyed. By making a copy the snap-in will
    // leak these resources. This is fixed in MMC 1.2 but at this point in a
    // snap-in's life it has no way of knowing the MMC version so we need to
    // leak it in 1.2 as well. Use function in rtutil.cpp to copy bitmap.

    IfFailGo(::CopyBitmap(hSmallImage,     phSmallImage));
    IfFailGo(::CopyBitmap(hSmallImageOpen, phSmallImageOpen));
    IfFailGo(::CopyBitmap(hLargeImage,     phLargeImage));

    // Use the mask color from SmallFolders. The other choice would have
    // been to add a mask color property to SnapIn which would have been
    // even more redundant.

    IfFailGo(m_piSmallFolders->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRef));
    *pclrMask = ColorRef;

Error:
    if (FAILED(hr))
    {
        if (NULL != *phSmallImage)
        {
            (void)::DeleteObject(*phSmallImage);
            *phSmallImage = NULL;
        }
        if (NULL != *phSmallImageOpen)
        {
            (void)::DeleteObject(*phSmallImageOpen);
            *phSmallImageOpen = NULL;
        }
        if (NULL != *phLargeImage)
        {
            (void)::DeleteObject(*phLargeImage);
            *phLargeImage = NULL;
        }
    }
    QUICK_RELEASE(piMMCImages);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IComponentData Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::CompareObjects                                    [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IDataObject *piDataObject1 [in] 1st data object to compare
//   IDataObject *piDataObject2 [in] 2nd data object to compare
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::CompareObjects
//
STDMETHODIMP CSnapIn::CompareObjects(IDataObject *piDataObject1, IDataObject *piDataObject2)
{
    HRESULT         hr = S_FALSE;
    CMMCDataObject *pMMCDataObject1 = NULL;
    CMMCDataObject *pMMCDataObject2 = NULL;
    BOOL            f1NotFromThisSnapIn = FALSE;
    BOOL            f2NotFromThisSnapIn = FALSE;
    CScopeItems    *pScopeItems1 = NULL;
    CScopeItems    *pScopeItems2 = NULL;
    CMMCListItems  *pMMCListItems1 = NULL;
    CMMCListItems  *pMMCListItems2 = NULL;
    CMMCListItem   *pMMCListItem1 = NULL;
    CMMCListItem   *pMMCListItem2 = NULL;
    BOOL            fEqual = FALSE;
    long            cObjects = 0;
    long            i = 0;

    // Determine whethere the data objects belong to this snap-in

    ::IdentifyDataObject(piDataObject1, this, &pMMCDataObject1,
                         &f1NotFromThisSnapIn);

    ::IdentifyDataObject(piDataObject2, this, &pMMCDataObject2,
                         &f2NotFromThisSnapIn);

    IfFalseGo( (!f1NotFromThisSnapIn) && (!f2NotFromThisSnapIn), S_FALSE);

    // Make sure they are the same type (e.g. single scope item)
    
    IfFalseGo(pMMCDataObject1->GetType() == pMMCDataObject2->GetType(), S_FALSE);

    // Based on the type compare their referenced scope items and list items.
    // ScopeItems can be compared for pointer equality as there can only be
    // one instance of a given scope item. List items, can come from different
    // list views and represent the same underlying data so the comparison is
    // more difficulty. See CSnapIn::CompareListItems (above) for more info.
    
    switch(pMMCDataObject1->GetType())
    {
        case CMMCDataObject::ScopeItem:
            if ( pMMCDataObject1->GetScopeItem() ==
                 pMMCDataObject2->GetScopeItem() )
            {
                hr = S_OK;
            }
            break;

        case CMMCDataObject::ListItem:
            IfFailGo(CompareListItems(pMMCDataObject1->GetListItem(),
                                      pMMCDataObject2->GetListItem(),
                                      &fEqual));
            if (fEqual)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
            break;

        case CMMCDataObject::MultiSelect:
            // Need to compare each of the scope items and list items contained
            // by the 2 data objects. This case could occur when an array of
            // objects is passed to MMCPropertySheetProvider.CreatePropertySheet
            // and the same array is passed to
            // MMCPropertySheetProvider.FindPropertySheet

            pScopeItems1 = pMMCDataObject1->GetScopeItems();
            pScopeItems2 = pMMCDataObject2->GetScopeItems();
            cObjects = pScopeItems1->GetCount();
            IfFalseGo(cObjects == pScopeItems2->GetCount(), S_FALSE);
            for (i = 0; i < cObjects; i++)
            {
                IfFalseGo(pScopeItems1->GetItemByIndex(i) ==
                          pScopeItems2->GetItemByIndex(i), S_FALSE);
            }

            pMMCListItems1 = pMMCDataObject1->GetListItems();
            pMMCListItems2 = pMMCDataObject2->GetListItems();
            cObjects = pMMCListItems1->GetCount();
            IfFalseGo(cObjects == pMMCListItems2->GetCount(), S_FALSE);
            for (i = 0; i < cObjects; i++)
            {
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                            pMMCListItems1->GetItemByIndex(i), &pMMCListItem1));
                IfFailGo(CSnapInAutomationObject::GetCxxObject(
                            pMMCListItems2->GetItemByIndex(i), &pMMCListItem2));

                IfFailGo(CompareListItems(pMMCListItem1, pMMCListItem2, &fEqual));
                IfFalseGo(fEqual, S_FALSE);
            }
            hr = S_OK;
            break;

        default:
            break;
    }
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetDisplayInfo                                    [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   SCOPEDATAITEM *psdi [in] Scope item for which display info is needed
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::GetDisplayInfo
//
STDMETHODIMP CSnapIn::GetDisplayInfo(SCOPEDATAITEM *psdi)
{
    HRESULT     hr = S_OK;
    CScopeItem *pScopeItem = reinterpret_cast<CScopeItem *>(psdi->lParam);

    VARIANT varImageIndex;
    ::VariantInit(&varImageIndex);

    // Zero lParam indicates static node

    if (NULL == pScopeItem)
    {
        pScopeItem = m_pStaticNodeScopeItem;
    }

    IfFalseGo(NULL != pScopeItem, SID_E_INTERNAL);

    // For SDI_STR return ScopeItem.ScopeNode.DisplayName

    if ( SDI_STR == (psdi->mask & SDI_STR) )
    {
        psdi->displayname = pScopeItem->GetDisplayNamePtr();
    }

    // For SDI_IMAGE return SnapIn.SmallFolders(ScopeItem.Folder).Index

    else if ( SDI_IMAGE == (psdi->mask & SDI_IMAGE) )
    {
        IfFailGo(pScopeItem->get_Folder(&varImageIndex));
        IfFailGo(GetScopeItemImage(varImageIndex, &psdi->nImage));
    }

    // For SDI_OPENIMAGE return SnapIn.SmallFolders(ScopeItem.Folder).Index adjusted

    else if ( SDI_OPENIMAGE == (psdi->mask & SDI_OPENIMAGE) )
    {
        IfFailGo(pScopeItem->get_Folder(&varImageIndex));
        IfFailGo(GetScopeItemImage(varImageIndex, &psdi->nOpenImage));
        // Adjust for open image index (see CSnapIn::AddScopeItemImages())
        psdi->nOpenImage += static_cast<int>(m_cImages);
    }

Error:
    (void)::VariantClear(&varImageIndex);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::QueryDataObject                                   [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long                cookie         [in] 0 for static node or CScopeItem ptr
//   DATA_OBJECT_TYPES   type           [in] CCT_SCOPE, CCT_RESULT,
//                                           CCT_SNAPIN_MANAGER, CCT_UNINITIALIZED
//   IDataObject       **ppiDataObject  [out] data object returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::QueryDataObject
//
STDMETHODIMP CSnapIn::QueryDataObject
(
    long                cookie,
    DATA_OBJECT_TYPES   type,
    IDataObject       **ppiDataObject
)
{
    HRESULT         hr = S_OK;
    CScopeItem     *pScopeItem = NULL;

    DebugPrintf("IComponentData::QueryDataObject(cookie=%08.8X, type=%08.8X)\r\n", cookie, type);

    // Zero cookie is static node. If we havent added a ScopeItem for static
    // node then do it now
    
    if (0 == cookie)
    {
        if (NULL == m_pStaticNodeScopeItem)
        {
            IfFailGo(m_pScopeItems->AddStaticNode(&m_pStaticNodeScopeItem));
            m_RuntimeMode = siRTPrimary;
        }
        pScopeItem = m_pStaticNodeScopeItem;
    }
    else
    {
        // Any other cookie is just the CScopeItem pointer

        pScopeItem = reinterpret_cast<CScopeItem *>(cookie);
    }

    // Set the ScopeItem's data object's context and return the data object

    pScopeItem->GetData()->SetContext(type);

    hr = pScopeItem->GetData()->QueryInterface(IID_IDataObject,
                                    reinterpret_cast<void **>(ppiDataObject));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Notify                                            [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IDataObject     *piDataObject [in] target of the notification
//   MMC_NOTIFY_TYPE  event        [in] notification
//   long             Arg          [in or out] defined by notificaton
//   long             Param        [in or out] defined by notificaton
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::Notify
//
STDMETHODIMP CSnapIn::Notify
(
    IDataObject     *piDataObject,
    MMC_NOTIFY_TYPE  event,
    long             Arg,
    long             Param
)
{
    HRESULT                hr = S_OK;
    BOOL                   fHandled = FALSE;
    MMC_EXPANDSYNC_STRUCT *pExpandSync = NULL;

    switch (event)
    {
        case MMCN_DELETE:
            DebugPrintf("IComponentData::Notify(MMCN_DELETE)\r\n");
            hr = OnDelete(piDataObject);
            break;

        case MMCN_EXPAND:
            DebugPrintf("IComponentData::Notify(MMCN_EXPAND)\r\n");
            hr = OnExpand(Expand,
                          piDataObject,
                          static_cast<BOOL>(Arg),
                          static_cast<HSCOPEITEM>(Param),
                          &fHandled);
            break;

        case MMCN_EXPANDSYNC:
            DebugPrintf("IComponentData::Notify(MMCN_EXPANDSYNC)\r\n");
            pExpandSync = reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(Param);
            hr = OnExpand(ExpandSync,
                          piDataObject,
                          pExpandSync->bExpanding,
                          pExpandSync->hItem,
                          &pExpandSync->bHandled);
            break;

        case MMCN_PRELOAD:
            DebugPrintf("IComponentData::Notify(MMCN_PRELOAD)\r\n");
            hr = OnPreload(piDataObject, static_cast<HSCOPEITEM>(Arg));
            break;

        case MMCN_RENAME:
            DebugPrintf("IComponentData::Notify(MMCN_RENAME)\r\n");
            hr = OnRename(piDataObject, (OLECHAR *)Param);
            break;

        case MMCN_REMOVE_CHILDREN:
            DebugPrintf("IComponentData::Notify(MMCN_REMOVE_CHILDREN)\r\n");
            hr = OnRemoveChildren(piDataObject, static_cast<HSCOPEITEM>(Arg));
            break;
    }

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::CreateComponent                                   [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IComponent **ppiComponent [out] IComponent returned here
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::CreateComponent
//
STDMETHODIMP CSnapIn::CreateComponent(IComponent **ppiComponent)
{
    HRESULT  hr = S_OK;
    IView   *piView = NULL;
    CView   *pView = NULL;

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    // Add a new View to SnapIn.Views and get its IComponent

    IfFailGo(m_piViews->Add(varUnspecified, varUnspecified, &piView));
    IfFailGo(piView->QueryInterface(IID_IComponent,
                                    reinterpret_cast<void **>(ppiComponent)));

    // Give the View a back pointer to the snap-in

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piView, &pView));
    pView->SetSnapIn(this);

    // Set Views.CurrentView and SnapIn.CurrentView
    
    m_pViews->SetCurrentView(piView);
    m_pCurrentView = pView;

    // The new View is considered active so its CControlbar becomes the
    // active one.
    
    SetCurrentControlbar(pView->GetControlbar());

    // If this view was created because the snap-in called View.NewWindow with
    // siCaption then set View.Caption.

    IfFailGo(piView->put_Caption(m_pViews->GetNextViewCaptionPtr()));

    // Make sure we have the MMC.EXE path so we can build taskpad and res
    // URLS

    IfFailGo(SetMMCExePath());

    // Fire Views_Initialize

    m_pViews->FireInitialize(piView);

Error:
    if (FAILED(hr))
    {
        *ppiComponent = NULL;
    }
    QUICK_RELEASE(piView);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Initialize                                        [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IUnknown *punkConsole [in] MMC's IConsole
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::Initialize
//
STDMETHODIMP CSnapIn::Initialize(IUnknown *punkConsole)
{
    HRESULT hr = S_OK;

    // In theory, this method should never be called twice but as a precaution
    // we'll release any existing console interfaces.

    ReleaseConsoleInterfaces();

    // Acquire all the console interfaces needed for the life of the snap-in

    IfFailGo(punkConsole->QueryInterface(IID_IConsole2,
                                     reinterpret_cast<void **>(&m_piConsole2)));

    IfFailGo(punkConsole->QueryInterface(IID_IConsoleNameSpace2,
                            reinterpret_cast<void **>(&m_piConsoleNameSpace2)));

    IfFailGo(m_piConsole2->QueryInterface(IID_IDisplayHelp,
                                   reinterpret_cast<void **>(&m_piDisplayHelp)));

    IfFailGo(m_piConsole2->QueryInterface(IID_IStringTable,
                                   reinterpret_cast<void **>(&m_piStringTable)));


    hr = m_piConsole2->QueryScopeImageList(&m_piImageList);
    EXCEPTION_CHECK(hr);

    // Call IImageList::ImageListSetStrip to set the scope pane images
    
    IfFailGo(AddScopeItemImages());

    // Make sure we have the MMC.EXE path so we can build taskpad and res
    // URLS

    IfFailGo(SetMMCExePath());

    // Set object model host on design time definitions and the View collection
    // These will be removed in IComponent::Destroy (CSnapIn::Destroy

    IfFailGo(SetObjectModelHost(m_piSnapInDesignerDef));
    IfFailGo(SetObjectModelHost(m_piViews));

    DebugPrintf("Firing SnapIn_Load\r\n");

    FireEvent(&m_eiLoad);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Destroy                                           [IComponentData]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//
// Output:
//    HRESULT
//
// Notes:
// Implements IComponentData::Destroy
//
STDMETHODIMP CSnapIn::Destroy()
{
    HRESULT hr = S_OK;

    // Fire SnapIn_Unload to tell the snap-in we are being unloaded from MMC

    DebugPrintf("Firing SnapIn_Unload\r\n");

    FireEvent(&m_eiUnload);

    // The scope item for the static node must be removed here because it is not
    // destroyed like all the other elements in the collection that represent
    // real scope items.

    if ( (NULL != m_pScopeItems) && (NULL != m_pStaticNodeScopeItem) )
    {
        m_pScopeItems->RemoveStaticNode(m_pStaticNodeScopeItem);
    }

    // Release all interfaces held on the console now. If we didn't this now
    // then there could be circular ref counts between us and MMC.

    ReleaseConsoleInterfaces();

    // Tell all of our contained objects to remove their refs on us as their
    // object model host. This is also done now to avoid circular ref counts.

    IfFailGo(RemoveObjectModelHost(m_piViews));
    IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));

    // Remove the current view from SnapIn.Views as it holds a ref on the View
    m_pViews->SetCurrentView(NULL);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IExtendControlbar Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::ControlbarNotify                               [IExtendControlbar]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IControlbar *piControlbar [in] MMC interface
//
// Output:
//    HRESULT
//
// Notes:
// Implements IExtendControlbar::ControlbarNotify
//
STDMETHODIMP CSnapIn::SetControlbar(IControlbar *piControlbar)
{
    HRESULT      hr = S_OK;
    BOOL         fWasSet = TRUE;
    CControlbar *pPrevControlbar = GetCurrentControlbar();

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    hr = m_pControlbar->SetControlbar(piControlbar);

    // Restore the previous current controlbar

    SetCurrentControlbar(pPrevControlbar);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::ControlbarNotify                               [IExtendControlbar]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   MMC_NOTIFY_TYPE  event        [in] notification
//   long             Arg          [in or out] defined by notificaton
//   long             Param        [in or out] defined by notificaton
//
// Output:
//    HRESULT
//
// Notes:
// Implements IExtendControlbar::ControlbarNotify
//
STDMETHODIMP CSnapIn::ControlbarNotify
(
    MMC_NOTIFY_TYPE event,
    LPARAM          arg,
    LPARAM          param
)
{
    HRESULT      hr = S_OK;
    BOOL         fWasSet = TRUE;
    CControlbar *pPrevControlbar = GetCurrentControlbar();

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    switch (event)
    {
        case MMCN_SELECT:
            hr = m_pControlbar->OnControlbarSelect(
                                         reinterpret_cast<IDataObject *>(param),
                                         (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
            break;

        case MMCN_BTN_CLICK:
            hr = m_pControlbar->OnButtonClick(
                                           reinterpret_cast<IDataObject *>(arg),
                                           static_cast<int>(param));
            break;

        case MMCN_MENU_BTNCLICK:
            hr = m_pControlbar->OnMenuButtonClick(
                                     reinterpret_cast<IDataObject *>(arg),
                                     reinterpret_cast<MENUBUTTONDATA *>(param));
            break;
    }

    // Restore the previous current controlbar

    SetCurrentControlbar(pPrevControlbar);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                     IExtendControlbarRemote Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::MenuButtonClick                          [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject    *piDataObject   [in]  from MMCN_MENU_BTNCLICK
//      int             idCommand      [in]  from MENUBUTTONDATA.idCommand passed
//                                           to the proxy with MMCN_MENU_BTNCLICK
//      POPUP_MENUDEF **ppPopupMenuDef [out] popup menu definition returned here
//                                           so proxy can display it
//
// Output:
//
// Notes:
//
// This function effectively handles MMCN_MENU_BTNCLICK when running
// under a debugging session.
//
// The proxy for IExtendControlbar::ControlbarNotify() will QI for
// IExtendControlbarRemote and call this method when it gets MMCN_MENU_BTNCLICK.
// We fire MMCToolbar_ButtonDropDown and the return an array of menu item
// definitions. The proxy will display the popup menu on the MMC side and then
// call IExtendControlbarRemote::PopupMenuClick() if the user makes a selection.
// (See implementation below in CSnapIn::PopupMenuClick()).
//

STDMETHODIMP CSnapIn::MenuButtonClick
(
    IDataObject    *piDataObject,
    int             idCommand,
    POPUP_MENUDEF **ppPopupMenuDef
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    hr = m_pControlbar->MenuButtonClick(piDataObject, idCommand, ppPopupMenuDef);

    // Restore the previous current controlbar

    SetCurrentControlbar(NULL);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::PopupMenuClick                           [IExtendControlbarRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IDataObject *piDataObject [in] from MMCN_MENU_BTNCLICK
//      UINT         uIDItem      [in] ID of popup menu item selected
//      IUnknown    *punkParam    [in] punk we returned to stub in
//                                     CSnapIn::MenuButtonClick() (see above).
//                                     This is IUnknown on CMMCButton.
//
// Output:
//
// Notes:
//
// This function effectively handles a popup menu selection for a menu button
// when running under a debugging session.
//
// After the proxy for IExtendControlbar::ControlbarNotify() has displayed
// a popup menu on our behalf, if the user made a selection it will call this
// method. See CSnapIn::MenuButtonClick() above for more info.
//

STDMETHODIMP CSnapIn::PopupMenuClick
(
    IDataObject *piDataObject,
    UINT         uiIDItem,
    IUnknown    *punkParam
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as pure controlbar extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and controlbar extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

    // The CSnapIn's CControlbar is the one that can be used during this event
    // so set it up

    SetCurrentControlbar(m_pControlbar);

    // Pass the event on to CControlbar for the actual handling

    hr = m_pControlbar->PopupMenuClick(piDataObject, uiIDItem, punkParam);

    // Remove the current controlbar

    SetCurrentControlbar(NULL);

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IExtendContextMenu Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::AddMenuItems                                  [IExtendContextMenu]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject          *piDataObject           [in] data object of selected
//                                                    items
//
//  IContextMenuCallback *piContextMenuCallback  [in] MMC callback interface to
//                                                    add menu items
//
//  long                 *plInsertionAllowed     [in, out] determines where
//                                                         in menu insertions
//                                                         may be made. Snap-in
//                                                         may turn off bits
//                                                         to prevent further
//                                                         insertions
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendedContextMenu::AddMenuItems
//
// MMC uses IExtendedContextMenu on the snap-in's main object in two cases.
// 1. To allow an extension snap-in to extend context menus displayed for the
// primary snap-in it is extending.
// 2. In a primary snap-in, when a context menu is displayed for a scope item in
// the scope pane, the snap-in may add to the top, new and task menus. Adding to
// the view menu is done separately using the IExtendContextMenu on the object
// that implements IComponent (CView in view.cpp).
//
// CContextMenu object handles both cases.
//
STDMETHODIMP CSnapIn::AddMenuItems
(
    IDataObject          *piDataObject,
    IContextMenuCallback *piContextMenuCallback,
    long                 *plInsertionAllowed
)
{
    HRESULT         hr = S_OK;
    BOOL            fWasSet = TRUE;
    CScopePaneItem *pSelectedItem = NULL;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure menu extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and menu extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

    // Only pass the currently selected item if it is active meaning that it is
    // currently displaying the contents of the result pane.
    
    if (NULL != m_pCurrentView)
    {
        pSelectedItem = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();

        // Check for NULL. This can happen in the case where a snap-in is added
        // to a console and its static node is expanded using the plus sign only.
        // If the Console Root is selected and the user right clicks a
        // snap-in scope item there will be no currently selected item.
        
        if (NULL != pSelectedItem)
        {
            if (!pSelectedItem->Active())
            {
                pSelectedItem = NULL;
            }
        }
    }

    // Let CContextMenu handle the event
    
    IfFailGo(m_pContextMenu->AddMenuItems(piDataObject,
                                          piContextMenuCallback,
                                          plInsertionAllowed,
                                          pSelectedItem));

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::Command                                       [IExtendContextMenu]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  long         lCommandID   [in] menu item clicked
//  IDataObject *piDataObject [in] data object of selected item(s)
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendedContextMenu::Command
//
STDMETHODIMP CSnapIn::Command
(
    long         lCommandID,
    IDataObject *piDataObject
)
{
    HRESULT         hr = S_OK;
    BOOL            fWasSet = TRUE;
    CScopePaneItem *pSelectedItem = NULL;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure menu extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and menu extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }
    IfFailGo(SetObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

    // If there is a current view get its currently selected ScopePaneItem

    if (NULL != m_pCurrentView)
    {
        pSelectedItem = m_pCurrentView->GetScopePaneItems()->GetSelectedItem();
    }

    // Let CContextMenu handle the event

    IfFailGo(m_pContextMenu->Command(lCommandID, piDataObject, pSelectedItem));

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    IfFailGo(RemoveObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                    IExtendPropertySheet2 Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::CreatePropertyPages                        [IExtendPropertySheet2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IPropertySheetCallback *piPropertySheetCallback [in] MMC interface
//  LONG_PTR                handle                  [in] MMC propsheet handle
//                                                       (not used)
//  IDataObject            *piDataObject            [in] data object of selected
//                                                       item(s)
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheet2::CreatePropertyPages
//
STDMETHODIMP CSnapIn::CreatePropertyPages
(
    IPropertySheetCallback *piPropertySheetCallback,
    LONG_PTR                handle,
    IDataObject            *piDataObject
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure property page extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and property page extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }

    // Let the internal routine handle the event

    IfFailGo(InternalCreatePropertyPages(piPropertySheetCallback, handle,
                                         piDataObject, NULL));
    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::QueryPagesFor                              [IExtendPropertySheet2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject *piDataObject [in] data object of selected item(s)
//
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheet2::QueryPagesFor
//
STDMETHODIMP CSnapIn::QueryPagesFor(IDataObject *piDataObject)
{
    HRESULT         hr = S_OK;
    CMMCDataObject *pMMCDataObject  = NULL;
    VARIANT_BOOL    fvarHavePages = VARIANT_FALSE;
    BOOL            fWasSet = TRUE;

    // This should be one of our data objects. If not then ignore it.

    hr = CSnapInAutomationObject::GetCxxObject(piDataObject, &pMMCDataObject);
    IfFalseGo(SUCCEEDED(hr), S_FALSE);

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure property page extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and property page extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }

    // If its the snap-in manager then fire SnapIn_QueryConfigurationWizard

    if (CCT_SNAPIN_MANAGER == pMMCDataObject->GetContext())
    {
        DebugPrintf("Firing SnapIn_QueryConfigurationWizard\r\n");

        FireEvent(&m_eiQueryConfigurationWizard, &fvarHavePages);

        if (VARIANT_TRUE == fvarHavePages)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        // Not the snap-in manager. Let the View handle it as it is no
        // different than an IExtendPropertySheet2::QueryPagesFor on
        // the IComponent object (the View).

        if (NULL != m_pCurrentView)
        {
            IfFailGo(m_pCurrentView->QueryPagesFor(piDataObject));
        }
        else
        {
            ASSERT(FALSE, "CSnapIn Received IExtendPropertySheet2::QueryPagesFor() and there is no current view");
            hr = S_FALSE;
        }
    }

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }

Error:
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::GetWatermarks                              [IExtendPropertySheet2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheet2::GetWatermarks
//
// We return S_OK from this method to indicate to MMC that we do not have
// any watermarks. VB snap-ins cannot implement wizard97 style wizards using
// this method. They must use Image objects on the property page to simulate
// the watermarks. See the designer end-user docs section
// "Creating Wizard97-Style Wizards" under "Programming Techniques".
//
STDMETHODIMP CSnapIn::GetWatermarks
(
    IDataObject *piDataObject,
    HBITMAP     *phbmWatermark,
    HBITMAP     *phbmHeader,
    HPALETTE    *phPalette,
    BOOL        *bStretch
)
{
    HRESULT   hr = S_OK;
    IPicture *piPicture = NULL;


    *phbmWatermark = NULL;
    *phbmHeader = NULL;
    *phPalette = NULL;
    *bStretch = FALSE;

    // UNDONE:
    // There is a painting problem with watermarks and they are overwritten
    // by VB's property page painting so disable them for now.
    
    return S_OK;

    if (NULL != m_piWatermark)
    {
        // UNDONE: need to use CopyBitmap() to upgrade bitmaps that have
        // a lower color depth than the screen
        IfFailGo(::GetPictureHandle(m_piWatermark, PICTYPE_BITMAP,
                                 reinterpret_cast<OLE_HANDLE *>(phbmWatermark)));
    }
    
    if (NULL != m_piHeader)
    {
        // UNDONE: need to use CopyBitmap() to upgrade bitmaps that have
        // a lower color depth than the screen
        IfFailGo(::GetPictureHandle(m_piHeader, PICTYPE_BITMAP,
                                    reinterpret_cast<OLE_HANDLE *>(phbmHeader)));
    }

    if ( (NULL != m_piWatermark) || (NULL != m_piHeader) )
    {
        IfFailGo(m_piPalette->QueryInterface(IID_IPicture,
                                         reinterpret_cast<void **>(&piPicture)));

        IfFailGo(piPicture->get_hPal(reinterpret_cast<OLE_HANDLE *>(phPalette)));

        if (VARIANT_TRUE == m_StretchWatermark)
        {
            *bStretch = TRUE;
        }
    }

Error:
    QUICK_RELEASE(piPicture);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                    IExtendPropertySheetRemote Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::CreatePropertyPageDefs                [IExtendPropertySheetRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IDataObject         *piDataObject [in] data object of selected item(s)
//                                                       
//  WIRE_PROPERTYPAGES **ppPages      [out] Property page defs returned here.
//                                          These will be freed by the
//                                          MIDL-generated stub
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IExtendPropertySheetRemote::CreatePropertyPageDefs
//
// This interface is used instead of IExtendPropertySheet2 when running under
// the debugger. This method is called by the
// IExtendPropertySheet2::CreatePropertyPages proxy in mmcproxy.dll.
//
STDMETHODIMP CSnapIn::CreatePropertyPageDefs
(
    IDataObject         *piDataObject,
    WIRE_PROPERTYPAGES **ppPages
)
{
    HRESULT hr = S_OK;
    BOOL    fWasSet = TRUE;

    // If this is an extension then set the objet model host and then remove
    // it on the way out. We have to do it this way because there is no
    // other opportunity to remove back pointers as a pure property page extension
    // does not receive IComponentData::Initialize and IComponentData::Destroy.
    // We check if it was already set because that could happen in a combination
    // namespace and property page extension and we don't want to remove it on the
    // way out.

    if (siRTExtension == m_RuntimeMode)
    {
        IfFailGo(SetObjectModelHostIfNotSet(m_piSnapInDesignerDef, &fWasSet));
    }

    // Let internal routine handle this call

    IfFailGo(InternalCreatePropertyPages(NULL, NULL, piDataObject, ppPages));

    // Remove the object model host if it wasn't set on the way in

    if (!fWasSet)
    {
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                     IRequiredExtensions Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::EnableAllExtensions                          [IRequiredExtensions]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IRequiredExtensions::EnableAllExtensions
//
//
STDMETHODIMP CSnapIn::EnableAllExtensions()
{
    HRESULT      hr = S_FALSE;
    CExtensions *pExtensions = NULL;
    IExtension  *piExtension = NULL; // Not AddRef()ed
    long         cExtensions = 0;
    long         i = 0;
    VARIANT_BOOL fvarEnabled = VARIANT_FALSE;

    SnapInExtensionTypeConstants Type = siStatic;

    // If the snap-in has not populated SnapIn.RequiredExtensions then return
    // S_FALSE to indicate all extensions are not enabled

    IfFalseGo(NULL != m_piRequiredExtensions, S_FALSE);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piRequiredExtensions,
                                                   &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(cExtensions != 0, S_FALSE);

    // Iterate through the collection and look for any disabled static extension.
    // If one is found then return S_FALSE.

    for (i = 0; i < cExtensions; i++)
    {
        piExtension = pExtensions->GetItemByIndex(i);

        IfFailGo(piExtension->get_Type(&Type));
        if (siStatic != Type)
        {
            continue;
        }

        IfFailGo(piExtension->get_Enabled(&fvarEnabled));
        IfFalseGo(VARIANT_TRUE == fvarEnabled, S_FALSE);
    }

    // All statics are enabled - return S_OK to indicate that to MMC.
    
    hr = S_OK;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetFirstExtension                            [IRequiredExtensions]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pclsidExtension [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IRequiredExtensions::GetFirstExtension
//
//
STDMETHODIMP CSnapIn::GetFirstExtension(CLSID *pclsidExtension)
{
    HRESULT hr = S_OK;

    // If the snap-in has not populated SnapIn.RequiredExtensions then return
    // S_FALSE to indicate all extensions are not enabled.

    IfFalseGo(NULL != m_piRequiredExtensions, S_FALSE);

    // Initialize the enumerator and return the first enabled extension

    m_iNextExtension = 0;

    IfFailGo(GetNextExtension(pclsidExtension));

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetNextExtension                            [IRequiredExtensions]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pclsidExtension [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IRequiredExtensions::GetNextExtension
//
//
STDMETHODIMP CSnapIn::GetNextExtension(CLSID *pclsidExtension)
{
    HRESULT      hr = S_FALSE;
    CExtensions *pExtensions = NULL;
    CExtension  *pExtension = NULL;
    long         cExtensions = 0;
    BOOL         fEnabledFound = FALSE;

    // If the snap-in has not populated SnapIn.RequiredExtensions then return
    // S_FALSE to indicate all extensions are not enabled.

    IfFalseGo(NULL != m_piRequiredExtensions, S_FALSE);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piRequiredExtensions,
                                                   &pExtensions));
    cExtensions = pExtensions->GetCount();
    IfFalseGo(cExtensions != 0, S_FALSE);

    // Iterate through the collection starting at the current position and look
    // for the next enabled extension.  If one is found then return S_OK to
    // indicate to MMC that it should require that extension. Note that we do
    // not distinguish here between static and dynamic extensions. This is the
    // opportunity for the snap-in to preload a dynamic extension if desired.

    while ( (!fEnabledFound) && (m_iNextExtension < cExtensions) )
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                    pExtensions->GetItemByIndex(m_iNextExtension), &pExtension));

        m_iNextExtension++;

        if (pExtension->Enabled())
        {
            hr = ::CLSIDFromString(pExtension->GetCLSID(), pclsidExtension);
            EXCEPTION_CHECK_GO(hr);
            fEnabledFound = TRUE;
        }
    }

    hr = fEnabledFound ? S_OK : S_FALSE;

Error:
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                           ISnapinHelp Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetHelpTopic                                         [ISnapinHelp]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  LPOLESTR *ppwszHelpFile [out] complete path to help file returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles ISnapinHelp::GetHelpTopic
//
STDMETHODIMP CSnapIn::GetHelpTopic(LPOLESTR *ppwszHelpFile)
{
    HRESULT  hr = S_OK;
    size_t   cchHelpFile = 0;
    size_t   cbHelpFile = 0;
    OLECHAR *pwszSnapInPath = NULL; // not allocated, no need to free
    size_t   cbSnapInPath = 0;
    BOOL     fRelative = FALSE;
    OLECHAR *pwszFullPath = NULL;
    OLECHAR *pchLastBackSlash = NULL;

    // If SnapIn.HelpFile has not been set then return S_FALSE to tell MMC
    // that we don't have a help file.

    IfFalseGo(ValidBstr(m_bstrHelpFile), S_FALSE);

    // If the help file name is relative then convert to a fully qualified path

    cchHelpFile = ::wcslen(m_bstrHelpFile);

    // If it starts with a backslash then consider it fully qualified.

    if (L'\\' == m_bstrHelpFile[0])
    {
        fRelative = FALSE;
    }
    else if (cchHelpFile > 3) // enough room for C:\ ?
    {
        // If it does not have :\ in the 2nd and 3rd characters then consider it
        // relative

        if ( (L':' != m_bstrHelpFile[1]) || (L'\\' != m_bstrHelpFile[2] ) )
        {
            fRelative = TRUE;
        }
    }
    else
    {
        fRelative = TRUE;
    }

    if (fRelative)
    {
        // Find last backslash in snap-in path.

        IfFailGo(GetSnapInPath(&pwszSnapInPath, &cbSnapInPath));

        pchLastBackSlash = ::wcsrchr(pwszSnapInPath, L'\\');
        if (NULL == pchLastBackSlash)
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        // Determine how many bytes of the snap-in path we need

        cbSnapInPath = ((pchLastBackSlash + 1) - pwszSnapInPath) * sizeof(OLECHAR);
        
        cbHelpFile = cchHelpFile * sizeof(OLECHAR);

        pwszFullPath = (OLECHAR *)::CtlAllocZero(cbSnapInPath +
                                                 cbHelpFile +
                                                 sizeof(OLECHAR)); // for null
        if (NULL == pwszFullPath)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        ::memcpy(pwszFullPath, pwszSnapInPath, cbSnapInPath);

        ::memcpy((BYTE *)pwszFullPath + cbSnapInPath, m_bstrHelpFile, cbHelpFile);
    }
    else
    {
        pwszFullPath = m_bstrHelpFile;
    }

    IfFailGo(::CoTaskMemAllocString(pwszFullPath, ppwszHelpFile));

Error:
    if ( fRelative && (NULL != pwszFullPath) )
    {
        ::CtlFree(pwszFullPath);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                           ISnapinHelp2 Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetLinkedTopics                                     [ISnapinHelp2]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  LPOLESTR *ppwszTopics [out] Linked topics returned here.
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles ISnapinHelp2::GetLinkedTopics
//
STDMETHODIMP CSnapIn::GetLinkedTopics(LPOLESTR *ppwszTopics)
{
    HRESULT hr = S_OK;

    *ppwszTopics = NULL;

    // If SnapIn.LinkTopics has not been set then return S_FALSE to tell MMC
    // that we don't have a linked topics.

    IfFalseGo(ValidBstr(m_bstrLinkedTopics), S_FALSE);

    // UNDONE need to resolve relative paths of all help files.

    IfFailGo(::CoTaskMemAllocString(m_bstrLinkedTopics, ppwszTopics));

Error:
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
//                    IPersistStreamInit Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetClassID                                    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pClsid [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::GetClassID
//
STDMETHODIMP CSnapIn::GetClassID(CLSID *pClsid)
{
    *pClsid = CLSID_SnapIn;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapIn::InitNew                                       [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::InitNew
//
STDMETHODIMP CSnapIn::InitNew()
{
    HRESULT hr = S_OK;

    RELEASE(m_piSnapInDesignerDef);

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CSnapIn::Load                                          [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IStream *piStream [in] stream to load from
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::Load
//
STDMETHODIMP CSnapIn::Load(IStream *piStream)
{
    HRESULT         hr = S_OK;
    CLSID           clsid = CLSID_NULL;
    IUnknown       *punkSnapInDesignerDef = NULL;
    IPersistStream *piPersistStream = NULL;
    _PropertyBag   *p_PropertyBag = NULL;

    // This may be a VB serialization load or it may be a console load. To
    // distinguish the two we read the CLSID from the beginning of the stream.
    // If is is CLSID_SnapInDesignerDef the is is a VB serialization load.
    // If it is CLSID_PropertyBag then it is a console load.

    // Read the CLSID

    hr = ::ReadClassStm(piStream, &clsid);
    EXCEPTION_CHECK_GO(hr);

    // Check the CLSID

    if (CLSID_PropertyBag == clsid)
    {
        // Transfer the stream contents to a property bag

        IfFailGo(::PropertyBagFromStream(piStream, &p_PropertyBag));

        // Fire Snapin_ReadProperties

        FireEvent(&m_eiReadProperties, p_PropertyBag);
    }
    else if (CLSID_SnapInDesignerDef == clsid)
    {
        // Load the SnapInDesignerDef object. This is the snap-in definition
        // serialized in the designer as the runtime state.

        RELEASE(m_piSnapInDesignerDef);
        punkSnapInDesignerDef = CSnapInDesignerDef::Create(NULL);
        if (NULL == punkSnapInDesignerDef)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(punkSnapInDesignerDef->QueryInterface(IID_ISnapInDesignerDef,
                           reinterpret_cast<void **>(&m_piSnapInDesignerDef)));

        IfFailGo(punkSnapInDesignerDef->QueryInterface(IID_IPersistStream,
            reinterpret_cast<void **>(&piPersistStream)));

        IfFailGo(piPersistStream->Load(piStream));

        // Get the SnapInDef object to make fetching properties from the state easy

        RELEASE(m_piSnapInDef);
        IfFailGo(m_piSnapInDesignerDef->get_SnapInDef(&m_piSnapInDef));

        // Set the SnapIn properties. Set object model host so image lists
        // can be found by using a key into SnapInDesignerDef.ImageLists.

        IfFailGo(SetObjectModelHost(m_piSnapInDesignerDef));
        IfFailGo(SetSnapInPropertiesFromState());
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
    }
    else
    {
        // Neither CLSID is there. Stream is corrupt.
        hr = SID_E_SERIALIZATION_CORRUPT
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    QUICK_RELEASE(punkSnapInDesignerDef);
    QUICK_RELEASE(piPersistStream);
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CSnapIn::Save                                          [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IStream *piStream    [in] stream to save to
//  BOOL     fClearDirty [in] TRUE=clear snap-in's dirty flag so GetDirty would
//                            return S_FALSE
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::Save
//
STDMETHODIMP CSnapIn::Save(IStream *piStream, BOOL fClearDirty)
{
    HRESULT       hr = S_OK;
    _PropertyBag *p_PropertyBag = NULL;

    VARIANT var;
    ::VariantInit(&var);

    // Unlike Load, Save can only come from MMC so create a property bag.
    // fire the event and save it to the stream.

    // Create a VBPropertyBag object

    hr = ::CoCreateInstance(CLSID_PropertyBag,
                            NULL, // no aggregation
                            CLSCTX_INPROC_SERVER,
                            IID__PropertyBag,
                            reinterpret_cast<void **>(&p_PropertyBag));
    EXCEPTION_CHECK_GO(hr);

    // Fire Snapin_WriteProperties

    FireEvent(&m_eiWriteProperties, p_PropertyBag);

    // Write CLSID_PropertyBag to the beginning of the stream

    hr = ::WriteClassStm(piStream, CLSID_PropertyBag);
    EXCEPTION_CHECK_GO(hr);

    // Get the stream contents in a SafeArray of Byte

    IfFailGo(p_PropertyBag->get_Contents(&var));

    // Write the SafeArray contents to the stream

    IfFailGo(::WriteSafeArrayToStream(var.parray, piStream, WriteLength));

Error:
    (void)::VariantClear(&var);
    QUICK_RELEASE(p_PropertyBag);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::IsDirty                                       [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  None
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::IsDirty
//
// The designer object model does not have any way for a snap-in to indicate
// that a snap-in is dirty. This was an oversight discovered too late in the
// product cycle. There should have been a property SnapIn.Changed to control
// the return value from this function.
//
// To avoid a situation where a snap-in needs to save something we always return
// S_OK to indicate that the snap-in is dirty and should be saved. The only
// problem this may cause is that when a console is opened in author mode and
// the user does not do anything that requires a save (e.g. selected a node
// in the scope pane) then they will be prompted to save unnecessarily.
//
STDMETHODIMP CSnapIn::IsDirty()
{
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetSizeMax                                    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  ULARGE_INTEGER* puliSize [out] size returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IPersistStreamInit::GetSizeMax
//
STDMETHODIMP CSnapIn::GetSizeMax(ULARGE_INTEGER* puliSize)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
//                          IOleObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::SetClientSite                                         [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IOleClientSite *piOleClientSite [in] new client site
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetClientSite
//
STDMETHODIMP CSnapIn::SetClientSite(IOleClientSite *piOleClientSite)
{
    RELEASE(m_piOleClientSite);
    if (NULL != piOleClientSite)
    {
        RRETURN(piOleClientSite->QueryInterface(IID_IOleClientSite,
                                reinterpret_cast<void **>(&m_piOleClientSite)));
    }
    else
    {
        return S_OK;
    }
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetClientSite                                         [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  IOleClientSite **ppiOleClientSite [in] current client site returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetClientSite
//
STDMETHODIMP CSnapIn::GetClientSite(IOleClientSite **ppiOleClientSite)
{
    if (NULL != m_piOleClientSite)
    {
        m_piOleClientSite->AddRef();
    }
    *ppiOleClientSite = m_piOleClientSite;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetHostNames                                          [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetHostNames
//
STDMETHODIMP CSnapIn::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObj
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Close                                                 [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Close
//
STDMETHODIMP CSnapIn::Close(DWORD dwSaveOption)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetMoniker                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetMoniker
//
STDMETHODIMP CSnapIn::SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetMoniker                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetMoniker
//
STDMETHODIMP CSnapIn::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppmk
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::InitFromData                                          [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::InitFromData
//
STDMETHODIMP CSnapIn::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetClipboardData                                      [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetClipboardData
//
STDMETHODIMP CSnapIn::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::DoVerb                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::DoVerb
//
STDMETHODIMP CSnapIn::DoVerb
(
    LONG            iVerb,
    LPMSG           lpmsg,
    IOleClientSite *pActiveSite,
    LONG            lindex,
    HWND            hwndParent,
    LPCRECT         lprcPosRect
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::EnumVerbs                                             [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::EnumVerbs
//
STDMETHODIMP CSnapIn::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Update                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Update
//
STDMETHODIMP CSnapIn::Update()
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::IsUpToDate                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::IsUpToDate
//
STDMETHODIMP CSnapIn::IsUpToDate()
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Update                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  CLSID *pClsid [out] CLSID returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetUserClassID
//
STDMETHODIMP CSnapIn::GetUserClassID(CLSID *pClsid)
{
    if (NULL != pClsid)
    {
        *pClsid = CLSID_SnapIn;
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetUserType                                           [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetUserType
//
STDMETHODIMP CSnapIn::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetExtent                                             [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetExtent
//
STDMETHODIMP CSnapIn::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetExtent                                             [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetExtent
//
STDMETHODIMP CSnapIn::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Advise                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Advise
//
STDMETHODIMP CSnapIn::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Unadvise                                              [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::Unadvise
//
STDMETHODIMP CSnapIn::Unadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::EnumAdvise                                            [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::EnumAdvise
//
STDMETHODIMP CSnapIn::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// CSnapIn::Advise                                                [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  DWORD  dwAspect  [in] not used
//  DWORD *pdwStatus [in] misc status bits returned here
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::GetMiscStatus
//
STDMETHODIMP CSnapIn::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    return OLEMISC_INVISIBLEATRUNTIME;
}

//=--------------------------------------------------------------------------=
// CSnapIn::SetColorScheme                                        [IOleObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//  Not used
//                                                       
// Output:
//      HRESULT
//
// Notes:
//
// Handles IOleObject::SetColorScheme
//
STDMETHODIMP CSnapIn::SetColorScheme(LOGPALETTE *pLogpal)
{
    return E_NOTIMPL;
}


//=--------------------------------------------------------------------------=
//                   IProvideDynamicClassInfo Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapInDesigner::GetDynamicClassInfo             [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
//  ITypeInfo **ppTypeInfo [out] snap-in's dynamic typeinfo returned here
//  DWORD      *pdwCookie  [in]  typeinfo cookie from design time returned here
//
// Output:
//    HRESULT
//
// Notes:
//
// Handles IProvideDynamicClassInfo::GetDynamicClassInfo
//
STDMETHODIMP CSnapIn::GetDynamicClassInfo(ITypeInfo **ppTypeInfo, DWORD *pdwCookie)
{
    *pdwCookie = m_dwTypeinfoCookie;

    // Let IProvideClassInfo::GetClassInfo return the typeinfo
    
    RRETURN(GetClassInfo(ppTypeInfo));
}

//=--------------------------------------------------------------------------=
// CSnapIn::FreezeShape    [IProvideDynamicClassInfo]
//=--------------------------------------------------------------------------=
//
//
// Parameters:
//    None
//
// Output:
//    HRESULT
//
// Notes:
//
// Handles IProvideDynamicClassInfo::FreezeShape
// Not used at runtime because typeinfo can only change at design time.
//
STDMETHODIMP CSnapIn::FreezeShape(void)
{
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetClassInfo                                   [IProvideClassInfo]
//=--------------------------------------------------------------------------=
//
// Parameters:
//
//  ITypeInfo **ppTypeInfo [out] snap-in's dynamic typeinfo returned here
// Output:
//    HRESULT
//
// Notes:
//
//
// Handles IProvideClassInfo::GetClassInfo
//

STDMETHODIMP CSnapIn::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    ITypeLib *piTypeLib = NULL;
    HRESULT   hr = S_OK;

    IfFalseGo(NULL != ppTypeInfo, S_OK);

    // Load our typelib using registry information

    hr = ::LoadRegTypeLib(LIBID_SnapInLib,
                          1,
                          0,
                          LOCALE_SYSTEM_DEFAULT,
                          &piTypeLib);
    IfFailGo(hr);

    // Get the ITypeInfo for CLSID_SnapIn (the top level object)

    hr = piTypeLib->GetTypeInfoOfGuid(CLSID_SnapIn, ppTypeInfo);

Error:
    QUICK_RELEASE(piTypeLib);
    return hr;
}


//=--------------------------------------------------------------------------=
//                        IObjectModelHost Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::GetSnapInDesignerDef                  [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ISnapInDesignerDef **ppiSnapInDesignerDef [out] return designer's
//                                                    ISnapInDesignerDef here
//    
//
// Output:
//      HRESULT
//
// Notes:
//
// Handles IObjectModelHost::GetSnapInDesignerDef
//
// Called from an extensibility object when it needs access to the top of
// the object model.
//
//

STDMETHODIMP CSnapIn::GetSnapInDesignerDef
(
    ISnapInDesignerDef **ppiSnapInDesignerDef
)
{
    HRESULT hr = S_OK;

    if ( (NULL == m_piSnapInDesignerDef) || (NULL == ppiSnapInDesignerDef) )
    {
        *ppiSnapInDesignerDef = NULL;
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        m_piSnapInDesignerDef->AddRef();
        *ppiSnapInDesignerDef = m_piSnapInDesignerDef;
    }
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::GetRuntime                                      [IObjectModelHost]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    BOOL *pfRuntime [out] return flag indiciating whether host is runtime
//                          or designer
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IObjectModelHost::GetRuntime
//
// Called from any object when it needs to determine if it is running at runtime
// or at design time.
//
STDMETHODIMP CSnapIn::GetRuntime(BOOL *pfRuntime)
{
    HRESULT hr = S_OK;
    
    if (NULL == pfRuntime)
    {
        hr = SID_E_INTERNAL;
        EXCEPTION_CHECK(hr);
    }
    else
    {
        *pfRuntime = TRUE;
    }

    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                          IDispatch Methods
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// CSnapIn::GetTypeInfoCount                                       [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    UINT *pctinfo [out] return count of typeinfo interfaces supported here
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetTypeInfoCount
//
STDMETHODIMP CSnapIn::GetTypeInfoCount(UINT *pctinfo)
{
    RRETURN(CSnapInAutomationObject::GetTypeInfoCount(pctinfo));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetTypeInfoCount                                       [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   UINT        itinfo        [in]  which typeinfo requested (0=IDispatch)
//   LCID        lcid          [in]  locale of typeinfo
//   ITypeInfo **ppTypeInfoOut [out] snap-in's typeinfo returned here
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetTypeInfo
//
STDMETHODIMP CSnapIn::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    RRETURN(CSnapInAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut));
}


//=--------------------------------------------------------------------------=
// CSnapIn::GetIDsOfNames                                          [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   REFIID    riid      [in] IID for which DISPIDs are needed
//   OLECHAR **rgszNames [in] names for which DISPIDs are needed
//   UINT      cnames    [in] # of names
//   LCID      lcid      [in] locale of names
//   DISPID   *rgdispid  [out] DISPIDs returned here
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetIDsOfNames
//
// Defers to base class which means that any objects added to typeinfo at design
// time (e.g. toolbar, image list or menu) cannot be retrieved late bound. This
// means that when the snap-in passes Me to a subroutine, it cannot pass it
// As Object, it must pass it As SnapIn so that VB will use the dual interface.
//
STDMETHODIMP CSnapIn::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cnames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    // UNDONE: need to implement this for dispids >= DISPID_DYNAMIC_BASE
    // so dynamic props can be fetched late bound

    RRETURN(CSnapInAutomationObject::GetIDsOfNames(riid, rgszNames, cnames,
                                                   lcid, rgdispid));
}

//=--------------------------------------------------------------------------=
// CSnapIn::GetIDsOfNames                                          [IDispatch]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   DISPID      dispid      [in] DISPID of method or property
//   REFIID      riid        [in] dispatch IID
//   LCID        lcid        [in] locale of caller
//   WORD        wFlags      [in] DISPATCH_METHOD, DISPATCH_PROPERTYGET etc.
//   DISPPARAMS *pdispparams [in] parameters to method
//   VARIANT    *pvarResult  [out] return value of method
//   EXCEPINFO  *pexcepinfo  [out] exception details if DISP_E_EXCEPTION returned
//   UINT       *puArgErr    [out] index of 1st incorrect argument
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IDispatch::GetIDsOfNames
//
// For static properties and methods we defer to the base class in the
// framework. For dynamic properties (toolbars, menus and image lists) we need
// to search the design time definitions for an object with a matching DISPID.
// VB will always do a DISPATCH_PROPERTYGET on these objects.
//
STDMETHODIMP CSnapIn::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT         hr = S_OK;
    IMMCToolbars   *piMMCToolbars = NULL;
    CMMCToolbars   *pMMCToolbars = NULL;
    IMMCToolbar    *piMMCToolbar = NULL; // Not AddRef()ed
    CMMCToolbars   *pMMCToolbar = NULL;
    IMMCImageLists *piMMCImageLists = NULL;
    CMMCImageLists *pMMCImageLists = NULL;
    IMMCImageList  *piMMCImageList = NULL;
    CMMCImageList  *pMMCImageList = NULL;
    BOOL            fFound = FALSE;
    IMMCMenus      *piMMCMenus = NULL;
    IMMCMenu       *piMMCMenu = NULL;
    long            cObjects = 0;
    long            i = 0;
    
    // For static methods and properties just pass it on to the framework.

    if (dispid < DISPID_DYNAMIC_BASE)
    {
        RRETURN(CSnapInAutomationObject::Invoke(dispid, riid, lcid, wFlags,
                                                pdispparams, pvarResult,
                                                pexcepinfo, puArgErr));
    }

    // It's a static property. Need to find the object among toolbars,
    // image lists, and menus.

    // First try toolbars.

    IfFailGo(m_piSnapInDesignerDef->get_Toolbars(&piMMCToolbars));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbars, &pMMCToolbars));
    cObjects = pMMCToolbars->GetCount();

    for (i = 0; (i < cObjects) && (!fFound); i++)
    {
        piMMCToolbar = pMMCToolbars->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbar,
                                                       &pMMCToolbar));
        if (pMMCToolbar->GetDispid() == dispid)
        {
            pvarResult->vt = VT_DISPATCH;
            piMMCToolbar->AddRef();
            pvarResult->pdispVal = static_cast<IDispatch *>(piMMCToolbar);
            fFound = TRUE;
        }
    }

    IfFalseGo(!fFound, S_OK);

    // Not a toolbar. Try image lists.

    IfFailGo(m_piSnapInDesignerDef->get_ImageLists(&piMMCImageLists));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImageLists, &pMMCImageLists));
    cObjects = pMMCImageLists->GetCount();

    for (i = 0; (i < cObjects) && (!fFound); i++)
    {
        piMMCImageList = pMMCImageLists->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImageList,
                                                       &pMMCImageList));
        if (pMMCImageList->GetDispid() == dispid)
        {
            pvarResult->vt = VT_DISPATCH;
            piMMCImageList->AddRef();
            pvarResult->pdispVal = static_cast<IDispatch *>(piMMCImageList);
            fFound = TRUE;
        }
    }

    IfFalseGo(!fFound, S_OK);

    // Not an image list. Try menus.

    IfFailGo(m_piSnapInDesignerDef->get_Menus(&piMMCMenus));
    IfFailGo(FindMenu(piMMCMenus, dispid, &fFound, &piMMCMenu));
    if (fFound)
    {
        pvarResult->vt = VT_DISPATCH;
        pvarResult->pdispVal = static_cast<IDispatch *>(piMMCMenu);
    }

    IfFalseGo(!fFound, S_OK);

    
    // If we're here then its a bad dispid. Pass it on to the base class
    // and it will fill in the exception stuff

    hr = CSnapInAutomationObject::Invoke(dispid, riid, lcid, wFlags,
                                         pdispparams, pvarResult,
                                         pexcepinfo, puArgErr);

Error:
    QUICK_RELEASE(piMMCToolbars);
    QUICK_RELEASE(piMMCImageLists);
    QUICK_RELEASE(piMMCMenus);
    RRETURN(hr);
}




//=--------------------------------------------------------------------------=
// CSnapIn::FindMenu
//=--------------------------------------------------------------------------=
//
// Parameters:
//   IMMCMenus  *piMMCMenus [in]  menus collection to search
//   DISPID      dispid     [in]  DISPID to search for
//   BOOL       *pfFound    [out] TRUE returned here if menu found
//   IMMCMenu  **ppiMMCMenu [out] menu returned here if found
//    
// Output:
//      HRESULT
//
// Notes:
//
// Recursively searches the MMCMenus collection and children for an MMCMenu
// object that has the specified DISPID.
//
HRESULT CSnapIn::FindMenu(IMMCMenus *piMMCMenus, DISPID dispid, BOOL *pfFound, IMMCMenu **ppiMMCMenu)
{
    HRESULT         hr = S_OK;
    IMMCMenus      *piMMCChildMenus = NULL;
    CMMCMenus      *pMMCMenus = NULL;
    IMMCMenu       *piMMCMenu = NULL; // Not AddRef()ed
    CMMCMenu       *pMMCMenu = NULL;
    long            cObjects = 0;
    long            i = 0;

    *pfFound = FALSE;
    *ppiMMCMenu = NULL;

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenus, &pMMCMenus));
    cObjects = pMMCMenus->GetCount();

    for (i = 0; (i < cObjects) && (!*pfFound); i++)
    {
        // Get the next MMCMenu object
        
        piMMCMenu = pMMCMenus->GetItemByIndex(i);
        IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCMenu, &pMMCMenu));

        // If the DISPID is a match then we've found it
        
        if (pMMCMenu->GetDispid() == dispid)
        {
            *pfFound = TRUE;
            piMMCMenu->AddRef();
            *ppiMMCMenu = piMMCMenu;
        }
        else
        {
            // DISPID did not match. Get the children of the MMCMenu and
            // make a recursive call to search them.
            
            IfFailGo(piMMCMenu->get_Children(reinterpret_cast<MMCMenus **>(&piMMCChildMenus)));
            IfFailGo(FindMenu(piMMCChildMenus, dispid, pfFound, ppiMMCMenu));
            RELEASE(piMMCChildMenus);
        }
    }


Error:
    QUICK_RELEASE(piMMCChildMenus);
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                            IMMCRemote Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::ObjectIsRemote                                        [IMMCRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   None
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IMMCRemote::ObjectIsRemote
//
// Called from proxy in mmcproxy.dll to tell the runtime that it is running
// remotely. Used during debugging.
//
STDMETHODIMP CSnapIn::ObjectIsRemote()
{
    m_fWeAreRemote = TRUE;
    return S_OK;
}



//=--------------------------------------------------------------------------=
// CSnapIn::SetMMCExePath                                         [IMMCRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   char *pszPath [in] path to MMC.EXE
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IMMCRemote::SetMMCExePath
//
// Called from proxy in mmcproxy.dll to give the remotely running runtime
// the path to MMC.EXE.
//
STDMETHODIMP CSnapIn::SetMMCExePath(char *pszPath)
{
    HRESULT hr = S_OK;
    size_t  cbToCopy = 0;

    // The path may already have been set. The proxy makes this call in
    // both IComponentData::Initialize and IComponentData::CreateComponent.
    // See IComponentData_CreateComponent_Proxy in
    // \mmc.vb\vb98ctls\mmcproxy\proxy.c for why this is done.

    IfFalseGo(NULL == m_pwszMMCEXEPath, S_OK);

    IfFalseGo(NULL != pszPath, E_INVALIDARG);

    cbToCopy = (::strlen(pszPath) + 1) * sizeof(char);

    IfFalseGo(cbToCopy <= sizeof(m_szMMCEXEPath), E_INVALIDARG);

    ::memcpy(m_szMMCEXEPath, pszPath, cbToCopy);
    
    // Get the wide version also as various parts of the code will need it.

    IfFailGo(::WideStrFromANSI(m_szMMCEXEPath, &m_pwszMMCEXEPath));
    m_cbMMCExePathW = ::wcslen(m_pwszMMCEXEPath) * sizeof(WCHAR);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CSnapIn::SetMMCCommandLine                                     [IMMCRemote]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   char *pszCmdLine [in] command line used to start MMC.EXE
//    
// Output:
//      HRESULT
//
// Notes:
//
// Handles IMMCRemote::SetMMCCommandLine
//
// Called from proxy in mmcproxy.dll to give the remotely running runtime
// the MMC.EXE command line.
//
STDMETHODIMP CSnapIn::SetMMCCommandLine(char *pszCmdLine)
{
    HRESULT hr = S_OK;
    size_t  cbCmdLine = ::strlen(pszCmdLine) + 1;

    if (NULL != m_pszMMCCommandLine)
    {
        CtlFree(m_pszMMCCommandLine);
        m_pszMMCCommandLine = NULL;
    }

    m_pszMMCCommandLine = (char *)CtlAlloc(cbCmdLine);
    if (NULL == m_pszMMCCommandLine)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    ::memcpy(m_pszMMCCommandLine, pszCmdLine, cbCmdLine);
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// CSnapIn::InternalQueryInterface                            [CUnknownObject]
//=--------------------------------------------------------------------------=
//
// Parameters:
//   REFIID riid        [in] IID requested
//   void **ppvObjOut   [out] object interface returned
//    
// Output:
//      HRESULT
//
// Notes:
//
// Overrides CUnknownObject::InternalQueryInterface
//
// Called from the framework when it cannot answer a QI
//
HRESULT CSnapIn::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    HRESULT hr = S_OK;
    
    if ( (IID_ISnapIn == riid) || (m_IID == riid) )
    {
        *ppvObjOut = static_cast<ISnapIn *>(this);
        ExternalAddRef();
    }
    else if (IID_IPersistStream == riid)
    {
        // We need to support IPersistStream in addition to IPersistStreamInit
        // because the VB runtime will not pass IPersistStreamInit QIs from an
        // external source to the base class (meaning us). When MMC saves a
        // console file it QIs for IPersistStorage, IPersistStream and
        // IPersistStreamInit. As VB blocks IPersistStreamInit, supporting
        // IPersistStream is the only way to respond to this. When the snap-in
        // is loaded due to a CoCreateInstance call then the VB runtime QIs for
        // IPersistStreamInit.
        
        *ppvObjOut = static_cast<IPersistStream *>(this);
        ExternalAddRef();
    }
    else if (IID_IPersistStreamInit == riid)
    {
        *ppvObjOut = static_cast<IPersistStreamInit *>(this);
        ExternalAddRef();
    }
    else if (IID_IProvideDynamicClassInfo == riid)
    {
        *ppvObjOut = static_cast<IProvideDynamicClassInfo *>(this);
        ExternalAddRef();
    }
    else if (IID_IComponentData == riid)
    {
        *ppvObjOut = static_cast<IComponentData *>(this);
        ExternalAddRef();
    }
    else if (IID_ISnapinAbout == riid)
    {
        // This means that we were created for ISnapInAbout only and there
        // will be no opportunity to remove the object model host so remove
        // it now.
        IfFailGo(RemoveObjectModelHost(m_piSnapInDesignerDef));
        IfFailGo(RemoveObjectModelHost(static_cast<IContextMenu *>(m_pContextMenu)));
        IfFailGo(RemoveObjectModelHost(static_cast<IMMCControlbar *>(m_pControlbar)));
        m_RuntimeMode = siRTSnapInAbout;
        *ppvObjOut = static_cast<ISnapinAbout *>(this);
        ExternalAddRef();
    }
    else if (IID_IObjectModelHost == riid)
    {
        *ppvObjOut = static_cast<IObjectModelHost *>(this);
        ExternalAddRef();
    }
    else if (IID_IOleObject == riid)
    {
        *ppvObjOut = static_cast<IOleObject *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendContextMenu == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendContextMenu *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendControlbar == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendControlbar *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendControlbarRemote == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendControlbarRemote *>(this);
        ExternalAddRef();
    }
    else if ( (IID_IExtendPropertySheet == riid) ||
              (IID_IExtendPropertySheet2 == riid) )
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendPropertySheet2 *>(this);
        ExternalAddRef();
    }
    else if (IID_IExtendPropertySheetRemote == riid)
    {
        if (siRTUnknown == m_RuntimeMode)
        {
            if (siStandAlone == m_Type)
            {
                m_RuntimeMode = siRTPrimary;
            }
            else
            {
                m_RuntimeMode = siRTExtension;
            }
        }

        *ppvObjOut = static_cast<IExtendPropertySheetRemote *>(this);
        ExternalAddRef();
    }
    else if (IID_IRequiredExtensions == riid)
    {
        *ppvObjOut = static_cast<IRequiredExtensions *>(this);
        ExternalAddRef();
    }
    else if (IID_ISnapinHelp == riid)
    {
        *ppvObjOut = static_cast<ISnapinHelp *>(this);
        ExternalAddRef();
    }
    else if (IID_ISnapinHelp2 == riid)
    {
        *ppvObjOut = static_cast<ISnapinHelp2 *>(this);
        ExternalAddRef();
    }
    else if (IID_IMMCRemote == riid)
    {
        *ppvObjOut = static_cast<IMMCRemote *>(this);
        ExternalAddRef();
    }
    else
        hr = CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapin.h ===
//=--------------------------------------------------------------------------=
// snapin.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapIn class definition
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPIN_DEFINED_
#define _SNAPIN_DEFINED_

#include "dataobj.h"
#include "scopitms.h"
#include "scopitem.h"
#include "views.h"
#include "view.h"
#include "spanitms.h"
#include "resviews.h"
#include "extsnap.h"
#include "ctxtmenu.h"
#include "prpsheet.h"
#include "xtensons.h"
#include "xtenson.h"
#include "strtable.h"

class CMMCDataObject;
class CScopeItems;
class CScopeItem;
class CViews;
class CView;
class CScopePaneItems;
class CResultViews;
class CExtensionSnapIn;
class CContextMenu;
class CControlbar;
class CMMCStringTable;



//=--------------------------------------------------------------------------=
//
// class CSnapIn
//
// This is the object that the VB runtime will CoCreate and aggregate when
// MMC CoCreates the user's snap-in DLL created in the VB IDE.
// It implements IComponentData, persistence, interfaces required by the VB
// runtime, and MMC extension interfaces.
//
// at runtime, this class also serves as the object model host for the design
// time definition objects.
//=--------------------------------------------------------------------------=

class CSnapIn : public CSnapInAutomationObject,
                public ISnapIn,
                public IPersistStreamInit,
                public IPersistStream,
                public IObjectModelHost,
                public IProvideDynamicClassInfo,
                public IOleObject,
                public ISnapinAbout,
                public IComponentData,
                public IExtendContextMenu,
                public IExtendControlbar,
                public IExtendControlbarRemote,
                public IExtendPropertySheet2,
                public IExtendPropertySheetRemote,
                public IRequiredExtensions,
                public ISnapinHelp2,
                public IMMCRemote
{
    private:
        CSnapIn(IUnknown *punkOuter);
        ~CSnapIn();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();

    // IDispatch methods. Can't use DECLARE_STANDARD_DISPATCH() because
    // we need to handle dynamic property gets in Invoke for image lists,
    // toolbars, and menus

        STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
        STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut);
        STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames,
                                 UINT cnames, LCID lcid, DISPID *rgdispid);
        STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags,
                          DISPPARAMS *pdispparams, VARIANT *pVarResult,
                          EXCEPINFO *pexcepinfo, UINT *puArgErr);



    // ISnapIn
        BSTR_PROPERTY_RW(CSnapIn,    Name,                  DISPID_SNAPIN_NAME);
        BSTR_PROPERTY_RW(CSnapIn,    NodeTypeName,          DISPID_SNAPIN_NODE_TYPE_NAME);
        BSTR_PROPERTY_RO(CSnapIn,    NodeTypeGUID,          DISPID_SNAPIN_NODE_TYPE_GUID);

        BSTR_PROPERTY_RO(CSnapIn,    DisplayName,           DISPID_SNAPIN_DISPLAY_NAME);
        STDMETHOD(put_DisplayName)(BSTR bstrDisplayName);

        SIMPLE_PROPERTY_RW(CSnapIn,  Type,                  SnapInTypeConstants, DISPID_SNAPIN_TYPE);
        BSTR_PROPERTY_RW(CSnapIn,    HelpFile,              DISPID_SNAPIN_HELP_FILE);
        BSTR_PROPERTY_RW(CSnapIn,    LinkedTopics,          DISPID_SNAPIN_LINKED_TOPICS);
        BSTR_PROPERTY_RW(CSnapIn,    Description,           DISPID_SNAPIN_DESCRIPTION);
        BSTR_PROPERTY_RW(CSnapIn,    Provider,              DISPID_SNAPIN_PROVIDER);
        BSTR_PROPERTY_RW(CSnapIn,    Version,               DISPID_SNAPIN_VERSION);
        COCLASS_PROPERTY_RW(CSnapIn, SmallFolders,          MMCImageList, IMMCImageList, DISPID_SNAPIN_SMALL_FOLDERS);
        COCLASS_PROPERTY_RW(CSnapIn, SmallFoldersOpen,      MMCImageList, IMMCImageList, DISPID_SNAPIN_SMALL_FOLDERS_OPEN);
        COCLASS_PROPERTY_RW(CSnapIn, LargeFolders,          MMCImageList, IMMCImageList, DISPID_SNAPIN_LARGE_FOLDERS);
        OBJECT_PROPERTY_RW(CSnapIn,  Icon,                  IPictureDisp, DISPID_SNAPIN_ICON);
        OBJECT_PROPERTY_RW(CSnapIn,  Watermark,             IPictureDisp, DISPID_SNAPIN_WATERMARK);
        OBJECT_PROPERTY_RW(CSnapIn,  Header,                IPictureDisp, DISPID_SNAPIN_HEADER);
        OBJECT_PROPERTY_RW(CSnapIn,  Palette,               IPictureDisp, DISPID_SNAPIN_PALETTE);
        SIMPLE_PROPERTY_RW(CSnapIn,  StretchWatermark,      VARIANT_BOOL,  DISPID_SNAPIN_STRETCH_WATERMARK);
        VARIANT_PROPERTY_RO(CSnapIn, StaticFolder,          DISPID_SNAPIN_STATIC_FOLDER);
        STDMETHOD(put_StaticFolder)(VARIANT varFolder);
        COCLASS_PROPERTY_RO(CSnapIn, ScopeItems,            ScopeItems, IScopeItems, DISPID_SNAPIN_SCOPEITEMS);
        COCLASS_PROPERTY_RO(CSnapIn, Views,                 Views, IViews, DISPID_SNAPIN_VIEWS);
        COCLASS_PROPERTY_RO(CSnapIn, ExtensionSnapIn,       ExtensionSnapIn,     IExtensionSnapIn, DISPID_SNAPIN_EXTENSION_SNAPIN);
        COCLASS_PROPERTY_RO(CSnapIn, ScopePaneItems,        ScopePaneItems, IScopePaneItems, DISPID_SNAPIN_SCOPE_PANE_ITEMS);
        COCLASS_PROPERTY_RO(CSnapIn, ResultViews,           ResultViews, IResultViews, DISPID_SNAPIN_RESULT_VIEWS);
        SIMPLE_PROPERTY_RO(CSnapIn,  RuntimeMode,           SnapInRuntimeModeConstants, DISPID_SNAPIN_RUNTIME_MODE);

        STDMETHOD(get_TaskpadViewPreferred)(VARIANT_BOOL *pfvarPreferred);

        STDMETHOD(get_RequiredExtensions)(Extensions **ppExtensions);
        
        STDMETHOD(get_Clipboard)(MMCClipboard **ppMMCClipboard);

        SIMPLE_PROPERTY_RW(CSnapIn,  Preload, VARIANT_BOOL, DISPID_SNAPIN_PRELOAD);

        STDMETHOD(get_StringTable)(MMCStringTable **ppMMCStringTable);

        STDMETHOD(get_CurrentView)(View **ppView);
        STDMETHOD(get_CurrentScopePaneItem)(ScopePaneItem **ppScopePaneItem);
        STDMETHOD(get_CurrentScopeItem)(ScopeItem **ppScopeItem);
        STDMETHOD(get_CurrentResultView)(ResultView **ppResultView);
        STDMETHOD(get_CurrentListView)(MMCListView **ppListView);
        STDMETHOD(get_MMCCommandLine)(BSTR *pbstrCmdLine);

        STDMETHOD(ConsoleMsgBox)(BSTR     Prompt,
                                 VARIANT  Buttons,
                                 VARIANT  Title,
                                 int     *pnResult);

        STDMETHOD(ShowHelpTopic)(BSTR Topic);
        STDMETHOD(Trace)(BSTR Message);
        STDMETHOD(FireConfigComplete)(IDispatch *pdispConfigObject);
        STDMETHOD(FormatData)(VARIANT                Data,
                              long                   StartingIndex,
                              SnapInFormatConstants  Format,
                              VARIANT               *BytesUsed,
                              VARIANT               *pvarFormattedData);

    // IPersistStreamInit and IPersistStream methods
        STDMETHOD(GetClassID)(CLSID *pCLSID);
        STDMETHOD(IsDirty)();
        STDMETHOD(Load)(IStream *piStream);
        STDMETHOD(Save)(IStream *piStream, BOOL fClearDirty);
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *puliSize);
        STDMETHOD(InitNew)();

    // IProvideDynamicClassInfo
        STDMETHOD(GetClassInfo)(ITypeInfo **ppTypeInfo);
        STDMETHOD(GetDynamicClassInfo)(ITypeInfo **ppTypeInfo, DWORD *pdwCookie);
        STDMETHOD(FreezeShape)(void);

    // IOleObject

        STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
        STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
        STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp,
                               LPCOLESTR szContainerObj);
        STDMETHOD(Close)(DWORD dwSaveOption);
        STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker *pmk);
        STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker,
                             IMoniker **ppmk);
        STDMETHOD(InitFromData)(IDataObject *pDataObject,
                               BOOL fCreation,
                               DWORD dwReserved);
        STDMETHOD(GetClipboardData)(DWORD dwReserved,
                                   IDataObject **ppDataObject);
        STDMETHOD(DoVerb)(LONG iVerb,
                          LPMSG lpmsg,
                          IOleClientSite *pActiveSite,
                          LONG lindex,
                          HWND hwndParent,
                          LPCRECT lprcPosRect);
        STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
        STDMETHOD(Update)();
        STDMETHOD(IsUpToDate)();
        STDMETHOD(GetUserClassID)(CLSID *pClsid);
        STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
        STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
        STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
        STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
        STDMETHOD(Unadvise)(DWORD dwConnection);
        STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
        STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
        STDMETHOD(SetColorScheme)(LOGPALETTE *pLogpal);


    // ISnapinAbout
        STDMETHOD(GetSnapinDescription)(LPOLESTR *ppszDescription);

        STDMETHOD(GetProvider)(LPOLESTR *ppszName);

        STDMETHOD(GetSnapinVersion)(LPOLESTR *ppszVersion);

        STDMETHOD(GetSnapinImage)(HICON *phAppIcon);

        STDMETHOD(GetStaticFolderImage)(HBITMAP  *phSmallImage,
                                        HBITMAP  *phSmallImageOpen,
                                        HBITMAP  *phLargeImage,
                                        COLORREF *pclrMask);


    // IComponentData
        STDMETHOD(CompareObjects)(IDataObject *piDataObject1, IDataObject *piDataObject2);
        STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pItem);
        STDMETHOD(QueryDataObject)(long cookie, DATA_OBJECT_TYPES type, IDataObject ** ppiDataObject);
        STDMETHOD(Notify)(IDataObject *pDataObject, MMC_NOTIFY_TYPE event, long Arg, long Param);
        STDMETHOD(CreateComponent)(IComponent **ppiComponent);
        STDMETHOD(Initialize)(IUnknown *punkConsole);
        STDMETHOD(Destroy)();

    // IExtendControlbar
        STDMETHOD(SetControlbar)(IControlbar *piControlbar);
        STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,
                                    LPARAM arg, LPARAM param);

    // IExtendControlbarRemote
        STDMETHOD(MenuButtonClick)(IDataObject   *piDataObject,
                                   int             idCommand,
                                   POPUP_MENUDEF **ppPopupMenuDef);
        STDMETHOD(PopupMenuClick)(IDataObject *piDataObject,
                                  UINT         uIDItem,
                                  IUnknown    *punkParam);

    // IExtendContextMenu
        STDMETHOD(AddMenuItems)(IDataObject          *piDataObject,
                                IContextMenuCallback *piContextMenuCallback,
                                long                 *plInsertionAllowed);
        STDMETHOD(Command)(long lCommandID, IDataObject *piDataObject);

    // IExtendPropertySheet2
        STDMETHOD(CreatePropertyPages)(IPropertySheetCallback *piPropertySheetCallback,
                                       LONG_PTR handle,
                                       IDataObject *piDataObject);
        STDMETHOD(QueryPagesFor)(IDataObject *piDataObject);
        STDMETHOD(GetWatermarks)(IDataObject *piDataObject,
                                 HBITMAP     *phbmWatermark,
                                 HBITMAP     *phbmHeader,
                                 HPALETTE    *phPalette,
                                 BOOL        *bStretch);

    // IExtendPropertySheetRemote
        STDMETHOD(CreatePropertyPageDefs)(IDataObject          *piDataObject,
                                          WIRE_PROPERTYPAGES **ppPages);

    // IRequiredExtensions
        STDMETHOD(EnableAllExtensions)();
        STDMETHOD(GetFirstExtension)(CLSID *pclsidExtension);
        STDMETHOD(GetNextExtension)(CLSID *pclsidExtension);

    // ISnapinHelp
        STDMETHOD(GetHelpTopic)(LPOLESTR *ppwszHelpFile);

    // ISnapinHelp2
        STDMETHOD(GetLinkedTopics)(LPOLESTR *ppwszTopics);

    // IMMCRemote
        STDMETHOD(ObjectIsRemote)();
        STDMETHOD(SetMMCExePath)(char *pszPath);
        STDMETHOD(SetMMCCommandLine)(char *pszCmdLine);

    // IObjectModelHost
        STDMETHOD(Update)(long ObjectCookie, IUnknown *punkObject, DISPID dispid) { return S_OK; }
        STDMETHOD(Add)(long CollectionCookie, IUnknown *punkNewObject)  { return S_OK; }
        STDMETHOD(Delete)(long ObjectCookie, IUnknown *punkObject)  { return S_OK; }
        STDMETHOD(GetSnapInDesignerDef)(ISnapInDesignerDef **ppiSnapInDesignerDef);
        STDMETHOD(GetRuntime)(BOOL *pfRuntime);

    // Public utility methods
        ISnapInDef         *GetSnapInDef() { return m_piSnapInDef; }
        ISnapInDesignerDef *GetSnapInDesignerDef() { return m_piSnapInDesignerDef; }
        CScopeItem         *GetStaticNodeScopeItem() { return m_pStaticNodeScopeItem; }
        CScopeItems        *GetScopeItems() { return m_pScopeItems; }
        CScopePaneItems    *GetScopePaneItems() { return m_pScopePaneItems; }
        CResultViews       *GetResultViews() { return m_pResultViews; }
        IConsole2          *GetIConsole2() { return m_piConsole2; }
        IConsoleNameSpace2 *GetIConsoleNameSpace2() { return m_piConsoleNameSpace2; }
        CViews             *GetViews() { return m_pViews; }
        CView              *GetCurrentView() { return m_pCurrentView; }
        void                SetCurrentView(CView *pView) { m_pCurrentView = pView; }
        long                GetImageCount() { return m_cImages; }
        char               *GetMMCExePath() { return m_szMMCEXEPath; }
        WCHAR              *GetMMCExePathW() { return m_pwszMMCEXEPath; }
        BSTR                GetNodeTypeGUID() { return m_bstrNodeTypeGUID; }
        BSTR                GetDisplayName() { return m_bstrDisplayName; }
        HRESULT             GetSnapInPath(OLECHAR **ppwszPath,
                                          size_t   *pcbSnapInPath);
        SnapInRuntimeModeConstants GetRuntimeMode() { return m_RuntimeMode; }
        void SetRuntimeMode(SnapInRuntimeModeConstants Mode) { m_RuntimeMode = Mode; }
        DWORD GetInstanceID() { return m_dwInstanceID; }
        BOOL GetPreload() { return VARIANTBOOL_TO_BOOL(m_Preload); }
        void FireHelp() { FireEvent(&m_eiHelp); }
        SnapInTypeConstants GetType() { return m_Type; }
        HRESULT SetStaticFolder(VARIANT varFolder);
        BOOL WeAreRemote() { return m_fWeAreRemote; }

        // Sets SnapIn.DisplayName without changing it in MMC
        HRESULT SetDisplayName(BSTR bstrDisplayName);

        CExtensionSnapIn *GetExtensionSnapIn() { return m_pExtensionSnapIn; }
        CControlbar *GetControlbar() { return m_pControlbar; }

        // These methods are used to keep track of the currently active
        // controlbar. They are called by both CSnapIn's and CView's
        // IExtendControlbar method implementations on entry and exit to each
        // method of that interface. Tracking the active controlbar allows 
        // MMCToolbar to find the instance of IToolbar or IMenuButton that it
        // should use when the snap-in alters the toolbar or menubutton (e.g.
        // enable/disable buttons). This is necessary because a single MMCToolbar
        // object is shared among multiple views. This sharing allows events
        // to be on MMCToolbar rather than a collection of MMCToolbars.

        CControlbar* GetCurrentControlbar() { return m_pControlbarCurrent; }

        void SetCurrentControlbar(CControlbar* pControlbar)
        { m_pControlbarCurrent = pControlbar; }

        // Converts an unqualified URL to a fully qualified res:// URL for the
        // snap-in's DLL.

        HRESULT ResolveResURL(WCHAR *pwszURL, OLECHAR **ppwszResolvedURL);

        // Set and remove the object model host on design time definitions
        
        HRESULT SetDesignerDefHost();
        HRESULT RemoveDesignerDefHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        void ReleaseConsoleInterfaces();
        HRESULT AddScopeItemImages();
        HRESULT GetScopeItemImage(VARIANT varImageIndex, int *pnIndex);
        HRESULT SetSnapInPropertiesFromState();
        HRESULT GetStaticNodeDataObject(IDataObject       **ppiDataObject,
                                        DATA_OBJECT_TYPES   context);
        HRESULT SetObjectModelHost(IUnknown *punkObject);
        HRESULT RemoveObjectModelHost(IUnknown *punkObject);
        HRESULT SetObjectModelHostIfNotSet(IUnknown *punkObject, BOOL *pfWasSet);

        enum ExpandType { Expand, ExpandSync };
        
        HRESULT OnExpand(ExpandType Type, IDataObject *piDataObject,
                         BOOL fExpanded, HSCOPEITEM hsi, BOOL *pfHandled);
        HRESULT OnRename(IDataObject *piDataObject, OLECHAR *pwszNewName);
        HRESULT OnPreload(IDataObject *piDataObject, HSCOPEITEM hsi);
        HRESULT OnDelete(IDataObject *piDataObject);
        HRESULT OnRemoveChildren(IDataObject *piDataObject, HSCOPEITEM hsi);

        HRESULT FindMenu(IMMCMenus *piMMCMenus, DISPID dispid,
                         BOOL *pfFound, IMMCMenu **ppiMMCMenu);

        HRESULT AddDynamicNameSpaceExtensions(CScopeItem *pScopeItem);

        HRESULT GetScopeItemExtensions(CExtensions    *pExtensions,
                                       IScopeItemDefs *piScopeItemDefs);
        HRESULT GetListItemExtensions(CExtensions   *pExtensions,
                                      IListViewDefs *piListViewDefs);
        HRESULT FireReadProperties(IStream *piStream);
        HRESULT StoreStaticHSI(CScopeItem *pScopeItem,
                               CMMCDataObject *pMMCDataObject, HSCOPEITEM hsi);
        HRESULT ExtractBSTR(long cBytes, BSTR bstr, BSTR *pbstrOut, long *pcbUsed);
        HRESULT ExtractBSTRs(long cBytes, BSTR bstr, VARIANT *pvarOut, long *pcbUsed);
        HRESULT ExtractObject(long cBytes, void *pvData, IUnknown **ppunkObject, long *pcbUsed,
                              SnapInFormatConstants Format);
        HRESULT InternalCreatePropertyPages(IPropertySheetCallback  *piPropertySheetCallback,
                                            LONG_PTR                 handle,
                                            IDataObject             *piDataObject,
                                            WIRE_PROPERTYPAGES     **ppPages);
        HRESULT SetMMCExePath();
        HRESULT CompareListItems(CMMCListItem *pMMCListItem1,
                                 CMMCListItem *pMMCListItem2,
                                 BOOL         *pfEqual);


        ISnapInDesignerDef *m_piSnapInDesignerDef;   // serialized state
        ISnapInDef         *m_piSnapInDef;           // from serialzation
        IOleClientSite     *m_piOleClientSite;       // VB runtime client site
        CScopeItems        *m_pScopeItems;           // SnapIn.ScopeItems
        CScopeItem         *m_pStaticNodeScopeItem;  // ptr to ScopeItem for static node
        CExtensionSnapIn   *m_pExtensionSnapIn;      // SnapIn.ExtensionSnapIn
        CViews             *m_pViews;                // SnapIn.Views
        CView              *m_pCurrentView;          // SnapIn.CurrentView
        CScopePaneItems    *m_pScopePaneItems;       // hidden collection used
                                                     // for event firing only
        CResultViews       *m_pResultViews;          // same here
        IConsole2          *m_piConsole2;            // MMC interface
        IConsoleNameSpace2 *m_piConsoleNameSpace2;   // MMC interface
        IImageList         *m_piImageList;           // MMC interface
        IDisplayHelp       *m_piDisplayHelp;         // MMC interface
        IStringTable       *m_piStringTable;         // MMC interface
        HSCOPEITEM          m_hsiRootNode;           // HSCOPEITEM for static node
        BOOL                m_fHaveStaticNodeHandle; // TRUE=m_hsiRootNode is valid
        DWORD               m_dwTypeinfoCookie;      // for VB runtime, comes from serialization
        long                m_cImages;               // used to calculate image
                                                     // indexes for
                                                     // IComponentData::GetDisplayInfo
        IID                 m_IID;                   // dynamic IID from typeinfo

        CContextMenu       *m_pContextMenu;         // implements MMC's
                                                    // IExtendContextMenu and
                                                    // our IContextMenu


        CControlbar        *m_pControlbar;          // Implements MMC's
                                                    // IExtendControlbar and our
                                                    // IMMCControlbar

        CControlbar        *m_pControlbarCurrent;   // Pointer to CControlbar
                                                    // object currently executing
                                                    // an IExtendControlbar
                                                    // method. This could be
                                                    // the one belonging to
                                                    // CSnapIn (for extensions)
                                                    // or one belonging to a View

        BOOL                m_fWeAreRemote;         // indicates whether
                                                    // the snap-in is being
                                                    // run remotely (in an F5
                                                    // for source debugging)

        char                m_szMMCEXEPath[MAX_PATH];// When running remotely
                                                     // the proxy will give us
                                                     // MMC.EXE's path so we can
                                                     // build taskpad display
                                                     // strings. When running
                                                     // locally we initialize
                                                     // with GetModuleFileName().

        WCHAR              *m_pwszMMCEXEPath;        // Wide version of same
        size_t              m_cbMMCExePathW;         // size of it in bytes without
                                                     // terminating null char

        OLECHAR            *m_pwszSnapInPath;        // Fully qualified file
                                                     // name of snap-in's DLL.
                                                     // Used when resolving
                                                     // relative res:// URLs in
                                                     // a taskpad.
        size_t             m_cbSnapInPath;           // Length in bytes of path
                                                     // without terminating null.

        DWORD              m_dwInstanceID;           // Set with GetTickCount()
                                                     // to uniquely identify a
                                                     // a snap-in instance. Used
                                                     // when interpreting data
                                                     // objects to determine
                                                     // whether a VB sourced
                                                     // selection comes from the
                                                     // same snap-in.

        IExtensions       *m_piRequiredExtensions;   // From IDL. Collection
                                                     // of registered extensions
                                                     // for the snap-in.

        long               m_iNextExtension;         // Used to implement required
                                                     // extension enumeration for
                                                     // IRequiredExtensions

        IMMCStringTable   *m_piMMCStringTable;       // From IDL. StringTable
                                                     // object that wraps MMC's
                                                     // IStringTable.

        char              *m_pszMMCCommandLine;      // MMC command line set
                                                     // from proxy

        // Event parameter definitions
        
        static EVENTINFO m_eiLoad;

        static EVENTINFO m_eiUnload;

        static EVENTINFO m_eiHelp;

        static VARTYPE   m_rgvtQueryConfigurationWizard[1];
        static EVENTINFO m_eiQueryConfigurationWizard;

        static VARTYPE   m_rgvtCreateConfigurationWizard[1];
        static EVENTINFO m_eiCreateConfigurationWizard;

        static VARTYPE   m_rgvtConfigurationComplete[1];
        static EVENTINFO m_eiConfigurationComplete;

        static VARTYPE   m_rgvtWriteProperties[1];
        static EVENTINFO m_eiWriteProperties;

        static VARTYPE   m_rgvtReadProperties[1];
        static EVENTINFO m_eiReadProperties;

        static EVENTINFO m_eiPreload;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SnapIn,                 // name
                                &CLSID_SnapIn,          // clsid
                                "SnapIn",               // objname
                                "SnapIn",               // lblname
                                &CSnapIn::Create,       // creation function
                                TLIB_VERSION_MAJOR,     // major version
                                TLIB_VERSION_MINOR,     // minor version
                                &IID_ISnapIn,           // dispatch IID
                                &DIID_DSnapInEvents,    // event IID
                                HELP_FILENAME,          // help file
                                TRUE);                  // thread safe


#endif // _SNAPIN_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapindef.h ===
//=--------------------------------------------------------------------------=
// snapindef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDef class definition - implements design time definition object
//
//=--------------------------------------------------------------------------=

#ifndef _SNAPINDEF_DEFINED_
#define _SNAPINDEF_DEFINED_


class CSnapInDef : public CSnapInAutomationObject,
                   public CPersistence,
                   public ISnapInDef,
                   public IPerPropertyBrowsing
{
    private:
        CSnapInDef(IUnknown *punkOuter);
        ~CSnapInDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISnapInDef

        BSTR_PROPERTY_RW(CSnapInDef,        Name,                  DISPID_SNAPINDEF_NAME);
        BSTR_PROPERTY_RW(CSnapInDef,        NodeTypeName,          DISPID_SNAPINDEF_NODE_TYPE_NAME);
        BSTR_PROPERTY_RO(CSnapInDef,        NodeTypeGUID,          DISPID_SNAPINDEF_NODE_TYPE_GUID);
        BSTR_PROPERTY_RW(CSnapInDef,        DisplayName,           DISPID_SNAPINDEF_DISPLAY_NAME);
        SIMPLE_PROPERTY_RW(CSnapInDef,      Type,                  SnapInTypeConstants, DISPID_SNAPINDEF_TYPE);
        BSTR_PROPERTY_RW(CSnapInDef,        HelpFile,              DISPID_SNAPINDEF_HELP_FILE);
        BSTR_PROPERTY_RW(CSnapInDef,        LinkedTopics,          DISPID_SNAPINDEF_LINKED_TOPICS);
        BSTR_PROPERTY_RW(CSnapInDef,        Description,           DISPID_SNAPINDEF_DESCRIPTION);
        BSTR_PROPERTY_RW(CSnapInDef,        Provider,              DISPID_SNAPINDEF_PROVIDER);
        BSTR_PROPERTY_RW(CSnapInDef,        Version,               DISPID_SNAPINDEF_VERSION);

        STDMETHOD(get_SmallFolders)(IMMCImageList **ppiMMCImageList);
        STDMETHOD(putref_SmallFolders)(IMMCImageList *piMMCImageList);

        STDMETHOD(get_SmallFoldersOpen)(IMMCImageList **ppiMMCImageList);
        STDMETHOD(putref_SmallFoldersOpen)(IMMCImageList *piMMCImageList);

        STDMETHOD(get_LargeFolders)(IMMCImageList **ppiMMCImageList);
        STDMETHOD(putref_LargeFolders)(IMMCImageList *piMMCImageList);

        // For Icon we need some integrity checking on the put so declare a
        // an RO object property to let CSnapInAutomationObject handle the get
        // and then handle the put explicitly.
        
        OBJECT_PROPERTY_RO(CSnapInDef,      Icon,                  IPictureDisp, DISPID_SNAPINDEF_ICON);
        STDMETHOD(putref_Icon)(IPictureDisp *piIcon);


        OBJECT_PROPERTY_RW(CSnapInDef,      Watermark,             IPictureDisp, DISPID_SNAPINDEF_WATERMARK);
        OBJECT_PROPERTY_RW(CSnapInDef,      Header,                IPictureDisp, DISPID_SNAPINDEF_HEADER);
        OBJECT_PROPERTY_RW(CSnapInDef,      Palette,               IPictureDisp, DISPID_SNAPINDEF_PALETTE);
        SIMPLE_PROPERTY_RW(CSnapInDef,      StretchWatermark,      VARIANT_BOOL,  DISPID_SNAPINDEF_STRETCH_WATERMARK);

        VARIANT_PROPERTY_RO(CSnapInDef,     StaticFolder,          DISPID_SNAPINDEF_STATIC_FOLDER);
        STDMETHOD(put_StaticFolder)(VARIANT varFolder);

        BSTR_PROPERTY_RW(CSnapInDef,        DefaultView,           DISPID_SNAPINDEF_DEFAULTVIEW);
        SIMPLE_PROPERTY_RW(CSnapInDef,      Extensible,            VARIANT_BOOL, DISPID_SNAPINDEF_EXTENSIBLE);
        OBJECT_PROPERTY_RO(CSnapInDef,      ViewDefs,              IViewDefs, DISPID_SNAPINDEF_VIEWDEFS);
        OBJECT_PROPERTY_RO(CSnapInDef,      Children,              IScopeItemDefs, DISPID_SNAPINDEF_CHILDREN);
        BSTR_PROPERTY_RW(CSnapInDef,        IID,                   DISPID_SNAPINDEF_IID);
        SIMPLE_PROPERTY_RW(CSnapInDef,      Preload,               VARIANT_BOOL, DISPID_SNAPINDEF_PRELOAD);
      
     // IPerPropertyBrowsing
        STDMETHOD(GetDisplayString)(DISPID dispID, BSTR *pBstr);
        STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid);
        STDMETHOD(GetPredefinedStrings)(DISPID      dispID,
                                        CALPOLESTR *pCaStringsOut,
                                        CADWORD    *pCaCookiesOut);
        STDMETHOD(GetPredefinedValue)(DISPID   dispID,
                                      DWORD    dwCookie,
                                      VARIANT *pVarOut);

     // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();
        
    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

        // Variable to hold values for SnapInDef properties that have custom
        // get/put functions.

        IMMCImageList     *m_piSmallFolders;
        IMMCImageList     *m_piSmallFoldersOpen;
        IMMCImageList     *m_piLargeFolders;
        BSTR               m_bstrSmallFoldersKey;
        BSTR               m_bstrSmallFoldersOpenKey;
        BSTR               m_bstrLargeFoldersKey;

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[2]; // should be 3 when extension enabled again
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SnapInDef,           // name
                                &CLSID_SnapInDef,    // clsid
                                "SnapInDef",         // objname
                                "SnapInDef",         // lblname
                                &CSnapInDef::Create, // creation function
                                TLIB_VERSION_MAJOR,  // major version
                                TLIB_VERSION_MINOR,  // minor version
                                &IID_ISnapInDef,     // dispatch IID
                                NULL,                // event IID
                                HELP_FILENAME,       // help file
                                TRUE);               // thread safe


#endif // _SNAPINDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkey.cpp ===
//=--------------------------------------------------------------------------=
// sortkey.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCColumnHeader class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "sortkey.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CSortKey::CSortKey(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_SORTKEY,
                            static_cast<ISortKey *>(this),
                            static_cast<CSortKey *>(this),
                            0,     // no property pages
                            NULL,  // no property pages
                            NULL)  // no peristence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CSortKey::~CSortKey()
{
    FREESTRING(m_bstrKey);
    InitMemberVariables();
}

void CSortKey::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_Column = 0;
    m_SortOrder = siAscending;
    m_SortIcon = VARIANT_TRUE;
}


IUnknown *CSortKey::Create(IUnknown * punkOuter)
{
    CSortKey *pSortKey = New CSortKey(punkOuter);
    if (NULL == pSortKey)
    {
        return NULL;
    }
    else
    {
        return pSortKey->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSortKey::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_ISortKey == riid)
    {
        *ppvObjOut = static_cast<ISortKey *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkeys.h ===
//=--------------------------------------------------------------------------=
// sortkeys.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSortKeys class definition - implements SortKeys collection
//
//=--------------------------------------------------------------------------=

#ifndef _SORTKEYS_DEFINED_
#define _SORTKEYS_DEFINED_

#include "collect.h"
#include "view.h"

class CSortKeys : public CSnapInCollection<ISortKey, SortKey, ISortKeys>
{
    protected:
        CSortKeys(IUnknown *punkOuter);
        ~CSortKeys();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISortKeys
        BSTR_PROPERTY_RW(CSortKeys, ColumnSetID, DISPID_SORTKEYS_COLUMN_SET_ID);
        STDMETHOD(Add)(VARIANT   Index,
                       VARIANT   Key,
                       VARIANT   Column,
                       VARIANT   SortOrder,
                       VARIANT   SortIcon,
                       SortKey **ppSortKey);
        STDMETHOD(Persist)();

    // Public utility methods

    public:

        void SetView(CView *pView) { m_pView = pView; }
        CView *GetView() { return m_pView; }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        CView *m_pView; // back ptr to owning view
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SortKeys,           // name
                                &CLSID_SortKeys,    // clsid
                                "SortKeys",         // objname
                                "SortKeys",         // lblname
                                &CSortKeys::Create, // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ISortKeys,     // dispatch IID
                                NULL,               // no events IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _SORTKEYS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\snapindef.cpp ===
//=--------------------------------------------------------------------------=
// snapindef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSnapInDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "snapindef.h"

// for ASSERT and FAIL
//
SZTHISFILE



const GUID *CSnapInDef::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_SnapInDefGeneralPP,
    &CLSID_SnapInDefImageListPP,
    // &CLSID_SnapInDefExtensionsPP
};


#pragma warning(disable:4355)  // using 'this' in constructor

CSnapInDef::CSnapInDef(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SNAPINDEF,
                           static_cast<ISnapInDef *>(this),
                           static_cast<CSnapInDef *>(this),
                           sizeof(m_rgpPropertyPageCLSIDs) /
                               sizeof(m_rgpPropertyPageCLSIDs[0]),
                           m_rgpPropertyPageCLSIDs,
                           static_cast<CPersistence *>(this)),
   CPersistence(&CLSID_SnapInDef,
                g_dwVerMajor,
                g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CSnapInDef::~CSnapInDef()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrNodeTypeName);
    FREESTRING(m_bstrNodeTypeGUID);
    FREESTRING(m_bstrDisplayName);
    FREESTRING(m_bstrHelpFile);
    FREESTRING(m_bstrLinkedTopics);
    FREESTRING(m_bstrDescription);
    FREESTRING(m_bstrProvider);
    FREESTRING(m_bstrVersion);
    RELEASE(m_piSmallFolders);
    RELEASE(m_piSmallFoldersOpen);
    RELEASE(m_piLargeFolders);
    RELEASE(m_piIcon);
    RELEASE(m_piWatermark);
    RELEASE(m_piHeader);
    RELEASE(m_piPalette);
    (void)::VariantClear(&m_varStaticFolder);
    FREESTRING(m_bstrSmallFoldersKey);
    FREESTRING(m_bstrSmallFoldersOpenKey);
    FREESTRING(m_bstrLargeFoldersKey);
    FREESTRING(m_bstrDefaultView);
    RELEASE(m_piViewDefs);
    RELEASE(m_piChildren);
    FREESTRING(m_bstrIID);
    InitMemberVariables();
}

void CSnapInDef::InitMemberVariables()
{
    m_bstrName = NULL;
    m_bstrNodeTypeName = NULL;
    m_bstrNodeTypeGUID = NULL;
    m_bstrDisplayName = NULL;
    m_Type = siStandAlone;
    m_bstrHelpFile = NULL;
    m_bstrLinkedTopics = NULL;
    m_bstrDescription = NULL;
    m_bstrProvider = NULL;
    m_bstrVersion = NULL;
    m_piSmallFolders = NULL;
    m_piSmallFoldersOpen = NULL;
    m_piLargeFolders = NULL;
    m_piIcon = NULL;
    m_piWatermark = NULL;
    m_piHeader = NULL;
    m_piPalette = NULL;
    m_StretchWatermark = VARIANT_FALSE;

    ::VariantInit(&m_varStaticFolder);

    m_bstrSmallFoldersKey= NULL;
    m_bstrSmallFoldersOpenKey= NULL;
    m_bstrLargeFoldersKey= NULL;
    m_bstrDefaultView = NULL;
    m_Extensible = VARIANT_TRUE;
    m_piViewDefs = NULL;
    m_piChildren = NULL;
    m_bstrIID = NULL;
    m_Preload = VARIANT_FALSE;
}



IUnknown *CSnapInDef::Create(IUnknown * punkOuter)
{
    CSnapInDef *pSnapInDef = New CSnapInDef(punkOuter);
    if (NULL == pSnapInDef)
    {
        return NULL;
    }
    else
    {
        return pSnapInDef->PrivateUnknown();
    }
}



//=--------------------------------------------------------------------------=
//                       ISnapInDef Properties
//=--------------------------------------------------------------------------=

STDMETHODIMP CSnapInDef::get_SmallFolders(IMMCImageList **ppiMMCImageList)
{
    RRETURN(GetImages(ppiMMCImageList, m_bstrSmallFoldersKey, &m_piSmallFolders));
}

STDMETHODIMP CSnapInDef::putref_SmallFolders(IMMCImageList *piMMCImageList)
{
    RRETURN(SetImages(piMMCImageList, &m_bstrSmallFoldersKey, &m_piSmallFolders));
}


STDMETHODIMP CSnapInDef::get_SmallFoldersOpen(IMMCImageList **ppiMMCImageList)
{
    RRETURN(GetImages(ppiMMCImageList, m_bstrSmallFoldersOpenKey, &m_piSmallFoldersOpen));
}

STDMETHODIMP CSnapInDef::putref_SmallFoldersOpen(IMMCImageList *piMMCImageList)
{
    RRETURN(SetImages(piMMCImageList, &m_bstrSmallFoldersOpenKey, &m_piSmallFoldersOpen));
}


STDMETHODIMP CSnapInDef::get_LargeFolders(IMMCImageList **ppiMMCImageList)
{
    RRETURN(GetImages(ppiMMCImageList, m_bstrLargeFoldersKey, &m_piLargeFolders));
}

STDMETHODIMP CSnapInDef::putref_LargeFolders(IMMCImageList *piMMCImageList)
{
    RRETURN(SetImages(piMMCImageList, &m_bstrLargeFoldersKey, &m_piLargeFolders));
}


STDMETHODIMP CSnapInDef::putref_Icon(IPictureDisp *piIcon)
{
    HRESULT   hr = S_OK;
    IPicture *piPicture = NULL;
    short     PictureType = PICTYPE_UNINITIALIZED;

    if (NULL == piIcon)
    {
        hr = SID_E_CANT_DELETE_ICON;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(piIcon->QueryInterface(IID_IPicture,
                                    reinterpret_cast<void **>(&piPicture)));

    IfFailGo(piPicture->get_Type(&PictureType));

    if (PICTYPE_ICON != PictureType)
    {
        hr = SID_E_ICON_REQUIRED;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(SetObject(piIcon, IID_IPictureDisp, &m_piIcon,
                       DISPID_SNAPINDEF_ICON));

Error:
    QUICK_RELEASE(piPicture);
    RRETURN(hr);
}


STDMETHODIMP CSnapInDef::put_StaticFolder(VARIANT varFolder)
{
    HRESULT hr = S_OK;
    long    lFolder = 0;

    // This property can be entered in the property browser at design time.
    // Its default value is an empty string. If the user types in a number
    // then VB will convert it to a string. If the user does not use the
    // same number as the key of the image, then the runtime won't find the
    // image. To prevent this, we check if the property is a string, and if so,
    // then we check if it is only digits. If it is only digits then we convert
    // it to VT_I4.

    if (VT_BSTR == varFolder.vt)
    {
        hr = ::ConvertToLong(varFolder, &lFolder);
        if (S_OK == hr)
        {
            varFolder.vt = VT_I4;
            varFolder.lVal = lFolder;
        }
    }
    IfFailGo(SetVariant(varFolder, &m_varStaticFolder, DISPID_SNAPINDEF_STATIC_FOLDER));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                 IPerPropertyBrowsing Properties
//=--------------------------------------------------------------------------=

STDMETHODIMP CSnapInDef::GetDisplayString(DISPID dispID, BSTR *pBstr)
{
    *pBstr = NULL;
    return E_NOTIMPL;
}


STDMETHODIMP CSnapInDef::MapPropertyToPage(DISPID dispID, CLSID *pClsid)
{
    return E_NOTIMPL;
}


STDMETHODIMP CSnapInDef::GetPredefinedStrings
(
    DISPID      dispID,
    CALPOLESTR *pCaStringsOut,
    CADWORD    *pCaCookiesOut
)
{
    // Initialize structures because VB doesn't always pass them in intialized

    if (NULL != pCaStringsOut)
    {
        pCaStringsOut->cElems = 0;
        pCaStringsOut->pElems = NULL;
    }

    if (NULL != pCaCookiesOut)
    {
        pCaCookiesOut->cElems = 0;
        pCaCookiesOut->pElems = NULL;
    }
    return E_NOTIMPL;
}


STDMETHODIMP CSnapInDef::GetPredefinedValue
(
    DISPID   dispID,
    DWORD    dwCookie,
    VARIANT *pVarOut
)
{
    ::VariantInit(pVarOut);
    return E_NOTIMPL;
}



//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDef::Persist()
{
    HRESULT hr = S_OK;
    GUID    NodeTypeGUID = GUID_NULL;
    HICON   hiconDefault = NULL;

    WCHAR   wszNodeTypeGUID[64];
    ::ZeroMemory(wszNodeTypeGUID, sizeof(wszNodeTypeGUID));

    VARIANT varIndexDefault;
    ::VariantInit(&varIndexDefault);

    varIndexDefault.vt = VT_I4;
    varIndexDefault.lVal = 0;

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistBstr(&m_bstrNodeTypeName, L"", OLESTR("NodeTypeName")));

    // On InitNew generate a node type GUID

    if (InitNewing())
    {
        hr = ::CoCreateGuid(&NodeTypeGUID);
        EXCEPTION_CHECK_GO(hr);
        if (0 == ::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                                   sizeof(wszNodeTypeGUID) /
                                   sizeof(wszNodeTypeGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    IfFailGo(PersistBstr(&m_bstrNodeTypeGUID, wszNodeTypeGUID, OLESTR("NodeTypeGUID")));

    // If this is a project being loaded from a template then NodeTypeGUID will
    // be all zeroes. We use this is as a flag to indicate that a new GUID needs
    // to be created.

    if (Loading())
    {
        hr = ::CLSIDFromString(m_bstrNodeTypeGUID, &NodeTypeGUID);
        EXCEPTION_CHECK_GO(hr);
        if (GUID_NULL == NodeTypeGUID)
        {
            hr = ::CoCreateGuid(&NodeTypeGUID);
            EXCEPTION_CHECK_GO(hr);
            if (0 == ::StringFromGUID2(NodeTypeGUID, wszNodeTypeGUID,
                                       sizeof(wszNodeTypeGUID) /
                                       sizeof(wszNodeTypeGUID[0])))
            {
                hr = SID_E_INTERNAL;
                EXCEPTION_CHECK_GO(hr);
            }

            FREESTRING(m_bstrNodeTypeGUID);
            m_bstrNodeTypeGUID = ::SysAllocString(wszNodeTypeGUID);
            if (NULL == m_bstrNodeTypeGUID)
            {
                hr = SID_E_OUTOFMEMORY;
                EXCEPTION_CHECK_GO(hr);
            }
        }
    }

    IfFailGo(PersistBstr(&m_bstrDisplayName, L"", OLESTR("DisplayName")));

    IfFailGo(PersistSimpleType(&m_Type, siStandAlone, OLESTR("Type")));

    IfFailGo(PersistBstr(&m_bstrHelpFile, L"", OLESTR("HelpFile")));

    // If we are loading from a persistence version < 0,2 then skip LinkedTopics

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 2) )
    {
    }
    else
    {
        IfFailGo(PersistBstr(&m_bstrLinkedTopics, L"", OLESTR("LinkedTopics")));
    }

    IfFailGo(PersistBstr(&m_bstrDescription, L"", OLESTR("Description")));

    IfFailGo(PersistBstr(&m_bstrProvider, L"", OLESTR("Provider")));

    IfFailGo(PersistBstr(&m_bstrVersion, L"", OLESTR("Version")));

    IfFailGo(PersistBstr(&m_bstrSmallFoldersKey, L"", OLESTR("SmallFolders")));

    if (InitNewing())
    {
        RELEASE(m_piSmallFolders);
    }

    IfFailGo(PersistBstr(&m_bstrSmallFoldersOpenKey, L"", OLESTR("SmallFoldersOpen")));

    if (InitNewing())
    {
        RELEASE(m_piSmallFoldersOpen);
    }

    IfFailGo(PersistBstr(&m_bstrLargeFoldersKey, L"", OLESTR("LargeFolders")));

    if (InitNewing())
    {
        RELEASE(m_piLargeFolders);
    }

    if (InitNewing())
    {
        // For a new snap-in use the MMC icon as the default
        hiconDefault = ::LoadIcon(GetResourceHandle(),
                                  MAKEINTRESOURCE(IDI_ICON_DEFAULT));
        if (NULL == hiconDefault)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }
        IfFailGo(::CreateIconPicture(&m_piIcon, hiconDefault));
        // Note that if we could not create the picture there is no need
        // to call ::DestroyIcon() as icons loaded from a resource are
        // not explicitly destoryed
    }
    else
    {
        IfFailRet(PersistPicture(&m_piIcon, OLESTR("Icon")));
    }

    if ( (Loading()) && (0 == GetMinorVersion()) && (0 == GetMajorVersion()) )
    {
        // Version 0.0 did not yet have watermarks so don't try to load them.
        // In this case we need to create empty pictures for the new properties.

        IfFailGo(::CreateEmptyBitmapPicture(&m_piWatermark));
        IfFailGo(::CreateEmptyBitmapPicture(&m_piHeader));
        IfFailGo(::CreateEmptyBitmapPicture(&m_piPalette));
    }
    else
    {
        IfFailRet(PersistPicture(&m_piWatermark, OLESTR("Watermark")));

        IfFailRet(PersistPicture(&m_piHeader, OLESTR("Header")));

        IfFailRet(PersistPicture(&m_piPalette, OLESTR("Palette")));

        IfFailGo(PersistSimpleType(&m_StretchWatermark, VARIANT_FALSE, OLESTR("StretchWatermark")));
    }

    IfFailGo(PersistVariant(&m_varStaticFolder, varIndexDefault, OLESTR("StaticFolder")));

    IfFailGo(PersistBstr(&m_bstrDefaultView, L"", OLESTR("DefaultView")));

    IfFailGo(PersistSimpleType(&m_Extensible, VARIANT_TRUE, OLESTR("Extensible")));

    IfFailGo(PersistObject(&m_piViewDefs, CLSID_ViewDefs,
                           OBJECT_TYPE_VIEWDEFS, IID_IViewDefs,
                           OLESTR("ViewDefs")));

    IfFailGo(PersistObject(&m_piChildren, CLSID_ScopeItemDefs,
                           OBJECT_TYPE_SCOPEITEMDEFS, IID_IScopeItemDefs,
                           OLESTR("Children")));

    IfFailGo(PersistBstr(&m_bstrIID, L"", OLESTR("IID")));

    IfFailGo(PersistSimpleType(&m_Preload, VARIANT_FALSE, OLESTR("Preload")));

    // Tell ViewDefs that all collections should serialize keys only as the
    // actual objects are stored in the master collections owned by
    // SnapInDesignerDef. We only need to serialize the view names.

    if (InitNewing())
    {
        IfFailGo(UseKeysOnly(m_piViewDefs));
    }

Error:
   RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ISnapInDef == riid)
    {
        *ppvObjOut = static_cast<ISnapInDef *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IPerPropertyBrowsing == riid)
    {
        *ppvObjOut = static_cast<IPerPropertyBrowsing *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}


//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSnapInDef::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piChildren));
    IfFailRet(SetObjectHost(m_piViewDefs));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkey.h ===
//=--------------------------------------------------------------------------=
// sortkey.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CSortKey class definition - implememnts SortKey object
//
//=--------------------------------------------------------------------------=

#ifndef _SORTKEY_DEFINED_
#define _SORTKEY_DEFINED_

#include "colhdrs.h"

class CSortKey : public CSnapInAutomationObject,
                 public ISortKey
{
    private:
        CSortKey(IUnknown *punkOuter);
        ~CSortKey();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ISortKey

    public:

        SIMPLE_PROPERTY_RW(CSortKey, Index,     long,                     DISPID_SORTKEY_INDEX);
        BSTR_PROPERTY_RW(CSortKey,   Key,                                 DISPID_SORTKEY_KEY);
        SIMPLE_PROPERTY_RW(CSortKey, Column,    long,                     DISPID_SORTKEY_COLUMN);
        SIMPLE_PROPERTY_RW(CSortKey, SortOrder, SnapInSortOrderConstants, DISPID_SORTKEY_SORTORDER);
        SIMPLE_PROPERTY_RW(CSortKey, SortIcon,  VARIANT_BOOL,             DISPID_SORTKEY_SORTICON);

    // Public Utility methods

    public:

        long GetIndex() { return m_Index; }
        long GetColumn() { return m_Column; }
        SnapInSortOrderConstants GetSortOrder() { return m_SortOrder; }
        BOOL GetSortIcon() { return VARIANTBOOL_TO_BOOL(m_SortIcon); }

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(SortKey,            // name
                                &CLSID_SortKey,     // clsid
                                "SortKey",          // objname
                                "SortKey",          // lblname
                                &CSortKey::Create,  // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ISortKey,      // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _SORTKEY_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\sortkeys.cpp ===
//=--------------------------------------------------------------------------=
// sortkeys.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CColumnSettings class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "sortkeys.h"
#include "sortkey.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CSortKeys::CSortKeys(IUnknown *punkOuter) :
    CSnapInCollection<ISortKey, SortKey, ISortKeys>(
                      punkOuter,
                      OBJECT_TYPE_SORTKEYS,
                      static_cast<ISortKeys *>(this),
                      static_cast<CSortKeys *>(this),
                      CLSID_SortKey,
                      OBJECT_TYPE_SORTKEY,
                      IID_ISortKey,
                      NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CSortKeys::InitMemberVariables()
{
    m_pView = NULL;
    m_bstrColumnSetID = NULL;
}

CSortKeys::~CSortKeys()
{
    InitMemberVariables();
    FREESTRING(m_bstrColumnSetID);
}

IUnknown *CSortKeys::Create(IUnknown * punkOuter)
{
    CSortKeys *pSortKeys = New CSortKeys(punkOuter);
    if (NULL == pSortKeys)
    {
        return NULL;
    }
    else
    {
        return pSortKeys->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                      ISortKeys Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CSortKeys::Add
(
    VARIANT   Index,
    VARIANT   Key,
    VARIANT   Column,
    VARIANT   SortOrder,
    VARIANT   SortIcon,
    SortKey **ppSortKey
)
{
    HRESULT   hr = S_OK;
    ISortKey *piSortKey = NULL;
    CSortKey *pSortKey = NULL;
    long      lIndex = 0;

    VARIANT varCoerced;
    ::VariantInit(&varCoerced);

    hr = CSnapInCollection<ISortKey, SortKey, ISortKeys>::Add(Index, Key, &piSortKey);
    IfFailGo(hr);

    if (ISPRESENT(Column))
    {
        hr = ::VariantChangeType(&varCoerced, &Column, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piSortKey->put_Column(varCoerced.lVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(SortOrder))
    {
        hr = ::VariantChangeType(&varCoerced, &SortOrder, 0, VT_I4);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piSortKey->put_SortOrder(static_cast<SnapInSortOrderConstants>(varCoerced.lVal)));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    if (ISPRESENT(SortIcon))
    {
        hr = ::VariantChangeType(&varCoerced, &SortIcon, 0, VT_BOOL);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piSortKey->put_SortIcon(varCoerced.boolVal));
    }

    hr = ::VariantClear(&varCoerced);
    EXCEPTION_CHECK_GO(hr);

    *ppSortKey = reinterpret_cast<SortKey *>(piSortKey);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piSortKey);
    }
    (void)::VariantClear(&varCoerced);
    RRETURN(hr);
}


STDMETHODIMP CSortKeys::Persist()
{
    HRESULT        hr = S_OK;
    IColumnData   *piColumnData = NULL; // Not AddRef()ed
    long           i = 0;
    long           cSortKeys = 0;
    MMC_SORT_DATA *pSortData;
    CSortKey      *pSortKey = NULL;
    SColumnSetID  *pSColumnSetID = NULL;

    MMC_SORT_SET_DATA SortSetData;
    ::ZeroMemory(&SortSetData, sizeof(SortSetData));

    if (NULL == m_pView)
    {
        hr = SID_E_DETACHED_OBJECT;
        EXCEPTION_CHECK_GO(hr);
    }

    piColumnData = m_pView->GetIColumnData();
    if (NULL == piColumnData)
    {
        hr = SID_E_MMC_FEATURE_NOT_AVAILABLE;
        EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(::GetColumnSetID(m_bstrColumnSetID, &pSColumnSetID));

    SortSetData.cbSize = sizeof(SortSetData);
    cSortKeys = GetCount();

    if (0 == cSortKeys)
    {
        SortSetData.nNumItems = 0;
        SortSetData.pSortData = NULL;
    }
    else
    {
        SortSetData.nNumItems = static_cast<int>(cSortKeys);
        SortSetData.pSortData = (MMC_SORT_DATA *)CtlAllocZero(cSortKeys * sizeof(MMC_SORT_DATA));
        if (NULL == SortSetData.pSortData)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        for (i = 0, pSortData = SortSetData.pSortData;
             i < cSortKeys;
             i++, pSortData++)
        {
            IfFailGo(CSnapInAutomationObject::GetCxxObject(GetItemByIndex(i),
                                                           &pSortKey));
            if (siDescending == pSortKey->GetSortOrder())
            {
                pSortData->dwSortOptions = RSI_DESCENDING;
            }

            if (VARIANT_FALSE == pSortKey->GetSortIcon())
            {
                pSortData->dwSortOptions |= RSI_NOSORTICON;
            }
            pSortData->nColIndex = static_cast<int>(pSortKey->GetColumn() - 1L);
        }
    }

    hr = piColumnData->SetColumnSortData(pSColumnSetID, &SortSetData);
    EXCEPTION_CHECK_GO(hr);

Error:
    if (NULL != pSColumnSetID)
    {
        CtlFree(pSColumnSetID);
    }
    if (NULL != SortSetData.pSortData)
    {
        CtlFree(SortSetData.pSortData);
    }
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CSortKeys::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if(IID_ISortKeys == riid)
    {
        *ppvObjOut = static_cast<ISortKeys *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<ISortKey, SortKey, ISortKeys>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitem.cpp ===
//=--------------------------------------------------------------------------=
// spanitem.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItem class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "snapin.h"
#include "views.h"
#include "spanitem.h"
#include "ocxvdef.h"
#include "urlvdef.h"
#include "tpdvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

#pragma warning(disable:4355)  // using 'this' in constructor

CScopePaneItem::CScopePaneItem(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_SCOPEPANEITEM,
                           static_cast<IScopePaneItem *>(this),
                           static_cast<CScopePaneItem *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CScopePaneItem::~CScopePaneItem()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrDisplayString);
    FREESTRING(m_bstrPreferredTaskpad);
    RELEASE(m_piResultView);
    RELEASE(m_piResultViews);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrColumnSetID);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    FREESTRING(m_bstrDefaultDisplayString);
    RELEASE(m_piScopeItemDef);
    FREESTRING(m_bstrTitleText);
    FREESTRING(m_bstrBodyText);
    InitMemberVariables();
}

void CScopePaneItem::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Index = 0;
    m_bstrKey = NULL;
    m_piScopeItem = NULL;
    m_ResultViewType = siUnknown;
    m_bstrDisplayString = NULL;
    m_HasListViews = VARIANT_FALSE;
    m_piResultView = NULL;
    m_piResultViews = NULL;
    m_fvarSelected = VARIANT_FALSE;
    m_piParent = NULL;

    ::VariantInit(&m_varTag);

    m_bstrColumnSetID = NULL;
    m_fIsStatic = FALSE;
    m_pSnapIn = NULL;
    m_pScopeItem = NULL;
    m_pResultView = NULL;
    m_pResultViews = NULL;
    m_pScopePaneItems = NULL;
    m_ActualResultViewType = siUnknown;
    m_pwszActualDisplayString = NULL;
    m_DefaultResultViewType = siUnknown;
    m_bstrDefaultDisplayString = NULL;
    m_bstrPreferredTaskpad = NULL;
    m_piScopeItemDef = NULL;
    m_fActive = FALSE;
    m_bstrTitleText = NULL;
    m_bstrBodyText = NULL;
    m_IconType = siIconNone;
    m_fHaveMessageViewParams = FALSE;
}

IUnknown *CScopePaneItem::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkScopePaneItem = NULL;
    IUnknown *punkResultViews = NULL;

    CScopePaneItem *pScopePaneItem = New CScopePaneItem(punkOuter);

    IfFalseGo(NULL != pScopePaneItem, SID_E_OUTOFMEMORY);
    punkScopePaneItem = pScopePaneItem->PrivateUnknown();

    punkResultViews = CResultViews::Create(NULL);
    IfFalseGo(NULL != punkResultViews, SID_E_OUTOFMEMORY);
    IfFailGo(punkResultViews->QueryInterface(IID_IResultViews,
                                  reinterpret_cast<void **>(&pScopePaneItem->m_piResultViews)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkResultViews, &pScopePaneItem->m_pResultViews));
    pScopePaneItem->m_pResultViews->SetScopePaneItem(pScopePaneItem);

Error:
    QUICK_RELEASE(punkResultViews);
    if (FAILED(hr))
    {
        RELEASE(punkScopePaneItem);
    }
    return punkScopePaneItem;
}


void CScopePaneItem::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
    m_pResultViews->SetSnapIn(pSnapIn);
}

void CScopePaneItem::SetScopeItem(CScopeItem *pScopeItem)
{
    m_pScopeItem = pScopeItem;
    m_piScopeItem = static_cast<IScopeItem *>(pScopeItem);
}


void CScopePaneItem::SetResultView(CResultView *pResultView)
{
    m_pResultView = pResultView;
    RELEASE(m_piResultView);
    m_piResultView = static_cast<IResultView *>(pResultView);
    m_piResultView->AddRef();
}


void CScopePaneItem::SetParent(CScopePaneItems *pScopePaneItems)
{
    m_pScopePaneItems = pScopePaneItems;
    m_piParent = static_cast<IScopePaneItems *>(pScopePaneItems);
}

void CScopePaneItem::SetScopeItemDef(IScopeItemDef *piScopeItemDef)
{
    RELEASE(m_piScopeItemDef);
    piScopeItemDef->AddRef();
    m_piScopeItemDef = piScopeItemDef;
}


//=--------------------------------------------------------------------------=
// CScopePaneItem::DetermineResultView
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Fires GetResultViewInfo. If handled then sets ResultViewType
// and ResultViewDisplayString from returned values, creates a new result view
// of this type and sets ResultView.
//
// If not handled and the ResultViews collection is not empty then fires
// GetResultView.
//
// If not handled or the collection is empty then uses current ResultViewType
// and ResultViewDisplayString, creates a new result view of this type and sets
// ResultView.
//
// If the current ResultViewType is siUnknown then it is set to siListView.
// This means that if the VB dev does not set anything at design time or runtime
// the snap-in will display a listview.
//
// If a new ResultView is created then ResultViews_Initialize is fired. 
//
// If this function returns successfully then ResultViewType,
// ResultViewDisplayString, and ResultView have valid values.

HRESULT CScopePaneItem::DetermineResultView()
{
    HRESULT                        hr = S_OK;
    SnapInResultViewTypeConstants  ViewTypeCopy = siUnknown;
    BSTR                           bstrDisplayStringCopy = NULL;
    long                           cResultViews = 0;
    IResultView                   *piResultView = NULL;
    BOOL                           fEventHandled = FALSE;
    BOOL                           fNeedNewResultView = TRUE;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Get the default result view type and display string. See the comment
    // header for SetViewInfoFromDefaults() for an explanation of how defaults
    // can be set. If defaults were not set then a code-defined listview is used
    // i.e. ResultViewType=siListView and DisplayString=NULL. Either way, upon
    // return from this call m_ResultViewType and m_bstrDisplayString will be
    // set correctly.

    IfFailGo(SetViewInfoFromDefaults());

    // Give the snap-in a chance to examine and potentially change the result 
    // view type and display string by firing ScopePaneItems_GetResultViewInfo.
    // Set the passed in parameters to the defaults. Make a copy of the defaults
    // so we can check whether they were changed.

    ViewTypeCopy = m_ResultViewType;
    if (NULL != m_bstrDisplayString)
    {
        // Note that we can't just copy the pointer because:
        // 1) We don't know whether VBA might optimize the replacement of
        // an out parameters by reusing the same space when it fits.
        // 2) oleaut32.dll does BSTR memory caching and it could easily
        // reuse the same memory if VBA calls SysFreeString() followed by
        // SysAllocString() for something that fits.

        bstrDisplayStringCopy = ::SysAllocString(m_bstrDisplayString);
        if (NULL == bstrDisplayStringCopy)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

    m_pSnapIn->GetScopePaneItems()->FireGetResultViewInfo(
                                            static_cast<IScopePaneItem *>(this),
                                            &m_ResultViewType,
                                            &m_bstrDisplayString);

    // If the snap-in set the display string to an empty string ("") then
    // free that string and change it to NULL.

    if (NULL != m_bstrDisplayString)
    {
        if (L'\0' == *m_bstrDisplayString)
        {
            FREESTRING(m_bstrDisplayString);
        }
    }

    // Determine whether the snap-in handled the event i.e. changed the view
    // type or display string
    
    if (ViewTypeCopy != m_ResultViewType)
    {
        fEventHandled = TRUE;
    }
    else
    {
        if (NULL == bstrDisplayStringCopy)
        {
            if (NULL != m_bstrDisplayString)
            {
                fEventHandled = TRUE;
            }
        }
        else // display string before event was non-NULL
        {
            if (NULL == m_bstrDisplayString) // Did snap-in change it to NULL?
            {
                fEventHandled = TRUE;
            }
            else if (::wcscmp(m_bstrDisplayString, bstrDisplayStringCopy) != 0)
            {
                // string contents have changed
                fEventHandled = TRUE;
            }
        }
    }

    if (!fEventHandled)
    {
        // GetResultViewInfo was not handled. If there are any existing result
        // views then try ScopePaneItems_GetResultView to allow the snap-in to
        // choose one for reuse.

        IfFailGo(m_piResultViews->get_Count(&cResultViews));
        if (0 != cResultViews)
        {
            fEventHandled = m_pSnapIn->GetScopePaneItems()->FireGetResultView(
                                            static_cast<IScopePaneItem *>(this),
                                            &varIndex);
            if (fEventHandled)
            {
                // Event was handled. Check for valid index. If not then use
                // current type and display string.

                hr = m_piResultViews->get_Item(varIndex, reinterpret_cast<ResultView **>(&piResultView));
                EXCEPTION_CHECK_GO(hr);

                fNeedNewResultView = FALSE;
            }
        }
    }

    if (fNeedNewResultView)
    {
        // We need a new result view. Create one and set its type and
        // display string from what we just established above.

        IfFailGo(CreateNewResultView(MMC_VIEW_OPTIONS_NONE, &piResultView));
    }
    else
    {
        // We're using an existing result view. Update the ScopePaneItem's
        // view type, display string, actual view type, and actual display string

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piResultView, &m_pResultView));

        IfFailGo(piResultView->get_Type(&m_ResultViewType));
        FREESTRING(m_bstrDisplayString);
        IfFailGo(piResultView->get_DisplayString(&m_bstrDisplayString));

        m_ActualResultViewType = m_pResultView->GetActualType();

        if (NULL != m_pwszActualDisplayString)
        {
            ::CoTaskMemFree(m_pwszActualDisplayString);
            m_pwszActualDisplayString = NULL;
        }

        if (NULL != m_pResultView->GetActualDisplayString())
        {
            IfFailGo(::CoTaskMemAllocString(m_pResultView->GetActualDisplayString(),
                                            &m_pwszActualDisplayString));
        }
    }

    RELEASE(m_piResultView);
    m_piResultView = piResultView;
    piResultView = NULL;

Error:
    ASSERT(NULL != m_pResultView, "CScopePaneItem::DetermineResultView did not set a current result view");

    FREESTRING(bstrDisplayStringCopy);
    QUICK_RELEASE(piResultView);
    (void)::VariantClear(&varIndex);

    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
// CScopePaneItem::CreateNewResultView
//=--------------------------------------------------------------------------=
//
// Parameters:
//   long          lViewOptions  [in]  For listviews, any MMC_VIEW_OPTIONS_XXX
//                                     or MMC_VIEW_OPTIONS_NONE
//   IResultView **ppiResultView [out] new ResultView object returned here
//
// Output:
//      HRESULT
//
// Notes:
//
// This function adds a new ResultView to ScopePaneItem.ResultViews, set its
// display string and type, sets its actual string and type, sets
// ResultView.ListView properties from the view options, makes it the
// current ResultView (i.e. sets m_pResultView pointing to it), and fires
// ResultViews_Initialize. Returns IResultView on the new ResultView.
//

HRESULT CScopePaneItem::CreateNewResultView(long lViewOptions, IResultView **ppiResultView)
{
    HRESULT      hr = S_OK;
    IResultView *piResultView = NULL;
    BSTR         bstrDefaultItemTypeGUID = NULL;
    WCHAR        wszDefaultItemTypeGUID[64] = L"";
    GUID         guidDefaultItemType = GUID_NULL;

    VARIANT varUnspecified;
    UNSPECIFIED_PARAM(varUnspecified);

    IfFailGo(m_piResultViews->Add(varUnspecified, varUnspecified, &piResultView));
    IfFailGo(piResultView->put_Type(m_ResultViewType));
    IfFailGo(piResultView->put_DisplayString(m_bstrDisplayString));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piResultView, &m_pResultView));
    m_pResultView->SetSnapIn(m_pSnapIn);
    m_pResultView->SetScopePaneItem(this);

    // At this point the result view type is set but it may be predefined
    // at design time. Now Determine the real result view type and, if it's
    // a listview or taskpad, initialize ResultView.Listview or
    // ResultView.Taskpad from the design time settings (e.g. column header
    // definitions, images, tasks, etc).

    IfFailGo(DetermineActualResultViewType());

    // If this is a listview or a listpad then set HasListViews so the View
    // object can determine whether to allow listview options on the view menu.

    if ( (siListView == m_ActualResultViewType) ||
         (siListpad == m_ActualResultViewType) )
    {
        m_HasListViews = VARIANT_TRUE;
    }

    // Tell the ResultView the truth about its real nature

    m_pResultView->SetActualType(m_ActualResultViewType);
    m_pResultView->SetActualDisplayString(m_pwszActualDisplayString);

    // Set properties based on view options

    if ( (lViewOptions & MMC_VIEW_OPTIONS_MULTISELECT) != 0 )
    {
        m_pResultView->GetListView()->SetMultiSelect(TRUE);
    }

    if ( (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) != 0 )
    {
        m_pResultView->GetListView()->SetVirtual(TRUE);
    }

    // If this is a code-defined listview then give the result view
    // a default item type GUID. The snap-in can always change it, but this
    // will prevent errors if the snap-in decides to access
    // MMCListItem.DynamicExtensions if the item type GUID has not been set by
    // the snap-in and has not been set from a default in a pre-defined listview.

    if ( (siPreDefined != m_ResultViewType) &&
         (siListView == m_ActualResultViewType) )
    {
        hr = ::CoCreateGuid(&guidDefaultItemType);
        EXCEPTION_CHECK_GO(hr);

        if (0 == ::StringFromGUID2(guidDefaultItemType, wszDefaultItemTypeGUID,
                                   sizeof(wszDefaultItemTypeGUID) /
                                   sizeof(wszDefaultItemTypeGUID[0])))
        {
            hr = SID_E_INTERNAL;
            EXCEPTION_CHECK_GO(hr);
        }

        bstrDefaultItemTypeGUID = ::SysAllocString(wszDefaultItemTypeGUID);
        if (NULL == bstrDefaultItemTypeGUID)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        IfFailGo(m_pResultView->put_DefaultItemTypeGUID(bstrDefaultItemTypeGUID));
    }
    else if (siMessageView == m_ActualResultViewType)
    {
        // This is a message view. If there are preset parameters from a
        // previous call to DisplayMessageView then set them in
        // ResultView.MessageView.

        if (m_fHaveMessageViewParams)
        {
            // reset the flag so that DisplayMessageView can be used again
            m_fHaveMessageViewParams = FALSE;

            IfFailGo(m_pResultView->GetMessageView()->put_TitleText(m_bstrTitleText));
            FREESTRING(m_bstrTitleText);

            IfFailGo(m_pResultView->GetMessageView()->put_BodyText(m_bstrBodyText));
            FREESTRING(m_bstrBodyText);

            IfFailGo(m_pResultView->GetMessageView()->put_IconType(m_IconType));
        }
    }

    // At this point the new ResultView is fully initialized and we can
    // let the user muck with it in ResultViews_Initialize

    m_pResultView->SetInInitialize(TRUE);
    m_pSnapIn->GetResultViews()->FireInitialize(piResultView);
    m_pResultView->SetInInitialize(FALSE);

Error:
    FREESTRING(bstrDefaultItemTypeGUID);
    if (FAILED(hr))
    {
        QUICK_RELEASE(piResultView);
    }
    else
    {
        *ppiResultView = piResultView;
    }
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
// CScopePaneItem::SetViewInfoFromDefaults
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// The snap-in may have set ScopePaneItem.ResultViewType and
// ScopePaneItem.ResultViewDisplayString or they may have been set in response
// to a View menu selection. If ResultViewType is siUnknown then we assume that
// it has not been set and we use the default values. Default values are
// assigned at design time by setting the default view on a scope item
// defintion.
// If there is no default value the we use a listview.
//

HRESULT CScopePaneItem::SetViewInfoFromDefaults()
{
    HRESULT      hr = S_OK;
    BSTR         bstrDisplayString = NULL;
    VARIANT_BOOL fvarTaskpadViewPreferred = VARIANT_FALSE;

    // If ResultViewType has been set then use it

    IfFalseGo(siUnknown == m_ResultViewType, S_OK);

    // Dump the old display string. Even if we fail to allocate a new one
    // the NULL will default to a listview.

    FREESTRING(m_bstrDisplayString);
    m_ResultViewType = siListView;

    // Check if the user set the "taskpad view preferred" option in MMC

    IfFailGo(m_pSnapIn->get_TaskpadViewPreferred(&fvarTaskpadViewPreferred));

    // If it is set then and there is a taskpad defined for this
    // scope item that is to be used in this case, then use it.

    if ( (VARIANT_TRUE == fvarTaskpadViewPreferred) &&
         (NULL != m_bstrPreferredTaskpad) )
    {
        bstrDisplayString = m_bstrPreferredTaskpad;
        m_ResultViewType = siPreDefined;
    }
    else if (siUnknown != m_DefaultResultViewType)
    {
        // Not using a taskpad because of the user option.
        // Take default if there is one

        bstrDisplayString = m_bstrDefaultDisplayString;
        m_ResultViewType = m_DefaultResultViewType;
    }
    else
    {
        // There is no default. Use a listview.

        m_ResultViewType = siListView;
    }

    // If there is a display string then set it.

    if (NULL != bstrDisplayString)
    {
        m_bstrDisplayString = ::SysAllocString(bstrDisplayString);
        if (NULL == m_bstrDisplayString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }

Error:
    RRETURN(hr);
}


HRESULT CScopePaneItem::SetDefaultDisplayString(BSTR bstrString)
{
    HRESULT hr = S_OK;
    BSTR bstrNewString = NULL;

    if (NULL != bstrString)
    {
        bstrNewString = ::SysAllocString(bstrString);
        if (NULL == bstrNewString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    FREESTRING(m_bstrDefaultDisplayString);
    m_bstrDefaultDisplayString = bstrNewString;

Error:
    RRETURN(hr);
}

HRESULT CScopePaneItem::SetPreferredTaskpad(BSTR bstrViewName)
{
    HRESULT hr = S_OK;
    BSTR bstrNewString = NULL;

    if (NULL != bstrViewName)
    {
        bstrNewString = ::SysAllocString(bstrViewName);
        if (NULL == bstrNewString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
    }
    FREESTRING(m_bstrPreferredTaskpad);
    m_bstrPreferredTaskpad = bstrNewString;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CScopePaneItem::DetermineActualResultViewType
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// Upon entry to this function the ResultViewType and ResultViewDisplayString
// properties are set both in the ScopePaneItem and in the current result view
// pointed to by m_pResultView.
//
// If the result view type is predefined then the definition must be read
// and the actual type and display string returned.
//
// If the type is a listview and the type came from a design time setting,
// the ListViewDef.ListView is cloned into ResultView.ListView.
//
// The same is done for a taskpad into ResultView.Taskpad
// 
// For OCX and URL views only the type and ProgID/URL are needed from the
// the design time definition.
//
// In all cases, this function sets m_ActualResultViewType and
// m_pwszActualDisplayString. 


HRESULT CScopePaneItem::DetermineActualResultViewType()
{
    HRESULT           hr = S_OK;
    IViewDefs        *piViewDefs = NULL;

    IListViewDefs    *piListViewDefs = NULL;
    IListViewDef     *piListViewDef = NULL;

    IOCXViewDefs     *piOCXViewDefs = NULL;
    IOCXViewDef      *piOCXViewDef = NULL;
    COCXViewDef      *pOCXViewDef = NULL;
    CLSID             clsidOCX = CLSID_NULL;

    IURLViewDefs     *piURLViewDefs = NULL;
    IURLViewDef      *piURLViewDef = NULL;
    CURLViewDef      *pURLViewDef = NULL;

    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    CTaskpadViewDef  *pTaskpadViewDef = NULL;

    BSTR              bstrDisplayString = NULL;
    VARIANT_BOOL      fvarAlwaysCreateNewOCX = VARIANT_FALSE;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varTag;
    ::VariantInit(&varTag);

    // If the view is not predefined then use the type and display string as is
    // for all but message view. In that case we need to set the actual display
    // string to MMC's message view OCX CLSID.

    if (siPreDefined != m_ResultViewType)
    {
        m_ActualResultViewType = m_ResultViewType;

        if (siMessageView == m_ResultViewType)
        {
            hr = ::StringFromCLSID(CLSID_MessageView,
                                   &m_pwszActualDisplayString);
            EXCEPTION_CHECK_GO(hr);
        }
        else
        {
            IfFailGo(::CoTaskMemAllocString(m_bstrDisplayString,
                                            &m_pwszActualDisplayString));
        }
        return S_OK;
    }

    // The view is predefined. Need to get its definition.

    IfFailGo(m_pSnapIn->GetSnapInDesignerDef()->get_ViewDefs(&piViewDefs));

    // It could be any type of view so try each one.

    varKey.vt = VT_BSTR;
    varKey.bstrVal = m_bstrDisplayString;

    // Dump the old actual view info and default to listview.

    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
        m_pwszActualDisplayString = NULL;
    }
    m_ActualResultViewType = siListView;

    // Check for a list view

    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));

    hr = piListViewDefs->get_Item(varKey, &piListViewDef);
    if (SUCCEEDED(hr))
    {
        // It's a listview. Type and display string are already set but
        // we need to clone the listview configuration set at design time.
        IfFailGo(CloneListView(piListViewDef));
        goto Error;
    }
    else 
    {
        // Make sure the error is "element not found" before trying other types
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

    // Check for an OCX view

    IfFailGo(piViewDefs->get_OCXViews(&piOCXViewDefs));

    hr = piOCXViewDefs->get_Item(varKey, &piOCXViewDef);
    if (SUCCEEDED(hr))
    {
        IfFailGo(piOCXViewDef->get_ProgID(&bstrDisplayString));

        hr = ::CLSIDFromProgID(bstrDisplayString, &clsidOCX);
        EXCEPTION_CHECK_GO(hr);

        hr = ::StringFromCLSID(clsidOCX, &m_pwszActualDisplayString);
        EXCEPTION_CHECK_GO(hr);

        // Record the actual display string in the view def so that our
        // MMCN_RESTORE_VIEW handler can find the view def.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piOCXViewDef, &pOCXViewDef));
        IfFailGo(pOCXViewDef->SetActualDisplayString(m_pwszActualDisplayString));

        IfFailGo(piOCXViewDef->get_AlwaysCreateNewOCX(&fvarAlwaysCreateNewOCX));
        m_pResultView->SetAlwaysCreateNewOCX(fvarAlwaysCreateNewOCX);

        IfFailGo(piOCXViewDef->get_Tag(&varTag));
        IfFailGo(m_pResultView->put_Tag(varTag));

        m_ActualResultViewType = siOCXView;
        goto Error;
    }
    else 
    {
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

    // Check if default is a URL view

    IfFailGo(piViewDefs->get_URLViews(&piURLViewDefs));

    hr = piURLViewDefs->get_Item(varKey, &piURLViewDef);
    if (SUCCEEDED(hr))
    {
        IfFailGo(piURLViewDef->get_URL(&bstrDisplayString));
        IfFailGo(::CoTaskMemAllocString(bstrDisplayString,
                                        &m_pwszActualDisplayString));

        // Record the actual display string in the view def so that our
        // MMCN_RESTORE_VIEW handler can find the view def.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piURLViewDef, &pURLViewDef));
        IfFailGo(pURLViewDef->SetActualDisplayString(m_pwszActualDisplayString));

        IfFailGo(piURLViewDef->get_Tag(&varTag));
        IfFailGo(m_pResultView->put_Tag(varTag));

        m_ActualResultViewType = siURLView;
        goto Error;
    }
    else 
    {
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

    // Check for a taskpad

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));

    hr = piTaskpadViewDefs->get_Item(varKey, &piTaskpadViewDef);
    if (SUCCEEDED(hr))
    {
        // It's a taskpad. We need to clone the taskpad configuration set
        // at design time.
        IfFailGo(CloneTaskpadView(piTaskpadViewDef));

        IfFailGo(BuildTaskpadDisplayString(piListViewDefs));

        // Record the actual display string in the view def so that our
        // MMCN_RESTORE_VIEW handler can find the view def.

        IfFailGo(CSnapInAutomationObject::GetCxxObject(piTaskpadViewDef, &pTaskpadViewDef));
        IfFailGo(pTaskpadViewDef->SetActualDisplayString(m_pwszActualDisplayString));
    }
    else 
    {
        // Make sure the error is "element not found" before trying other types
        IfFalseGo(SID_E_ELEMENT_NOT_FOUND == hr, hr);
    }

Error:
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    QUICK_RELEASE(piListViewDef);
    QUICK_RELEASE(piOCXViewDefs);
    QUICK_RELEASE(piOCXViewDef);
    QUICK_RELEASE(piURLViewDefs);
    QUICK_RELEASE(piURLViewDef);
    QUICK_RELEASE(piTaskpadViewDefs);
    QUICK_RELEASE(piTaskpadViewDef);
    RRETURN(hr);
}


HRESULT CScopePaneItem::CloneListView(IListViewDef *piListViewDef)
{
    HRESULT             hr = S_OK;
    IMMCListView       *piMMCListViewDT = NULL;
    IMMCListView       *piMMCListViewRT = NULL;
    BSTR                bstrItemTypeGUID = NULL;

    // Get the design time and runtime listview objects. Clone the runtime
    // from the design time.

    IfFailGo(piListViewDef->get_ListView(&piMMCListViewDT));
    IfFailGo(m_pResultView->get_ListView(reinterpret_cast<MMCListView **>(&piMMCListViewRT)));
    IfFailGo(::CloneObject(piMMCListViewDT, piMMCListViewRT));

    IfFailGo(piListViewDef->get_DefaultItemTypeGUID(&bstrItemTypeGUID));
    IfFailGo(m_pResultView->put_DefaultItemTypeGUID(bstrItemTypeGUID));

Error:
    QUICK_RELEASE(piMMCListViewDT);
    QUICK_RELEASE(piMMCListViewRT);
    FREESTRING(bstrItemTypeGUID);
    RRETURN(hr);
}



HRESULT CScopePaneItem::CloneTaskpadView(ITaskpadViewDef *piTaskpadViewDef)
{
    HRESULT   hr = S_OK;
    ITaskpad *piTaskpadDT = NULL;
    ITaskpad *piTaskpadRT = NULL;

    // Get the design time and runtime Taskpadview objects

    IfFailGo(piTaskpadViewDef->get_Taskpad(&piTaskpadDT));
    IfFailGo(m_pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpadRT)));
    IfFailGo(::CloneObject(piTaskpadDT, piTaskpadRT));

Error:
    QUICK_RELEASE(piTaskpadDT);
    QUICK_RELEASE(piTaskpadRT);
    RRETURN(hr);
}



HRESULT CScopePaneItem::BuildTaskpadDisplayString(IListViewDefs *piListViewDefs)
{
    HRESULT                     hr = S_OK;
    ITaskpad                   *piTaskpad = NULL;
    IListViewDef               *piListViewDef = NULL;
    OLECHAR                    *pwszMMCExePath = NULL;
    OLECHAR                    *pwszHash = NULL;
    size_t                      cchMMCExePath = 0;
    size_t                      cchString = 0;
    BSTR                        bstrURL = NULL;
    BSTR                        bstrName = NULL;
    size_t                      cchName = 0;
    size_t                      cchListpad = 0;
    WCHAR                      *pwszListpadHtm = NULL;
    SnapInTaskpadTypeConstants  TaskpadType = Default;
    SnapInListpadStyleConstants ListpadStyle = siVertical;

    VARIANT varKey;
    ::VariantInit(&varKey);

    // Determine the taskpad type so that we can build the display string.

    IfFailGo(m_pResultView->get_Taskpad(reinterpret_cast<Taskpad **>(&piTaskpad)));
    IfFailGo(piTaskpad->get_Type(&TaskpadType));

    if ( (Default == TaskpadType) || (Listpad == TaskpadType) )
    {
        // Using an MMC template.
        // The URL needs to be
        // res://<MMC.EXE full path>/<template name>#<taskpad name>

        // Get the EXE path as a wide string
        
        pwszMMCExePath = m_pSnapIn->GetMMCExePathW();

        cchMMCExePath = ::wcslen(pwszMMCExePath);

        // Get the taskpad name to follow the "#"

        IfFailGo(piTaskpad->get_Name(&bstrName));

        cchName = ::wcslen(bstrName);

        // Determine the buffer size needed and allocate it. Add 1 for the "#"
        // and 1 for the terminating null.

        cchString = CCH_RESURL + cchMMCExePath + cchName + 2;

        if (Default == TaskpadType)
        {
            cchString += CCH_DEFAULT_TASKPAD;
            m_ActualResultViewType = siTaskpad;
        }
        else
        {
            IfFailGo(piTaskpad->get_ListpadStyle(&ListpadStyle));

            if (siVertical == ListpadStyle)
            {
                cchString += CCH_LISTPAD;
                cchListpad = CCH_LISTPAD;
                pwszListpadHtm = LISTPAD;
            }
            else
            {
                cchString += CCH_LISTPAD_HORIZ;
                cchListpad = CCH_LISTPAD_HORIZ;
                pwszListpadHtm = LISTPAD_HORIZ;
            }
            m_ActualResultViewType = siListpad;
        }

        m_pwszActualDisplayString =
                          (OLECHAR *)::CoTaskMemAlloc(cchString * sizeof(WCHAR));

        if (NULL == m_pwszActualDisplayString)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }

        // Concatenate the pieces ("res://", path, .htm, "#", and taskpad name)

        ::memcpy(m_pwszActualDisplayString, RESURL, CCH_RESURL * sizeof(WCHAR));

        ::memcpy(&m_pwszActualDisplayString[CCH_RESURL], pwszMMCExePath,
                 cchMMCExePath * sizeof(WCHAR));

        if (Default == TaskpadType)
        {
            ::memcpy(&m_pwszActualDisplayString[CCH_RESURL + cchMMCExePath],
                     DEFAULT_TASKPAD,
                     CCH_DEFAULT_TASKPAD * sizeof(WCHAR));

            pwszHash = &m_pwszActualDisplayString[CCH_RESURL +
                                                  cchMMCExePath +
                                                  CCH_DEFAULT_TASKPAD];
        }
        else
        {
            ::memcpy(&m_pwszActualDisplayString[CCH_RESURL + cchMMCExePath],
                     pwszListpadHtm,
                     cchListpad * sizeof(WCHAR));

            pwszHash = &m_pwszActualDisplayString[CCH_RESURL +
                                                  cchMMCExePath +
                                                  cchListpad];
        }

        *pwszHash = L'#';

        // Concatenate the name (along with its terminating null)
        
        ::memcpy(pwszHash + 1, bstrName, (cchName + 1) * sizeof(WCHAR));
    }
    else // custom taskpad
    {
        // Get the URL for the taskpad template as that is the display string

        IfFailGo(piTaskpad->get_URL(&bstrURL));
        IfFailGo(m_pSnapIn->ResolveResURL(bstrURL, &m_pwszActualDisplayString));
        m_ActualResultViewType = siCustomTaskpad;
    }

    // If not a listpad then we're done
    
    IfFalseGo(Listpad == TaskpadType, S_OK);

    // It is a listpad, If there is an associated listview definition then
    // we node to clone it into ResultView.ListView just as we would for a
    // listview.

    IfFailGo(piTaskpad->get_ListView(&varKey.bstrVal));
    varKey.vt = VT_BSTR;

    // Assume a NULL or zero length string means no listview

    IfFalseGo(ValidBstr(varKey.bstrVal), S_OK);

    // Get the listview definition

    hr = piListViewDefs->get_Item(varKey, &piListViewDef);
    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_UNKNOWN_LISTVIEW;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    // Clone it into ResultView.ListView

    IfFailGo(CloneListView(piListViewDef));
    
Error:
    QUICK_RELEASE(piTaskpad);
    QUICK_RELEASE(piListViewDef);
    FREESTRING(bstrName);
    FREESTRING(bstrURL);
    (void)::VariantClear(&varKey);
    RRETURN(hr);
}



HRESULT CScopePaneItem::DestroyResultView()
{
    HRESULT hr = S_OK;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    IfFalseGo(NULL != m_pResultView, S_OK);

    varIndex.vt = VT_I4;

    IfFailGo(m_piResultView->get_Index(&varIndex.lVal));
    IfFailGo(m_piResultViews->Remove(varIndex));

    m_pSnapIn->GetResultViews()->FireTerminate(m_piResultView);

    RELEASE(m_piResultView);

    m_pResultView = NULL;

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CScopePaneItem::OnListViewSelected()
//=--------------------------------------------------------------------------=
//
// Parameters:
//
// Output:
//      HRESULT
//
// Notes:
//
// If a non-listview is in the result pane for this scope item and the
// user selects one of the listviews from the View menu (small, large,
// list, detailed, filtered), then CContextMenu::Command() will call this
// function. This function searches for the first pre-defined listview for the
// scope item. If found is sets m_bstrDisplayString to the listview name and
// m_ResultViewType to siPredefined. If the scope item does not have any
// predefined listviews then it sets m_bstrDisplayString to NULL and 
// m_ResultViewType to siListView, which indicates a code-defined listview.
// During MMC's subsequent IComponent::GetResultViewType() call, CView will
// call DetermineResultView() and that function will use the values set here.
//
HRESULT CScopePaneItem::OnListViewSelected()
{
    HRESULT        hr = S_OK;
    IScopeItemDef *piScopeItemDef = NULL; // not AddRef()ed
    IViewDefs     *piViewDefs = NULL;
    IListViewDefs *piListViewDefs = NULL;
    IListViewDef  *piListViewDef = NULL;
    long           cListViewDefs = 0;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // Set up for a code-defined listview. If we find a predefined listview then
    // we'll change it.

    FREESTRING(m_bstrDisplayString);
    m_ResultViewType = siListView;

    // If this is the static node then get its view definitions
    if (m_fIsStatic)
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_ViewDefs(&piViewDefs));
    }
    else
    {
        // Not the static node.
        // Is there a design time definition for this scope item?

        piScopeItemDef = m_pScopeItem->GetScopeItemDef();
        IfFalseGo(NULL != piScopeItemDef, S_OK);

        // Get the listview definitions

        IfFailGo(piScopeItemDef->get_ViewDefs(&piViewDefs));
    }

    IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));

    // Check that there is at least one listview defined
    
    IfFailGo(piListViewDefs->get_Count(&cListViewDefs));
    IfFalseGo(0 != cListViewDefs, S_OK);

    // Get the name of the listview and set it as the display string.
    // Set the type to siPreDefined.
    
    varIndex.vt = VT_I4;
    varIndex.lVal = 1L;
    IfFailGo(piListViewDefs->get_Item(varIndex, &piListViewDef));
    IfFailGo(piListViewDef->get_Name(&m_bstrDisplayString));

    m_ResultViewType = siPreDefined;
    
Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      IScopePaneItem Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CScopePaneItem::DisplayNewResultView
(
    BSTR                          DisplayString, 
    SnapInResultViewTypeConstants ViewType
)
{
    HRESULT    hr = S_OK;
    HSCOPEITEM hsi = NULL;

    // Set our display string and view type from parameters

    IfFailGo(SetBstr(DisplayString, &m_bstrDisplayString,
                     DISPID_SCOPEPANEITEM_DISPLAY_STRING));

    IfFailGo(SetSimpleType(ViewType, &m_ResultViewType,
                           DISPID_SCOPEPANEITEM_RESULTVIEW_TYPE));

    // Crawl up the hierarchy to the view that owns this scope pane item
    // and get its IConsole2 to reselect the scope item.

    hsi = m_pScopeItem->GetScopeNode()->GetHSCOPEITEM();

    hr = m_pScopePaneItems->GetParentView()->GetIConsole2()->SelectScopeItem(hsi);
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


STDMETHODIMP CScopePaneItem::DisplayMessageView
(
    BSTR                               TitleText,
    BSTR                               BodyText,
    SnapInMessageViewIconTypeConstants IconType
)
{
    HRESULT    hr = S_OK;

    // Store the parameters so that we can set them when the new result view
    // is created.

    FREESTRING(m_bstrTitleText);
    FREESTRING(m_bstrBodyText);

    if (NULL == TitleText)
    {
        TitleText = L"";
    }
    
    if (NULL == BodyText)
    {
        BodyText = L"";
    }

    m_bstrTitleText = ::SysAllocString(TitleText);
    m_bstrBodyText = ::SysAllocString(BodyText);
    if ( (NULL == m_bstrTitleText) || (NULL == m_bstrBodyText) )
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }
    m_IconType = IconType;
    m_fHaveMessageViewParams = TRUE;

    // Initiate display of the new result view.

    IfFailGo(DisplayNewResultView(NULL, siMessageView));

Error:
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopePaneItem::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IScopePaneItem == riid)
    {
        *ppvObjOut = static_cast<IScopePaneItem *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopePaneItem::OnSetHost()
{
    HRESULT hr = S_OK;

    IfFailRet(SetObjectHost(m_piResultViews));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\stub_mmc_i.c ===
#include <mmc_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitem.h ===
//=--------------------------------------------------------------------------=
// spanitem.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItem class definition - implements ScopePaneItem object
//
//=--------------------------------------------------------------------------=

#ifndef _SPANITEM_DEFINED_
#define _SPANITEM_DEFINED_

#include "dataobj.h"
#include "scopitem.h"
#include "spanitms.h"
#include "resviews.h"
#include "resview.h"

class CScopeItem;
class CScopePaneItems;
class CResultView;

class CScopePaneItem : public CSnapInAutomationObject,
                       public IScopePaneItem
{
    private:
        CScopePaneItem(IUnknown *punkOuter);
        ~CScopePaneItem();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IScopePaneItem
        BSTR_PROPERTY_RW(CScopePaneItem,        Name,                       DISPID_SCOPEPANEITEM_NAME);
        SIMPLE_PROPERTY_RW(CScopePaneItem,      Index,                      long, DISPID_SCOPEPANEITEM_INDEX);
        BSTR_PROPERTY_RW(CScopePaneItem,        Key,                        DISPID_SCOPEPANEITEM_KEY);
        COCLASS_PROPERTY_RO(CScopePaneItem,     ScopeItem,                  ScopeItem, IScopeItem, DISPID_SCOPEPANEITEM_SCOPEITEM);
        SIMPLE_PROPERTY_RW(CScopePaneItem,      ResultViewType,             SnapInResultViewTypeConstants, DISPID_SCOPEPANEITEM_RESULTVIEW_TYPE);
        BSTR_PROPERTY_RW(CScopePaneItem,        DisplayString,              DISPID_SCOPEPANEITEM_DISPLAY_STRING);
        SIMPLE_PROPERTY_RW(CScopePaneItem,      HasListViews,               VARIANT_BOOL, DISPID_SCOPEPANEITEM_HAS_LISTVIEWS);
        COCLASS_PROPERTY_RO(CScopePaneItem,     ResultView,                 ResultView, IResultView, DISPID_SCOPEPANEITEM_RESULTVIEW);
        COCLASS_PROPERTY_RO(CScopePaneItem,     ResultViews,                ResultViews, IResultViews, DISPID_SCOPEPANEITEM_RESULTVIEWS);
        BSTR_PROPERTY_RW(CScopePaneItem,        ColumnSetID,                DISPID_SCOPEPANEITEM_COLUMN_SET_ID);

        COCLASS_PROPERTY_RO(CScopePaneItem,     Parent,                     ScopePaneItems, IScopePaneItems, DISPID_SCOPEPANEITEM_PARENT);
        VARIANTREF_PROPERTY_RW(CScopePaneItem,  Tag,                        DISPID_SCOPEPANEITEM_TAG);

        STDMETHOD(DisplayNewResultView)(BSTR DisplayString, 
                                        SnapInResultViewTypeConstants ViewType);

        STDMETHOD(DisplayMessageView)(BSTR                               TitleText,
                                      BSTR                               BodyText,
                                      SnapInMessageViewIconTypeConstants IconType);

    // Public utility methods

        BOOL IsStaticNode() { return m_fIsStatic; }
        void SetStaticNode() { m_fIsStatic = TRUE; }

        void SetSelected(BOOL fSelected) { m_fvarSelected = fSelected ? VARIANT_TRUE : VARIANT_FALSE; }

        void SetSnapIn(CSnapIn *pSnapIn);
        void SetScopeItem(CScopeItem *pScopeItem);
        CScopeItem *GetScopeItem() { return m_pScopeItem; }
        void SetScopeItemDef(IScopeItemDef *piScopeItemDef);

        void SetResultView(CResultView *pResultView);
        CResultView *GetResultView() { return m_pResultView; }
        HRESULT DestroyResultView();

        CResultViews *GetResultViews() { return m_pResultViews; }

        LPOLESTR GetActualDisplayString() { return m_pwszActualDisplayString; }
        SnapInResultViewTypeConstants GetActualResultViewType() { return m_ActualResultViewType; }

        void SetDefaultResultViewType(SnapInResultViewTypeConstants Type) { m_DefaultResultViewType = Type; }
        HRESULT SetDefaultDisplayString(BSTR bstrString);

        BSTR GetDisplayString() { return m_bstrDisplayString; }

        void SetParent(CScopePaneItems *pScopePaneItems);
        CScopePaneItems *GetParent() { return m_pScopePaneItems; }

        HRESULT DetermineResultView();
        BOOL HasListViews() { return VARIANTBOOL_TO_BOOL(m_HasListViews); }

        HRESULT SetPreferredTaskpad(BSTR bstrViewName);

        HRESULT CreateNewResultView(long          lViewOptions,
                                    IResultView **ppiResultView);

        void SetActive(BOOL fActive) { m_fActive = fActive; }
        BOOL Active() { return m_fActive; }

        BSTR GetColumnSetID() { return m_bstrColumnSetID; }

        long GetIndex() { return m_Index; }

        HRESULT OnListViewSelected();


    // CSnapInAutomationObject overrides
        HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();
        HRESULT DetermineActualResultViewType();
        HRESULT GetDefaultViewInfo();
        HRESULT SetViewInfoFromDefaults();
        HRESULT CloneListView(IListViewDef *piListViewDef);
        HRESULT CloneTaskpadView(ITaskpadViewDef *piTaskpadViewDef);
        HRESULT BuildTaskpadDisplayString(IListViewDefs *piListViewDefs);

        BOOL                           m_fIsStatic;      // TRUE=this is static node
        VARIANT_BOOL                   m_fvarSelected;   // not used
        CSnapIn                       *m_pSnapIn;        // back ptr to snap-in
        CScopeItem                    *m_pScopeItem;     // back ptr to ScopeItem
        IScopeItemDef                 *m_piScopeItemDef; // back ptr to ScopeItemDef
        CResultView                   *m_pResultView;    // ScopePaneItem.ResultView
        CResultViews                  *m_pResultViews;   // ScopePaneItem.ResultViews
        CScopePaneItems               *m_pScopePaneItems;//ScopePaneItem.Parent

        // These variables hold the real result view type and display string.
        // When using a predefined
        // result view (ResultView.Type = siPredefined) this says what it really
        // is (e.g. siURLView, siListView etc.)

        SnapInResultViewTypeConstants  m_ActualResultViewType;
        OLECHAR                       *m_pwszActualDisplayString;

        // For nodes defined at design time that have default result view defined

        SnapInResultViewTypeConstants  m_DefaultResultViewType;
        BSTR                           m_bstrDefaultDisplayString;

        BOOL                           m_fActive; // TRUE=scope pane item
                                                  // has active result pane

        // These variables are used to store the message view parameters when
        // the snap-in calls DisplayMessageView. The flag indicates whether we
        // are storing those parameters so that the subsequent call to
        // DetermineResultView() will use them.

        BSTR                                m_bstrTitleText;
        BSTR                                m_bstrBodyText;
        SnapInMessageViewIconTypeConstants  m_IconType;
        BOOL                                m_fHaveMessageViewParams;

        // If the scope item has a taskpad defined at design time that is marked
        // to be used when the user has set "taskpad view preferred" in MMC
        // then this variable contains its name.
        
        BSTR                           m_bstrPreferredTaskpad;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopePaneItem,             // name
                                &CLSID_ScopePaneItem,      // clsid
                                "ScopePaneItem",           // objname
                                "ScopePaneItem",           // lblname
                                NULL,                      // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_IScopePaneItem,       // dispatch IID
                                NULL,                      // event IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _SPANITEM_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitms.cpp ===
//=--------------------------------------------------------------------------=
// spanitms.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItems class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "spanitms.h"
#include "spanitem.h"
#include "scopnode.h"
#include "tpdvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE


VARTYPE CScopePaneItems::m_rgvtInitialize[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopePaneItems::m_eiInitialize =
{
    DISPID_SCOPEPANEITEMS_EVENT_INITIALIZE,
    sizeof(m_rgvtInitialize) / sizeof(m_rgvtInitialize[0]),
    m_rgvtInitialize
};


VARTYPE CScopePaneItems::m_rgvtTerminate[1] =
{
    VT_UNKNOWN
};

EVENTINFO CScopePaneItems::m_eiTerminate =
{
    DISPID_SCOPEPANEITEMS_EVENT_TERMINATE,
    sizeof(m_rgvtTerminate) / sizeof(m_rgvtTerminate[0]),
    m_rgvtTerminate
};




VARTYPE CScopePaneItems::m_rgvtGetResultViewInfo[3] =
{
    VT_UNKNOWN,
    VT_I4 | VT_BYREF,
    VT_BSTR | VT_BYREF
};

EVENTINFO CScopePaneItems::m_eiGetResultViewInfo =
{
    DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW_INFO,
    sizeof(m_rgvtGetResultViewInfo) / sizeof(m_rgvtGetResultViewInfo[0]),
    m_rgvtGetResultViewInfo
};

VARTYPE CScopePaneItems::m_rgvtGetResultView[2] =
{
    VT_UNKNOWN,
    VT_VARIANT | VT_BYREF
};

EVENTINFO CScopePaneItems::m_eiGetResultView =
{
    DISPID_SCOPEPANEITEMS_EVENT_GET_RESULTVIEW,
    sizeof(m_rgvtGetResultView) / sizeof(m_rgvtGetResultView[0]),
    m_rgvtGetResultView
};






#pragma warning(disable:4355)  // using 'this' in constructor

CScopePaneItems::CScopePaneItems(IUnknown *punkOuter) :
   CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>(
                     punkOuter,
                     OBJECT_TYPE_SCOPEPANEITEMS,
                     static_cast<IScopePaneItems *>(this),
                     static_cast<CScopePaneItems *>(this),
                     CLSID_ScopePaneItem,
                     OBJECT_TYPE_SCOPEPANEITEM,
                     IID_IScopePaneItem,
                     NULL) // no persistence
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


void CScopePaneItems::InitMemberVariables()
{
    m_piSelectedItem = NULL;
    m_piParent = NULL;
    m_pSnapIn = NULL;
    m_pParentView = NULL;
    m_pStaticNodeItem = NULL;
    m_pSelectedItem = NULL;
}

CScopePaneItems::~CScopePaneItems()
{
    RELEASE(m_piSelectedItem);
    InitMemberVariables();
}

IUnknown *CScopePaneItems::Create(IUnknown * punkOuter)
{
    CScopePaneItems *pScopePaneItems = New CScopePaneItems(punkOuter);
    if (NULL == pScopePaneItems)
    {
        return NULL;
    }
    else
    {
        return pScopePaneItems->PrivateUnknown();
    }
}


HRESULT CScopePaneItems::CreateScopePaneItem
(
    BSTR             bstrName,
    IScopePaneItem **ppiScopePaneItem
)
{
    HRESULT         hr = S_OK;
    IScopePaneItem *piScopePaneItem = NULL;
    IUnknown       *punkScopePaneItem = NULL;

    VARIANT varKey;
    ::VariantInit(&varKey);

    VARIANT varIndex;
    UNSPECIFIED_PARAM(varIndex);

    punkScopePaneItem = CScopePaneItem::Create(NULL);
    if (NULL == punkScopePaneItem)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkScopePaneItem->QueryInterface(IID_IScopePaneItem,
                                  reinterpret_cast<void **>(&piScopePaneItem)));

    varKey.vt = VT_BSTR;
    varKey.bstrVal = bstrName;
    hr = CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>::AddExisting(
                                                               varIndex,
                                                               varKey,
                                                               piScopePaneItem);
    IfFailGo(hr);
    IfFailGo(piScopePaneItem->put_Name(bstrName));

    IfFailGo(SetObjectHost(piScopePaneItem));

Error:
    if (SUCCEEDED(hr))
    {
        *ppiScopePaneItem = piScopePaneItem;
    }
    else
    {
        QUICK_RELEASE(piScopePaneItem);
        *ppiScopePaneItem = NULL;
    }

    QUICK_RELEASE(punkScopePaneItem);
    RRETURN(hr);
}



HRESULT CScopePaneItems::AddNode
(
    CScopeItem      *pScopeItem,
    CScopePaneItem **ppScopePaneItem
)
{
    HRESULT                        hr = S_OK;
    IScopeNode                    *piScopeNode = NULL;
    CScopeNode                    *pScopeNode = NULL;
    CScopePaneItem                *pScopePaneItem = NULL;
    IScopePaneItem                *piScopePaneItem = NULL;
    IViewDefs                     *piViewDefs = NULL;
    IListViewDefs                 *piListViewDefs = NULL;
    BSTR                           bstrProp = NULL;
    long                           cListViewDefs = 0;
    SnapInResultViewTypeConstants  ResultViewType = siUnknown;

    // Create the scope pane item

    IfFailGo(CreateScopePaneItem(pScopeItem->GetNamePtr(), &piScopePaneItem));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopePaneItem, &pScopePaneItem));

    // Set its properties from the scope item

    IfFailGo(pScopeItem->get_ScopeNode(reinterpret_cast<ScopeNode **>(&piScopeNode)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piScopeNode, &pScopeNode));

    // If there is a default view then set the result view type to "predfined"

    if (pScopeItem->IsStaticNode())
    {
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_DefaultView(&bstrProp));
        IfFailGo(m_pSnapIn->GetSnapInDef()->get_ViewDefs(&piViewDefs));
    }
    else
    {
        if (NULL != pScopeItem->GetScopeItemDef())
        {
            IfFailGo(pScopeItem->GetScopeItemDef()->get_ViewDefs(&piViewDefs));
            IfFailGo(pScopeItem->GetScopeItemDef()->get_DefaultView(&bstrProp));
        }
    }

    if ( (NULL != bstrProp) && (L'\0' != *bstrProp) )
    {
        ResultViewType = siPreDefined;
    }
    else
    {
        // No default view. Type is unknown and display string is NULL
        ResultViewType = siUnknown;
    }

    pScopePaneItem->SetDefaultResultViewType(ResultViewType);
    IfFailGo(pScopePaneItem->SetDefaultDisplayString(bstrProp));

    FREESTRING(bstrProp);

    // Check if the scope item has a taskpad marked to be used when
    // the user has checked the "taskpad view preferred" option. If there is
    // one the give its name to the ScopePaneItem.

    IfFailGo(SetPreferredTaskpad(piViewDefs, pScopePaneItem));

    // Determine the initial value of HasListViews based on the presence of
    // a design time listview definition. The default is False so only need
    // to set it if there are some listviews.

    if (NULL != piViewDefs)
    {
        IfFailGo(piViewDefs->get_ListViews(&piListViewDefs));
        IfFailGo(piListViewDefs->get_Count(&cListViewDefs));
        if (0 != cListViewDefs)
        {
            IfFailGo(piScopePaneItem->put_HasListViews(VARIANT_TRUE));
        }
    }

    if (pScopeItem->IsStaticNode())
    {
        pScopePaneItem->SetStaticNode();
        m_pStaticNodeItem = pScopePaneItem;
    }

    pScopePaneItem->SetSnapIn(m_pSnapIn);
    pScopePaneItem->SetScopeItem(pScopeItem);
    pScopePaneItem->SetParent(this);

    // Set the default ColumnSetID from the scope item's node type. The snap-in
    // may change this at any time but it is best to do so during the
    // ScopePaneItems_Initialize event fired below

    IfFailGo(pScopePaneItem->put_ColumnSetID(pScopeItem->GetScopeNode()->GetNodeTypeGUID()));

    *ppScopePaneItem = pScopePaneItem;

    FireScopePaneItemsInitialize(static_cast<IScopePaneItem *>(pScopePaneItem));

Error:

    // Note: the returned C++ pointer is not AddRef()ed. At this point
    // the collection has the only ref on the scope pane item.

    QUICK_RELEASE(piScopePaneItem);
    QUICK_RELEASE(piScopeNode);
    QUICK_RELEASE(piViewDefs);
    QUICK_RELEASE(piListViewDefs);
    FREESTRING(bstrProp);
    RRETURN(hr);
}


HRESULT CScopePaneItems::SetPreferredTaskpad
(
    IViewDefs      *piViewDefs,
    CScopePaneItem *pScopePaneItem
)
{
    HRESULT           hr = S_OK;
    ITaskpadViewDefs *piTaskpadViewDefs = NULL;
    ITaskpadViewDef  *piTaskpadViewDef = NULL;
    long              cTaskpads = 0;
    BOOL              fFound = FALSE;
    BSTR              bstrName = NULL;
    VARIANT_BOOL      fvarUseForPreferred = VARIANT_FALSE;

    VARIANT varIndex;
    ::VariantInit(&varIndex);

    // A code-define scope item won't have any predefined result views

    IfFalseGo(NULL != piViewDefs, S_OK);

    // Check if the scope item has taskpads defined at design time

    IfFailGo(piViewDefs->get_TaskpadViews(&piTaskpadViewDefs));
    IfFailGo(piTaskpadViewDefs->get_Count(&cTaskpads));
    IfFalseGo(0 != cTaskpads, S_OK);

    // Look for the first one marked to be used when the user has set
    // "taskpad view preferred" option in MMC.

    varIndex.vt = VT_I4;
    
    for (varIndex.lVal = 1L;
         (varIndex.lVal <= cTaskpads) && (!fFound);
         varIndex.lVal++)
    {
        IfFailGo(piTaskpadViewDefs->get_Item(varIndex, &piTaskpadViewDef));
        IfFailGo(piTaskpadViewDef->get_UseWhenTaskpadViewPreferred(&fvarUseForPreferred));
        if (VARIANT_TRUE == fvarUseForPreferred)
        {
            fFound = TRUE;
            IfFailGo(piTaskpadViewDef->get_Name(&bstrName));
            IfFailGo(pScopePaneItem->SetPreferredTaskpad(bstrName));
        }
        RELEASE(piTaskpadViewDef);
    }

Error:
    QUICK_RELEASE(piTaskpadViewDefs);
    QUICK_RELEASE(piTaskpadViewDef);
    FREESTRING(bstrName);
    RRETURN(hr);
}



void CScopePaneItems::FireGetResultViewInfo
(
    IScopePaneItem                *piScopePaneItem,
    SnapInResultViewTypeConstants *pViewType,
    BSTR                          *pbstrDisplayString
)
{
    DebugPrintf("Firing ScopePaneItems_FireGetResultViewInfo(%ls, %ld, %ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr(), *pViewType, ((*pbstrDisplayString) == NULL) ? L"" : (*pbstrDisplayString));

    FireEvent(&m_eiGetResultViewInfo,
              piScopePaneItem,
              pViewType,
              pbstrDisplayString);
}



void CScopePaneItems::FireScopePaneItemsInitialize
(
    IScopePaneItem *piScopePaneItem
)
{
    if (NULL != m_pSnapIn)
    {
        DebugPrintf("Firing ScopePaneItems_Initialize(%ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr() );

        m_pSnapIn->GetScopePaneItems()->FireEvent(&m_eiInitialize, piScopePaneItem);
    }
}

BOOL CScopePaneItems::FireGetResultView
(
    IScopePaneItem *piScopePaneItem,
    VARIANT        *pvarIndex
)
{
    ::VariantInit(pvarIndex);

    DebugPrintf("Firing ScopePaneItems_GetResultView(%ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr() );

    FireEvent(&m_eiGetResultView, piScopePaneItem, pvarIndex);

    if (VT_EMPTY == pvarIndex->vt)
    {
        return FALSE; // consider this as event not handled
    }
    else
    {
        return TRUE;
    }
}




void CScopePaneItems::SetSnapIn(CSnapIn *pSnapIn)
{
    m_pSnapIn = pSnapIn;
}

void CScopePaneItems::SetParentView(CView *pView)
{
    m_pParentView = pView;

    // We don't AddRef the interface pointer as our lifetime is governed
    // by out parent view and we need to avoid circular refcounting problems.
    // When user code fetches the Parent property, m_iParent will be
    // AddRef()ed before returning it to the VBA caller.

    m_piParent = static_cast<IView *>(pView);
}


void CScopePaneItems::SetSelectedItem(CScopePaneItem *pScopePaneItem)
{
    m_pSelectedItem = pScopePaneItem;
    RELEASE(m_piSelectedItem);
    m_piSelectedItem = static_cast<IScopePaneItem *>(pScopePaneItem);
    m_piSelectedItem->AddRef();
}


STDMETHODIMP CScopePaneItems::Remove(VARIANT Index)
{
    HRESULT     hr = S_OK;
    IScopePaneItem *piScopePaneItem = NULL;

    // Get the scope pane item. This checks its existence and leaves a ref on it
    // so we can fire ScopePaneItems_Terminate.

    IfFailGo(get_Item(Index, &piScopePaneItem));

    // Remove it from the collection

    hr =  CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>::Remove(Index);
    IfFailGo(hr);

    if (NULL != m_pSnapIn)
    {
        // Fire ScopePaneItems_Terminate

        DebugPrintf("Firing ScopePaneItems_Terminate(%ls)\r\n", (static_cast<CScopePaneItem *>(piScopePaneItem))->GetScopeItem()->GetDisplayNamePtr() );

        m_pSnapIn->GetScopePaneItems()->FireEvent(&m_eiTerminate, piScopePaneItem);
    }

Error:
    QUICK_RELEASE(piScopePaneItem);
    RRETURN(hr);
}

//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CScopePaneItems::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IScopePaneItems == riid)
    {
        *ppvObjOut = static_cast<IScopePaneItems *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\spanitms.h ===
//=--------------------------------------------------------------------------=
// spanitms.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CScopePaneItems class definition - implements ScopePaneItems collection
//
//=--------------------------------------------------------------------------=

#ifndef _SCOPEPANEITEMS_DEFINED_
#define _SCOPEPANEITEMS_DEFINED_

#include "collect.h"
#include "spanitem.h"
#include "view.h"
#include "snapin.h"

class CView;
class CScopePaneItem;

class CScopePaneItems : public CSnapInCollection<IScopePaneItem, ScopePaneItem, IScopePaneItems>
{
    protected:
        CScopePaneItems(IUnknown *punkOuter);
        ~CScopePaneItems();

    public:
        static IUnknown *Create(IUnknown * punk);

        HRESULT AddNode(CScopeItem *pScopeItem,
                        CScopePaneItem **ppScopePaneItem);
        CScopePaneItem *GetStaticNodeItem() { return m_pStaticNodeItem; }
        void SetSnapIn(CSnapIn *pSnapIn);
        void SetParentView(CView *pView);
        CView *GetParentView() { return m_pParentView; }
        void SetSelectedItem(CScopePaneItem *pScopePaneItem);
        CScopePaneItem *GetSelectedItem() { return m_pSelectedItem; }
        STDMETHOD(Remove)(VARIANT Index);

    // Event firing methods
        void FireScopePaneItemsInitialize(IScopePaneItem *piScopePaneItem);
        void FireGetResultViewInfo(IScopePaneItem                *piScopePaneItem,
                                   SnapInResultViewTypeConstants *pViewType,
                                   BSTR                          *pbstrDisplayString);

        BOOL FireGetResultView(IScopePaneItem *piScopePaneItem,
                               VARIANT        *pvarIndex);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    public:

    // IScopePaneItems
        COCLASS_PROPERTY_RO(CScopePaneItems, SelectedItem, ScopePaneItem, IScopePaneItem, DISPID_SCOPEPANEITEMS_SELECTED_ITEM);
        COCLASS_PROPERTY_RO(CScopePaneItems, Parent, View, IView, DISPID_SCOPEPANEITEMS_PARENT);

    protected:

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


    private:

        void InitMemberVariables();
        HRESULT CreateScopePaneItem(BSTR bstrName,
                                    IScopePaneItem **ppiScopePaneItem);
        HRESULT SetPreferredTaskpad(IViewDefs      *piViewDefs,
                                    CScopePaneItem *pScopePaneItem);

        CSnapIn        *m_pSnapIn;          // back ptr to snap-in
        CView          *m_pParentView;      // ScopePaneItems.Parent
        CScopePaneItem *m_pStaticNodeItem;  // ptr to ScopePaneItem for static node
        CScopePaneItem *m_pSelectedItem;    // ScopePaneItems.SelectedItem

        // Event parameter definitions

        static VARTYPE   m_rgvtInitialize[1];
        static EVENTINFO m_eiInitialize;

        static VARTYPE   m_rgvtTerminate[1];
        static EVENTINFO m_eiTerminate;

        static VARTYPE   m_rgvtGetResultViewInfo[3];
        static EVENTINFO m_eiGetResultViewInfo;

        static VARTYPE   m_rgvtGetResultView[2];
        static EVENTINFO m_eiGetResultView;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(ScopePaneItems,              // name
                                &CLSID_ScopePaneItems,       // clsid
                                "ScopePaneItems",            // objname
                                "ScopePaneItems",            // lblname
                                NULL,                        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IScopePaneItems,        // dispatch IID
                                &DIID_DScopePaneItemsEvents, // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _SCOPEPANEITEMS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\strtable.h ===
//=--------------------------------------------------------------------------=
// strtable.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCStringTable class definition - implements MMCStringTable collection
//
//=--------------------------------------------------------------------------=

#ifndef _STRTABLE_DEFINED_
#define _STRTABLE_DEFINED_

#include "snapin.h"

class CMMCStringTable : public CSnapInAutomationObject,
                        public IMMCStringTable
{
    private:
        CMMCStringTable(IUnknown *punkOuter);
        ~CMMCStringTable();

    public:
        static IUnknown *Create(IUnknown * punk);
        void SetIStringTable(IStringTable *piStringTable);
    
    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCStringTable methods

        STDMETHOD(get_Item)(long ID, BSTR *pbstrString);
        STDMETHOD(get__NewEnum)(IUnknown **ppunkEnum);
        STDMETHOD(Add)(BSTR String, long *plID);
        STDMETHOD(Find)(BSTR String, long *plID);
        STDMETHOD(Remove)(long ID);
        STDMETHOD(Clear)();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        IStringTable *m_piStringTable; // MMC interface
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(StringTable,                // name
                                NULL,                       // clsid
                                "StringTable",              // objname
                                "StringTable",              // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IMMCStringTable,       // dispatch IID
                                NULL,                       // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe


class CEnumStringTable : public CSnapInAutomationObject,
                         public IEnumVARIANT

{
    public:
        CEnumStringTable(IEnumString *piEnumString);
        ~CEnumStringTable();

    private:

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

        // IEnumVARIANT
        STDMETHOD(Next)(unsigned long   celt,
                        VARIANT        *rgvar,
                        unsigned long  *pceltFetched);        
        STDMETHOD(Skip)(unsigned long celt);        
        STDMETHOD(Reset)();        
        STDMETHOD(Clone)(IEnumVARIANT **ppenum);

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

        void InitMemberVariables();

        IEnumString *m_piEnumString;
};


DEFINE_AUTOMATIONOBJECTWEVENTS2(EnumStringTable,            // name
                                NULL,                       // clsid
                                "StringTable",              // objname
                                "StringTable",              // lblname
                                NULL,                       // creation function
                                TLIB_VERSION_MAJOR,         // major version
                                TLIB_VERSION_MINOR,         // minor version
                                &IID_IEnumVARIANT,          // dispatch IID
                                NULL,                       // event IID
                                HELP_FILENAME,              // help file
                                TRUE);                      // thread safe



#endif // _STRTABLE_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\strtable.cpp ===
//=--------------------------------------------------------------------------=
// strtable.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCStringTable class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "strtable.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCStringTable::CMMCStringTable(IUnknown *punkOuter) :
   CSnapInAutomationObject(punkOuter,
                           OBJECT_TYPE_STRINGTABLE,
                           static_cast<IMMCStringTable *>(this),
                           static_cast<CMMCStringTable *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();

    // This class makes the assumption that an MMC_STRING_ID (typedefed as a
    // DWORD in mmc.idl) is the same size as a long. The following code checks
    // that assumption and ASSERTS if it is not true.

    ASSERT(sizeof(DWORD) == sizeof(long), "CMMCStringTable will not work because sizeof(DWORD) != sizeof(long)");
}

#pragma warning(default:4355)  // using 'this' in constructor


IUnknown *CMMCStringTable::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    IUnknown *punkMMCStringTable = NULL;

    CMMCStringTable *pMMCStringTable = New CMMCStringTable(punkOuter);

    if (NULL == pMMCStringTable)
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }
    punkMMCStringTable = pMMCStringTable->PrivateUnknown();

Error:
    return punkMMCStringTable;
}



CMMCStringTable::~CMMCStringTable()
{
    RELEASE(m_piStringTable);
    InitMemberVariables();
}

void CMMCStringTable::InitMemberVariables()
{
    m_piStringTable = NULL;
}



void CMMCStringTable::SetIStringTable(IStringTable *piStringTable)
{
    RELEASE(m_piStringTable);
    if (NULL != piStringTable)
    {
        piStringTable->AddRef();
    }
    m_piStringTable = piStringTable;
}


//=--------------------------------------------------------------------------=
//                      IMMCStringTable Methods
//=--------------------------------------------------------------------------=



STDMETHODIMP CMMCStringTable::get_Item(long ID, BSTR *pbstrString)
{
    HRESULT  hr = S_OK;
    ULONG    cchString = 0;
    WCHAR   *pwszString = NULL;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the string's length and allocate a buffer. MMC returns the
    // length in characters without the terminating null.

    hr = m_piStringTable->GetStringLength(static_cast<MMC_STRING_ID>(ID),
                                          &cchString);
    EXCEPTION_CHECK_GO(hr);

    pwszString = (WCHAR *)::CtlAllocZero( (cchString + 1) * sizeof(OLECHAR) );
    if (NULL == pwszString)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->GetString(static_cast<MMC_STRING_ID>(ID),
                                    cchString + 1, pwszString, NULL);
    EXCEPTION_CHECK_GO(hr);

    *pbstrString = ::SysAllocString(pwszString);
    if (NULL == *pbstrString)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (NULL != pwszString)
    {
        ::CtlFree(pwszString);
    }
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::get__NewEnum(IUnknown **ppunkEnum)
{
    HRESULT           hr = S_OK;
    CEnumStringTable *pEnumStringTable = NULL;
    IEnumString      *piEnumString = NULL;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->Enumerate(&piEnumString);
    EXCEPTION_CHECK_GO(hr);

    pEnumStringTable = New CEnumStringTable(piEnumString);

    if (NULL == pEnumStringTable)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }


Error:
    QUICK_RELEASE(piEnumString);
    if (FAILED(hr))
    {
        if (NULL != pEnumStringTable)
        {
            delete pEnumStringTable;
        }
        *ppunkEnum = NULL;
    }
    else
    {
        *ppunkEnum = static_cast<IUnknown *>(static_cast<IEnumVARIANT *>(pEnumStringTable));
    }
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::Add(BSTR String, long *plID)
{
    HRESULT       hr = S_OK;
    MMC_STRING_ID id = 0;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->AddString(static_cast<LPCOLESTR>(String), &id);
    EXCEPTION_CHECK_GO(hr);

    *plID = static_cast<long>(id);

Error:
    RRETURN(hr);
}


STDMETHODIMP CMMCStringTable::Find(BSTR String, long *plID)
{
    HRESULT       hr = S_OK;
    MMC_STRING_ID id = 0;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->FindString(static_cast<LPCOLESTR>(String), &id);
    EXCEPTION_CHECK_GO(hr);

    *plID = static_cast<long>(id);

Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::Remove(long ID)
{
    HRESULT hr = S_OK;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->DeleteString(static_cast<MMC_STRING_ID>(ID));
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}



STDMETHODIMP CMMCStringTable::Clear()
{
    HRESULT hr = S_OK;

    if (NULL == m_piStringTable)
    {
        hr = SID_E_NOT_CONNECTED_TO_MMC;
        EXCEPTION_CHECK_GO(hr);
    }

    hr = m_piStringTable->DeleteAllStrings();
    EXCEPTION_CHECK_GO(hr);

Error:
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCStringTable::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IMMCStringTable == riid)
    {
        *ppvObjOut = static_cast<IMMCStringTable *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}









//=--------------------------------------------------------------------------=
//                      CEnumStringTable Methods
//=--------------------------------------------------------------------------=

#pragma warning(disable:4355)  // using 'this' in constructor

CEnumStringTable::CEnumStringTable(IEnumString *piEnumString) :
   CSnapInAutomationObject(NULL,
                           OBJECT_TYPE_ENUMSTRINGTABLE,
                           static_cast<IEnumVARIANT *>(this),
                           static_cast<CEnumStringTable *>(this),
                           0,    // no property pages
                           NULL, // no property pages
                           NULL) // no persistence
{
    InitMemberVariables();
    if (NULL != piEnumString)
    {
        piEnumString->AddRef();
    }
    m_piEnumString = piEnumString;
}

#pragma warning(default:4355)  // using 'this' in constructor


CEnumStringTable::~CEnumStringTable()
{
    RELEASE(m_piEnumString);
    InitMemberVariables();
}

void CEnumStringTable::InitMemberVariables()
{
    m_piEnumString = NULL;
}



//=--------------------------------------------------------------------------=
//                        IEnumVariant Methods
//=--------------------------------------------------------------------------=


STDMETHODIMP CEnumStringTable::Next
(
    unsigned long   celt,
    VARIANT        *rgvar,
    unsigned long  *pceltFetched
)
{
    HRESULT        hr = S_OK;
    unsigned long  i = 0;
    ULONG          celtFetched = 0; 
    LPOLESTR      *ppStrings = NULL;

    // Initialize result array.

    for (i = 0; i < celt; i++)
    {
        ::VariantInit(&rgvar[i]);
    }

    // Allocate the string pointer array

    ppStrings = (LPOLESTR *)::CtlAllocZero(celt * sizeof(LPOLESTR));
    if (NULL == ppStrings)
    {
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the strings from MMC

    hr = m_piEnumString->Next(celt, ppStrings, &celtFetched);
    EXCEPTION_CHECK_GO(hr);

    // Put each string into a BSTR in a VARIANT for return to the snap-in

    for (i = 0; i < celtFetched; i++) 
    {
        rgvar[i].bstrVal = ::SysAllocString(ppStrings[i]);
        if (NULL == rgvar[i].bstrVal)
        {
            hr = SID_E_OUTOFMEMORY;
            EXCEPTION_CHECK_GO(hr);
        }
        rgvar[i].vt = VT_BSTR;
    }

Error:

    // If we got any strings from MMC then free them and free the array.

    if (NULL != ppStrings)
    {
        for (i = 0; i < celtFetched; i++) 
        {
            if (NULL != ppStrings[i])
            {
                ::CoTaskMemFree(ppStrings[i]);
            }
        }
        ::CtlFree(ppStrings);
    }

    // If we managed to get some strings into BSTRs but something then failed, we
    // need to free the BSTR that were allocated.

    if (FAILED(hr))
    {
        for (i = 0; i < celt; i++)
        {
            (void)::VariantClear(&rgvar[i]);
        }
    }

    // If the caller requested the number of elements fetched then return it.
    
    if (pceltFetched != NULL)
    {
        if (SUCCEEDED(hr))
        {
            *pceltFetched = celtFetched;
        }
        else
        {
            *pceltFetched = 0;
        }
    }

    RRETURN(hr);
}



STDMETHODIMP CEnumStringTable::Skip
(
    unsigned long celt
)
{
    HRESULT hr = m_piEnumString->Skip(celt);
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}



STDMETHODIMP CEnumStringTable::Reset()
{
    HRESULT hr = m_piEnumString->Reset();
    EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


STDMETHODIMP CEnumStringTable::Clone(IEnumVARIANT **ppenum)
{
    HRESULT hr = S_OK;

    CEnumStringTable *pClone = New CEnumStringTable(m_piEnumString);

    if (NULL == pClone)
    {
        *ppenum = NULL;
        hr = SID_E_OUTOFMEMORY;
        EXCEPTION_CHECK_GO(hr);
    }

    *ppenum = static_cast<IEnumVARIANT *>(pClone);

Error:
    RRETURN(hr);
}





//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CEnumStringTable::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (IID_IEnumVARIANT == riid)
    {
        *ppvObjOut = static_cast<IEnumVARIANT *>(this);
        ExternalAddRef();
        return S_OK;
    }
    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\stub_mssnapr_i.c ===
#define IID_IMMCListView My_IID_IMMCListView
#define IID_INodeType    My_IID_INodeType
#include <mssnapr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\task.cpp ===
//=--------------------------------------------------------------------------=
// task.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTask class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "task.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CTask::CTask(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_TASK,
                            static_cast<ITask *>(this),
                            static_cast<CTask *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_Task,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CTask::~CTask()
{
    FREESTRING(m_bstrKey);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrText);
    FREESTRING(m_bstrMouseOverImage);
    FREESTRING(m_bstrMouseOffImage);
    FREESTRING(m_bstrFontFamily);
    FREESTRING(m_bstrEOTFile);
    FREESTRING(m_bstrSymbolString);
    FREESTRING(m_bstrHelpString);
    FREESTRING(m_bstrURL);
    FREESTRING(m_bstrScript);
    InitMemberVariables();
}

void CTask::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_Visible = VARIANT_TRUE;

    ::VariantInit(&m_varTag);

    m_bstrText = NULL;
    m_ImageType = siNoImage;
    m_bstrMouseOverImage = NULL;
    m_bstrMouseOffImage = NULL;
    m_bstrFontFamily = NULL;
    m_bstrEOTFile = NULL;
    m_bstrSymbolString = NULL;
    m_bstrHelpString = NULL;
    m_ActionType = siNotify;
    m_bstrURL = NULL;
    m_bstrScript = NULL;
}

IUnknown *CTask::Create(IUnknown * punkOuter)
{
    CTask *pTask = New CTask(punkOuter);
    if (NULL == pTask)
    {
        return NULL;
    }
    else
    {
        return pTask->PrivateUnknown();
    }
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTask::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varDefault;
    ::VariantInit(&varDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    if ( Loading() && (GetMajorVersion() == 0) && (GetMinorVersion() < 10) )
    {
    }
    else
    {
        IfFailRet(PersistSimpleType(&m_Visible, VARIANT_TRUE, OLESTR("Visible")));
    }

    IfFailRet(PersistVariant(&m_varTag, varDefault, OLESTR("Tag")));

    IfFailRet(PersistBstr(&m_bstrText, L"", OLESTR("Text")));

    IfFailRet(PersistSimpleType(&m_ImageType, siNoImage, OLESTR("ImageType")));

    IfFailRet(PersistBstr(&m_bstrMouseOverImage, L"", OLESTR("MouseOverImage")));

    IfFailRet(PersistBstr(&m_bstrMouseOffImage, L"", OLESTR("MouseOffImage")));

    IfFailRet(PersistBstr(&m_bstrFontFamily, L"", OLESTR("FontFamily")));

    IfFailRet(PersistBstr(&m_bstrEOTFile, L"", OLESTR("EOTFile")));

    IfFailRet(PersistBstr(&m_bstrSymbolString, L"", OLESTR("SymbolString")));

    IfFailRet(PersistBstr(&m_bstrHelpString, L"", OLESTR("HelpString")));

    IfFailRet(PersistSimpleType(&m_ActionType, siNotify, OLESTR("ActionType")));

    IfFailRet(PersistBstr(&m_bstrURL, L"", OLESTR("URL")));

    IfFailRet(PersistBstr(&m_bstrScript, L"", OLESTR("Script")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTask::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ITask == riid)
    {
        *ppvObjOut = static_cast<ITask *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\taskpad.cpp ===
//=--------------------------------------------------------------------------=
// taskpad.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpad class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "taskpad.h"
#include "tasks.h"

// for ASSERT and FAIL
//
SZTHISFILE


#pragma warning(disable:4355)  // using 'this' in constructor

CTaskpad::CTaskpad(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_TASKPAD,
                            static_cast<ITaskpad *>(this),
                            static_cast<CTaskpad *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_Taskpad,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CTaskpad::~CTaskpad()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrTitle);
    FREESTRING(m_bstrDescriptiveText);
    FREESTRING(m_bstrURL);
    FREESTRING(m_bstrMouseOverImage);
    FREESTRING(m_bstrMouseOffImage);
    FREESTRING(m_bstrFontFamily);
    FREESTRING(m_bstrEOTFile);
    FREESTRING(m_bstrSymbolString);
    FREESTRING(m_bstrListpadTitle);
    FREESTRING(m_bstrListpadButtonText);
    FREESTRING(m_bstrListView);
    RELEASE(m_piTasks);
    InitMemberVariables();
}

void CTaskpad::InitMemberVariables()
{
    m_bstrName = NULL;
    m_Type = Default;
    m_bstrTitle = NULL;
    m_bstrDescriptiveText = NULL;
    m_bstrURL = NULL;
    m_BackgroundType = siNoImage;
    m_bstrMouseOverImage = NULL;
    m_bstrMouseOffImage = NULL;
    m_bstrFontFamily = NULL;
    m_bstrEOTFile = NULL;
    m_bstrSymbolString = NULL;
    m_ListpadStyle = siVertical;
    m_bstrListpadTitle = NULL;
    m_ListpadHasButton = VARIANT_FALSE;
    m_bstrListpadButtonText = NULL;
    m_bstrListView = NULL;
    m_piTasks = NULL;
}


IUnknown *CTaskpad::Create(IUnknown * punkOuter)
{
    HRESULT   hr = S_OK;
    CTaskpad *pTaskpad = New CTaskpad(punkOuter);
    IUnknown *punkTasks = CTasks::Create(NULL);

    if ( (NULL == pTaskpad) || (NULL == punkTasks) )
    {
        hr = SID_E_OUTOFMEMORY;
        GLOBAL_EXCEPTION_CHECK_GO(hr);
    }

    IfFailGo(punkTasks->QueryInterface(IID_ITasks,
                               reinterpret_cast<void **>(&pTaskpad->m_piTasks)));

Error:
    QUICK_RELEASE(punkTasks);
    if (FAILEDHR(hr))
    {
        if (NULL != pTaskpad)
        {
            delete pTaskpad;
        }
        return NULL;
    }
    else
    {
        return pTaskpad->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpad::Persist()
{
    HRESULT hr = S_OK;

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistSimpleType(&m_Type, Default, OLESTR("Type")));

    IfFailRet(PersistBstr(&m_bstrTitle, L"", OLESTR("Title")));

    IfFailRet(PersistBstr(&m_bstrURL, L"", OLESTR("URL")));

    IfFailRet(PersistBstr(&m_bstrDescriptiveText, L"", OLESTR("DescriptiveText")));

    IfFailRet(PersistSimpleType(&m_BackgroundType, siNoImage, OLESTR("BackgroundType")));

    IfFailRet(PersistBstr(&m_bstrMouseOverImage, L"", OLESTR("MouseOverImage")));

    IfFailRet(PersistBstr(&m_bstrMouseOffImage, L"", OLESTR("MouseOffImage")));

    IfFailRet(PersistBstr(&m_bstrFontFamily, L"", OLESTR("FontFamily")));

    IfFailRet(PersistBstr(&m_bstrEOTFile, L"", OLESTR("EOTFile")));

    IfFailRet(PersistBstr(&m_bstrSymbolString, L"", OLESTR("SymbolString")));

    IfFailRet(PersistSimpleType(&m_ListpadStyle, siVertical, OLESTR("ListpadStyle")));

    IfFailRet(PersistBstr(&m_bstrListpadTitle, L"", OLESTR("ListpadTitle")));

    IfFailRet(PersistSimpleType(&m_ListpadHasButton, VARIANT_FALSE, OLESTR("ListpadHasButton")));

    IfFailRet(PersistBstr(&m_bstrListpadButtonText, L"", OLESTR("ListpadButtonText")));

    IfFailRet(PersistBstr(&m_bstrListView, L"", OLESTR("ListView")));

    IfFailRet(PersistObject(&m_piTasks, CLSID_Tasks,
                            OBJECT_TYPE_TASKS, IID_ITasks, OLESTR("Tasks")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpad::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_ITaskpad == riid)
    {
        *ppvObjOut = static_cast<ITaskpad *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\taskpad.h ===
//=--------------------------------------------------------------------------=
// taskpad.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpad class definition - implements Taskpad object
//
//=--------------------------------------------------------------------------=

#ifndef _TASKPAD_DEFINED_
#define _TASKPAD_DEFINED_

class CTaskpad : public CSnapInAutomationObject,
                 public CPersistence,
                 public ITaskpad
{
    private:
        CTaskpad(IUnknown *punkOuter);
        ~CTaskpad();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITaskpad
        BSTR_PROPERTY_RW(CTaskpad,       Name,                                               DISPID_TASKPAD_NAME);
        SIMPLE_PROPERTY_RW(CTaskpad,     Type,              SnapInTaskpadTypeConstants,      DISPID_TASKPAD_TYPE);
        BSTR_PROPERTY_RW(CTaskpad,       Title,                                              DISPID_TASKPAD_TITLE);
        BSTR_PROPERTY_RW(CTaskpad,       DescriptiveText,                                    DISPID_TASKPAD_DESCRIPTIVE_TEXT);
        BSTR_PROPERTY_RW(CTaskpad,       URL,                                                DISPID_TASKPAD_URL);
        SIMPLE_PROPERTY_RW(CTaskpad,     BackgroundType,    SnapInTaskpadImageTypeConstants, DISPID_TASKPAD_BACKGROUND_TYPE);
        BSTR_PROPERTY_RW(CTaskpad,       MouseOverImage,                                     DISPID_TASKPAD_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTaskpad,       MouseOffImage,                                      DISPID_TASKPAD_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTaskpad,       FontFamily,                                         DISPID_TASKPAD_FONT_FAMILY);
        BSTR_PROPERTY_RW(CTaskpad,       EOTFile,                                            DISPID_TASKPAD_EOT_FILE);
        BSTR_PROPERTY_RW(CTaskpad,       SymbolString,                                       DISPID_TASKPAD_SYMBOL_STRING);
        SIMPLE_PROPERTY_RW(CTaskpad,     ListpadStyle,      SnapInListpadStyleConstants,     DISPID_TASKPAD_LISTPAD_STYLE);
        BSTR_PROPERTY_RW(CTaskpad,       ListpadTitle,                                       DISPID_TASKPAD_LISTPAD_TITLE);
        SIMPLE_PROPERTY_RW(CTaskpad,     ListpadHasButton,  VARIANT_BOOL,                    DISPID_TASKPAD_LISTPAD_HAS_BUTTON);
        BSTR_PROPERTY_RW(CTaskpad,       ListpadButtonText,                                  DISPID_TASKPAD_LISTPAD_BUTTON_TEXT);
        BSTR_PROPERTY_RW(CTaskpad,       ListView,                                           DISPID_TASKPAD_LISTVIEW);
        COCLASS_PROPERTY_RO(CTaskpad,    Tasks,             Tasks, ITasks,                   DISPID_TASKPAD_TASKS);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Taskpad,            // name
                                &CLSID_Taskpad,     // clsid
                                "Taskpad",          // objname
                                "Taskpad",          // lblname
                                &CTaskpad::Create,  // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ITaskpad,      // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _TASKPAD_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tasks.cpp ===
//=--------------------------------------------------------------------------=
// tasks.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTasks class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tasks.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CTasks::CTasks(IUnknown *punkOuter) :
    CSnapInCollection<ITask, Task, ITasks>(punkOuter,
                                           OBJECT_TYPE_TASKS,
                                           static_cast<ITasks *>(this),
                                           static_cast<CTasks *>(this),
                                           CLSID_Task,
                                           OBJECT_TYPE_TASK,
                                           IID_ITask,
                                           static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_Tasks,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CTasks::~CTasks()
{
}

IUnknown *CTasks::Create(IUnknown * punkOuter)
{
    CTasks *pTasks = New CTasks(punkOuter);
    if (NULL == pTasks)
    {
        return NULL;
    }
    else
    {
        return pTasks->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTasks::Persist()
{
    HRESULT  hr = S_OK;
    ITask   *piTask = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<ITask, Task, ITasks>::Persist(piTask);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                          ITasks Methods
//=--------------------------------------------------------------------------=

STDMETHODIMP CTasks::Add
(
    VARIANT   Index,
    VARIANT   Key, 
    VARIANT   Text,
    Task    **ppTask
)
{
    HRESULT hr = S_OK;
    VARIANT varText;
    ::VariantInit(&varText);
    ITask *piTask = NULL;

    hr = CSnapInCollection<ITask, Task, ITasks>::Add(Index, Key, &piTask);
    IfFailGo(hr);

    if (ISPRESENT(Text))
    {
        hr = ::VariantChangeType(&varText, &Text, 0, VT_BSTR);
        EXCEPTION_CHECK_GO(hr);
        IfFailGo(piTask->put_Text(varText.bstrVal));
    }

    *ppTask = reinterpret_cast<Task *>(piTask);

Error:

    if (FAILED(hr))
    {
        QUICK_RELEASE(piTask);
    }
    (void)::VariantClear(&varText);
    RRETURN(hr);
}



//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTasks::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_ITasks == riid)
    {
        *ppvObjOut = static_cast<ITasks *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<ITask, Task, ITasks>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\task.h ===
//=--------------------------------------------------------------------------=
// task.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTask class definition - implements Task object
//
//=--------------------------------------------------------------------------=

#ifndef _TASK_DEFINED_
#define _TASK_DEFINED_

class CTask : public CSnapInAutomationObject,
              public CPersistence,
              public ITask
{
    private:
        CTask(IUnknown *punkOuter);
        ~CTask();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        long GetIndex() { return m_Index; }
        BOOL Visible() { return VARIANTBOOL_TO_BOOL(m_Visible); }
        BSTR GetText() { return m_bstrText; }
        SnapInTaskpadImageTypeConstants GetImageType() { return m_ImageType; }
        BSTR GetMouseOverImage() { return m_bstrMouseOverImage; }
        BSTR GetMouseOffImage() { return m_bstrMouseOffImage; }
        BSTR GetFontfamily() { return m_bstrFontFamily; }
        BSTR GetEOTFile() { return m_bstrEOTFile; }
        BSTR GetSymbolString() { return m_bstrSymbolString; }
        BSTR GetHelpString() { return m_bstrHelpString; }
        SnapInActionTypeConstants GetActionType() { return m_ActionType; }
        BSTR GetURL() { return m_bstrURL; }
        BSTR GetScript() { return m_bstrScript; }

    private:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITask

        SIMPLE_PROPERTY_RW(CTask,       Index,          long,                               DISPID_TASK_INDEX);
        BSTR_PROPERTY_RW(CTask,         Key,                                                DISPID_TASK_KEY);
        SIMPLE_PROPERTY_RW(CTask,       Visible,        VARIANT_BOOL,                       DISPID_TASK_VISIBLE);
        VARIANTREF_PROPERTY_RW(CTask,   Tag,                                                DISPID_TASK_TAG);
        BSTR_PROPERTY_RW(CTask,         Text,                                               DISPID_TASK_TEXT);
        SIMPLE_PROPERTY_RW(CTask,       ImageType,      SnapInTaskpadImageTypeConstants,    DISPID_TASK_IMAGE_TYPE);
        BSTR_PROPERTY_RW(CTask,         MouseOverImage,                                     DISPID_TASK_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTask,         MouseOffImage,                                      DISPID_TASK_MOUSE_OVER_IMAGE);
        BSTR_PROPERTY_RW(CTask,         FontFamily,                                         DISPID_TASK_FONT_FAMILY);
        BSTR_PROPERTY_RW(CTask,         EOTFile,                                            DISPID_TASK_EOT_FILE);
        BSTR_PROPERTY_RW(CTask,         SymbolString,                                       DISPID_TASK_SYMBOL_STRING);
        BSTR_PROPERTY_RW(CTask,         HelpString,                                         DISPID_TASK_HELP_STRING);
        SIMPLE_PROPERTY_RW(CTask,       ActionType,     SnapInActionTypeConstants,          DISPID_TASK_ACTION_TYPE);
        BSTR_PROPERTY_RW(CTask,         URL,                                                DISPID_TASK_URL);
        BSTR_PROPERTY_RW(CTask,         Script,                                             DISPID_TASK_SCRIPT);
      
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Task,               // name
                                &CLSID_Task,        // clsid
                                "Task",             // objname
                                "Task",             // lblname
                                &CTask::Create,     // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ITask,         // dispatch IID
                                NULL,               // event IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _TASK_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tls.h ===
//=--------------------------------------------------------------------------=
// tls.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTls class definition
//
// This object manages TLS on behalf of all objects in the designer runtime.
//
//=--------------------------------------------------------------------------=

#ifndef _TLS_DEFINED_
#define _TLS_DEFINED_

// Any code in the designer runtime that needs TLS needs to reserve a slot
// by adding a #define for itself (e.g. TLS_SLOT_PPGWRAP) and incrementing
// TLS_SLOT_COUNT. To use TLS call CTls::Set and CTls::Get rather than the
// Win32 TlsSetValue/TlsGetValue.

#define TLS_SLOT_PPGWRAP 0
#define TLS_SLOT_COUNT   1


class CTls
{
public:
    static void Initialize();
    static void Destroy();

    static HRESULT Set(UINT uiSlot, void *pvData);
    static HRESULT Get(UINT uiSlot, void **ppvData);
    
private:
    static DWORD m_adwTlsIndexes[TLS_SLOT_COUNT];
    static BOOL m_fAllocedTls;
};

#endif // _TLS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tls.cpp ===
//=--------------------------------------------------------------------------=
// tls.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTls class implementation
//
// This object manages TLS on behalf of all objects in the designer runtime.
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tls.h"

// for ASSERT and FAIL
//
SZTHISFILE

DWORD CTls::m_adwTlsIndexes[TLS_SLOT_COUNT];
BOOL CTls::m_fAllocedTls = FALSE;

#define INVALID_INDEX (DWORD)0xFFFFFFFF

//=--------------------------------------------------------------------------=
// CTls::Initialize
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Calls TlsAlloc() for all slots. This is called from InitializeLibrary in
// main.cpp that is called by the framework during DllMain when the dll is
// loaded.
//
void CTls::Initialize()
{
    UINT i = 0;

    m_fAllocedTls = TRUE;

    for (i = 0; i < TLS_SLOT_COUNT; i++)
    {
        m_adwTlsIndexes[i] = ::TlsAlloc();
    }
}


//=--------------------------------------------------------------------------=
// CTls::Initialize
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Calls TlsFree() for all slots that have allocated TLS. This is called from
// UninitializeLibrary in main.cpp that is called by the framework during
// DllMain when the dll is unloaded.
//
void CTls::Destroy()
{
    UINT i = 0;

    if (m_fAllocedTls)
    {
        for (i = 0; i < TLS_SLOT_COUNT; i++)
        {
            if (INVALID_INDEX != m_adwTlsIndexes[i])
            {
                (void)::TlsFree(m_adwTlsIndexes[i]);
                m_adwTlsIndexes[i] = INVALID_INDEX;
            }
        }
        m_fAllocedTls = FALSE;
    }
}


//=--------------------------------------------------------------------------=
// CTls::Set
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Checks slot number validity and calls TlsSetValue. Use this function
// rather than TlsSetValue directly.
//
HRESULT CTls::Set(UINT uiSlot, void *pvData)
{
    HRESULT hr = S_OK;

    IfFalseGo(m_fAllocedTls, SID_E_INTERNAL);
    IfFalseGo(uiSlot < TLS_SLOT_COUNT, SID_E_INVALIDARG);
    IfFalseGo(INVALID_INDEX != m_adwTlsIndexes[uiSlot], SID_E_OUTOFMEMORY);
    IfFalseGo(::TlsSetValue(m_adwTlsIndexes[uiSlot], pvData), HRESULT_FROM_WIN32(::GetLastError()));

Error:
    GLOBAL_EXCEPTION_CHECK(hr);
    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
// CTls::Get
//=--------------------------------------------------------------------------=
//
// Parameters:
//      None
//
// Output:
//      None
//
// Notes:
//
// Checks slot number validity and calls TlsGetValue. Use this function
// rather than TlsGetValue directly.
//
HRESULT CTls::Get(UINT uiSlot, void **ppvData)
{
    HRESULT hr = S_OK;

    IfFalseGo(m_fAllocedTls, SID_E_INTERNAL);
    IfFalseGo(uiSlot < TLS_SLOT_COUNT, SID_E_INVALIDARG);
    IfFalseGo(INVALID_INDEX != m_adwTlsIndexes[uiSlot], SID_E_OUTOFMEMORY);

    *ppvData = ::TlsGetValue(m_adwTlsIndexes[uiSlot]);
    if (NULL == *ppvData)
    {
        if (NO_ERROR != ::GetLastError())
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }

Error:
    GLOBAL_EXCEPTION_CHECK(hr);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tlver.h ===
//=--------------------------------------------------------------------------=
// tlver.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// Type library version definitions
//
//=--------------------------------------------------------------------------=

#define TLIB_VERSION        1.0
#define TLIB_VERSION_MAJOR  1
#define TLIB_VERSION_MINOR  0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tasks.h ===
//=--------------------------------------------------------------------------=
// tasks.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTasks class definition - implements Tasks collection
//
//=--------------------------------------------------------------------------=

#ifndef _TASKS_DEFINED_
#define _TASKS_DEFINED_

#include "collect.h"

class CTasks : public CSnapInCollection<ITask, Task, ITasks>,
               public CPersistence
{
    protected:
        CTasks(IUnknown *punkOuter);
        ~CTasks();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITasks
        STDMETHOD(Add)(VARIANT   Index,
                       VARIANT   Key, 
                       VARIANT   Text,
                       Task    **ppTask);

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);


};

DEFINE_AUTOMATIONOBJECTWEVENTS2(Tasks,              // name
                                &CLSID_Tasks,       // clsid
                                "Tasks",            // objname
                                "Tasks",            // lblname
                                &CTasks::Create,    // creation function
                                TLIB_VERSION_MAJOR, // major version
                                TLIB_VERSION_MINOR, // minor version
                                &IID_ITasks,        // dispatch IID
                                NULL,               // no events IID
                                HELP_FILENAME,      // help file
                                TRUE);              // thread safe


#endif // _TASKS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbar.cpp ===
//=--------------------------------------------------------------------------=
// toolbar.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbar class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "toolbar.h"
#include "toolbars.h"
#include "button.h"
#include "images.h"
#include "image.h"
#include "ctlbar.h"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// Macro: MAKE_BUTTON_ID()
//
// The command ID is an int in MMCBUTTON but in practice only the
// low word of that int is received in an MMCN_BTN_CLICK notification.
// So, we have 16 bits to indentify both an MMCToolbar object and
// one of its buttons. We use the high 8 bits for the index of the
// toolbar in SnapInDesignerDef.Toolbars and the lower 8 for the index
// of the button in MMCToolbar.Buttons. This means that there can only
// be 256 toolbars and only 256 buttons per toolbar.
//=--------------------------------------------------------------------------=

#define MAKE_BUTTON_ID(pMMCButton) MAKEWORD(pMMCButton->GetIndex(), m_Index)



// Macro: MAKE_MENUBUTTON_ID()
//
// The command for a menu button is the C++ pointer to the MMCButton object
// that owns it.

#define MAKE_MENUBUTTON_ID(pMMCButton) reinterpret_cast<int>(pMMCButton)

const GUID *CMMCToolbar::m_rgpPropertyPageCLSIDs[2] =
{
    &CLSID_MMCToolbarGeneralPP,
    &CLSID_MMCToolbarButtonsPP
};



VARTYPE CMMCToolbar::m_rgvtButtonClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CMMCToolbar::m_eiButtonClick =
{
    DISPID_TOOLBAR_EVENT_BUTTON_CLICK,
    sizeof(m_rgvtButtonClick) / sizeof(m_rgvtButtonClick[0]),
    m_rgvtButtonClick
};



VARTYPE CMMCToolbar::m_rgvtButtonDropDown[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CMMCToolbar::m_eiButtonDropDown =
{
    DISPID_TOOLBAR_EVENT_BUTTON_DROPDOWN,
    sizeof(m_rgvtButtonDropDown) / sizeof(m_rgvtButtonDropDown[0]),
    m_rgvtButtonDropDown
};



VARTYPE CMMCToolbar::m_rgvtButtonMenuClick[2] =
{
    VT_UNKNOWN,
    VT_UNKNOWN
};

EVENTINFO CMMCToolbar::m_eiButtonMenuClick =
{
    DISPID_TOOLBAR_EVENT_BUTTON_MENU_CLICK,
    sizeof(m_rgvtButtonMenuClick) / sizeof(m_rgvtButtonMenuClick[0]),
    m_rgvtButtonMenuClick
};




#pragma warning(disable:4355)  // using 'this' in constructor

CMMCToolbar::CMMCToolbar(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_MMCTOOLBAR,
                            static_cast<IMMCToolbar *>(this),
                            static_cast<CMMCToolbar *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCToolbar,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCToolbar::~CMMCToolbar()
{
    FREESTRING(m_bstrKey);
    RELEASE(m_piButtons);
    RELEASE(m_piImages);
    FREESTRING(m_bstrName);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrImagesKey);
    Detach();
    InitMemberVariables();
}

void CMMCToolbar::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_piButtons = NULL;
    m_bstrName = NULL;
    ::VariantInit(&m_varTag);
    m_piImages = NULL;
    m_bstrImagesKey = NULL;
    m_pButtons = NULL;
    m_fIAmAToolbar = FALSE;
    m_fIAmAMenuButton = FALSE;
    m_cAttaches = 0;
}

IUnknown *CMMCToolbar::Create(IUnknown * punkOuter)
{
    HRESULT      hr = S_OK;
    IUnknown    *punkToolbar = NULL;
    IUnknown    *punkButtons = NULL;
    CMMCToolbar *pMMCToolbar = New CMMCToolbar(punkOuter);

    IfFalseGo(NULL != pMMCToolbar, SID_E_OUTOFMEMORY);
    punkToolbar = pMMCToolbar->PrivateUnknown();

    punkButtons = CMMCButtons::Create(NULL);
    IfFalseGo(NULL != punkButtons, SID_E_OUTOFMEMORY);

    IfFailGo(punkButtons->QueryInterface(IID_IMMCButtons,
                         reinterpret_cast<void **>(&pMMCToolbar->m_piButtons)));

    IfFailGo(CSnapInAutomationObject::GetCxxObject(punkButtons,
                                                   &pMMCToolbar->m_pButtons));
    pMMCToolbar->m_pButtons->SetToolbar(pMMCToolbar);

Error:
    QUICK_RELEASE(punkButtons);
    if (FAILED(hr))
    {
        RELEASE(punkToolbar);
    }
    return punkToolbar;
}


HRESULT CMMCToolbar::IsToolbar(BOOL *pfIsToolbar)
{
    HRESULT     hr = S_OK;
    CMMCButton *pMMCButton = NULL;
    long        i = 0;
    long        cButtons = m_pButtons->GetCount();

    *pfIsToolbar = FALSE;

    // If there are no buttons, then this is not a toolbar

    IfFalseGo(0 != cButtons, S_OK);

    while (i < cButtons)
    {
        
        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));
        IfFalseGo(pMMCButton->GetStyle() != siDropDown, S_OK);
        i++;
    }

    *pfIsToolbar = TRUE;
    m_fIAmAToolbar = TRUE;
    m_fIAmAMenuButton = FALSE;

Error:
    RRETURN(hr);
}


HRESULT CMMCToolbar::IsMenuButton(BOOL *pfIsMenuButton)
{
    HRESULT     hr = S_OK;
    CMMCButton *pMMCButton = NULL;
    long        i = 0;
    long        cButtons = m_pButtons->GetCount();

    *pfIsMenuButton = FALSE;

    // If there are no button definitions, then this is not a menu button

    IfFalseGo(0 != cButtons, S_OK);

    while (i < cButtons)
    {

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));
        IfFalseGo(siDropDown == pMMCButton->GetStyle(), S_OK);
        i++;
    }

    *pfIsMenuButton = TRUE;
    m_fIAmAMenuButton = TRUE;
    m_fIAmAToolbar = FALSE;

Error:
    RRETURN(hr);
}


HRESULT CMMCToolbar::Attach(IUnknown *punkControl)
{
    HRESULT      hr = S_OK;
    IToolbar    *piToolbar = NULL;
    IMenuButton *piMenuButton = NULL;

    // Increment attachment count
    m_cAttaches++;

    // Pass control to AttachXxxx methods

    if (m_fIAmAToolbar)
    {
        IfFailGo(punkControl->QueryInterface(IID_IToolbar,
                                      reinterpret_cast<void **>(&piToolbar)));
        IfFailGo(AttachToolbar(piToolbar));
    }
    else if (m_fIAmAMenuButton)
    {
        IfFailGo(punkControl->QueryInterface(IID_IMenuButton,
                                   reinterpret_cast<void **>(&piMenuButton)));
        IfFailGo(AttachMenuButton(piMenuButton));
    }

Error:
    if (FAILED(hr))
    {
        Detach();
    }
    QUICK_RELEASE(piToolbar);
    QUICK_RELEASE(piMenuButton);
    RRETURN(hr);
}

void CMMCToolbar::Detach()
{
    m_cAttaches--;
}


HRESULT CMMCToolbar::AttachToolbar(IToolbar *piToolbar)
{
    HRESULT       hr = S_OK;
    CMMCButton   *pMMCButton = NULL;
    long          i = 0;
    long          cButtons = m_pButtons->GetCount();

    // Add the images

    IfFailGo(AddToolbarImages(piToolbar));

    // Add the buttons

    for (i = 0; i < cButtons; i++)
    {
        // Get the button definition

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));

        IfFailGo(AddButton(piToolbar, pMMCButton));
    }

Error:
    RRETURN(hr);
}

HRESULT CMMCToolbar::AddToolbarImages(IToolbar *piToolbar)
{
    HRESULT        hr = S_OK;
    IMMCImageList *piMMCImageList = NULL;
    IMMCImages    *piMMCImages = NULL;
    CMMCImages    *pMMCImages = NULL;
    CMMCImage     *pMMCImage = NULL;
    long           cImages = 0;
    long           i = 0;
    HBITMAP        hbitmap = NULL;
    OLE_COLOR      OleColorMask = 0;
    COLORREF       ColorRefMask = RGB(0x00,0x00,0x00);

    BITMAP bitmap;
    ::ZeroMemory(&bitmap, sizeof(bitmap));

    // Make sure we have an image list. If no VB code has done a get
    // on MMCToolbar.ImageList then we have yet to pull the image list
    // from the master collection. Doing our own get will take care
    // of that. We immediately release it because the get will put it
    // into m_piImages.

    if (NULL == m_piImages)
    {
        IfFailGo(get_ImageList(reinterpret_cast<MMCImageList **>(&piMMCImageList)));
        RELEASE(piMMCImageList);
    }

    // Now if there is no image list then the project was saved without
    // an image list specified in the toolbar definition.

    if (NULL == m_piImages)
    {
        hr = SID_E_TOOLBAR_HAS_NO_IMAGELIST;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the image collection

    IfFailGo(m_piImages->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCImages, &pMMCImages));

    /// Make sure it contains images

    cImages = pMMCImages->GetCount();
    if (0 == cImages)
    {
        hr = SID_E_TOOLBAR_HAS_NO_IMAGES;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the mask color

    IfFailGo(m_piImages->get_MaskColor(&OleColorMask));
    IfFailGo(::OleTranslateColor(OleColorMask, NULL, &ColorRefMask));

    // Add the bitmaps to the MMC toolbar

    for (i = 0; i < cImages; i++)
    {
        // Get the bitmap handle

        IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                     pMMCImages->GetItemByIndex(i), &pMMCImage));

        IfFailGo(pMMCImage->GetPictureHandle(PICTYPE_BITMAP, 
                                    reinterpret_cast<OLE_HANDLE *>(&hbitmap)));
        // Get the bitmap definition so we can get its size in pixels. (IPicture
        // returns size in HIMETRIC so we would have to convert it to pixels).

        if (::GetObject(hbitmap, sizeof(BITMAP), (LPSTR)&bitmap) <= 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            EXCEPTION_CHECK_GO(hr);
        }

        // Add one bitmap to the MMC toolbar

        hr = piToolbar->AddBitmap(1, hbitmap, bitmap.bmWidth, bitmap.bmHeight,
                                  ColorRefMask);
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    if (SID_E_INVALIDARG == hr)
    {
        EXCEPTION_CHECK(hr);
    }
    QUICK_RELEASE(piMMCImageList);
    QUICK_RELEASE(piMMCImages);
    RRETURN(hr);
}


HRESULT CMMCToolbar::AddButton(IToolbar *piToolbar, CMMCButton *pMMCButton)
{
    HRESULT       hr = S_OK;
    IMMCImages   *piMMCImages = NULL;
    IMMCImage    *piMMCImage = NULL;
    long          lImageIndex = 0;

    SnapInButtonStyleConstants Style = siDefault;

    MMCBUTTON MMCButton;
    ::ZeroMemory(&MMCButton, sizeof(MMCButton));

    if (NULL == m_piImages)
    {
        hr = SID_E_TOOLBAR_HAS_NO_IMAGELIST;
        EXCEPTION_CHECK_GO(hr);
    }

    // Get the images collection so that we can get the numeric image index

    IfFailGo(m_piImages->get_ListImages(reinterpret_cast<MMCImages **>(&piMMCImages)));

    // Get the button attributes and translate them into an MMCBUTTON

    // Get the image and get its index

    hr = piMMCImages->get_Item(pMMCButton->GetImage(), reinterpret_cast<MMCImage **>(&piMMCImage));
    if (SID_E_ELEMENT_NOT_FOUND == hr)
    {
        hr = SID_E_TOOLBAR_IMAGE_NOT_FOUND;
        EXCEPTION_CHECK_GO(hr);
    }
    IfFailGo(hr);

    IfFailGo(piMMCImage->get_Index(&lImageIndex));
    RELEASE(piMMCImage);
    MMCButton.nBitmap = static_cast<int>(lImageIndex - 1L);

    // See the top of the file for how we create button IDs

    MMCButton.idCommand = MAKE_BUTTON_ID(pMMCButton);

    // Tell the button who owns it. This allows the button to handle
    // property changes that must be sent to MMC via IToolbar

    pMMCButton->SetToolbar(this);

    // Get the buttons type

    Style = pMMCButton->GetStyle();

    if ( siDefault == (Style & siDefault) )
    {
        MMCButton.fsType |= TBSTYLE_BUTTON;
    }

    if ( siCheck == (Style & siCheck) )
    {
        MMCButton.fsType |= TBSTYLE_CHECK;
    }

    if ( siButtonGroup == (Style & siButtonGroup) )
    {
        MMCButton.fsType |= TBSTYLE_GROUP;
    }

    if ( siSeparator == (Style & siSeparator) )
    {
        MMCButton.fsType |= TBSTYLE_SEP;
    }

    // Set the button state.

    if (siPressed == pMMCButton->GetValue())
    {
        if (TBSTYLE_CHECK == MMCButton.fsType)
        {
            MMCButton.fsState |= TBSTATE_CHECKED;
        }
        else
        {
            MMCButton.fsState |= TBSTATE_PRESSED;
        }
    }

    if (VARIANT_TRUE == pMMCButton->GetEnabled())
    {
        MMCButton.fsState |= TBSTATE_ENABLED;
    }

    if (VARIANT_FALSE == pMMCButton->GetVisible())
    {
        MMCButton.fsState |= TBSTATE_HIDDEN;
    }

    if (VARIANT_TRUE == pMMCButton->GetMixedState())
    {
        MMCButton.fsState |= TBSTATE_INDETERMINATE;
    }

    // Get the caption and tooltip text

    MMCButton.lpButtonText = pMMCButton->GetCaption();
    MMCButton.lpTooltipText = pMMCButton->GetToolTipText();

    // Ask MMC to add the button

    hr = piToolbar->InsertButton(static_cast<int>(pMMCButton->GetIndex() - 1L),
                                 &MMCButton);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMMCImages);
    QUICK_RELEASE(piMMCImage);
    RRETURN(hr);
}


HRESULT CMMCToolbar::RemoveButton(long lButtonIndex)
{
    HRESULT   hr = S_OK;
    IToolbar *piToolbar = NULL;
    
    IfFailGo(CControlbar::GetToolbar(m_pSnapIn, this, &piToolbar));

    hr = piToolbar->DeleteButton(static_cast<int>(lButtonIndex - 1L));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piToolbar);
    RRETURN(hr);
}


HRESULT CMMCToolbar::SetButtonState
(
    CMMCButton       *pMMCButton,
    MMC_BUTTON_STATE  State,
    BOOL              fValue
)
{
    HRESULT   hr = S_OK;
    IToolbar *piToolbar = NULL;

    IfFailGo(CControlbar::GetToolbar(m_pSnapIn, this, &piToolbar));

    hr = piToolbar->SetButtonState(MAKE_BUTTON_ID(pMMCButton), State, fValue);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piToolbar);
    RRETURN(hr);
}



HRESULT CMMCToolbar::GetButtonState
(
    CMMCButton       *pMMCButton,
    MMC_BUTTON_STATE  State,
    BOOL             *pfValue
)
{
    HRESULT   hr = S_OK;
    IToolbar *piToolbar = NULL;

    IfFailGo(CControlbar::GetToolbar(m_pSnapIn, this, &piToolbar));

    hr = piToolbar->GetButtonState(MAKE_BUTTON_ID(pMMCButton), State, pfValue);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piToolbar);
    RRETURN(hr);
}


HRESULT CMMCToolbar::SetMenuButtonState
(
    CMMCButton       *pMMCButton,
    MMC_BUTTON_STATE  State,
    BOOL              fValue
)
{
    HRESULT      hr = S_OK;
    IMenuButton *piMenuButton = NULL;

    IfFailGo(CControlbar::GetMenuButton(m_pSnapIn, this, &piMenuButton));

    hr = piMenuButton->SetButtonState(MAKE_MENUBUTTON_ID(pMMCButton), State,
                                      fValue);
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMenuButton);
    RRETURN(hr);
}


HRESULT CMMCToolbar::SetMenuButtonText
(
    CMMCButton *pMMCButton,
    BSTR        bstrText,
    BSTR        bstrToolTipText
)
{
    HRESULT      hr = S_OK;
    IMenuButton *piMenuButton = NULL;

    IfFailGo(CControlbar::GetMenuButton(m_pSnapIn, this, &piMenuButton));

    hr = piMenuButton->SetButton(MAKE_MENUBUTTON_ID(pMMCButton),
                                   static_cast<LPOLESTR>(bstrText),
                                   static_cast<LPOLESTR>(bstrToolTipText));
    EXCEPTION_CHECK_GO(hr);

Error:
    QUICK_RELEASE(piMenuButton);
    RRETURN(hr);
}


HRESULT CMMCToolbar::AttachMenuButton(IMenuButton *piMenuButton)
{
    HRESULT         hr = S_OK;
    CMMCButton      *pMMCButton = NULL;
    long            i = 0;
    long            cButtons = m_pButtons->GetCount();
    int             idButton = 0;

    // The toolbar contains one or more buttons that each contain one or more
    // menu buttons. We need to iterate through the buttons and add each menu
    // button.

    for (i = 0; i < cButtons; i++)
    {
        // Get the button definition

        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_pButtons->GetItemByIndex(i),
                                                       &pMMCButton));

        // Tell the button who owns it.

        pMMCButton->SetToolbar(this);

        // Ask MMC to add the button. We use a pointer to the button's C++
        // object as its command ID.

        hr = piMenuButton->AddButton(MAKE_MENUBUTTON_ID(pMMCButton),
                                     pMMCButton->GetCaption(),
                                     pMMCButton->GetToolTipText());

        EXCEPTION_CHECK_GO(hr);

        // Use the button's Enabled and Visible properties to set the initial
        // visual state of the menu button.

        hr = piMenuButton->SetButtonState(
                                 MAKE_MENUBUTTON_ID(pMMCButton),
                                 ENABLED,
                                 VARIANTBOOL_TO_BOOL(pMMCButton->GetEnabled()));
        EXCEPTION_CHECK_GO(hr);

        hr = piMenuButton->SetButtonState(
                                MAKE_MENUBUTTON_ID(pMMCButton),
                                HIDDEN,
                                !VARIANTBOOL_TO_BOOL(pMMCButton->GetVisible()));
        EXCEPTION_CHECK_GO(hr);
    }

Error:
    RRETURN(hr);
}


HRESULT CMMCToolbar::GetToolbarAndButton
(
    int           idButton,
    CMMCToolbar **ppMMCToolbar,
    CMMCButton  **ppMMCButton,
    CSnapIn      *pSnapIn
)
{
    HRESULT             hr = S_OK;
    IMMCToolbars       *piMMCToolbars = NULL;
    CMMCToolbars       *pMMCToolbars = NULL;
    CMMCToolbar        *pMMCToolbar = NULL;
    CMMCButton         *pMMCButton = NULL;
    long                lToolbarIndex = HIBYTE(LOWORD(idButton)) - 1;
    long                lButtonIndex = LOBYTE(LOWORD(idButton)) - 1;

    *ppMMCToolbar = NULL;
    *ppMMCButton = NULL;

    IfFailGo(pSnapIn->GetSnapInDesignerDef()->get_Toolbars(&piMMCToolbars));
    
    IfFailGo(CSnapInAutomationObject::GetCxxObject(piMMCToolbars, &pMMCToolbars));

    IfFalseGo(pMMCToolbars->GetCount() > lToolbarIndex, SID_E_INTERNAL);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                                    pMMCToolbars->GetItemByIndex(lToolbarIndex),
                                    &pMMCToolbar));

    IfFalseGo(pMMCToolbar->m_pButtons->GetCount() > lButtonIndex, SID_E_INTERNAL);

    IfFailGo(CSnapInAutomationObject::GetCxxObject(
                          pMMCToolbar->m_pButtons->GetItemByIndex(lButtonIndex),
                          &pMMCButton));

    *ppMMCToolbar = pMMCToolbar;
    *ppMMCButton = pMMCButton;

Error:
    if (SID_E_INTERNAL == hr)
    {
        GLOBAL_EXCEPTION_CHECK(hr);
    }
    QUICK_RELEASE(piMMCToolbars);
    RRETURN(hr);
}


BOOL CMMCToolbar::Attached()
{
    return (m_cAttaches > 0);
}



void CMMCToolbar::FireButtonClick
(
    IMMCClipboard *piMMCClipboard,
    IMMCButton    *piMMCButton
)
{
    DebugPrintf("Firing %ls_ButtonClick(%ls)\r\n", m_bstrName, (static_cast<CMMCButton *>(piMMCButton))->GetCaption());

    FireEvent(&m_eiButtonClick, piMMCClipboard, piMMCButton);
}



void CMMCToolbar::FireButtonDropDown
(
    IMMCClipboard *piMMCClipboard,
    IMMCButton    *piMMCButton
)
{
    DebugPrintf("Firing %ls_ButtonDropDown(%ls)\r\n", m_bstrName, (static_cast<CMMCButton *>(piMMCButton))->GetCaption());

    FireEvent(&m_eiButtonDropDown, piMMCClipboard, piMMCButton);
}




void CMMCToolbar::FireButtonMenuClick
(
    IMMCClipboard  *piMMCClipboard,
    IMMCButtonMenu *piMMCButtonMenu
)
{
    DebugPrintf("Firing %ls_ButtonMenuClick(%ls)\r\n", m_bstrName, (static_cast<CMMCButtonMenu *>(piMMCButtonMenu))->GetText());

    FireEvent(&m_eiButtonMenuClick, piMMCClipboard, piMMCButtonMenu);
}



//=--------------------------------------------------------------------------=
//                       IMMCToolbar Properties
//=--------------------------------------------------------------------------=

STDMETHODIMP CMMCToolbar::get_ImageList(MMCImageList **ppMMCImageList)
{
    RRETURN(GetImages(reinterpret_cast<IMMCImageList **>(ppMMCImageList), m_bstrImagesKey, &m_piImages));
}

STDMETHODIMP CMMCToolbar::putref_ImageList(MMCImageList *pMMCImageList)
{
    RRETURN(SetImages(reinterpret_cast<IMMCImageList *>(pMMCImageList), &m_bstrImagesKey, &m_piImages));
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbar::Persist()
{
    HRESULT      hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailGo(CPersistence::Persist());

    IfFailGo(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailGo(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailGo(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailGo(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailGo(PersistObject(&m_piButtons, CLSID_MMCButtons,
                           OBJECT_TYPE_MMCBUTTONS, IID_IMMCButtons,
                           OLESTR("Buttons")));

    if ( InitNewing() || Loading() )
    {
        IfFailGo(CSnapInAutomationObject::GetCxxObject(m_piButtons, &m_pButtons));
        m_pButtons->SetToolbar(this);
    }

    IfFailGo(PersistBstr(&m_bstrImagesKey, L"", OLESTR("Images")));

    IfFailGo(PersistDISPID());

    if ( InitNewing() )
    {
        RELEASE(m_piImages);
    }

Error:

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbar::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCToolbar == riid)
    {
        *ppvObjOut = static_cast<IMMCToolbar *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
//                 CSnapInAutomationObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbar::OnSetHost()
{
    RRETURN(SetObjectHost(m_piButtons));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbar.h ===
//=--------------------------------------------------------------------------=
// toolbar.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbar class definition - implements MMCToolbar object
//
//=--------------------------------------------------------------------------=

#ifndef _TOOLBAR_DEFINED_
#define _TOOLBAR_DEFINED_

#include "buttons.h"
#include "button.h"
#include "snapin.h"

class CMMCButtons;
class CMMCButton;

class CMMCToolbar : public CSnapInAutomationObject,
                    public CPersistence,
                    public IMMCToolbar
{
    private:
        CMMCToolbar(IUnknown *punkOuter);
        ~CMMCToolbar();
    
    public:
        static IUnknown *Create(IUnknown * punk);

    public:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // IMMCToolbar

        SIMPLE_PROPERTY_RW(CMMCToolbar, Index, long, DISPID_TOOLBAR_INDEX);
        BSTR_PROPERTY_RW(CMMCToolbar, Key, DISPID_TOOLBAR_KEY);
        COCLASS_PROPERTY_RO(CMMCToolbar, Buttons, MMCButtons, IMMCButtons, DISPID_TOOLBAR_BUTTONS);

        STDMETHOD(get_ImageList)(MMCImageList **ppMMCImageList);
        STDMETHOD(putref_ImageList)(MMCImageList *pMMCImageList);

        BSTR_PROPERTY_RW(CMMCToolbar, Name, DISPID_TOOLBAR_NAME);
        VARIANTREF_PROPERTY_RW(CMMCToolbar, Tag, DISPID_TOOLBAR_TAG);

    // Public utility methods
    public:

        void FireButtonClick(IMMCClipboard *piMMCClipboard,
                             IMMCButton    *piMMCButton);
                                       
        void FireButtonDropDown(IMMCClipboard *piMMCClipboard,
                                IMMCButton    *piMMCButton);

        void FireButtonMenuClick(IMMCClipboard  *piMMCClipboard,
                                 IMMCButtonMenu *piMMCButtonMenu);
        
        HRESULT IsToolbar(BOOL *pfIsToolbar);
        HRESULT IsMenuButton(BOOL *pfIsMenuButton);
        HRESULT Attach(IUnknown *punkControl);
        void Detach();
        void SetSnapIn(CSnapIn *pSnapIn) { m_pSnapIn = pSnapIn; }
        CSnapIn *GetSnapIn() { return m_pSnapIn; }

        // Determines whether the toolbar is attached to an MMC toolbar or
        // menu button
        
        BOOL Attached();

        // Adds a button to the MMC toolbar

        HRESULT AddButton(IToolbar *piToolbar, CMMCButton *pMMCButton);

        // Removes a button from the MMC toolbar
        
        HRESULT RemoveButton(long lButtonIndex);

        // Get and set button and menu button state

        HRESULT GetButtonState(CMMCButton       *pMMCButton,
                               MMC_BUTTON_STATE  State,
                               BOOL             *pfValue);

        HRESULT SetButtonState(CMMCButton       *pMMCButton,
                               MMC_BUTTON_STATE  State,
                               BOOL              fValue);
        
        HRESULT SetMenuButtonState(CMMCButton       *pMMCButton,
                                   MMC_BUTTON_STATE  State,
                                   BOOL              fValue);

        HRESULT SetMenuButtonText(CMMCButton *pMMCButton,
                                  BSTR        bstrText,
                                  BSTR        bstrToolTipText);

        // Note there is no GetMenuButtonState because MMC does not support it

        // Given a command ID returns the owning toolbar and button

        static HRESULT GetToolbarAndButton(int           idButton,
                                           CMMCToolbar **ppMMCToolbar,
                                           CMMCButton  **ppMMCButton,
                                           CSnapIn      *pSnapIn);

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:

        void InitMemberVariables();
        HRESULT AttachToolbar(IToolbar *piToolbar);
        HRESULT AddToolbarImages(IToolbar *piToolbar);
        HRESULT AttachMenuButton(IMenuButton *piMenuButton);

        CSnapIn           *m_pSnapIn;         // back ptr to snap-in
        IMMCImageList     *m_piImages;        // MMCToolbar.Images
        BSTR               m_bstrImagesKey;   // Key of MMCToolbar.ImageList
                                              // in SnapInDesignerDef.ImageLists
        CMMCButtons       *m_pButtons;        // MMCToolbar.Buttons
        BOOL               m_fIAmAToolbar;    // TRUE=MMCToolbar is a toolbar
        BOOL               m_fIAmAMenuButton; // TRUE=MMCToolbar is a menu button
        long               m_cAttaches;       // no. of times toolbar has been
                                              // attached to an MMC controlbar

        // Property page CLSIDs for ISpecifyPropertyPages
        
        static const GUID *m_rgpPropertyPageCLSIDs[2];

        // Event parameter definitions

        static VARTYPE   m_rgvtButtonClick[2];
        static EVENTINFO m_eiButtonClick;

        static VARTYPE   m_rgvtButtonDropDown[2];
        static EVENTINFO m_eiButtonDropDown;

        static VARTYPE   m_rgvtButtonMenuClick[2];
        static EVENTINFO m_eiButtonMenuClick;
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCToolbar,                  // name
                                &CLSID_MMCToolbar,           // clsid
                                "MMCToolbar",                // objname
                                "MMCToolbar",                // lblname
                                &CMMCToolbar::Create,        // creation function
                                TLIB_VERSION_MAJOR,          // major version
                                TLIB_VERSION_MINOR,          // minor version
                                &IID_IMMCToolbar,            // dispatch IID
                                &DIID_DMMCToolbarEvents,     // event IID
                                HELP_FILENAME,               // help file
                                TRUE);                       // thread safe


#endif // _TOOLBAR_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbars.cpp ===
//=--------------------------------------------------------------------------=
// toolbars.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbars class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "toolbars.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CMMCToolbars::CMMCToolbars(IUnknown *punkOuter) :
    CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>(
                                             punkOuter,
                                             OBJECT_TYPE_MMCTOOLBARS,
                                             static_cast<IMMCToolbars *>(this),
                                             static_cast<CMMCToolbars *>(this),
                                             CLSID_MMCToolbar,
                                             OBJECT_TYPE_MMCTOOLBAR,
                                             IID_IMMCToolbar,
                                             static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_MMCToolbars,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CMMCToolbars::~CMMCToolbars()
{
}

IUnknown *CMMCToolbars::Create(IUnknown * punkOuter)
{
    CMMCToolbars *pMMCToolbars = New CMMCToolbars(punkOuter);
    if (NULL == pMMCToolbars)
    {
        return NULL;
    }
    else
    {
        return pMMCToolbars->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbars::Persist()
{
    HRESULT       hr = S_OK;
    IMMCToolbar  *piMMCToolbar = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>::Persist(piMMCToolbar);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CMMCToolbars::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_IMMCToolbars == riid)
    {
        *ppvObjOut = static_cast<IMMCToolbars *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdefs.cpp ===
//=--------------------------------------------------------------------------=
// tpdvdefs.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpadViewDefs class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tpdvdefs.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor

CTaskpadViewDefs::CTaskpadViewDefs(IUnknown *punkOuter) :
    CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>(
                                          punkOuter,
                                          OBJECT_TYPE_TASKPADVIEWDEFS,
                                          static_cast<ITaskpadViewDefs *>(this),
                                          static_cast<CTaskpadViewDefs *>(this),
                                          CLSID_TaskpadViewDef,
                                          OBJECT_TYPE_TASKPADVIEWDEF,
                                          IID_ITaskpadViewDef,
                                          static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_TaskpadViewDefs,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
}

#pragma warning(default:4355)  // using 'this' in constructor


CTaskpadViewDefs::~CTaskpadViewDefs()
{
}

IUnknown *CTaskpadViewDefs::Create(IUnknown * punkOuter)
{
    CTaskpadViewDefs *pTaskpadViewDefs = New CTaskpadViewDefs(punkOuter);
    if (NULL == pTaskpadViewDefs)
    {
        return NULL;
    }
    else
    {
        return pTaskpadViewDefs->PrivateUnknown();
    }
}


//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDefs::Persist()
{
    HRESULT          hr = S_OK;
    ITaskpadViewDef *piTaskpadViewDef = NULL;

    IfFailRet(CPersistence::Persist());
    hr = CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>::Persist(piTaskpadViewDef);

    RRETURN(hr);
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CTaskpadViewDefs::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if(IID_ITaskpadViewDefs == riid)
    {
        *ppvObjOut = static_cast<ITaskpadViewDefs *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>::InternalQueryInterface(riid, ppvObjOut);
}

// CSnapInCollection specialization

HRESULT CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>::GetMaster(ITaskpadViewDefs **ppiMasterTaskpadViewDefs)
{
    H_RRETURN(GetTaskpadViewDefs(ppiMasterTaskpadViewDefs));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdefs.h ===
//=--------------------------------------------------------------------------=
// tpdvdefs.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpadViewDefs class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _TPDVDEFS_DEFINED_
#define _TPDVDEFS_DEFINED_

#define MASTER_COLLECTION
#include "collect.h"

class CTaskpadViewDefs : public CSnapInCollection<ITaskpadViewDef, TaskpadViewDef, ITaskpadViewDefs>,
                         public CPersistence
{
    protected:
        CTaskpadViewDefs(IUnknown *punkOuter);
        ~CTaskpadViewDefs();

    public:
        static IUnknown *Create(IUnknown * punk);

    protected:
        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(TaskpadViewDefs,           // name
                                &CLSID_TaskpadViewDefs,    // clsid
                                "TaskpadViewDefs",         // objname
                                "TaskpadViewDefs",         // lblname
                                &CTaskpadViewDefs::Create, // creation function
                                TLIB_VERSION_MAJOR,        // major version
                                TLIB_VERSION_MINOR,        // minor version
                                &IID_ITaskpadViewDefs,     // dispatch IID
                                NULL,                      // no events IID
                                HELP_FILENAME,             // help file
                                TRUE);                     // thread safe


#endif // _TPDVDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdef.h ===
//=--------------------------------------------------------------------------=
// tpdvdef.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// COCXViewDef class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _TPDVDEF_DEFINED_
#define _TPDVDEF_DEFINED_


class CTaskpadViewDef : public CSnapInAutomationObject,
                        public CPersistence,
                        public ITaskpadViewDef
{
    private:
        CTaskpadViewDef(IUnknown *punkOuter);
        ~CTaskpadViewDef();
    
    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    // ITaskpadViewDef

        BSTR_PROPERTY_RW(CTaskpadViewDef,       Name,  DISPID_TASKPADVIEWDEF_NAME);
        SIMPLE_PROPERTY_RW(CTaskpadViewDef,     Index, long, DISPID_TASKPADVIEWDEF_INDEX);
        BSTR_PROPERTY_RW(CTaskpadViewDef,       Key, DISPID_TASKPADVIEWDEF_KEY);
        SIMPLE_PROPERTY_RW(CTaskpadViewDef,     AddToViewMenu, VARIANT_BOOL, DISPID_TASKPADVIEWDEF_ADD_TO_VIEW_MENU);
        BSTR_PROPERTY_RW(CTaskpadViewDef,       ViewMenuText, DISPID_TASKPADVIEWDEF_VIEW_MENU_TEXT);
        BSTR_PROPERTY_RW(CTaskpadViewDef,       ViewMenuStatusBarText, DISPID_TASKPADVIEWDEF_VIEW_MENU_STATUS_BAR_TEXT);
        SIMPLE_PROPERTY_RW(CTaskpadViewDef,     UseWhenTaskpadViewPreferred, VARIANT_BOOL, DISPID_TASKPADVIEWDEF_USE_WHEN_TASKPAD_VIEW_PREFERRED);
        OBJECT_PROPERTY_RO(CTaskpadViewDef,     Taskpad, ITaskpad, DISPID_TASKPADVIEWDEF_TASKPAD);
      
    // Public Utility Methods
    public:
        BSTR GetName() { return m_bstrName; }
        BOOL AddToViewMenu() { return VARIANTBOOL_TO_BOOL(m_AddToViewMenu); }
        LPWSTR GetViewMenuText() { return static_cast<LPWSTR>(m_bstrViewMenuText); }
        LPWSTR GetViewMenuStatusBarText() { return static_cast<LPWSTR>(m_bstrViewMenuStatusBarText); }
        HRESULT SetActualDisplayString(OLECHAR *pwszString);
        OLECHAR *GetActualDisplayString() { return m_pwszActualDisplayString; }

    protected:

    // CPersistence overrides
        virtual HRESULT Persist();

    // CSnapInAutomationObject overrides
        virtual HRESULT OnSetHost();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    private:
        void InitMemberVariables();

        OLECHAR *m_pwszActualDisplayString; // At runtime this will contain the
                                            // actual display string returned
                                            // to MMC for this result view.

};

DEFINE_AUTOMATIONOBJECTWEVENTS2(TaskpadViewDef,           // name
                                &CLSID_TaskpadViewDef,    // clsid
                                "TaskpadViewDef",         // objname
                                "TaskpadViewDef",         // lblname
                                &CTaskpadViewDef::Create, // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_ITaskpadViewDef,     // dispatch IID
                                NULL,                     // event IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _TPDVDEF_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\toolbars.h ===
//=--------------------------------------------------------------------------=
// toolbars.h
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CMMCToolbars class definition - implements design time definition
//
//=--------------------------------------------------------------------------=

#ifndef _TOOLBARS_DEFINED_
#define _TOOLBARS_DEFINED_

#include "collect.h"

class CMMCToolbars : public CSnapInCollection<IMMCToolbar, MMCToolbar, IMMCToolbars>,
                     public CPersistence
{
    protected:
        CMMCToolbars(IUnknown *punkOuter);
        ~CMMCToolbars();

    public:
        static IUnknown *Create(IUnknown * punk);

        DECLARE_STANDARD_UNKNOWN();
        DECLARE_STANDARD_DISPATCH();

    protected:
    // CPersistence overrides
        virtual HRESULT Persist();

    // CUnknownObject overrides
        HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);
};

DEFINE_AUTOMATIONOBJECTWEVENTS2(MMCToolbars,              // name
                                &CLSID_MMCToolbars,       // clsid
                                "MMCToolbars",            // objname
                                "MMCToolbars",            // lblname
                                &CMMCToolbars::Create,    // creation function
                                TLIB_VERSION_MAJOR,       // major version
                                TLIB_VERSION_MINOR,       // minor version
                                &IID_IMMCToolbars,        // dispatch IID
                                NULL,                     // no events IID
                                HELP_FILENAME,            // help file
                                TRUE);                    // thread safe


#endif // _TOOLBARS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\urlvdef.cpp ===
//=--------------------------------------------------------------------------=
// urlvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CURLViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "urlvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE

const GUID *CURLViewDef::m_rgpPropertyPageCLSIDs[1] = { &CLSID_URLViewDefGeneralPP };


#pragma warning(disable:4355)  // using 'this' in constructor

CURLViewDef::CURLViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_URLVIEWDEF,
                            static_cast<IURLViewDef *>(this),
                            static_cast<CURLViewDef *>(this),
                            sizeof(m_rgpPropertyPageCLSIDs) /
                            sizeof(m_rgpPropertyPageCLSIDs[0]),
                            m_rgpPropertyPageCLSIDs,
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_URLViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CURLViewDef::~CURLViewDef()
{
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrName);
    (void)::VariantClear(&m_varTag);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    FREESTRING(m_bstrURL);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    InitMemberVariables();
}

void CURLViewDef::InitMemberVariables()
{
    m_Index = 0;
    m_bstrKey = NULL;
    m_bstrName = NULL;

    ::VariantInit(&m_varTag);

    m_AddToViewMenu = VARIANT_FALSE;
    m_bstrViewMenuText = NULL;
    m_bstrViewMenuStatusBarText = NULL;
    m_bstrURL = NULL;
    m_pwszActualDisplayString = NULL;
}

IUnknown *CURLViewDef::Create(IUnknown * punkOuter)
{
    CURLViewDef *pURLViewDef = New CURLViewDef(punkOuter);
    if (NULL == pURLViewDef)
    {
        return NULL;
    }
    else
    {
        return pURLViewDef->PrivateUnknown();
    }
}


HRESULT CURLViewDef::SetActualDisplayString(OLECHAR *pwszString)
{
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    RRETURN(::CoTaskMemAllocString(pwszString,
                                   &m_pwszActualDisplayString));
}

//=--------------------------------------------------------------------------=
//                         CPersistence Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDef::Persist()
{
    HRESULT hr = S_OK;

    VARIANT varTagDefault;
    ::VariantInit(&varTagDefault);

    IfFailRet(CPersistence::Persist());

    IfFailRet(PersistSimpleType(&m_Index, 0L, OLESTR("Index")));

    IfFailRet(PersistBstr(&m_bstrKey, L"", OLESTR("Key")));

    IfFailRet(PersistBstr(&m_bstrName, L"", OLESTR("Name")));

    IfFailRet(PersistVariant(&m_varTag, varTagDefault, OLESTR("Tag")));

    IfFailRet(PersistSimpleType(&m_AddToViewMenu, VARIANT_FALSE, OLESTR("AddToViewMenu")));

    IfFailRet(PersistBstr(&m_bstrViewMenuText, L"", OLESTR("ViewMenuText")));

    IfFailRet(PersistBstr(&m_bstrViewMenuStatusBarText, L"", OLESTR("ViewMenuStatusBarText")));

    IfFailRet(PersistBstr(&m_bstrURL, L"", OLESTR("URL")));

    return S_OK;
}


//=--------------------------------------------------------------------------=
//                      CUnknownObject Methods
//=--------------------------------------------------------------------------=

HRESULT CURLViewDef::InternalQueryInterface(REFIID riid, void **ppvObjOut) 
{
    if (CPersistence::QueryPersistenceInterface(riid, ppvObjOut) == S_OK)
    {
        ExternalAddRef();
        return S_OK;
    }
    else if (IID_IURLViewDef == riid)
    {
        *ppvObjOut = static_cast<IURLViewDef *>(this);
        ExternalAddRef();
        return S_OK;
    }

    else
        return CSnapInAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\designer\vb98ctls\mssnapr\mssnapr\tpdvdef.cpp ===
//=--------------------------------------------------------------------------=
// tpdvdef.cpp
//=--------------------------------------------------------------------------=
// Copyright (c) 1999, Microsoft Corp.
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=
//
// CTaskpadViewDef class implementation
//
//=--------------------------------------------------------------------------=

#include "pch.h"
#include "common.h"
#include "tpdvdef.h"

// for ASSERT and FAIL
//
SZTHISFILE



#pragma warning(disable:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CTaskpadViewDef::CTaskpadViewDef
//=--------------------------------------------------------------------------=
//
// Parameters:
//      IUnknown *punkOuter [in] outer unknown for aggregation
//
// Output:
//
// Notes:
//
// This object does not support ISpecifyPropertyPages because in the
// the designer it is not the selected object (the contained Taskpad
// object is handed to VB for the property browser). Taskpad also does not
// support ISpecifyPropertyPages because the taskpad property pages (see
// mssnapd\pstaskp.cpp) need the ITaskpadViewDef interface and that is not
// available from the ITaskpad that the property page would receive if the
// user hit the Custom ... button in the property browser. When the user
// selects the properties button or context menu item within the designer
// it is the designer itself that is calling OleCreatePropertyFrame() so
// it can pass the ITaskpadViewDef as the object (see
// CSnapInDesigner::ShowTaskpadViewProperties() in mssnapd\taskpvw.cpp).
//

CTaskpadViewDef::CTaskpadViewDef(IUnknown *punkOuter) :
    CSnapInAutomationObject(punkOuter,
                            OBJECT_TYPE_TASKPADVIEWDEF,
                            static_cast<ITaskpadViewDef *>(this),
                            static_cast<CTaskpadViewDef *>(this),
                            0,    // no property pages
                            NULL, // no property pages
                            static_cast<CPersistence *>(this)),
    CPersistence(&CLSID_TaskpadViewDef,
                 g_dwVerMajor,
                 g_dwVerMinor)
{
    InitMemberVariables();
}

#pragma warning(default:4355)  // using 'this' in constructor


CTaskpadViewDef::~CTaskpadViewDef()
{
    FREESTRING(m_bstrName);
    FREESTRING(m_bstrKey);
    FREESTRING(m_bstrViewMenuText);
    FREESTRING(m_bstrViewMenuStatusBarText);
    RELEASE(m_piTaskpad);
    if (NULL != m_pwszActualDisplayString)
    {
        ::CoTaskMemFree(m_pwszActualDisplayString);
    }
    InitMemberVariables();