                pPB_BitStream, pPB_BitOffset);
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));

                //  Write CBPB
                if (emitCBPB)
                {
                    PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 
                            6, pPB_BitStream, pPB_BitOffset);
					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
                }

				// The P blocks are all empty
	    		PutBits(3, 2, pPB_BitStream, pPB_BitOffset);	// CBPY = 11, no coded P blocks

	  		    //if( bUseDQUANT )
	  		    //{
	    		    // write DQUANT to bit stream here.
	  		    //}

                //  Write MVD{2-4}
                //    Note:  MVD cannot be copied from future frame because 
                //           predictors are different for PB-frame (G.2)
			    if( (EC->GOBHeaderPresent & GOBHeaderMask) != 0 )
			    {
				    GOBHeaderFlag = TRUE;
			    }
			    else
			    {
				    GOBHeaderFlag = FALSE;
			    }
                writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
                        pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);
                //  Write MVDB
                if (emitMVDB)
                {
                    ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
                    ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
                    //  Write horizontal motion vector
                    index = (pCurMB->BlkY1.BHMV + 32)*2;
                    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                             pPB_BitStream, pPB_BitOffset);
                    //  Write vertical motion vector
                    index = (pCurMB->BlkY1.BVMV + 32)*2;
                    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                             pPB_BitStream, pPB_BitOffset);
                }
                //  There is no P-mblock blk data
                //  B-frame block data is always INTER-coded (last param is 0)
                if (emitCBPB)
                {
                    rvs = MBRunValSign;
#ifdef H263P
                    MBEncodeVLC(&rvs, NULL, (pCurMB->CodedBlocksB & 0x3f), 
                                pPB_BitStream, pPB_BitOffset, 0, 0);
#else
                    MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocksB, 
                                pPB_BitStream, pPB_BitOffset, 0, 0);
#endif
                }
            }	// end of else
		}
		else
		{
            //  Copy COD and MCBPC
            //  If it is the first MB in the GOB, then GOB header 
            //  is also copied.
            CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                     pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,// src
                     FutrPMBData[curMB].CBPYBitOff);                     // len
            //  Write MODB
            if ((pCurMB->CodedBlocksB & 0x3f) == 0)
            {
                emitCBPB = 0;
            }
            else
            {
                emitCBPB = 1;
            }
            
            if (((pCurMB->BlkY1.BHMV != 0)
                 || (pCurMB->BlkY1.BVMV != 0))
               || emitCBPB == 1)
            {
                emitMVDB = 1;
            }
            else
            {
                emitMVDB = 0;
            }

            index = (emitMVDB<<1) | emitCBPB;
            PutBits(VLC_MODB[index][1], VLC_MODB[index][0], 
                    pPB_BitStream, pPB_BitOffset);
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));

            //  Write CBPB
            if (emitCBPB)
            {
                PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 
                        6, pPB_BitStream, pPB_BitOffset);
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
            }
            //  Copy CBPY, {DQUANT}
            CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                     pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff // src
                                        + FutrPMBData[curMB].CBPYBitOff,
                     FutrPMBData[curMB].MVDBitOff                        // len
                     - FutrPMBData[curMB].CBPYBitOff);
            //  Write MVD{2-4}
            //    Note:  MVD cannot be copied from future frame because 
            //           predictors are different for PB-frame (G.2)
			if( (EC->GOBHeaderPresent & GOBHeaderMask) != 0 )
			{
				GOBHeaderFlag = TRUE;
			}
			else
			{
				GOBHeaderFlag = FALSE;
			}
            writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
                    pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);
            //  Write MVDB
            if (emitMVDB)
            {
                ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
                ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
                //  Write horizontal motion vector
                index = (pCurMB->BlkY1.BHMV + 32)*2;
                PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                         pPB_BitStream, pPB_BitOffset);
                //  Write vertical motion vector
                index = (pCurMB->BlkY1.BVMV + 32)*2;
                PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                         pPB_BitStream, pPB_BitOffset);
            }
            //  Copy P-mblock blk data
            CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                     pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff // src
                                        + FutrPMBData[curMB].BlkDataBitOff,
                     FutrPMBData[curMB+1].MBStartBitOff                  // len
                     - FutrPMBData[curMB].MBStartBitOff
                     - FutrPMBData[curMB].BlkDataBitOff);
            //  B-frame block data is always INTER-coded (last param is 0)
            if (emitCBPB)
            {
                rvs = MBRunValSign;
#ifdef H263P
                MBEncodeVLC(&rvs, NULL, (pCurMB->CodedBlocksB & 0x3f), 
                            pPB_BitStream, pPB_BitOffset, 0, 0);
#else
                MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocksB, 
                            pPB_BitStream, pPB_BitOffset, 0, 0);
#endif
            }
        }	// end of else

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pPB_BitStream,
                                                    (U32) *pPB_BitOffset);
	} // for MB

} // end of PB_GOB_Q_RLE_VLC_WriteBS()


/*************************************************************
 *  Name: PB_GOB_VLC_WriteBS 
 *  Description:  Write out GOB layer bits for GOB number "GOB".
 *  Parameters:
 *    EC                 Encoder catalog
 *    pMBRVS_Luma        Quantized DCT coeffs. of B-block luma
 *    pMBRVS_Chroma      Quantized DCT coeffs. of B-block chroma
 *    pP_BitStreamStart  Pointer to start of bit stream for the future
 *                       P-frame.  Some data from future P frame is copied over
 *                       to PB-frame.
 *    pPB_BitStream      Current PB-frame byte pointer
 *    pPB_BitOffset      Bit offset in the current byte pointed by pPB_BitStream
 *    FutrPMBData        Bit stream info on future P-frame.  This info. is 
 *                       initialized in GOB_Q_RLE_VLC_WriteBS()
 *    GOB                GOBs are numbered from 0 in a frame.
 *    QP                 Quantization value for B-block coefficients.
 *  Side-effects:
 *    pPB_BitStream and pPB_BitOffset are modified as a result of writing bits 
 *    to the stream.
 *  Notes:
 *    The improved PB-frame mode of H.263+ is currently only available in
 *    MMX enabled versions of the encoder. This routine is the MMX equivalent
 *    of PB_GOB_Q_RLE_VLC_WriteBS(), which does not contain the H.263+
 *    modifications.
 *************************************************************/
void PB_GOB_VLC_WriteBS(
	T_H263EncoderCatalog       * EC,
	I8                         * pMBRVS_Luma,
	I8                         * pMBRVS_Chroma,
	U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
	const T_FutrPMBData  * const FutrPMBData,
    const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
)
{
    UN  MB;
    U32 curMB, index;
    U32 GOBHeaderMask, GOBHeaderFlag;
    U8  bUseDQUANT = 0;   // Indicates if DQUANT is present.
    U8  emitCBPB, emitMVDB;
	register T_MBlockActionStream *pCurMB;

	FX_ENTRY("PB_GOB_VLC_WriteBS")

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

    for (MB = 0, curMB = GOB*EC->NumMBPerRow,
            pCurMB = EC->pU8_MBlockActionStream + curMB;
         MB < EC->NumMBPerRow;
         MB++, curMB++, pCurMB++)
	{
		/*
		* Quantize and RLE each block in the macroblock,
		* skipping empty blocks as denoted by CodedBlocks.
		* If any more blocks are empty after quantization
		* then the appropriate CodedBlocks bit is cleared.
		*/
		//  Write MBlock data
		// Check if entire macroblock is empty, including zero MV's.
		if(((pCurMB->MBType == INTER)
		 || (pCurMB->MBType == INTER4V))
	 	 && (pCurMB->COD == 1) ) 
		{
#ifdef H263P
			// If forward prediction selected for B block, macroblock is not empty
            if( ((pCurMB->CodedBlocksB & 0x3f) == 0)
                 && (pCurMB->BlkY1.BHMV == 0)
                && (pCurMB->BlkY1.BVMV == 0)
				&& ((pCurMB->CodedBlocksB & 0x80) == 0))	// forward pred. not selected
#else
            if( ((pCurMB->CodedBlocksB & 0x3f) == 0)
                 && (pCurMB->BlkY1.BHMV == 0)
                && (pCurMB->BlkY1.BVMV == 0))
#endif
			{
				//  P-mblock not coded, and neither is PB-mblock.
				//  COD = 1, empty MB.
				//  If it is the first MB in the GOb, then GOB header 
				//  is also copied
				CopyBits(pPB_BitStream, pPB_BitOffset,                         // dest
				         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,  // src
				         FutrPMBData[curMB+1].MBStartBitOff                    // len
				         - FutrPMBData[curMB].MBStartBitOff);
			} 
			else 
			{ // Macro block is not empty.
				//  Copy COD and MCBPC
				//  If it is the first MB in the GOB, then GOB header 
				//  is also copied.
				if(FutrPMBData[curMB+1].MBStartBitOff - FutrPMBData[curMB].MBStartBitOff != 1) 
				{
					CopyBits(pPB_BitStream, pPB_BitOffset,                      // dest
					         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,     // src
					         FutrPMBData[curMB+1].MBStartBitOff                       // len
					         - FutrPMBData[curMB].MBStartBitOff - 1);
				}
				PutBits(0, 1, pPB_BitStream, pPB_BitOffset);	// COD = 0, nonempty MB
				/*******************************************
				* Write macroblock header to bit stream.
				*******************************************/	  
				// Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
				index = (pCurMB->CodedBlocks >> 4) & 0x3;
				// Add the MB type to next two bits to the left.
				index |= (pCurMB->MBType << 2);
				// Write code to bitstream.
				PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], pPB_BitStream, pPB_BitOffset);
				//  Write MODB
				if((pCurMB->CodedBlocksB & 0x3f) == 0) 
				{
					emitCBPB = 0;
				} 
				else 
				{
					emitCBPB = 1;
				}

#ifdef H263P
				if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON)
				{
					// include MVDB only if forward prediction selected
					// for bidirectional prediction, MVd = [0, 0]
					if (pCurMB->CodedBlocksB & 0x80)
					{
						emitMVDB = 1;
					}
					else
					{
						emitMVDB = 0;
					}
				}
				else
#endif // H263P
				{
					if(((pCurMB->BlkY1.BHMV != 0) || (pCurMB->BlkY1.BVMV != 0)) || emitCBPB == 1) 
					{
						emitMVDB = 1;
					} 
					else {
						emitMVDB = 0;
					}
				}

#ifdef H263P
				if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON) 
				{
					if (!emitCBPB) {
						if (!emitMVDB)
							// Bidirectional prediction with all empty blocks
							index = 0;
						else
							// Forward prediction with all empty blocks
							index = 1;
					} else {
						if (emitMVDB)
							// Forward prediction with non-empty blocks
							index = 2;
						else
							// Bidirectional prediction with non-empty blocks
							index = 3;
					}

					PutBits(VLC_IMPROVED_PB_MODB[index][1], VLC_IMPROVED_PB_MODB[index][0], 
							pPB_BitStream, pPB_BitOffset);
					DbgLog((LOG_TRACE,6,TEXT("MB=%d emitCBPB=%d emitMVDB=%d MODB=%d"),
							 curMB, (int)emitCBPB, (int)emitMVDB, 
							 (int)VLC_IMPROVED_PB_MODB[index][1]));
				}
				else // not using improved PB-frame mode
#endif // H263P
				{
					index = (emitMVDB<<1) | emitCBPB;
					PutBits(VLC_MODB[index][1], VLC_MODB[index][0], pPB_BitStream, pPB_BitOffset);

					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));
				}

				//  Write CBPB
				if(emitCBPB) {
					PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 6, pPB_BitStream, pPB_BitOffset);

					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
				}
				PutBits(3, 2, pPB_BitStream, pPB_BitOffset);	// CBPY = 11, no coded P blocks
				//if( bUseDQUANT ) 
				//{
					// write DQUANT to bit stream here.
				//}
				//  Write MVD{2-4}
				//    Note:  MVD cannot be copied from future frame because 
				//           predictors are different for PB-frame (G.2)
				if((EC->GOBHeaderPresent & GOBHeaderMask) != 0) 
				{
					GOBHeaderFlag = TRUE;
				} 
				else 
				{
					GOBHeaderFlag = FALSE;
				}
				writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
				pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);
				//  Write MVDB
				if (emitMVDB) 
				{
					ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
					ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
					//  Write horizontal motion vector
					index = (pCurMB->BlkY1.BHMV + 32)*2;
					PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
					//  Write vertical motion vector
					index = (pCurMB->BlkY1.BVMV + 32)*2;
					PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
				}
				//  There is no P-mblock blk data
				//  B-frame block data is always INTER-coded (last param is 0)
				if (emitCBPB) 
				{
#ifdef H263P
					MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, (pCurMB->CodedBlocksB & 0x3f), 
					pPB_BitStream, pPB_BitOffset, 0, 1);
#else
					MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocksB, 
					pPB_BitStream, pPB_BitOffset, 0, 1);
#endif
				}
			}	// end of else
		} 
		else 
		{
			//  Copy COD and MCBPC
			//  If it is the first MB in the GOB, then GOB header 
			//  is also copied.
			CopyBits(pPB_BitStream, pPB_BitOffset,                      // dest
			         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,     // src
			         FutrPMBData[curMB].CBPYBitOff);                          // len
			//  Write MODB
			if((pCurMB->CodedBlocksB & 0x3f) == 0) 
			{
				emitCBPB = 0;
			} 
			else 
			{
				emitCBPB = 1;
			}

#ifdef H263P
			if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON)
			{
				// include MVDB only if forward prediction selected
				// for bidirectional prediction, MVd = [0, 0]
				if (pCurMB->CodedBlocksB & 0x80)
				{
					emitMVDB = 1;
				}
				else
				{
					emitMVDB = 0;
				}
			}
			else
#endif // H263P
			{
				if(((pCurMB->BlkY1.BHMV != 0) || (pCurMB->BlkY1.BVMV != 0)) || emitCBPB == 1) 
				{
					emitMVDB = 1;
				} 
				else {
					emitMVDB = 0;
				}
			}


#ifdef H263P
			if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON) 
			{
				if (!emitCBPB) {
					if (!emitMVDB)
						// Bidirectional prediction with all empty blocks
						index = 0;
					else
						// Forward prediction with all empty blocks
						index = 1;
				} else {
					if (emitMVDB)
						// Forward prediction with non-empty blocks
						index = 2;
					else
						// Bidirectional prediction with non-empty blocks
						index = 3;
				}

				PutBits(VLC_IMPROVED_PB_MODB[index][1], VLC_IMPROVED_PB_MODB[index][0], 
						pPB_BitStream, pPB_BitOffset);

				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_IMPROVED_PB_MODB[index][1]));
			}
			else // not using improved PB-frame mode
#endif // H263P
			{
				index = (emitMVDB<<1) | emitCBPB;
				PutBits(VLC_MODB[index][1], VLC_MODB[index][0], pPB_BitStream, pPB_BitOffset);
			
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));
			}
			
			//  Write CBPB
			if (emitCBPB) {
				PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 6, pPB_BitStream, pPB_BitOffset);
			
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
			}
			//  Copy CBPY, {DQUANT}
			CopyBits(pPB_BitStream, pPB_BitOffset,                               // dest
			         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff               // src
			         + FutrPMBData[curMB].CBPYBitOff, FutrPMBData[curMB].MVDBitOff     // len
			         - FutrPMBData[curMB].CBPYBitOff);

			//  Write MVD{2-4}
			//    Note:  MVD cannot be copied from future frame because 
			//           predictors are different for PB-frame (G.2)
			if((EC->GOBHeaderPresent & GOBHeaderMask) != 0) 
			{
				GOBHeaderFlag = TRUE;
			} 
			else 
			{
				GOBHeaderFlag = FALSE;
			}
			writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
			pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);

			//  Write MVDB
			if (emitMVDB) 
			{
				ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
				ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
				//  Write horizontal motion vector
				index = (pCurMB->BlkY1.BHMV + 32)*2;
				PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
				//  Write vertical motion vector
				index = (pCurMB->BlkY1.BVMV + 32)*2;
				PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
			}
			//  Copy P-mblock blk data
			CopyBits(pPB_BitStream, pPB_BitOffset,                               // dest
			         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff               // src
			         + FutrPMBData[curMB].BlkDataBitOff, 
			         FutrPMBData[curMB+1].MBStartBitOff                                // len
			         - FutrPMBData[curMB].MBStartBitOff
			         - FutrPMBData[curMB].BlkDataBitOff);
			//  B-frame block data is always INTER-coded (last param is 0)
			if(emitCBPB) 
			{
#ifdef H263P
				MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, 
					        (pCurMB->CodedBlocksB & 0x3f), 
							pPB_BitStream, pPB_BitOffset, 0, 1);
#else
				MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, 
					        pCurMB->CodedBlocksB, 
							pPB_BitStream, pPB_BitOffset, 0, 1);
#endif
			}
		}	// end of else

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pPB_BitStream,
                                                    (U32) *pPB_BitOffset);
	} // for MB

} // end of PB_GOB_VLC_WriteBS()

/***************************************************************
 *  MB_Quantize_RLE
 *    Takes the list of coefficient pairs from the DCT routine
 *    and returns a list of Run/Level/Sign triples (each 1 byte)
 *    The end of the run/level/sign triples for a block
 *    is signalled by an illegal combination (TBD).
 ****************************************************************/
static I8 * MB_Quantize_RLE(
    I32 **DCTCoefs,
    I8   *MBRunValPairs,
	U8   *CodedBlocks,
	U8    BlockType,
	I32   QP
)
{
    int   b;
    U8    bitmask = 1;
    I8  * EndAddress;

    #ifdef DEBUG_DCT
    int  DCTarray[64];
    #endif

	FX_ENTRY("MB_Quantize_RLE")

    /*
     * Loop through all 6 blocks of macroblock.
     */
    for(b = 0; b < 6; b++, bitmask <<= 1)
    {
        
		DEBUGMSG(ZONE_ENCODE_MB, ("%s: Block #%d\r\n", _fx_, b));

        // Skip this block if not coded.
        if( (*CodedBlocks & bitmask) == 0)
            continue;
        
        #ifdef DEBUG_DCT
	    cnvt_fdct_output((unsigned short *) *DCTCoefs, DCTarray, (int) BlockType);
	    #endif
	
        /*
         * Quantize and run-length encode a block.
         */  
       EndAddress = QUANTRLE(*DCTCoefs, MBRunValPairs, QP, (int)BlockType);
       #ifdef DEBUG
	    char *p;
	    for(p = (char *)MBRunValPairs; p < (char *)EndAddress; p+=3)
        {
			DEBUGMSG(ZONE_ENCODE_MB, ("%s: (%u, %u, %d)\r\n", _fx_, (unsigned char)*p, (unsigned char)*(p+1), (int)*(p+2)));
        }
	    #endif

        // Clear coded block bit for this block.
        if ( EndAddress == MBRunValPairs)
        {
            ASSERT(BlockType != INTRABLOCK)	// should have at least INTRADC in an INTRA blck
            *CodedBlocks &= ~bitmask;
        }
        else if ( (EndAddress == (MBRunValPairs+3)) && (BlockType == INTRABLOCK) )
        {
            *CodedBlocks &= ~bitmask;
            MBRunValPairs = EndAddress;
        }
        else
        {
            MBRunValPairs = EndAddress;
            *MBRunValPairs = -1;   // Assign an illegal run to signal end of block.
            MBRunValPairs += 3;	   // Increment to the next triple.
        }
        
        *DCTCoefs += 32;		// Increment DCT Coefficient pointer to next block.
    }

    return MBRunValPairs;
}


/*******************************************************************
 * Variable length code teh run/level/sign triples and write the 
 * codes to the bitstream.
 *******************************************************************/
/*
U8 *  MB_VLC_WriteBS()
{
  for(b = 0; b < 6; b++)
  {
      Block_VLC_WriteBS()
  }
}
*/

void InitVLC(void)
{
  int i, size, code;
  int run, level;

  /*
   * initialize INTRADC fixed length code table.
   */
  for(i = 1; i < 254; i++)
  {
    FLC_INTRADC[i] = i;
  }
  FLC_INTRADC[0] = 1;
  FLC_INTRADC[128] = 255;
  FLC_INTRADC[254] = 254;
  FLC_INTRADC[255] = 254;

 /*
  * Initialize tcoef tables.
  */

  for(i=0; i < 64*12; i++)
  {
    VLC_TCOEF_TBL[i] = 0x0000FFFF;
  }
  
  for(run=0; run < 64; run++)
  {
    for(level=1; level <= TCOEF_RUN_MAXLEVEL[run].maxlevel; level++)
	{
	  size = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1)*2);
	  size <<= 16;
	  code = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1)*2 +1);
      VLC_TCOEF_TBL[ (run) + (level-1)*64 ] = code;
      VLC_TCOEF_TBL[ (run) + (level-1)*64 ] |= size;
	} // end of for level
  } // end of for run


 /*
  * Initialize last tcoef tables.
  */
  
  for(i=0; i < 64*3; i++)
  {
    VLC_TCOEF_LAST_TBL[i] = 0x0000FFFF;
  }    

  run = 0;
  for(level=1; level <= 3; level++)
  {
    size = *(VLC_TCOEF + 58*2 + (level - 1)*2);
    size <<= 16;
    code = *(VLC_TCOEF + 58*2 + (level - 1)*2 +1);
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] = code;
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] |= size;
  } // end of for level

  run = 1;
  for(level=1; level <= 2; level++)
  {
    size = *(VLC_TCOEF + 61*2 + (level - 1)*2);
    size <<= 16;
    code = *(VLC_TCOEF + 61*2 + (level - 1)*2 +1);
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] = code;
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] |= size;
  } // end of for level

  level=1;
  for(run=2; run <= 40; run++)
  {
    size = *(VLC_TCOEF + 63*2+ (run - 2)*2);
    size <<= 16;
    code = *(VLC_TCOEF + 63*2 + (run - 2)*2 +1);
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] = code;
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] |= size;
  } // end of for run

} // InitVLC.



/******************************************************************
 *  Name: median
 *  
 *  Description: Take the median of three signed chars.  Implementation taken 
 *               from the decoder.
 *******************************************************************/
static char __fastcall median(char v1, char v2, char v3)
{
    char temp;
    
    if (v2 < v1) 
    {
        temp = v2; v2 = v1; v1 = temp;
    } 
    //  Invariant : v1 < v2
    if (v2 > v3) 
    { 
        v2 = (v1 < v3) ? v3 : v1;
    }
    return v2;
}

/*************************************************************
 *  Name:       writeP_MVD
 *  Algorithm:  See section 6.1.1
 *     This routine assumes that there are always four motion 
 *  vectors per macroblock defined. If there is actually one
 *  motion vector in the macroblock, then the four MV fields
 *  should be equivalent. In this way the MV predictor for 
 *  block 1 of the 4 MV case is calculated the same way as the
 *  MV predictor for the macroblock in the 1 MV case.
 ************************************************************/
static void writeP_MVD(
    const U32                     curMB, 
    T_MBlockActionStream  * const pCurMB,
    const U32                     NumMBPerRow,
	const U32					  NumMBs,
    U8                         ** pP_BitStream,
    U8                          * pP_BitOffset,
	U32							  GOBHeaderPresent,
	T_H263EncoderCatalog         *EC
)
{
    I8  HMV, VMV, BHMV, BVMV, CHMV, CVMV, DHMV, DVMV;
    I8  HMV1, HMV2, HMV3, VMV1, VMV2, VMV3;

	FX_ENTRY("writeP_MVD")

    //FirstMEState = pCurMB->FirstMEState;

	/*
	 * Top left corner of picture of GOB.
	 */
    if( (curMB == 0) || 
              ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) == 0)  ) )
    {
        HMV = 0;
        VMV = 0;

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = VMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Upper edge (not corner) or upper right corner of picture
	 * or GOB.
	 */
    else if( (curMB < NumMBPerRow) ||
             ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) > 0)  ) )
    {
        register T_MBlockActionStream *pMB1;

        pMB1 = pCurMB - 1; 
        HMV = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        VMV = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }	
	/*
	 * Central portion of the picture, not next to any edge.
	 */
    else if ( 	((curMB % NumMBPerRow) != 0) &&		// not left edge
				(curMB >= NumMBPerRow) &&			// not top row
				((curMB % NumMBPerRow) != (NumMBPerRow-1)) &&	// not right edge
				(curMB < (NumMBs - NumMBPerRow))    )	// not bottom row
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;

        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;

        HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        HMV = median(HMV1, HMV2, HMV3);
        
        VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        VMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        
        VMV = median(VMV1, VMV2, VMV3);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V


    }
	/*
	 * Left edge or lower left corner.
	 */
    else if( (curMB % NumMBPerRow) == 0 )
    {
        register T_MBlockActionStream *pMB2, *pMB3;

        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;

        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        HMV = median(0, HMV2, HMV3);
        
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        VMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        VMV = median(0, VMV2, VMV3);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = 0;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Right edge or lower right corner.
	 */
    else if( (curMB % NumMBPerRow) == (NumMBPerRow-1) )
    {
        register T_MBlockActionStream *pMB1, *pMB2;

        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 

        HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV = median(HMV1, HMV2, 0);
        
        VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        
        VMV = median(VMV1, VMV2, 0);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   0;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   0;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
    else
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;

        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;

        HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        HMV = median(HMV1, HMV2, HMV3);
        
        VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        VMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        
        VMV = median(VMV1, VMV2, VMV3);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }

    /******************************************************************
     *  Compute motion vector delta and write VLC out to the bitstream
     ******************************************************************/
    register I32 hdelta, vdelta;
    register U32 index;

    hdelta = pCurMB->BlkY1.PHMV - HMV;
    vdelta = pCurMB->BlkY1.PVMV - VMV;
    
#ifdef DEBUG
	if (EC->PictureHeader.UMV == OFF) {
		ASSERT((pCurMB->BlkY2.PHMV >= -32 && pCurMB->BlkY2.PHMV <= 31));
		ASSERT((pCurMB->BlkY2.PVMV >= -32 && pCurMB->BlkY2.PVMV <= 31));
	} else {
		if (HMV <= -32) {
			ASSERT((pCurMB->BlkY2.PHMV >= -63 && pCurMB->BlkY2.PHMV <= 0));
		} else if (HMV <= 32) {
			ASSERT((hdelta >= -32 && hdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY2.PHMV >= 0 && pCurMB->BlkY2.PHMV <= 63));
		}
		if (VMV <= -32) {
			ASSERT((pCurMB->BlkY2.PVMV >= -63 && pCurMB->BlkY2.PVMV <= 0));
		} else if (VMV <= 32) {
			ASSERT((vdelta >= -32 && vdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY2.PVMV >= 0 && pCurMB->BlkY2.PVMV <= 63));
		}
	}
#endif

	if (EC->PictureHeader.UMV == ON)
	{
		if (HMV < -31 && hdelta < -63) 
			hdelta += 64;
		else if (HMV > 32 && hdelta > 63) 
			hdelta -= 64;

		if (VMV < -31 && vdelta < -63) 
			vdelta += 64;
		else if (VMV > 32 && vdelta > 63) 
			vdelta -= 64;
	}
	// Adjust the deltas to be in the range of -32...+31
	if(hdelta > 31)
		hdelta -= 64;
	if(hdelta < -32)
		hdelta += 64;

	if(vdelta > 31)
		vdelta -= 64;
	if(vdelta < -32)
		vdelta += 64;
    
	DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 1) MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY1.PHMV, pCurMB->BlkY1.PVMV));
    
    // Write horizontal motion vector delta here.
    index = (hdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

	#ifdef COUNT_BITS
	EC->Bits.MBHeader += *(vlc_mvd+index);
	EC->Bits.MV += *(vlc_mvd+index);
	#endif
	    
    // Write horizontal motion vector delta here.
    index = (vdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

	#ifdef COUNT_BITS
	EC->Bits.MBHeader += *(vlc_mvd+index);
	EC->Bits.MV += *(vlc_mvd+index);
	#endif

	/*
	 * Deal with 4 MV case.
	 */
	if(pCurMB->MBType == INTER4V)
	{

		/*--------------
		 * Block 2.
		 *--------------*/
    	hdelta = pCurMB->BlkY2.PHMV - BHMV;
    	vdelta = pCurMB->BlkY2.PVMV - BVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY2.PHMV >= -32 && pCurMB->BlkY2.PHMV <= 31));
			ASSERT((pCurMB->BlkY2.PVMV >= -32 && pCurMB->BlkY2.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY2.PHMV >= -63 && pCurMB->BlkY2.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PHMV >= 0 && pCurMB->BlkY2.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY2.PVMV >= -63 && pCurMB->BlkY2.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PVMV >= 0 && pCurMB->BlkY2.PVMV <= 63));
			}
		}
#endif

		if (EC->PictureHeader.UMV == ON)
		{
			if (BHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (BHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (BVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (BVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}
		// Adjust the deltas to be in the range of -32...+31
		if(hdelta > 31)
			hdelta -= 64;
		if(hdelta < -32)
			hdelta += 64;

		if(vdelta > 31)
			vdelta -= 64;
		if(vdelta < -32)
			vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 2)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY2.PHMV, pCurMB->BlkY2.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif


		/*----------------
		 * Block 3
		 *---------------*/
    	hdelta = pCurMB->BlkY3.PHMV - CHMV;
    	vdelta = pCurMB->BlkY3.PVMV - CVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY3.PHMV >= -32 && pCurMB->BlkY3.PHMV <= 31));
			ASSERT((pCurMB->BlkY3.PVMV >= -32 && pCurMB->BlkY3.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY3.PHMV >= -63 && pCurMB->BlkY3.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PHMV >= 0 && pCurMB->BlkY3.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY3.PVMV >= -63 && pCurMB->BlkY3.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PVMV >= 0 && pCurMB->BlkY3.PVMV <= 63));
			}
		}
#endif

		if (EC->PictureHeader.UMV == ON)
		{
			if (CHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (CHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (CVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (CVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}
		// Adjust the deltas to be in the range of -32...+31
		if(hdelta > 31)
			hdelta -= 64;
		if(hdelta < -32)
			hdelta += 64;

		if(vdelta > 31)
			vdelta -= 64;
		if(vdelta < -32)
			vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 3)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY3.PHMV, pCurMB->BlkY3.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif


		/*-----------------
		 * Block 4
		 *-------------------*/
    	hdelta = pCurMB->BlkY4.PHMV - DHMV;
    	vdelta = pCurMB->BlkY4.PVMV - DVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY4.PHMV >= -32 && pCurMB->BlkY4.PHMV <= 31));
			ASSERT((pCurMB->BlkY4.PVMV >= -32 && pCurMB->BlkY4.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY4.PHMV >= -63 && pCurMB->BlkY4.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PHMV >= 0 && pCurMB->BlkY4.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY4.PVMV >= -63 && pCurMB->BlkY4.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PVMV >= 0 && pCurMB->BlkY4.PVMV <= 63));
			}
		}
#endif

		if (EC->PictureHeader.UMV == ON)
		{
			if (DHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (DHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (DVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (DVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}
		// Adjust the deltas to be in the range of -32...+31
		if(hdelta > 31)
			hdelta -= 64;
		if(hdelta < -32)
			hdelta += 64;

		if(vdelta > 31)
			vdelta -= 64;
		if(vdelta < -32)
			vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 4)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY4.PHMV, pCurMB->BlkY4.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif

	} // end of if INTER4V

}

/*************************************************************
 *  Name:       writePB_MVD
 *  Algorithm:  See section 6.1.1 and annex G
 *     This routine assumes that there are always four motion 
 *  vectors per macroblock defined. If there is actually one
 *  motion vector in the macroblock, then the four MV fields
 *  should be equivalent. In this way the MV predictor for 
 *  block 1 of the 4 MV case is calculated the same way as the
 *  MV predictor for the macroblock in the 1 MV case.
 ************************************************************/
static void writePB_MVD(
    const U32              curMB, 
    T_MBlockActionStream * const pCurMB,
    const U32              NumMBPerRow,
	const U32			   NumMBs,
    U8                  ** pPB_BitStream,
    U8                   * pPB_BitOffset,
	U32					   GOBHeaderPresent,
	const T_H263EncoderCatalog  *EC
)
{
    U8  FirstMEState;
    I8  HMV, VMV, BHMV, BVMV, CHMV, CVMV, DHMV, DVMV;
    I8  HMV1, HMV2, HMV3, VMV1, VMV2, VMV3;
    
	FX_ENTRY("writePB_MVD")

    FirstMEState = pCurMB->FirstMEState;

	/*
	 * Top left corner of picture of GOB.
	 */
    if( (curMB == 0) || 
              ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) == 0)  ) )
    {
        HMV = 0;
        VMV = 0;

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = VMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Upper edge (not corner) or upper right corner of picture
	 * or GOB.
	 */
    else if( (curMB < NumMBPerRow) ||
             ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) > 0)  ) )
    {
        register T_MBlockActionStream *pMB1;
        
        pMB1 = pCurMB - 1; 
        HMV = pMB1->BlkY2.PHMV;
        VMV = pMB1->BlkY2.PVMV;


		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }	
	/*
	 * Central portion of the picture, not next to any edge.
	 */
    else if ( 	((curMB % NumMBPerRow) != 0) &&		// not left edge
				(curMB >= NumMBPerRow) &&			// not top row
				((curMB % NumMBPerRow) != (NumMBPerRow-1)) &&	// not right edge
				(curMB < (NumMBs - NumMBPerRow))    )	// not bottom row
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;
        
        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;
        HMV = median(pMB1->BlkY2.PHMV, pMB2->BlkY3.PHMV, pMB3->BlkY3.PHMV);
        VMV = median(pMB1->BlkY2.PVMV, pMB2->BlkY3.PVMV, pMB3->BlkY3.PVMV);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   pMB3->BlkY3.PHMV;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   pMB3->BlkY3.PVMV;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Left edge or lower left corner.
	 */
    else if( (curMB % NumMBPerRow) == 0 )
    {
        register T_MBlockActionStream *pMB2, *pMB3;
        
        pMB2 = pCurMB - NumMBPerRow;
        pMB3 = pMB2 + 1;
        HMV = median(0, pMB2->BlkY3.PHMV, pMB3->BlkY3.PHMV);
        VMV = median(0, pMB2->BlkY3.PVMV, pMB3->BlkY3.PVMV);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   pMB3->BlkY3.PHMV;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   pMB3->BlkY3.PVMV;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = 0;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Right edge or lower right corner.
	 */
    else if( (curMB % NumMBPerRow) == (NumMBPerRow-1) )
    {
        register T_MBlockActionStream *pMB1, *pMB2;
        
        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        HMV = median(pMB1->BlkY2.PHMV, pMB2->BlkY3.PHMV, 0);
        VMV = median(pMB1->BlkY2.PVMV, pMB2->BlkY3.PVMV, 0);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   0;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   0;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
    else
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;
        
        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;
        HMV = median(pMB1->BlkY2.PHMV, pMB2->BlkY3.PHMV, pMB3->BlkY3.PHMV);
        VMV = median(pMB1->BlkY2.PVMV, pMB2->BlkY3.PVMV, pMB3->BlkY3.PVMV);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   pMB3->BlkY3.PHMV;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   pMB3->BlkY3.PVMV;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }

    /******************************************************************
     *  Compute motion vector delta and write VLC out to the bitstream
     ******************************************************************/
    register I32 hdelta, vdelta;
    register U32 index;

    hdelta = pCurMB->BlkY1.PHMV - HMV;
    vdelta = pCurMB->BlkY1.PVMV - VMV;
    
#ifdef DEBUG
	if (EC->PictureHeader.UMV == OFF) {
		ASSERT((pCurMB->BlkY1.PHMV >= -32 && pCurMB->BlkY1.PHMV <= 31));
		ASSERT((pCurMB->BlkY1.PVMV >= -32 && pCurMB->BlkY1.PVMV <= 31));
	} else {
		if (HMV <= -32) {
			ASSERT((pCurMB->BlkY1.PHMV >= -63 && pCurMB->BlkY1.PHMV <= 0));
		} else if (HMV <= 32) {
			ASSERT((hdelta >= -32 && hdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY1.PHMV >= 0 && pCurMB->BlkY1.PHMV <= 63));
		}
		if (VMV <= -32) {
			ASSERT((pCurMB->BlkY1.PVMV >= -63 && pCurMB->BlkY1.PVMV <= 0));
		} else if (VMV <= 32) {
			ASSERT((vdelta >= -32 && vdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY1.PVMV >= 0 && pCurMB->BlkY1.PVMV <= 63));
		}
	}
#endif

    // Adjust the deltas to be in the range of -32...+31
    
	if (EC->PictureHeader.UMV == ON)
	{
		if (HMV < -31 && hdelta < -63) 
			hdelta += 64;
		else if (HMV > 32 && hdelta > 63) 
			hdelta -= 64;

		if (VMV < -31 && vdelta < -63) 
			vdelta += 64;
		else if (VMV > 32 && vdelta > 63) 
			vdelta -= 64;
	}

	if(hdelta > 31)
        hdelta -= 64;
    if(hdelta < -32)
        hdelta += 64;
    
    if(vdelta > 31)
        vdelta -= 64;
    if(vdelta < -32)
        vdelta += 64;

	DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 1)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY1.PHMV, pCurMB->BlkY1.PVMV));
    
    // Write horizontal motion vector delta
    index = (hdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    // Write vertical motion vector delta
    index = (vdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);


	/*
	 * Deal with 4 MV case.
	 */
	if(pCurMB->MBType == INTER4V)
	{

		/*--------------
		 * Block 2.
		 *--------------*/
    	hdelta = pCurMB->BlkY2.PHMV - BHMV;
    	vdelta = pCurMB->BlkY2.PVMV - BVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY2.PHMV >= -32 && pCurMB->BlkY2.PHMV <= 31));
			ASSERT((pCurMB->BlkY2.PVMV >= -32 && pCurMB->BlkY2.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY2.PHMV >= -63 && pCurMB->BlkY2.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PHMV >= 0 && pCurMB->BlkY2.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY2.PVMV >= -63 && pCurMB->BlkY2.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PVMV >= 0 && pCurMB->BlkY2.PVMV <= 63));
			}
		}
#endif
		
    	// Adjust the deltas to be in the range of -32...+31
		if (EC->PictureHeader.UMV == ON)
		{
			if (BHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (BHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (BVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (BVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}


    	if(hdelta > 31)
        	hdelta -= 64;
    	if(hdelta < -32)
	        hdelta += 64;
    
    	if(vdelta > 31)
        	vdelta -= 64;
    	if(vdelta < -32)
        	vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 2)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY2.PHMV, pCurMB->BlkY2.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);


		/*----------------
		 * Block 3
		 *---------------*/
    	hdelta = pCurMB->BlkY3.PHMV - CHMV;
    	vdelta = pCurMB->BlkY3.PVMV - CVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY3.PHMV >= -32 && pCurMB->BlkY3.PHMV <= 31));
			ASSERT((pCurMB->BlkY3.PVMV >= -32 && pCurMB->BlkY3.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY3.PHMV >= -63 && pCurMB->BlkY3.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PHMV >= 0 && pCurMB->BlkY3.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY3.PVMV >= -63 && pCurMB->BlkY3.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PVMV >= 0 && pCurMB->BlkY3.PVMV <= 63));
			}
		}
#endif
		
    	// Adjust the deltas to be in the range of -32...+31

		if (EC->PictureHeader.UMV == ON)
		{
			if (CHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (CHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (CVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (CVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}

    	if(hdelta > 31)
        	hdelta -= 64;
    	if(hdelta < -32)
        	hdelta += 64;
    
    	if(vdelta > 31)
        	vdelta -= 64;
    	if(vdelta < -32)
        	vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 3)MB#=%d\nMV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY3.PHMV, pCurMB->BlkY3.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);


		/*-----------------
		 * Block 4
		 *-------------------*/
    	hdelta = pCurMB->BlkY4.PHMV - DHMV;
    	vdelta = pCurMB->BlkY4.PVMV - DVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY4.PHMV >= -32 && pCurMB->BlkY4.PHMV <= 31));
			ASSERT((pCurMB->BlkY4.PVMV >= -32 && pCurMB->BlkY4.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY4.PHMV >= -63 && pCurMB->BlkY4.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PHMV >= 0 && pCurMB->BlkY4.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY4.PVMV >= -63 && pCurMB->BlkY4.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PVMV >= 0 && pCurMB->BlkY4.PVMV <= 63));
			}
		}
#endif
		
    	// Adjust the deltas to be in the range of -32...+31
		if (EC->PictureHeader.UMV == ON)
		{
			if (DHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (DHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (DVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (DVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}

    	if(hdelta > 31)
        	hdelta -= 64;
    	if(hdelta < -32)
        	hdelta += 64;
    
    	if(vdelta > 31)
        	vdelta -= 64;
    	if(vdelta < -32)
        	vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 4)MB#=%d\nMV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY4.PHMV, pCurMB->BlkY4.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);

	} // end of if INTER4V


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\dxpal.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 14:05:16  $
;// $Archive:   S:\h26x\src\dec\dxpal.cpv  $
;// $Header:   S:\h26x\src\dec\dxpal.cpv   1.2   22 Dec 1995 14:05:16   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxpal.cpv  $
// 
//    Rev 1.2   22 Dec 1995 14:05:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   03 Nov 1995 11:49:48   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.0   31 Jul 1995 13:00:52   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:28   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:56   CZHU
// Initial revision.

#include "precomp.h"

#ifdef USE_WIN95_PAL // { USE_WIN95_PAL
unsigned char PalTable[236*4] = {
	   4,   4,   4, PC_NOCOLLAPSE,
	   8,   8,   8, PC_NOCOLLAPSE,
	  12,  12,  12, PC_NOCOLLAPSE,
	  17,  17,  17, PC_NOCOLLAPSE,
	  22,  22,  22, PC_NOCOLLAPSE,
	  28,  28,  28, PC_NOCOLLAPSE,
	  34,  34,  34, PC_NOCOLLAPSE,
	  41,  41,  41, PC_NOCOLLAPSE,
	  85,  85,  85, PC_NOCOLLAPSE,
	  77,  77,  77, PC_NOCOLLAPSE,
	  66,  66,  66, PC_NOCOLLAPSE,
	  57,  57,  57, PC_NOCOLLAPSE,
	 255, 124, 128, PC_NOCOLLAPSE,
	 255,  80,  80, PC_NOCOLLAPSE,
	 214,   0, 147, PC_NOCOLLAPSE,
	 204, 236, 255, PC_NOCOLLAPSE,
	 239, 214, 198, PC_NOCOLLAPSE,
	 231, 231, 214, PC_NOCOLLAPSE,
	 173, 169, 144, PC_NOCOLLAPSE,
	  51,   0,   0, PC_NOCOLLAPSE,
	 102,   0,   0, PC_NOCOLLAPSE,
	 153,   0,   0, PC_NOCOLLAPSE,
	 204,   0,   0, PC_NOCOLLAPSE,
	   0,  51,   0, PC_NOCOLLAPSE,
	  51,  51,   0, PC_NOCOLLAPSE,
	 102,  51,   0, PC_NOCOLLAPSE,
	 153,  51,   0, PC_NOCOLLAPSE,
	 204,  51,   0, PC_NOCOLLAPSE,
	 255,  51,   0, PC_NOCOLLAPSE,
	   0, 102,   0, PC_NOCOLLAPSE,
	  51, 102,   0, PC_NOCOLLAPSE,
	 102, 102,   0, PC_NOCOLLAPSE,
	 153, 102,   0, PC_NOCOLLAPSE,
	 204, 102,   0, PC_NOCOLLAPSE,
	 255, 102,   0, PC_NOCOLLAPSE,
	   0, 153,   0, PC_NOCOLLAPSE,
	  51, 153,   0, PC_NOCOLLAPSE,
	 102, 153,   0, PC_NOCOLLAPSE,
	 153, 153,   0, PC_NOCOLLAPSE,
	 204, 153,   0, PC_NOCOLLAPSE,
	 255, 153,   0, PC_NOCOLLAPSE,
	   0, 204,   0, PC_NOCOLLAPSE,
	  51, 204,   0, PC_NOCOLLAPSE,
	 102, 204,   0, PC_NOCOLLAPSE,
	 153, 204,   0, PC_NOCOLLAPSE,
	 204, 204,   0, PC_NOCOLLAPSE,
	 255, 204,   0, PC_NOCOLLAPSE,
	 102, 255,   0, PC_NOCOLLAPSE,
	 153, 255,   0, PC_NOCOLLAPSE,
	 204, 255,   0, PC_NOCOLLAPSE,
	   0,   0,  51, PC_NOCOLLAPSE,
	  51,   0,  51, PC_NOCOLLAPSE,
	 102,   0,  51, PC_NOCOLLAPSE,
	 153,   0,  51, PC_NOCOLLAPSE,
	 204,   0,  51, PC_NOCOLLAPSE,
	 255,   0,  51, PC_NOCOLLAPSE,
	   0,  51,  51, PC_NOCOLLAPSE,
	  51,  51,  51, PC_NOCOLLAPSE,
	 102,  51,  51, PC_NOCOLLAPSE,
	 153,  51,  51, PC_NOCOLLAPSE,
	 204,  51,  51, PC_NOCOLLAPSE,
	 255,  51,  51, PC_NOCOLLAPSE,
	   0, 102,  51, PC_NOCOLLAPSE,
	  51, 102,  51, PC_NOCOLLAPSE,
	 102, 102,  51, PC_NOCOLLAPSE,
	 153, 102,  51, PC_NOCOLLAPSE,
	 204, 102,  51, PC_NOCOLLAPSE,
	 255, 102,  51, PC_NOCOLLAPSE,
	   0, 153,  51, PC_NOCOLLAPSE,
	  51, 153,  51, PC_NOCOLLAPSE,
	 102, 153,  51, PC_NOCOLLAPSE,
	 153, 153,  51, PC_NOCOLLAPSE,
	 204, 153,  51, PC_NOCOLLAPSE,
	 255, 153,  51, PC_NOCOLLAPSE,
	   0, 204,  51, PC_NOCOLLAPSE,
	  51, 204,  51, PC_NOCOLLAPSE,
	 102, 204,  51, PC_NOCOLLAPSE,
	 153, 204,  51, PC_NOCOLLAPSE,
	 204, 204,  51, PC_NOCOLLAPSE,
	 255, 204,  51, PC_NOCOLLAPSE,
	  51, 255,  51, PC_NOCOLLAPSE,
	 102, 255,  51, PC_NOCOLLAPSE,
	 153, 255,  51, PC_NOCOLLAPSE,
	 204, 255,  51, PC_NOCOLLAPSE,
	 255, 255,  51, PC_NOCOLLAPSE,
	   0,   0, 102, PC_NOCOLLAPSE,
	  51,   0, 102, PC_NOCOLLAPSE,
	 102,   0, 102, PC_NOCOLLAPSE,
	 153,   0, 102, PC_NOCOLLAPSE,
	 204,   0, 102, PC_NOCOLLAPSE,
	 255,   0, 102, PC_NOCOLLAPSE,
	   0,  51, 102, PC_NOCOLLAPSE,
	  51,  51, 102, PC_NOCOLLAPSE,
	 102,  51, 102, PC_NOCOLLAPSE,
	 153,  51, 102, PC_NOCOLLAPSE,
	 204,  51, 102, PC_NOCOLLAPSE,
	 255,  51, 102, PC_NOCOLLAPSE,
	   0, 102, 102, PC_NOCOLLAPSE,
	  51, 102, 102, PC_NOCOLLAPSE,
	 102, 102, 102, PC_NOCOLLAPSE,
	 153, 102, 102, PC_NOCOLLAPSE,
	 204, 102, 102, PC_NOCOLLAPSE,
	   0, 153, 102, PC_NOCOLLAPSE,
	  51, 153, 102, PC_NOCOLLAPSE,
	 102, 153, 102, PC_NOCOLLAPSE,
	 153, 153, 102, PC_NOCOLLAPSE,
	 204, 153, 102, PC_NOCOLLAPSE,
	 255, 153, 102, PC_NOCOLLAPSE,
	   0, 204, 102, PC_NOCOLLAPSE,
	  51, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 102, PC_NOCOLLAPSE,
	 204, 204, 102, PC_NOCOLLAPSE,
	 255, 204, 102, PC_NOCOLLAPSE,
	   0, 255, 102, PC_NOCOLLAPSE,
	  51, 255, 102, PC_NOCOLLAPSE,
	 153, 255, 102, PC_NOCOLLAPSE,
	 204, 255, 102, PC_NOCOLLAPSE,
	 255,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 255, PC_NOCOLLAPSE,
	   0, 153, 153, PC_NOCOLLAPSE,
	 153,  51, 153, PC_NOCOLLAPSE,
	 153,   0, 153, PC_NOCOLLAPSE,
	 204,   0, 153, PC_NOCOLLAPSE,
	   0,   0, 153, PC_NOCOLLAPSE,
	  51,  51, 153, PC_NOCOLLAPSE,
	 102,   0, 153, PC_NOCOLLAPSE,
	 204,  51, 153, PC_NOCOLLAPSE,
	 255,   0, 153, PC_NOCOLLAPSE,
	   0, 102, 153, PC_NOCOLLAPSE,
	  51, 102, 153, PC_NOCOLLAPSE,
	 102,  51, 153, PC_NOCOLLAPSE,
	 153, 102, 153, PC_NOCOLLAPSE,
	 204, 102, 153, PC_NOCOLLAPSE,
	 255,  51, 153, PC_NOCOLLAPSE,
	  51, 153, 153, PC_NOCOLLAPSE,
	 102, 153, 153, PC_NOCOLLAPSE,
	 153, 153, 153, PC_NOCOLLAPSE,
	 204, 153, 153, PC_NOCOLLAPSE,
	 255, 153, 153, PC_NOCOLLAPSE,
	   0, 204, 153, PC_NOCOLLAPSE,
	  51, 204, 153, PC_NOCOLLAPSE,
	 102, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 153, PC_NOCOLLAPSE,
	 204, 204, 153, PC_NOCOLLAPSE,
	 255, 204, 153, PC_NOCOLLAPSE,
	   0, 255, 153, PC_NOCOLLAPSE,
	  51, 255, 153, PC_NOCOLLAPSE,
	 102, 204, 153, PC_NOCOLLAPSE,
	 153, 255, 153, PC_NOCOLLAPSE,
	 204, 255, 153, PC_NOCOLLAPSE,
	 255, 255, 153, PC_NOCOLLAPSE,
	   0,   0, 204, PC_NOCOLLAPSE,
	  51,   0, 153, PC_NOCOLLAPSE,
	 102,   0, 204, PC_NOCOLLAPSE,
	 153,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 204, PC_NOCOLLAPSE,
	   0,  51, 153, PC_NOCOLLAPSE,
	  51,  51, 204, PC_NOCOLLAPSE,
	 102,  51, 204, PC_NOCOLLAPSE,
	 153,  51, 204, PC_NOCOLLAPSE,
	 204,  51, 204, PC_NOCOLLAPSE,
	 255,  51, 204, PC_NOCOLLAPSE,
	   0, 102, 204, PC_NOCOLLAPSE,
	  51, 102, 204, PC_NOCOLLAPSE,
	 102, 102, 153, PC_NOCOLLAPSE,
	 153, 102, 204, PC_NOCOLLAPSE,
	 204, 102, 204, PC_NOCOLLAPSE,
	 255, 102, 153, PC_NOCOLLAPSE,
	   0, 153, 204, PC_NOCOLLAPSE,
	  51, 153, 204, PC_NOCOLLAPSE,
	 102, 153, 204, PC_NOCOLLAPSE,
	 153, 153, 204, PC_NOCOLLAPSE,
	 204, 153, 204, PC_NOCOLLAPSE,
	 255, 153, 204, PC_NOCOLLAPSE,
	   0, 204, 204, PC_NOCOLLAPSE,
	  51, 204, 204, PC_NOCOLLAPSE,
	 102, 204, 204, PC_NOCOLLAPSE,
	 153, 204, 204, PC_NOCOLLAPSE,
	 204, 204, 204, PC_NOCOLLAPSE,
	 255, 204, 204, PC_NOCOLLAPSE,
	   0, 255, 204, PC_NOCOLLAPSE,
	  51, 255, 204, PC_NOCOLLAPSE,
	 102, 255, 153, PC_NOCOLLAPSE,
	 153, 255, 204, PC_NOCOLLAPSE,
	 204, 255, 204, PC_NOCOLLAPSE,
	 255, 255, 204, PC_NOCOLLAPSE,
	  51,   0, 204, PC_NOCOLLAPSE,
	 102,   0, 255, PC_NOCOLLAPSE,
	 153,   0, 255, PC_NOCOLLAPSE,
	   0,  51, 204, PC_NOCOLLAPSE,
	  51,  51, 255, PC_NOCOLLAPSE,
	 102,  51, 255, PC_NOCOLLAPSE,
	 153,  51, 255, PC_NOCOLLAPSE,
	 204,  51, 255, PC_NOCOLLAPSE,
	 255,  51, 255, PC_NOCOLLAPSE,
	   0, 102, 255, PC_NOCOLLAPSE,
	  51, 102, 255, PC_NOCOLLAPSE,
	 102, 102, 204, PC_NOCOLLAPSE,
	 153, 102, 255, PC_NOCOLLAPSE,
	 204, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 204, PC_NOCOLLAPSE,
	   0, 153, 255, PC_NOCOLLAPSE,
	  51, 153, 255, PC_NOCOLLAPSE,
	 102, 153, 255, PC_NOCOLLAPSE,
	 153, 153, 255, PC_NOCOLLAPSE,
	 204, 153, 255, PC_NOCOLLAPSE,
	 255, 153, 255, PC_NOCOLLAPSE,
	   0, 204, 255, PC_NOCOLLAPSE,
	  51, 204, 255, PC_NOCOLLAPSE,
	 102, 204, 255, PC_NOCOLLAPSE,
	 153, 204, 255, PC_NOCOLLAPSE,
	 204, 204, 255, PC_NOCOLLAPSE,
	 255, 204, 255, PC_NOCOLLAPSE,
	  51, 255, 255, PC_NOCOLLAPSE,
	 102, 255, 204, PC_NOCOLLAPSE,
	 153, 255, 255, PC_NOCOLLAPSE,
	 204, 255, 255, PC_NOCOLLAPSE,
	 255, 102, 102, PC_NOCOLLAPSE,
	 102, 255, 102, PC_NOCOLLAPSE,
	 255, 255, 102, PC_NOCOLLAPSE,
	 102, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 255, PC_NOCOLLAPSE,
	 102, 255, 255, PC_NOCOLLAPSE,
	 165,   0,  33, PC_NOCOLLAPSE,
	  95,  95,  95, PC_NOCOLLAPSE,
	 119, 119, 119, PC_NOCOLLAPSE,
	 134, 134, 134, PC_NOCOLLAPSE,
	 150, 150, 150, PC_NOCOLLAPSE,
	 203, 203, 203, PC_NOCOLLAPSE,
	 178, 178, 178, PC_NOCOLLAPSE,
	 215, 215, 215, PC_NOCOLLAPSE,
	 221, 221, 221, PC_NOCOLLAPSE,
	 227, 227, 227, PC_NOCOLLAPSE,
	 234, 234, 234, PC_NOCOLLAPSE,
	 241, 241, 241, PC_NOCOLLAPSE,
	 248, 248, 248, PC_NOCOLLAPSE
};
#else // }{ USE_WIN95_PAL
unsigned char PalTable[236*4] = {
                              0,  39+ 15,       0,  PC_NOCOLLAPSE,
                              0,  39+ 24,       0,  PC_NOCOLLAPSE,
                              0,  39+ 33,       0,  PC_NOCOLLAPSE,
                              0,  39+ 42,       0,  PC_NOCOLLAPSE,
                        -44+ 51,  39+ 51,       0,  PC_NOCOLLAPSE,
                        -44+ 60,  39+ 60, -55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  39+ 69, -55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  39+ 78, -55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  39+ 87, -55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  39+ 96, -55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  39+105, -55+105,  PC_NOCOLLAPSE,
                        -44+114,  39+114, -55+114,  PC_NOCOLLAPSE,
                        -44+123,  39+123, -55+123,  PC_NOCOLLAPSE,
                        -44+132,  39+132, -55+132,  PC_NOCOLLAPSE,
                        -44+141,  39+141, -55+141,  PC_NOCOLLAPSE,
                        -44+150,  39+150, -55+150,  PC_NOCOLLAPSE,
                        -44+159,  39+159, -55+159,  PC_NOCOLLAPSE,
                        -44+168,  39+168, -55+168,  PC_NOCOLLAPSE,
                        -44+177,  39+177, -55+177,  PC_NOCOLLAPSE,
                        -44+186,  39+186, -55+186,  PC_NOCOLLAPSE,
                        -44+195,  39+195, -55+195,  PC_NOCOLLAPSE,
                        -44+204,  39+204, -55+204,  PC_NOCOLLAPSE,
                        -44+213,  39+213, -55+213,  PC_NOCOLLAPSE,
                        -44+222,     255, -55+222,  PC_NOCOLLAPSE,
                        -44+231,     255, -55+231,  PC_NOCOLLAPSE,
                        -44+240,     255, -55+240,  PC_NOCOLLAPSE,

                              0,  26+ 15,   0+ 15,  PC_NOCOLLAPSE,
                              0,  26+ 24,   0+ 24,  PC_NOCOLLAPSE,
                              0,  26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                              0,  26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                        -44+105,  26+105,   0+105,  PC_NOCOLLAPSE,
                        -44+114,  26+114,   0+114,  PC_NOCOLLAPSE,
                        -44+123,  26+123,   0+123,  PC_NOCOLLAPSE,
                        -44+132,  26+132,   0+132,  PC_NOCOLLAPSE,
                        -44+141,  26+141,   0+141,  PC_NOCOLLAPSE,
                        -44+150,  26+150,   0+150,  PC_NOCOLLAPSE,
                        -44+159,  26+159,   0+159,  PC_NOCOLLAPSE,
                        -44+168,  26+168,   0+168,  PC_NOCOLLAPSE,
                        -44+177,  26+177,   0+177,  PC_NOCOLLAPSE,
                        -44+186,  26+186,   0+186,  PC_NOCOLLAPSE,
                        -44+195,  26+195,   0+195,  PC_NOCOLLAPSE,
                        -44+204,  26+204,   0+204,  PC_NOCOLLAPSE,
                        -44+213,  26+213,   0+213,  PC_NOCOLLAPSE,
                        -44+222,  26+222,   0+222,  PC_NOCOLLAPSE,
                        -44+231,     255,   0+231,  PC_NOCOLLAPSE,
                        -44+240,     255,   0+240,  PC_NOCOLLAPSE,

                              0,  14+ 15,  55+ 15,  PC_NOCOLLAPSE,
                              0,  14+ 24,  55+ 24,  PC_NOCOLLAPSE,
                              0,  14+ 33,  55+ 33,  PC_NOCOLLAPSE,
                              0,  14+ 42,  55+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  14+ 51,  55+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  14+ 60,  55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  14+ 69,  55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  14+ 78,  55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  14+ 87,  55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  14+ 96,  55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  14+105,  55+105,  PC_NOCOLLAPSE,
                        -44+114,  14+114,  55+114,  PC_NOCOLLAPSE,
                        -44+123,  14+123,  55+123,  PC_NOCOLLAPSE,
                        -44+132,  14+132,  55+132,  PC_NOCOLLAPSE,

						// Replace this entry with a more ie-logo-friendly color 
						// -44+141,  14+141,  55+141,  PC_NOCOLLAPSE,
							 51,     153,     255,  PC_NOCOLLAPSE,

                        -44+150,  14+150,  55+150,  PC_NOCOLLAPSE,
                        -44+159,  14+159,  55+159,  PC_NOCOLLAPSE,
                        -44+168,  14+168,  55+168,  PC_NOCOLLAPSE,
                        -44+177,  14+177,  55+177,  PC_NOCOLLAPSE,
                        -44+186,  14+186,  55+186,  PC_NOCOLLAPSE,
                        -44+195,  14+195,  55+195,  PC_NOCOLLAPSE,
                        -44+204,  14+204,     255,  PC_NOCOLLAPSE,
                        -44+213,  14+213,     255,  PC_NOCOLLAPSE,
                        -44+222,     255,     255,  PC_NOCOLLAPSE,
                        -44+231,     255,     255,  PC_NOCOLLAPSE,
                        -44+240,     255,     255,  PC_NOCOLLAPSE,

                          0+ 15,  13+ 15,       0,  PC_NOCOLLAPSE,
                          0+ 24,  13+ 24,       0,  PC_NOCOLLAPSE,
                          0+ 33,  13+ 33,       0,  PC_NOCOLLAPSE,
                          0+ 42,  13+ 42,       0,  PC_NOCOLLAPSE,
                          0+ 51,  13+ 51,       0,  PC_NOCOLLAPSE,
                          0+ 60,  13+ 60, -55+ 60,  PC_NOCOLLAPSE,
                          0+ 69,  13+ 69, -55+ 69,  PC_NOCOLLAPSE,
                          0+ 78,  13+ 78, -55+ 78,  PC_NOCOLLAPSE,
                          0+ 87,  13+ 87, -55+ 87,  PC_NOCOLLAPSE,
                          0+ 96,  13+ 96, -55+ 96,  PC_NOCOLLAPSE,
                          0+105,  13+105, -55+105,  PC_NOCOLLAPSE,
                          0+114,  13+114, -55+114,  PC_NOCOLLAPSE,
                          0+123,  13+123, -55+123,  PC_NOCOLLAPSE,
                          0+132,  13+132, -55+132,  PC_NOCOLLAPSE,
                          0+141,  13+141, -55+141,  PC_NOCOLLAPSE,
                          0+150,  13+150, -55+150,  PC_NOCOLLAPSE,
                          0+159,  13+159, -55+159,  PC_NOCOLLAPSE,
                          0+168,  13+168, -55+168,  PC_NOCOLLAPSE,
                          0+177,  13+177, -55+177,  PC_NOCOLLAPSE,
                          0+186,  13+186, -55+186,  PC_NOCOLLAPSE,
                          0+195,  13+195, -55+195,  PC_NOCOLLAPSE,
                          0+204,  13+204, -55+204,  PC_NOCOLLAPSE,
                          0+213,  13+213, -55+213,  PC_NOCOLLAPSE,
                          0+222,  13+222, -55+222,  PC_NOCOLLAPSE,
                          0+231,  13+231, -55+231,  PC_NOCOLLAPSE,
                          0+240,  13+242, -55+240,  PC_NOCOLLAPSE,

                          0+ 15,   0+ 15,   0+ 15,  PC_NOCOLLAPSE,
                          0+ 24,   0+ 24,   0+ 24,  PC_NOCOLLAPSE,
                          0+ 33,   0+ 33,   0+ 33,  PC_NOCOLLAPSE,
                          0+ 42,   0+ 42,   0+ 42,  PC_NOCOLLAPSE,
                          0+ 51,   0+ 51,   0+ 51,  PC_NOCOLLAPSE,
                          0+ 60,   0+ 60,   0+ 60,  PC_NOCOLLAPSE,
                          0+ 69,   0+ 69,   0+ 69,  PC_NOCOLLAPSE,
                          0+ 78,   0+ 78,   0+ 78,  PC_NOCOLLAPSE,
                          0+ 87,   0+ 87,   0+ 87,  PC_NOCOLLAPSE,
                          0+ 96,   0+ 96,   0+ 96,  PC_NOCOLLAPSE,
                          0+105,   0+105,   0+105,  PC_NOCOLLAPSE,
                          0+114,   0+114,   0+114,  PC_NOCOLLAPSE,
                          0+123,   0+123,   0+123,  PC_NOCOLLAPSE,
                          0+132,   0+132,   0+132,  PC_NOCOLLAPSE,
                          0+141,   0+141,   0+141,  PC_NOCOLLAPSE,
                          0+150,   0+150,   0+150,  PC_NOCOLLAPSE,
                          0+159,   0+159,   0+159,  PC_NOCOLLAPSE,
                          0+168,   0+168,   0+168,  PC_NOCOLLAPSE,
                          0+177,   0+177,   0+177,  PC_NOCOLLAPSE,
                          0+186,   0+186,   0+186,  PC_NOCOLLAPSE,
                          0+195,   0+195,   0+195,  PC_NOCOLLAPSE,
                          0+204,   0+204,   0+204,  PC_NOCOLLAPSE,
                          0+213,   0+213,   0+213,  PC_NOCOLLAPSE,
                          0+222,   0+222,   0+222,  PC_NOCOLLAPSE,
                          0+231,   0+231,   0+231,  PC_NOCOLLAPSE,
                          0+240,   0+240,   0+240,  PC_NOCOLLAPSE,

                          0+ 15, -13+ 15,  55+ 15,  PC_NOCOLLAPSE,
                          0+ 24, -13+ 24,  55+ 24,  PC_NOCOLLAPSE,
                          0+ 33, -13+ 33,  55+ 33,  PC_NOCOLLAPSE,
                          0+ 42, -13+ 42,  55+ 42,  PC_NOCOLLAPSE,
                          0+ 51, -13+ 51,  55+ 51,  PC_NOCOLLAPSE,
                          0+ 60, -13+ 60,  55+ 60,  PC_NOCOLLAPSE,
                          0+ 69, -13+ 69,  55+ 69,  PC_NOCOLLAPSE,
                          0+ 78, -13+ 78,  55+ 78,  PC_NOCOLLAPSE,
                          0+ 87, -13+ 87,  55+ 87,  PC_NOCOLLAPSE,
                          0+ 96, -13+ 96,  55+ 96,  PC_NOCOLLAPSE,
                          0+105, -13+105,  55+105,  PC_NOCOLLAPSE,
                          0+114, -13+114,  55+114,  PC_NOCOLLAPSE,
                          0+123, -13+123,  55+123,  PC_NOCOLLAPSE,
                          0+132, -13+132,  55+132,  PC_NOCOLLAPSE,
                          0+141, -13+141,  55+141,  PC_NOCOLLAPSE,
                          0+150, -13+150,  55+150,  PC_NOCOLLAPSE,
                          0+159, -13+159,  55+159,  PC_NOCOLLAPSE,
                          0+168, -13+168,  55+168,  PC_NOCOLLAPSE,
                          0+177, -13+177,  55+177,  PC_NOCOLLAPSE,
                          0+186, -13+186,  55+186,  PC_NOCOLLAPSE,
                          0+195, -13+195,  55+195,  PC_NOCOLLAPSE,
                          0+204, -13+204,     255,  PC_NOCOLLAPSE,
                          0+213, -13+213,     255,  PC_NOCOLLAPSE,
                          0+222, -13+222,     255,  PC_NOCOLLAPSE,
                          0+231, -13+231,     255,  PC_NOCOLLAPSE,
                          0+240, -13+240,     255,  PC_NOCOLLAPSE,

                         44+ 15, -14+ 15,       0,  PC_NOCOLLAPSE,
                         44+ 24, -14+ 24,       0,  PC_NOCOLLAPSE,
                         44+ 33, -14+ 33,       0,  PC_NOCOLLAPSE,
                         44+ 42, -14+ 42,       0,  PC_NOCOLLAPSE,
                         44+ 51, -14+ 51,       0,  PC_NOCOLLAPSE,
                         44+ 60, -14+ 60, -55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -14+ 69, -55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -14+ 78, -55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -14+ 87, -55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -14+ 96, -55+ 96,  PC_NOCOLLAPSE,
                         44+105, -14+105, -55+105,  PC_NOCOLLAPSE,
                         44+114, -14+114, -55+114,  PC_NOCOLLAPSE,
                         44+123, -14+123, -55+123,  PC_NOCOLLAPSE,
                         44+132, -14+132, -55+132,  PC_NOCOLLAPSE,
                         44+141, -14+141, -55+141,  PC_NOCOLLAPSE,
                         44+150, -14+150, -55+150,  PC_NOCOLLAPSE,
                         44+159, -14+159, -55+159,  PC_NOCOLLAPSE,
                         44+168, -14+168, -55+168,  PC_NOCOLLAPSE,
                         44+177, -14+177, -55+177,  PC_NOCOLLAPSE,
                         44+186, -14+186, -55+186,  PC_NOCOLLAPSE,
                         44+195, -14+195, -55+195,  PC_NOCOLLAPSE,
                         44+204, -14+204, -55+204,  PC_NOCOLLAPSE,
                            255, -14+213, -55+213,  PC_NOCOLLAPSE,
                            255, -14+222, -55+222,  PC_NOCOLLAPSE,
                            255, -14+231, -55+231,  PC_NOCOLLAPSE,
                            255, -14+242, -55+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,   0+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,   0+ 24,  PC_NOCOLLAPSE,
                         44+ 33, -26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                         44+105, -26+105,   0+105,  PC_NOCOLLAPSE,
                         44+114, -26+114,   0+114,  PC_NOCOLLAPSE,
                         44+123, -26+123,   0+123,  PC_NOCOLLAPSE,
                         44+132, -26+132,   0+132,  PC_NOCOLLAPSE,
                         44+141, -26+141,   0+141,  PC_NOCOLLAPSE,
                         44+150, -26+150,   0+150,  PC_NOCOLLAPSE,
                         44+159, -26+159,   0+159,  PC_NOCOLLAPSE,
                         44+168, -26+168,   0+168,  PC_NOCOLLAPSE,
                         44+177, -26+177,   0+177,  PC_NOCOLLAPSE,
                         44+186, -26+186,   0+186,  PC_NOCOLLAPSE,
                         44+195, -26+195,   0+195,  PC_NOCOLLAPSE,
                         44+204, -26+204,   0+204,  PC_NOCOLLAPSE,
                            255, -26+213,   0+213,  PC_NOCOLLAPSE,
                            255, -26+222,   0+222,  PC_NOCOLLAPSE,
                            255, -26+231,   0+231,  PC_NOCOLLAPSE,
                            255, -26+240,   0+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,  55+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,  55+ 24,  PC_NOCOLLAPSE,
                         44+ 33,       0,  55+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -39+ 42,  55+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -39+ 51,  55+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -39+ 60,  55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -39+ 69,  55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -39+ 78,  55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -39+ 87,  55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -39+ 96,  55+ 96,  PC_NOCOLLAPSE,
                         44+105, -39+105,  55+105,  PC_NOCOLLAPSE,
                         44+114, -39+114,  55+114,  PC_NOCOLLAPSE,
                         44+123, -39+123,  55+123,  PC_NOCOLLAPSE,
                         44+132, -39+132,  55+132,  PC_NOCOLLAPSE,
                         44+141, -39+141,  55+141,  PC_NOCOLLAPSE,
                         44+150, -39+150,  55+150,  PC_NOCOLLAPSE,
                         44+159, -39+159,  55+159,  PC_NOCOLLAPSE,
                         44+168, -39+168,  55+168,  PC_NOCOLLAPSE,
                         44+177, -39+177,  55+177,  PC_NOCOLLAPSE,
                         44+186, -39+186,  55+186,  PC_NOCOLLAPSE,
                         44+195, -39+195,  55+195,  PC_NOCOLLAPSE,
                         44+204, -39+204,     255,  PC_NOCOLLAPSE,
                            255, -39+213,     255,  PC_NOCOLLAPSE,
                            255, -39+222,     255,  PC_NOCOLLAPSE,
                            255, -39+231,     255,  PC_NOCOLLAPSE,
                            255, -39+240,     255,  PC_NOCOLLAPSE,

			0x81, 0x81, 0x83, PC_NOCOLLAPSE, 
			0x81, 0x81, 0x84, PC_NOCOLLAPSE
};
#endif // } USE_WIN95_PAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3pcolor.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*

CCIR 601 Specifies a conversion from RGB to YCrCb. For
what we call U and V, they are equivalent as 
U = Cb, V = Cr.

From CCIR 601-2 Annex II, we can go from RGB with values
in the range of 0-255, to YUV values in the same range
by the equation:

Y = (    77*R + 150*G +  29*B ) >> 8;
V = (   131*R - 110*G -  21*B ) >> 8 + 128; 	// Cr
U = ( (-44)*R -  87*G + 131*B ) >> 8 + 128;		// Cb

Has now changed to the inverse of the YUV->RGB on the
output, since the old version produced way too many bits.
The new version is:

Y = (   16836*R +  33056*G +  6416*B ) >> 16 + 16;
V = (   28777*R -  24117*G -  4660*B ) >> 16 + 128; 	// Cr
U = ( (-9726)*R -  19064*G + 28790*B ) >> 16 + 128;		// Cb

*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // { H263P

//
// All of the RGB converters follow the template given below. The converters make
// some assumptions about the frame size. All output frame sizes are assumed to
// have a frame height that is a multiple of 48. Also, the output frame width
// is assumed to be a multiple of 8. If the input frame size is equal
// to the output frame size, no stretching or cropping is done. Otherwise, the
// image is cropped and stretched for an 11:12 aspect ratio.
//

#if 0 // { 0
void rgb_color_converter() {
	for (j = 0; j < LumaIters; j++) {
		for (k = 0; k < mark; k++) {
			for (i = lpbiOutput->biWidth; i > 0; i -= m, pnext += n) {
				compute m Y values using look-up tables
				if (0 == (k&1)) {
					compute m/2 U,V values using look-up tables
				}
			}
			if ((0 == k) && j) {
				for (i = lpbiOutput->biWidth; i > 0; i -= 8 {
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
				}
			}
			pnext += iBackTwoLines;
			py += ypitch_adj;
			if (0 == (k&1)) {
				pu += uvpitch_adj;
				pv += uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = py - pitch;
			pyspace = py;
			pynext = py + pitch;
		}
	}
	if (stretch) {
		for (i = lpbiOutput->biWidth; i > 0; i -= 4 {
			*pyspace++ = *pyprev++;
		}
	}
}
#endif // } 0

// These are the look-up tables for the RGB converters. They are 8 bytes/entry
// to allow addressing via the scale by 8 indexed addressing mode. A pseudo-SIMD
// arrangement is used in these tables. Since all R, G and B contributions to the
// Y value are positive and fit in 15 bits, these are stored in the lower 16-bits
// of the YU word. In some cases, the U contribution is negative so it is placed
// in the upper 16 bits of the YU word. When a Y value is calculated, the U value
// is calculated in parallel. The V contribution is negative in some cases, but it
// gets its own word.

#define YRCoef   16836
#define YGCoef   33056
#define YBCoef    6416
#define URCoef    9726
#define UGCoef   19064
#define UBCoef   28790
#define VRCoef   28777
#define VGCoef   24117
#define VBCoef    4660

struct YUV RYUV[128];
struct YUV GYUV[128];
struct YUV BYUV[128];
struct YUVQUAD YUVPalette[256];

void fill_YUV_tables(void) {
int i,j;

  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      RYUV[((i*4)+j)>>1].YU = ((YRCoef*((i*4)+j+1))>>9) | ((-(((URCoef*((i*4)+j+1)))>>9))<<16);
      RYUV[((i*4)+j)>>1].V  = ((VRCoef*((i*4)+j+1))>>9);
    }
  }

  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      GYUV[((i*4)+j)>>1].YU = ((YGCoef*((i*4)+j+1))>>9) | ((-(((UGCoef*((i*4)+j+1)))>>9))<<16);
      GYUV[((i*4)+j)>>1].V  = -((VGCoef*((i*4)+j+1))>>9);
    }
  }

  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      BYUV[((i*4)+j)>>1].YU = ((YBCoef*((i*4)+j+1))>>9) | (((UBCoef*((i*4)+j+1))>>9)<<16);
      BYUV[((i*4)+j)>>1].V  = -((VBCoef*((i*4)+j+1))>>9);
    }
  }
}

void Compute_YUVPalette(LPBITMAPINFOHEADER	lpbiInput) {
RGBQUAD *lpCEntry, *lpCTable = (RGBQUAD *)((U8 *)lpbiInput + sizeof(BITMAPINFOHEADER));
YUVQUAD *lpYUVEntry;
DWORD i;
int t;

	for (i = 0; i < lpbiInput->biClrUsed; i++) {
		lpCEntry = &lpCTable[i];
		lpYUVEntry = &YUVPalette[i];
		t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
			  GYUV[lpCEntry->rgbGreen>>1].YU +
			  RYUV[lpCEntry->rgbRed>>1].YU );
		lpYUVEntry->Yval = (U8)((t>>8)+8);
		lpYUVEntry->Uval = (U8)((t>>24)+64);
		t = ( RYUV[lpCEntry->rgbRed>>1].V +
			  GYUV[lpCEntry->rgbGreen>>1].V +
			  BYUV[lpCEntry->rgbBlue>>1].V );
		lpYUVEntry->Vval = (U8)((t>>8)+64);
	}
}

typedef struct {
  // Ptr to color conv initializer function.
  void ( * Initializer) (LPBITMAPINFOHEADER	lpbiInput);
  void ( * ColorConvertor[3]) (
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);
// [0] P5 version
// [1] P6 version
// [2] MMX version
} T_H26XInputColorConvertorCatalog;

/*  The Connectix Quick Cam requires RGB to YUV12 conversion.
 *  The B/W camera generates palette versions (8 and 4 bit).
 *  The color camera generates RGB24 for million colors and
 *  RGB16555 for thousands colors.
 */

#ifndef USE_BILINEAR_MSH26X
static void BGR32_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}
#endif

static void BGR24_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

static void BGR16555_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

static void CLUT8_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

static void CLUT4_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

T_H26XInputColorConvertorCatalog InputColorConvertorCatalog[] = {
	{ NULL,			NULL,						NULL,					NULL					},
#ifndef USE_BILINEAR_MSH26X
	{ BGR32_INIT,	P5_H26X_BGR32toYUV12,		P5_H26X_BGR32toYUV12,	P5_H26X_BGR32toYUV12    },
#endif
	{ BGR24_INIT,	P5_H26X_BGR24toYUV12,		P5_H26X_BGR24toYUV12,	P5_H26X_BGR24toYUV12	},
	{ BGR16555_INIT,P5_H26X_BGR16555toYUV12,	P5_H26X_BGR16555toYUV12,P5_H26X_BGR16555toYUV12 },
	{ CLUT8_INIT,	P5_H26X_CLUT8toYUV12,		P5_H26X_CLUT8toYUV12,	P5_H26X_CLUT8toYUV12	},
	{ CLUT4_INIT,	P5_H26X_CLUT4toYUV12,		P5_H26X_CLUT4toYUV12,	P5_H26X_CLUT4toYUV12	},
	{ NULL,			C_H26X_YVU9toYUV12,			C_H26X_YVU9toYUV12,		C_H26X_YVU9toYUV12      },
	{ NULL,			P5_H26X_YUY2toYUV12,		P5_H26X_YUY2toYUV12,	P5_H26X_YUY2toYUV12     },
	{ NULL,			P5_H26X_UYVYtoYUV12,		P5_H26X_UYVYtoYUV12,	P5_H26X_UYVYtoYUV12     },
	{ NULL,			C_H26X_YUV12toEncYUV12,		C_H26X_YUV12toEncYUV12,	C_H26X_YUV12toEncYUV12  },
};

void colorCnvtInitialize(
	LPBITMAPINFOHEADER	lpbiInput,
	int InputColorConvertor) {

	if (InputColorConvertorCatalog[InputColorConvertor].Initializer) {
		InputColorConvertorCatalog[InputColorConvertor].Initializer(lpbiInput);
	}
}

#ifdef USE_MMX // { USE_MMX
extern BOOL MMX_Enabled;
#endif // } USE_MMX

/*************************************************************
 *  Name:         colorCnvtFrame
 *  Description:  Color convert and copy input frame.
 ************************************************************/
void colorCnvtFrame(
  	U32			ColorConvertor,
	LPCODINST	lpCompInst,
    ICCOMPRESS	*lpicComp,
    U8			*YPlane,
    U8			*UPlane,
    U8			*VPlane
)
{
	LPBITMAPINFOHEADER	lpbiInput = lpicComp->lpbiInput;
    U8 *lpInput = (U8 *) lpicComp->lpInput;

#ifdef USE_MMX // { USE_MMX
	InputColorConvertorCatalog[ColorConvertor].ColorConvertor[MMX_Enabled ? MMX_CC : PENTIUM_CC](lpbiInput,lpCompInst->xres,lpCompInst->yres,lpInput,YPlane,UPlane,VPlane,PITCH);
#else // }{ USE_MMX
	InputColorConvertorCatalog[ColorConvertor].ColorConvertor[PENTIUM_CC](lpbiInput,lpCompInst->xres,lpCompInst->yres,lpInput,YPlane,UPlane,VPlane,PITCH);
#endif // } USE_MMX
			

}

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb16.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//
// Only the 555 version of RGB16 input color conversion is provided. To generate
// other versions, use the following table.
//
//   number             shift              mask
//                     B, G, R
//   ------          -----------       ----------------
//    555              2, 3, 8         0x7C, 0x7C, 0x7C
//    664              3, 3, 9         0x78, 0x7E, 0x7E
//    565              2, 4, 9         0x7C, 0x7E, 0x7C
//    655              2, 3, 9         0x7C, 0x7C, 0x7E
//
// Only 555 falls under BI_RGB. The others are specified using the
// BI_BITFIELDS compression specification. For BI_BITFIELDS, call
// Build16bitModeID to get the actual bitfield number. This routine requires the
// three array elements in the bmiColors field of a BITMAPINFO object.
//
/*****************************************************************************
 *
 *  H26X_BGR16555toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0 // { 0

void C_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	int t1, t2;
	int tm1, tm2;

	C_RGB_COLOR_CONVERT_INIT

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {
			for (i = OutputWidth; i > 0; i-=4, YPlane+=4) {
				tm1 = *pnext++;
				t1 = (BYUV[(tm1<<2)&0x7C].YU +
					 GYUV[(tm1>>3)&0x7C].YU +
					 RYUV[(tm1>>8)&0x7C].YU);
				*(YPlane) = (U8)((t1>>SHIFT_WIDTH)+8);
				t = (BYUV[(tm1>>14)&0x7C].YU +
					 GYUV[(tm1>>19)&0x7C].YU +
					 RYUV[(tm1>>24)&0x7C].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm2 = *pnext++;
				t2 = (BYUV[(tm2<<2)&0x7C].YU +
					 GYUV[(tm2>>3)&0x7C].YU +
					 RYUV[(tm2>>8)&0x7C].YU);
				*(YPlane+2) = (U8)((t2>>SHIFT_WIDTH)+8);
				t = (BYUV[(tm2>>14)&0x7C].YU +
					 GYUV[(tm2>>19)&0x7C].YU +
					 RYUV[(tm2>>24)&0x7C].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*(U16 *)UPlane = ((t1+0x40000000)>>24) |	(((t2+0x40000000)>>16)&0xFF00);
					t1 = (RYUV[(tm1>>8)&0x7C].V +
						 GYUV[(tm1>>3)&0x7C].V +
						 BYUV[(tm1<<2)&0x7C].V);
					t2 = (RYUV[(tm2>>8)&0x7C].V +
						 GYUV[(tm2>>3)&0x7C].V +
						 BYUV[(tm2<<2)&0x7C].V);
					*(U16 *)VPlane = ((t1+0x4000)>>8) | ((t2+0x4000)&0xFF00);
					UPlane += 2; VPlane += 2;
				}
			}
			// The next two cases are mutually exclusive.
			// If there is a width_diff there cannot be a stretch and
			// if there is a stretch, there cannot be a width_diff.
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	// The next two cases are mutually exclusive.
	// If there is a height_diff there cannot be a stretch and
	// if there is a stretch, there cannot be a height_diff.
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR55516toYUV12

#endif // } 0

__declspec(naked)
void P5_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		eax, [esp + OUTPUT_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm1 = pnext[0]
// t = ( BYUV[(tm1>>14)&0x7C].YU +
//       GYUV[(tm1>>19)&0x7C].YU +
//       RYUV[(tm1>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t1 = ( BYUV[(tm1<< 2)&0x7C].YU +
//       GYUV[(tm1>> 8)&0x7C].YU +
//       RYUV[(tm1>>13)&0x7C].YU )
// *YPlane = (U8)((t1>>8)+8)
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 1
	mov 	ebx, [esi]
	mov		[esp + LOOP_I], eax
// 2
	mov 	eax, ebx
	mov 	ecx, ebx
// 3
	shr 	eax, 14
	mov 	edx, ebx
// 4
	shr 	ecx, 19
	and 	eax, 0x7C
// 5
	shr 	edx, 24
	and 	ecx, 0x7C
// 6
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 9
	sar 	eax, 8
		and	ebx,  0x1F
// 10
		shl 	ebx, 2
	add 	eax, 8
// 11
		shr 	ecx, 3
	mov	 	[edi + 1], al
// 12
		shr 	edx, 8
		and 	ecx, 0x7C
// 13
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 15
		add	 	eax, [RYUV+edx*8].YU
		lea		edi, [edi + 4]
// 16
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add	 	eax, 8
		and		ebx, 1
// 18
		mov 	[edi - 4], al
		jnz 	L9a

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t1>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop

L9a:
// tm2 = pnext[1]
// t = ( BYUV[(tm2>>14)&0x7C].YU +
//       GYUV[(tm2>>19)&0x7C].YU +
//       RYUV[(tm2>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t2 = ( BYUV[(tm2<< 2)&0x7C].YU +
//       GYUV[(tm2>> 8)&0x7C].YU +
//       RYUV[(tm2>>13)&0x7C].YU )
// *YPlane = (U8)((t2>>8)+8)
// YPlane += 4
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 27
	mov 	eax, [esi + 4]
	lea		esi, [esi + 8]
// 28
	mov 	ebx, eax
	mov 	ecx, eax
// 29
	shr 	eax, 14
	mov 	edx, ebx
// 30
	shr 	ecx, 19
	and 	eax, 0x7C
// 31
	shr 	edx, 24
	and 	ecx, 0x7C
// 32
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 33
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 34
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 35
	sar 	eax, 8
		and	ebx,  0x1F
// 36
		shl 	ebx, 2
	add 	eax, 8
// 37
		shr 	ecx, 3
	mov	 	[edi - 1], al
// 38
		shr 	edx, 8
		and 	ecx, 0x7C
// 39
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 40
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 41
		add	 	eax, [RYUV+edx*8].YU
		nop
// 42
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 43
		add	 	eax, 8
		and		ebx, 1
// 44
		mov 	[edi - 2], al
		jnz 	L9

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t2>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 45
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 46
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 47
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 48
	mov		[edx], al
	inc		edx
// 49
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 50
	sar 	ebx, 8
	inc		edx
// 51
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 52
	mov		[edx - 1], bl
	nop

L9:
// 53
	mov		eax, [esp + LOOP_I]
	nop
// 54
	sub		eax, 4
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb24.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR24toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0 // { 0

void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{

	C_RGB_COLOR_CONVERT_INIT

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {
			for (i = OutputWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>SHIFT_WIDTH)+8);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
			}
			// The next two cases are mutually exclusive.
			// If there is a width_diff there cannot be a stretch and
			// if there is a stretch, there cannot be a width_diff.
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	// The next two cases are mutually exclusive.
	// If there is a height_diff there cannot be a stretch and
	// if there is a stretch, there cannot be a height_diff.
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR24toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 4, pnext += 12)
L5:
	mov		eax, [esp + OUTPUT_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[t0>>25].YU +
//       GYUV[(t1>> 1)&0x7F].YU +
//       RYUV[(t1>> 9)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	eax, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	ebx, eax
	mov 	edx, ecx
// 3
	shr 	eax, 25
	and 	ecx, 0xFE
// 4
	shr 	ecx, 1
	and 	edx, 0xFE00
// 5
	shr 	edx, 9
		and		ebx, 0xFEFEFE
// 6
	mov 	eax, [BYUV+eax*8].YU
	nop
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
	sar 	eax, 8
		and 	ebx, 0xFE
// 10
		shr 	ebx, 1
	add	eax,  8
// 11
		shr 	ecx, 9
	mov	 [edi + 1], al
// 12
		shr		edx, 17
		and		ecx, 0x7F
// 13
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 15
		add		eax, [RYUV+edx*8].YU
		nop
// 16
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add		eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t1 = pnext[1]
// t2 = pnext[2]
// t = ( BYUV[(t2>> 9)&0x7F].YU +
//       GYUV[(t2>>17)&0x7F].YU +
//       RYUV[t2>>25].YR )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t1>>17)&0x7F].YU +
//       GYUV[t1>>25].YU +
//       RYUV[(t2>> 1)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 27
	mov		ebp, [esi + 4]
	mov 	ebx, [esi + 8]
// 28
	mov 	eax, ebx
	mov 	ecx, ebx
// 29
	shr		eax, 9
	mov		edx, ebx
// 30
	shr 	ecx, 17
	and 	eax, 0x7F
// 31
	shr 	edx, 25
	and		ecx, 0x7F
// 32
	mov 	eax, [BYUV+eax*8].YU
	nop
// 33
	add 	eax, [GYUV+ecx*8].YU
		and		ebx, 0xFE
// 34
	add 	eax, [RYUV+edx*8].YU
		mov		ecx, ebp
// 35
		shr		ebx, 1
	add	eax,  0x800
// 36
	sar 	eax, 8
		mov		edx, ebp
// 37
		shr		edx, 17
	mov	 [edi + 3], al
// 38
		shr 	ecx, 25
		and		edx, 0x7F
// 39
		mov		eax, [RYUV+ebx*8].YU
		mov		ebp, ebx
// 40
		add	 	eax, [GYUV+ecx*8].YU
		nop
// 41
		add		eax, [BYUV+edx*8].YU
		nop
// 42
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 43
		add		eax, 8
		and		ebx, 1
// 44
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 45
	mov 	ebx, [BYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 46
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 47
	add		eax, 64
	add 	ebx, [RYUV+ebp*8].V
// 48
	mov		[edx], al
	inc		edx
// 49
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 50
	sar 	ebx, 8
	inc		edx
// 51
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 52
	mov		[edx - 1], bl
	nop
L16:
// 53
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 12]
// 54
	sub		eax, 4
	lea		edi, [edi + 4]
// 55
	mov		[esp + LOOP_I], eax
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov		ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:
	
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	mov		edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb32.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#ifdef H263P // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR32toYUV12()
 * 	
 *  Convert from BGR32 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0 // { 0

void C_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	int tm1, tm2;
	int t1, t2, t3, t4;

	C_RGB_COLOR_CONVERT_INIT

	// This assignment statement is here simply to avoid a warning message.
	t = t;

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = OutputWidth; i > 0; i-=4, YPlane+=4) {
				tm1 = *pnext++;
				t1 = (BYUV[(tm1>>1)&0x7F].YU +
				     GYUV[(tm1>>9)&0x7F].YU +
				     RYUV[(tm1>>17)&0x7F].YU);
				tm = *pnext++;
				t2 = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				tm2 = *pnext++;
				t3 = (BYUV[(tm2>>1)&0x7F].YU +
				     GYUV[(tm2>>9)&0x7F].YU +
				     RYUV[(tm2>>17)&0x7F].YU);
				tm = *pnext++;
				t4 = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*(U32 *)YPlane =
					(((t1+0x800)>>8)&0xFF)      |
					((t2+0x800)&0xFF00)         |
					(((t3+0x800)<<8)&0xFF0000)  |
					(((t4+0x800)<<16)&0xFF000000);
				if (0 == (k&1)) {
					*(U16 *)UPlane =
						((t1+0x40000000)>>24)            |
						(((t2+0x40000000)>>16)&0xFF00);
					t1 = (BYUV[(tm1>>1)&0x7F].V +
						 GYUV[(tm1>>9)&0x7F].V +
						 RYUV[(tm1>>17)&0x7F].V);
					t2 = (BYUV[(tm2>>1)&0x7F].V +
						 GYUV[(tm2>>9)&0x7F].V +
						 RYUV[(tm2>>17)&0x7F].V);
					*(U16 *)VPlane =
						((t1+0x4000)>>8)              |
						((t2+0x4000)&0xFF00);
					UPlane += 2; VPlane += 2;
				}
			}
			// The next two cases are mutually exclusive.
			// If there is a width_diff there cannot be a stretch and
			// if there is a stretch, there cannot be a width_diff.
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	// The next two cases are mutually exclusive.
	// If there is a height_diff there cannot be a stretch and
	// if there is a stretch, there cannot be a height_diff.
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR32toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 4, pnext += 16)
L5:
	mov		eax, [esp + OUTPUT_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  |    | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  |    | R2 | G2 | B2 | pnext[1]
//  ---------------------
//  |    | R3 | G3 | B3 | pnext[2]
//  ---------------------
//  |    | R4 | G4 | B4 | pnext[3]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[(t1>> 1)&0x7F].YU +
//       GYUV[(t1>> 9)&0x7F].YU +
//       RYUV[(t1>>17)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	ebx, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	eax, ecx
	mov 	edx, ecx
// 3
	shr 	eax, 1
	and 	ecx, 0xFE00
// 4
	shr 	ecx, 9
	and 	eax, 0x7F
// 5
	shr 	edx, 17
	nop
// 6
	mov 	eax, [BYUV+eax*8].YU
	and		edx, 0x7F
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
		shr 	ebx, 1
	add	eax,  0x800
// 10
	sar 	eax, 8
		and		ecx, 0xFE00
// 11
		shr 	ecx, 9
		and		ebx, 0x7F
// 12
		shr		edx, 17
	mov	 [edi + 1], al
// 13
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 15
		add		eax, [RYUV+edx*8].YU
		nop
// 16
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add		eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  |    | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  |    | R2 | G2 | B2 | pnext[1]
//  ---------------------
//  |    | R3 | G3 | B3 | pnext[2]
//  ---------------------
//  |    | R4 | G4 | B4 | pnext[3]
//  ---------------------

// t2 = pnext[2]
// t3 = pnext[3]
// t = ( BYUV[(t3>> 1)&0x7F].YU +
//       GYUV[(t3>> 9)&0x7F].YU +
//       RYUV[(t3>>17)&0x7F].YU )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t2>> 1)&0x7F].YU +
//       GYUV[(t2>> 9)&0x7F].YU +
//       RYUV[(t2>>17)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 27
	mov		ebx, [esi + 8]
	mov 	ecx, [esi + 12]
// 28
	mov 	eax, ecx
	mov 	edx, ecx
// 29
	shr 	eax, 1
	and 	ecx, 0xFE00
// 30
	shr 	ecx, 9
	and 	eax, 0x7F
// 31
	shr 	edx, 17
	nop
// 32
	mov 	eax, [BYUV+eax*8].YU
	and		edx, 0x7F
// 33
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx, ebx
// 34
	add 	eax, [RYUV+edx*8].YU
		mov		edx, ebx
// 35
		shr		ebx, 1
	add	eax,  0x800
// 36
	sar 	eax, 8
		and		ebx, 0x7F
// 37
		shr		ecx, 9
	mov	 [edi + 3], al
// 38
		shr 	edx, 17
		and		ecx, 0x7F
// 39
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 40
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 41
		add		eax, [RYUV+edx*8].YU
		nop
// 42
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 43
		add		eax, 8
		and		ebx, 1
// 44
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 45
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 46
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 47
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 48
	mov		[edx], al
	inc		edx
// 49
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 50
	sar 	ebx, 8
	inc		edx
// 51
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 52
	mov		[edx - 1], bl
	nop
L16:
// 53
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 16]
// 54
	sub		eax, 4
	lea		edi, [edi + 4]
// 55
	mov		[esp + LOOP_I], eax
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov		ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	mov		edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3pcolor.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#ifndef _H263P_E3PCOLOR_H_
#define  _H263P_E3PCOLOR_H_ 

// Defines for the input color convertors
#ifdef USE_BILINEAR_MSH26X
#define RGB24toYUV12     1
#define RGB16555toYUV12  2
#define CLUT8toYUV12     3
#define CLUT4toYUV12     4
#define YVU9toYUV12      5
#define YUY2toYUV12      6
#define UYVYtoYUV12      7
#define YUV12toEncYUV12  8
#else
#define RGB32toYUV12     1
#define RGB24toYUV12     2
#define RGB16555toYUV12  3
#define CLUT8toYUV12     4
#define CLUT4toYUV12     5
#define YVU9toYUV12      6
#define YUY2toYUV12      7
#define UYVYtoYUV12      8
#define YUV12toEncYUV12  9
#endif

#define COEF_WIDTH   8
#define SHIFT_WIDTH  COEF_WIDTH

#define C_RGB_COLOR_CONVERT_INIT													\
	U32 *pnext;																		\
	U32 *pyprev, *pyspace, *pynext;													\
	U32 *puvprev, *puvspace;														\
	U8	t8u, t8v;																	\
	U32 tm;																			\
	int t;																			\
	int i, j, k;																	\
	int BackTwoLines;																\
	int widthx16;																	\
	int heightx16;																	\
	int width_diff = 0;																\
	int height_diff = 0;															\
	int width_adj = 0;																\
	int height_adj = 0;																\
	int stretch = 0;																\
	int aspect = 0;																	\
	int word_ypitch_adj = 0;														\
	int word_uvpitch_adj = 0;														\
	int LumaIters = 1;																\
	int mark = OutputHeight;														\
	int byte_ypitch_adj = pitch - OutputWidth;										\
	int byte_uvpitch_adj = pitch - (OutputWidth >> 1);								\
	if (lpbiInput->biHeight > OutputHeight) {										\
		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) {						\
			LumaIters += 4;															\
		}																			\
		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1;						\
		width_adj *= lpbiInput->biBitCount;											\
		width_adj >>= 3;															\
		aspect = LumaIters;															\
		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1;			\
		stretch = 1;																\
		mark = 11;																	\
	} else {																		\
		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF;								\
		width_diff = widthx16 - OutputWidth;										\
		byte_ypitch_adj -= width_diff;												\
		word_ypitch_adj = byte_ypitch_adj >> 2;										\
		byte_uvpitch_adj -= (width_diff >> 1);										\
		word_uvpitch_adj = byte_uvpitch_adj >> 2;									\
		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF;								\
		height_diff = heightx16 - OutputHeight;										\
	}																				\
	BackTwoLines = -((lpbiInput->biWidth + OutputWidth) >> 2);						\
	BackTwoLines *= lpbiInput->biBitCount;											\
	BackTwoLines >>= 3;																\
	pnext =	(U32 *)(lpInput +														\
				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3) *				\
					((OutputHeight - aspect - 1) + height_adj)) +					\
				width_adj);

#define C_WIDTH_FILL																\
	if (width_diff) {																\
		tm = (*(YPlane-1)) << 24;													\
		tm |= (tm>>8) | (tm>>16) | (tm>>24);										\
		*(U32 *)YPlane = tm;														\
		if ((width_diff-4) > 0) {													\
			*(U32 *)(YPlane + 4) = tm;												\
		}																			\
		if ((width_diff-8) > 0) {													\
			*(U32 *)(YPlane + 8) = tm;												\
		}																			\
		YPlane += width_diff;														\
		if (0 == (k&1)) {															\
			t8u = *(UPlane-1);														\
			t8v = *(VPlane-1);														\
			*UPlane++ = t8u;														\
			*UPlane++ = t8u;														\
			*VPlane++ = t8v;														\
			*VPlane++ = t8v;														\
			if ((width_diff-4) > 0) {												\
				*UPlane++ = t8u;													\
				*UPlane++ = t8u;													\
				*VPlane++ = t8v;													\
				*VPlane++ = t8v;													\
			}																		\
			if ((width_diff-8) > 0) {												\
				*UPlane++ = t8u;													\
				*UPlane++ = t8u;													\
				*VPlane++ = t8v;													\
				*VPlane++ = t8v;													\
			}																		\
		}																			\
	}

#define C_HEIGHT_FILL																\
	if (height_diff) {																\
		pyprev =  (U32 *)(YPlane - pitch);											\
		pyspace = (U32 *)YPlane;													\
		for (j = height_diff; j > 0; j--) {											\
			for (i = widthx16; i>0; i -=4) {										\
				*pyspace++ = *pyprev++;												\
			}																		\
			pyspace += word_ypitch_adj;												\
			pyprev  += word_ypitch_adj;												\
		}																			\
		puvprev =  (U32 *)(UPlane - pitch);											\
		puvspace = (U32 *)UPlane;													\
		for (j = height_diff; j > 0; j -= 2) {										\
			for (i = widthx16; i>0; i -= 8) {										\
				*puvspace++ = *puvprev++;											\
			}																		\
			puvspace += word_uvpitch_adj;											\
			puvprev  += word_uvpitch_adj;											\
		}																			\
		puvprev =  (U32 *)(VPlane - pitch);											\
		puvspace = (U32 *)VPlane;													\
		for (j = height_diff; j > 0; j -= 2) {										\
			for (i = widthx16; i>0; i -= 8) {										\
				*puvspace++ = *puvprev++;											\
			}																		\
			puvspace += word_uvpitch_adj;											\
			puvprev  += word_uvpitch_adj;											\
		}																			\
	}

struct YUV {
  int YU;
  int V;
};

struct YUVQUAD {
	U8 Yval;
	U8 dummy;
	union {
		struct {
			U8 Uval;
			U8 Vval;
		};
		U16 UVval;
	};
};

extern struct YUV RYUV[];
extern struct YUV GYUV[];
extern struct YUV BYUV[];
extern struct YUVQUAD YUVPalette[];

extern void Compute_YUVPalette(LPBITMAPINFOHEADER lpbiInput);

#ifndef USE_BILINEAR_MSH26X
extern void C_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);
#endif

extern void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

#endif // !_H263P_E3PCOLOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb8.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_CLUT8toYUV12()
 * 	
 *  Convert from CLUT8 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0 // { 0

void C_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	U32 tm1, tm2;
	C_RGB_COLOR_CONVERT_INIT

	// The following assignment is here simply to avoid a warning.
	t = t;

	// The palette may change with a new frame. Since we don't know when the palette
	// changes, we have to be conservative and compute it for each frame. However, this
	// should still be quicker than computing Y, U, and V for each pixel.

	Compute_YUVPalette(lpbiInput);

	for (j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = OutputWidth; (i & ~0x7); i-=8, YPlane+=8, pnext+=2) {
				tm1 = *pnext;
				*(U32 *)YPlane =
					YUVPalette[tm1&0xFF].Yval                 |
					((YUVPalette[(tm1>>8)&0xFF].Yval) << 8)   |
					((YUVPalette[(tm1>>16)&0xFF].Yval) << 16) |
					((YUVPalette[(tm1>>24)].Yval) << 24);
				tm2 = *(pnext+1);
				*(U32 *)(YPlane+4) =
					YUVPalette[tm2&0xFF].Yval                 |
					((YUVPalette[(tm2>>8)&0xFF].Yval) << 8)   |
					((YUVPalette[(tm2>>16)&0xFF].Yval) << 16) |
					((YUVPalette[(tm2>>24)].Yval) << 24);
				if (0 == (k&1)) {
					*(U32 *)UPlane =
						YUVPalette[tm1&0xFF].Uval                 |
						((YUVPalette[(tm1>>16)&0xFF].Uval) << 8)  |
						((YUVPalette[tm2&0xFF].Uval) << 16)       |
						((YUVPalette[(tm2>>16)&0xFF].Uval) << 24);
					*(U32 *)VPlane =
						YUVPalette[tm1&0xFF].Vval                 |
						((YUVPalette[(tm1>>16)&0xFF].Vval) << 8)  |
						((YUVPalette[tm2&0xFF].Vval) << 16)       |
						((YUVPalette[(tm2>>16)&0xFF].Vval) << 24);
					UPlane +=4; VPlane += 4;
				}
			}
			if (i & 0x4) {
				tm = *pnext++;
				*(U32 *)YPlane =
					YUVPalette[tm&0xFF].Yval                 |
					((YUVPalette[(tm>>8)&0xFF].Yval) << 8)   |
					((YUVPalette[(tm>>16)&0xFF].Yval) << 16) |
					((YUVPalette[(tm>>24)].Yval) << 24);
				YPlane += 4;
				if (0 == (k&1)) {
					*(U16 *)UPlane =
						YUVPalette[tm&0xFF].Uval                 |
						((YUVPalette[(tm>>16)&0xFF].Uval) << 8);
					*(U16 *)VPlane =
						YUVPalette[tm&0xFF].Vval                 |
						((YUVPalette[(tm>>16)&0xFF].Vval) << 8);
					UPlane += 2; VPlane += 2;
				}
			}
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUT8toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// Compute_YUVPalette(lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	push	eax
	call	Compute_YUVPalette
	pop		eax

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		ebp, [esp + OUTPUT_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm = *pnext
// *(U32 *)YPlane =
//  YUVPalette[tm&0xFF].Yval                 |
//  ((YUVPalette[(tm>>8)&0xFF].Yval) << 8)   |
//  ((YUVPalette[(tm>>16)&0xFF].Yval) << 16) |
//  ((YUVPalette[(tm>>24)].Yval) << 24)
	mov		eax, [esi]
	 nop
	mov		ebx, eax
	 mov	ecx, eax
	shr		ebx, 8
	 mov	edx, eax
	shr		ecx, 16
	 and	eax, 0xFF
	shr		edx, 24
	 and	ebx, 0xFF
	and		ecx, 0xFF
	 and	edx, 0xFF
	mov		al, [YUVPalette+eax*4].Yval
	 mov	bl, [YUVPalette+ebx*4].Yval
	shl		ebx, 8
	 mov	cl, [YUVPalette+ecx*4].Yval
	shl		ecx, 16
	 mov	dl, [YUVPalette+edx*4].Yval
	shl		edx, 24
	 or		eax, ebx
	or		eax, ecx
	 mov	ebx, [esp + LOOP_K]
	or		eax, edx
	 and	ebx, 1
	mov		[edi], eax
	 jnz	Lno_luma
// tm = *pnext
// *(U32 *)UPlane =
//  YUVPalette[tm&0xFF].Uval                 |
//	((YUVPalette[(tm>>16)&0xFF].Uval) << 8)
// *(U32 *)VPlane =
//  YUVPalette[tm&0xFF].Vval                 |
//  ((YUVPalette[(tm>>16)&0xFF].Vval) << 8)
// UPlane +=2
// VPlane += 2
	mov		eax, [esi]
	 nop
	mov		ebx, eax
	 and	eax, 0xFF
	shr		ebx, 16
	 mov	ecx, [esp + UPLANE]
	mov		ax, [YUVPalette+eax*4].UVval
	 and	ebx, 0xFF
	mov		edx, [esp + VPLANE]
	 add	ecx, 2
	mov		bx, [YUVPalette+ebx*4].UVval
	 add	edx, 2
	mov		[ecx - 2], al
	 mov	[esp + UPLANE], ecx
	mov		[edx - 2], ah
	 mov	[esp + VPLANE], edx
	mov		[ecx - 1], bl
	 mov	[edx - 1], bh

Lno_luma:
// pnext++
// YPlane += 4
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebp, 4
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb4.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_CLUT4toYUV12()
 * 	
 *  Convert from CLUT4 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0 // { 0

void C_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	U8  *p8next;
	U8  tm1, tm2, tm3, tm4;

	C_RGB_COLOR_CONVERT_INIT

	// The following assignment is here simply to avoid a warning message.
	t = t;

	// The palette may change with a new frame. Since we don't know when the palette
	// changes, we have to be conservative and compute it for each frame. However, this
	// should still be quicker than computing Y, U, and V for each pixel.

	Compute_YUVPalette(lpbiInput);

	for (j = 0, p8next = (U8 *)pnext; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = OutputWidth; (i & ~0x7); i-=8, YPlane+=8, p8next+=4) {
				tm1 = *p8next;
				tm2 = *(p8next+1);
				*(U32 *)YPlane =
					YUVPalette[(tm1>>4)&0xF].Yval            |
					((YUVPalette[tm1&0xF].Yval) << 8)        |
					((YUVPalette[(tm2>>4)&0xF].Yval) << 16)  |
					((YUVPalette[tm2&0xF].Yval) << 24);
				tm3 = *(p8next+2);
				tm4 = *(p8next+3);
				*(U32 *)(YPlane+4) =
					YUVPalette[(tm3>>4)&0xF].Yval            |
					((YUVPalette[tm3&0xF].Yval) << 8)        |
					((YUVPalette[(tm4>>4)&0xF].Yval) << 16)  |
					((YUVPalette[tm4&0xF].Yval) << 24);
				if (0 == (k&1)) {
					*(U32 *)UPlane =
						YUVPalette[(tm1>>4)&0xF].Uval            |
						((YUVPalette[(tm2>>4)&0xF].Uval) << 8)  |
						((YUVPalette[(tm3>>4)&0xF].Uval) << 16) |
						((YUVPalette[(tm4>>4)&0xF].Uval) << 24);
					*(U32 *)VPlane =
						YUVPalette[(tm1>>4)&0xF].Vval            |
						((YUVPalette[(tm2>>4)&0xF].Vval) << 8)  |
						((YUVPalette[(tm3>>4)&0xF].Vval) << 16) |
						((YUVPalette[(tm4>>4)&0xF].Vval) << 24);
					UPlane +=4; VPlane += 4;
				}
			}
			if (i & 0x4) {
				tm1 = *p8next++;
				tm2 = *p8next++;
				*(U32 *)YPlane =
					YUVPalette[(tm1>>4)&0xF].Yval            |
					((YUVPalette[tm1&0xF].Yval) << 8)        |
					((YUVPalette[(tm2>>4)&0xF].Yval) << 16)  |
					((YUVPalette[tm2&0xF].Yval) << 24);
				YPlane += 4;
				if (0 == (k&1)) {
					*(U16 *)UPlane =
						YUVPalette[(tm1>>4)&0xF].Uval           |
						((YUVPalette[(tm2>>4)&0xF].Uval) << 8);
					*(U16 *)VPlane =
						YUVPalette[(tm1>>4)&0xF].Vval           |
						((YUVPalette[(tm2>>4)&0xF].Vval) << 8);
					UPlane += 2; VPlane += 2;
				}
			}
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			p8next += (BackTwoLines << 2);
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		}
		C_HEIGHT_FILL
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}

	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUT4toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// Compute_YUVPalette(lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	push	eax
	call	Compute_YUVPalette
	pop		eax

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		ebp, [esp + OUTPUT_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm1 = *p8next
// tm2 = *(p8next+1);
// *(U32 *)YPlane =
//  YUVPalette[(tm1>>4)&0xF].Yval            |
//  ((YUVPalette[tm1&0xF].Yval) << 8)        |
//  ((YUVPalette[(tm2>>4)&0xF].Yval) << 16)  |
//  ((YUVPalette[tm2&0xF].Yval) << 24)
	mov		ax, [esi]
	 nop
	mov		ebx, eax
	 mov	ecx, eax
	shr		ecx, 12
	 mov	edx, eax
	shr		eax, 4
	 and	ebx, 0xF
	shr		edx, 8
	 and	eax, 0xF
	and		ecx, 0xF
	 and	edx, 0xF
	mov		al, [YUVPalette+eax*4].Yval
	 mov	bl, [YUVPalette+ebx*4].Yval
	shl		ebx, 8
	 mov	cl, [YUVPalette+ecx*4].Yval
	shl		ecx, 16
	 mov	dl, [YUVPalette+edx*4].Yval
	shl		edx, 24
	 or		eax, ebx
	or		eax, ecx
	 mov	ebx, [esp + LOOP_K]
	or		eax, edx
	 and	ebx, 1
	mov		[edi], eax
	 jnz	Lno_luma
// tm1 = *p8next
// tm2 = *(p8next+1);
// *(U32 *)UPlane =
//  YUVPalette[(tm1>>4)&0xF].Uval            |
//  ((YUVPalette[(tm2>>4)&0xF].Uval) << 8)
// *(U32 *)VPlane =
//  YUVPalette[(tm1>>4)&0xF].Vval            |
//  ((YUVPalette[(tm2>>4)&0xF].Vval) << 8)
// UPlane += 2
// VPlane += 2
	mov		ax, [esi]
	 nop
	mov		ecx, eax
	 and	eax, 0xF0
	shr		eax, 4
	 mov	ebx, [esp + UPLANE]
	shr		ecx, 12
	 mov	ax, [YUVPalette+eax*4].UVval
	and		ecx, 0xF
	 mov	edx, [esp + VPLANE]
	add		ebx, 2
	 mov	cx, [YUVPalette+ecx*4].UVval
	add		edx, 2
	 mov	[ebx - 2], al
	mov		[esp + UPLANE], ebx
	 mov	[edx - 2], ah
	mov		[esp + VPLANE], edx
	 mov	[ebx - 1], cl
	mov		[edx - 1], ch
	 nop

Lno_luma:
// p8next += 2
// YPlane += 4
	lea		esi, [esi + 2]
	lea		edi, [edi + 4]
	sub		ebp, 4
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   gmlim  $
// $Date:   17 Apr 1997 16:55:12  $
// $Archive:   S:\h26x\src\enc\e3rtp.h_v  $
// $Header:   S:\h26x\src\enc\e3rtp.h_v   1.4   17 Apr 1997 16:55:12   gmlim  $
// $Log:   S:\h26x\src\enc\e3rtp.h_v  $
;// 
;//    Rev 1.4   17 Apr 1997 16:55:12   gmlim
;// Added H263RTP_GetMaxBsInfoStreamSize().
;// 
;//    Rev 1.3   05 Dec 1996 17:03:44   GMLIM
;// 
;// Changed the way RTP packetization was done to guarantee proper packet
;// size.
;// 
;//    Rev 1.2   16 Sep 1996 16:50:26   CZHU
;// changed RTP BS Init for smaller packet size
;// 
;//    Rev 1.1   29 Aug 1996 09:30:38   CZHU
;// 
;// Added a function checking intra-GOB
;// 
;//    Rev 1.0   22 Apr 1996 17:09:46   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.4   01 Mar 1996 16:36:30   DBRUCKS
;// 
;// add unPacketSize parameter to H263RTP_InitBsInfoStream
;// 
;//    Rev 1.3   23 Feb 1996 16:18:46   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:00:48   CZHU
;// ean up
;// Clean up
;// 
;//    Rev 1.1   14 Feb 1996 14:59:38   CZHU
;// Support both mode A and mode B payload modes.
;// 
;//    Rev 1.0   12 Feb 1996 17:04:46   CZHU
;// Initial revision.
;// 
;//    Rev 1.3   11 Dec 1995 14:53:24   CZHU
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H263_RTP_INC_
#define  _H263_RTP_INC_

extern  I32 H263RTP_InitBsInfoStream( LPCODINST,T_H263EncoderCatalog *);
extern void H263RTP_ResetBsInfoStream(T_H263EncoderCatalog *);
extern I32  H263RTP_UpdateBsInfo(T_H263EncoderCatalog *,T_MBlockActionStream *,U32,U32,U32,U8 *,U32);
extern  void H263RTP_TermBsInfoStream(T_H263EncoderCatalog * );
extern  U32 H263RTP_AttachBsInfoStream(T_H263EncoderCatalog * ,U8 *, U32);
extern  U32 H263RTPFindMVs (T_H263EncoderCatalog *, T_MBlockActionStream * , U32 ,U32, I8 [2]);

//Chad intra GOB
extern BOOL IsIntraCoded( T_H263EncoderCatalog *, U32);
extern U32 H263RTP_GetMaxBsInfoStreamSize(T_H263EncoderCatalog *EC);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\exbitsio.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbitsio.cpp
 *
 * Description:
 *		Routines to write fields to a bit stream buffer.
 *
 * Routines:						Prototypes in:
 *		BSWriteField					e3enc.h
 */

//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 15:32:50  $
// $Archive:   S:\h26x\src\enc\exbitsio.cpv  $
// $Header:   S:\h26x\src\enc\exbitsio.cpv   1.5   27 Dec 1995 15:32:50   RMCKENZX  $
// $Log:   S:\h26x\src\enc\exbitsio.cpv  $
// 
//    Rev 1.5   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
//    Rev 1.4   09 Nov 1995 14:11:22   AGUPTA2
// PB-frame+performance+structure enhancements.
// 
//    Rev 1.3   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.2   25 Aug 1995 11:54:06   TRGARDOS
// 
// Debugged PutBits routine.
// 
//    Rev 1.1   14 Aug 1995 11:35:18   TRGARDOS
// y
// Finished writing picture frame header
// 
//    Rev 1.0   11 Aug 1995 17:28:34   TRGARDOS
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

/*************************************************************************
 * BSWriteField
 *
 * Write a field value of a specified size of bits into the
 * bitstream at the specified byte and bit offset.
 *
 * It is assumed that the field value is right justified
 * in the parameter fieldval, and field len never exceeds
 * 25.
 *
 * Returns void
 */
void PutBits(
	unsigned int fieldval,
	unsigned int fieldlen,
	unsigned char **pbs,
	unsigned char *bitoffset
	)
{
  unsigned int wordval;

  // Shift field left so that the field starts at
  // the current bit offset in the dword.
  fieldval <<= (32 - fieldlen) - *bitoffset;

  // Read in next dword starting at current byte position.
  wordval = (**pbs << 24) + (*(*pbs+1) << 16) + (*(*pbs+2) << 8) + *(*pbs+3);

  // Bitwise or the two dwords.
  wordval |= fieldval;

  // Write word back into memory, big-endian.
  *(*pbs+3) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+2) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+1) = wordval & 0xff;
  wordval >>= 8;
  **pbs = wordval & 0xff;

  // update byte and bit counters.
  *pbs += (*bitoffset + fieldlen) >> 3;
  *bitoffset = (*bitoffset + fieldlen) % 8;

} // end of BSWriteField function.


/*************************************************************
 *  CopyBits
 *
 ************************************************************/
void CopyBits(
    U8        **pDestBS,
    U8         *pDestBSOffset,
    const U8   *pSrcBS,
    const U32   uSrcBitOffset,
    const U32   uBits
)
{
    U32       bitstocopy, bitsinbyte;
    const U8 *sptr;

    if (uBits == 0) goto done;

    bitstocopy = uBits;
    sptr = pSrcBS + (uSrcBitOffset >> 3);
    bitsinbyte = 8 - (uSrcBitOffset & 0x7);
    if (bitsinbyte <= bitstocopy)
    {
        PutBits((*sptr) & ((1 << bitsinbyte) - 1),
                bitsinbyte, pDestBS, pDestBSOffset);
        bitstocopy -= bitsinbyte;
        sptr++;
    }
    else
    {
        PutBits( (*sptr >> (8 - (uSrcBitOffset & 0x7) - bitstocopy))
                 & ((1 << bitstocopy) - 1),
                bitstocopy, pDestBS, pDestBSOffset);
        goto done;
    }
    while (bitstocopy >= 8)
    {
        PutBits(*sptr, 8, pDestBS, pDestBSOffset);
        bitstocopy -= 8;
        sptr++;
    }
    if (bitstocopy > 0)
    {
        PutBits((*sptr)>>(8-bitstocopy), bitstocopy, pDestBS, pDestBSOffset);
    }

done:
    return;
}  //  CopyBits function
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
//
// e3rtp.cpp
//
// Description:
//      This file is for RTP payload generation.  See EPS for details.
//
// Routines:
//      getRTPPacketSizeThreshold
//      H263RTP_InitBsInfoStream
//      H263RTP_ResetBsInfoStream
//      H263RTPFindMVs
//      H263RTP_UpdateBsInfo
//      H263RTP_TermBsInfoStream
//      H263RTP_AttachBsInfoStream
//      IsIntraCoded
//      H263RTP_GetMaxBsInfoStreamSize()
//
// -------------------------------------------------------------------------
//
// $Author:   gmlim  $
// $Date:   17 Apr 1997 16:54:02  $
// $Archive:   S:\h26x\src\enc\e3rtp.cpv  $
// $Header:   S:\h26x\src\enc\e3rtp.cpv   1.14   17 Apr 1997 16:54:02   gmlim  $
// $Log:   S:\h26x\src\enc\e3rtp.cpv  $
// 
//    Rev 1.14   17 Apr 1997 16:54:02   gmlim
// Added H263RTP_GetMaxBsInfoStreamSize().
// 
//    Rev 1.13   06 Mar 1997 16:06:26   gmlim
// Changed RTP to generate mode A packet at the beginning of a GOB.
// 
//    Rev 1.12   18 Feb 1997 15:33:06   CZHU
// Changed UpdateBSInfo() not to force packet at GOB all the time.
// 
//    Rev 1.11   07 Feb 1997 10:57:28   CZHU
// Added three entry in EC to remove static variable used in e3rtp.cpp
// 
//    Rev 1.10   24 Jan 1997 13:33:36   CZHU
// 
// Stop generating more packets when internal buffer is to overflow.
// 
//    Rev 1.9   11 Dec 1996 10:38:24   gmlim
// Removed unused pBsInfoStream from H263RTP_AttachBsInfoStream().
// 
//    Rev 1.8   05 Dec 1996 17:01:08   GMLIM
// Changed the way RTP packetization was done to guarantee proper packet
// size.  Created H263RTP_ResetBsInfoStream() and replaced two previous
// bitstream info update fucntions with H263RTP_UpdateBsInfo().
// 
//    Rev 1.7   06 Nov 1996 16:31:06   gmlim
// Removed H263ModeC def.s and did some cleanup.
// 
//    Rev 1.6   03 Nov 1996 18:44:42   gmlim
// Added support for mode c.
// 
//    Rev 1.5   24 Oct 1996 16:27:50   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.4   25 Sep 1996 10:55:28   CZHU
// Added checking null pointers at allocation and before use.
// 
//    Rev 1.3   16 Sep 1996 16:50:48   CZHU
// changed RTP BS Init for smaller packet size
// 
//    Rev 1.2   29 Aug 1996 09:31:00   CZHU
// Added a function checking intra-GOB
// 
//    Rev 1.1   28 Apr 1996 20:09:04   BECHOLS
// 
// Removed RTP_HEADER IFDEFs.
// 
//    Rev 1.0   22 Apr 1996 17:46:10   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:33:04   CZHU
// Moved packet loss sim to c3rtp.cpp
// 
//    Rev 1.6   29 Mar 1996 13:37:42   CZHU
// 
//    Rev 1.5   01 Mar 1996 16:37:08   DBRUCKS
// change to use 3/4ths of packet size as the threshold 
// change to make packet size a parameter
// 
//    Rev 1.4   23 Feb 1996 17:36:48   CZHU
// 
//    Rev 1.3   23 Feb 1996 16:18:28   CZHU
// integrate with build 29
// 
//    Rev 1.2   15 Feb 1996 12:00:42   CZHU
// Clean up
// 
//    Rev 1.1   14 Feb 1996 14:59:36   CZHU
// Support both mode A and mode B payload modes.
// 
//    Rev 1.0   12 Feb 1996 17:04:44   CZHU
// Initial revision.
// 
//    Rev 1.5   25 Jan 1996 16:14:34   CZHU
// name changes
// 
//    Rev 1.4   15 Dec 1995 13:06:46   CZHU
// 
//    Rev 1.3   11 Dec 1995 14:52:42   CZHU
// Added support for per MB packetization
// 
//    Rev 1.2   04 Dec 1995 16:50:26   CZHU
// 
//    Rev 1.1   01 Dec 1995 15:53:52   CZHU
// Included Init() and Term() functions.
// 
//    Rev 1.0   01 Dec 1995 15:31:02   CZHU
// Initial revision.
** *************************************************************************/

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
#endif

static U32 uBitOffset_currPacket;
static U8 *pBitStream_currPacket;
static U8 *pBitStream_lastPacket;

// ---------------------------------------------------------------------------
// getRTPPacketSizeThreshold()
// Helper function to calculate the threshold of packet size
// for given maximum packet size and data rate
// ---------------------------------------------------------------------------
 
static U32 getRTPPacketSizeThreshold(U32 uRequested)
{
    U32 uSize;
    // uSize = uRequested * 90 / 100;
    uSize = uRequested;
    ASSERT(uSize);
    return uSize;
}

// ---------------------------------------------------------------------------
// H263RTP_InitBsInfoStream()
// ---------------------------------------------------------------------------

I32 H263RTP_InitBsInfoStream(LPCODINST lpInst, T_H263EncoderCatalog *EC)
{
    U32 uBsInfoSize = getRTPBsInfoSize(lpInst);

	FX_ENTRY("H263RTP_InitBsInfoStream")

    if (EC->hBsInfoStream != NULL)
	{
        HeapFree(GetProcessHeap(), NULL, EC->pBaseBsInfoStream);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)EC->pBaseBsInfoStream);
#endif
	}

    EC->pBaseBsInfoStream = HeapAlloc(GetProcessHeap(), NULL, uBsInfoSize);

    if (EC->pBaseBsInfoStream == NULL)
    {
        lpInst->Configuration.bRTPHeader = FALSE;
        return FALSE;
    }

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "E3RTP: %7ld Ln %5ld\0", uBsInfoSize, __LINE__);
	AddName((unsigned int)EC->pBaseBsInfoStream, gsz1);
#endif

    EC->hBsInfoStream = (void *) uBsInfoSize;
    EC->uPacketSizeThreshold = getRTPPacketSizeThreshold(lpInst->Configuration.unPacketSize);

	DEBUGMSG(ZONE_INIT, ("%s: BsInfoStream  initialized\r\n", _fx_));
   return TRUE;
}

// ---------------------------------------------------------------------------
// H263RTP_ResetBsInfoStream()
// ---------------------------------------------------------------------------

void H263RTP_ResetBsInfoStream(T_H263EncoderCatalog *EC)
{
	FX_ENTRY("H263RTP_ResetBsInfoStream")

    EC->pBsInfoStream = EC->pBaseBsInfoStream;
    EC->uBase = 0;
    EC->uNumOfPackets = 0;

    uBitOffset_currPacket = 0;
    pBitStream_currPacket = EC->PictureHeader.PB ? EC->pU8_BitStrCopy :
                                                   EC->pU8_BitStream;
    pBitStream_lastPacket = pBitStream_currPacket;

	DEBUGMSG(ZONE_ENCODE_RTP, ("%s: BsInfoStream  reset\r\n", _fx_));
}

// ---------------------------------------------------------------------------
// H263RTPFindMVs()
// Find motion vector predictors for current MB and return in arraryMVs[]
// ---------------------------------------------------------------------------

U32 H263RTPFindMVs(
    T_H263EncoderCatalog * EC, 
    T_MBlockActionStream * pMBlockAction,
    U32 uMBA,
    U32 uGOBN,
    I8 arrayMVs[2]
)
{
    if (!uMBA)
    {
        arrayMVs[0] = 0;
        arrayMVs[1] = 0;
    }
    else // revisit for AP
    {
        arrayMVs[0] = pMBlockAction[-1].BlkY1.PHMV;
        arrayMVs[1] = pMBlockAction[-1].BlkY1.PVMV;
    }
    return TRUE;
 }

// ---------------------------------------------------------------------------
// H263RTP_UpdateBsInfo()
// This routine is called at the beginning of each MB to update the bitstream
// info buffer
// ---------------------------------------------------------------------------

I32 H263RTP_UpdateBsInfo(
    T_H263EncoderCatalog *EC,
    T_MBlockActionStream *pMBlockAction,
    U32 uQuant, 
    U32 uMBA,
	U32 uGOBN,
    U8 *pBitStream,
	U32 uBitOffset
)
{
    U32 uNewBytes;
    T_RTP_H263_BSINFO *pBsInfoStream;
    I8 arrayMVs[2];

	FX_ENTRY("H263RTP_UpdateBsInfo")

    if (EC->pBsInfoStream == NULL) return FALSE;

    if (uMBA)
    {
        if ((U32) (pBitStream - pBitStream_lastPacket) <
                                                    EC->uPacketSizeThreshold)
        {
            pBitStream_currPacket = pBitStream;
            uBitOffset_currPacket = uBitOffset;
            return TRUE;
        }

        pBsInfoStream           = (T_RTP_H263_BSINFO *) EC->pBsInfoStream;
        pBsInfoStream->u8Mode   = EC->PictureHeader.PB ? RTP_H263_MODE_C :
                                                         RTP_H263_MODE_B;
        pBsInfoStream->u8MBA    = (U8) uMBA;
        pBsInfoStream->u8Quant  = (U8) uQuant;
        pBsInfoStream->u8GOBN   = (U8) uGOBN;
        H263RTPFindMVs(EC, pMBlockAction, uMBA, uGOBN, arrayMVs);
        pBsInfoStream->i8HMV1   = arrayMVs[0];
        pBsInfoStream->i8VMV1   = arrayMVs[1];
    }
    else
    {
        pBsInfoStream           = (T_RTP_H263_BSINFO *) EC->pBsInfoStream;
        pBsInfoStream->u8Mode   = RTP_H263_MODE_A;
        pBsInfoStream->u8MBA    = 0;
        pBsInfoStream->u8Quant  = 0;
        pBsInfoStream->u8GOBN   = (U8) uGOBN;
        pBsInfoStream->i8HMV1   = 0;
        pBsInfoStream->i8VMV1   = 0;
    }

    uNewBytes = (U32) (pBitStream_currPacket - pBitStream_lastPacket);
    EC->uBase += uNewBytes;

    pBsInfoStream->uBitOffset   = uBitOffset_currPacket + (EC->uBase << 3);
    pBsInfoStream->i8HMV2       = 0;
    pBsInfoStream->i8VMV2       = 0;
    pBsInfoStream->uFlags       = 0;

	DEBUGMSG(ZONE_ENCODE_RTP, ("%s: Flag=%d,Mode=%d,GOB=%d,MB=%d,Quant=%d,BitOffset=%d,pBitStream=%lx,LastPacketSz=%d B\r\n", _fx_, pBsInfoStream->uFlags, pBsInfoStream->u8Mode, pBsInfoStream->u8GOBN, pBsInfoStream->u8MBA, pBsInfoStream->u8Quant, pBsInfoStream->uBitOffset, (U32) pBitStream_currPacket, uNewBytes));

    // update packet pointers
    pBitStream_lastPacket = pBitStream_currPacket;
    pBitStream_currPacket = pBitStream;
    uBitOffset_currPacket = uBitOffset;

    // create a new packet: update counter and pointer
    EC->uNumOfPackets ++;
    EC->pBsInfoStream = (void *) ++ pBsInfoStream;
    ASSERT((DWORD) EC->hBsInfoStream >
           (DWORD) EC->pBsInfoStream - (DWORD) EC->pBaseBsInfoStream);

    return TRUE;

} // H263RTP_UpdateBsInfo()

// ---------------------------------------------------------------------------
// H263RTP_TermBsInfoStream()
// ---------------------------------------------------------------------------

void H263RTP_TermBsInfoStream(T_H263EncoderCatalog * EC)
{
	FX_ENTRY("H263RTP_TermBsInfoStream")

	DEBUGMSG(ZONE_INIT, ("%s: BsInfoStream freed\r\n", _fx_));

	HeapFree(GetProcessHeap(), NULL, EC->pBaseBsInfoStream);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)EC->pBaseBsInfoStream);
#endif
	EC->hBsInfoStream= NULL;
	return;
}


// ---------------------------------------------------------------------------
// H263RTP_AttachBsInfoStream()
// ---------------------------------------------------------------------------

U32 H263RTP_AttachBsInfoStream(
    T_H263EncoderCatalog * EC,
    U8 *lpOutput,
    U32 uSize
)
{
    U32 uIncreasedSize;
    U8 *lpAligned;
    T_H263_RTP_BSINFO_TRAILER BsInfoTrailer;

    // build bsinfo for the last packets
    BsInfoTrailer.uVersion        = H263_RTP_PAYLOAD_VERSION;
    BsInfoTrailer.uFlags          = 0;
    BsInfoTrailer.uUniqueCode     = H263_RTP_BS_START_CODE;
    BsInfoTrailer.uCompressedSize = uSize;
    BsInfoTrailer.uNumOfPackets   = EC->uNumOfPackets;
    BsInfoTrailer.u8Src           = EC->FrameSz;
    BsInfoTrailer.u8TR            = EC->PictureHeader.TR;

    if (EC->PictureHeader.PicCodType == INTRAPIC)
        BsInfoTrailer.uFlags |= RTP_H26X_INTRA_CODED;

    if (EC->PictureHeader.PB == ON)
    {
        BsInfoTrailer.u8TRB   = EC->PictureHeader.TRB;
        BsInfoTrailer.u8DBQ   = EC->PictureHeader.DBQUANT;
        BsInfoTrailer.uFlags |= RTP_H263_PB;
    }
    else
    {
        BsInfoTrailer.u8TRB   = 0;
        BsInfoTrailer.u8DBQ   = 0;
    }

    if (EC->PictureHeader.AP == ON)
        BsInfoTrailer.uFlags |= RTP_H263_AP;

    if (EC->PictureHeader.SAC == ON)
        BsInfoTrailer.uFlags |= RTP_H263_SAC;

    // update size field for the last BsInfoTrailer
    uIncreasedSize = EC->uNumOfPackets * sizeof(T_RTP_H263_BSINFO);

    // copy extended BS info and trailer to the given output buffer
    lpAligned = (U8 *) ((U32) (lpOutput + uSize + 3) & 0xfffffffc);
    memcpy(lpAligned, EC->pBaseBsInfoStream, uIncreasedSize);
    memcpy(lpAligned + uIncreasedSize, &BsInfoTrailer,
                                       sizeof(T_H263_RTP_BSINFO_TRAILER));

    return(uIncreasedSize + sizeof(T_H263_RTP_BSINFO_TRAILER)
                          + (U32) (lpAligned - lpOutput - uSize));
}

// ---------------------------------------------------------------------------
// IsIntraCoded(EC, GOB)
// return TRUE if current GOB is intra coded.
// other wise FALSE;
// Chad for intra GOB
// ---------------------------------------------------------------------------

BOOL IsIntraCoded(T_H263EncoderCatalog * EC, U32 Gob)
{
    U32 uGobMax, uGobMin;

    if (EC->uNumberForcedIntraMBs)
    {
        // for those GOBs are forced intra
        uGobMax = EC->uNextIntraMB / EC->NumMBPerRow;
        uGobMin = uGobMax - EC->uNumberForcedIntraMBs / EC->NumMBPerRow;

        if (Gob >= uGobMin && Gob < uGobMax)
            return TRUE;
	}
	return FALSE;
}

// ---------------------------------------------------------------------------
//  H263RTP_GetMaxBsInfoStreamSize()
//  return max size of EBS with trailer + 3 allignment bytes - 4/16/97 Gim
// ---------------------------------------------------------------------------

U32 H263RTP_GetMaxBsInfoStreamSize(T_H263EncoderCatalog *EC)
{
    return (EC->uNumOfPackets * sizeof(T_RTP_H263_BSINFO) +
                                sizeof(T_H263_RTP_BSINFO_TRAILER) + 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3vlc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/***************************************************************************
 * $Header:   S:\h26x\src\enc\e3vlc.h_v   1.7   27 Dec 1995 15:32:58   RMCKENZX  $
 * $Log:   S:\h26x\src\enc\e3vlc.h_v  $
;// 
;//    Rev 1.7   27 Dec 1995 15:32:58   RMCKENZX
;// Added copyright notice
 ***************************************************************************/

#ifndef _E3VLC_H
#define _E3VLC_H

extern "C" U8 FLC_INTRADC[256];
extern "C" int VLC_TCOEF_TBL[64*12*2];
extern "C" int VLC_TCOEF_LAST_TBL[64*3*2];

/*
 * Define the TCOEF escape constant and field length.
 */
#define TCOEF_ESCAPE_FIELDLEN  7
#define TCOEF_ESCAPE_FIELDVAL  3

#define TCOEF_RUN_FIELDLEN  6
#define TCOEF_LEVEL_FIELDLEN  8

#endif _E3VLC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3stat.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
 ****************************************************************************
 * 
 *  e3stat.cpp
 *
 *  Description:
 *		This modules contains the encoder statistics routines
 *
 *	Routines:				    All routines declared in e3stat.h
 *		StatsFrameSize  	
 *		InitFrameSizeStats
 *		OutputFrameSizeStats
 *		
 *		StatsUsedQuant
 *		InitQuantStats
 *		OutputQuantStats
 *		
 *		InitPSNRStats
 *		OutputPSNRStats
 *		InitStats		
 *		IncrementPSNRCounter		
 *		ComputeYPSNR
 *		ComputeVPSNR
 *		ComputeUPSNR
 *
 *  Data:

// $Header:   R:\h26x\h26x\src\enc\e3stat.cpv   1.0   22 Apr 1996 17:46:22   BECHOLS  $
// $Log:   R:\h26x\h26x\src\enc\e3stat.cpv  $
// 
//    Rev 1.0   22 Apr 1996 17:46:22   BECHOLS
// Initial revision.
// 
//    Rev 1.1   08 Mar 1996 14:14:26   DBRUCKS
// add framesize stats and fixed PSNR to use energy instead of the signal
// 
//    Rev 1.0   01 Mar 1996 16:34:40   DBRUCKS
// Initial revision.
*/

#include "precomp.h"

#ifdef ENCODE_STATS


    #define MAX_FRAME_SIZE_INDEX	255
	static U32 uArrayFrameSize[MAX_FRAME_SIZE_INDEX+1];
	static U32 uArrayBitStreamSize[MAX_FRAME_SIZE_INDEX+1];
	static int iFrameSizeIndex = 0;

	static U32 uQuantCount[32];

	#define MAX_PSNR_INDEX	255
	static double dArrayYPSNR[MAX_PSNR_INDEX+1];
	static double dArrayVPSNR[MAX_PSNR_INDEX+1];
	static double dArrayUPSNR[MAX_PSNR_INDEX+1];
	static int iPSNRIndex = 0;

	static double ComputePSNR(U8 * pu8Input,
							  int iInputPitch,
							  U8 * pu8Output,
							  int iOutputPitch,
							  UN unWidth,
							  UN unHeight);

	 
	/************************************************************************
	 *
	 *  StatsFrameSize
	 *
	 *  Save the frame size information - with possbily different bitstream
	 *  and frame sizes.  
	 */
	extern void StatsFrameSize(U32 uBitStreamSize, U32 uFrameSize)
	{
		ASSERT(uFrameSize >= uBitStreamSize);

		if (iFrameSizeIndex <= MAX_FRAME_SIZE_INDEX)
		{
			uArrayBitStreamSize[iFrameSizeIndex] = uBitStreamSize;
			uArrayFrameSize[iFrameSizeIndex] = uFrameSize;
			iFrameSizeIndex++; /* can grow to one larger than MAX_FRAME_SIZE_INDEX */
		}
	} /* end StatsFrameSize() */

	/************************************************************************
	 *
	 *  InitFrameSizeStats
	 */
	extern void InitFrameSizeStats()
	{
		int i;

		for (i = 0; i <= MAX_FRAME_SIZE_INDEX ; i++)
		{
			uArrayFrameSize[i] = 0;
			uArrayBitStreamSize[i] = 0;
		}
		iFrameSizeIndex = 0;
	} /* end InitFrameSizeStats() */

	/************************************************************************
	 *
	 *  OutputFrameSizeStats
	 */
	extern void OutputFrameSizeStats(char * filename)
	{
		U32 uSumBitStream;
		U32 uSumFrame;
		FILE * fp;
		int i;

		FX_ENTRY("OutputFrameSizeStats")

		ASSERT(iFrameSizeIndex <= (MAX_FRAME_SIZE_INDEX+1));
		fp = fopen(filename, "a");
		if (fp == NULL)
		{
			ERRORMESSAGE(("%s: Error opening stats file\r\n", _fx_));
		}
		else
		{
			uSumBitStream = 0;
			uSumFrame = 0;
			for (i = 0; i < iFrameSizeIndex ; i++)
			{
				uSumFrame += uArrayFrameSize[i];
				uSumBitStream += uArrayBitStreamSize[i];
				if (uArrayFrameSize[i] != uArrayBitStreamSize[i])
				{
					fprintf(fp,	"Frame[%d] Sizes: Frame=%d BitStream=%d Other=%d\n",
						    i, (int) uArrayFrameSize[i], (int) uArrayBitStreamSize[i], 
						    (int) (uArrayFrameSize[i] - uArrayBitStreamSize[i]));
				}
				else
				{
					fprintf(fp,"Frame[%d] Size=%d\n", (int) i, (int) uArrayFrameSize[i]);
				}
			}
			if (iFrameSizeIndex > 0)
			{
				if (uSumFrame != uSumBitStream)
				{
					fprintf(fp,"Count = %ld Average Sizes: Frm=%f BS=%f Other=%f\n",
						    (long) iFrameSizeIndex, 
						    ((float)uSumFrame)/((float)iFrameSizeIndex), 
						    ((float)uSumBitStream)/((float)iFrameSizeIndex),
						    ((float)(uSumFrame - uSumBitStream))/((float)iFrameSizeIndex)); 
				}
				else
				{
					fprintf(fp,"Count = %ld Average Size=%f\n", (long) iFrameSizeIndex, 
						    ((float)uSumFrame)/((float)iFrameSizeIndex));
				}
			}
			else
			{
				fprintf(fp,"No frame size statistics available\n");
			}
			fclose(fp);
		}
	} /* end OutputFrameSizeStats() */

	/************************************************************************
	 *
	 *  InitQuantStats
	 */
	extern void InitQuantStats()
	{
		int i;
		for (i = 0 ; i < 32 ; i++)
		{
			uQuantCount[i] = 0;
		}
	} /* end InitQuantStats() */

	/************************************************************************
	 *
	 *  StatsUsedQuant
	 */
	extern void StatsUsedQuant(
		int iQuant)
	{
		ASSERT(iQuant >= 1 && iQuant <= 31);
	 	uQuantCount[iQuant]++;
	} /* end StatsUsedQuant() */

	/************************************************************************
	 *
	 *  OutputQuantStats
	 */
	extern void OutputQuantStats(char * filename)
	{
		U32 uCount;
		U32 uTotal;
		FILE * fp;
		int i;

		FX_ENTRY("OutputQuantStats")

		fp = fopen(filename, "a");
		if (fp == NULL)
		{
			ERRORMESSAGE(("%s: Error opening stats file\r\n", _fx_));
		}
		else
		{
			uCount = 0;
			uTotal = 0;
			for (i = 0; i < 32 ; i++)
			{
				if (uQuantCount[i] > 0)
				{
					uCount += uQuantCount[i];
					uTotal += (uQuantCount[i] * i);
					fprintf(fp,"Quant[%d] = %ld\n", 
						    (int)i, (long) uQuantCount[i]);
				}
			}
			if (uCount > 0)
			{
				fprintf(fp,"Count = %ld Average = %f\n",
				        (long) uCount, ((float)uTotal)/((float)uCount));
			}
			else
			{
				fprintf(fp,"No quantization statistics available\n");
			}
			fclose(fp);
		}
	} /* end OutputQuantStats() */

	/************************************************************************
	 *
	 *  InitPSNRStats - initialize the PSNR data structures
	 */
	extern void InitPSNRStats()
	{
		int i;
		for (i = 0; i <= MAX_PSNR_INDEX; i++)
		{
			dArrayYPSNR[i] = 0.0;
			dArrayVPSNR[i] = 0.0;
			dArrayUPSNR[i] = 0.0;
		}
		iPSNRIndex = 0;
	} /* end InitPSNRStats() */

	/************************************************************************
	 * 
	 *  OutputPSNRStats - output the PSNR data to the specified file
	 */
	extern void OutputPSNRStats(
	    char * filename)
	{
		int i;
		FILE * fp;
		double dYTotal;
		double dVTotal;
		double dUTotal;

		FX_ENTRY("OutputPSNRStats")

		ASSERT(iPSNRIndex <= (MAX_PSNR_INDEX+1));

		fp = fopen(filename, "a");
		if (fp == NULL)
		{
			ERRORMESSAGE(("%s: Unable to open PSNR output file\r\n", _fx_));
		}
		else
		{
			if (iPSNRIndex <= 0)
			{
				fprintf(fp,"No PSNR data available\n");
			}
			else
			{
				dYTotal = 0.0;
				dVTotal = 0.0;
				dUTotal = 0.0;
				for (i = 0; i < iPSNRIndex ; i++)
				{
					dYTotal += dArrayYPSNR[i];
					dVTotal += dArrayVPSNR[i];
					dUTotal += dArrayUPSNR[i];
					fprintf(fp, "YVU#%d = %f %f %f\n", (int)i,
							dArrayYPSNR[i],dArrayVPSNR[i],dArrayUPSNR[i]);
				}
				fprintf(fp, "Average = %f %f %f\n",
						dYTotal/((double)iPSNRIndex),
						dVTotal/((double)iPSNRIndex),
						dUTotal/((double)iPSNRIndex));
			}
			fclose(fp);
		}
	} /* end OutputPSNRStats */

	/********************************************************************
	 *
	 *  IncrementPSNRCounter()
	 */
	extern void IncrementPSNRCounter()
	{
	 	if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
	 		iPSNRIndex++;
		}
	} /* end IncrementPSNRCounter() */

	/************************************************************************
	 *
	 *  ComputeYPSNR - compute the Y PSNR Value
	 */
	extern void ComputeYPSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		double dPSNR;
		if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
			dPSNR = ComputePSNR(pu8Input,iInputPitch,
			                    pu8Output,iOutputPitch,
								unWidth,unHeight);
			dArrayYPSNR[iPSNRIndex] = dPSNR;
		}
	} /* end ComputeYPSNR() */

	/************************************************************************
	 *
	 *  ComputeVPSNR - compute the V PSNR Value
	 */
	extern void ComputeVPSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		double dPSNR;
		if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
			dPSNR = ComputePSNR(pu8Input,iInputPitch,
			                    pu8Output,iOutputPitch,
								unWidth,unHeight);
			dArrayVPSNR[iPSNRIndex] = dPSNR;
		}
	} /* end ComputeVPSNR() */

	/************************************************************************
	 *
	 *  ComputeUPSNR - compute the U PSNR Value
	 */
	extern void ComputeUPSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		double dPSNR;
		if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
			dPSNR = ComputePSNR(pu8Input,iInputPitch,
			                    pu8Output,iOutputPitch,
								unWidth,unHeight);
			dArrayUPSNR[iPSNRIndex] = dPSNR;
		}
	} /* end ComputeUPSNR() */

	/***************************** STATIC ROUTINES *************************/

	/************************************************************************
	 *
	 *  ComputePSNR - compute Peek Signal to Noise Ratio over this plane
	 *
	 *						   255*255
	 *	PSNR = 10log   ----------------------------
	 *              10 SUM((I-O)(I-O))/Wdith*Height
	 */
	static double ComputePSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		UN unW;
		UN unH;
		U32 uSum;
		double dMSE;
		double dPSNR;
		double dTemp;
		int iInput;
		int iOutput;
		int iDiff;
		int iSquareOfDiff;

		/* Obtain the sum of the square of the differences
		 */
		uSum = 0;
		for (unH = 0; unH < unHeight; unH++)
		{
			for (unW = 0; unW < unWidth; unW++)
			{
				iInput = (int)*pu8Input++;
				iOutput = (int)*pu8Output++;
				iDiff = iInput - iOutput;
				iSquareOfDiff = iDiff*iDiff;
				uSum += (U32) iSquareOfDiff;
			}
			pu8Input += (iInputPitch - (int)unWidth);
			pu8Output += (iOutputPitch - (int)unWidth);
		}

		/* Obtain the Mean Squared Error
		 */
		if (uSum == 0)
		{
			dMSE = 0.01; /* a non-zero value */
		}
		else
		{
			dMSE = ((double)uSum)/((double)(unWidth*unHeight));
		}

		/* Obtain PSNR
		 */
		dTemp = (255.0 * 255.0) / dMSE;
		dTemp = log10(dTemp);
		dPSNR = 10.0 * dTemp;

		return dPSNR;
	} /* end ComputePSNR() */

#endif /* ENCODE_STATS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3ycrcb.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

/***************************************************
 * H26X_YVU9toYUV12()
 *  Convert from YVU9 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 * uv_plane_common()
 *  Helper function to convert V and U plane information.
 *  Since the process is similar for both planes, the
 *  conversion code was included in this subroutine.
 *
 ***************************************************/	

#define READ_DWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned int *)(src))), ((val) &= 0xFEFEFEFE), ((val) >>= 1))

#define WRITE_DWORD(dest,val) ((*(unsigned int *)(dest)) = (val))

#define AVERAGE_DWORDS(out,in1,in2)  ((out) = ((((in1) + (in2)) & 0xFEFEFEFE) >> 1))

#define DUP_LOWER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = (((val) & 0x000000FF) |	(((val) << 8) & 0x0000FF00) | \
							  	(((val) << 8) & 0x00FF0000) | (((val) << 16) & 0xFF000000)))

#define DUP_UPPER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = ((((val) >> 16) & 0x000000FF) |	(((val) >> 8) & 0x0000FF00) | \
							  	(((val) >> 8) & 0x00FF0000) | ((val) & 0xFF000000)))

static void C_uv_plane_common(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *psrc,
	U8 *Plane,
	const int pitch) {

U8	*pprev;
U8	*pnext = psrc + (lpbiInput->biWidth >> 2);
U8	*pdest_copy = Plane;
U8	*pdest_avg = Plane + pitch;
U8	t, tb1, tb2;
U32	t1, t2;
int i, j, k;
int dest_pitch_adj;
int widthx4 = ((OutputWidth >> 2) + 0x3) & ~0x3;
int heightx4 = 0;
int width_diff = 0;
int height_diff = 0;
int stretch = 0;
int flag = 0;
int NextSrcLine = 0;
int ChromaIters = 1;
int mark = (OutputHeight >> 2);
int byte_uvpitch_adj = 0;

	if (lpbiInput->biHeight > OutputHeight) {
		for (ChromaIters = 0, i = OutputHeight; i > 0; i -= 48) {
			ChromaIters += 2;
		}
		NextSrcLine = (lpbiInput->biWidth - OutputWidth) >> 2;
		stretch = (NextSrcLine ? 1 : 0);
		mark = 6 - stretch;
		flag = stretch;
	} else {
		width_diff = widthx4 - (OutputWidth >> 2);
		byte_uvpitch_adj -= width_diff;
		heightx4 = ((lpbiInput->biHeight >> 2) + 0x3) & ~0x3;
		height_diff = (heightx4 - (lpbiInput->biHeight >> 2)) << 1;
	}
	dest_pitch_adj = pitch - (widthx4 << 1);

	for (j = ChromaIters; j > 0; j--) {
		for (k = mark + (flag & 1); k > 0; k--) {
			if (!stretch && (1 == j) && (1 == k)) {
				pnext = psrc;
			}
			for (i = (OutputWidth >> 1); (i & ~0x7); i-=8, psrc+=4, pnext+=4,
												pdest_copy+=8, pdest_avg+=8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				DUP_LOWER_TWO_BYTES(pdest_copy,t1);
				DUP_UPPER_TWO_BYTES((pdest_copy+4),t1);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			if (i & 0x4) {
				t = *psrc++ >> 1;
				*(U16*)pdest_copy = t | (t<<8);
				t = (t + (*pnext++ >> 1)) >> 1;
				*(U16*)pdest_avg = t | (t<<8);
				t = *psrc++ >> 1;
				*(U16*)(pdest_copy+2) = t | (t<<8);
				t = (t + (*pnext++ >> 1)) >> 1;
				*(U16*)(pdest_avg+2) = t | (t<<8);
				pdest_copy += 4; pdest_avg += 4;
			}
			if (i & 0x2) {
				t = *psrc++ >> 1;
				*(U16*)pdest_copy = t | (t<<8);
				t = (t + (*pnext++ >> 1)) >> 1;
				*(U16*)pdest_avg = t | (t<<8);
				pdest_copy += 2; pdest_avg += 2;
			}
			if (width_diff) {
				tb1 = *(pdest_copy-1);
				tb2 = *(pdest_avg-1);
				*pdest_copy++ = tb1; *pdest_copy++ = tb1;
				*pdest_avg++ = tb2;  *pdest_avg++ = tb2;
				if ((width_diff-1) > 0) {
					*pdest_copy++ = tb1; *pdest_copy++ = tb1;
					*pdest_avg++ = tb2;  *pdest_avg++ = tb2;
				}
				if ((width_diff-2) > 0) {
					*pdest_copy++ = tb1; *pdest_copy++ = tb1;
					*pdest_avg++ = tb2;  *pdest_avg++ = tb2;
				}
			}
			psrc += NextSrcLine;
			pnext += NextSrcLine;
			pdest_copy = pdest_avg + dest_pitch_adj;
			pdest_avg = pdest_copy + pitch;
		}
		if (height_diff) {
			pprev =  pdest_copy - pitch;
			for (j = height_diff; j > 0; j--) {
				for (i = widthx4; i>0; i--) {
					*pdest_copy++ = *pprev++;
					*pdest_copy++ = *pprev++;
				}
				pprev += dest_pitch_adj;
				pdest_copy += dest_pitch_adj;
			}
		}
		if (stretch) {
			psrc -= (lpbiInput->biWidth >> 2);
			pnext -= (lpbiInput->biWidth >> 2);
			pdest_avg = pdest_copy;
			for (i = OutputWidth >> 1; i > 0; i -= 8, psrc += 4, pnext += 4,
                                                              pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += NextSrcLine;
			pnext += NextSrcLine;
			pdest_copy = pdest_avg + dest_pitch_adj;
			pdest_avg = pdest_copy + pitch;
			flag++;
		}
	}
}

void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch) {

U32	*pnext, *plast, *pbn;
U32 *pyprev, *pyspace;
U8  *pvsrc, *pusrc;
int t;
int i, j, k;
int NextLine;
int widthx16;
int heightx16;
int width_diff = 0;
int height_diff = 0;
int width_adj = 0;
int height_adj = 0;
int stretch = 0;
int aspect = 0;
int word_ypitch_adj = 0;
int LumaIters = 1;
int mark = OutputHeight;
int byte_ypitch_adj = pitch - OutputWidth;

	if (lpbiInput->biHeight > OutputHeight) {
		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) {
			LumaIters += 4;
		}
		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1;
		aspect = LumaIters;
		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1;
		stretch = 1;
		mark = 11;
	} else {
		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF;
		width_diff = widthx16 - OutputWidth;
		byte_ypitch_adj -= width_diff;
		word_ypitch_adj = byte_ypitch_adj >> 2;
		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF;
		height_diff = heightx16 - OutputHeight;
	}
	NextLine = width_adj >> 1;
	pnext = (U32 *)(lpInput + (lpbiInput->biWidth * height_adj) + width_adj);

	for (j = LumaIters; j > 0; j--) {
		for (k = mark; k > 0; k--) {
			for (i = OutputWidth; (i & ~0xF); i-=16, YPlane+=16) {
				*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+8) = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+12) = (*pnext++ >> 1) & 0x7F7F7F7F;
			}
			if (i & 0x8) {
				*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
				YPlane += 8;
			}
			if (i & 0x4) {
				*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
				YPlane += 4;
			}
			if (width_diff) {
				t = (*(YPlane-1)) << 24;
				t |= (t>>8) | (t>>16) | (t>>24);
				*(U32 *)YPlane = t;
				if ((width_diff-4) > 0) {
					*(U32 *)(YPlane + 4) = t;
				}
				if ((width_diff-8) > 0) {
					*(U32 *)(YPlane + 8) = t;
				}
				YPlane += width_diff;
			}
			pnext += NextLine;
			YPlane += byte_ypitch_adj;
		}
		if (height_diff) {
			pyprev =  (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			for (j = height_diff; j > 0; j--) {
				for (i = widthx16; i>0; i -=4) {
					*pyspace++ = *pyprev++;
				}
				pyspace += word_ypitch_adj;
				pyprev  += word_ypitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth >> 2);
			pbn = pnext;
			for (i = OutputWidth; i > 0; i -= 4, YPlane += 4, plast++, pbn++) {
				*(U32 *)YPlane =
					( ((*plast & 0xFCFCFCFC) >> 2) +
				      ((*pbn & 0xFCFCFCFC) >> 2) );
			}
			YPlane += byte_ypitch_adj;
		}
	}

	pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight);
	pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight>>2));
	t = ((lpbiInput->biWidth>>2) * (height_adj>>2)) + (width_adj>>2);
	pvsrc += t;
	pusrc += t;
	C_uv_plane_common(lpbiInput,OutputWidth,OutputHeight,pusrc,UPlane,pitch);
	C_uv_plane_common(lpbiInput,OutputWidth,OutputHeight,pvsrc,VPlane,pitch);
}

/***************************************************
 * H26X_YUY2toYUV12()
 *  Convert from YUY2 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 ***************************************************/

#if 0 // { 0

void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch) {

	U8	*pline;

	C_RGB_COLOR_CONVERT_INIT

	// Since YUY2 is so much like RGB (inverted image), the macro used to initialize
	// RGB conversion is also used here. However, there are some local variables
	// declared in C_RGB_COLOR_CONVERT_INIT that are not used here. The following
	// assignment is here simply to avoid warnings.
	t = t;

	pline = (U8 *)pnext;

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {
			for (i = OutputWidth; i > 0; i-=4, pline+=8, YPlane+=4) {
				*(U32 *)YPlane =             (*pline>>1) | ((*(pline+ 2)<<7)&0x7F00) |
					        ((*(pline+ 4)<<15)&0x7F0000) | ((*(pline+ 6)<<23)&0x7F000000);
				if (0 == (k & 1)) {
					*(U16 *)UPlane =        (*(pline+ 1)>>1) | ((*(pline+ 5)<<7)&0x7F00);
					*(U16 *)VPlane =        (*(pline+ 3)>>1) | ((*(pline+ 7)<<7)&0x7F00);
					UPlane += 2; VPlane += 2;
				}
			}
			pnext = (U32 *)pline;
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			pline = (U8 *)pnext;
			YPlane += byte_ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
}

#endif // } 0

__declspec(naked)
void P5_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	sar		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	sar		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	sar		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	sar		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for (i = FrameWidth; i > 0; i -= 4, pnext += 8, YPlane += 4)
	mov		ebp, [esp + OUTPUT_WIDTH]
// The following jump is used to make sure the start of the loop begin in the U pipe.
	jmp		L6
// *(U32 *)YPlane =             (*pline>>1) | ((*(pline+ 2)<<7)&0x7F00) |
//   	       ((*(pline+ 4)<<15)&0x7F0000) | ((*(pline+ 6)<<23)&0x7F000000)
// Register usage:
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
	mov		al, [esi]
	 mov	cl, [esi+4]
	shr		eax, 1
	 mov	bl, [esi+2]
	shl		ecx, 15
	 mov	dl, [esi+6]
	shl		ebx, 7
	 and	ecx, 0x7F0000
	shl		edx, 23
	 and	ebx, 0x7F00
	and		edx, 0x7F000000
	 or		ebx, eax
	or		ebx, ecx
	 lea	edi, [edi+4]
	or		ebx, edx
	 lea	esi, [esi+8]
	mov		[edi-4], ebx
	 mov	ebx, [esp + LOOP_K]
// if (0 == (k & 1))
//  *(U16 *)UPlane = (*(pline+ 1)>>1) | ((*(pline+ 5)<<7)&0x7F00)
//	*(U16 *)VPlane = (*(pline+ 3)>>1) | ((*(pline+ 7)<<7)&0x7F00)
	test	ebx, 1
	 jnz	L7

	mov		ecx, [esp + UPLANE]
	 mov	edx, [esp + VPLANE]
	mov		al, [esi-7]
	 mov	bl, [esi-3]
	shr		eax, 1
	 and	ebx, 0xFE
	shl		ebx, 7
	 lea	edx, [edx+2]
	or		ebx, eax
	 mov	al, [esi-5]
	shr		eax, 1
	 mov	[ecx], bx
	mov		bl, [esi-1]
	 lea	ecx, [ecx+2]
	and		ebx, 0xFE
	 mov	[esp + UPLANE], ecx
	shl		ebx, 7
	 mov	[esp + VPLANE], edx
	or		ebx, eax
	 nop
	mov		[edx-2], bx
	 nop
L7:
	sub		ebp, 4
	 jnz	L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	sar		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	xor		eax, eax
	mov		ebx, [esp + LOOP_K]
	cmp		ebx, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

/***************************************************
 * H26X_YUV12toEncYUV12()
 *  Copy YUV12 data to encoder memory at the
 *  appropriate location. It is assumed that the input
 *  data is stored as rows of Y, followed by rows of U,
 *  then rows of V.
 *
 ***************************************************/

 void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch) {

	int i, j;
	U32 *pnext = (U32 *)lpInput;
	U32 *plast;
	U32 t;
	U16 t16;
	U8  *p8next;
	int byte_ypitch_adj;	
	int byte_uvpitch_adj;
	
	int yinput_height = lpbiInput->biHeight;
	int yinput_width = lpbiInput->biWidth;
	int yheight_diff = 0;
	int ywidth_diff = 0;
	int uvheight_diff = 0;
	int uvwidth_diff = 0;

	int uvinput_width = yinput_width >> 1;
	int uvinput_height = yinput_height >> 1;
	int uvoutput_width = OutputWidth >> 1;

	int widthx16 = (OutputWidth + 0xF) & ~0xF;
	int width_diff = widthx16 - OutputWidth;
	int heightx16  = (OutputHeight + 0xF) & ~0xF;
	int height_diff = heightx16 - OutputHeight;

	// This routine has to handle two cases:
	//  - arbitrary frame size (width and height may be any multiple of 4 up to CIF size).
	//  - backward compatibility with H263 (320x240 -> 352x288 still mode)
	// Note: Crop and stretch was not supported for YUV12 conversion in H263.
	if (width_diff) {
		byte_ypitch_adj = pitch - widthx16;
		byte_uvpitch_adj = pitch - (widthx16 >> 1);
	} else {
		byte_ypitch_adj = pitch - OutputWidth;	
		byte_uvpitch_adj = pitch - (OutputWidth >> 1);
		ywidth_diff = OutputWidth - yinput_width;
		yheight_diff = OutputHeight - yinput_height;
		uvwidth_diff = ywidth_diff >> 1;
		uvheight_diff = yheight_diff >> 1;
	}

	// Y Plane conversion.
	for (j = yinput_height; j > 0; j--, YPlane += byte_ypitch_adj) {
		for (i = yinput_width; (i & ~0xF); i-=16, YPlane+=16) {
			*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+8) = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+12) = (*pnext++ >> 1) & 0x7F7F7F7F;
		}
		if (i & 0x8) {
			*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
			YPlane += 8;
		}
		if (i & 0x4) {
			*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
			YPlane += 4;
		}
		// The next two cases are mutually exclusive. If there is a width_diff,
		// then there is no ywidth_diff. If there is a ywidth_diff, then there
		// is no width_diff. Both width_diff and ywidth_diff may be zero.
		if (width_diff) {
			t = (*(YPlane-1)) << 24;
			t |= (t>>8) | (t>>16) | (t>>24);
			*(U32 *)YPlane = t;
			if ((width_diff-4) > 0) {
				*(U32 *)(YPlane + 4) = t;
			}
			if ((width_diff-8) > 0) {
				*(U32 *)(YPlane + 8) = t;
			}
			YPlane += width_diff;
		}
		for (i = ywidth_diff; i > 0; i -= 4) {
			*(U32 *)YPlane = 0; YPlane += 4;
		}
	}
	// The next two cases are mutually exclusive. If there is a height_diff,
	// then there is no yheight_diff. If there is a yheight_diff, then there
	// is no height_diff. Both height_diff and yheight_diff may be zero.
	if (height_diff) {
		for (j = height_diff; j > 0; j-- ) {
			plast = (U32 *)(YPlane - pitch);
			for (i = widthx16; i > 0; i -= 4, YPlane += 4) {
				*(U32 *)YPlane = *plast++;
			}
			YPlane += byte_ypitch_adj;
		}
	}
	for (j = yheight_diff; j > 0; j--, YPlane += byte_ypitch_adj) {
		for (i = widthx16; i > 0; i -= 4) {
			*(U32 *)YPlane = 0; YPlane += 4;
		}
	}

	// U Plane conversion.
	p8next = (U8 *)pnext;
	for (j = uvinput_height; j > 0; j--, UPlane += byte_uvpitch_adj) {
		for (i = uvinput_width; (i & ~0x7); i-=8, UPlane+=8, p8next+=8) {
			*(U32 *)UPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			*(U32 *)(UPlane+4) = (*(U32 *)(p8next+4) >> 1) & 0x7F7F7F7F;
		}
		if (i & 0x4) {
			*(U32 *)UPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			UPlane += 4, p8next += 4;
		}
		if (i & 0x2) {
			*(U16 *)UPlane = (*(U16 *)p8next >> 1) & 0x7F7F;
			UPlane += 2, p8next += 2;
		}
		// The next two cases are mutually exclusive. If there is a width_diff,
		// then there is no uvwidth_diff. If there is a uvwidth_diff, then there
		// is no width_diff. Both width_diff and uvwidth_diff may be zero.
		if (width_diff) {
			t16 = (*(UPlane-1)) << 8;
			t16 |= (t16>>8); 
			*(U16*)UPlane = t16; UPlane += 2;
			if ((width_diff-4) > 0) {
				*(U16*)UPlane = t16; UPlane += 2;
			}
			if ((width_diff-8) > 0) {
				*(U16*)UPlane = t16; UPlane += 2;
			}
		}
		for (i = uvwidth_diff; i > 0; i -= 4) {
			*(U32 *)UPlane = 0x40404040; UPlane += 4;
		}
	}
	// The next two cases are mutually exclusive. If there is a height_diff,
	// then there is no uvheight_diff. If there is a uvheight_diff, then there
	// is no height_diff. Both height_diff and uvheight_diff may be zero.
	if (height_diff) {
		for (j = (height_diff >> 1); j > 0; j--, UPlane += byte_uvpitch_adj ) {
			plast = (U32 *)(UPlane - pitch);
			for (i = (widthx16 >> 1); i > 0; i -= 4, UPlane += 4) {
				*(U32 *)UPlane = *plast++;
			}
		}
	}
	for (j = uvheight_diff; j > 0; j--, UPlane += byte_uvpitch_adj) {
		for (i = uvoutput_width; i > 0; i -= 4) {
			*(U32 *)UPlane = 0x40404040; UPlane += 4;
		}
	}

	// V Plane conversion.
	for (j = uvinput_height; j > 0; j--, VPlane += byte_uvpitch_adj) {
		for (i = uvinput_width; (i & ~0x7); i-=8, VPlane+=8, p8next+=8) {
			*(U32 *)VPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			*(U32 *)(VPlane+4) = (*(U32 *)(p8next+4) >> 1) & 0x7F7F7F7F;
		}
		if (i & 0x4) {
			*(U32 *)VPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			VPlane += 4, p8next += 4;
		}
		if (i & 0x2) {
			*(U16 *)VPlane = (*(U16 *)p8next >> 1) & 0x7F7F;
			VPlane += 2, p8next += 2;
		}
		// The next two cases are mutually exclusive. If there is a width_diff,
		// then there is no uvwidth_diff. If there is a uvwidth_diff, then there
		// is no width_diff. Both width_diff and uvwidth_diff may be zero.
		if (width_diff) {
			t16 = (*(VPlane-1)) << 8;
			t16 |= (t16>>8); 
			*(U16*)VPlane = t16; VPlane += 2;
			if ((width_diff-4) > 0) {
				*(U16*)VPlane = t16; VPlane += 2;
			}
			if ((width_diff-8) > 0) {
				*(U16*)VPlane = t16; VPlane += 2;
			}
		}
		for (i = uvwidth_diff; i > 0; i -= 4) {
			*(U32 *)VPlane = 0x40404040; VPlane += 4;
		}
	}
	// The next two cases are mutually exclusive. If there is a height_diff,
	// then there is no uvheight_diff. If there is a uvheight_diff, then there
	// is no height_diff. Both height_diff and uvheight_diff may be zero.
	if (height_diff) {
		for (j = (height_diff >> 1); j > 0; j--, VPlane += byte_uvpitch_adj ) {
			plast = (U32 *)(VPlane - pitch);
			for (i = (widthx16 >> 1); i > 0; i -= 4, VPlane += 4) {
				*(U32 *)VPlane = *plast++;
			}
		}
	}
	for (j = uvheight_diff; j > 0; j--, VPlane += byte_uvpitch_adj) {
		for (i = uvoutput_width; i > 0; i -= 4) {
			*(U32 *)VPlane = 0x40404040; VPlane += 4;
		}
	}
}

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\e3stat.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  e3stat.h
 *
 *  Description:
 *		Interface to the encoder statistics functions
 *
 *		Activate with ENCODE_STATS
 */

/*
 * $Header:   R:\h26x\h26x\src\enc\e3stat.h_v   1.0   22 Apr 1996 17:10:10   BECHOLS  $
 * $Log:   R:\h26x\h26x\src\enc\e3stat.h_v  $
;// 
;//    Rev 1.0   22 Apr 1996 17:10:10   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.1   08 Mar 1996 14:13:36   DBRUCKS
;// add frame size stats for use with RTP headers
;// 
;//    Rev 1.0   01 Mar 1996 16:34:48   DBRUCKS
;// Initial revision.
 */

#ifndef __E3STAT_H__
#define __E3STAT_H__

	#ifdef ENCODE_STATS

		/* Frame Sizes
		 */
		extern void StatsFrameSize(U32 uBitStreamSize, U32 uFrameSize);
		extern void InitFrameSizeStats();
		extern void OutputFrameSizeStats(char * filename);

		/* Quantization
		 */
		extern void StatsUsedQuant(int iQuant);
		extern void InitQuantStats();
		extern void OutputQuantStats(char * filename);
 
 		/* PSNR
		 */
		extern void InitPSNRStats();
		extern void OutputPSNRStats(char * filename);
		extern void IncrementPSNRCounter();
		extern void ComputeYPSNR(U8 * pu8Input,
							  	 int iInputPitch,
							  	 U8 * pu8Output,
								 int iOutputPitch,
							     UN unWidth,
							     UN unHeight);
		extern void ComputeVPSNR(U8 * pu8Input,
							  	 int iInputPitch,
							  	 U8 * pu8Output,
								 int iOutputPitch,
							     UN unWidth,
							     UN unHeight);
		extern void ComputeUPSNR(U8 * pu8Input,
							  	 int iInputPitch,
							  	 U8 * pu8Output,
								 int iOutputPitch,
							     UN unWidth,
							     UN unHeight);
	
	#endif /* ENCODE_STATS */

#endif /* __E3STAT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\exbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
                                                                      //
////////////////////////////////////////////////////////////////////////////
//
// $Author:   mbodart  $
// $Date:   17 Mar 1997 08:22:08  $
// $Archive:   S:\h26x\src\enc\exbase.cpv  $
// $Header:   S:\h26x\src\enc\exbase.cpv   1.73   17 Mar 1997 08:22:08   mbodart  $
// $Log:   S:\h26x\src\enc\exbase.cpv  $
// 
//    Rev 1.73   17 Mar 1997 08:22:08   mbodart
// Minor fixes.
// 
//    Rev 1.72   11 Mar 1997 13:46:46   JMCVEIGH
// Allow input = 320x240 and output = 320x240 for YUV12. This is
// for snapshot mode.
// 
//    Rev 1.71   10 Mar 1997 17:34:34   MDUDA
// Put in a check for 9-bit YUV12 and adjusted the internal compress
// structure instead of the input bitmap header info.
// 
//    Rev 1.70   10 Mar 1997 10:41:20   MDUDA
// Treating inconsistent format/bitwidth as a debug warning. Changing
// bit count to match format.
// 
//    Rev 1.69   07 Mar 1997 16:00:32   JMCVEIGH
// Added checks for non-NULL lpInst before getting H263PlusState. 
// Two separate "suggestions" for image sizes if input size is not
// supported in GetFormat. 
// 
//    Rev 1.68   07 Mar 1997 11:55:44   JMCVEIGH
// Moved query in GetFormat to after we have filled out the output
// format. This is because some apps. will ask for the format and
// then use the returned data, regardless if there was an error.
// Silly apps!
// 
//    Rev 1.67   07 Mar 1997 09:53:08   mbodart
// Added a call to _clearfp() in the Compress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.66   06 Mar 1997 15:39:26   KLILLEVO
// 
// CompressQuery now checks for input/output formats regardless
// of configuration status. Also put in trace support for lparam1 and lparam2.
// 
//    Rev 1.65   22 Jan 1997 12:17:14   MDUDA
// 
// Put in more checking for H263+ option in CompressQuery
// and CompressBegin.
// 
//    Rev 1.64   22 Jan 1997 08:11:22   JMCVEIGH
// Backward compatibility with crop/stretch for 160x120 and 240x180
// in CompressGetFormat(). Do old way unless we have received the
// H263Plus custom message.
// 
//    Rev 1.63   13 Jan 1997 10:52:14   JMCVEIGH
// 
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.62   09 Jan 1997 13:50:50   MDUDA
// Removed some _CODEC_STATS stuff.
// 
//    Rev 1.61   06 Jan 1997 17:42:30   JMCVEIGH
// If H263Plus message is not sent, encoder only supports standard
// frame sizes (sub-QCIF, QCIF, or CIF along with special cases),
// as before.
// 
//    Rev 1.60   30 Dec 1996 19:57:04   MDUDA
// Making sure that input formats agree with the bit count field.
// 
//    Rev 1.59   20 Dec 1996 15:25:28   MDUDA
// Fixed problem where YUV12 was enabled for crop and stretch.
// This feature is only allowed for RGB, YVU9 and YUY2.
// 
//    Rev 1.58   16 Dec 1996 13:36:08   MDUDA
// 
// Modified Compress Instance info for input color convertors.
// 
//    Rev 1.57   11 Dec 1996 16:01:20   MBODART
// In Compress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.56   09 Dec 1996 17:59:36   JMCVEIGH
// Added support for arbitrary frame size support.
// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
// Normally, application will pass identical (arbitrary) frame
// sizes in lParam1 and lParam2 of CompressBegin(). If 
// cropping/stretching desired to convert to standard frame sizes,
// application should pass the desired output size in lParam2 and
// the input size in lParam1.
// 
//    Rev 1.55   09 Dec 1996 09:50:12   MDUDA
// 
// Allowing 240x180 and 160x120 (crop and stretch) for YUY2.
// Modified _CODEC_STATS stuff.
// 
//    Rev 1.54   07 Nov 1996 14:45:16   RHAZRA
// Added buffer size adjustment to H.261 CompressGetSize() function
// 
//    Rev 1.53   31 Oct 1996 22:33:32   BECHOLS
// Decided buffer arbitration must be done in cxq_main.cpp for RTP.
// 
//    Rev 1.52   31 Oct 1996 21:55:50   BECHOLS
// Added fudge factor for RTP waiting for Raj to decide what he wants to do.
// 
//    Rev 1.51   31 Oct 1996 10:05:46   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.50   18 Oct 1996 14:35:46   MDUDA
// 
// Separated CompressGetSize and CompressQuery for H261 and H263 cases.
// 
//    Rev 1.49   11 Oct 1996 16:05:16   MDUDA
// 
// Added initial _CODEC_STATS stuff.
// 
//    Rev 1.48   16 Sep 1996 16:50:52   CZHU
// Return larger size for GetCompressedSize when RTP is enabled.
// 
//    Rev 1.47   13 Aug 1996 10:36:46   MDUDA
// 
// Now allowing RGB4 input format.
// 
//    Rev 1.46   09 Aug 1996 09:43:30   MDUDA
// Now allowing RGB16 format on input. This is generated by the color Quick Ca
// 
//    Rev 1.45   02 Aug 1996 13:45:58   MDUDA
// 
// Went back to previous version that allows RGB8 and RGB24 in
// 240x180 and 160x120 frames.
// 
//    Rev 1.44   01 Aug 1996 11:54:58   BECHOLS
// Cut & Paste Error.
// 
//    Rev 1.43   01 Aug 1996 11:20:28   BECHOLS
// Fixed handling of RGB 24 bit stuff so that it doesn't allow sizes other
// than QCIF, SQCIF, or CIF.  I broke this earlier when I added the RGB 8
// bit support. ...
// 
//    Rev 1.42   22 Jul 1996 13:31:16   BECHOLS
// 
// Added code to allow a CLUT8 input providing that the input resolutions
// are either 240x180 or 160x120.
// 
//    Rev 1.41   11 Jul 1996 15:43:58   MDUDA
// Added support for YVU9 240 x 180 and 160 x 120 for H263 only.
// We now produce subQCIF for 160x120 and QCIF for 240x180.
// 
//    Rev 1.40   05 Jun 1996 10:57:54   AKASAI
// Added #ifndef H261 in CompressQuery to make sure that H.261 will
// only support FCIF and QCIF input image sizes.  All other input sizes
// should return ICERR_BADFORMAT.
// 
//    Rev 1.39   30 May 1996 17:02:34   RHAZRA
// Added SQCIF support for H.263 in CompressGetSize()
// 
//    Rev 1.38   06 May 1996 12:47:40   BECHOLS
// Changed the structure element to unBytesPerSecond.
// 
//    Rev 1.37   06 May 1996 00:09:44   BECHOLS
// Changed the handling of the CompressFramesInfo message to get DataRate
// from the configuration data if the configuration has the data, and
// we haven't received a CompressBegin message yet.
// 
//    Rev 1.36   23 Apr 1996 16:51:20   KLILLEVO
// moved paranthesis to fix format check in CompressQuery()
// 
//    Rev 1.35   18 Apr 1996 16:07:10   RHAZRA
// Fixed CompressQuery to keep compiler happy for the non-MICROSOFT version
// 
//    Rev 1.34   18 Apr 1996 15:57:46   BECHOLS
// RAJ- Changed the query logic to correctly filter the allowable resolutions
// for compression.
// 
//    Rev 1.33   12 Apr 1996 14:15:40   RHAZRA
// Added paranthesis in CompressGetSize() to make the ifdef case work
// 
//    Rev 1.32   12 Apr 1996 13:31:02   RHAZRA
// Added SQCIF support in CompressGetSize() with #ifdef SUPPORT_SQCIF;
// changed CompressGetSize() to return 0 if the input format is not
// supported.
// 
//    Rev 1.31   10 Apr 1996 16:53:08   RHAZRA
// Added a error return in CompressGetSize() to keep complier smiling...
// 
//    Rev 1.30   10 Apr 1996 16:39:56   RHAZRA
// Added a check for the 320x240 size in CompressGetSize() function;
// added a ifndef to disable certain sizes and compression formats.
// 
//    Rev 1.29   04 Apr 1996 13:35:00   RHAZRA
// Changed CompressGetSize() to return spec-compliant buffer sizes.
// 
//    Rev 1.28   03 Apr 1996 08:39:52   SCDAY
// Added H261 specific code to CompressGetSize to limit buffer size
// as defined in H261 spec
// 
//    Rev 1.27   21 Feb 1996 11:43:12   SCDAY
// cleaned up compiler build warning by changing conversion frlDataRate to (U3
// 
//    Rev 1.26   15 Feb 1996 16:03:36   RHAZRA
// 
// Added a check for NULL lpInst pointer in CompressGetFormat()
// 
//    Rev 1.25   02 Feb 1996 18:53:46   TRGARDOS
// Changed code to read frame rate from Compressor Instance
// instead of the hack from Quality field.
// 
//    Rev 1.24   26 Jan 1996 09:35:32   TRGARDOS
// Added #ifndef H261 for 160x120,320x240 support.
// 
//    Rev 1.23   04 Jan 1996 18:36:54   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.22   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
///////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef  YUV9FROMFILE
PAVIFILE paviFile;
PAVISTREAM paviStream; 
U8 huge * glpTmp;
HGLOBAL hgMem;
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns a format that 
;//                 we can deliver back to the caller.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressGetFormat(LPINST pi, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#else
DWORD PASCAL CompressGetFormat(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#endif
{
    DWORD dwQuery;
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;
#endif

	FX_ENTRY("CompressGetFormat")

	// lpInst == NULL is OK
	// this is what you get on ICOpen(...,ICMODE_QUERY)
#if 0
    if (lpInst == NULL) {
		ERRORMESSAGE(("%s: got a NULL lpInst pointer\r\n", _fx_));
       return ((DWORD) ICERR_ERROR);
    }
#endif

#ifdef USE_BILINEAR_MSH26X
    if(dwQuery = CompressQuery(pi, lParam1, NULL)) {
#else
    if(dwQuery = CompressQuery(lpInst, lParam1, NULL)) {
#endif
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
        return(dwQuery);
    }
    if(lParam2 == NULL) {
        // he just want me to return the output buffer size. 
        return ((DWORD)sizeof(BITMAPINFOHEADER));
    }

	// Check pointer
	if (!lParam1)
		return ICERR_ERROR;

    // give him back what he passed with our stuff in it 
	#ifndef WIN32
    (void)_fmemcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#else
	 (void)memcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#endif

    lParam2->biBitCount = 24;
#ifdef USE_BILINEAR_MSH26X
    lParam2->biCompression = pi->fccHandler;
#else
    lParam2->biCompression = FOURCC_H263;
#endif

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState);

	if (!bH263PlusState) {
		// For backward compatibility, make sure the crop and stretch cases are covered.
		if ( (lParam1->biCompression == FOURCC_YVU9) ||
			 (lParam1->biCompression == FOURCC_YUY2) ||
			 (lParam1->biCompression == FOURCC_UYVY) ||
			 (lParam1->biCompression == FOURCC_YUV12) ||
			 (lParam1->biCompression == FOURCC_IYUV) ||
			 (lParam1->biCompression == BI_RGB) )
		{
			if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
			{
				lParam2->biWidth        = 176;
				lParam2->biHeight       = 144;
			}
			if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
			{
				lParam2->biWidth        = 128;
				lParam2->biHeight       = 96;
			}
		}
	}
#else
	if ( (lParam1->biCompression == FOURCC_YVU9) ||
		 (lParam1->biCompression == FOURCC_YUY2) ||
		 (lParam1->biCompression == FOURCC_UYVY) ||
		 (lParam1->biCompression == FOURCC_YUV12) ||
		 (lParam1->biCompression == FOURCC_IYUV) ||
		 (lParam1->biCompression == BI_RGB) )
	{
		if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
			lParam2->biWidth        = 176;
			lParam2->biHeight       = 144;
		}
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
			lParam2->biWidth        = 128;
			lParam2->biHeight       = 96;
		}
	}
	else
	{
    	lParam2->biWidth        = MOD4(lParam1->biWidth);
    	lParam2->biHeight       = MOD4(lParam1->biHeight);
	}
#endif

    lParam2->biClrUsed      = 0;
    lParam2->biClrImportant = 0;
    lParam2->biPlanes       = 1;        
#ifdef USE_BILINEAR_MSH26X
    lParam2->biSizeImage    = CompressGetSize(pi, lParam1, lParam2);
#else
    lParam2->biSizeImage    = CompressGetSize(lpInst, lParam1, lParam2);
#endif
    return(ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns the maximum
;//                 size that a compressed buffer can be.  This size is
;//                 guaranteed in encoder design.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

	FX_ENTRY("CompressGetSize")

	if ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) {
		dwRet = 8192L;
	} else {
		if  ((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) {
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			ERRORMESSAGE(("%s: ICERR_BADIMAGESIZE\r\n", _fx_));
			dwRet = 0;
		}  
	}

#if 0
	// Adjust the buffer size for RTP. Note that this adjustment will be performed
	// only if the codec has been told previously to use RTP and the RTP-related
	// information has been initialized. Therefore, the current (11/7) AM interface
	// will not take advantage of this routine.

	if (dwRet && lpInst && lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += H261EstimateRTPOverhead(lpInst, lParam1);
	}
#endif

	return dwRet;
}
#else
/* H.263 case */
#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressGetSize(LPINST pi, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#else
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#endif
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;
#endif
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

	FX_ENTRY("CompressGetSize")

    if (lParam1 == NULL) {
		// We will use a size of zero to indicate an error for CompressGetSize
		ERRORMESSAGE(("%s: got a NULL lParam1 pointer\r\n", _fx_));
 	    dwRet = 0;
        return dwRet;
    }

#ifndef H263P
#ifdef USE_BILINEAR_MSH26X
	if (pi->fccHandler == FOURCC_H26X)
	{
		// H.263+
		U32 unPaddedWidth;
		U32 unPaddedHeight;
		U32 unSourceFormatSize;

		// Base buffer size on frame dimensions padded to multiples of 16
		if (lParam2 == NULL) 
		{
			// In case an old application passed in a NULL pointer in lParam2,
			// we use the input frame dimensions to calculate the format size
			unPaddedWidth = (lParam1->biWidth + 0xf) & ~0xf;
			unPaddedHeight = (lParam1->biHeight + 0xf) & ~0xf;
		} 
		else 
		{
			unPaddedWidth = (lParam2->biWidth + 0xf) & ~0xf;
			unPaddedHeight = (lParam2->biHeight + 0xf) & ~0xf;
		}

		unSourceFormatSize = unPaddedWidth * unPaddedHeight;

		// See Table 1/H.263, document LBC-96-358
		if (unSourceFormatSize < 25348)
			dwRet = 8192L;
		else if (unSourceFormatSize < 101380)
			dwRet = 32768L;
		else if (unSourceFormatSize < 405508)
			dwRet = 65536L;
		else 
			dwRet = 131072L;
	}
	else
	{
#endif
		if (((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
#ifdef USE_BILINEAR_MSH26X
			((lParam1->biWidth == 80) && (lParam1->biHeight == 64)) ||
#endif
			((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
			((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ||
			((lParam1->biWidth == 160) && (lParam1->biHeight == 120)))
		{
			dwRet = 8192L;
		}
		else if (((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ||
				((lParam1->biWidth == 320) && (lParam1->biHeight == 240)))
		{
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			ERRORMESSAGE(("%s: ICERR_BADIMAGESIZE\r\n", _fx_));
			dwRet = 0;
		}
#ifdef USE_BILINEAR_MSH26X
	}
#endif
#else
	// H.263+
	U32 unPaddedWidth;
	U32 unPaddedHeight;
	U32 unSourceFormatSize;

	// Base buffer size on frame dimensions padded to multiples of 16
	if (lParam2 == NULL) 
	{
		// In case an old application passed in a NULL pointer in lParam2,
		// we use the input frame dimensions to calculate the format size
		unPaddedWidth = (lParam1->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam1->biHeight + 0xf) & ~0xf;
	} 
	else 
	{
		unPaddedWidth = (lParam2->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam2->biHeight + 0xf) & ~0xf;
	}

	unSourceFormatSize = unPaddedWidth * unPaddedHeight;

	// See Table 1/H.263, document LBC-96-358
	if (unSourceFormatSize < 25348)
		dwRet = 8192L;
	else if (unSourceFormatSize < 101380)
		dwRet = 32768L;
	else if (unSourceFormatSize < 405508)
		dwRet = 65536L;
	else 
		dwRet = 131072L;
#endif

#if 0
	//adjust if RTP is enabled, based on information in Configuration
   	//Size calculated using DataRate, FrameRate in lpInst, 
	//and lpInst->Configuration.unPacketSize;
	//Chad, 9/12/96
 	if (dwRet && lpInst &&
		lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += getRTPBsInfoSize(lpInst);
	}
#endif

	return dwRet;
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
    // Check for good input format

	FX_ENTRY("CompressQuery")

    if(NULL == lParam1)                          
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
 		return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) )
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) && (lParam1->biBitCount != 24))
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if(!  ( ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  ))
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if( lParam1->biPlanes != 1 )
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
    }

    if(0 == lParam2)                            // Checking input only
		return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
    if( lParam2->biCompression != FOURCC_H263 )
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
        return ((DWORD)ICERR_BADFORMAT);
    }

    return(ICERR_OK);
}
#else
/* H.263 case */
#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressQuery(LPINST pi, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#else
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#endif
{
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;
#endif

	FX_ENTRY("CompressQuery")

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState); 
#endif

    // Check for good input format
    if(lParam1 == NULL)                          
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YVU9) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) &&
		(lParam1->biCompression != FOURCC_UYVY) &&
		(lParam1->biCompression != FOURCC_YUY2) )
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) &&
		(	(lParam1->biBitCount != 24) &&
#ifdef H263P
			(lParam1->biBitCount != 32) &&
#endif
			(lParam1->biBitCount != 16) &&
			(lParam1->biBitCount != 8) &&
			(lParam1->biBitCount != 4) ) )
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
	}

#ifndef H263P
#ifdef USE_BILINEAR_MSH26X
	if (pi->fccHandler == FOURCC_H26X)
	{
		if ((lParam1->biWidth & 0x3) || (lParam1->biHeight & 0x3) ||
			(lParam1->biWidth < 4)   || (lParam1->biWidth > 352) ||
			(lParam1->biHeight < 4)  || (lParam1->biHeight > 288))
		{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
	}
	else
	{
#endif
		if(!
		  ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
#ifdef USE_BILINEAR_MSH26X
    		((lParam1->biWidth == 80) && (lParam1->biHeight == 64)) ||
#endif
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  

#ifndef MICROSOFT
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) )
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) )
		  ||
		  ( ( (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV) )
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) )
#endif
		  ))
		{
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
#ifdef USE_BILINEAR_MSH26X
	}
#endif
#else
	if (((FOURCC_YVU9 == lParam1->biCompression) && (9 != lParam1->biBitCount)) ||
	    ((FOURCC_YUY2 == lParam1->biCompression) && (16 != lParam1->biBitCount)) ||
	    ((FOURCC_UYVY == lParam1->biCompression) && (16 != lParam1->biBitCount)) ||
		// The following check for 9-bit YUV12 is a hack to work around a VPhone 1.x bug.
	    ((FOURCC_YUV12 == lParam1->biCompression) &&
			!((12 == lParam1->biBitCount) || (9 == lParam1->biBitCount))) ||
	    ((FOURCC_IYUV == lParam1->biCompression) &&
			!((12 == lParam1->biBitCount) || (9 == lParam1->biBitCount)))) {
		ERRORMESSAGE(("%s: Incorrect bit width (ICERR_BADFORMAT)\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

	// The H263+ message indicates whether arbitrary frame
	// sizes are to be supported. If arbitrary frames are needed,
	// the H263+ message must be sent before the first call to
	// CompressQuery.

	if (bH263PlusState) {
		if ((lParam1->biWidth & 0x3) || (lParam1->biHeight & 0x3) ||
			(lParam1->biWidth < 4)   || (lParam1->biWidth > 352) ||
			(lParam1->biHeight < 4)  || (lParam1->biHeight > 288)) {
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
		  ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) ) ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ) ||
		  ( ( (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV) )
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) ) ))
		{
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

    if( lParam1->biPlanes != 1 )
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
    }

    if(lParam2 == 0)                            // Checking input only
        return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
#ifdef USE_BILINEAR_MSH26X
    if( (lParam2->biCompression != FOURCC_H263) && (lParam2->biCompression != FOURCC_H26X) )
#else
    if( lParam2->biCompression != FOURCC_H263 )
#endif
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
        return ((DWORD)ICERR_BADFORMAT);
    }

#if defined(H263P)
	if (bH263PlusState) {
		if ((lParam1->biWidth != lParam2->biWidth) ||
			(lParam1->biHeight != lParam2->biHeight)) {
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return ((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
			(( ( ((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
			     ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
			     ((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ) &&
			   (lParam1->biWidth == lParam2->biWidth) && (lParam1->biHeight == lParam2->biHeight) ) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == FOURCC_UYVY) ||
			   (lParam1->biCompression == FOURCC_YUV12) ||
			   (lParam1->biCompression == FOURCC_IYUV) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) &&
	  			((lParam2->biWidth == 128) && (lParam2->biHeight == 96)))) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == FOURCC_UYVY) ||
			   (lParam1->biCompression == FOURCC_YUV12) ||
			   (lParam1->biCompression == FOURCC_IYUV) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) &&
	  			((lParam2->biWidth == 176) && (lParam2->biHeight == 144)))) ||
			 (((lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV)) &&
			   (((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) &&
	  			((lParam2->biWidth == 320) && (lParam2->biHeight == 240)))) ) )
		{
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return ((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

    return(ICERR_OK);
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressFramesInfo(LPCODINST lpCompInst, ICCOMPRESSFRAMES *lParam1, int lParam2)
{
	FX_ENTRY("CompressFramesInfo");

	// Check to see if we are given a nonzero pointer.
	if (lpCompInst == NULL)
	{
		ERRORMESSAGE(("%s: CompressFramesInfo called with NULL parameter - returning ICERR_BADFORMAT", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	// lParam2 should be the size of the structure.
	if (lParam2 != sizeof(ICCOMPRESSFRAMES))
	{
		ERRORMESSAGE(("%s: wrong size of ICOMPRESSFRAMES structure", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	if (!lParam1 || (lParam1->dwScale == 0))
	{
		ERRORMESSAGE(("%s: dwScale is zero", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	lpCompInst->FrameRate = (float)lParam1->dwRate / (float)lParam1->dwScale;

	lpCompInst->DataRate  = (U32)lParam1->lDataRate;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Setting frame rate at %ld.%ld fps and bitrate at %ld bps", _fx_, (DWORD)lpCompInst->FrameRate, (DWORD)((lpCompInst->FrameRate - (float)(DWORD)lpCompInst->FrameRate) * 100.0f), lpCompInst->DataRate * 8UL));

	return ((DWORD)ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       BOOL bIsOkRes(LPCODINST);
;//
;// Description:    This function checks whether the desired height and
;//                 width are possible.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
BOOL bIsOkRes(LPCODINST lpCompInst)
{
    BOOL    bRet;

	// Check for NULL pointer
	if (lpCompInst == NULL)
		return 0;

    bRet = lpCompInst->xres <= 352
        && lpCompInst->yres <= 288
        && lpCompInst->xres >= 4
        && lpCompInst->yres >= 4
        && (lpCompInst->xres & ~3) == lpCompInst->xres
        && (lpCompInst->yres & ~3) == lpCompInst->yres;

    return(bRet);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressBegin(
#ifdef USE_BILINEAR_MSH26X
		LPINST pi,
#else
		LPCODINST lpCompInst,
#endif
		LPBITMAPINFOHEADER lParam1,
		LPBITMAPINFOHEADER lParam2
	)
{
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpCompInst = (LPCODINST)pi->CompPtr;
#endif
    DWORD dwQuery;
	LRESULT retval;

#if defined(H263P)
	BOOL bH263PlusState = FALSE;
	if (lpCompInst)
		CustomGetH263PlusState(lpCompInst, (DWORD FAR *)&bH263PlusState);
#endif

	// Check input and output format.
#ifdef USE_BILINEAR_MSH26X
    if( (dwQuery = CompressQuery(pi, lParam1, lParam2)) != ICERR_OK)
#else
    if( (dwQuery = CompressQuery(lpCompInst, lParam1, lParam2)) != ICERR_OK)
#endif
        return(dwQuery);

	// Check instance pointer
	if (!lpCompInst || !lParam1)
		return ICERR_ERROR;

#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
	lpCompInst->InputCompression = lParam1->biCompression;
	lpCompInst->InputBitWidth = lParam1->biBitCount;
	if (((FOURCC_YUV12 == lParam1->biCompression) || (FOURCC_IYUV == lParam1->biCompression)) && (9 == lParam1->biBitCount)) {
		lpCompInst->InputBitWidth = 12;
	}
#endif

#if defined(H263P)
	if ( lParam2 && bH263PlusState)
	{
		// This is the "new" style for indicating if the input should 
		// be cropped/stretched to a standard frame size.
		// Old applications may pass in NULL or junk for lparam2.
		// New applications should pass a valid lParam2 that indicates
		// the desired output frame size. Also, the H263Plus flag must
		// be set in the configuration structure before calling CompressBegin()
	    lpCompInst->xres    = (WORD)lParam2->biWidth;
		lpCompInst->yres    = (WORD)lParam2->biHeight;

	} else	
#endif // H263P
	{
		lpCompInst->xres    = (WORD)lParam1->biWidth;
		lpCompInst->yres    = (WORD)lParam1->biHeight;

		lpCompInst->Is160x120 = FALSE;
		lpCompInst->Is240x180 = FALSE;
		lpCompInst->Is320x240 = FALSE;
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
		  lpCompInst->xres    = 128;
		  lpCompInst->yres    = 96;
		  lpCompInst->Is160x120 = TRUE;
		}
		else if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
		  lpCompInst->xres    = 176;
		  lpCompInst->yres    = 144;
		  lpCompInst->Is240x180 = TRUE;
		}
		else if ( (lParam1->biWidth == 320) && (lParam1->biHeight == 240) )
		{
		  lpCompInst->xres    = 352;
		  lpCompInst->yres    = 288;
		  lpCompInst->Is320x240 = TRUE;
		}
	}

    if(!bIsOkRes(lpCompInst))
        return((DWORD)ICERR_BADIMAGESIZE);

    // Set frame size.
    if (lpCompInst->xres == 128 && lpCompInst->yres == 96)
  	  lpCompInst->FrameSz = SQCIF;
    else if (lpCompInst->xres == 176 && lpCompInst->yres == 144)
      lpCompInst->FrameSz = QCIF;
    else if (lpCompInst->xres == 352 && lpCompInst->yres == 288)
      lpCompInst->FrameSz = CIF;
#ifdef USE_BILINEAR_MSH26X
    else if (pi->fccHandler == FOURCC_H26X)
      lpCompInst->FrameSz = fCIF;
#endif
#ifdef H263P
	else
	  lpCompInst->FrameSz = CUSTOM;
#else
    else	// unsupported frame size.
      return (DWORD)ICERR_BADIMAGESIZE;
#endif


    // Allocate and Initialize tables and memory that are specific to
    // this instance.
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
    retval = H263InitEncoderInstance(lParam1,lpCompInst);
#else
    retval = H263InitEncoderInstance(lpCompInst);
#endif

    return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressEnd(LPCODINST);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressEnd(LPCODINST lpInst)
{  
  LRESULT retval;

  retval = H263TermEncoderInstance(lpInst);
  
  return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL Compress(
#ifdef USE_BILINEAR_MSH26X
				LPINST pi,
#else
				LPCODINST lpInst,			// ptr to Compressor instance information.
#endif
				ICCOMPRESS FAR * lpCompInfo, // ptr to ICCOMPRESS structure.
				DWORD dOutbufSize			// size, in bytes, of the ICCOMPRESS structure.
			)
{
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;			// ptr to Compressor instance information.
#endif
    DWORD dwRet;

	FX_ENTRY("Compress")

	// Check to see if we are given a NULL pointer.
	if(lpInst == NULL || lpCompInfo == NULL)
	{
		ERRORMESSAGE(("%s: called with NULL parameter\r\n", _fx_));
		return( (DWORD) ICERR_ERROR );
	}

    try
	{
#ifdef USE_BILINEAR_MSH26X
        dwRet = H263Compress(pi, lpCompInfo);
#else
        dwRet = H263Compress(lpInst, lpCompInfo);
#endif
    }
    catch (...)
	{
        // For a DEBUG build, display a message and pass the exception up.
        // For a release build, stop the exception here and return an error
        // code.  This gives upstream code a chance to gracefully recover.
		// We also need to clear the floating point control word, otherwise
		// the upstream code may incur an exception the next time it tries
		// a floating point operation (presuming this exception was due
		// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
		ERRORMESSAGE(("%s: Exception occured!!!\r\n", _fx_));
        throw;
#else
		_clearfp();
        return (DWORD) ICERR_ERROR;
#endif
    }

    if(dwRet != ICERR_OK)
	{
		ERRORMESSAGE(("%s: Failed!!!\r\n", _fx_));
	}

    // now transfer the information.
    lpCompInfo->lpbiOutput->biSize =sizeof(BITMAPINFOHEADER);
#ifdef USE_BILINEAR_MSH26X
    lpCompInfo->lpbiOutput->biCompression  = pi->fccHandler;
#else
    lpCompInfo->lpbiOutput->biCompression  = FOURCC_H263;
#endif
    lpCompInfo->lpbiOutput->biPlanes       = 1;
    lpCompInfo->lpbiOutput->biBitCount     = 24;
    lpCompInfo->lpbiOutput->biWidth        = lpInst->xres;
    lpCompInfo->lpbiOutput->biHeight       = lpInst->yres;
    lpCompInfo->lpbiOutput->biSizeImage    = lpInst->CompressedSize;
    lpCompInfo->lpbiOutput->biClrUsed      = 0;
    lpCompInfo->lpbiOutput->biClrImportant = 0;

	// lpCompInfo->dwFlags is set inside the compressor.

	// set the chunk idea if requested
	if (lpCompInfo->lpckid)
	{
		*(lpCompInfo->lpckid) = TWOCC_H26X;
	}
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\adjpels.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\adjpels.asv   1.2   22 Dec 1995 15:54:30   KMILLS  $
;//
;// $Log:   S:\h26x\src\dec\adjpels.asv  $
;// 
;//    Rev 1.2   22 Dec 1995 15:54:30   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.1   31 Oct 1995 10:50:56   BNICKERS
;// Save/restore ebx.
;// 
;//    Rev 1.0   01 Sep 1995 17:14:04   DBRUCKS
;// add adjustpels
;*  
;*     Rev 1.0   29 Mar 1995 12:17:14   BECHOLS
;*  Initial revision.
;// 
;//    Rev 1.2   07 Dec 1994 16:21:04   BNICKERS
;// Prepare entry sequence for flat model.
;// 
;//    Rev 1.1   05 Dec 1994 09:45:18   BNICKERS
;// Prepare for flat model.
;// 
;//    Rev 1.0   15 Jul 1994 11:10:20   BECHOLS
;// Initial revision.
;//
;////////////////////////////////////////////////////////////////////////////
;
;  adjpels -- This function adjusts pel values to track the user's tinkering
;             with brightness, contrast, and saturation knobs.  Each call
;             to this function adjusts one plane.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
;include decinst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataAdjustPels>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE AdjustPels (U8 FAR * InstanceBase,
;                                   X32 PlaneBase,
;                                   DWORD PlaneWidth,
;                                   DWORD PlanePitch,
;                                   DWORD PlaneHeight,
;                                   X32 AdjustmentTable);
;
;  In 16-bit Microsoft Windows (tm), InstanceBase provides the segment
;  descriptor for the plane and the adjustment table.
;
;  In 32-bit Microsoft Windows (tm), InstanceBase provides the base to apply
;  to the plane base and the adjustment table.

PUBLIC  AdjustPels

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        AdjustPels  proc DIST LANG AInstanceBase:      DWORD,
                                   APlaneBase:         DWORD,
                                   APlaneWidth:        DWORD,
                                   APlanePitch:        DWORD,
                                   APlaneHeight:       DWORD,
                                   AAdjustmentTable:   DWORD

IFDEF WIN32

LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase             = LocalFrameSize + RegisterStorageSize +  4
PlaneBase                = LocalFrameSize + RegisterStorageSize +  8
PlaneWidth               = LocalFrameSize + RegisterStorageSize + 12
PlanePitch               = LocalFrameSize + RegisterStorageSize + 16
PlaneHeight              = LocalFrameSize + RegisterStorageSize + 20
AdjustmentTable          = LocalFrameSize + RegisterStorageSize + 24
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 28


; No Locals (on local stack frame)

LCL EQU <esp+>

ELSE

RegisterStorageSize = 20           ; Put local variables on stack.

; Arguments:

InstanceBase_zero        = RegisterStorageSize +  4
InstanceBase_SegNum      = RegisterStorageSize +  6
PlaneBase                = RegisterStorageSize +  8
PlaneWidth               = RegisterStorageSize + 12
PlanePitch               = RegisterStorageSize + 14
PlaneHeight              = RegisterStorageSize + 16
AdjustmentTable          = RegisterStorageSize + 18
EndOfArgList             = RegisterStorageSize + 20

LCL EQU <>

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   eax,PD InstanceBase[esp]
  mov   esi,PD AdjustmentTable[esp]
  mov   edi,PD PlaneBase[esp]
  add   esi,eax
  add   edi,eax
  mov   ecx,PD PlaneWidth[esp]
  mov   edx,PD PlaneHeight[esp]
  mov   ebp,PD PlanePitch[esp]
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  movzx esi,PW [ebp+AdjustmentTable]
  mov   edi,PD [ebp+PlaneBase]
  movzx ecx,PW [ebp+PlaneWidth]
  movzx edx,PW [ebp+PlaneHeight]
  movzx ebp,PW [ebp+PlanePitch]
ENDIF

  sub   ebp,ecx
   xor  ebx,ebx
  shl   ecx,5
   dec  edx
  shl   edx,16
   xor  eax,eax

; Register usage:
;  ebp -- skip distance, i.e. pitch minus width.
;  esi -- Adjustment table address.
;  edi -- Plane cursor.
;  edx[16:31] -- height.
;  dh  -- width counter.
;  ch  -- width.
;  dl  -- An adjusted pel.
;  cl  -- An adjusted pel.
;  bl  -- A raw pel.
;  al  -- A raw pel.
  
NextLine:
  mov   al,PB [edi  ]
   mov  bl,PB [edi+4]
  mov   dh,ch

Next8Pels:
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]  ; Table duplicated;  avoids many bank conflicts.
  mov   al,PB [edi+1]
   mov  bl,PB [edi+5]
  mov   PB [edi  ],cl
   mov  PB [edi+4],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+2]
   mov  bl,PB [edi+6]
  mov   PB [edi+1],cl
   mov  PB [edi+5],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+3]
   mov  bl,PB [edi+7]
  mov   PB [edi+2],cl
   mov  PB [edi+6],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+8]
   mov  bl,PB [edi+12]
  mov   PB [edi+3],cl
   mov  PB [edi+7],dl
  add   edi,8
   dec  dh
  jne   Next8Pels

  add   edi,ebp
   sub  edx,000010000H
  jge   NextLine

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

AdjustPels endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\exbrc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbrc.cpp
 *
 * Description:
 *   Bit rate control routines for H.261 and H.263.  The bit rate is controlled
 *   by changing QUANT value at the GOB level (H.261) or picture and GOB level
 *   (H.26X).  InitBRC() must be called at the time encoder is instanced; it
 *   initializes some data values in BRCState structure. CalcPQUANT() computes the new
 *   quant. value at the picture level; it must always be called.
 *   CalcMBQUANT computes the new quant. value at the MB level; it need not be 
 *   called if quant. adjustment is done at the picture level.
 *   
 *
 * Routines:
 *   InitBRC
 *   CalcPQUANT
 *   CalcMBQUANT
 * Prototypes in:
 *   e3enc.h
 * Note
 *   Encoder must update BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, and
 *   BRCState->uTargetFrmSize.
 */

/*
 * $Header:   S:\h26x\src\enc\exbrc.cpv   1.15   31 Oct 1996 14:59:26   MBODART  $
 * $Log:   S:\h26x\src\enc\exbrc.cpv  $
// 
//    Rev 1.15   31 Oct 1996 14:59:26   MBODART
// Prevent recent changes from inadvertantly affecting H.261.
// 
//    Rev 1.14   31 Oct 1996 10:05:38   KLILLEVO
// changed from DBOUT to DbgLog
// 
// 
//    Rev 1.13   29 Aug 1996 09:31:54   CZHU
// Map intra-coded GOB to simpliar quality of inter-coded neighbours
// 
//    Rev 1.12   14 Aug 1996 16:46:22   CZHU
// Adjust QP for intra frames other than the first Key frames. 
// 
//    Rev 1.11   12 Mar 1996 13:26:54   KLILLEVO
// new rate control with adaptive bit usage profile
// 
//    Rev 1.10   05 Feb 1996 17:15:12   TRGARDOS
// Added code to do custom quantizer selection for
// still frames
// 
//    Rev 1.9   01 Dec 1995 15:27:06   DBRUCKS
// I removed the QP_mean affects to the global_adj value.
// This resulted in removing any affect of the target frame rate on 
// the global adj value.
// 
//    Rev 1.8   28 Nov 1995 15:01:04   TRGARDOS
// Initialized target frame rate in BRCinit.
// 
//    Rev 1.7   27 Nov 1995 19:26:00   TRGARDOS
// Cleaned up bit rate control functions to be generic h26x bit rate
// controller.  Based off of macro blocks instead of GOBS now.
// 
//    Rev 1.6   26 Oct 1995 19:50:54   TRGARDOS
// Fixed a small mistake in the global adjust calculation
// and changed frame rate to a parameter.
// 
//    Rev 1.5   25 Oct 1995 23:22:36   SINGX
// Changed BRC back to we just get frame rate from client
// and compute global adjust ourselves.
// 
//    Rev 1.4   25 Oct 1995 20:14:40   TRGARDOS
// Added code to use global adjustment passed from client.
// 
//    Rev 1.3   12 Oct 1995 12:04:42   TRGARDOS
// Added QP_mean initialization in initBRC and added clipping
// to all calculations of the new QP.
// 
//    Rev 1.2   11 Oct 1995 19:35:00   TRGARDOS
// Modified bit rate controller.
// 
//    Rev 1.1   09 Oct 1995 11:48:10   TRGARDOS
// Added float typecasting.
// 
//    Rev 1.0   06 Oct 1995 16:41:22   AGUPTA2
// Initial revision.
 */

// PhilF-: In the LAN case and QCIF mode, it looks like even with the smallest quantizer
// we may be way below the max allowed at 30fps. Therefore, with little motion,
// the bitrate looks constant at a low bitrate value. When high motion comes in,
// even with the same small quantizer we will remain below the max. So we will
// use that small quantizer, and the size of those compressed frames will get bigger
// because of the higher motion -> this explains why we don't have a straight
// line in the LAN case when looking at StatView...

#include "precomp.h"

U8 clampQP(int iUnclampedQP)
{
	return ((iUnclampedQP < 2) ? 2 : (iUnclampedQP > 31) ? 31 : iUnclampedQP);
}

/****************************************************************************
 * InitBRC
 * Parameter:
 *   BRCState: T_H263EncoderCatalog ptr
 *   Initializes some some variables in the encoder catalog.
 * Note
 *  Must be called when the encoder is instanced.
 */
void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int numMBs)
{
	FX_ENTRY("InitBRC");

	BRCState->NumMBs = numMBs;
	BRCState->u8INTRA_QP = DefIntraQP;
	BRCState->u8INTER_QP = DefInterQP;
	BRCState->uLastINTRAFrmSz = 0;
	BRCState->uLastINTERFrmSz = 0;
	BRCState->QP_mean = DefIntraQP;
	BRCState->TargetFrameRate = (float) 0.0;
	BRCState->u8StillQnt = 0;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Bitrate controller initial state:\r\n  numMBs = %ld macroblocks\r\n  u8INTRA_QP = %ld\r\n  u8INTER_QP = %ld\r\n", _fx_, BRCState->NumMBs, BRCState->u8INTRA_QP, BRCState->u8INTER_QP));
	DEBUGMSG(ZONE_BITRATE_CONTROL, ("  uLastINTRAFrmSz = %ld bytes\r\n  uLastINTERFrmSz = %ld bytes\r\n  QP_mean = %ld\r\n  TargetFrameRate = %ld.%ld fps\r\n", BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, BRCState->QP_mean, (DWORD)BRCState->TargetFrameRate, (DWORD)((BRCState->TargetFrameRate - (float)(DWORD)BRCState->TargetFrameRate) * 10.0f)));

}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcPQUANT | This function computes the PQUANT value to
 *   use for the current frame. This is done by using the target frame size
 *   and the results achieved with the previous frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The PQUANT value.
 *
 * @comm H.261 does not have PQUANT. So, H261 encoder can call this routine
 *   once and use the value returned as GQUANT for all GOBs.  Or, it can
 *   call CalcMBQUANT for all GOBs.
 *
 *   This routine MUST be called for every frame for which QUANT adjustment
 *   is required. CalcMBQUANT() might not be called.
 *
 * @xref <f FindNewQuant> <f CalcMBQUANT>
 ***************************************************************************/
U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcPQUANT");

    if (PicCodType == INTERPIC)
    {
        if (BRCState->uLastINTERFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last P-frame as the starting point
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTERFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / (float)BRCState->uTargetFrmSize;

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_, clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}
			else
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_,clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}

        	BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5));
        }
		else
		{
			// This the first P-frame - use default value
			BRCState->u8INTER_QP = clampQP((unsigned char) BRCState->QP_mean);
			BRCState->Global_Adj = (float)0.0;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTER_QP = %ld\r\n", _fx_, BRCState->u8INTER_QP));
		}

        return BRCState->u8INTER_QP;
    }
    else if (PicCodType == INTRAPIC)
    {
        if (BRCState->uLastINTRAFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last I-frame as the starting point
			// Assume lighting & other conditions haven't changed too much since last I-frame
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTRAFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float)BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}
			else
			{
				// This the first I-frame - use default value
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}

			BRCState->u8INTRA_QP = clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTRA_QP = %ld\r\n", _fx_, clampQP(BRCState->u8INTRA_QP)));
		}

        return clampQP(BRCState->u8INTRA_QP);
    }
    else
    {
		ERRORMESSAGE(("%s: Unknown frame type\r\n", _fx_));
        return clampQP(BRCState->u8INTRA_QP);  //  return any valid value
    }
    
}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcMBQUANT | This function computes the GQUANT value to
 *   use for the current GOB. This is done by using the target frame size and
 *   the running average of the GQUANTs computed for the previous GOBs in
 *   the current frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm U32 | uCumPrevFrmSize | Specifies the cumulated size of the previous
 *   GOBs in the previous frame.
 *
 * @parm U32 | uPrevFrmSize | Specifies the total size of the previous
 *   frame.
 *
 * @parm U32 | uCumFrmSize | Specifies the cumulated size of the previous
 *   GOBs.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The GQUANT value.
 *
 * @xref <f FindNewQuant> <f CalcPQUANT>
 ***************************************************************************/
U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uCumPrevFrmSize, U32 uPrevFrmSize, U32 uCumFrmSize, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcMBQUANT");

	float		Local_Adj;
	int			TargetCumSize;

	if (PicCodType == INTERPIC)
	{
		// Calculate the local adjustment parameter by looking at how well we've
		// been doing so far with the previous GOBs
		TargetCumSize = (int)uCumPrevFrmSize * BRCState->uTargetFrmSize / uPrevFrmSize;

		// If this is the first GOB there's no local adjustment to compute
		Local_Adj = TargetCumSize ? (float)((int)uCumFrmSize - TargetCumSize) / (float)TargetCumSize : 0.0f;

		BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj + Local_Adj) + (float)0.5));

#ifdef _DEBUG
		if (Local_Adj >= 0L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)Local_Adj, (DWORD)((Local_Adj - (float)(DWORD)Local_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)(Local_Adj * -1.0f), (DWORD)((Local_Adj - (float)(DWORD)(Local_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
#endif

		return BRCState->u8INTER_QP;
	}
	else if (PicCodType == INTRAPIC)
	{
		// The previous I-frame is so old that there isn't much point in doing local
		// adjustments - so only consider the global changes
		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTRA_QP = %ld\r\n", _fx_, BRCState->u8INTRA_QP));

		return BRCState->u8INTRA_QP;
	}
	else
	{
		ERRORMESSAGE(("%s: Unknown frame type\r\n", _fx_));
		return BRCState->u8INTRA_QP;  //  return some valid value
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ccinst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\ccinst.inv   1.7   05 Feb 1996 13:35:40   BNICKERS  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _CCINST_INC_
ELSE
_CCINST_INC = 1

include memmodel.inc

; Instance data in the Color Convertor's segment.

IFDEF WIN32

_H26xColorConvertorTbl SEGMENT DWORD PUBLIC 'DATA'
EXTERNDEF H26xColorConvertorTables:BYTE
_H26xColorConvertorTbl ENDS

ELSE

H26xColorConvertorTables = 0
LocalStorageCC EQU H26xColorConvertorTables ; 512 bytes for function locals
H26xColorConvertorTables = 512    ; locals under 16-bit Microsoft windows (tm).

ENDIF


; For CLUT8 and CLUT8Zoom2:

; 64 Dwords of UV contrib to line 0, dithered 4 ways.  Line 1 rotated 2 bytes.
UVDitherLine01  EQU H26xColorConvertorTables + 0

; 64 Dwords of UV contrib to line 2, dithered 4 ways.  Line 3 rotated 2 bytes.
UVDitherLine23  EQU H26xColorConvertorTables + 256

; 262 bytes of Y's contrib to CLUT indices.
YDither         EQU H26xColorConvertorTables + 512

; 26 bytes of padding.

; 256 Dwords of Y's contrib to CLUT indices, dithered 4 ways.
YDitherZ2       EQU H26xColorConvertorTables + 800

IFDEF WIN32
ELSE
SizeOf_CLUT8FixedPart    = H26xColorConvertorTables + 1824
H26xColorConvertorTables = H26xColorConvertorTables - 1824
ENDIF

; For RGB16   (Lo/Hi differ by dither.)

; These are the tables for 555 format.
RValLo        EQU H26xColorConvertorTables + 1824 ; 304 bytes for clamped R val.
GValLo        EQU H26xColorConvertorTables + 2128 ; 262 bytes for clamped G val.
BValLo        EQU H26xColorConvertorTables + 2390 ; 350 bytes for clamped B val.
RValHi        EQU H26xColorConvertorTables + 2740 ; 304 bytes for clamped R val.
GValHi        EQU H26xColorConvertorTables + 3044 ; 262 bytes for clamped G val.
BValHi        EQU H26xColorConvertorTables + 3306 ; 350 bytes for clamped B val.
; 565 format is 2048 bytes after 555 format.
; 655 format is 2048 bytes after 565 format.
; 664 format is 2048 bytes after 655 format.
                                                  ; 24 bytes Padding

UContrib      EQU H26xColorConvertorTables + 9824 ; interleaved with V.
VContrib      EQU H26xColorConvertorTables + 9828 ; interleaved with U.
                                                  ; 512 longwords.

; For RGB16 Zoom By 2.

; These are the tables for 555 format.
RValZ2        EQU H26xColorConvertorTables + 11872 ; 304 Dwords for clamped R.
GValZ2        EQU H26xColorConvertorTables + 13088 ; 262 Dwords for clamped G.
BValZ2        EQU H26xColorConvertorTables + 14136 ; 350 Dwords for clamped B.
; 565 format is 4096 bytes after 555 format.
; 655 format is 4096 bytes after 565 format.
; 664 format is 4096 bytes after 655 format.
                                                   ; 16 bytes Padding
IFDEF WIN32
ELSE
SizeOf_RGB16FixedPart    = H26xColorConvertorTables + 27840
H26xColorConvertorTables = H26xColorConvertorTables - 26016
ENDIF                                 


; For RGB24

B24Value      EQU H26xColorConvertorTables + 27840 ; 701 bytes for clamped Bval.
                                                   ; 3 bytes Padding
R24Value      EQU B24Value + 47                    ; Clamped R value.
G24Value      EQU B24Value + 96                    ; Clamped G value.

U24Contrib    EQU H26xColorConvertorTables + 28544 ; interleaved with V.
V24Contrib    EQU H26xColorConvertorTables + 28548 ; interleaved with U.
                                                   ; 512 longwords.

IFDEF WIN32
ELSE
SizeOf_RGB24FixedPart    = H26xColorConvertorTables + 30592
H26xColorConvertorTables = H26xColorConvertorTables -  2752
ENDIF

ActivePaletteIdxTable EQU H26xColorConvertorTables + 30592 ; 2^16 bytes.
UContribToAPIdx       EQU H26xColorConvertorTables + 96128 ; 1024 bytes UDith.
VContribToAPIdx       EQU H26xColorConvertorTables + 97152 ; 1024 bytes clamp B.

IFDEF WIN32
ELSE
SizeOf_CLUT8APFixedPart  = H26xColorConvertorTables + 12160 ; Keep it same as
H26xColorConvertorTables = H26xColorConvertorTables - 67584 ; three lines above
ENDIF

ENDIF

CCTYPE_YUV12ForEnc         =  0
CCTYPE_CLUT8               =  1
CCTYPE_CLUT8DCI            =  2
CCTYPE_CLUT8ZoomBy2        =  3
CCTYPE_CLUT8ZoomBy2DCI     =  4
CCTYPE_RGB24               =  5
CCTYPE_RGB24DCI            =  6
CCTYPE_RGB24ZoomBy2        =  7
CCTYPE_RGB24ZoomBy2DCI     =  8
CCTYPE_RGB16555            =  9
CCTYPE_RGB16555DCI         = 10
CCTYPE_RGB16555ZoomBy2     = 11
CCTYPE_RGB16555ZoomBy2DCI  = 12  
CCTYPE_IF09                = 13
CCTYPE_RGB16664            = 14
CCTYPE_RGB16664DCI         = 15
CCTYPE_RGB16664ZoomBy2     = 16
CCTYPE_RGB16664ZoomBy2DCI  = 17 
CCTYPE_RGB16565            = 18
CCTYPE_RGB16565DCI         = 19
CCTYPE_RGB16565ZoomBy2     = 20
CCTYPE_RGB16565ZoomBy2DCI  = 21 
CCTYPE_RGB16655            = 22
CCTYPE_RGB16655DCI         = 23
CCTYPE_RGB16655ZoomBy2     = 24
CCTYPE_RGB16655ZoomBy2DCI  = 25 
CCTYPE_CLUT8APDCI          = 26
CCTYPE_CLUT8APZoomBy2DCI   = 27
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\exbrc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Header:   S:\h26x\src\enc\exbrc.h_v   1.2   12 Mar 1996 13:26:58   KLILLEVO  $
// $Log:   S:\h26x\src\enc\exbrc.h_v  $
;// 
;//    Rev 1.2   12 Mar 1996 13:26:58   KLILLEVO
;// new rate control with adaptive bit usage profile
;// 
;//    Rev 1.1   05 Feb 1996 17:15:22   TRGARDOS
;// Converted an unused byte in the BRCState structure to
;// a variable to store the still quantizer number.
;// 
;//    Rev 1.0   27 Nov 1995 19:49:10   TRGARDOS
;// Initial revision.

#ifndef _EXBRC_H_
#define _EXBRC_H_

/*
 * Structure for bit rate controller state variables.
 * Size of structure is 32 Bytes.
 */
struct BRCStateStruct {
	U32		NumMBs;
	U32		uLastINTRAFrmSz;
	U32		uLastINTERFrmSz;
	int		QP_mean;
	U32		uTargetFrmSize;
	float 	Global_Adj;
	U8		u8INTRA_QP;
	U8		u8INTER_QP;
	U8		u8StillQnt;		// Keeps of tracker of Qnt used for still image compression.
	U8		Unassigned[1];	// pad to make a multiple of 16 bytes.
	float	TargetFrameRate;
	};

void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int NumMBs);

U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType);

U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uTargetPos, U32 uTargetSum, U32 uCumFrmSize, EnumPicCodType PicCodType);

U8 clampQP(int iUnclampedQP);

#endif // _EXBRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\memmon.cpp ===
/*
** memmon\api\memmon.c - Win32 functions to talk to Memmon
*/
#include "Precomp.h"

#ifdef TRACK_ALLOCATIONS // { TRACK_ALLOCATIONS

// #define LOG_ALLOCATIONS 1

static HANDLE   hMemmon = INVALID_HANDLE_VALUE;           /* VxD handle */
static unsigned uMyProcessId;

/*
** OpenMemmon - Must be called before any other calls.  Gets a handle to
**              Memmon.
*/
int OpenMemmon( void )
{

#ifdef LOG_ALLOCATIONS
	OutputDebugString("OpenMemmon()\r\n");
#endif

    uMyProcessId = GetCurrentProcessId();
    if( hMemmon != INVALID_HANDLE_VALUE )
        return TRUE;

    hMemmon = CreateFile( "\\\\.\\memmon", GENERIC_READ, 0,
                NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hMemmon == INVALID_HANDLE_VALUE )
        return FALSE;
    else
        return TRUE;
}


/*
** CloseMemmon - Should be called when the program is finished with Memmon.
**               Closes handle.
*/
void CloseMemmon( void )
{

#ifdef LOG_ALLOCATIONS
	OutputDebugString("CloseMemmon()\r\n");
#endif

    /*
    ** If we have a valid handle to memmon, free any buffers and
    ** close it.
    */
    if( hMemmon != INVALID_HANDLE_VALUE ) {
        FreeBuffer();
        CloseHandle( hMemmon );
        hMemmon = INVALID_HANDLE_VALUE;
    }
}


/*
** FindFirstVxD - Get information on the first VxD in the system
**
** Returns 0 on failure, number of VxDs on success
*/
int FindFirstVxD( VxDInfo * info )
{
    int temp, num;

    temp = info->vi_size;
    DeviceIoControl( hMemmon, MEMMON_DIOC_FindFirstVxD,
            info, sizeof( VxDInfo ), NULL, 0, NULL, NULL );
    num = info->vi_size;
    info->vi_size = temp;

    return num;
}


/*
** FindNextVxD - Get information on the next VxD in the system.  Must
**      pass same pointer as used in FindFirstVxD.  Continue to call
**      until it returns FALSE to get all VxDs.
**
** Returns 0 on failure (no more VxDs), >0 on success, -1 for restart
*/
int FindNextVxD( VxDInfo * info )
{
    DeviceIoControl( hMemmon, MEMMON_DIOC_FindNextVxD,
            info, sizeof( VxDInfo ), NULL, 0, NULL, NULL );

    return info->vi_vhandle;
}


/*
** GetVxDLoadInfo - Get information about VxD objects, sizes, etc.
**      info must be large enough to hold all of them.  Use obj
**      count from VxDInfo to allocate appropriate memory.  handle
**      comes from VxDInfo as well.
**
** Returns 0 on failure, >0 on success
*/
int GetVxDLoadInfo( VxDLoadInfo * info, int handle, int size )
{
    info->vli_size = size;
    info->vli_objinfo[0].voi_linearaddr = handle;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetVxDLoadInfo,
                        info, size, NULL, 0, NULL, NULL );
}


/*
** GetFirstContext - Get information on first context in system.
**      ProcessIDs returned will match Toolhelp32 process ids.
**
** ciFlags field of ContextInfo contains 1 if this is the first time
** this context has been examined.
**
** bIgnoreStatus = FALSE - Causes ciFlags to be zero if this context
**              is examined again
** bIgnoreStatus = TRUE - ciFlags will be the same next time as it
**              is this time
**
** Returns 0 on failure, >0 on success
*/
int     GetFirstContext( ContextInfo * context, BOOL bIgnoreStatus )
{
    context->ciProcessID = uMyProcessId;
    if( bIgnoreStatus )
        context->ciFlags = 1;
    else
        context->ciFlags = 0;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetFirstContext,
                context, sizeof( ContextInfo ), NULL, 0, NULL, NULL );
}


/*
** GetNextContext - Pass same structure used in GetFirstContext
**
** ciFlags field of ContextInfo contains 1 if this is the first time
** this context has been examined.
**
** bIgnoreStatus = FALSE - Causes ciFlags to be zero if this context
**              is examined again
** bIgnoreStatus = TRUE - ciFlags will be the same next time as it
**              is this time
**
** Returns 0 on failure (no more contexts), >0 on success
**
** On failure, if the ciHandle field is -1, the list changed during
** the search, and needs to be read again.  (FindFirstContext again)
*/
int     GetNextContext( ContextInfo * context, BOOL bIgnoreStatus )
{
    if( bIgnoreStatus )
        context->ciFlags = 1;
    else
        context->ciFlags = 0;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetNextContext,
                context, sizeof( ContextInfo ), NULL, 0, NULL, NULL );
}


/*
** GetContextInfo - Get a list of block addresses and sizes for a context
**      Use ContextInfo to decide how many, and allocate enough space.
**
** Returns 0 on failure, >0 on success
*/
int     GetContextInfo( int handle, BlockRecord * info, int numblocks )
{
    info->brLinAddr = numblocks;
    info->brPages = handle;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetContextInfo,
                info, numblocks * sizeof( BlockRecord ), NULL,
                0, NULL, NULL );
}


/*
** SetBuffer - Allocate and lock some number of pages
**      - If called more than once, the previous buffer is freed.
**
** pages is the number of pages to allocate
**
** Returns NULL on failure, pointer to buffer on success
*/
void * SetBuffer( int pages )
{
    unsigned uAddr = (unsigned)pages;
    int iRes;

    iRes = DeviceIoControl( hMemmon, MEMMON_DIOC_SetBuffer,
        &uAddr, sizeof( uAddr ), NULL, 0, NULL, NULL );

    if( iRes )
        return (void *)uAddr;
    else
        return NULL;
}


/*
** FreeBuffer - Free the buffer allocated by SetBuffer
**
** Returns 0 on failure, >0 on success
*/
int FreeBuffer( void )
{
    return DeviceIoControl( hMemmon, MEMMON_DIOC_FreeBuffer,
                NULL, 0, NULL, 0, NULL, NULL );
}


/*
** GetPageInfo - Get present/committed/accessed information about a
**      range of pages in a specific process
**
** uAddr is the address to get the information
** uNumPages is the number of pages to get information on
** uProcessID is GetCurrentProcessID() or a process id from ToolHelp
**      It's ignored if the address is a global address
** pBuffer is a buffer uNumPages long where the info will be stored:
**      - one byte for each page, a combination of the following flags:
**              MEMMON_Present
**              MEMMON_Committed
**              MEMMON_Accessed
**              MEMMON_Writeable
**              MEMMON_Lock
**
** Returns 0 on failure, >0 on success
*/
int GetPageInfo( unsigned uAddr, unsigned uNumPages,
                unsigned uProcessID, char * pBuffer )
{
    PAGEINFO        pi;

    pi.uAddr = uAddr;
    pi.uNumPages = uNumPages;
    pi.uProcessID = uProcessID;
    pi.uCurrentProcessID = uMyProcessId;
    pi.uOperation = PAGES_QUERY;
    pi.pBuffer = pBuffer;

    return DeviceIoControl( hMemmon, MEMMON_DIOC_PageInfo,
                &pi, sizeof( PAGEINFO ), NULL, 0, NULL, NULL );
}


/*
** ClearAccessed - Clear accessed bits for a range of process pages
**
** uAddr is the address of the first page to clear
** uNumPages is the number of pages to reset
** uProcessID is GetCurrentProcessID() or a process id from ToolHelp
**              It's ignored if the block is a global block
**
** Returns 0 on failure, >0 on success
*/
int ClearAccessed( unsigned uAddr, unsigned uNumPages, unsigned uProcessID )
{
    PAGEINFO        pi;

    pi.uAddr = uAddr;
    pi.uNumPages = uNumPages;
    pi.uProcessID = uProcessID;
    pi.uCurrentProcessID = uMyProcessId;
    pi.uOperation = PAGES_CLEAR;
    pi.pBuffer = NULL;

    return DeviceIoControl( hMemmon, MEMMON_DIOC_PageInfo,
                &pi, sizeof( PAGEINFO ), NULL, 0, NULL, NULL );
}

/*
** GetHeapSize - return how many allocated blocks in kernel heaps
**
** uSwap    - Estimated number allocated blocks in swappable heap
** uFixed   - Estimated number allocated blocks in fixed heap
**
** This number is lower than the actual number of blocks in the heap.
** Some VMM functions call HeapAllocate directly rather than through
** the service and aren't included in this count.  Free blocks aren't
** included in this count.
**
*/
void GetHeapSizeEstimate( unsigned * uSwap, unsigned * uFixed )
{
    unsigned info[2];

    DeviceIoControl( hMemmon, MEMMON_DIOC_GetHeapSize,
            info, sizeof( info ), NULL, 0, NULL, NULL );

    *uSwap = info[0];
    *uFixed = info[1];
}

/*
** GetHeapList - Get list of busy and free blocks in one of the kernel
**      heaps
**
** pBuffer - buffer to store records
** uSize - size of buffer in bytes
** uFlags - MEMMON_HEAPSWAP or MEMMON_HEAPLOCK
**
** Each record is two dwords.  The first, contains an address and flags:
**
** MEMMON_HP_FREE  - This block heap is not in use
** MEMMON_HP_VALID - If set the size of the block can be calculated by
**                   subtracting this address from the next.  If this
**                   flag isn't set, this block is a sentinel block and
**                   it's size is 0.
**
** The second dword contains the EIP of the caller.  This value is 0
** for all free blocks.  If this value is 0 for a busy block,
** HeapAllocate was called directly (not through the service) and so
** this block was allocated somewhere in VMM.
**
** Returns number of heap blocks stored in buffer
*/
int GetHeapList( unsigned * pBuffer, unsigned uSize, unsigned uFlags )
{
    unsigned info[3];

    info[0] = (unsigned)pBuffer;
    info[1] = uSize;
    info[2] = uFlags;

    DeviceIoControl( hMemmon, MEMMON_DIOC_GetHeapList,
            info, sizeof( info ), NULL, 0, NULL, NULL );

    return info[0];
}

/*
** GetSysInfo - get system info from memmon
**
** pInfo - pointer to SYSINFO struct to fill in
**
** Returns: 0 on failure, non 0 on success
*/
int GetSysInfo( PSYSINFO pInfo )
{
    pInfo->infoSize = sizeof( SYSINFO );
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetSysInfo,
            pInfo, pInfo->infoSize, NULL, 0, NULL, NULL );
}

/*
** AddName - Add a name to Memmon's name list for this process
**
** uAddress     - Address of block to name
** pszName      - name of block
**
** Returns 0 on success, non-0 on failure
*/
int AddName( unsigned uAddress, char * pszName )
{
    unsigned info[3];
	int res;

#ifdef LOG_ALLOCATIONS
	char szDebug[96];

	wsprintf(szDebug, "ADD - 0x%08lX - %s\r\n", uAddress, pszName);
	OutputDebugString(szDebug);
#endif

    info[0] = uMyProcessId;
    info[1] = uAddress;
    info[2] = (unsigned)pszName;
    res = DeviceIoControl( hMemmon, MEMMON_DIOC_AddName,
            info, sizeof( info ), NULL, 0, NULL, NULL );

	if (res)
		OutputDebugString("SUCCESS\r\n");
	else
		OutputDebugString("FAILURE\r\n");

	return res;	
}

/*
** RemoveName - Remove a name from Memmon's name list for this process
**
** uAddress     - Address of block to remove name
**
** Returns 0 on success, non-0 on failure
*/
int RemoveName( unsigned uAddress )
{
    unsigned info[2];

#ifdef LOG_ALLOCATIONS
	char szDebug[96];

	wsprintf(szDebug, "RMV - 0x%08lX \r\n", uAddress);
	OutputDebugString(szDebug);
#endif

    info[0] = uMyProcessId;
    info[1] = uAddress;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_RemoveName,
            info, sizeof( info ), NULL, 0, NULL, NULL );
}

/*
** GetFirstName - Get first name in name list for a context
**
** pContext - Context to get first name in
** pName    - Buffer to use for name info
**
** Returns 0 on success, non-0 on failure
*/
int GetFirstName( ContextInfo * pContext, PBLOCKNAME pBlock )
{
    unsigned info[2];

    info[0] = (unsigned)pContext;
    info[1] = (unsigned)pBlock;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetFirstName,
            info, sizeof( info ), NULL, 0, NULL, NULL );
}

/*
** GetNextName - Remove a name from Memmon's name list for this process
**
** pBlock   - Buffer to save info
**
** Returns 0 on success, non-0 on failure
*/
int GetNextName( PBLOCKNAME pBlock )
{
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetNextName,
            pBlock, sizeof( BLOCKNAME ), NULL, 0, NULL, NULL );
}


#endif // } TRACK_ALLOCATIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\flipuyvy.cpp ===
#include "precomp.h"
#include "flip.h"




bool FlipImage(LPCODINST lpCompInst, ICCOMPRESS *lpicComp)
{
	// at the moment, we only know how to flip UYVY
	if (FOURCC_UYVY != lpicComp->lpbiInput->biCompression)
	{
		return false;
	}

	if (lpCompInst->bFlip == FALSE)
	{
		return false;
	}

	return FlipUYVY(lpCompInst, lpicComp);
}


bool FlipUYVY(LPCODINST lpCompInst, ICCOMPRESS *lpicComp)
{
	int nRows, int nCols;
	int nIndex;

	int nPitch;  // row width in bytes;
	int nImageSize;
	BYTE *pSrc, *pDst; // first and last rows
	BYTE *pBuffer=NULL;

	LPBITMAPINFOHEADER pBitMapInfo = lpicComp->lpbiInput;

	nRows = pBitMapInfo->biHeight;
	nCols = pBitMapInfo->biWidth;
	nPitch = nCols * 2;
	nImageSize = nRows * nPitch;


	// allocate the flip buffer if it hasn't already been allcoated
	if ((lpCompInst->pFlipBuffer == NULL) || (lpCompInst->dwFlipBufferSize < nImageSize))
	{
		if (lpCompInst->pFlipBuffer)
		{
			delete [] lpCompInst->pFlipBuffer;
		}
		lpCompInst->pFlipBuffer = (void*) (new BYTE [nImageSize]);
		if (lpCompInst->pFlipBuffer)
		{
			lpCompInst->dwFlipBufferSize = nImageSize;
		}
		else
		{
			lpCompInst->dwFlipBufferSize = 0;
			return false; // out of memory!
		}
	}
	

	pSrc = (BYTE*)lpicComp->lpInput;
	pDst = (BYTE*)(lpCompInst->pFlipBuffer) + (nRows - 1)*nPitch; // bottom of scratch buffer

	for (nIndex = 0; nIndex < nRows; nIndex++)
	{
		CopyMemory(pDst, pSrc, nPitch);
		pSrc += nPitch;
		pDst = pDst - nPitch;
	}

	return true;

}


void ReleaseFlipMemory(LPCODINST lpCompInst)
{
	if (lpCompInst->pFlipBuffer != NULL)
	{
		delete [] lpCompInst->pFlipBuffer;
		lpCompInst->pFlipBuffer = 0;
		lpCompInst->dwFlipBufferSize = 0;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\memmon.h ===
/*
** memmon.h
**
** Structures, equates, and function prototypes to
** access the Memmon VxD.
*/

/*
** Information per VxD
*/
typedef struct {

        unsigned        vi_size;
        unsigned        vi_vhandle;             /* VxDLdr's handle */
        unsigned short  vi_flags;
        unsigned short  vi_cobj;                /* Number of objects */
        char            vi_name[8];             /* Not NULL-terminated */

} VxDInfo;

#define VXD_INITALIZED      0x0001
#define VXD_DYNAMIC         0x8000


/*
** Information per VxD object
*/
typedef struct {

        unsigned        voi_linearaddr;
        unsigned        voi_size;               /* In bytes */
        unsigned        voi_objtype;

} VxDObjInfo;

/*
** VxD Object Types, copied directly from VMM.H
*/
#define RCODE_OBJ       -1

#define LCODE_OBJ       0x01
#define LDATA_OBJ       0x02
#define PCODE_OBJ       0x03
#define PDATA_OBJ       0x04
#define SCODE_OBJ       0x05
#define SDATA_OBJ       0x06
#define CODE16_OBJ      0x07
#define LMSG_OBJ        0x08
#define PMSG_OBJ        0x09

#define DBOC_OBJ        0x0B
#define DBOD_OBJ        0x0C

#define ICODE_OBJ       0x11
#define IDATA_OBJ       0x12
#define ICODE16_OBJ     0x13
#define IMSG_OBJ        0x14


/*
** Load information for a VxD
*/
typedef struct {

        unsigned        vli_size;
        VxDObjInfo      vli_objinfo[1];

} VxDLoadInfo;


/*
** Information for each context
*/
typedef struct {

        unsigned        ciContext;              /* Context ID */
        unsigned        ciProcessID;            /* Win32 process ID */
        unsigned        ciBlockCount;
        unsigned        ciHandle;               /* Memmon's handle */
        unsigned short  ciFlags;
        unsigned short  ciNumContexts;

} ContextInfo;

#define CONTEXT_NEW     0x0001                  /* Never sampled before */
#define CONTEXT_CHANGE  0x0002                  /* context list has changed */


/*
** Information for each block in a context
*/
typedef struct {

        unsigned        brLinAddr;
        unsigned        brPages;
        unsigned        brFlags;                /* PageAllocate flags */
        unsigned        brEIP;                  /* Caller's EIP */

} BlockRecord;


/*
** Page lock information
*/
typedef struct {

        unsigned        liProcessID;
        unsigned        liAddr;
        unsigned char * liBuffer;

} LockInfo;

/*
** The following structure is used internally to for GetPageInfo and
** ClearAccessed.  See memmon.c for usage.
*/
typedef struct {

        unsigned        uAddr;
        unsigned        uNumPages;
        unsigned        uProcessID;
        unsigned        uCurrentProcessID;
        unsigned        uOperation;
        char *          pBuffer;

} PAGEINFO;

#define PAGES_CLEAR     0
#define PAGES_QUERY     1

/*
** Structure filled in by GetSysInfo
*/
typedef struct {

        unsigned        infoSize;
        unsigned        infoMinCacheSize;
        unsigned        infoMaxCacheSize;
        unsigned        infoCurCacheSize;

} SYSINFO, *PSYSINFO;

/*
** Structure used to describe block names
*/
typedef struct {

        char            bnName[32];
        unsigned        bnAddress;
        unsigned        bnNext;

} BLOCKNAME, *PBLOCKNAME;

/*
** DeviceIoCtrl functions.  See memmon.c / psapi.c for usage.
*/
#define MEMMON_DIOC_FindFirstVxD        0x80
#define MEMMON_DIOC_FindNextVxD         0x81
#define MEMMON_DIOC_GetVxDLoadInfo      0x82
#define MEMMON_DIOC_GetFirstContext     0x83
#define MEMMON_DIOC_GetNextContext      0x84
#define MEMMON_DIOC_GetContextInfo      0x85
#define MEMMON_DIOC_SetBuffer           0x86
#define MEMMON_DIOC_FreeBuffer          0x87
#define MEMMON_DIOC_PageInfo            0x88

#define MEMMON_DIOC_WatchProcess        0x89
#define MEMMON_DIOC_GetChanges          0x8A
#define MEMMON_DIOC_QueryWS             0x8B
#define MEMMON_DIOC_EmptyWS             0x8C

#define MEMMON_DIOC_GetHeapSize         0x8D
#define MEMMON_DIOC_GetHeapList         0x8E

#define MEMMON_DIOC_GetSysInfo          0x8F

#define MEMMON_DIOC_AddName             0x90
#define MEMMON_DIOC_RemoveName          0x91
#define MEMMON_DIOC_GetFirstName        0x92
#define MEMMON_DIOC_GetNextName         0x93

/*
** Flags returned in GetBlockInfo and PageInfo calls
*/
#define MEMMON_Present                  0x01
#define MEMMON_Committed                0x02
#define MEMMON_Accessed                 0x04
#define MEMMON_Writeable                0x08
#define MEMMON_Phys                     0x10
#define MEMMON_Lock                     0x20

/*
** Flags used for heap analysis
*/
#define MEMMON_HEAPLOCK                 0x00000000
#define MEMMON_HEAPSWAP                 0x00000200
#define MEMMON_HP_FREE                  0x00000001
#define MEMMON_HP_VALID                 0x00000002
#define MEMMON_HP_FLAGS                 0x00000003
#define MEMMON_HP_ADDRESS               0xFFFFFFFC


/*
** Function prototypes (memmon.c)
*/
int     OpenMemmon( void );
void    CloseMemmon( void );

int     FindFirstVxD( VxDInfo * info );
int     FindNextVxD( VxDInfo * info );
int     GetVxDLoadInfo( VxDLoadInfo * info, int handle, int size );

int     GetFirstContext( ContextInfo * context, BOOL bIgnoreStatus );
int     GetNextContext( ContextInfo * context, BOOL bIgnoreStatus );
int     GetContextInfo( int context, BlockRecord * info, int numblocks );
int     GetLockInfo( unsigned uAddr, unsigned uProcessID, char * pBuffer );

void *  SetBuffer( int pages );
int     FreeBuffer( void );

int     GetPageInfo( unsigned, unsigned, unsigned, char * );
int     ClearAccessed( unsigned, unsigned, unsigned );

void    GetHeapSizeEstimate( unsigned *, unsigned * );
int     GetHeapList( unsigned *, unsigned, unsigned );

int     GetSysInfo( PSYSINFO );

int AddName( unsigned uAddress, char * pszName );
int RemoveName( unsigned uAddress );
int GetFirstName( ContextInfo * pContext, PBLOCKNAME pBlock );
int GetNextName( PBLOCKNAME pBlock );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\precomp.h ===
#include <windows.h>
#include <windowsx.h>   /* for GlobalAllocPtr and GlobalFreePtr */
#include <math.h>
#include <memory.h>     // for _fmemcpy
#include <dos.h>        // for _FP_SEG, _FP_OFF
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>     // MAX_PATH
#include <float.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msviddrv.h>
#include <mmddk.h> // Equals both?
#include <compddk.h>
//#include <vfw.h>
#ifdef _DEBUG
#ifdef RING0
extern "C" {
#include <std.h>
#include <sys.h>
}
#endif
#endif
#include <confdbg.h>
#include <avutil.h>
#include "ctypedef.h"
#ifdef H261
#include "cxprf.h"
#endif
#include "cdrvdefs.h"
#include "cproto.h"
#include "cldebug.h"
#if 0
// They do test in one case. In the others they always bring d3dec.h
#ifdef H261
#include "d1dec.h"
#else
#include "d3dec.h"
#endif
#endif
#include "d3dec.h"
#include "c3rtp.h"
#include "dxgetbit.h"
#include "d3rtp.h"
#include "d3coltbl.h"
#include "cresourc.h"
#include "cdialogs.h"
#ifndef H261
// They do test in one case. In the others they always bring e3enc.h, e3rtp.h
#include "exbrc.h"
#include "e3enc.h"
#include "e3rtp.h"
#else
// This section never is included... so I guess we haven't defined H261 -> we build H263
// Look for the include files for H.261 and bring them into the build
#include "e1enc.h"
#include "e1rtp.h"
#endif
#include "ccustmsg.h"
#include "ccpuvsn.h"
#include "cdrvcom.h"
#include "d3tables.h"
#include "dxcolori.h"
#include "d3const.h"
#include "d3coltbl.h"
#include "ccodecid.h"
#include "dxap.h"
#include "d3pict.h"
#include "d3gob.h"
#include "d3mblk.h"
#include "d3mvdec.h"
#include "dxfm.h"
#include "d3idct.h"
#include "d3halfmc.h"
#include "d3bvriq.h"
#ifdef RING0
// RINGO ain't defined, so there is no encasst.h
#include "encasst.h"
#endif
#ifdef ENCODE_STATS
#include "e3stat.h"
#endif /* ENCODE_STATS */
#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {
#include "e3pcolor.h"
#endif
#include "e3vlc.h"
#include "counters.h"
#include "ctiming.h"
#include "MemMon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\clocals.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\common\clocals.inv   1.1   27 Dec 1995 14:12:04   RMCKENZX  $
;// $Log:   S:\h26x\src\common\clocals.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:12:04   RMCKENZX
;// 
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

include memmodel.inc
IFDEF WIN32
LDal    macro   address
        mov     al,BYTE PTR address[esp]
        endm

LDbl    macro   address
        mov     bl,BYTE PTR address[esp]
        endm

LDcl    macro   address
        mov     cl,BYTE PTR address[esp]
        endm

LDdl    macro   address
        mov     dl,BYTE PTR address[esp]
        endm

LDah    macro   address
        mov     ah,BYTE PTR address[esp]
        endm

LDbh    macro   address
        mov     bh,BYTE PTR address[esp]
        endm

LDch    macro   address
        mov     ch,BYTE PTR address[esp]
        endm

LDdh    macro   address
        mov     dh,BYTE PTR address[esp]
        endm

Leax    macro   address
        mov     eax,DWORD PTR address[esp]
        endm

Lebx    macro   address
        mov     ebx,DWORD PTR address[esp]
        endm

Lecx    macro   address
        mov     ecx,DWORD PTR address[esp]
        endm

Ledx    macro   address
        mov     edx,DWORD PTR address[esp]
        endm

Lesi    macro   address
        mov     esi,DWORD PTR address[esp]
        endm

Ledi    macro   address
        mov     edi,DWORD PTR address[esp]
        endm

Lebp    macro   address
        mov     ebp,DWORD PTR address[esp]
        endm

LZeax   macro   address
        movzx   eax,BYTE PTR address[esp]
        endm

LZebx   macro   address
        movzx   ebx,BYTE PTR address[esp]
        endm

LZecx   macro   address
        movzx   ecx,BYTE PTR address[esp]
        endm

LZedx   macro   address
        movzx   edx,BYTE PTR address[esp]
        endm

LZesi   macro   address
        movzx   esi,BYTE PTR address[esp]
        endm

LZedi   macro   address
        movzx   edi,BYTE PTR address[esp]
        endm

LZebp   macro   address
        movzx   ebp,BYTE PTR address[esp]
        endm

STal    macro   address
        mov     BYTE PTR address[esp],al
        endm

STbl    macro   address
        mov     BYTE PTR address[esp],bl
        endm

STcl    macro   address
        mov     BYTE PTR address[esp],cl
        endm

STdl    macro   address
        mov     BYTE PTR address[esp],dl
        endm

STah    macro   address
        mov     BYTE PTR address[esp],ah
        endm

STbh    macro   address
        mov     BYTE PTR address[esp],bh
        endm

STch    macro   address
        mov     BYTE PTR address[esp],ch
        endm

STdh    macro   address
        mov     BYTE PTR address[esp],dh
        endm

Seax    macro   address
        mov     DWORD PTR address[esp],eax
        endm

Sebx    macro   address
        mov     DWORD PTR address[esp],ebx
        endm

Secx    macro   address
        mov     DWORD PTR address[esp],ecx
        endm

Sedx    macro   address
        mov     DWORD PTR address[esp],edx
        endm

Sesi    macro   address
        mov     DWORD PTR address[esp],esi
        endm

Sedi    macro   address
        mov     DWORD PTR address[esp],edi
        endm

Sebp    macro   address
        mov     DWORD PTR address[esp],ebp
        endm

ADDeax  macro   address
        add     eax,DWORD PTR address[esp]
        endm

ADDebx  macro   address
        add     ebx,DWORD PTR address[esp]
        endm

ADDecx  macro   address
        add     ecx,DWORD PTR address[esp]
        endm

ADDedx  macro   address
        add     edx,DWORD PTR address[esp]
        endm

ADDesi  macro   address
        add     esi,DWORD PTR address[esp]
        endm

ADDedi  macro   address
        add     edi,DWORD PTR address[esp]
        endm

ADDebp  macro   address
        add     ebp,DWORD PTR address[esp]
        endm

SUBeax  macro   address
        sub     eax,DWORD PTR address[esp]
        endm

SUBebx  macro   address
        sub     ebx,DWORD PTR address[esp]
        endm

SUBecx  macro   address
        sub     ecx,DWORD PTR address[esp]
        endm

SUBedx  macro   address
        sub     edx,DWORD PTR address[esp]
        endm

SUBesi  macro   address
        sub     esi,DWORD PTR address[esp]
        endm

SUBedi  macro   address
        sub     edi,DWORD PTR address[esp]
        endm

SUBebp  macro   address
        sub     ebp,DWORD PTR address[esp]
        endm

CMPeax  macro   address
        cmp     eax,DWORD PTR address[esp]
        endm

CMPebx  macro   address
        cmp     ebx,DWORD PTR address[esp]
        endm

CMPecx  macro   address
        cmp     ecx,DWORD PTR address[esp]
        endm

CMPedx  macro   address
        cmp     edx,DWORD PTR address[esp]
        endm

CMPesi  macro   address
        cmp     esi,DWORD PTR address[esp]
        endm

CMPedi  macro   address
        cmp     edi,DWORD PTR address[esp]
        endm

CMPebp  macro   address
        cmp     ebp,DWORD PTR address[esp]
        endm

ADDC2M  macro   address,constant
        add     DWORD PTR address[esp],constant
        endm

ELSE
LDal    macro   address
        DB      0A0H            ; opcode: move memory to accumulator (al)
        DD      address         ; source
        endm

LDbl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      01DH            ; destination: bl
        DD      address         ; source
        endm

LDcl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      00DH            ; destination: cl
        DD      address         ; source
        endm

LDdl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      015H            ; destination: dl
        DD      address         ; source
        endm

LDah    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      025H            ; destination: ah
        DD      address         ; source
        endm

LDbh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      03DH            ; destination: bh
        DD      address         ; source
        endm

LDch    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      02DH            ; destination: ch
        DD      address         ; source
        endm

LDdh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      035H            ; destination: dh
        DD      address         ; source
        endm

Leax    macro   address
        DB      0A1H            ; opcode: move memory to accumulator (eax)
        DD      address         ; source
        endm

Lebx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

Lecx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

Ledx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

Lesi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

Ledi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

Lebp    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

LZeax   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

LZebx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

LZecx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

LZedx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

LZesi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

LZedi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

LZebp   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

STal    macro   address
        DB      0A2H            ; opcode: move accumulator (al) to memory
        DD      address         ; destination
        endm

STbl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      01DH            ; source: bl
        DD      address         ; destination
        endm

STcl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      00DH            ; source: cl
        DD      address         ; destination
        endm

STdl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      015H            ; source: dl
        DD      address         ; destination
        endm

STah    macro   address
        DB      088H            ; opcode: move register to memory
        DB      025H            ; source: ah
        DD      address         ; destination
        endm

STbh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      03DH            ; source: bh
        DD      address         ; destination
        endm

STch    macro   address
        DB      088H            ; opcode: move register to memory
        DB      02DH            ; source: ch
        DD      address         ; destination
        endm

STdh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      035H            ; source: dh
        DD      address         ; destination
        endm

Seax    macro   address
        DB      0A3H            ; opcode: move accumulator (eax) to memory
        DD      address         ; destination
        endm

Sebx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      01DH            ; source: ebx
        DD      address         ; destination
        endm

Secx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      00DH            ; source: ecx
        DD      address         ; destination
        endm

Sedx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      015H            ; source: edx
        DD      address         ; destination
        endm

Sesi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      035H            ; source: esi
        DD      address         ; destination
        endm

Sedi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      03DH            ; source: edi
        DD      address         ; destination
        endm

Sebp    macro   address
        DB      089H            ; opcode: move register to memory
        DB      02DH            ; source: ebp
        DD      address         ; destination
        endm

ADDeax  macro   address
        DB      003H            ; opcode: add memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

ADDebx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

ADDecx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

ADDedx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

ADDesi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

ADDedi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

ADDebp  macro   address
        DB      003H            ; opcode: add memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

SUBeax  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      005H            ; source: eax
        DD      address         ; destination
        endm

SUBebx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

SUBecx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

SUBedx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

SUBesi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

SUBedi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

SUBebp  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

CMPeax  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      005H            ; source: eax
        DD      address         ; source
        endm

CMPebx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      01DH            ; source: ebx
        DD      address         ; source
        endm

CMPecx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      00DH            ; source: ecx
        DD      address         ; source
        endm

CMPedx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      015H            ; source: edx
        DD      address         ; source
        endm

CMPesi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      035H            ; source: esi
        DD      address         ; source
        endm

CMPedi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      03DH            ; source: edi
        DD      address         ; source
        endm

CMPebp  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      02DH            ; source: ebp
        DD      address         ; source
        endm

ADDC2M  macro   address,constant
        add     ds:DWORD PTR address,constant
        endm

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512162.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512162.asv
;//
;// $Log:   S:\h26x\src\dec\cx512162.asv  $
;// 
;//    Rev 1.8   22 Mar 1996 16:41:06   BNICKERS
;// Fix bug wherein UV contrib was being taken from one pel to the right.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:00   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 10:02:00   BNICKERS
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   16 Feb 1996 15:12:42   BNICKERS
;// Correct color shift.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:22   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:38:54   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:54   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:16   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:18   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by two.
; ||||||||
; cx512162 -- This function performs zoom-by-2 YUV12-to-RGB16 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  for H26x.  It handles any format in which there
;             are three fields, the low order field being B and fully contained
;             in the low order byte, the second field being G and being
;             somewhere in bits 4 through 11, and the high order field being
;             R and fully contained in the high order byte.  Present support
;             for 555, 565, 655, and 644 formats only.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD, AUPlane: DWORD, AFrameWidth: DWORD, AFrameHeight: DWORD,
AYPitch: DWORD, AVPitch: DWORD, AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD, ADCIOffset: DWORD, ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD, ACCType: DWORD

LocalFrameSize = 64+768*6+24
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
LineParity               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
StashOddLinePel0         EQU  [esp+72]
StashOddLinePel1         EQU  [esp+76]
StashOddLinePel2         EQU  [esp+80]
StashOddLinePel3         EQU  [esp+84]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0/2
  cmp   ebx,CCTYPE_RGB16555ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16555ZoomBy2DCI
  je    @f
  mov   ecx,4096/2
  cmp   ebx,CCTYPE_RGB16565ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16565ZoomBy2DCI
  je    @f
  mov   ecx,8192/2
  cmp   ebx,CCTYPE_RGB16655ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16655ZoomBy2DCI
  je    @f
  mov   ecx,12288/2
  cmp   ebx,CCTYPE_RGB16664ZoomBy2DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664ZoomBy2
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
   mov  StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  shl   ebx,2
   add  edx,esi
  sub   eax,ebx
   mov  YSkipDistance,ecx
  shr   ebx,3
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  YLimit,edx
  mov   esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,24
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-20],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  mov   esi,YCursor
   xor  ecx,ecx
  mov   [edi],ecx                    ; Store EOL indicator.
   mov  edx,CCType
  mov   dl,[esi]                     ; Fetch Y00.
   xor  ebx,ebx
  mov   bl,ChromaContribution        ; Get U contribution to B value.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3,edx         ; Stash offset to RGB table to use.
   mov  edi,CCOCursor
  mov   al,ChromaContribution+2      ; Get V contribution to R value.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+1      ; Get UV contribution to G value.
   mov  LineParity,ch
  and   eax,0FFH
   sub  esp,4608

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- Construction of a pel (twice) of RGB16.
;  edx -- Y value (i.e. Y contribution to R, G, and B) times 4, plus offset
;         to select appropriate table.
;  cl  -- UV contribution to G field of RGB value.
;  bl  -- U contribution to B field of RGB value.
;  al  -- V contribution to R field of RGB value.

DoLine1:
DoNext4YPelsOfLine0:

   mov  ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel00.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel00.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel00.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi],ebp                 ; Store Pel00 to color converted output.
   mov  dl,[esi+1]                   ; Fetch Y01.
  rol   ebp,16                       ; Swap Pel00 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel0+4608,ebp    ; Stash Pel00 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  add   edi,16                       ; Advance output cursor.
   add  esi,4                        ; Advance luma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel01.
   mov  bl,ChromaContribution+4+4608 ; Load U contribution to B val for pels2&3.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel01.
   mov  al,ChromaContribution+6+4608 ; Load V contribution to R val for pels2&3.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel01.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+4-16],ebp            ; Store Pel01 to color converted output.
   mov  dl,[esi+2-4]                 ; Fetch Y02.
  rol   ebp,16                       ; Swap Pel01 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel1+4608,ebp    ; Stash Pel01 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+5+4608 ; Load UV contrib to G val for pels2&3.
   add  esp,24                       ; Advance chroma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel02.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel02.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel02.
   mov  edx,StashOddLinePel3+4608-24 ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+8-16],ebp            ; Store Pel02 to color converted output.
   mov  dl,[esi+3-4]                 ; Fetch Y03.
  rol   ebp,16                       ; Swap Pel02 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y02 to 7 bits.
  mov   StashOddLinePel3+4608,edx    ; Stash offset to RGB table to use.
   add  edx,edx                      ; Get four times luma.
  mov   StashOddLinePel2+4608-24,ebp ; Stash Pel02 for later xfer to 2nd line.
   mov  esi,esi                      ; Keep pairing happy.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel03.
   mov  bl,ChromaContribution+0+4608 ; Load U contribution to B val for pels0&1.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+2+4608 ; Load V contribution to R val for pels0&1.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel03.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+12-16],ebp           ; Store Pel03 to color converted output.
   mov  dl,[esi]                     ; Fetch Y00.
  rol   ebp,16                       ; Swap Pel03 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3+4608-24,ebp ; Stash Pel03 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  test  eax,eax
   mov  cl,ChromaContribution+1+4608 ; Load UV contrib to G val for pels2&3.
  jne   DoNext4YPelsOfLine0
   
  and   esp,0FFFFE000H
  add   esp,02000H
  mov   edx,YSkipDistance
   mov  ebp,CCOSkipDistance
  add   esi,edx
   mov  ebx,AspectCount
  add   edi,ebp
   sub  ebx,2                    ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   lea  ecx,StashOddLinePel0
  mov   edx,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   eax,[ecx]
   mov  ebx,[ecx+4]
  mov   Ze [edi],eax
   mov  eax,[ecx+8]
  mov   Ze [edi+4],ebx
   mov  ebx,[ecx+12]
  mov   Ze [edi+8],eax
   add  ecx,24
  mov   Ze [edi+12],ebx
   add  edi,16
  sub   edx,4
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebp

Skip2ndLineOfLine0:

   mov  al,LineParity
  xor   al,1
   je   Line1Done

  mov   LineParity,al
   mov  edx,CCType
  mov   dl,[esi]
   xor  ebx,ebx
  mov   bl,ChromaContribution
   and  edx,0FFFFFFFEH
  mov   StashOddLinePel3,edx
   xor  ecx,ecx
  add   edx,edx
   mov  al,ChromaContribution+2
  mov   cl,ChromaContribution+1
   sub  esp,4608
  and   eax,0FFH
   jmp  DoLine1

Line1Done:

  mov   YCursor,esi
   mov  eax,esi
  mov   CCOCursor,edi
   mov  ecx,ChromaPitch
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cmemmod.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\common\cmemmod.inv   1.1   27 Dec 1995 14:12:08   RMCKENZX  $
;// $Log:   S:\h26x\src\common\cmemmod.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:12:08   RMCKENZX
;// 
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF memmodel_inc
ELSE

IFDEF WIN32
.486
.MODEL FLAT, STDCALL
Zd EQU <>
Ze EQU <>
Zf EQU <>
Zg EQU <>
Zs EQU <>
Zc EQU <>
BPTR equ ebp
SPTR equ esp
NAT_WORD TEXTEQU <DWORD>

ELSE

.MODEL MEDIUM
.486
Zd EQU <ds:>
Ze EQU <es:>
Zf EQU <fs:>
Zg EQU <gs:>
Zs EQU <ss:>
Zc EQU <cs:>
BPTR equ bp
SPTR equ sp
NAT_WORD TEXTEQU <WORD>

ENDIF

PD EQU <DWORD PTR>
PW EQU <WORD PTR>
PB EQU <BYTE PTR>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; this provides a normal return when under WIN32 and
;; a 16 bit mode instruction override when under not WIN32
;;
;; This is needed as the segment this code runs in is
;; in 32 bit mode but the caller is in 16 bit mode.
;;
;; under WIN32, we must relieve the stack of passed
;; args, and with proper setup of the PROC directive,
;; the assembler will calculate the correct value
;; to relieve every time it sees the ret.
;;
;; this also sets the language to 'C' when not under WIN32 and
;; stdcall when under WIN32
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifdef WIN32
LANG    TEXTEQU <stdcall>
DIST    TEXTEQU <>
rturn   MACRO
	ret
ENDM
else
LANG    TEXTEQU <C>
DIST    TEXTEQU <FAR>
rturn   MACRO
	db      66h
	retf
ENDM
endif

memmodel_inc=1

; this is intended to emulate a disabled epilouge with the single
; exception of relieving the stack of passed parameters if
; the calling type is STDCALL.
;
; only stdcall and c calling conventions are directly supported.
; VARARGS is not supported.
; NONE of the standard prologue or epilogue switches
; are used.
; Like the standard epilogue, the use of retf, retn or ret n
; where n is the number of bytes to relieve, this macro
; is effectively disabled.
ReturnAndRelieveEpilogueMacro MACRO procname, \
                                    flag,     \
                                    parmbytes, \
                                    localbytes, \
                                    reglist, \
                                    macroargs
LOCAL RET_DIST
if (flag AND 020h)
; We are in a FAR procedure
	RET_DIST TEXTEQU <retf>
else
; We are in a local procedure
	RET_DIST TEXTEQU <ret>
endif

if (flag AND 010h)
; user restoring the stack: ret n, retf or retn was used
	RET_DIST
else
; user expects us to restore the stack: ret was used
if (flag AND 007h) EQ 3
; stdcall calling convention
if parmbytes EQ 0
	RET_DIST
else
	RET_DIST		parmbytes
endif
else
; assume 'C' calling convention
	RET_DIST
endif

endif
ENDM

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx1209.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;// 
;// $Header:   S:\h26x\src\dec\cx51209.asv
;// 
;// $Log:   S:\h26x\src\dec\cx51209.asv
;// 
;////////////////////////////////////////////////////////////////////////////
; cx1209  -- This function performs YUV12 to IF09 color conversion for H26x.
;            IF09 consists of Y, V, U in 8-bit, planar format, plus a plane of
;            4-bit flags, each in 8 bits of storage, with each bit indicative
;            of which dwords of Y are unchanged from the previous frame.
;            IF09 is only applicable using DCI.
;
;            This version is tuned for maximum performance on both the Pentium
;            (r) microcprocessor and the Pentium Pro (tm) microprocessor.
;
;            Indentation of instructions indicates expected U/V pipe execution
;            on Pentium (r) microprocessor;  indented instructions are
;            expected to execute in V-pipe, outdented instructions in U-pipe.
;            Inside loops, blank lines delineate groups of 1, 2, or 3
;            instructions that are expected to be decoded simultaneously
;            on the Pentium Pro (tm) microprocessor.
;
; cx1209
; ^^^^^^
; ||||++----- Convert to IF09.
; ||++------- Convert from YUV12.
; |+--------- For both H261 and H263.
; +---------- Color convertor.
;-------------------------------------------------------------------------------
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx1209>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

PUBLIC  YUV12ToIF09
YUV12ToIF09    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AUVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

; void * YUV12ToIF09 (
;       U8 * YPlane,
;       U8 * VPlane,
;       U8 * UPlane,
;       UN  FrameWidth,
;       UN  FrameHeight,
;       UN  YPitch,
;       UN  UVPitch,
;       UN  AspectAdjustmentCount,
;       U8 * ColorConvertedFrame,
;       U32 DCIOffset,
;       U32 CCOffsetToLine0,
;       IN  CCOPitch,
;       IN  CCType)
;
;  YPlane and VPlane are offsets relative to InstanceBase.  In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;
IFDEF WIN32

LocalFrameSize = 32
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
FrameWidth               = LocalFrameSize + RegisterStorageSize + 12
FrameHeight              = LocalFrameSize + RegisterStorageSize + 16
YPitch                   = LocalFrameSize + RegisterStorageSize + 20
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 24
DCIOffset                = LocalFrameSize + RegisterStorageSize + 28
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 32
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 36
CCType                   = LocalFrameSize + RegisterStorageSize + 40
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 44

; Locals (on local stack frame)

CCOCursor                  =   0
YLimit                     =   4
CCOVCursor                 =   8
CCOUCursor                 =  12
CCOSkipCursor              =  16
VLimit                     =  20
YLine1Limit                =  24
CCOUVPitch                 =  28

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
FrameWidth_arg             = RegisterStorageSize + 16
FrameHeight_arg            = RegisterStorageSize + 18
YPitch_arg                 = RegisterStorageSize + 20
ColorConvertedFrame        = RegisterStorageSize + 22
ColorConvertedFrame_SegNum = RegisterStorageSize + 24
DCIOffset                  = RegisterStorageSize + 26
CCOffsetToLine0            = RegisterStorageSize + 30
CCOPitch_arg               = RegisterStorageSize + 34
EndOfArgList               = RegisterStorageSize + 36

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
YLimit                     = LocalStorageCC +   4
CCOVCursor                 = LocalStorageCC +   8
CCOUCursor                 = LocalStorageCC +  12
CCOSkipCursor              = LocalStorageCC +  16
VLimit                     = LocalStorageCC +  20
YLine1Limit                = LocalStorageCC +  24
CCOUVPitch                 = LocalStorageCC +  28
YPlane                     = LocalStorageCC +  32
VPlane                     = LocalStorageCC +  36
FrameWidth                 = LocalStorageCC +  40
FrameHeight                = LocalStorageCC +  44
YPitch                     = LocalStorageCC +  48
CCOPitch                   = LocalStorageCC +  52

LCL EQU <>

ENDIF

  push    esi
  push    edi
  push    ebp
  push    ebx
IFDEF WIN32
  sub     esp,LocalFrameSize
  mov     eax,PD [esp+ColorConvertedFrame]
  add     eax,PD [esp+DCIOffset]
  add     eax,PD [esp+CCOffsetToLine0]
  mov     PD [esp+CCOCursor],eax
ELSE
  xor     eax,eax
  mov     eax,ds
  push    eax
  mov     ebp,esp
  and     ebp,00000FFFFH
  mov     ds, PW [ebp+InstanceBase_SegNum]
  mov     es, PW [ebp+ColorConvertedFrame_SegNum]

  mov     ebx,PD [ebp+YPlane_arg]           ; Make YPlane accessible
  mov     ds:PD YPlane,ebx
  mov     ebx,PD [ebp+VPlane_arg]           ; Make VPlane accessible.
  mov     ds:PD VPlane,ebx
  mov     ax,PW [ebp+FrameWidth_arg]        ; Make FrameWidth accessible
  mov     ds:PD FrameWidth,eax
  mov     ax,PW [ebp+FrameHeight_arg]       ; Make FrameHeight accessible
  mov     ds:PD FrameHeight,eax
  mov     ax,PW [ebp+YPitch_arg]            ; Make YPitch accessible
  mov     ds:PD YPitch,eax
  mov     ax,PW [ebp+ColorConvertedFrame]   ; Init CCOCursor
  add     eax,PD [ebp+DCIOffset]
  mov     ds:PD CCOCursor,eax
  movsx   ebx,PW [ebp+CCOPitch_arg]         ; Make CCOPitch accessible
  mov     ds:PD CCOPitch,ebx
ENDIF
  Ledx    FrameHeight
   Lebx   CCOPitch
  shr     ebx,2                    ; UV pitch for the output
   Lecx   YPitch
  add     ebx,3                    ; Pitch is always a multiple of 4.
   Lebp   CCOPitch
  and     ebx,0FFFFFFFCH
   Lesi   YPlane                   ; Fetch cursor over luma plane.
  Sebx    CCOUVPitch
   Leax   CCOCursor
  imul    ecx,edx                  ; ecx: size of Y input.
  imul    ebp,edx                  ; ebp: was CCOPitch, now size of Y output.
  imul    ebx,edx                  ; ebp: size of U/V output (times 4).
  add     ecx,esi                  ; ecx: Ylimit
   add    eax,ebp                  ; eax was CCOCursor, now CCOVCursor
  Secx    YLimit
   Seax   CCOVCursor
  sar     ebx,2                    ; ebx: UVsize of output
   Lecx   FrameWidth               ; ecx: Y frame width
  add     esi,ecx                  ; esi: end of first input Y
   add    eax,ebx                  ; eax: now CCOUCursor
  shr     ecx,2
   Seax   CCOUCursor
  Lebp    VPlane                   ; ebp Vplane input
   Ledx   YPitch
  lea     esi,[edx+esi]            ; End of Y line 1
   add    ebp,ecx                  ; end of Vline
  Sesi    YLine1Limit
   add    eax,ebx                  ; CCO Skip Blocks
  Sebp    VLimit                   ; UV width for input
   Seax   CCOSkipCursor

; Prepare the UV contribution to decide the skip blocks, and copy chroma
; planes at the same time.
;
; Register usage:
;
; esi: V plane input pointer
; edi; V output pointer
; ebp: U output pointer
; edx: Y plane input pointer
; ecx: V limit
; ebx: Work area for U
; eax: Work area for V

ChromaPrep:

  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Ledx    YPlane
   Leax   YPitch
  Lesi    VPlane
   Lecx   VLimit
  sub     edi,esi            ; make edi offset to esi.
   sub    ebp,esi            ; make ebp offset to esi to save inc in the loop.
  lea     edx,[eax+edx-1296] ; make edx point at place for chroma prep.
   mov    eax,PD [esi]           ; fetch four V
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

ChromaLoop:

  mov     Ze PD[esi+edi*1],eax   ; Store four V.
   mov    ebx,PD [esi+UOFFSET]   ; fetch four U
  add     esi,4

   mov    PD [edx],eax           ; Store four V to chroma-prep line in Y frame.
  add     edx,16                 ; Advance chroma-prep cursor.
   add    ebx,ebx                ; Change to 8-bit.  (Low bit undef, usually 0).

  mov     Ze PD[esi+ebp*1-4],ebx ; Store four U.
   mov    eax,PD [esi]           ; fetch next four V.
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

   mov    PD [edx-12],ebx        ; Store four U to chroma-prep line in Y frame.
  mov     bl,Ze PB [esi+edi*1]   ; Pre-load output cache line
   cmp    esi,ecx

  mov     bl,Ze PB [esi+ebp*1]   ; Pre-load output cache line
   jb     ChromaLoop

; update chroma pointers.

  add     ecx,VPITCH
   Lebx   CCOUVPitch
  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Secx    VLimit
   add    edi,ebx              ; update V output ptr to the next line
  Leax    VPlane
   add    ebp,ebx              ; update U output ptr to the next line
  Sedi    CCOVCursor
   add    eax,VPITCH
  Sebp    CCOUCursor
   Seax   VPlane

; now do Luma a row of 4x4 blocks
;
; register usage:
;
; esi: Y cursor
; edi: CCOCursor
; ebp: counts down 4 lines of luma.
; ecx: counts down frame width.
; ebx: Y Pitch.
; eax: Work area.

; copy a row of 4x4 luma

  Lesi    YPlane
   Lecx   FrameWidth
  Ledi    CCOCursor
   add    esi,ecx
  neg     ecx
   Lebx   YPitch

  sub     edi,ecx
   mov    eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
   mov    ebp,4

YLoop:

  mov     Ze PD[edi+ecx],eax   ; Store them to IF09 output, Y plane.
   mov    eax,PD[esi+ecx+4]    ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.

   add    ecx,4                ; Advance induction variable.
  jl      YLoop

YLoopDone:

  Lecx    FrameWidth
   add    esi,ebx
  add     edi,ecx
   neg    ecx
  mov     eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
  dec     ebp
   jne    YLoop

  add     edi,ecx
  Sedi    CCOCursor           ; save the output ptr for next four lines

; Build the skip block mask
;
; Register usage:
;
; esi: Y ptr
; edi: Mask Ptr
; ebp: Y Pitch
; edx: mask
; ecx: Archive value
; ebx: UV contribution
; eax: Dword of Y pels
;
; Y starts with Line 1 of 4x4 blocks, since UV pattern has been saved
; relative to line 1.

  Lesi    YPlane
   Lebp   YPitch
  Ledi    CCOSkipCursor
   add    esi,ebp                          ; esi point at line 1 of luma

BuildSkipDescrLoop:

  mov     ebx,PD [esi-1296]         ; Fetch 4 U's;  byte0 corresponds to this Y.
   mov    eax,PD [esi-1292]         ; Fetch 4 V's;  byte0 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,0000000FCH            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1300]         ; Fetch 4 U's;  byte1 corresponds to this Y.
   mov    eax,PD [esi-1296]         ; Fetch 4 V's;  byte1 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,00000FC00H            ; Extract 6 bits of V.
  and     ebx,007E00000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1304]         ; Fetch 4 U's;  byte2 corresponds to this Y.
   mov    eax,PD [esi-1300]         ; Fetch 4 V's;  byte2 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   and    eax,000FC0000H            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1308]         ; Fetch 4 U's;  byte3 corresponds to this Y.
   mov    eax,PD [esi-1304]         ; Fetch 4 V's;  byte3 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.
  shr     eax,26                    ; Extract 6 bits of V.
   and    ebx,007E00000H            ; Extract 6 bits of U.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   jne    BuildSkipDescrLoop

BuildSkipDescrLoopDone:


  add     edi,3               ; Round to next dword.
   lea    ebx,[ebx+ebp*4]     ; update YLine1Limit for next row of blocks
  and     edi,0FFFFFFFCH
   Lesi   YPlane
  Sedi    CCOSkipCursor
   Sebx   YLine1Limit
  lea     esi,[esi+ebp*4]
   Leax   YLimit
  Sesi    YPlane
   cmp    esi,eax
  jl      ChromaPrep

IFDEF WIN32
  add     esp,LocalFrameSize
ELSE
  pop     ebx
  mov     ds,ebx
ENDIF
  pop     ebx
  pop     ebp
  pop     edi
  pop     esi
  rturn

YUV12ToIF09 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512161.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;//
;// $Header:   S:\h26x\src\dec\cx512161.asv
;//
;// $Log:   S:\h26x\src\dec\cx512161.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:44   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Mar 1996 15:51:18   BNICKERS
;// Made this function non-destructive on input.  Only works on flat model now.
;// 
;//    Rev 1.4   05 Feb 1996 13:34:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   27 Dec 1995 14:35:40   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:50   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:20   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:26   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For H263 or H261.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512161 -- This function performs YUV12-to-RGB16 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles any format in which there are three fields, the low
;             order field being B and fully contained in the low order byte, the
;             second field being G and being somewhere in bits 4 through 11, 
;             and the high order field being R and fully contained in the high
;             order byte.  Formats presently supported:  555, 565, 655, and 664.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN   FrameWidth,
;                                     UN   FrameHeight,
;                                     UN   YPitch,
;                                     UN   VPitch,
;                                     UN   AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32  DCIOffset,
;                                     U32  CCOffsetToLine0,
;                                     IN   CCOPitch,
;                                     IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0
  cmp   ebx,CCTYPE_RGB16555
  je    @f
  cmp   ebx,CCTYPE_RGB16555DCI
  je    @f
  mov   ecx,2048
  cmp   ebx,CCTYPE_RGB16565
  je    @f
  cmp   ebx,CCTYPE_RGB16565DCI
  je    @f
  mov   ecx,4096
  cmp   ebx,CCTYPE_RGB16655
  je    @f
  cmp   ebx,CCTYPE_RGB16655DCI
  je    @f
  mov   ecx,6144
  cmp   ebx,CCTYPE_RGB16664DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,1
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   CCOSkipDistance,eax
   mov  YLimit,edx
  mov   YCursor,esi
   mov  esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   mov  ebx,AspectCount
  mov   [edi],ecx                   ; Store EOL indicator.
   mov  eax,CCType
  xor   edx,edx
   mov  edi,CCOCursor
  dec   ebx                         ; If count is non-zero, we keep the line.
   mov  esi,YCursor
  mov   AspectCount,ebx
   jne  KeepLine0

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine0

KeepLine0:

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- U contribution to B field of RGB value.
;  edx -- V contribution to R field of RGB value.
;         Clamped, positioned G value.
;  ecx -- UV contribution to G field of RGB value.
;         Clamped, positioned G value.
;  ebx -- Construction of two pels of RGB16.
;  al -- Y value (i.e. Y contribution to R, G, and B);

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine0:

  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel01.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel01.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel01.
  or    ebx,edx                        ; Combine RGB16 value for Pel01.
   mov  al,[esi]                       ; Fetch Y00.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel01.
   mov  dl,ChromaContribution+1536+2   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel00.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel00.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]             ; Get clamped R value for Pel00.
  or    ebx,ecx                        ; Combine RGB16 value for Pel00.
   mov  al,[esi+3]                     ; Fetch Y03. 
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4  ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+5   ; Get UV contribution to G value.
  mov   dl,ChromaContribution+1536+6   ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  mov   Ze [edi],ebx                   ; Write the 2 pels to output.
   add  esi,4                          ; Advance Y line cursor
  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel03.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel03.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel03.
  or    ebx,edx                        ; Combine RGB16 value for Pel03.
   mov  al,[esi+2-4]                   ; Fetch Y02.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel03.
   mov  dl,ChromaContribution+1536+6   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel02.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel02.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]          ; Get clamped R value for Pel02.
  or    ebx,ecx                        ; Combine RGB16 value for Pel02.
   mov  al,[esi+5-4]                   ; Fetch Y05.
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8  ; Get next pel's U contrib to B value.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+9   ; Get next pel's UV contrib to G value.
  mov   Ze [edi+4],ebx                 ; Write the 2 pels to output.
   add  edi,8                          ; Advance color converted output cursor.
  mov   dl,ChromaContribution+1536+10  ; Get next pel's V contrib to R value.
   and  ebp,0FFH                       ; Extract U contribution to G value.
  lea   esp,[esp+8]                    ; Advance Chroma contribution cursor.
   jne  DoNext4YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   ebp,YSkipDistance
   mov  ebx,AspectCount
  add   esi,ebp
   dec  ebx                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine1

KeepLine1:

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine1:

  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+2
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+3]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4
  shr   al,1
   mov  cl,ChromaContribution+1536+5
  mov   dl,ChromaContribution+1536+6
   and  ebp,0FFH
  mov   Ze [edi],ebx
   add  esi,4
  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi+2-4]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+6
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+5-4]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8
  shr   al,1
   mov  cl,ChromaContribution+1536+9
  mov   Ze [edi+4],ebx
   add  edi,8
  mov   dl,ChromaContribution+1536+10
   and  ebp,0FFH
  lea   esp,[esp+8]
   jne  DoNext4YPelsOfLine1

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine1:

   mov  eax,YSkipDistance           ; Inc LumaCursor to next line.
  add   eax,esi
   mov  ecx,ChromaPitch
  mov   CCOCursor,edi
   mov  YCursor,eax
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx51224z.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512242.asv
;//
;// $Log:   S:\h26x\src\dec\cx512242.asv  $
;// 
;//    Rev 1.8   20 Mar 1996 10:57:22   bnickers
;// Fix numerous bugs.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:22   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 09:58:36   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:36   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   22 Dec 1995 15:42:18   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.3   30 Oct 1995 17:15:32   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 17:49:36   CZHU
;// Fix a whole bunch of bugs.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:28   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cx512242 -- This function performs YUV12-to-RGB24 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
B0R0G0B0                 EQU  [esp+72]
G1B1R0G0                 EQU  [esp+76]
R1G1B1R1                 EQU  [esp+80]
B2R2G2B2                 EQU  [esp+84]
G3B3R2G2                 EQU  [esp+88]
R3G3B3R3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax

DoLine1:
                                     ;                                           EAX                 EBX                ECX              EDX              EBP
  xor   ebx,ebx                      ;                                           -- -- -- --        >-- -- -- --        ?? ?? ?? ??      ?? ?? ?? ??     ?? ?? ?? ??
   xor  ecx,ecx                      ;                                           -- -- -- --         -- -- -- --       >-- -- -- --      ?? ?? ?? ??     ?? ?? ?? ??
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.       -- -- -- --         -- -- -- --        -- -- -- --      ?? ?? ?? ??     AA AA AA AA
   xor  edx,edx                      ;                                           -- -- -- --         -- -- -- --        -- -- -- --     >-- -- -- --     AA AA AA AA
  mov   cl,[esi]                     ; Fetch Y0.                                 -- -- -- --         -- -- -- --      m>-- -- -- y0      -- -- -- --     AA AA AA AA
   mov  bl,ChromaContribution+3      ; Fetch U contrib to B value.               -- -- -- --       m>-- -- -- uB01      -- -- -- y0      -- -- -- --     AA AA AA AA
  mov   dl,ChromaContribution+2      ; Fetch UV contrib to G value.              -- -- -- --         -- -- -- uB01      -- -- -- y0    m>-- -- -- uvG01  AA AA AA AA
   and  ebp,0000001FFH               ; Extract V contrib to R.                   -- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01 >-- -- -1 AA
  mov   edi,CCOCursor                ;                                           -- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
   sub  esp,6144                     ;                                           -- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
  xor   eax,eax                      ;                                          >-- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B                          m>-- -- -- B0        <-- -- -- uB01     <-- -- -- y0      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.	                         -- -- -- B0       m>-- -- R0 uB01     <-- -- -- y0      -- -- -- uvG01  <-- -- -1 AA
  mov    bl,PB G24Value[ecx+edx]       ; Fetch Pel0 G.                           -- -- -- B0       m>-- -- R0 G0       <-- -- -- y0     <-- -- -- uvG01   -- -- -1 AA
   mov   cl,[esi+1]                    ; Fetch Y1.                               -- -- -- B0         -- -- R0 G0      m>-- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  shl    ebx,8                         ;                                         -- -- -- B0        >-- R0 G0 --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA

  shl    ebx,8                         ;                                         -- -- -- B0        >R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.							 -- -- -- B0       m>R0 G0 G1 --       <-- -- -- y1     <-- -- -- uvG01   -- -- -1 AA
  mov    dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.           -- -- -- B0         R0 G0 G1 --        -- -- -- y1    m>-- -- -- uB01    -- -- -1 AA
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.                           -- -- -- B0       m>R0 G0 G1 B1       <-- -- -- y1     <-- -- -- uB01    -- -- -1 AA
  add    al,bl                         ; Fetch Pel1 B.                         r>-- -- -- B0+B1      R0 G0 G1 B1        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   shr   al,1                          ; Fetch Pel1 B.                          >-- -- -- B01        R0 G0 G1 B1        -- -- -- y1      -- -- -- uB01    -- -- -1 AA


  or     eax,ebx                       ;									   r>-- R0 G0 B0        <-- R0 G0 --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.							 -- R0 G0 B0       m>-- R0 G1 --       <-- -- -- y1     <-- -- -- uvG01   -- -- -1 AA
  mov    dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.           -- R0 G0 B0         -- R0 G1 --        -- -- -- y1    m>-- -- -- uB01    -- -- -1 AA
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.                           -- R0 G0 B0       m>-- R0 G1 B1       <-- -- -- y1     <-- -- -- uB01    -- -- -1 AA
  rol    ebx,16                        ; Make room for R1                        -- R0 G0 B0        >G1 B1 -- R0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   dl,bl                         ; Save R0.                                -- R0 G0 B0         G1 B1 -- R0        -- -- -- y1     >-- -- -- R0      -- -- -1 AA
  mov    bl,PB R24Value[ecx+ebp*1]     ; Fetch Pel1 R1.                          -- R0 G0 B0        >G1 B1 -- R1       <-- -- -- y1      -- -- -- R0     <-- -- -1 AA
   add   dl,bl                         ; Add R1 to R0.                           -- R0 G0 B0         G1 B1 -- R1        -- -- -- y1     >-- -- -- R0+R1   -- -- -1 AA
  shr    edx,1                         ; Compute (R1+R0)/2.                      -- R0 G0 B0         G1 B1 -- R1        -- -- -- y1     >-- -- -- R01     -- -- -1 AA
   mov   bh,dl                         ; Save R01.                               -- R0 G0 B0        >G1 B1 R01R1        -- -- -- y1     <-- -- -- R01     -- -- -1 AA
  rol    ebx,16                        ; Reorder components.                     -- R0 G0 B0        >R01R1 G1 B1        -- -- -- y1      -- -- -- R01     -- -- -1 AA
   mov   dl,al                         ; Copy B0.                               <-- R0 G0 B0         R01R1 G1 B1        -- -- -- y1    r>-- -- -- B0      -- -- -1 AA
  mov    cl,bh                         ; Copy G1.                                -- R0 G0 B0        <R01R1 G1 B1      r>-- -- -- G1      -- -- -- B0      -- -- -1 AA
   add   dl,bl                         ; Add B1 to B0.                           -- R0 G0 B0        <R01R1 G1 B1        -- -- -- G1    r>-- -- -- B0+B1   -- -- -1 AA
  add    cl,ah                         ; Add G0 to G1.                          <-- R0 G0 B0         R01R1 G1 B1      r>-- -- -- G1+G0   -- -- -- B0+B1   -- -- -1 AA
   shr   edx,1                         ; Compute (B1+B0)/2.                      -- R0 G0 B0         R01R1 G1 B1        -- -- -- G1+G0  >-- -- -- B01     -- -- -1 AA
  shr    ecx,1                         ; Compute (G1+G0)/2.                      -- R0 G0 B0         R01R1 G1 B1       >-- -- -- G01     -- -- -- B01     -- -- -1 AA
   shl   ecx,24                        ; Reorder nibbles.                        -- R0 G0 B0         R01R1 G1 B1        -- -- -- G01    >B01-- -- --      -- -- -1 AA
  or     eax,edx                       ; Reorder nibbles.                      r>B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01    <B01-- -- --      -- -- -1 AA
   mov   Ze [edi],eax                  ; Save B01R0G0B0.                       m<B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01     B01-- -- --      -- -- -1 AA
  mov    edx,ebx                       ;                                         B01R0 G0 B0        <R01R1 G1 B1        -- -- -- G01    >R01R1 G1 B1      -- -- -1 AA
   rol   edx,16                        ;                                         B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01    >G1 B1 R01R1      -- -- -1 AA
  mov    dl,cl                         ;                                         B01R0 G0 B0         R01R1 G1 B1       <-- -- -- G01    >R1 B1 R01G01     -- -- -1 AA
   mov   Ze [edi+4],edx                ; Save R1B1R01G01.                        B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01   m<R1 B1 R01G01     -- -- -1 AA

   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.     B0 R0 G0 B0         G1 B1 R0 R1        -- -- -- y1      -- -- -- uB01    BB BB BB BB
  mov    bh,bl                         ; Copy Pel1 R.                            B0 R0 G0 B0        >G1 B1 R1 R1        -- -- -- y1      -- -- -- uB01    BB BB BB BB
   mov   cl,[esi+2]                    ; Fetch Y2.                               B0 R0 G0 B0         G1 B1 R1 R1      m>-- -- -- y2      -- -- -- uB01    BB BB BB BB
  ror    ebx,8                         ; Third output:                           B0 R0 G0 B0        >R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01    BB BB BB BB
   and   ebp,0000001FFH                ; Extract V contrib to R.                 B0 R0 G0 B0        >R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01    -- -- -1 BB
  mov    dl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2     >-- -- -- uvG23   -- -- -1 BB
   xor   eax,eax                       ;                                        >-- -- -- --         R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    al,ChromaContribution+6144+7  ; Fetch U contrib to B value.            >-- -- -- uB23       R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   R1G1B1R1+6144,ebx             ; Stash for saving to second line.        -- -- -- uB23     m<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    Ze [edi+8],ebx                ; Save R1G1B1R1.                          -- -- -- uB23     m<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   xor   ebx,ebx                       ;                                         -- -- -- uB23      >-- -- -- --        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    bh,PB B24Value[ecx+eax*2]     ; Fetch Pel2 B.                          <-- -- -- uB23      >-- -- B2 --       <-- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.                          >-- -- R2 uB23       -- -- B2 --       <-- -- -- y2      -- -- -- uvG23  <-- -- -1 BB
  mov    al,PB G24Value[ecx+edx]       ; Fetch Pel2 G.                          >-- -- R2 G2         -- -- B2 --       <-- -- -- y2     <-- -- -- uvG23   -- -- -1 BB
   mov   cl,[esi+3]                    ; Fetch Y3.                               -- -- R2 G2         -- -- B2 --       >-- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  shl    eax,16                        ;                 R2 G2 -- --            >R2 G2 -- --         -- -- B2 --        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   bl,bh                         ; Copy Pel2 B.    -- -- B2 B2             R2 G2 -- --        >-- -- B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  or     ebx,eax                       ;                 R2 G2 B2 B2             R2 G2 -- --        >R2 G2 B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R2 G2 G3 --            >R2 G2 G3 --         R2 G2 B2 B2       <-- -- -- y3     <-- -- -- uvG23   -- -- -1 BB
  ror    ebx,8                         ; Fourth output:  B2 R2 G2 B2             R2 G2 G3 --        >B2 R2 G2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   dl,ChromaContribution+6144+7  ; Refetch U contrib to B value.           R2 G2 G3 --         B2 R2 G2 B2        -- -- -- y3     >-- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+12],ebx               ; Save B2R2G2B2.                          R2 G2 G3 --       m<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   al,PB B24Value[ecx+edx*2]     ; Fetch Pel3 B.   R2 G2 G3 B3           m>R2 G2 G3 B3         B2 R2 G2 B2       <-- -- -- y3     <-- -- -- uB23    -- -- -1 BB
  rol    eax,16                        ; Fifth output:   G3 B3 R2 G2            >G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   B2R2G2B2+6144,ebx             ; Stash for saving to second line.        G3 B3 R2 G2       m<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+16],eax               ; Save G3B3R2G2.                        m<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   G3B3R2G2+6144,eax             ; Stash for saving to second line.      m<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.   G3 B3 -- R3           m>G3 B3 R2 R3         B2 R2 G2 B2       <-- -- -- y3      -- -- -- uB23   <-- -- -1 BB
   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.     G3 B3 R2 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23  m>CC CC CC CC
  mov    ah,al                         ; Copy Pel3 R.    G3 B3 R3 R3            >G3 B3 R3 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    CC CC CC CC
   mov   cl,[esi+4]                    ; Fetch Y4.                               G3 B3 R3 R3         B2 R2 G2 B2       >-- -- -- y4      -- -- -- uB23    CC CC CC CC
  ror    eax,8                         ; Sixth output:   R3 G3 B3 R3            >R3 G3 B3 R3         B2 R2 G2 B2        -- -- -- y4      -- -- -- uB23    CC CC CC CC
   xor   ebx,ebx                       ;                                         R3 G3 B3 R3        >-- -- -- --        -- -- -- y4      -- -- -- uB23    CC CC CC CC
  mov    dl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.            R3 G3 B3 R3         -- -- -- --        -- -- -- y4    m>-- -- -- uvG45   CC CC CC CC
   and   ebp,0000001FFH                ; Extract U contrib to B.                 R3 G3 B3 R3         -- -- -- --        -- -- -- y4      -- -- -- uvG45  >-- -- -1 CC
  mov    bl,ChromaContribution+6144+35 ; Fetch U contrib to B value.             R3 G3 B3 R3        >-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   lea   esi,[esi+4]                   ; Advance input cursor.                   R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
  mov    Ze [edi+20],eax               ; Save R3G3B3R3.                        m<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   mov   R3G3B3R3+6144,eax             ; Stash for saving to second line.      m<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
  mov    eax,ebx                       ;                                       r>-- -- -- uB45      <-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 C
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,B0R0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512242.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512242.asv
;//
;// $Log:   S:\h26x\src\dec\cx512242.asv  $
;// 
;//    Rev 1.8   20 Mar 1996 10:57:22   bnickers
;// Fix numerous bugs.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:22   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 09:58:36   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:36   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   22 Dec 1995 15:42:18   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.3   30 Oct 1995 17:15:32   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 17:49:36   CZHU
;// Fix a whole bunch of bugs.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:28   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cx512242 -- This function performs YUV12-to-RGB24 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

IFDEF USE_BILINEAR_MSH26X

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
BaR0G0B0                 EQU  [esp+72]
G1B1RaGa                 EQU  [esp+76]
RbGbBbR1                 EQU  [esp+80]
BcR2G2B2                 EQU  [esp+84]
G3B3RcGc                 EQU  [esp+88]
RdGdBdR3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax
                                     ;                                           EAX                 EBX                ECX              EDX              EBP
   mov  edx,FrameWidth               ;                                           ?? ?? ?? ??         ?? ?? ?? ??        ?? ?? ?? ??     >-- -- -- --      ?? ?? ?? ??
   add  edx,YSkipDistance            ;                                           ?? ?? ?? ??         ?? ?? ?? ??        ?? ?? ?? ??     >-- -- delta      ?? ?? ?? ??

DoLine1:
  xor   ebx,ebx                      ;                                           ?? ?? ?? ??        >-- -- -- --        ?? ?? ?? ??      -- -- delta      ?? ?? ?? ??
   xor  ecx,ecx                      ;                                           ?? ?? ?? ??         -- -- -- --       >-- -- -- --      -- -- delta      ?? ?? ?? ??
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.       ?? ?? ?? ??         -- -- -- --        -- -- -- --      -- -- delta     >AA AA AA AA
  mov   cl,[esi]                     ; Fetch Y0.                                 ?? ?? ?? ??         -- -- -- --      m>-- -- -- y0      -- -- delta      AA AA AA AA
   mov  bl,ChromaContribution+2      ; Fetch UV contrib to G value.              ?? ?? ?? ??       m>-- -- -- uvG01     -- -- -- y0      -- -- delta      AA AA AA AA
   and  ebp,0000001FFH               ; Extract V contrib to R.                   ?? ?? ?? ??         -- -- -- uvG01     -- -- -- y0      -- -- delta     >-- -- -1 AA
  mov   edi,CCOCursor                ;                                           ?? ?? ?? ??         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 AA
   sub  esp,6144                     ;                                           ?? ?? ?? ??         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 AA

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  xor   eax,eax                        ;                                        >-- -- -- --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 AA
   mov   al,[esi+1]                    ; Fetch Y1.                             m>-- -- -- y1         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  add    eax,ecx                       ; Add Y0 to Y1.                          >-- -- -- y1+y0      -- -- -- uvG01    <-- -- -- y0      -- -- delta      -- -- -1 vR01
  shl    eax,23                        ; Low bit will be nuked by R0.           >ya -- -- --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pel0 G.                         m>ya -- G0 --        <-- -- -- uvG01    <-- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   bl,ChromaContribution+6144+3  ; Fetch U contrib to B value.             ya -- G0 --       m>-- -- -- uB01      -- -- -- y0      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B.                         m>ya -- G0 B0        <-- -- -- uB01     <-- -- -- y0      -- -- delta      -- -- -1 vR01
  rol    eax,16                        ;                                        >G0 B0 ya --         -- -- -- uB01      -- -- -- y0      -- -- delta      -- -- -1 vR01
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.                         m>G0 B0 ya R0         -- -- -- uB01     <-- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   cl,ah                         ;                                        <G0 B0 ya R0         -- -- -- uB01     >-- -- -- ya      -- -- delta      -- -- -1 vR01
   mov   ah,PB B24Value[ecx+ebx*2]     ; Fetch Pela B.                         m>G0 B0 Ba R0        <-- -- -- uB01     <-- -- -- ya      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;                                        >Ba R0 G0 B0         -- -- -- uB01      -- -- -- ya      -- -- delta      -- -- -1 vR01
  mov    Ze [edi],eax                  ; First output.                         m<Ba R0 G0 B0         -- -- -- uB01      -- -- -- ya      -- -- delta      -- -- -1 vR01

  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Ba R0 G0 B0       m>-- -- -- uvG01     -- -- -- ya      -- -- delta      -- -- -1 vR01
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pela G.                         m>Ba R0 G0 Ga        <-- -- -- uvG01    <-- -- -- ya      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pela R.                         m>Ba R0 Ra Ga         -- -- -- uvG01    <-- -- -- ya      -- -- delta      -- -- -1 vR01
   mov   cl,[esi+1]                    ; Fetch Y1.                               Ba R0 Ra Ga         -- -- -- uvG01   m>-- -- -- y1      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Ra Ga -- --         -- -- -- uvG01     -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pel1 G.                         m>Ra Ga G1 --        <-- -- -- uvG01    <-- -- -- y1      -- -- delta      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+3  ; Fetch U contrib to B value.              Ra Ga G1 --       m>-- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel1 B.                         m>Ra Ga G1 B1        <-- -- -- uB01     <-- -- -- y1      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;										>G1 B1 Ra Ga         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov    Ze [edi+4],eax                ; Second output.					       m<G1 B1 Ra Ga         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   al,[esi+2]                    ; Fetch Y2.                             m>-- -- -- y2         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
   add   eax, ecx                      ; Add Y1 to Y2							>-- -- -- y2+y1      -- -- -- uB01     <-- -- -- y1      -- -- delta      -- -- -1 vR01
   shl   eax, 7                        ; Low bit will be nuked by R1.           >-- -- yb --         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov   al,PB R24Value[ecx+ebp*1]      ; Fetch Pel1 R.                         m>-- -- yb R1         -- -- -- uB01     <-- -- -- y1      -- -- delta      -- -- -1 vR01
  mov   cl,ah                          ;                                        <-- -- yb R1         -- -- -- uB01     >-- -- -- yb      -- -- delta      -- -- -1 vR01
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelb B.                         m>-- -- Bb R1        <-- -- -- uB01     <-- -- -- yb      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Bb R1 -- --         -- -- -- uB01      -- -- -- yb      -- -- delta      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Bb R1 -- --       m>-- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01
   mov   al,PB G24Value[ecx+ebx]       ; Fetch Pelb G.                         m>Bb R1 -- Gb        <-- -- -- uvG01    <-- -- -- yb      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelb R.                         m>Bb R1 Rb Gb         -- -- -- uvG01    <-- -- -- yb      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;										>Rb Gb Bb R1         -- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01
  mov    Ze [edi+8],eax                ; Third output.					       m<Rb Gb Bb R1         -- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01

  xor   eax,eax                        ;                                        >-- -- -- --         -- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01
   mov   cl,[esi]                      ; ReFetch Y0.                             -- -- -- --         -- -- -- uvG01   m>-- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   al,[esi+edx+1]                ; Fetch Y128.                           m>-- -- -- y128       -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  add   eax,ecx                        ; Add Y0 to Y128.                       m>-- -- -- y128+y0    -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
   shl   eax, 16                       ;                                        >-- ++ -- --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   al,[esi+edx]                  ; Fetch Y127.                           m>-- ++ -- y127       -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  add    eax,ecx                       ; Add Y0 to Y127                         >-- ++ -- y127+y0    -- -- -- uvG01    <-- -- -- y0      -- -- delta      -- -- -1 vR01
   shl   eax,7                         ; Normalize Y0 + Y127, and Y0 + Y128     >yt -- ys --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  mov    cl,ah                         ;                                        <yt -- ys --         -- -- -- uvG01    >-- -- -- ys      -- -- delta      -- -- -1 vR01
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pels G.                         m>yt -- Gs Bs        <-- -- -- uvG01    <-- -- -- ys      -- -- delta      -- -- -1 vR01
  mov    bl,ChromaContribution+6144+3  ; Fetch U contrib to B value.             yt -- Gs Bs       m>-- -- -- uB01      -- -- -- ys      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pels B.                         m>yt -- -- Bs        <-- -- -- uB01     <-- -- -- ys      -- -- delta      -- -- -1 vR01
  rol    eax,16                        ;                                        >Gs Bs yt --         -- -- -- uB01      -- -- -- ys      -- -- delta      -- -- -1 vR01
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pels R.                         m>Gs Bs yt Rs         -- -- -- uB01     <-- -- -- ys      -- -- delta      -- -- -1 vR01
   mov   cl,ah                         ;                                        <Gs Bs yt Rs         -- -- -- uB01     >-- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelt B.                         m>Gs Bs Bt Rs        <-- -- -- uB01     <-- -- -- yt      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;                                        >Bt Rs Gs Bs         -- -- -- uB01      -- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   BaR0G0B0+6144,eax             ; Stash for saving to second line.      s<Bt Rs Gs Bs         -- -- -- uB01      -- -- -- yt      -- -- delta      -- -- -1 vR01

  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Bt Rs Gs Bs       m>-- -- -- uvG01     -- -- -- yt      -- -- delta      -- -- -1 vR01
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pelt G.                         m>Bt Rs Gs Gt        <-- -- -- uvG01    <-- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelt R.                         m>Bt Rs Rt Gt         -- -- -- uvG01    <-- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   cl,[esi+1]                    ; Fetch Y1.                               Bt Rs Rt Gt         -- -- -- uvG01   m>-- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   bl,[esi+edx+2]                ; Fetch Y129.                             Bt Rs Rt Gt       m>-- -- -- y129      -- -- -- y1      -- -- delta      -- -- -1 vR01
  add   ebx,ecx                        ; Add Y1 to Y129.                         Bt Rs Rt Gt        >-- -- -- y129+y1  <-- -- -- y1      -- -- delta      -- -- -1 vR01
   shl   ebx, 16                       ;                                         Bt Rs Rt Gt        >-- ++ -- --        -- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   bl,[esi+edx+1]                ; Fetch Y128.                             Bt Rs Rt Gt       m>-- ++ -- y128      -- -- -- y1      -- -- delta      -- -- -1 vR01
  add    ebx,ecx                       ; Add Y1 to Y128                          Bt Rs Rt Gt        >-- ++ -- y128+y1  <-- -- -- y1      -- -- delta      -- -- -1 vR01
   shl   ebx,7                         ; Normalize Y1 + Y128, and Y1 + Y129      Bt Rs Rt Gt        >yv -- yu --        -- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   cl,bh                         ;                                         Bt Rs Rt Gt        <yv -- yu --       >-- -- -- yu      -- -- delta      -- -- -1 vR01
   shr   ebx,24                        ;                                         Bt Rs Rt Gt        >-- -- -- yv        -- -- -- yu      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Rt Gt -- --         -- -- -- yv        -- -- -- yu      -- -- delta      -- -- -1 vR01
  mov    ah,bl                         ;                                        >Rt Gt yv --        <-- -- -- yv        -- -- -- yu      -- -- delta      -- -- -1 vR01
  mov  bl,ChromaContribution+6144+3    ; Fetch U contrib to B value.             Rt Gt yv --       m>-- -- -- uB01      -- -- -- yu      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pelu B.                         m>Rt Gt yv Bu        <-- -- -- uB01     <-- -- -- yu      -- -- delta      -- -- -1 vR01
  shl    edx, 16                       ; Make room to save yv                    Rt Gt yv Bu         -- -- -- uB01      -- -- -- yu     <delta -- --      -- -- -1 vR01
  mov    dl,ah                         ;                                         Rt Gt yv Bu         -- -- -- uB01      -- -- -- yu     >delta -- yv      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Rt Gt yv Bu       m>-- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pelu G.                         m>Rt Gt Gu Bu        <-- -- -- uvG01    <-- -- -- yu      delta -- yv      -- -- -1 vR01
  ror    eax,16                        ;										>Gu Bu Rt Gt         -- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01
   mov   G1B1RaGa+6144,eax             ; Stash for saving to second line.      s<Gu Bu Rt Gt         -- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01
  mov   al,PB R24Value[ecx+ebp*1]      ; Fetch Pelu R.                         m>-- -- -- Ru         -- -- -- uvG01    <-- -- -- yu      delta -- yv     <-- -- -1 vR01
  mov   cl,dl                          ;                                         -- -- -- Ru         -- -- -- uvG01    >-- -- -- yv      delta -- yv      -- -- -1 vR01
  shr   edx,16                         ; Restore delta                           -- -- -- Ru         -- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01
  mov  bl,ChromaContribution+6144+3    ; Fetch U contrib to B value.             -- -- -- Ru       m>-- -- -- uB01      -- -- -- yv      -- -- delta      -- -- -1 vR01
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelv B.                         m>-- -- Bv Ru        <-- -- -- uB01     <-- -- -- yv      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Bv Ru -- --         -- -- -- uB01      -- -- -- yv      -- -- delta      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Bv Ru -- --       m>-- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   al,PB G24Value[ecx+ebx]       ; Fetch Pelv G.                         m>Bv Ru -- Gv        <-- -- -- uvG01    <-- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelv R.                         m>Bv Ru Rv Gv         -- -- -- uvG01    <-- -- -- yv      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;										>Rv Gv Bv Ru         -- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   RbGbBbR1+6144,eax             ; Stash for saving to second line.      s<Rv Gv Bv Ru         -- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uB01      -- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.     -- -- -- --         -- -- -- uB01      -- -- -- yv      -- -- delta    m>BB BB BB BB
   mov   cl,[esi+2]                    ; Fetch Y2.                               -- -- -- --         -- -- -- uB01    m>-- -- -- y2      -- -- delta      BB BB BB BB
   and   ebp,0000001FFH                ; Extract V contrib to R.                 -- -- -- --         -- -- -- uB01      -- -- -- y2      -- -- delta     >-- -- -1 vR23
   mov   al,[esi+3]                    ; Fetch Y3.                             m>-- -- -- y3         -- -- -- uB01      -- -- -- y2      -- -- delta      BB BB BB BB
   add   eax, ecx                      ; Add Y2 to Y3							>-- -- -- y3+y2      -- -- -- uB01     <-- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             -- -- -- --       m>-- -- -- uB23      -- -- -- y2      -- -- delta      -- -- -1 vR23
  shl    eax,23                        ; Low bit will be nuked by R2.           >yc -- -- --         -- -- -- uB23      -- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel2 B.                         m>yc -- -- B2        <-- -- -- uB23     <-- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            yc -- -- B2       m>-- -- -- uvG23    <-- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pel2 G.                         m>yc -- G2 B2        <-- -- -- uvG23    <-- -- -- y2      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;                                        >G2 B2 yc --         -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
   mov   al,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.                         m>G2 B2 yc R2         -- -- -- uvG23    <-- -- -- y2      -- -- delta     <-- -- -1 vR23
  mov    cl, ah                        ;                                        <G2 B2 yc R2         -- -- -- uvG23    >-- -- -- yc      -- -- delta     <-- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             G2 B2 yc R2       m>-- -- -- uB23     >-- -- -- yc      -- -- delta     <-- -- -1 vR23
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelc B.                         m>G2 B2 Bc R2        <-- -- -- uB23     <-- -- -- yc      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;										>Bc R2 G2 B2         -- -- -- uB23      -- -- -- yc      -- -- delta      -- -- -1 vR23
  mov    Ze [edi+12],eax               ; Fourth output.                        m<Bc R2 G2 B2         -- -- -- uB23      -- -- -- yc      -- -- delta      -- -- -1 vR23

   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelc R.                         m>Bc R2 Rc B2         -- -- -- uB23     <-- -- -- yc      -- -- delta     <-- -- -1 vR23
  mov    bl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            Bc R2 Rc B2       m>-- -- -- uvG23     -- -- -- yc      -- -- delta      -- -- -1 vR23
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pelc G.                         m>Bc R2 Rc Gc        <-- -- -- uvG23    <-- -- -- yc      -- -- delta      -- -- -1 vR23
   mov   cl,[esi+3]                    ; Fetch Y3.                               Bc R2 Rc Gc         -- -- -- uvG23   m>-- -- -- y3      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;                                        >Rc Gc -- --         -- -- -- uvG23     -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pel3 G.                         m>Rc Gc G3 --         -- -- -- uvG23    <-- -- -- y3      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             Rc Gc G3 --       m>-- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   al,PB B24Value[ecx+ebx*2]     ; Fetch Pel3 B.                         m>Rc Gc G3 B3        <-- -- -- uB23     <-- -- -- y3      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;										>G3 B3 Rc Gc         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
  mov    Ze [edi+16],eax               ; Fifth output.                         m<G3 B3 Rc Gc         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   al,[esi+4]                    ; Fetch Y4.                             m>-- -- -- y4         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   add   eax,ecx                       ; Add Y3 to Y4.                          >-- -- -- y4+y3      -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   shl   eax,7                         ; Low bit will be nuked by R3.           >-- -- yd --         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.                         m>-- -- yd R3         -- -- -- uB23     <-- -- -- y3      -- -- delta     <-- -- -1 vR23
   mov   cl,ah                         ;                                        <-- -- yd R3         -- -- -- uB23     >-- -- -- yd      -- -- delta     <-- -- -1 vR23
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Peld B.                         m>-- -- Bd R3        <-- -- -- uB23     <-- -- -- yd      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;										>Bd R3 -- --         -- -- -- uB23      -- -- -- yd      -- -- delta      -- -- -1 vR23
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Peld R.                         m>Bd R3 Rd --         -- -- -- uB23     <-- -- -- yd      -- -- delta     <-- -- -1 vR23
  mov    bl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            Bd R3 Rd --       m>-- -- -- uvG23    <-- -- -- yd      -- -- delta     <-- -- -1 vR23
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Peld G.                         m>Bd R3 Rd Gd        <-- -- -- uvG23    <-- -- -- yd      -- -- delta      -- -- -1 vR23
  rol    eax,16                        ;                                        >Rd Gd Bd R3         -- -- -- uvG23     -- -- -- yd      -- -- delta      -- -- -1 vR23
  mov    Ze [edi+20],eax               ; Sixth output.                         m<Rd Gd Bd R3         -- -- -- uvG23     -- -- -- yd      -- -- delta      -- -- -1 vR23

  xor   eax,eax                        ;                                        >-- -- -- --         -- -- -- uvG23     -- -- -- yd      -- -- delta      -- -- -1 vR23
   mov   cl,[esi+2]                    ; ReFetch Y2.                             -- -- -- --         -- -- -- uvG23   m>-- -- -- y2      -- -- delta      -- -- -1 vR23
   mov   al,[esi+edx+3]                ; Fetch Y130.                           m>-- -- -- y130       -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
  add   eax,ecx                        ; Add Y2 to Y130.                       m>-- -- -- y130+y2    -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
   shl   eax, 16                       ;                                        >-- ++ -- --         -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
   mov   al,[esi+edx+2]                ; Fetch Y129.                           m>-- ++ -- y129       -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
  add    eax,ecx                       ; Add Y2 to Y129                         >-- ++ -- y129+y2    -- -- -- uvG23    <-- -- -- y2      -- -- delta      -- -- -1 vR23
   shl   eax,7                         ; Normalize Y2 + Y129, and Y2 + Y130     >yx -- yw --         -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    cl,ah                         ;                                        <yx -- yw --         -- -- -- uvG23    >-- -- -- yw      -- -- delta      -- -- -1 vR23
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pelw G.                         m>yx -- Gw Bw        <-- -- -- uvG23    <-- -- -- yw      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             yx -- Gw Bw       m>-- -- -- uB23      -- -- -- yw      -- -- delta      -- -- -1 vR23
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pelw B.                         m>yx -- -- Bw        <-- -- -- uB23     <-- -- -- yw      -- -- delta      -- -- -1 vR23
  rol    eax,16                        ;                                        >Gw Bw yx --         -- -- -- uB23      -- -- -- yw      -- -- delta      -- -- -1 vR23
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pelw R.                         m>Gw Bw yx Rw         -- -- -- uB23     <-- -- -- yw      -- -- delta      -- -- -1 vR23
   mov   cl,ah                         ;                                        <Gw Bw yx Rw         -- -- -- uB23     >-- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelx B.                         m>Gw Bw Bx Rw        <-- -- -- uB23     <-- -- -- yx      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;                                        >Bx Rw Gw Bw         -- -- -- uB23      -- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   BcR2G2B2+6144,eax             ; Stash for saving to second line.      s<Bx Rw Gw Bw         -- -- -- uB23      -- -- -- yx      -- -- delta      -- -- -1 vR23

  mov   bl,ChromaContribution+6144+6   ; Fetch UV contrib to G value.            Bx Rw Gw Bw       m>-- -- -- uvG23     -- -- -- yx      -- -- delta      -- -- -1 vR23
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pelx G.                         m>Bx Rw Gw Gx        <-- -- -- uvG23    <-- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelx R.                         m>Bx Rw Rx Gx         -- -- -- uvG23    <-- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   cl,[esi+3]                    ; Fetch Y3.                               Bx Rw Rx Gx         -- -- -- uvG23   m>-- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   bl,[esi+edx+4]                ; Fetch Y131.                             Bx Rw Rx Gx       m>-- -- -- y131      -- -- -- y3      -- -- delta      -- -- -1 vR23
  add   ebx,ecx                        ; Add Y3 to Y131.                         Bx Rw Rx Gx        >-- -- -- y131+y3  <-- -- -- y3      -- -- delta      -- -- -1 vR23
   shl   ebx, 16                       ;                                         Bx Rw Rx Gx        >-- ++ -- --        -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   bl,[esi+edx+3]                ; Fetch Y130.                             Bx Rw Rx Gx       m>-- ++ -- y130      -- -- -- y3      -- -- delta      -- -- -1 vR23
  add    ebx,ecx                       ; Add Y3 to Y130                          Bx Rw Rx Gx        >-- ++ -- y130+y3  <-- -- -- y3      -- -- delta      -- -- -1 vR23
   shl   ebx,7                         ; Normalize Y3 + Y130, and Y3 + Y131      Bx Rw Rx Gx        >yz -- yy --        -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   cl,bh                         ;                                         Bx Rw Rx Gx        <yz -- yy --       >-- -- -- yy      -- -- delta      -- -- -1 vR23
   shr   ebx,24                        ;                                         Bx Rw Rx Gx        >-- -- -- yz        -- -- -- yy      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;                                        >Rx Gx -- --         -- -- -- yz        -- -- -- yy      -- -- delta      -- -- -1 vR23
  mov    ah,bl                         ;                                        >Rx Gx yz --        <-- -- -- yz        -- -- -- yy      -- -- delta      -- -- -1 vR23
  mov  bl,ChromaContribution+6144+7    ; Fetch U contrib to B value.             Rx Gx yz --       m>-- -- -- uB23      -- -- -- yy      -- -- delta      -- -- -1 vR23
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pely B.                         m>Rx Gx yz By        <-- -- -- uB23     <-- -- -- yy      -- -- delta      -- -- -1 vR23
  shl    edx, 16                       ; Make room to save yz                    Rx Gx yz By         -- -- -- uB23      -- -- -- yy     <delta -- --      -- -- -1 vR23
  mov    dl,ah                         ;                                         Rx Gx yz By         -- -- -- uB23      -- -- -- yy     >delta -- yz      -- -- -1 vR23
  mov   bl,ChromaContribution+6144+6   ; Fetch UV contrib to G value.            Rx Gx yz By       m>-- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pely G.                         m>Rx Gx Gy By        <-- -- -- uvG23    <-- -- -- yy      delta -- yz      -- -- -1 vR23
  ror    eax,16                        ;										>Gy By Rx Gx         -- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23
   mov   G3B3RcGc+6144,eax             ; Stash for saving xo second line.      s<Gy By Rx Gx         -- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23
  mov   al,PB R24Value[ecx+ebp*1]      ; Fetch Pely R.                         m>-- -- -- Ry         -- -- -- uvG23    <-- -- -- yy      delta -- yz     <-- -- -1 vR23
  mov   cl,dl                          ;                                         -- -- -- Ry         -- -- -- uvG23    >-- -- -- yz      delta -- yz      -- -- -1 vR23
  shr   edx,16                         ; Restore delta                           -- -- -- Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23
  mov  bl,ChromaContribution+6144+7    ; Fetch U contrib to B value.             -- -- -- Ry       m>-- -- -- uB23      -- -- -- yz      -- -- delta      -- -- -1 vR23
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelz B.                         m>-- -- Bz Ry        <-- -- -- uB23     <-- -- -- yz      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;                                        >Bz Ry -- --         -- -- -- uB23      -- -- -- yz      -- -- delta      -- -- -1 vR23
  mov   bl,ChromaContribution+6144+6   ; Fetch UV contrib to G value.            Bz Ry -- --       m>-- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23
   mov   al,PB G24Value[ecx+ebx]       ; Fetch Pelz G.                         m>Bz Ry -- Gz        <-- -- -- uvG23    <-- -- -- yz      -- -- delta      -- -- -1 vR23
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelz R.                         m>Bz Ry Rz Gz         -- -- -- uvG23    <-- -- -- yz      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;										>Rz Gz Bz Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23
   mov   RdGdBdR3+6144,eax             ; Stash for saving to second line.      s<Rz Gz Bz Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23

   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.     Rz Gz Bz Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta    m>CC CC CC CC
  mov    bl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.            Rz Gz Bz Ry       m>-- -- -- uvG45     -- -- -- yz      -- -- delta      CC CC CC CC
   and   ebp,0000001FFH                ; Extract U contrib to B.                 Rz Gz Bz Ry         -- -- -- uvG45     -- -- -- yz      -- -- delta     >-- -- -1 vR45
  mov    cl,[esi+4]                    ; Fetch Y4.                               Rz Gz Bz Ry         -- -- -- uvG45   m>-- -- -- y4      -- -- delta      -- -- -1 vR45
   lea   esi,[esi+4]                   ; Advance input cursor.  
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,BaR0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

ELSE

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
B0R0G0B0                 EQU  [esp+72]
G1B1R0G0                 EQU  [esp+76]
R1G1B1R1                 EQU  [esp+80]
B2R2G2B2                 EQU  [esp+84]
G3B3R2G2                 EQU  [esp+88]
R3G3B3R3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax

DoLine1:
                                     ;                                           EAX                 EBX                ECX              EDX              EBP
  xor   ebx,ebx                      ;                                           ?? ?? ?? ??        >-- -- -- --        ?? ?? ?? ??      ?? ?? ?? ??     ?? ?? ?? ??
   xor  ecx,ecx                      ;                                           ?? ?? ?? ??         -- -- -- --       >-- -- -- --      ?? ?? ?? ??     ?? ?? ?? ??
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.       ?? ?? ?? ??         -- -- -- --        -- -- -- --      ?? ?? ?? ??    >AA AA AA AA
   xor  edx,edx                      ;                                           ?? ?? ?? ??         -- -- -- --        -- -- -- --     >-- -- -- --     AA AA AA AA
  mov   cl,[esi]                     ; Fetch Y0.                                 ?? ?? ?? ??         -- -- -- --      m>-- -- -- y0      -- -- -- --     AA AA AA AA
   mov  bl,ChromaContribution+3      ; Fetch U contrib to B value.               ?? ?? ?? ??       m>-- -- -- uB01      -- -- -- y0      -- -- -- --     AA AA AA AA
  mov   dl,ChromaContribution+2      ; Fetch UV contrib to G value.              ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0    m>-- -- -- uvG01  AA AA AA AA
   and  ebp,0000001FFH               ; Extract V contrib to R.                   ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01 >-- -- -1 AA
  mov   edi,CCOCursor                ;                                           ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
   sub  esp,6144                     ;                                           ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
  xor   eax,eax                      ;                                          >-- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B.                         m>-- -- B0 --        <-- -- -- uB01     <-- -- -- y0      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.                           -- -- B0 --       m>-- -- R0 uB01     <-- -- -- y0      -- -- -- uvG01  <-- -- -1 AA
  mov    bl,PB G24Value[ecx+edx]       ; Fetch Pel0 G.   -- -- R0 G0             -- -- B0 --       m>-- -- R0 G0       <-- -- -- y0     <-- -- -- uvG01   -- -- -1 AA
   mov   cl,[esi+1]                    ; Fetch Y1.                               -- -- B0 --         -- -- R0 G0      m>-- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  shl    ebx,16                        ;                 R0 G0 -- --             -- -- B0 --        >R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   al,ah                         ; Copy Pel0 B.    -- -- B0 B0            >-- -- B0 B0         R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  or     eax,ebx                       ;                 R0 G0 B0 B0            >R0 G0 B0 B0        <R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R0 G0 G1 --             R0 G0 B0 B0       m>R0 G0 G1 --       <-- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  ror    eax,8                         ; First output:   B0 R0 G0 B0            >B0 R0 G0 B0         R0 G0 G1 --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.           B0 R0 G0 B0         R0 G0 G1 --        -- -- -- y1    m>-- -- -- uB01    -- -- -1 AA
  mov    Ze [edi],eax                  ; Save B0R0G0B0.                        m<B0 R0 G0 B0         R0 G0 G1 --        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.   R0 G0 G1 B1             B0 R0 G0 B0       m>R0 G0 G1 B1       <-- -- -- y1     <-- -- -- uB01    -- -- -1 AA
  rol    ebx,16                        ; Second output:  G1 B1 R0 G0             B0 R0 G0 B0        >G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   B0R0G0B0+6144,eax             ; Stash for saving to second line.      s<B0 R0 G0 B0        >G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
  mov    Ze [edi+4],ebx                ; Save G1B1R0G0.					         B0 R0 G0 B0       m<G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   G1B1R0G0+6144,ebx             ; Stash for saving to second line.        B0 R0 G0 B0       s<G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
  mov    bl,PB R24Value[ecx+ebp*1]     ; Fetch Pel1 R.   G1 B1 -- R1             B0 R0 G0 B0       m>G1 B1 R0 R1       <-- -- -- y1      -- -- -- uB01   <-- -- -1 AA
   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.     B0 R0 G0 B0         G1 B1 R0 R1        -- -- -- y1      -- -- -- uB01  m>BB BB BB BB
  mov    bh,bl                         ; Copy Pel1 R.    G1 B1 R1 R1             B0 R0 G0 B0        >G1 B1 R1 R1        -- -- -- y1      -- -- -- uB01    BB BB BB BB

   mov   cl,[esi+2]                    ; Fetch Y2.                               B0 R0 G0 B0         G1 B1 R1 R1      m>-- -- -- y2      -- -- -- uB01    BB BB BB BB
  ror    ebx,8                         ; Third output:   R1 G1 B1 R1             B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01    BB BB BB BB
   and   ebp,0000001FFH                ; Extract V contrib to R.                 B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01   >-- -- -1 BB
  mov    dl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2    m>-- -- -- uvG23   -- -- -1 BB
   xor   eax,eax                       ;                                         -- -- -- --         R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    al,ChromaContribution+6144+7  ; Fetch U contrib to B value.           m>-- -- -- uB23       R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   R1G1B1R1+6144,ebx             ; Stash for saving to second line.        -- -- -- uB23     s<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    Ze [edi+8],ebx                ; Save R1G1B1R1.                          -- -- -- uB23     m<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   xor   ebx,ebx                       ;                                         -- -- -- uB23      >-- -- -- --        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    bh,PB B24Value[ecx+eax*2]     ; Fetch Pel2 B.                          <-- -- -- uB23     m>-- -- B2 --       <-- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.                         m>-- -- R2 uB23       -- -- B2 --       <-- -- -- y2      -- -- -- uvG23  <-- -- -1 BB
  mov    al,PB G24Value[ecx+edx]       ; Fetch Pel2 G.   -- -- R2 G2           m>-- -- R2 G2         -- -- B2 --       <-- -- -- y2     <-- -- -- uvG23   -- -- -1 BB
   mov   cl,[esi+3]                    ; Fetch Y3.                               -- -- R2 G2         -- -- B2 --      m>-- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  shl    eax,16                        ;                 R2 G2 -- --            >R2 G2 -- --         -- -- B2 --        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   bl,bh                         ; Copy Pel2 B.    -- -- B2 B2             R2 G2 -- --        >-- -- B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  or     ebx,eax                       ;                 R2 G2 B2 B2            <R2 G2 -- --        >R2 G2 B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R2 G2 G3 --           m>R2 G2 G3 --         R2 G2 B2 B2       <-- -- -- y3     <-- -- -- uvG23   -- -- -1 BB
  ror    ebx,8                         ; Fourth output:  B2 R2 G2 B2             R2 G2 G3 --        >B2 R2 G2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   dl,ChromaContribution+6144+7  ; Refetch U contrib to B value.           R2 G2 G3 --         B2 R2 G2 B2        -- -- -- y3    m>-- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+12],ebx               ; Save B2R2G2B2.                          R2 G2 G3 --       m<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   al,PB B24Value[ecx+edx*2]     ; Fetch Pel3 B.   R2 G2 G3 B3           m>R2 G2 G3 B3         B2 R2 G2 B2       <-- -- -- y3     <-- -- -- uB23    -- -- -1 BB
  rol    eax,16                        ; Fifth output:   G3 B3 R2 G2            >G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   B2R2G2B2+6144,ebx             ; Stash for saving to second line.        G3 B3 R2 G2       s<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+16],eax               ; Save G3B3R2G2.                        m<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   G3B3R2G2+6144,eax             ; Stash for saving to second line.      s<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.   G3 B3 -- R3	       m>G3 B3 R2 R3         B2 R2 G2 B2       <-- -- -- y3      -- -- -- uB23   <-- -- -1 BB
   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.     G3 B3 R2 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23  m<CC CC CC CC
  mov    ah,al                         ; Copy Pel3 R.    G3 B3 R3 R3            >G3 B3 R3 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    CC CC CC CC
   mov   cl,[esi+4]                    ; Fetch Y4.					             G3 B3 R3 R3         B2 R2 G2 B2      m>-- -- -- y4      -- -- -- uB23    CC CC CC CC
  ror    eax,8                         ; Sixth output:   R3 G3 B3 R3            >R3 G3 B3 R3         B2 R2 G2 B2        -- -- -- y4      -- -- -- uB23    CC CC CC CC
   xor   ebx,ebx                       ;                                         R3 G3 B3 R3        >-- -- -- --        -- -- -- y4      -- -- -- uB23    CC CC CC CC
  mov    dl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.            R3 G3 B3 R3         -- -- -- --        -- -- -- y4    m>-- -- -- uvG45   CC CC CC CC
   and   ebp,0000001FFH                ; Extract U contrib to B.                 R3 G3 B3 R3         -- -- -- --        -- -- -- y4      -- -- -- uvG45  >-- -- -1 CC
  mov    bl,ChromaContribution+6144+35 ; Fetch U contrib to B value.             R3 G3 B3 R3       m>-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   lea   esi,[esi+4]                   ; Advance input cursor.  
  mov    Ze [edi+20],eax               ; Save R3G3B3R3.                        m<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   mov   R3G3B3R3+6144,eax             ; Stash for saving to second line.      s<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
  mov    eax,ebx                       ;                                        >-- -- -- uB45      <-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,B0R0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512241.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512241.asv
;//
;// $Log:   S:\h26x\src\dec\cx512241.asv  $
;// 
;//    Rev 1.7   27 Mar 1996 18:39:26   RMCKENZX
;// Corrected bug in line parity which manifests on odd aspects.
;// 
;//    Rev 1.6   27 Mar 1996 14:41:46   RMCKENZX
;// Changed YSkipDistance to use register ebp, not eax.  When
;// pitch-width was more than 255, the first 4 pels of odd lines
;// would get erroneous values for blue, due to the presence of
;// non-zero values in the high order bits of eax.  Also cleaned a
;// few comments.
;// 
;//    Rev 1.5   18 Mar 1996 09:58:46   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:40:52   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   30 Oct 1995 17:15:30   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:47:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:30   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512241 -- This function performs YUV12-to-RGB24 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB24    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]
G2B2R1G1                 EQU  [esp+68]
R3G3B3R2                 EQU  [esp+72]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   mov  CCOSkipDistance,eax
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   YLimit,edx
   mov  YCursor,esi
  mov   esi,VCursor
   xor  eax,eax
  mov   LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[ 9:15] -- Zero (pad).
  ;                                 ; ebx[ 0: 8] -- Zero (red).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,16
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-12],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   xor  ebx,ebx
  mov   [edi+4],ecx                 ; Store EOL indicator.
   mov  edx,AspectCount
  mov   edi,CCOCursor
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   esi,YCursor
   mov  AspectCount,edx
  jne   KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of one and a third pels of RGB24.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl,al  -- UV contrib to G field of RGB val,  U contrib to B field of RGB val.

  mov   cl,[esi+3]                     ; Get Y03.
   mov  bl,ChromaContribution+6        ; Get UV contribution to G value.
  mov   ebp,ChromaContribution+4       ; Get V contribution to R value.
   sub  esp,3072
  and   ebp,01FFH                      ; Extract V contribution to R value.
   mov  dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.

DoNext4YPelsOfLine0:

  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+3072+7   ; Get U contribution to B value.
  shl   edx,16                         ; Position R and G value for Pel03.
   mov  bl,[esi+2]                     ; Get Y02.
  mov   dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel03.
   mov  cl,ChromaContribution+3072+6   ; Reload UV contribution to G value.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel02.
   mov  ebp,ChromaContribution+3072    ; Get V contribution to R value.
  mov   R3G3B3R2+3072,edx              ; Stash 1.33 pels.
   mov  dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel02.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel02.
   mov  cl,[esi+1]                     ; Get Y01.
  mov   bl,ChromaContribution+3072+2   ; Get UV contribution to G value.
   and  ebp,01FFH                      ; Extract V contribution to R value.
  shl   edx,16                         ; Position G and B values for Pel02.
   mov  al,ChromaContribution+3072+3   ; Get U contribution to B value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   mov  bl,[esi]                       ; Get Y00.
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   add  esi,4                          ; Advance source stream cursor.
  mov   G2B2R1G1+3072,edx              ; Stash 1.33 pels.
   mov  dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
  mov   cl,ChromaContribution+3072+2   ; Reload UV contribution to G value.
   add  edi,12                         ; Advance color converted output cursor.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel00.
   mov  ebp,ChromaContribution+3072+20 ; Get next V contribution to R value.
  shl   edx,16                         ; Position R for Pel00 and B for Pel01.
   and  ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
  mov   dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel00.
   mov  eax,G2B2R1G1+3072              ; Reload 2nd 1.33 pels.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel00.
   mov  cl,[esi+3]                     ; Get next Y03.
  mov   Ze [edi-12],edx                ; Write the first 1.33 pels out.
   mov  bl,ChromaContribution+3072+22  ; Get UV contribution to G value.
  mov   Ze [edi-8],eax                 ; Write the second 1.33 pels out.
   mov  edx,R3G3B3R2+3072
  mov   Ze [edi-4],edx                 ; Write the third 1.33 pels out.
   mov  eax,ebx                        ; Zero out upper bytes of eax.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.
   lea  esp,[esp+16]
  jne   DoNext4YPelsOfLine0

  and   esp,0FFFFF000H
  add   esp,1000H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512321.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512321.asv
;//
;// $Log:   S:\h26x\src\dec\cx512321.asv  $
;// 
;//    Rev 1.0   01 Apr 1996 10:25:46   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512321 -- This function performs YUV12-to-RGB32 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, the third byte is R, and the high order byte
;             is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB32    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  imul  edx,ecx
  sub   ecx,ebx
   lea  ebx,[ebx*4]
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,3
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  CCOSkipDistance,eax
  mov   YLimit,edx
   mov  ChromaLineLen,ebx
  mov   YCursor,esi
   xor  eax,eax
  mov   esi,VCursor
   mov  LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  edx,AspectCount
  mov   [edi],eax                   ; Store EOL indicator.
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   mov  edi,CCOCursor
  mov   esi,YCursor
   jne  KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  edx,edx

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+8]                    ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512322.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512322.asv
;//
;// $Log:   S:\h26x\src\dec\cx512322.asv  $
;// 
;//    Rev 1.2   12 Apr 1996 11:26:26   RMCKENZX
;// Corrected bug in fetching first V contribution to Red.
;// 
;//    Rev 1.1   10 Apr 1996 11:12:54   RMCKENZX
;// Fixed bug in aspect ratio correction -- clearing sign bit of bl.
;// 
;//    Rev 1.0   01 Apr 1996 10:25:48   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by two.
; ||||||||
; cx512322 -- This function performs YUV12-to-RGB32 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, the third byte is R, and the
;             high order byte is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB32ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]

YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  shl   ebx,3
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  add   edx,esi
   sub  eax,ebx
  shr   ebx,4
   mov  YLimit,edx
  mov   ChromaLineLen,ebx
   mov  CCOSkipDistance,eax
  mov   esi,VCursor
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi],eax                   ; Store EOL indicator.
   mov  LineParity,eax
  mov   edi,CCOCursor

Keep2ndLineOfOutput:
DoLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

   xor  edx,edx
  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  eax,eax

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
  mov   Ze [edi+4],edx                 ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+16]                   ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-8],edx                 ; Write RGB32 for Pel01.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  mov   eax,CCOSkipDistance
   mov  bl,LineParity
  add   edi,eax
   xor  bl,080H
  mov   esi,YCursor
   jns  SecondOutputLineDone
   
  mov   LineParity,bl
   mov  ebp,AspectCount
  sub   ebp,2                          ; If count is non-zero, we keep the line.
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ebp
   jg   Keep2ndLineOfOutput

  add   ebp,ecx
   and  bl, 7fh                     ; clear LineParity SecondOutputLineDone bit
  mov   AspectCount,ebp

SecondOutputLineDone:

  add   esi,LumaPitch
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx51281.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51281.asv
;//
;// $Log:   S:\h26x\src\dec\cx51281.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:40   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:43:28   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 11:49:40   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:08   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:20   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by one, i.e. non-zoom.
; |||||||
; cx51281  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It dithers among 9 chroma points and 26 luma points, mapping the
;             8 bit luma pels into the 26 luma points by clamping the ends and
;             stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   YLimit,edx
   mov  ChromaLineLen,ebx

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   [esi],edx                   ; Stash EOL indication.
   mov  edx,AspectCount
  mov   esi,YCursor                 ; Reload cursor over Y line.
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine0

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:

  mov   edi,CCOCursor                 ; Fetch output cursor.
   mov  eax,CCOPitch                  ; Compute start of next line.
  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <UV03 UV02 xxxx xxxx>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+3]                    ; Fetch Y03.
   and  edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
  mov   eax,ChromaContribution        ; Fetch <xxxx xxxx UV01 UV00>.
   sub  esp,1536-8
  and   eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
   mov  cl,[esi+2]                    ; Fetch Y02.

Line0Loop:

  or    eax,edx                       ; <UV03 UV02 UV01 UV00>.
   mov  dh,PB YDither[ebx+4]          ; <xxxx xxxx  Y03 xxxx>.
  mov   dl,PB YDither[ecx+2]          ; <xxxx xxxx  Y03  Y02>.
   mov  bl,PB [esi+1]                 ; Fetch Y01.
  shl   edx,16                        ; < Y03  Y02 xxxx xxxx>.
   mov  cl,PB [esi]                   ; Fetch Y00.
  mov   dh,PB YDither[ebx+6]          ; < Y03  Y02  Y01 xxxx>.
   mov  bl,PB [esi+3+4]               ; Fetch next Y03.
  mov   dl,PB YDither[ecx+0]          ; < Y03  Y02  Y01  Y00>.
   mov  cl,PB [esi+2+4]               ; Fetch next Y02.
  add   eax,edx                       ; < P03  P02  P01  P00>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <UV03 UV02 xxxx xxxx>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <xxxx xxxx UV01 UV00>.
  and   edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  add   esp,8
   and  eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
  jne   Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine0:

; Color convert another line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Y Pitch.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   esi,YCursor                   ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor                 ; Fetch output cursor.
  lea   eax,[esi+ebp*2]               ; Compute address of next line of Y.
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch                  ; Compute start of next line.
  mov   AspectCount,edx
   jne  KeepLine1

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <xxxx xxxx UV13 UV12>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+ebp*1+3]              ; Fetch Y13.
   mov  eax,ChromaContribution        ; Fetch <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   sub  esp,1536-8
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   mov  cl,[esi+ebp*1+2]              ; Fetch Y12.

Line1Loop:

  or    eax,edx                       ; <UV13 UV12 UV11 UV10>.
   mov  dh,PB YDither[ebx+6]          ; <xxxx xxxx  Y13 xxxx>.
  mov   dl,PB YDither[ecx+0]          ; <xxxx xxxx  Y13  Y12>.
   mov  bl,PB [esi+ebp*1+1]           ; Fetch Y11.
  shl   edx,16                        ; < Y13  Y12 xxxx xxxx>.
   mov  cl,PB [esi+ebp*1]             ; Fetch Y10.
  mov   dh,PB YDither[ebx+4]          ; < Y13  Y12  Y11 xxxx>.
   mov  bl,PB [esi+ebp*1+3+4]         ; Fetch next Y13.
  mov   dl,PB YDither[ecx+2]          ; < Y13  Y12  Y11  Y10>.
   mov  cl,PB [esi+ebp*1+2+4]         ; Fetch next Y12.
  add   eax,edx                       ; < P13  P12  P11  P10>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <xxxx xxxx UV13 UV12>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   lea  esp,[esp+8]
  jne   Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

  mov   edi,VCursor                   ; Fetch addr of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU          ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                      ; Fetch first V pel.
   ;
  and   ebx,0FCH                      ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]                ; Fetch first U pel.
  and   ecx,0FCH                      ; Reduce to 6 bits.
   mov  VCursor,edx                   ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine23[ebx]
   mov  bl,[edi+1]
  mov   eax,PD UVDitherLine01[ecx]
   mov  cl,[edi+ebp*1+1]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   and  bl,0FCH
  add   eax,edx
   and  cl,0FCH
  mov   edx,PD UVDitherLine23[ebx]
   mov  [esi],eax
  mov   eax,PD UVDitherLine01[ecx]
   mov  bl,[edi+2]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   mov  cl,[edi+ebp*1+2]
  add   eax,edx
   mov  edx,EndOfChromaLine
  mov   [esi+4],eax
   add  edi,2
  and   bl,0FCH
   and  cl,0FCH
  add   esi,8
   sub  edx,edi
  jne   @b

  mov   [esi],edx
   mov  edx,AspectCount
  mov   esi,YCursor
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine2

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine2

KeepLine2:

  mov   edi,CCOCursor
   mov  eax,CCOPitch
  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+3]
   and  edx,0FFFF0000H
  mov   eax,ChromaContribution
   sub  esp,1536-8
  and   eax,00000FFFFH
   mov  cl,[esi+2]

Line2Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+2]
  mov   dl,PB YDither[ecx+4]
   mov  bl,PB [esi+1]
  shl   edx,16
   mov  cl,PB [esi]
  mov   dh,PB YDither[ebx+0]
   mov  bl,PB [esi+3+4]
  mov   dl,PB YDither[ecx+6]
   mov  cl,PB [esi+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  and   edx,0FFFF0000H
   add  esi,4
  add   esp,8
   and  eax,00000FFFFH
  jne   Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine2:

  mov   esi,YCursor
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor
  lea   eax,[esi+ebp*2]
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch
  mov   AspectCount,edx
   jne  KeepLine3

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+ebp*1+3]
   mov  eax,ChromaContribution
  shl   edx,16
   sub  esp,1536-8
  shr   eax,16
   mov  cl,[esi+ebp*1+2]

Line3Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+0]
  mov   dl,PB YDither[ecx+6]
   mov  bl,PB [esi+ebp*1+1]
  shl   edx,16
   mov  cl,PB [esi+ebp*1]
  mov   dh,PB YDither[ebx+2]
   mov  bl,PB [esi+ebp*1+3+4]
  mov   dl,PB YDither[ecx+4]
   mov  cl,PB [esi+ebp*1+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  shl   edx,16
   add  esi,4
  shr   eax,16
   lea  esp,[esp+8]
  jne   Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextFourLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512yuv.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512yuv.asv   1.5   30 Dec 1996 20:02:08   MDUDA  $
;//
;// $Log:   S:\h26x\src\dec\cx512yuv.asv  $
;// 
;//    Rev 1.5   30 Dec 1996 20:02:08   MDUDA
;// Fixed problem where buffer boundaries were being over-written.
;// 
;//    Rev 1.4   11 Dec 1996 14:58:52   JMCVEIGH
;// 
;// Changed to support width the are multiples of 4.
;// 
;//    Rev 1.3   18 Jul 1996 12:52:58   KLILLEVO
;// changed cache heating to speed things up a bit 
;// 
;//    Rev 1.2   18 Jul 1996 09:39:34   KLILLEVO
;// 
;// added PVCS header and log

;; Very straightforward implementation of the YUV pitch changer
;; Does 16 pels at a time. If the width is not a multiple of 16
;; the remainder pels are handled as a special case. We assume
;; that the width is at least a multiple of 4

OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUV


YUV12ToYUV   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  12

RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

LineAdd          = 0          ; 1
LineWidth        = 4          ; 2

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_LineAdd                 EQU    [esp + LineAdd]
_LineWidth               EQU    [esp + LineWidth]
_uRemainderEdgePels		 EQU	[esp + uRemainderEdgePels]

; Save registers and start working

push    ebx
 push   esi
push    edi
 push   ebp

sub     esp, LocalFrameSize

 mov   	eax, _uCCOutputBuffer
add     eax, _uOffsetToLine0
 mov    ecx, _lOutput
add     eax, ecx        
 mov    ebx, _uYPitch
mov     ecx, _uWidth
 mov    esi, _uYPlane
mov     edi, eax

; luma
sub    ebx, ecx   ; ebx = pitch - width
 mov    edx, _uHeight
mov    eax, _uWidth
 mov    _LineAdd, ebx

L2:
test	ecx, 0FFFFFFF0H
 jz		LEdgePels			; Width may be less than 16

L1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 16
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 16], eax
 mov    DWORD PTR [edi - 12], ebx
mov     eax, DWORD PTR [esi + 8]
 mov    ebx, DWORD PTR [esi +12]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 16
 sub    ecx, 16

test	ecx, 0FFFFFFF0H
 jnz    L1

LEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 8 edge pels
test	ecx, 08H
 jz		Lchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 mov	ebx, DWORD PTR [esi + 4]			; Input pels 4-7
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 mov	DWORD PTR [edi + 4], ebx			; Output pels 4-7
add		esi, 8
 add	edi, 8

Lchk4:
; Check 4 edge pels
test	ecx, 04H
 jz		L2_cont
mov    eax, DWORD PTR [esi + 0]			; Input pels 0-3
add		esi, 4
mov    DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

L2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     L2

; chroma
mov     esi, _uUPlane
 mov    ecx, _uWidth
shr     ecx, 1
 mov    ebx, _uUVPitch
sub     ebx, ecx   ; ebx = pitch - width/2
 mov    edx, _uHeight
shr     edx, 1
 mov    _LineAdd, ebx
mov		_uWidth, ecx
 mov	_uHeight, edx

U2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

U1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    U1

UEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Uchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Uchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		U2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

U2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     U2


; chroma
mov    esi, _uVPlane
 mov	ecx, _uWidth
mov    edx, _uHeight
 nop

V2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

V1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    V1

VEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Vchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Vchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		V2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

V2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
jnz     V2

add     esp, LocalFrameSize  ; restore esp to registers                               

pop	    ebp
 pop    edi
pop	    esi
 pop    ebx
ret     52                   ; 13*4 bytes of arguments

YUV12ToYUV ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx51282.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51282.asv
;//
;// $Log:   S:\h26x\src\dec\cx51282.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:42   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:08   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:53:50   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 14:39:42   BNICKERS
;// Support YUV12 to CLUT8 zoom by 2.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:10   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by two.
; |||||||
; cx51282  -- This function performs YUV12 to CLUT8 zoom-by-2 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It dithers among 9 chroma points and 26 luma
;             points, mapping the 8 bit luma pels into the 26 luma points by
;             clamping the ends and stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8ZoomBy2

IFDEF USE_BILINEAR_MSH26X

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   ChromaLineLen,ebx
   mov  YLimit,edx

NextTwoLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8 
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov   [esi],edx                   ; Stash EOL indication.
   mov  esi,YCursor                 ; Reload cursor over y line.
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+1]                  ; Fetch y1.                                  XX XX XX XX       m>-- -- -- y1        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      -- -- -- --
  mov   cl,[esi]                    ; Fetch y0.                                  XX XX XX XX         -- -- -- y1      m>-- -- -- y0      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      -- -- -- --
  mov   al,PB YDither[ecx+0]        ; Fetch Y0.                                m>XX XX XX Y0         -- -- -- y1       <-- -- -- y0      -- -- -- --
   add  ecx,ebx                     ; Add y1 to y0.                              XX XX XX Y0        <-- -- -- y1       >-- -- -- y0+y1   -- -- -- --
  shr   ecx,1                       ; ya = (y0 + y1) / 2.                        XX XX XX Y0         -- -- -- y1       >-- -- -- ya      -- -- -- --
   mov  ah,PB YDither[ecx+6]        ; Fetch YA.                                  XX XX YA Y0         -- -- -- y1       <-- -- -- ya      -- -- -- --
  mov   dl,PB YDither[ebx+2]        ; Fetch Y1.                                  XX XX YA Y0         -- -- -- y1       <-- -- -- ya    m>-- -- -- Y1
   mov  cl,[esi+2]                  ; Fetch y2.                                  XX XX YA Y0         -- -- -- y1      m>-- -- -- y2      -- -- -- Y1
  add   ebx,ecx                     ; Add y2 to y1.                              XX XX YA Y0        >-- -- -- y1+y2    <-- -- -- y2      -- -- -- Y1
   shr  ebx,1                       ; yb = (y1 + y2) / 2.                        XX XX YA Y0        >-- -- -- yb        -- -- -- y2      -- -- -- Y1
  mov   dh,PB YDither[ebx+4]        ; Fetch YB.                                  XX XX YA Y0        >-- -- -- yb        -- -- -- y2    m>-- -- YB Y1
   sub  edi,esi                     ; Get span from y cursor to CCO cursor.      XX XX YA Y0         -- -- -- yb        -- -- -- y2      -- -- YB Y1
  shl   edx,16                      ; Position YB Y1.                            XX XX YA Y0         -- -- -- yb        -- -- -- y2     >YB Y1 -- --
   sub  edi,esi                     ;                                            XX XX YA Y0         -- -- -- yb        -- -- -- y2      YB Y1 -- --
  and   eax,00000FFFFH              ; Extract YA Y0.                            >-- -- YA Y0         -- -- -- yb        -- -- -- y2      YB Y1 -- --
   mov  bl,[esi+3]                  ; Fetch y3.                                  -- -- YA Y0       m>-- -- -- y3        -- -- -- y2      YB Y1 -- --
  or    eax,edx                     ; < YB Y1 YA Y0>.                           >YB Y1 YA Y0         -- -- -- y3        -- -- -- y2     <YB Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               YB Y1 YA Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  sub   esp,1536

Line0Loop:

  add   eax,edx                       ; < PB P1 PA P0>.                         >PB P1 PA P0         -- -- -- y3        -- -- -- y2     <C1 C1 C0 C0
   mov  Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PB P1 PA P0         -- -- -- y3        -- -- -- y2      C1 C1 C0 C0
  mov   al,PB YDither[ecx+0]          ; Fetch Y2.                              m>PB P1 PA Y2         -- -- -- y3       <-- -- -- y2      C1 C1 C0 C0
   add  ecx,ebx                       ; Add y3 to y2.                            PB P1 PA Y2         -- -- -- y3       >-- -- -- y2+y3   C1 C1 C0 C0
  shr   ecx,1                         ; yc = (y2 + y3) / 2.                      PB P1 PA Y2         -- -- -- y3       >-- -- -- yc      C1 C1 C0 C0
   mov  ah,PB YDither[ecx+6]          ; Fetch YC.                                PB P1 YC Y2         -- -- -- y3       <-- -- -- yc      C1 C1 C0 C0
  and   eax,00000FFFFH                ; Extract YC Y2.                          >-- -- YC Y2         -- -- -- y3        -- -- -- y2      C1 C1 C0 C0
   mov  dl,PB YDither[ebx+2]          ; Fetch Y3.                                -- -- YC Y2         -- -- -- y3        -- -- -- y2      C1 C1 C0 Y3
  mov   cl,[esi+4]                    ; Fetch y4.                                -- -- YC Y2         -- -- -- y3      m>-- -- -- y4      C1 C1 C0 Y3
   add  ebx,ecx                       ; Add y4 to y3.                            -- -- YC Y2        >-- -- -- y3+y4     -- -- -- y4      C1 C1 C0 Y3
  shr   ebx,1                         ; yd = (y3 + y4) / 2.                      -- -- YC Y2        >-- -- -- yd        -- -- -- y4      C1 C1 C0 Y3
   mov  dh,PB YDither[ebx+4]          ; Fetch YD.                                -- -- YC Y2        <-- -- -- yd        -- -- -- y4    m>C1 C1 YD Y3
  add   esi,4                         ; Advance cursor.                          -- -- YC Y2         -- -- -- yd        -- -- -- y4      C1 C1 YD Y3
   shl  edx,16                        ; Extract YD Y3.                           -- -- YC Y2         -- -- -- yd        -- -- -- y4     >YD Y3 -- --
  mov   bl,[esi+1]                    ; Fetch y5.                                -- -- YC Y2       m>-- -- -- y5        -- -- -- y4      YD Y3 -- --
   or   eax,edx                       ; < YD Y3 Yc Y2>.                         >YD Y3 YC Y2         -- -- -- y5        -- -- -- y4     <YD Y3 -- --
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             YD Y3 YC Y2         -- -- -- y5        -- -- -- y4    s>C3 C3 C2 C2
   add  eax,edx                       ; < P03  P03  P02  P02>.                  >PD P3 PC P2         -- -- -- y5        -- -- -- y4     <C3 C3 C2 C2
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PD P3 PC P2         -- -- -- y5        -- -- -- y4      C3 C3 C2 C2
   mov  al,PB YDither[ecx+0]          ; Fetch Y4.                                PD P3 PC Y4         -- -- -- y5       <-- -- -- y4      C3 C3 C2 C2
  add   ecx,ebx                       ; Add y5 to y4.                            PD P3 PC Y4        >-- -- -- y5       >-- -- -- y4+y5   C3 C3 C2 C2
   shr  ecx,1                         ; ye = (y4 + y5) / 2.                      PD P3 PC Y4         -- -- -- y5       >-- -- -- ye      C3 C3 C2 C2
  mov   ah,PB YDither[ecx+6]          ; Fetch YE.                              m>PD P3 YE Y4         -- -- -- y5       <-- -- -- ye      C3 C3 C2 C2
   and  eax,00000FFFFH                ; Extract YE Y4.                          >-- -- YE Y4         -- -- -- y5        -- -- -- ye      C3 C3 C2 C2
  mov   dl,PB YDither[ebx+2]          ; Fetch Y5.                                -- -- YE Y4         -- -- -- y5        -- -- -- ye    m>C3 C3 C2 Y5
   mov  cl,[esi+2]                    ; Fetch y6.                                -- -- YE Y4         -- -- -- y5      m>-- -- -- y6      C3 C3 C2 Y5
  add   ebx,ecx                       ; Add y6 to y5.                            -- -- YE Y4        >-- -- -- y5+y6    <-- -- -- y6      C3 C3 C2 Y5
   shr  ebx,1                         ; yf = (y5 + y6) / 2.                      -- -- YE Y4        >-- -- -- yf        -- -- -- y6      C3 C3 C2 Y5
  mov   dh,PB YDither[ebx+4]          ; Fetch YF.                                -- -- YE Y4        <-- -- -- yf        -- -- -- y6      C3 C3 YF Y5
   shl  edx,16                        ; Extract YF Y5.                           -- -- YE Y4         -- -- -- yf        -- -- -- y6      YF Y5 -- --
  mov   bl,[esi+3]                    ; Fetch y7.                                -- -- YE Y4       m>-- -- -- y7        -- -- -- y6      YF Y5 -- --
   or   eax,edx                       ; < YF Y5 YE Y4>.                         >YF Y5 YE Y4         -- -- -- y7        -- -- -- y6     <YF Y5 -- --
  mov   edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.             YF Y5 YE Y4         -- -- -- y7        -- -- -- y6    s>C5 C5 C4 C4
   add  esp,8                         ;                                          YF Y5 YE Y4         -- -- -- y7        -- -- -- y6      C5 C5 C4 C4
  test  edx,edx
   jne  Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   edx,AspectCount
   mov  edi,CCOCursor               ; Fetch output cursor.
  sub   edx,2
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   AspectCount,edx
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   ebp,AspectAdjustmentCount
   jg   KeepLine1

  add   edx,ebp
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

   mov  ebp,LumaPitch
  mov   bl,[esi+ebp+2]              ; Fetch y130.                                XX XX XX XX       m>-- -- -- y130      -- -- -- --      XX XX XX XX
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y130      -- -- -- --      XX XX XX XX
  mov   cl,[esi+1]                  ; Fetch y1.                                  XX XX XX XX         -- -- -- y130    m>-- -- -- y1      XX XX XX XX
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y130      -- -- -- y1      XX XX XX XX
  add   ebx,ecx                     ; Add y1 to y130.                            XX XX XX XX        >-- -- -- y130+y1  <-- -- -- y1      XX XX XX XX
   shr  ebx,1                       ; yd = (y1 + y130) / 2.                      XX XX XX XX        >-- -- -- yd        -- -- -- y1      XX XX XX XX
  mov   dh,PB YDither[ebx+6]        ; Fetch YD.                                  XX XX XX XX        <-- -- -- yd        -- -- -- y1    m>XX XX YD XX
   mov  bl,[esi+ebp+1]              ; Fetch y129.                                XX XX XX XX       m>-- -- -- y129      -- -- -- y1      XX XX YD XX
  add   ecx,ebx                     ; Add y129 to y1.                            XX XX XX XX        <-- -- -- y129     >-- -- -- y1+y129 XX XX YD XX
   shr  ecx,1                       ; yc = (y1 + y129) / 2.                      XX XX XX XX         -- -- -- y129     >-- -- -- yc      XX XX YD XX
  mov   dl,PB YDither[ecx+0]        ; Fetch YC.                                  XX XX XX XX         -- -- -- y129     <-- -- -- yc    m>XX XX YD YC
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y129      -- -- -- yc      XX XX YD YC
  shl   edx,16                      ; Extract YD YC.                             XX XX XX XX         -- -- -- y129      -- -- -- yc     >YD YC -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y129      -- -- -- yc      YD YC -- --
  mov   cl,[esi]                    ; Fetch y0.                                  XX XX XX XX         -- -- -- y129    m>-- -- -- y0      YD YC -- --
   add  ebx,ecx                     ; Add y0 to y129.                            XX XX XX XX        >-- -- -- y129+y0  <-- -- -- y0      YD YC -- --
  shr   ebx,1                       ; yb = (y0 + y129) / 2.                      XX XX XX XX        >-- -- -- yb        -- -- -- y0      YD YC -- --
   mov  ah,PB YDither[ebx+4]        ; Fetch YB.                                m>XX XX YB XX        <-- -- -- yb        -- -- -- y0      YD YC -- --
  mov   bl,[esi+ebp]                ; Fetch y128.                                XX XX YB XX       m>-- -- -- y128      -- -- -- y0      YD YC -- --
   add  ecx,ebx                     ; Add y0 to y128.                            XX XX YB XX        <-- -- -- y128     >-- -- -- y0+y128 YD YC -- --
  shr   ecx,1                       ; ya = (y0 + y128) / 2.                      XX XX YB XX         -- -- -- y128     >-- -- -- ya      YD YC -- --
   mov  al,PB YDither[ecx+2]        ; Fetch YA.                                  XX XX YB YA         -- -- -- y128     <-- -- -- ya      YD YC -- --
  mov   bl,[esi+ebp+4]              ; Fetch y132.                                XX XX YB YA       m>-- -- -- y132      -- -- -- ya      YD YC -- --
   and  eax,00000FFFFH              ; Extract YB YA.                            >-- -- YB YA         -- -- -- y132      -- -- -- ya      YD YC -- --
  mov   cl,[esi+3]                  ; Fetch y3.                                  -- -- YB YA         -- -- -- y132    m>-- -- -- y3      YD YC -- --
   or   eax,edx                     ; < YD YC YB YA>.                           >YD YC YB YA         -- -- -- y132      -- -- -- y3     <YD YC -- --
  mov   edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               YD YC YB YA         -- -- -- y132      -- -- -- y3    m>C1 C1 C0 C0
   rol  edx,16                      ; Swap dither pattern.                       YD YC YB YA         -- -- -- y132      -- -- -- y3     >C0 C0 C1 C1
  sub   esp,1536

Line1Loop:

  add   eax,edx                       ; < PA PB PC PD>.                         >PD PC PB PA         -- -- -- y132      -- -- -- y3     <C0 C0 C1 C1
   add  ebx,ecx                       ; Add y3 to y132.                          PD PC PB PA        >-- -- -- y132+y3  <-- -- -- y3      C0 C0 C1 C1
  shr   ebx,1                         ; yh = (y3 + y132) / 2.                    PD PC PB PA        >-- -- -- yh        -- -- -- y3      C0 C0 C1 C1
   mov  dh,PB YDither[ebx+6]          ; Fetch YH.                                PD PC PB PA        <-- -- -- yh        -- -- -- y3    m>C0 C0 YH C1
  mov   bl,[esi+ebp+3]                ; Fetch y131.                              PD PC PB PA       m>-- -- -- y131      -- -- -- y3      C0 C0 YH C1
   add  ecx,ebx                       ; Add y131 to y3.                          PD PC PB PA        <-- -- -- y131     >-- -- -- y3+y131 C0 C0 YH C1
  shr   ecx,1                         ; yg = (y3 + y131) / 2.                    PD PC PB PA         -- -- -- y131     >-- -- -- yg      C0 C0 YH C1
   mov  dl,PB YDither[ecx+0]          ; Fetch YG.                                PD PC PB PA         -- -- -- y131     <-- -- -- yg    m>C0 C0 YH YG
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PD PC PB PA         -- -- -- y131      -- -- -- yg      C0 C0 YH YG
   shl  edx,16                        ; Extract YH YG.                           PD PC PB PA         -- -- -- y131      -- -- -- yg     >YH YG -- --
  mov   cl,[esi+2]                    ; Fetch y2.                                PD PC PB PA         -- -- -- y131    m>-- -- -- y2      YH YG -- --
   add  ebx,ecx                       ; Add y2 to y131.                          PD PC PB PA        >-- -- -- y131+y0  <-- -- -- y2      YH YG -- --
  shr   ebx,1                         ; yf = (y2 + y131) / 2.                    PD PC PB PA        >-- -- -- yf        -- -- -- y2      YH YG -- --
   mov  ah,PB YDither[ebx+4]          ; Fetch YF.                              m>PD PC YF PA        <-- -- -- yf        -- -- -- y2      YH YG -- --
  mov   bl,[esi+ebp+2]                ; Fetch y130.                              PD PC YF PA       m>-- -- -- y130      -- -- -- y2      YH YG -- --
   add  ecx,ebx                       ; Add y2 to y130.                          PD PC YF PA        <-- -- -- y130     >-- -- -- y2+y130 YH YG -- --
  shr   ecx,1                         ; ye = (y2 + y130) / 2.                    PD PC YF PA         -- -- -- y130     >-- -- -- ye      YH YG -- --
   mov  al,PB YDither[ecx+2]          ; Fetch YE.                                PD PC YF YE         -- -- -- y130     <-- -- -- ye      YH YG -- --
  add   esi,4                         ; Advance cursor.                          PD PC YF YE         -- -- -- y130      -- -- -- ye      YH YG -- --
   and  eax,00000FFFFH                ; Extract YF YE.                          >-- -- YF YE         -- -- -- y130      -- -- -- ye      YH YG -- --
  mov   bl,[esi+ebp+2]                ; Fetch y134.                              -- -- YF YE       m>-- -- -- y134      -- -- -- ye      YH YG -- --
   or   eax,edx                       ; < YH YG YF YE>.                         >YH YG YF YE         -- -- -- y134      -- -- -- ye     <YH YG -- --
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             YH YG YF YE         -- -- -- y134      -- -- -- ye    s>C3 C3 C2 C2
   rol  edx,16                        ; Swap dither pattern.                     YH YG YF YE         -- -- -- y134      -- -- -- ye     >C2 C2 C3 C3
  add   esp,8                         ;                                          YH YG YF YE         -- -- -- y134      -- -- -- ye      C2 C2 C3 C3
   add  eax,edx                       ; < PH PG PF PE>.                         >PH PG PF PE         -- -- -- y134      -- -- -- ye     <C2 C2 C3 C3
  mov   cl,[esi+1]                    ; Fetch y5.                                PH PG PF PE         -- -- -- y134    m>-- -- -- y5      C2 C2 C3 C3
   mov  Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PH PG PF PE         -- -- -- y134      -- -- -- y5      C2 C2 C3 C3
  add   ebx,ecx                       ; Add y5 to y134.                          PH PG PF PE        >-- -- -- y134+y5  <-- -- -- y5      C2 C2 C3 C3
   shr  ebx,1                         ; yl = (y5 + y134) / 2.                    PH PG PF PE        >-- -- -- yl        -- -- -- y5      C2 C2 C3 C3
  mov   dh,PB YDither[ebx+6]          ; Fetch YL.                                PH PG PF PE        <-- -- -- yl        -- -- -- y5    m>C2 C2 YL C3
   mov  bl,[esi+ebp+1]                ; Fetch y133.                              PH PG PF PE       m>-- -- -- y133      -- -- -- y5      C2 C2 YL C3
  add   ecx,ebx                       ; Add y133 to y5.                          PH PG PF PE        <-- -- -- y133     >-- -- -- y5+y133 C2 C2 YL C3
   shr  ecx,1                         ; yk = (y5 + y133) / 2.                    PH PG PF PE         -- -- -- y133     >-- -- -- yk      C2 C2 YL C3
  mov   dl,PB YDither[ecx+0]          ; Fetch YK.                                PH PG PF PE         -- -- -- y133     <-- -- -- yk    m>C2 C2 YL YK
   shl  edx,16                        ; Extract YL YK.                           PH PG PF PE         -- -- -- y133      -- -- -- yk     >YL YK -- --
  mov   cl,[esi]                      ; Fetch y4.                                PH PG PF PE         -- -- -- y133    m>-- -- -- y4      YL YK -- --
   add  ebx,ecx                       ; Add y4 to y133.                          PH PG PF PE        >-- -- -- y133+y4  <-- -- -- y4      YL YK -- --
  shr   ebx,1                         ; yj = (y4 + y133) / 2.                    PH PG PF PE        >-- -- -- yj        -- -- -- y4      YL YK -- --
   mov  ah,PB YDither[ebx+4]          ; Fetch YJ.                              m>PH PG YJ PE        <-- -- -- yj        -- -- -- y4      YL YK -- --
  mov   bl,[esi+ebp]                  ; Fetch y132.                              PH PG YJ PE       m>-- -- -- y132      -- -- -- y4      YL YK -- --
   add  ecx,ebx                       ; Add y4 to y132.                          PH PG YJ PE        <-- -- -- y132     >-- -- -- y4+y132 YL YK -- --
  shr   ecx,1                         ; yi = (y4 + y132) / 2.                    PH PG YJ PE         -- -- -- y132     >-- -- -- yi      YL YK -- --
   mov  al,PB YDither[ecx+2]          ; Fetch YI.                                PH PG YJ YI         -- -- -- y132     <-- -- -- yi      YL YK -- --
  and   eax,00000FFFFH                ; Extract YJ YI.                          >-- -- YJ YI         -- -- -- y132      -- -- -- yi      YL YK -- --
   mov  bl,[esi+ebp+4]                ; Fetch y136.                              -- -- YJ YI       m>-- -- -- y136      -- -- -- yi      YL Yk -- --
  or    eax,edx                       ; < YL YK YJ YI>.                         >YL YK YJ YI         -- -- -- y136      -- -- -- yi      YL YK -- --
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             YL YK YJ YI         -- -- -- y136      -- -- -- yi    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     YL YK YJ YI         -- -- -- y136      -- -- -- yi     >C4 C4 C5 C5
   mov  cl,[esi+3]                    ; Fetch y7.                                YL YK YJ YI         -- -- -- y136    m>-- -- -- y7      C4 C4 C5 C5
  test  edx,edx
   jne  Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

; Now color convert the second input line of luma.

  mov   esi,YCursor                 ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+ebp*1]              ; Fetch y0.                                  XX XX XX XX       m>-- -- -- y0        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y0        -- -- -- --      -- -- -- --
  mov   cl,[esi+ebp*1+1]            ; Fetch y1.                                  XX XX XX XX         -- -- -- y0      m>-- -- -- y1      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y0        -- -- -- y1      -- -- -- --
  mov   dh,PB YDither[ebx+6]        ; Fecth Y0.                                  XX XX XX XX         -- -- -- y0        -- -- -- y1      -- -- Y0 --
   add  ebx,ecx                     ; Add y1 to y0.                              XX XX XX XX        >-- -- -- y0+y1    <-- -- -- y1      -- -- Y0 --
  shr   ebx,1                       ; ya = (y0 + y1) / 2.                        XX XX XX XX        >-- -- -- ya        -- -- -- y1      -- -- Y0 --
   mov  dl,PB YDither[ebx+0]        ; Fetch YA.                                  XX XX XX XX        <-- -- -- ya        -- -- -- y1    m>-- -- Y0 YA
  sub   edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- ya        -- -- -- y1      -- -- Y0 YA
   shl  edx,16                      ; Extract Y0 YA                              XX XX XX XX         -- -- -- ya        -- -- -- y1     >Y0 YA -- --
  sub   edi,esi                     ;                                            XX XX XX XX         -- -- -- ya        -- -- -- y1      Y0 YA -- --
   mov  bl,[esi+ebp*1+2]            ; Fetch y2.                                  XX XX XX XX       m>-- -- -- y2        -- -- -- y1      Y0 YA -- --
  mov   ah,PB YDither[ecx+4]        ; Fetch Y1.                                m>XX XX Y1 XX         -- -- -- y2       <-- -- -- y1      Y0 YA -- --
   add  ecx,ebx                     ; Add y2 to y1.                              XX XX Y1 XX         -- -- -- y2       >-- -- -- y1+y2   Y0 YA -- --
  shr   ecx,1                       ; yb = (y1 + y2) / 2.                        XX XX Y1 XX         -- -- -- y2       >-- -- -- yb      Y0 YA -- --
   mov  al,PB YDither[ecx+2]        ; Fetch YB.                                m>XX XX Y1 YB         -- -- -- y2       <-- -- -- yb      Y0 YA -- --
  and   eax,00000FFFFH              ; Extract Y1 YB.                            >-- -- Y1 YB         -- -- -- y2        -- -- -- yb      Y0 YA -- --
   mov  cl,[esi+ebp*1+3]            ; Fetch y3.                                  -- -- Y1 YB         -- -- -- y2      m>-- -- -- y3      Y0 YA -- --
  or    eax,edx                     ; < Y0 YA Y1 YB>.                           >Y0 YA Y1 YB         -- -- -- y2        -- -- -- y3     <Y0 YA -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y0 YA Y1 YB         -- -- -- y2        -- -- -- y3    m>C1 C1 C0 C0
  rol   edx,16                      ; Swap dither pattern.                       Y0 YA Y1 YB         -- -- -- y2        -- -- -- y3     >C0 C0 C1 C1
   sub  esp,1536

Line2Loop:

  add   eax,edx                       ; < P0 PA P1 PB>.                         >P0 PA P1 PB         -- -- -- y2        -- -- -- y3      C0 C0 C1 C1
   mov  dh,PB YDither[ebx+6]          ; Fecth Y2.                                P0 PA P1 PB        <-- -- -- y2        -- -- -- y3    m>C0 C0 Y2 C1
  add   ebx,ecx                       ; Add y3 to y2.                            P0 PA P1 PB        >-- -- -- y2+y3    <-- -- -- y3      C0 C0 Y2 C1
   shr  ebx,1                         ; yc = (y2 + y3) / 2.                      P0 PA P1 PB        >-- -- -- yc        -- -- -- y3      C0 C0 Y2 C1
  mov   dl,PB YDither[ebx+0]          ; Fetch YC.                                P0 PA P1 PB        <-- -- -- yc        -- -- -- y3    m>C0 C0 Y2 YC
   bswap eax                          ; < PB P1 PA P0>.                         >PB P1 PA P0         -- -- -- yc        -- -- -- y3      C0 C0 Y2 YC
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PB P1 PA P0         -- -- -- yc        -- -- -- y3      C0 C0 Y2 YC
   add  esi,4                         ;                                          PB P1 PA P0         -- -- -- yc        -- -- -- y3      C0 C0 Y2 YC
  shl   edx,16                        ; Extract Y2 YC.                           PB P1 PA P0         -- -- -- yc        -- -- -- y3     >Y2 YC -- --
   mov  bl,[esi+ebp*1]                ; Fetch y4.                                PB P1 PA P0       m>-- -- -- y4        -- -- -- y3      Y2 YC -- --
  mov   ah,PB YDither[ecx+4]          ; Fetch Y3.                              m>PB P1 Y3 P0         -- -- -- y4       <-- -- -- y3      Y2 YC -- --
   add  ecx,ebx                       ; Add y4 to y3.                            PB P1 Y3 P0         -- -- -- y4       >-- -- -- y4+y4   Y2 YC -- --
  shr   ecx,1                         ; yd = (y3 + y4) / 2.                      PB P1 Y3 P0         -- -- -- y4       >-- -- -- yd      Y2 YC -- --
   mov  al,PB YDither[ecx+2]          ; Fetch YD.                              m>PB P1 Y3 YD         -- -- -- y4       <-- -- -- yd      Y2 YC -- --
  and   eax,00000FFFFH                ; Extract Y3 YD.                          >-- -- Y3 YD         -- -- -- y4        -- -- -- yd      Y2 YC -- --
   or   eax,edx                       ; < Y2 YC Y3 YD>.                         >Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd     <Y2 YC -- --
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd    s>C3 C3 C2 C2
   rol  edx,16                        ; Swap dither pattern.                     Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd    s>C2 C2 C3 C3
  add   esp,8                         ;                                          Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd      C2 C2 C3 C3
   add  eax,edx                       ; < P2 PC P3 PD>.                         >P2 PC P3 PD         -- -- -- y4        -- -- -- yd     <C2 C2 C3 C3
  mov   cl,[esi+ebp*1+1]              ; Fetch next y5.                           P2 PC P3 PD         -- -- -- y4      m>-- -- -- y5      C2 C2 C3 C3
   bswap eax                          ; < PD P3 PC P2>.                         >PD P3 PC P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PD P3 PC P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
   mov  dh,PB YDither[ebx+6]          ; Fecth Y4.                                PD P3 PC P2        <-- -- -- y4        -- -- -- y5    m>C2 C2 Y4 C3
  add   ebx,ecx                       ; Add y5 to y4.                            PD P3 PC P2        >-- -- -- y4+y5    <-- -- -- y5      C2 C2 Y4 C3
   shr  ebx,1                         ; ye = (y4 + y5) / 2.                      PD P3 PC P2        >-- -- -- ye        -- -- -- y5      C2 C2 Y4 C3
  mov   dl,PB YDither[ebx+0]          ; Fetch YE.                                PD P3 PC P2        <-- -- -- ye        -- -- -- y5    m>C2 C2 Y4 YE
   shl  edx,16                        ; Extract Y4 YE.                           PD P3 PC P2         -- -- -- ye        -- -- -- y5     >Y4 YE -- --
  mov   bl,[esi+ebp*1+2]              ; Fetch y6.                                PD P3 PC P2       m>-- -- -- y6        -- -- -- y5      Y4 YE -- --
   mov  ah,PB YDither[ecx+4]          ; Fetch Y5.                              m>PD P3 Y5 P2         -- -- -- y6       <-- -- -- y5      Y4 YE -- --
  add   ecx,ebx                       ; Add y6 to y5.                            PD P3 Y5 P2         -- -- -- y6       >-- -- -- y5+y6   Y4 YE -- --
   shr  ecx,1                         ; yf = (y5 + y6) / 2.                      PD P3 Y5 P2         -- -- -- y6       >-- -- -- yf      Y4 YE -- --
  mov   al,PB YDither[ecx+2]          ; Fetch YF.                              m>PD P3 Y5 YF         -- -- -- y6       <-- -- -- yf      Y4 YE -- --
   and  eax,00000FFFFH                ; Extract Y5 YF.                          >-- -- Y5 YF         -- -- -- y6        -- -- -- yf      Y4 YE -- --
  or    eax,edx                       ; < Y4 YE Y5 YF>.                         >Y4 YE Y5 YF         -- -- -- y6        -- -- -- yf      Y4 YE -- --
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             Y4 YE Y5 YF         -- -- -- y6        -- -- -- yf    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     Y4 YE Y5 YF         -- -- -- y6        -- -- -- yf     >C4 C4 C5 C5
   mov  cl,[esi+ebp*1+3]              ; Fetch y7.                                Y4 YE Y5 YF         -- -- -- y6      m>-- -- -- y7      C4 C4 C5 C5
  test  edx,edx
   jne  Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   esi,YCursor
   mov  edx,AspectCount
  mov   edi,CCOCursor               ; Fetch output cursor.
   sub  edx,2
  lea   eax,[esi+ebp*2]             ; Compute start of next line.
   mov  AspectCount,edx
  mov   YCursor,eax
   jg   KeepLine3

  add   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

   mov  bl,[esi+ebp*2+2]            ; Fetch y130.                                XX XX XX XX       m>-- -- -- y130      -- -- -- --      XX XX XX XX
  mov   eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- y130      -- -- -- --      XX XX XX XX
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y130      -- -- -- --      XX XX XX XX
  mov   cl,[esi+ebp+1]              ; Fetch y1.                                  XX XX XX XX         -- -- -- y130    m>-- -- -- y1      XX XX XX XX
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y130      -- -- -- y1      XX XX XX XX
  add   ebx,ecx                     ; Add y1 to y130.                            XX XX XX XX        >-- -- -- y130+y1  <-- -- -- y1      XX XX XX XX
   shr  ebx,1                       ; yd = (y1 + y130) / 2.                      XX XX XX XX        >-- -- -- yd        -- -- -- y1      XX XX XX XX
  mov   al,PB YDither[ebx+0]        ; Fetch YD.                                m>XX XX XX YD        <-- -- -- yd        -- -- -- y1      XX XX XX XX
   mov  bl,[esi+ebp+1]              ; Fetch y129.                                XX XX XX YD       m>-- -- -- y129      -- -- -- y1      XX XX XX XX
  add   ecx,ebx                     ; Add y129 to y1.                            XX XX XX YD        <-- -- -- y129     >-- -- -- y1+y129 XX XX XX XX
   shr  ecx,1                       ; yc = (y1 + y129) / 2.                      XX XX XX YD         -- -- -- y129     >-- -- -- yc      XX XX XX XX
  mov   ah,PB YDither[ecx+6]        ; Fetch YC.                                m>XX XX YC YD         -- -- -- y129     <-- -- -- yc      XX XX XX XX
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX YC YD         -- -- -- y129      -- -- -- yc      XX XX XX XX
  and   eax,00000FFFFH              ; Extract YD YC.                            >-- -- YC YD         -- -- -- y129      -- -- -- yc      XX XX XX XX
   sub  edi,esi                     ;                                            -- -- YC YD         -- -- -- y129      -- -- -- yc      XX XX XX XX
  mov   cl,[esi+ebp]                ; Fetch y0.                                  -- -- YC YD         -- -- -- y129    m>-- -- -- y0      XX XX XX XX
   add  ebx,ecx                     ; Add y0 to y129.                            -- -- YC YD        >-- -- -- y129+y0  <-- -- -- y0      XX XX XX XX
  shr   ebx,1                       ; yb = (y0 + y129) / 2.                      -- -- YC YD        >-- -- -- yb        -- -- -- y0      XX XX XX XX
   mov  dl,PB YDither[ebx+2]        ; Fetch YB.                                  -- -- YC YD        <-- -- -- yb        -- -- -- y0    m>XX XX XX YB
  mov   bl,[esi+ebp*2]              ; Fetch y128.                                -- -- YC YD       m>-- -- -- y128      -- -- -- y0      XX XX XX YB
   add  ecx,ebx                     ; Add y0 to y128.                            -- -- YC YD        <-- -- -- y128     >-- -- -- y0+y128 XX XX XX YB
  shr   ecx,1                       ; ya = (y0 + y128) / 2.                      -- -- YC YD         -- -- -- y128     >-- -- -- ya      XX XX XX YB
   mov  dh,PB YDither[ecx+4]        ; Fetch YA.                                  -- -- YC YD         -- -- -- y128     <-- -- -- ya    m>XX XX YA YB
  mov   bl,[esi+ebp*2+4]            ; Fetch y132.                                -- -- YC YD       m>-- -- -- y132      -- -- -- ya      XX XX YA YB
   shl  edx,16                      ; Extract YB YA.                             -- -- YC YD         -- -- -- y132      -- -- -- ya     >YA YB -- --
  mov   cl,[esi+ebp+3]              ; Fetch y3.                                  -- -- YC YD         -- -- -- y132    m>-- -- -- y3      YA YB -- --
   or   eax,edx                     ; < YD YC YB YA>.                           >YA YB YC YD         -- -- -- y132      -- -- -- y3     <YA YB -- --
  mov   edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               YA YB YC YD         -- -- -- y132      -- -- -- y3    m>C1 C1 C0 C0
   sub  esp,1536

Line3Loop:

  add   eax,edx                       ; < PA PB PC PD>.                         >PA PB PC PD         -- -- -- y132      -- -- -- y3     <C1 C1 C0 C0
   add  ebx,ecx                       ; Add y3 to y132.                          PA PB PC PD        >-- -- -- y132+y3  <-- -- -- y3      C1 C1 C0 C0
  shr   ebx,1                         ; yh = (y3 + y132) / 2.                    PA PB PC PD        >-- -- -- yh        -- -- -- y3      C1 C1 C0 C0
   mov  dl,PB YDither[ebx+0]          ; Fetch YH.                                PA PB PC PD        <-- -- -- yh        -- -- -- y3    m>C1 C1 C0 YH
  bswap eax                           ;                                         >PD PC PB PA         -- -- -- yh        -- -- -- y3      C1 C1 C0 YH
  mov   bl,[esi+ebp*2+3]              ; Fetch y131.                              PD PC PB PA       m>-- -- -- y131      -- -- -- y3      C1 C1 C0 YH
   add  ecx,ebx                       ; Add y131 to y3.                          PD PC PB PA        <-- -- -- y131     >-- -- -- y3+y131 C1 C1 C0 YH
  shr   ecx,1                         ; yg = (y3 + y131) / 2.                    PD PC PB PA         -- -- -- y131     >-- -- -- yg      C1 C1 C0 YH
   mov  dh,PB YDither[ecx+6]          ; Fetch YG.                                PD PC PB PA         -- -- -- y131     <-- -- -- yg    m>C1 C1 YG YH
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PD PC PB PA         -- -- -- y131      -- -- -- yg      C1 C1 YG YH
   and  edx,00000FFFFH                ; Extract YG YH.                           PD PC PB PA         -- -- -- y131      -- -- -- yg     >-- -- YG YH
  mov   cl,[esi+ebp+2]                ; Fetch y2.                                PD PC PB PA         -- -- -- y131    m>-- -- -- y2      -- -- YG YH
   add  ebx,ecx                       ; Add y2 to y131.                          PD PC PB PA        >-- -- -- y131+y0  <-- -- -- y2      -- -- YG YH
  shr   ebx,1                         ; yf = (y2 + y131) / 2.                    PD PC PB PA        >-- -- -- yf        -- -- -- y2      -- -- YG YH
   mov  al,PB YDither[ebx+2]          ; Fetch YF.                              m>PD PC PB YF        <-- -- -- yf        -- -- -- y2      -- -- YG YH
  mov   bl,[esi+ebp*2+2]              ; Fetch y130.                              PD PC PB YF       m>-- -- -- y130      -- -- -- y2      -- -- YG YH
   add  ecx,ebx                       ; Add y2 to y130.                          PD PC PB YF        <-- -- -- y130     >-- -- -- y2+y130 -- -- YG YH
  shr   ecx,1                         ; ye = (y2 + y130) / 2.                    PD PC PB YF         -- -- -- y130     >-- -- -- ye      -- -- YG YH
   mov  ah,PB YDither[ecx+4]          ; Fetch YE.                                PD PC YE YF         -- -- -- y130     <-- -- -- ye      -- -- YG YH
  add   esi,4                         ; Advance cursor.                          PD PC YE YF         -- -- -- y130      -- -- -- ye      -- -- YG YH
   shl  eax,16                        ; Extract YE YF.                          >YE YF -- --         -- -- -- y130      -- -- -- ye      -- -- YG YH
  mov   bl,[esi+ebp*2+2]              ; Fetch y134.                              YE YF -- --       m>-- -- -- y134      -- -- -- ye      -- -- YG YH
   or   eax,edx                       ; < YH YG YF YE>.                         >YE YF YG YH         -- -- -- y134      -- -- -- ye     <-- -- YG YH
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             YE YF YG YH         -- -- -- y134      -- -- -- ye    s>C3 C3 C2 C2
  add   esp,8                         ;                                          YE YF YG YH         -- -- -- y134      -- -- -- ye      C3 C3 C2 C2
   add  eax,edx                       ; < PH PG PF PE>.                         >PE PF PG PH         -- -- -- y134      -- -- -- ye     <C3 C3 C2 C2
  mov   cl,[esi+ebp+1]                ; Fetch y5.                                PE PF PG PH         -- -- -- y134    m>-- -- -- y5      C3 C3 C2 C2
  bswap eax                           ;                                         >PH PG PF PE         -- -- -- y134      -- -- -- y5      C3 C3 C2 C2
   mov  Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PH PG PF PE         -- -- -- y134      -- -- -- y5      C3 C3 C2 C2
  add   ebx,ecx                       ; Add y5 to y134.                          PH PG PF PE        >-- -- -- y134+y5  <-- -- -- y5      C3 C3 C2 C2
   shr  ebx,1                         ; yl = (y5 + y134) / 2.                    PH PG PF PE        >-- -- -- yl        -- -- -- y5      C3 C3 C2 C2
  mov   dl,PB YDither[ebx+0]          ; Fetch YL.                                PH PG PF PE        <-- -- -- yl        -- -- -- y5    m>C3 C3 C2 YL
   mov  bl,[esi+ebp*2+1]              ; Fetch y133.                              PH PG PF PE       m>-- -- -- y133      -- -- -- y5      C3 C3 C2 YL
  add   ecx,ebx                       ; Add y133 to y5.                          PH PG PF PE        <-- -- -- y133     >-- -- -- y5+y133 C3 C3 C2 YL
   shr  ecx,1                         ; yk = (y5 + y133) / 2.                    PH PG PF PE         -- -- -- y133     >-- -- -- yk      C3 C3 C2 YL
  mov   dh,PB YDither[ecx+6]          ; Fetch YK.                                PH PG PF PE         -- -- -- y133     <-- -- -- yk    m>C3 C3 YK YL
   and  edx,00000FFFFH                ; Extract YK YL.                           PH PG PF PE         -- -- -- y133      -- -- -- yk     >-- -- YK YL
  mov   cl,[esi+ebp]                  ; Fetch y4.                                PH PG PF PE         -- -- -- y133    m>-- -- -- y4      -- -- YK YL
   add  ebx,ecx                       ; Add y4 to y133.                          PH PG PF PE        >-- -- -- y133+y4  <-- -- -- y4      -- -- YK YL
  shr   ebx,1                         ; yj = (y4 + y133) / 2.                    PH PG PF PE        >-- -- -- yj        -- -- -- y4      -- -- YK YL
   mov  al,PB YDither[ebx+2]          ; Fetch YJ.                              m>PH PG PF YJ        <-- -- -- yj        -- -- -- y4      -- -- YK YL
  mov   bl,[esi+ebp*2]                ; Fetch y132.                              PH PG PF YJ       m>-- -- -- y132      -- -- -- y4      -- -- YK YL
   add  ecx,ebx                       ; Add y4 to y132.                          PH PG PF YJ        <-- -- -- y132     >-- -- -- y4+y132 -- -- YK YL
  shr   ecx,1                         ; yi = (y4 + y132) / 2.                    PH PG PF YJ         -- -- -- y132     >-- -- -- yi      -- -- YK YL
   mov  ah,PB YDither[ecx+4]          ; Fetch YI.                                PH PG YI YJ         -- -- -- y132     <-- -- -- yi      -- -- YK YL
  shl   eax,16                        ; Extract YI YJ.                          >YI YJ -- --         -- -- -- y132      -- -- -- yi      -- -- YK YL
   mov  bl,[esi+ebp*2+4]              ; Fetch y136.                              YI YJ -- --       m>-- -- -- y136      -- -- -- yi      -- -- YK YL
  or    eax,edx                       ; < YL YK YJ YI>.                         >YI YJ YK YL         -- -- -- y136      -- -- -- yi      -- -- YK YL
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             YI YJ YK YL         -- -- -- y136      -- -- -- yi    s>C5 C5 C4 C4
   mov  cl,[esi+ebp+3]                ; Fetch y7.                                YI YJ YK YL         -- -- -- y136    m>-- -- -- y7      C5 C5 C4 C4
  test  edx,edx
   jne  Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextTwoLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8ZoomBy2 endp

ELSE

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   ChromaLineLen,ebx
   mov  YLimit,edx

NextTwoLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8 
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov   [esi],edx                   ; Stash EOL indication.
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+1]                  ; Fetch Y01.                                 XX XX XX XX       m>-- -- -- y1        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      -- -- -- --
  mov   cl,[esi]                    ; Fetch Y00.                                 XX XX XX XX         -- -- -- y1      m>-- -- -- y0      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      -- -- -- --
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.               XX XX XX XX        <-- -- -- y1        -- -- -- y0    m>Y1 Y1 Y1 Y1
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 Y1 Y1
  and   edx,0FFFF0000H              ; Extract < Y01  Y01  ___  ___>.             XX XX XX XX         -- -- -- y1        -- -- -- y0     >Y1 Y1 -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 -- --
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.             m>Y0 Y0 Y0 Y0         -- -- -- y1       <-- -- -- y0      Y1 Y1 -- --
   mov  bl,[esi+3]                  ; Fetch Y03.                                 Y0 Y0 Y0 Y0       m>-- -- -- y3        -- -- -- y0      Y1 Y1 -- --
  and   eax,00000FFFFH              ; Extract < ___  ___  Y00  Y00>.            >-- -- Y0 Y0         -- -- -- y3        -- -- -- y0      Y1 Y1 -- --
   mov  cl,[esi+2]                  ; Fetch Y02.                                 -- -- Y0 Y0         -- -- -- y3      m>-- -- -- y2      Y1 Y1 -- --
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     <Y1 Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  sub   esp,1536

Line0Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     <C1 C1 C0 C0
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P1 P1 P0 P0        <-- -- -- y3        -- -- -- y2    m>Y3 Y3 Y3 Y3
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
   add  esi,4                         ; Advance cursor.                          P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  and   edx,0FFFF0000H                ; Extract < Y03  Y03  ___  ___>.           P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     >Y3 Y3 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y2 Y2 Y2 Y2         -- -- -- y3       <-- -- -- y2      Y3 Y3 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y02  Y02>.          >-- -- Y2 Y2         -- -- -- y3        -- -- -- y2      Y3 Y3 -- --
   mov  bl,[esi+1]                    ; Fetch next Y01.                          -- -- Y2 Y2       m>-- -- -- y5        -- -- -- y2      Y3 Y3 -- --
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2     <Y3 Y3 -- --
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2    s>C3 C3 C2 C2
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P3 P3 P2 P2         -- -- -- y5        -- -- -- y2     <C3 C3 C2 C2
   mov  cl,[esi]                      ; Fetch next Y00.                          P3 P3 P2 P2         -- -- -- y5      m>-- -- -- y4      C3 C3 C2 C2
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P3 P3 P2 P2         -- -- -- y5        -- -- -- y4      C3 C3 C2 C2
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P3 P3 P2 P2        <-- -- -- y5        -- -- -- y4    m>Y5 Y5 Y5 Y5
  and   edx,0FFFF0000H                ; Extract < Y01  Y01  ___  ___>.           P3 P3 P2 P2         -- -- -- y5        -- -- -- y4     >Y5 Y5 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y4 Y4 Y4 Y4         -- -- -- y5       <-- -- -- y4      Y5 Y5 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y00  Y00>.          >-- -- Y4 Y4         -- -- -- y5        -- -- -- y4      Y5 Y5 -- --
   mov  bl,[esi+3]                    ; Fetch Y03.                               -- -- Y4 Y4       m>-- -- -- y7        -- -- -- y4      Y5 Y5 -- --
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4      Y5 Y5 -- --
   mov  edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.             Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4    s>C5 C5 C4 C4
  add   esp,8                         ;                                          Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4      C5 C5 C4 C4
   mov  cl,[esi+2]                    ; Fetch Y02.                               Y5 Y5 Y4 Y4         -- -- -- y7      m>-- -- -- y6      C5 C5 C4 C4
  test  edx,edx
   jne  Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   edx,AspectCount
   mov  edi,CCOCursor               ; Fetch output cursor.
  sub   edx,2
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   AspectCount,edx
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   ebp,AspectAdjustmentCount
   jg   KeepLine1

  add   edx,ebp
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  mov   bl,[esi+1]                  ; Fetch Y01.                                 XX XX XX XX       m>-- -- -- y1        -- -- -- --      XX XX XX XX
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      XX XX XX XX
  mov   cl,[esi]                    ; Fetch Y00.                                 XX XX XX XX         -- -- -- y1      m>-- -- -- y0      XX XX XX XX
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      XX XX XX XX
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.               XX XX XX XX        <-- -- -- y1        -- -- -- y0    m>Y1 Y1 Y1 Y1
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 Y1 Y1
  shl   edx,16                      ; Extract < Y01  Y01  ___  ___>.             XX XX XX XX         -- -- -- y1        -- -- -- y0     >Y1 Y1 -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 -- --
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.             m>Y0 Y0 Y0 Y0         -- -- -- y1       <-- -- -- y0      Y1 Y1 -- --
   mov  bl,[esi+3]                  ; Fetch Y03.                                 Y0 Y0 Y0 Y0       m>-- -- -- y3        -- -- -- y0      Y1 Y1 -- --
  shr   eax,16                      ; Extract < ___  ___  Y00  Y00>.            >-- -- Y0 Y0         -- -- -- y3        -- -- -- y0      Y1 Y1 -- --
   mov  cl,[esi+2]                  ; Fetch Y02.                                 -- -- Y0 Y0         -- -- -- y3      m>-- -- -- y2      Y1 Y1 -- --
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     <Y1 Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  rol   edx,16                      ; Swap dither pattern.                       Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     >C0 C0 C1 C1
   sub  esp,1536

Line1Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     <C0 C0 C1 C1
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P1 P1 P0 P0        <-- -- -- y3        -- -- -- y2    m>Y3 Y3 Y3 Y3
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
   add  esi,4                         ; Advance cursor.                          P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  shl   edx,16                        ; Extract < Y03  Y03  ___  ___>.           P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     >-- -- Y3 Y3
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y2 Y2 Y2 Y2         -- -- -- y3       <-- -- -- y2      -- -- Y3 Y3
  shr   eax,16                        ; Extract < ___  ___  Y02  Y02>.          >Y2 Y2 -- --         -- -- -- y3        -- -- -- y2      -- -- Y3 Y3
   mov  bl,[esi+1]                    ; Fetch next Y01.                          Y2 Y2 -- --       m>-- -- -- y5        -- -- -- y2      -- -- Y3 Y3
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2     <-- -- Y3 Y3
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2    s>C3 C3 C2 C2
  rol   edx,16                        ; Swap dither pattern.                     Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2    s>C2 C2 C3 C3
   add  esp,8                         ;                                          Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2      C2 C2 C3 C3
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P2 P2 P3 P3         -- -- -- y5        -- -- -- y2     <C2 C2 C3 C3
   mov  cl,[esi]                      ; Fetch next Y00.                          P2 P2 P3 P3         -- -- -- y5      m>-- -- -- y4      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P2 P2 P3 P3         -- -- -- y5        -- -- -- y4      C2 C2 C3 C3
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P2 P2 P3 P3        <-- -- -- y5        -- -- -- y4    m>Y5 Y5 Y5 Y5
  shl   edx,16                        ; Extract < Y01  Y01  ___  ___>.           P2 P2 P3 P3         -- -- -- y5        -- -- -- y4     >-- -- Y5 Y5
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y4 Y4 Y4 Y4         -- -- -- y5       <-- -- -- y4      -- -- Y5 Y5
  shr   eax,16                        ; Extract < ___  ___  Y00  Y00>.          >Y4 Y4 -- --         -- -- -- y5        -- -- -- y4      -- -- Y5 Y5
   mov  bl,[esi+3]                    ; Fetch Y03.                               Y4 Y4 -- --       m>-- -- -- y7        -- -- -- y4      -- -- Y5 Y5
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y4 Y4 Y5 Y5         -- -- -- y7        -- -- -- y4      -- -- Y5 Y5
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             Y4 Y4 Y5 Y5         -- -- -- y7        -- -- -- y4    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     Y4 Y4 Y5 Y5         -- -- -- y7        -- -- -- y4     >C4 C4 C5 C5
   mov  cl,[esi+2]                    ; Fetch Y02.                               Y4 Y4 Y5 Y5         -- -- -- y7      m>-- -- -- y6      C4 C4 C5 C5
  test  edx,edx
   jne  Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

; Now color convert the second input line of luma.

  mov   esi,YCursor                 ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+ebp*1]              ; Fetch Y01.                                 XX XX XX XX       m>-- -- -- y1        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      -- -- -- --
  mov   cl,[esi+ebp*1+1]            ; Fetch Y00.                                 XX XX XX XX         -- -- -- y1      m>-- -- -- y0      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      -- -- -- --
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.               XX XX XX XX        <-- -- -- y1        -- -- -- y0    m>Y1 Y1 Y1 Y1
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 Y1 Y1
  shl   edx,16                      ; Extract < Y01  Y01  ___  ___>.             XX XX XX XX         -- -- -- y1        -- -- -- y0     >Y1 Y1 -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 -- --
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.             m>Y0 Y0 Y0 Y0         -- -- -- y1       <-- -- -- y0      Y1 Y1 -- --
   mov  bl,[esi+ebp*1+2]            ; Fetch Y03.                                 Y0 Y0 Y0 Y0       m>-- -- -- y3        -- -- -- y0      Y1 Y1 -- --
  shr   eax,16                      ; Extract < ___  ___  Y00  Y00>.            >-- -- Y0 Y0         -- -- -- y3        -- -- -- y0      Y1 Y1 -- --
   mov  cl,[esi+ebp*1+3]            ; Fetch Y02.                                 -- -- Y0 Y0         -- -- -- y3      m>-- -- -- y2      Y1 Y1 -- --
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     <Y1 Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  rol   edx,16                      ; Swap dither pattern.                       Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     >C0 C0 C1 C1
   sub  esp,1536

Line2Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     <C0 C0 C1 C1
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P1 P1 P0 P0        <-- -- -- y3        -- -- -- y2    m>Y3 Y3 Y3 Y3
  bswap eax                           ;                                         >P0 P0 P1 P1         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P0 P0 P1 P1         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
   add  esi,4                         ;                                          P0 P0 P1 P1         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  shl   edx,16                        ; Extract < Y03  Y03  ___  ___>.           P0 P0 P1 P1         -- -- -- y3        -- -- -- y2     >Y3 Y3 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y2 Y2 Y2 Y2         -- -- -- y3       <-- -- -- y2      Y3 Y3 -- --
  shr   eax,16                        ; Extract < ___  ___  Y02  Y02>.          >-- -- Y2 Y2         -- -- -- y3        -- -- -- y2      Y3 Y3 -- --
   mov  bl,[esi+ebp*1]                ; Fetch next Y01.                          -- -- Y2 Y2       m>-- -- -- y5        -- -- -- y2      Y3 Y3 -- --
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2     <Y3 Y3 -- --
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2    s>C3 C3 C2 C2
  rol   edx,16                        ; Swap dither pattern.                     Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2    s>C2 C2 C3 C3
   add  esp,8                         ; Swap dither pattern.                     Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2      C2 C2 C3 C3
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P3 P3 P2 P2         -- -- -- y5        -- -- -- y2     <C2 C2 C3 C3
   mov  cl,[esi+ebp*1+1]              ; Fetch next Y00.                          P3 P3 P2 P2         -- -- -- y5      m>-- -- -- y4      C2 C2 C3 C3
  bswap eax                           ;                                         >P2 P2 P3 P3         -- -- -- y5        -- -- -- y4      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P2 P2 P3 P3         -- -- -- y5        -- -- -- y4      C2 C2 C3 C3
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P2 P2 P3 P3        <-- -- -- y5        -- -- -- y4    m>Y5 Y5 Y5 Y5
  shl   edx,16                        ; Extract < Y01  Y01  ___  ___>.           P2 P2 P3 P3         -- -- -- y5        -- -- -- y4     >Y5 Y5 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y4 Y4 Y4 Y4         -- -- -- y5       <-- -- -- y4      Y5 Y5 -- --
  shr   eax,16                        ; Extract < ___  ___  Y00  Y00>.          >-- -- Y4 Y4         -- -- -- y5        -- -- -- y4      Y5 Y5 -- --
   mov  bl,[esi+ebp*1+2]              ; Fetch Y03.                               -- -- Y4 Y4       m>-- -- -- y7        -- -- -- y4      Y5 Y5 -- --
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4      Y5 Y5 -- --
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4     >C4 C4 C5 C5
   mov  cl,[esi+ebp*1+3]              ; Fetch Y02.                               Y5 Y5 Y4 Y4         -- -- -- y7      m>-- -- -- y6      C4 C4 C5 C5
  test  edx,edx
   jne  Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   esi,YCursor
   mov  edx,AspectCount
  mov   edi,CCOCursor               ; Fetch output cursor.
   sub  edx,2
  lea   eax,[esi+ebp*2]             ; Compute start of next line.
   mov  AspectCount,edx
  mov   YCursor,eax
   jg   KeepLine3

  add   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  mov   bl,[esi+ebp*1]              ; Fetch Y00.                                 XX XX XX XX       m>-- -- -- y0        -- -- -- --      -- -- -- --
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- y0        -- -- -- --      -- -- -- --
  add   eax,edi                     ;                                           >XX XX XX XX         -- -- -- y0        -- -- -- --      -- -- -- --
   mov  cl,[esi+ebp*1+1]            ; Fetch Y01.                                 XX XX XX XX         -- -- -- y0      m>-- -- -- y1      -- -- -- --
  mov   CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y0        -- -- -- y1      -- -- -- --
   mov  edx,PD YDitherZ2[ebx*4]     ; Fetch < Y00  Y00  Y00  Y00>.               XX XX XX XX        <-- -- -- y0        -- -- -- y1    m>Y0 Y0 Y0 Y0
  sub   edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y0        -- -- -- y1      Y0 Y0 Y0 Y0
   mov  eax,PD YDitherZ2[ecx*4]     ; Fetch < Y01  Y01  Y01  Y01>.             m>Y1 Y1 Y1 Y1         -- -- -- y0       <-- -- -- y1      Y0 Y0 Y0 Y0
  and   edx,0FFFF0000H              ; Extract < ___  ___  Y00  Y00>.             Y1 Y1 Y1 Y1         -- -- -- y0        -- -- -- y1     >Y0 Y0 -- --
   sub  edi,esi                     ;                                            Y1 Y1 Y1 Y1         -- -- -- y0        -- -- -- y1      Y0 Y0 -- --
  mov   bl,[esi+ebp*1+2]            ; Fetch Y02.                                 Y1 Y1 Y1 Y1       m>-- -- -- y2        -- -- -- y1      Y0 Y0 -- --
   and  eax,00000FFFFH              ; Extract < ___  ___  Y01  Y01>.            >-- -- Y1 Y1         -- -- -- y2        -- -- -- y1      Y0 Y0 -- --
  mov   cl,[esi+ebp*1+3]            ; Fetch Y03.                                 -- -- Y1 Y1         -- -- -- y2      m>-- -- -- y3      Y0 Y0 -- --
   or   eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y0 Y0 Y1 Y1         -- -- -- y2        -- -- -- y3     <Y0 Y0 -- --
  mov   edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y0 Y0 Y1 Y1         -- -- -- y2        -- -- -- y3    m>C1 C1 C0 C0
   sub  esp,1536

Line3Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P0 P0 P1 P1         -- -- -- y2        -- -- -- y3     <C1 C1 C0 C0
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P0 P0 P1 P1        <-- -- -- y2        -- -- -- y3    m>Y2 Y2 Y2 Y2
  bswap eax                           ;                                         >P1 P1 P0 P0         -- -- -- y2        -- -- -- y3      Y2 Y2 Y2 Y2
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P1 P1 P0 P0         -- -- -- y2        -- -- -- y3      Y2 Y2 Y2 Y2
   add  esi,4                         ;                                          P1 P1 P0 P0         -- -- -- y2        -- -- -- y3      Y2 Y2 Y2 Y2
  and   edx,0FFFF0000H                ; Extract < Y03  Y03  ___  ___>.           P1 P1 P0 P0         -- -- -- y2        -- -- -- y3     >Y2 Y2 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y3 Y3 Y3 Y3         -- -- -- y2       <-- -- -- y3      Y2 Y2 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y02  Y02>.          >-- -- Y3 Y3         -- -- -- y2        -- -- -- y3      Y2 Y2 -- --
   mov  bl,[esi+ebp*1]                ; Fetch next Y01.                          -- -- Y3 Y3       m>-- -- -- y4        -- -- -- y3      Y2 Y2 -- --
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y2 Y2 Y3 Y3         -- -- -- y4        -- -- -- y3     <Y2 Y2 -- --
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y2 Y2 Y3 Y3         -- -- -- y4        -- -- -- y3    s>C3 C3 C2 C2
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P2 P2 P3 P3         -- -- -- y4        -- -- -- y3     <C2 C2 C3 C3
   mov  cl,[esi+ebp*1+1]              ; Fetch next Y00.                          P2 P2 P3 P3         -- -- -- y4      m>-- -- -- y5      C2 C2 C3 C3
  bswap eax                           ;                                         >P3 P3 P2 P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P3 P3 P2 P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P3 P3 P2 P2        <-- -- -- y4        -- -- -- y5    m>Y4 Y4 Y4 Y4
  and   edx,0FFFF0000H                ; Extract < Y01  Y01  ___  ___>.           P3 P3 P2 P2         -- -- -- y4        -- -- -- y5     >Y4 Y4 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y5 Y5 Y5 Y5         -- -- -- y4       <-- -- -- y5      Y4 Y4 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y00  Y00>.          >-- -- Y5 Y5         -- -- -- y4        -- -- -- y5      Y4 Y4 -- --
   mov  bl,[esi+ebp*1+2]              ; Fetch Y03.                               -- -- Y5 Y5       m>-- -- -- y6        -- -- -- y5      Y4 Y4 -- --
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y4 Y4 Y5 Y5         -- -- -- y6        -- -- -- y5      Y4 Y4 -- --
   mov  edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.             Y4 Y4 Y5 Y5         -- -- -- y6        -- -- -- y5    s>C5 C5 C4 C4
  add   esp,8                         ; Fetch <UV01 UV01 UV00 UV00>.             Y4 Y4 Y5 Y5         -- -- -- y6        -- -- -- y5      C5 C5 C4 C4 
   mov  cl,[esi+ebp*1+3]              ; Fetch Y02.                               Y4 Y4 Y5 Y5         -- -- -- y6      m>-- -- -- y7      C5 C5 C4 C4
  test  edx,edx
   jne  Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextTwoLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8ZoomBy2 endp

ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx5128a1.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a1.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a1.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:26   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:30   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:22:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:58:38   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:40   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:14   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by one, i.e. non-zoom.
; cx5128a1  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;              It converts the input to the clut8 index dyncamically computed
;              for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a1>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8AP (U8 * YPlane,
;                                       U8 * VPlane,
;                                       U8 * UPlane,
;                                       UN  FrameWidth,
;                                       UN  FrameHeight,
;                                       UN  YPitch,
;                                       UN  VPitch,
;                                       UN  AspectAdjustmentCount,
;                                       U8 FAR * ColorConvertedFrame,
;                                       U32 DCIOffset,
;                                       U32 CCOffsetToLine0,
;                                       IN  CCOPitch,
;                                       IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8AP

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8AP    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine0

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine0

KeepLine0:

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*2-8+0]        ; 03 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+2]                ; 02 -- Fetch luma for Pel02
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+3]                ; 03 -- Fetch luma for Pel03
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+2]        ; 01 -- Fetch UV contrib to Active Pal addr
    
Line0Loop:

  mov   bh,PB [esi-768*2-8+1]        ; 02 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01 -- Fetch luma for Pel01
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither03 -8] ; 03 -- Pel03 clut index
  mov   al,PB [esi+0]                ; 00 -- Fetch luma for Pel00
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither02 -8] ; 02 -- Pel02 clut index
  shl   edx,16                       ; 03 & 02 -- Position high order pels
   mov  ah,PB [esi-768*1-4+3]        ; 00 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+2+4]              ; 02 -- Fetch luma for next Pel02
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither01 -8] ; 01 -- Pel01 clut index
   mov  ch,PB [esi-768*1-4+2+4]      ; 01 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither00 -8] ; 00 -- Pel00 clut index
   mov  ah,PB [esi-768*2-8+0+4]      ; 03 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+3+4]              ; 03 -- Fetch luma for next Pel03
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line0Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine0:

  Lesi  YPlane                       ; Reload luma cursor.
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine1

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*2-8+2]        ; 13 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+ebp*1+2]          ; 12 -- Fetch luma for Pel12
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+ebp*1+3]          ; 13 -- Fetch luma for Pel13
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+0]        ; 11 -- Fetch UV contrib to Active Pal addr
    
Line1Loop:

  mov   bh,PB [esi-768*2-8+3]        ; 12 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+ebp*1+1]          ; 11 -- Fetch luma for Pel11
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither13 -8] ; 13 -- Pel13 clut index
  mov   al,PB [esi+ebp*1+0]          ; 10 -- Fetch luma for Pel10
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither12 -8] ; 12 -- Pel12 clut index
  shl   edx,16                       ; 13 & 12 -- Position high order pels
   mov  ah,PB [esi-768*1-4+1]        ; 10 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+ebp*1+2+4]        ; 12 -- Fetch luma for next Pel12
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither11 -8] ; 11 -- Pel11 clut index
   mov  ch,PB [esi-768*1-4+0+4]      ; 11 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither10 -8] ; 10 -- Pel10 clut index
   mov  ah,PB [esi-768*2-8+2+4]      ; 13 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+ebp*1+3+4]        ; 13 -- Fetch luma for next Pel13
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line1Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine1:

  Lesi  YPlane                       ; Reload luma cursor.
   lea  edx,[ebp*2]
  add   esi,edx
   Ledi VPlane
  Sesi  YPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine2

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine2

KeepLine2:

  mov   ah,PB [esi-768*2-8+1]
   mov  bl,PB [esi+2]
  shr   bl,1
   mov  al,PB [esi+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+3]
    
Line2Loop:

  mov   bh,PB [esi-768*2-8+0]
   mov  cl,PB [esi+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither23 -8]
  mov   al,PB [esi+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither22 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+2]
  shr   al,1
   mov  bl,PB [esi+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither21 -8]
   mov  ch,PB [esi-768*1-4+3+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither20 -8]
   mov  ah,PB [esi-768*2-8+1+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line2Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine2:

  Lesi  YPlane
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine3

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*2-8+3]
   mov  bl,PB [esi+ebp*1+2]
  shr   bl,1
   mov  al,PB [esi+ebp*1+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+1]
    
Line3Loop:

  mov   bh,PB [esi-768*2-8+2]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither33 -8]
  mov   al,PB [esi+ebp*1+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither32 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+0]
  shr   al,1
   mov  bl,PB [esi+ebp*1+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither31 -8]
   mov  ch,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither30 -8]
   mov  ah,PB [esi-768*2-8+3+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+ebp*1+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line3Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine3:

  Lesi  YPlane
   lea  edx,[ebp*2]
  add   esi,edx
   Ledx YLimit
  Sesi  YPlane
   cmp  esi,edx
  jne   NextFourLines

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8AP endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\excolcnv.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   21 Nov 1996 17:33:56  $
// $Archive:   S:\h26x\src\enc\excolcnv.cpv  $
// $Header:   S:\h26x\src\enc\excolcnv.cpv   1.45   21 Nov 1996 17:33:56   MDUDA  $
// $Log:   S:\h26x\src\enc\excolcnv.cpv  $
// 
//    Rev 1.45   21 Nov 1996 17:33:56   MDUDA
// Added more non-compressed YUV12 support (RGB16 and RGB24).
// Also rewrote IA_YUV12toEncYUV12 to be more readable.
// 
//    Rev 1.44   31 Oct 1996 10:05:48   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.43   22 Oct 1996 16:44:22   MDUDA
// Added IA support for YUY2 input color conversion and cleaned up C version.
// Now using IA version.
// 
//    Rev 1.42   18 Oct 1996 14:31:32   MDUDA
// 
// Added a C-version of YUY2 input color conversion.
// 
//    Rev 1.41   11 Oct 1996 16:04:50   MDUDA
// Using new RGB to YUV lookup tables.
// 
//    Rev 1.40   03 Oct 1996 10:43:58   AGUPTA2
// Got rid of segment directives; made tables read-only.
// 
//    Rev 1.39   13 Sep 1996 13:34:04   MDUDA
// Fixed YVU9 bug where input = output frame size was not colored
// (U and V planes) properly.
// 
//    Rev 1.38   11 Sep 1996 15:45:06   MDUDA
// Modified RGB look-up tables and added C_H26X_YUV12toEncYUV12 and
// IA_H26X_YUV12toEncYUV12.
// 
//    Rev 1.37   03 Sep 1996 14:54:46   MDUDA
// Fixed problem causing VC++ 4.1 internal compiler error. Replaced
// inline assembler constructs such as [ebx.biWidth] with
// (LPBITMAPINFOHEADER)[ebx].biWidth.
// 
//    Rev 1.36   29 Aug 1996 16:31:14   MDUDA
// Added Pentium assembler versions for all RGB conversion routines.
// Also, rewrote YVU9 support to allow input frame sizes other
// than 160x120 and 240x180.
// 
//    Rev 1.35   16 Aug 1996 12:17:48   MDUDA
// Fixed bug where U and V values in the BGR converters were treated as unsign
// values. Also did some general cleanup of BGR converters in preparation for
// doing Pentium assembler version.
// 
//    Rev 1.34   13 Aug 1996 10:35:38   MDUDA
// Added support for RGB4. Generalized RGB LUT support for 4-bit and
// and 8-bit pixels into a single routine.
// 
//    Rev 1.33   09 Aug 1996 09:45:02   MDUDA
// Added support for RGB16 format on input. This is for the color
// Quick Cam. Also, generalized RGB16 for other bit combinations.
// However, these can only be specified under BI_BITFIELDS format.
// 
//    Rev 1.32   02 Aug 1996 13:44:48   MDUDA
// modified H26X_BGR24toYUV12 to crop and stretch 240x180 and 160x120
// frames
// 
//    Rev 1.31   01 Aug 1996 14:03:50   MDUDA
// 
// Optimized H26X_YVU9toYUV12 by rewriting function in assembler code. Used in
// _asm. Also re-arranged functions so that colorCnvtFrame is at the end of
// the file.
// 
//    Rev 1.30   22 Jul 1996 13:28:22   BECHOLS
// Added a CLUT8 to YUV12 color convertor (CC). This CC crops and stretches
// either the 240x180 or the 160x120 image size to produce QCIF and SubQCIF
// image sizes respectively.
// 
//    Rev 1.29   11 Jul 1996 15:47:02   MDUDA
// 
// Modified H263_YVU9toYUV12 to create subQCIF and QCIF from
// 160x120 and 240x180 images, respectively. To fit the new
// formats, the original images are cropped and stretched using a
// dither pattern for the color planes.
// 
//    Rev 1.28   14 May 1996 12:04:08   KLILLEVO
// changed RGB->YUV color conversion to use the inverse
// if the output YUV->RGB conversion instead of the conversion
// "recommended by the CCIR". Compression performance for RGB
// input was significantly improved (33% less bits for same
// fixed QP)
// 
//    Rev 1.27   04 May 1996 21:55:20   BECHOLS
// For RGB24 to YVU12 conversion, I unrolled the inner loop by 8 and changed
// the writes to DWORD vs. BYTE writes.  This resulted in a 30% reduction in
// the execution time.
// 
//    Rev 1.26   10 Apr 1996 16:44:14   RHAZRA
// Fixed a bug in 320x240 mode for the H26X_YUV12toEncYUV12() function.
// DWORD should be and-ed with 0x7f7f7f7f and not 0x7f7f7f.
// 
//    Rev 1.25   27 Mar 1996 15:10:08   SCDAY
// Optimized H26X_YUV12toEncYUV12 'C' code to read/write DWORDs
// 
//    Rev 1.24   08 Jan 1996 17:46:14   unknown
// 
// Correct logic on bIs320x240 check
// 
//    Rev 1.23   05 Jan 1996 17:34:38   RMCKENZX
// corrected chroma pad value to 0x40 to achieve black padding
// 
//    Rev 1.22   05 Jan 1996 17:29:46   RMCKENZX
// Added code to pad out 320x240 stills to 352x288 
// full CIF images.
// 
//    Rev 1.21   04 Jan 1996 18:37:20   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.20   02 Jan 1996 17:09:04   TRGARDOS
// Moved colorCnvFrame into this file and made the
// color convertor functions static.
// 
//    Rev 1.19   27 Dec 1995 15:32:56   RMCKENZX
// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:35:42   TRGARDOS
// Added Brian's fix to the input color convertor to avoid
// overflow of the chars.
// 
//    Rev 1.17   27 Nov 1995 16:09:04   TRGARDOS
// Removed two unused variables to get rid of compiler warnings.
// 
//    Rev 1.16   30 Oct 1995 14:34:12   TRGARDOS
// Fixed 240x180 to center clip.
// 
//    Rev 1.15   30 Oct 1995 12:03:16   TRGARDOS
// Added color convertor support for YUV9 240x180.
// 
//    Rev 1.14   28 Oct 1995 15:39:28   TRGARDOS
// Fixed color conversion problem from YVU9 to YVU12.
// 
//    Rev 1.13   12 Oct 1995 17:40:12   TRGARDOS
// Fixed YUV12 input color convertor.
// 
//    Rev 1.12   12 Oct 1995 12:04:16   TRGARDOS
// Changed some variable names in YUV12 convertor.
// 
//    Rev 1.11   10 Oct 1995 16:34:12   TRGARDOS
// Added YUV12 input support.
// 
//    Rev 1.10   28 Sep 1995 17:02:36   DBRUCKS
// fix colorIn to not swap left to right
// 
//    Rev 1.9   15 Sep 1995 16:37:38   TRGARDOS
// 
// 
//    Rev 1.8   13 Sep 1995 17:09:22   TRGARDOS
// 
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.7   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.6   07 Sep 1995 09:27:54   TRGARDOS
// Added YVU9 to YVU12 color convertor.
// 
//    Rev 1.5   05 Sep 1995 15:50:46   TRGARDOS
// Added color back in to convertors.
// 
//    Rev 1.4   01 Sep 1995 17:51:42   TRGARDOS
// Fixed bugs in color converter.
// 
//    Rev 1.3   01 Sep 1995 10:13:42   TRGARDOS
// Debugging bit stream errors.
// 
//    Rev 1.2   30 Aug 1995 12:42:26   TRGARDOS
// Fixed bugs in intra AC coef VLC coding.
// 
//    Rev 1.1   02 Aug 1995 17:28:06   TRGARDOS
// 
// Cleaned up stuff to get stub working under new
// version control system.
// 
//    Rev 1.0   31 Jul 1995 13:07:10   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:16   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

/*

CCIR 601 Specifies a conversion from RGB to YCrCb. For
what we call U and V, they are equivalent as 
U = Cb, V = Cr.

From CCIR 601-2 Annex II, we can go from RGB with values
in the range of 0-255, to YUV values in the same range
by the equation:

Y = (    77*R + 150*G +  29*B ) >> 8;
V = (   131*R - 110*G -  21*B ) >> 8 + 128; 	// Cr
U = ( (-44)*R -  87*G + 131*B ) >> 8 + 128;		// Cb

Has now changed to the inverse of the YUV->RGB on the
output, since the old version produced way too many bits.
The new version is:

Y = (   16836*R +  33056*G +  6416*B ) >> 16 + 16;
V = (   28777*R -  24117*G -  4660*B ) >> 16 + 128; 	// Cr
U = ( (-9726)*R -  19064*G + 28790*B ) >> 16 + 128;		// Cb

*/

#include "precomp.h"

#if !defined(H263P) && !defined(USE_BILINEAR_MSH26X) // { H263P

#if defined(_CODEC_STATS)

static const double RDTSC_SHIFT_32 = 4294967296.0;

static double PENTIUM_TIMER()
{
	unsigned long int a, b;
	double temp1, temp2, result;

	__asm
	{
		_emit   0x0f
		_emit   0x31
		mov     a, eax
		mov     b, edx
	}

	temp1 = (double) a;
	temp2 = (double) (b & 0xFFFF);
	if (RDTSC_CLOCK_FREQ) {
		result = (temp1 + temp2 * RDTSC_SHIFT_32) / RDTSC_CLOCK_FREQ;
	} else {
		result = 0.0;
	}
	return( result * 1000.0 );
}

#endif

// Set all local functions to "static", and then set it accordingly if
// VTune statistics are to be collected. VTune doesn't recognize static functions
// so we need some way to turn off the static attribute if VTune is to be run
// on the executable. For now, simply use a define of _VTUNE to build the driver.
#if defined(_VTUNE)
#define _STATIC
#else
#define _STATIC static
#endif

// These are the look-up tables for the RGB converters. They are 8 bytes/entry
// to allow addressing via the scale by 8 indexed addressing mode. A pseudo-SIMD
// arrangement is used in these tables. Since all R, G and B contributions to the
// Y value are positive and fit in 15 bits, these are stored in the lower 16-bits
// of the YU word. In some cases, the U contribution is negative so it is placed
// in the upper 16 bits of the YU word. When a Y value is calculated, the U value
// is calculated in parallel. The V contribution is negative in some cases, but it
// gets its own word.

// This is the code that was used to generate the tables.
#if 0
#define YRCoef   16836
#define YGCoef   33056
#define YBCoef    6416
#define URCoef    9726
#define UGCoef   19064
#define UBCoef   28790
#define VRCoef   28777
#define VGCoef   24117
#define VBCoef    4660

#include <stdio.h>

void main() {
int i,j;

  printf("struct YUV {\n");
  printf("  int YU;\n");
  printf("  int V;\n");
  printf("};\n\n");

  printf("struct YUV  RYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YRCoef*((i*4)+j+1))>>9) |
         ((-(((URCoef*((i*4)+j+1)))>>9))<<16),
        ((VRCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  GYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YGCoef*((i*4)+j+1))>>9) |
         ((-(((UGCoef*((i*4)+j+1)))>>9))<<16),
         -((VGCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  BYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YBCoef*((i*4)+j+1))>>9) |
         (((UBCoef*((i*4)+j+1))>>9)<<16),
        -((VBCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");
}
#endif
 
struct YUV {
  int YU;
  int V;
};

const struct YUV  RYUV[] = {
{0xffee0020, 0x00000038}, {0xffc80062, 0x000000a8}, 
{0xffa200a4, 0x00000119}, {0xff7c00e6, 0x00000189}, 
{0xff560127, 0x000001f9}, {0xff300169, 0x0000026a}, 
{0xff0a01ab, 0x000002da}, {0xfee401ed, 0x0000034b}, 
{0xfebe022f, 0x000003bb}, {0xfe980270, 0x0000042b}, 
{0xfe7202b2, 0x0000049c}, {0xfe4c02f4, 0x0000050c}, 
{0xfe260336, 0x0000057d}, {0xfe000377, 0x000005ed}, 
{0xfdda03b9, 0x0000065d}, {0xfdb403fb, 0x000006ce}, 
{0xfd8e043d, 0x0000073e}, {0xfd68047e, 0x000007af}, 
{0xfd4204c0, 0x0000081f}, {0xfd1c0502, 0x0000088f}, 
{0xfcf60544, 0x00000900}, {0xfcd00585, 0x00000970}, 
{0xfcaa05c7, 0x000009e1}, {0xfc840609, 0x00000a51}, 
{0xfc5e064b, 0x00000ac2}, {0xfc38068d, 0x00000b32}, 
{0xfc1206ce, 0x00000ba2}, {0xfbec0710, 0x00000c13}, 
{0xfbc60752, 0x00000c83}, {0xfba00794, 0x00000cf4}, 
{0xfb7a07d5, 0x00000d64}, {0xfb540817, 0x00000dd4}, 
{0xfb2e0859, 0x00000e45}, {0xfb08089b, 0x00000eb5}, 
{0xfae208dc, 0x00000f26}, {0xfabc091e, 0x00000f96}, 
{0xfa960960, 0x00001006}, {0xfa7009a2, 0x00001077}, 
{0xfa4a09e3, 0x000010e7}, {0xfa240a25, 0x00001158}, 
{0xf9fe0a67, 0x000011c8}, {0xf9d80aa9, 0x00001239}, 
{0xf9b20aeb, 0x000012a9}, {0xf98c0b2c, 0x00001319}, 
{0xf9660b6e, 0x0000138a}, {0xf9400bb0, 0x000013fa}, 
{0xf91a0bf2, 0x0000146b}, {0xf8f40c33, 0x000014db}, 
{0xf8ce0c75, 0x0000154b}, {0xf8a80cb7, 0x000015bc}, 
{0xf8820cf9, 0x0000162c}, {0xf85c0d3a, 0x0000169d}, 
{0xf8360d7c, 0x0000170d}, {0xf8100dbe, 0x0000177d}, 
{0xf7ea0e00, 0x000017ee}, {0xf7c40e41, 0x0000185e}, 
{0xf79e0e83, 0x000018cf}, {0xf7780ec5, 0x0000193f}, 
{0xf7520f07, 0x000019af}, {0xf72c0f49, 0x00001a20}, 
{0xf7060f8a, 0x00001a90}, {0xf6e00fcc, 0x00001b01}, 
{0xf6ba100e, 0x00001b71}, {0xf6941050, 0x00001be2}, 
{0xf66e1091, 0x00001c52}, {0xf64810d3, 0x00001cc2}, 
{0xf6221115, 0x00001d33}, {0xf5fc1157, 0x00001da3}, 
{0xf5d61198, 0x00001e14}, {0xf5b011da, 0x00001e84}, 
{0xf58a121c, 0x00001ef4}, {0xf564125e, 0x00001f65}, 
{0xf53e12a0, 0x00001fd5}, {0xf51812e1, 0x00002046}, 
{0xf4f21323, 0x000020b6}, {0xf4cc1365, 0x00002126}, 
{0xf4a613a7, 0x00002197}, {0xf48013e8, 0x00002207}, 
{0xf45a142a, 0x00002278}, {0xf434146c, 0x000022e8}, 
{0xf40e14ae, 0x00002359}, {0xf3e814ef, 0x000023c9}, 
{0xf3c21531, 0x00002439}, {0xf39c1573, 0x000024aa}, 
{0xf37615b5, 0x0000251a}, {0xf35015f6, 0x0000258b}, 
{0xf32a1638, 0x000025fb}, {0xf304167a, 0x0000266b}, 
{0xf2de16bc, 0x000026dc}, {0xf2b816fe, 0x0000274c}, 
{0xf292173f, 0x000027bd}, {0xf26c1781, 0x0000282d}, 
{0xf24617c3, 0x0000289d}, {0xf2201805, 0x0000290e}, 
{0xf1fa1846, 0x0000297e}, {0xf1d41888, 0x000029ef}, 
{0xf1ae18ca, 0x00002a5f}, {0xf188190c, 0x00002acf}, 
{0xf162194d, 0x00002b40}, {0xf13c198f, 0x00002bb0}, 
{0xf11619d1, 0x00002c21}, {0xf0f01a13, 0x00002c91}, 
{0xf0ca1a54, 0x00002d02}, {0xf0a41a96, 0x00002d72}, 
{0xf07e1ad8, 0x00002de2}, {0xf0581b1a, 0x00002e53}, 
{0xf0321b5c, 0x00002ec3}, {0xf00c1b9d, 0x00002f34}, 
{0xefe61bdf, 0x00002fa4}, {0xefc01c21, 0x00003014}, 
{0xef9a1c63, 0x00003085}, {0xef741ca4, 0x000030f5}, 
{0xef4e1ce6, 0x00003166}, {0xef281d28, 0x000031d6}, 
{0xef021d6a, 0x00003246}, {0xeedc1dab, 0x000032b7}, 
{0xeeb61ded, 0x00003327}, {0xee901e2f, 0x00003398}, 
{0xee6a1e71, 0x00003408}, {0xee441eb2, 0x00003479}, 
{0xee1e1ef4, 0x000034e9}, {0xedf81f36, 0x00003559}, 
{0xedd21f78, 0x000035ca}, {0xedac1fba, 0x0000363a}, 
{0xed861ffb, 0x000036ab}, {0xed60203d, 0x0000371b}, 
{0xed3a207f, 0x0000378b}, {0xed1420c1, 0x000037fc}, 
};
const struct YUV  GYUV[] = {
{0xffdb0040, 0xffffffd1}, {0xff9100c1, 0xffffff73}, 
{0xff460142, 0xffffff15}, {0xfefc01c3, 0xfffffeb7}, 
{0xfeb10245, 0xfffffe59}, {0xfe6702c6, 0xfffffdfa}, 
{0xfe1c0347, 0xfffffd9c}, {0xfdd203c8, 0xfffffd3e}, 
{0xfd880449, 0xfffffce0}, {0xfd3d04ca, 0xfffffc82}, 
{0xfcf3054b, 0xfffffc23}, {0xfca805cc, 0xfffffbc5}, 
{0xfc5e064e, 0xfffffb67}, {0xfc1306cf, 0xfffffb09}, 
{0xfbc90750, 0xfffffaaa}, {0xfb7e07d1, 0xfffffa4c}, 
{0xfb340852, 0xfffff9ee}, {0xfae908d3, 0xfffff990}, 
{0xfa9f0954, 0xfffff932}, {0xfa5409d5, 0xfffff8d3}, 
{0xfa0a0a57, 0xfffff875}, {0xf9bf0ad8, 0xfffff817}, 
{0xf9750b59, 0xfffff7b9}, {0xf92a0bda, 0xfffff75b}, 
{0xf8e00c5b, 0xfffff6fc}, {0xf8960cdc, 0xfffff69e}, 
{0xf84b0d5d, 0xfffff640}, {0xf8010dde, 0xfffff5e2}, 
{0xf7b60e60, 0xfffff584}, {0xf76c0ee1, 0xfffff525}, 
{0xf7210f62, 0xfffff4c7}, {0xf6d70fe3, 0xfffff469}, 
{0xf68c1064, 0xfffff40b}, {0xf64210e5, 0xfffff3ad}, 
{0xf5f71166, 0xfffff34e}, {0xf5ad11e7, 0xfffff2f0}, 
{0xf5621269, 0xfffff292}, {0xf51812ea, 0xfffff234}, 
{0xf4cd136b, 0xfffff1d6}, {0xf48313ec, 0xfffff177}, 
{0xf439146d, 0xfffff119}, {0xf3ee14ee, 0xfffff0bb}, 
{0xf3a4156f, 0xfffff05d}, {0xf35915f0, 0xffffeffe}, 
{0xf30f1672, 0xffffefa0}, {0xf2c416f3, 0xffffef42}, 
{0xf27a1774, 0xffffeee4}, {0xf22f17f5, 0xffffee86}, 
{0xf1e51876, 0xffffee27}, {0xf19a18f7, 0xffffedc9}, 
{0xf1501978, 0xffffed6b}, {0xf10519f9, 0xffffed0d}, 
{0xf0bb1a7b, 0xffffecaf}, {0xf0701afc, 0xffffec50}, 
{0xf0261b7d, 0xffffebf2}, {0xefdb1bfe, 0xffffeb94}, 
{0xef911c7f, 0xffffeb36}, {0xef471d00, 0xffffead8}, 
{0xeefc1d81, 0xffffea79}, {0xeeb21e02, 0xffffea1b}, 
{0xee671e84, 0xffffe9bd}, {0xee1d1f05, 0xffffe95f}, 
{0xedd21f86, 0xffffe901}, {0xed882007, 0xffffe8a2}, 
{0xed3d2088, 0xffffe844}, {0xecf32109, 0xffffe7e6}, 
{0xeca8218a, 0xffffe788}, {0xec5e220b, 0xffffe72a}, 
{0xec13228d, 0xffffe6cb}, {0xebc9230e, 0xffffe66d}, 
{0xeb7e238f, 0xffffe60f}, {0xeb342410, 0xffffe5b1}, 
{0xeaea2491, 0xffffe552}, {0xea9f2512, 0xffffe4f4}, 
{0xea552593, 0xffffe496}, {0xea0a2614, 0xffffe438}, 
{0xe9c02696, 0xffffe3da}, {0xe9752717, 0xffffe37b}, 
{0xe92b2798, 0xffffe31d}, {0xe8e02819, 0xffffe2bf}, 
{0xe896289a, 0xffffe261}, {0xe84b291b, 0xffffe203}, 
{0xe801299c, 0xffffe1a4}, {0xe7b62a1d, 0xffffe146}, 
{0xe76c2a9f, 0xffffe0e8}, {0xe7212b20, 0xffffe08a}, 
{0xe6d72ba1, 0xffffe02c}, {0xe68c2c22, 0xffffdfcd}, 
{0xe6422ca3, 0xffffdf6f}, {0xe5f82d24, 0xffffdf11}, 
{0xe5ad2da5, 0xffffdeb3}, {0xe5632e26, 0xffffde55}, 
{0xe5182ea8, 0xffffddf6}, {0xe4ce2f29, 0xffffdd98}, 
{0xe4832faa, 0xffffdd3a}, {0xe439302b, 0xffffdcdc}, 
{0xe3ee30ac, 0xffffdc7e}, {0xe3a4312d, 0xffffdc1f}, 
{0xe35931ae, 0xffffdbc1}, {0xe30f322f, 0xffffdb63}, 
{0xe2c432b1, 0xffffdb05}, {0xe27a3332, 0xffffdaa6}, 
{0xe22f33b3, 0xffffda48}, {0xe1e53434, 0xffffd9ea}, 
{0xe19b34b5, 0xffffd98c}, {0xe1503536, 0xffffd92e}, 
{0xe10635b7, 0xffffd8cf}, {0xe0bb3638, 0xffffd871}, 
{0xe07136ba, 0xffffd813}, {0xe026373b, 0xffffd7b5}, 
{0xdfdc37bc, 0xffffd757}, {0xdf91383d, 0xffffd6f8}, 
{0xdf4738be, 0xffffd69a}, {0xdefc393f, 0xffffd63c}, 
{0xdeb239c0, 0xffffd5de}, {0xde673a41, 0xffffd580}, 
{0xde1d3ac3, 0xffffd521}, {0xddd23b44, 0xffffd4c3}, 
{0xdd883bc5, 0xffffd465}, {0xdd3d3c46, 0xffffd407}, 
{0xdcf33cc7, 0xffffd3a9}, {0xdca93d48, 0xffffd34a}, 
{0xdc5e3dc9, 0xffffd2ec}, {0xdc143e4a, 0xffffd28e}, 
{0xdbc93ecc, 0xffffd230}, {0xdb7f3f4d, 0xffffd1d2}, 
{0xdb343fce, 0xffffd173}, {0xdaea404f, 0xffffd115}, 
};
const struct YUV  BYUV[] = {
{0x0038000c, 0xfffffff7}, {0x00a80025, 0xffffffe5}, 
{0x0119003e, 0xffffffd3}, {0x01890057, 0xffffffc1}, 
{0x01fa0070, 0xffffffaf}, {0x026a0089, 0xffffff9c}, 
{0x02da00a2, 0xffffff8a}, {0x034b00bb, 0xffffff78}, 
{0x03bb00d5, 0xffffff66}, {0x042c00ee, 0xffffff54}, 
{0x049c0107, 0xffffff41}, {0x050d0120, 0xffffff2f}, 
{0x057d0139, 0xffffff1d}, {0x05ee0152, 0xffffff0b}, 
{0x065e016b, 0xfffffef9}, {0x06cf0184, 0xfffffee6}, 
{0x073f019d, 0xfffffed4}, {0x07b001b6, 0xfffffec2}, 
{0x082001cf, 0xfffffeb0}, {0x089001e8, 0xfffffe9e}, 
{0x09010201, 0xfffffe8b}, {0x0971021a, 0xfffffe79}, 
{0x09e20233, 0xfffffe67}, {0x0a52024c, 0xfffffe55}, 
{0x0ac30266, 0xfffffe43}, {0x0b33027f, 0xfffffe30}, 
{0x0ba40298, 0xfffffe1e}, {0x0c1402b1, 0xfffffe0c}, 
{0x0c8502ca, 0xfffffdfa}, {0x0cf502e3, 0xfffffde8}, 
{0x0d6602fc, 0xfffffdd5}, {0x0dd60315, 0xfffffdc3}, 
{0x0e46032e, 0xfffffdb1}, {0x0eb70347, 0xfffffd9f}, 
{0x0f270360, 0xfffffd8c}, {0x0f980379, 0xfffffd7a}, 
{0x10080392, 0xfffffd68}, {0x107903ab, 0xfffffd56}, 
{0x10e903c4, 0xfffffd44}, {0x115a03dd, 0xfffffd31}, 
{0x11ca03f7, 0xfffffd1f}, {0x123b0410, 0xfffffd0d}, 
{0x12ab0429, 0xfffffcfb}, {0x131c0442, 0xfffffce9}, 
{0x138c045b, 0xfffffcd6}, {0x13fc0474, 0xfffffcc4}, 
{0x146d048d, 0xfffffcb2}, {0x14dd04a6, 0xfffffca0}, 
{0x154e04bf, 0xfffffc8e}, {0x15be04d8, 0xfffffc7b}, 
{0x162f04f1, 0xfffffc69}, {0x169f050a, 0xfffffc57}, 
{0x17100523, 0xfffffc45}, {0x1780053c, 0xfffffc33}, 
{0x17f10555, 0xfffffc20}, {0x1861056e, 0xfffffc0e}, 
{0x18d20588, 0xfffffbfc}, {0x194205a1, 0xfffffbea}, 
{0x19b205ba, 0xfffffbd8}, {0x1a2305d3, 0xfffffbc5}, 
{0x1a9305ec, 0xfffffbb3}, {0x1b040605, 0xfffffba1}, 
{0x1b74061e, 0xfffffb8f}, {0x1be50637, 0xfffffb7d}, 
{0x1c550650, 0xfffffb6a}, {0x1cc60669, 0xfffffb58}, 
{0x1d360682, 0xfffffb46}, {0x1da7069b, 0xfffffb34}, 
{0x1e1706b4, 0xfffffb22}, {0x1e8806cd, 0xfffffb0f}, 
{0x1ef806e6, 0xfffffafd}, {0x1f6806ff, 0xfffffaeb}, 
{0x1fd90719, 0xfffffad9}, {0x20490732, 0xfffffac7}, 
{0x20ba074b, 0xfffffab4}, {0x212a0764, 0xfffffaa2}, 
{0x219b077d, 0xfffffa90}, {0x220b0796, 0xfffffa7e}, 
{0x227c07af, 0xfffffa6c}, {0x22ec07c8, 0xfffffa59}, 
{0x235d07e1, 0xfffffa47}, {0x23cd07fa, 0xfffffa35}, 
{0x243e0813, 0xfffffa23}, {0x24ae082c, 0xfffffa11}, 
{0x251e0845, 0xfffff9fe}, {0x258f085e, 0xfffff9ec}, 
{0x25ff0877, 0xfffff9da}, {0x26700890, 0xfffff9c8}, 
{0x26e008aa, 0xfffff9b6}, {0x275108c3, 0xfffff9a3}, 
{0x27c108dc, 0xfffff991}, {0x283208f5, 0xfffff97f}, 
{0x28a2090e, 0xfffff96d}, {0x29130927, 0xfffff95b}, 
{0x29830940, 0xfffff948}, {0x29f40959, 0xfffff936}, 
{0x2a640972, 0xfffff924}, {0x2ad4098b, 0xfffff912}, 
{0x2b4509a4, 0xfffff8ff}, {0x2bb509bd, 0xfffff8ed}, 
{0x2c2609d6, 0xfffff8db}, {0x2c9609ef, 0xfffff8c9}, 
{0x2d070a08, 0xfffff8b7}, {0x2d770a21, 0xfffff8a4}, 
{0x2de80a3b, 0xfffff892}, {0x2e580a54, 0xfffff880}, 
{0x2ec90a6d, 0xfffff86e}, {0x2f390a86, 0xfffff85c}, 
{0x2faa0a9f, 0xfffff849}, {0x301a0ab8, 0xfffff837}, 
{0x308a0ad1, 0xfffff825}, {0x30fb0aea, 0xfffff813}, 
{0x316b0b03, 0xfffff801}, {0x31dc0b1c, 0xfffff7ee}, 
{0x324c0b35, 0xfffff7dc}, {0x32bd0b4e, 0xfffff7ca}, 
{0x332d0b67, 0xfffff7b8}, {0x339e0b80, 0xfffff7a6}, 
{0x340e0b99, 0xfffff793}, {0x347f0bb2, 0xfffff781}, 
{0x34ef0bcc, 0xfffff76f}, {0x35600be5, 0xfffff75d}, 
{0x35d00bfe, 0xfffff74b}, {0x36400c17, 0xfffff738}, 
{0x36b10c30, 0xfffff726}, {0x37210c49, 0xfffff714}, 
{0x37920c62, 0xfffff702}, {0x38020c7b, 0xfffff6f0}, 
};

#define COEF_WIDTH   8
#define SHIFT_WIDTH  COEF_WIDTH

//
// All of the RGB converters follow the template given below. The converters make
// some assumptions about the frame size. All output frame sizes are assumed to
// have a frame height that is a multiple of 48. Also, the output frame width
// is assumed to be a multiple of 8. If the input frame size is equal
// to the output frame size, no stretching or cropping is done. Otherwise, the
// image is cropped and stretched for an 11:12 aspect ratio.
//

#if 0
void rgb_color_converter() {
	for (j = 0; j < LumaIters; j++) {
		for (k = 0; k < mark; k++) {
			for (i = FrameWidth; i > 0; i -= m, pnext += n) {
				compute m Y values using look-up tables
				if (0 == (k&1)) {
					compute m/2 U,V values using look-up tables
				}
			}
			if ((0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8 {
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
				}
			}
			pnext += iBackTwoLines;
			py += ypitch_adj;
			if (0 == (k&1)) {
				pu += uvpitch_adj;
				pv += uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = py - pitch;
			pyspace = py;
			pynext = py + pitch;
		}
	}
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4 {
			*pyspace++ = *pyprev++;
		}
	}
}
#endif

//
// For the IA versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR24toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */
#if defined(_CODEC_STATS)
#define NOC_SHIFT_WIDTH 7
void NOC_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int height_adj, width_adj;
	int LumaIters = 0;
	int ypitch_adj = 0;
	int uvpitch_adj = 0;

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	width_adj += (width_adj << 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 2);
	iBackTwoLines += (iBackTwoLines << 1);

	// Point to the beginning of the last line.
	pnext =	(U32 *)
				(lpInput +
				((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
					((FrameHeight - aspect - 1) + height_adj)) +
				width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>23)+128);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>NOC_SHIFT_WIDTH)+128);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>23)+128);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>NOC_SHIFT_WIDTH)+128);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of NOC_H26X_BGR24toYUV12()
#endif

#if 0
_STATIC void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int height_adj, width_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	width_adj += (width_adj << 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 2);
	iBackTwoLines += (iBackTwoLines << 1);

	// Point to the beginning of the last line.
	pnext =	(U32 *)
				(lpInput +
				((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
					((FrameHeight - aspect - 1) + height_adj)) +
				width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>SHIFT_WIDTH)+8);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR24toYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// width_adj += width_adj << 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	mov		eax, esi
	shr		eax, 1
	add		esi, eax
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -(lpbiInput->biWidth + FrameWidth)
// iBackTwoLines += (iBackTwoLines << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	neg		ebp
	mov		eax, ebp
	shl		eax, 1
	add		ebp, eax
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	add		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, pnext += 12)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[t0>>25].YU +
//       GYUV[(t1>> 1)&0x7F].YU +
//       RYUV[(t1>> 9)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	eax, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	ebx, eax
	mov 	edx, ecx
// 3
	shr 	eax, 25
	and 	ecx, 0xFE
// 4
	shr 	ecx, 1
	and 	edx, 0xFE00
// 5
	shr 	edx, 9
		and		ebx, 0xFEFEFE
// 6
	mov 	eax, [BYUV+eax*8].YU
	nop
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
		and 	ebx, 0xFE
	add	eax,  0x800
// 10
	sar 	eax, 8
	nop
// 11
		shr 	ebx, 1
		nop
// 12
		shr 	ecx, 9
	mov	 [edi + 1], al
// 13
		shr		edx, 17
		and		ecx, 0x7F
// 14
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 15
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 16
		add		eax, [RYUV+edx*8].YU
		nop
// 17
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 18
		add		eax, 8
		and		ebx, 1
// 19
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 20
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 21
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 22
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 23
	mov		[edx], al
	inc		edx
// 24
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 25
	sar 	ebx, 8
	inc		edx
// 26
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 27
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t1 = pnext[1]
// t2 = pnext[2]
// t = ( BYUV[(t2>> 9)&0x7F].YU +
//       GYUV[(t2>>17)&0x7F].YU +
//       RYUV[t2>>25].YR )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t1>>17)&0x7F].YU +
//       GYUV[t1>>25].YU +
//       RYUV[(t2>> 1)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 28
	mov		ebp, [esi + 4]
	mov 	ebx, [esi + 8]
// 29
	mov 	eax, ebx
	mov 	ecx, ebx
// 30
	shr		eax, 9
	mov		edx, ebx
// 31
	shr 	ecx, 17
	and 	eax, 0x7F
// 32
	shr 	edx, 25
	and		ecx, 0x7F
// 33
	mov 	eax, [BYUV+eax*8].YU
	nop
// 34
	add 	eax, [GYUV+ecx*8].YU
		and		ebx, 0xFE
// 35
	add 	eax, [RYUV+edx*8].YU
		mov		ecx, ebp
// 36
		shr		ebx, 1
	add	eax,  0x800
// 37
	sar 	eax, 8
		mov		edx, ebp
// 38
		shr		edx, 17
	mov	 [edi + 3], al
// 39
		shr 	ecx, 25
		and		edx, 0x7F
// 40
		mov		eax, [RYUV+ebx*8].YU
		mov		ebp, ebx
// 41
		add	 	eax, [GYUV+ecx*8].YU
		nop
// 42
		add		eax, [BYUV+edx*8].YU
		nop
// 43
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 44
		add		eax, 8
		and		ebx, 1
// 45
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 46
	mov 	ebx, [BYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 47
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 48
	add		eax, 64
	add 	ebx, [RYUV+ebp*8].V
// 49
	mov		[edx], al
	inc		edx
// 50
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 51
	sar 	ebx, 8
	inc		edx
// 52
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 53
	mov		[edx - 1], bl
	nop
L16:
// 54
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 12]
// 55
	sub		eax, 4
	lea		edi, [edi + 4]
// 56
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

#if defined(_CODEC_STATS)
#define NOC_SHIFT_WIDTH  7
void NOC_H26X_BGR16toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int LumaIters = 0;
	int ypitch_adj = 0;
	int uvpitch_adj = 0;

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;

	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 1);

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj)) +
					 width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 2, pnext++) {

				tm = *pnext;
				//    555              2, 3, 8         0x7C, 0x7C, 0x7C
				t = (BYUV[(tm>>14)&0x7C].YU +
					 GYUV[(tm>>19)&0x7C].YU +
					 RYUV[(tm>>24)&0x7C].YU);
				*(YPlane+1) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				t = (BYUV[(tm<<2)&0x7C].YU +
					 GYUV[(tm>>3)&0x7C].YU +
					 RYUV[(tm>>8)&0x7C].YU);
				*(YPlane) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				YPlane += 2;
				if (0 == (k&1)) {
					//    555              2, 3, 8         0x7C, 0x7C, 0x7C
					*UPlane++ = (U8)((t>>23)+128);
					t = (RYUV[(tm>>8)&0x7C].V +
						 GYUV[(tm>>3)&0x7C].V +
						 BYUV[(tm<<2)&0x7C].V);
					*VPlane++ = (U8)((t>>NOC_SHIFT_WIDTH)+128);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of NOC_H26X_BGR16toYUV12
#endif

#if 0
_STATIC void C_H26X_BGR16toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	UN  bitfield,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;

	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 1);

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj)) +
					 width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 2, pnext++) {

				tm = *pnext;
				switch (bitfield) {
					//    555              2, 3, 8         0x7C, 0x7C, 0x7C
					case 555:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>24)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>8)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#if 0
// Beware - untested code ahead				
					//    664              3, 3, 9         0x78, 0x7E, 0x7E
					case 664:
						t = (BYUV[(tm>>13)&0x78].YU +
						     GYUV[(tm>>19)&0x7E].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<3)&0x78].YU +
						     GYUV[(tm>>3)&0x7E].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    565              2, 4, 9         0x7C, 0x7E, 0x7C
					case 565:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>20)&0x7E].YU +
						     RYUV[(tm>>25)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>4)&0x7E].YU +
						     RYUV[(tm>>9)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    655              2, 3, 9         0x7C, 0x7C, 0x7E
					case 655:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#endif
				}
				if (0 == (k&1)) {
					switch (bitfield) {
						//    555              2, 3, 8         0x7C, 0x7C, 0x7C
						case 555:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>8)&0x7C].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#if 0
// Beware - untested code ahead				
						//    664              3, 3, 9         0x78, 0x7E, 0x7E
						case 664:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7E].V +
							     BYUV[(tm<<3)&0x78].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    565              2, 4, 9         0x7C, 0x7E, 0x7C
						case 565:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7C].V +
							     GYUV[(tm>>4)&0x7E].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    655              2, 3, 9         0x7C, 0x7C, 0x7E
						case 655:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#endif
					}
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR16toYUV12
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm = pnext[0]
// t = ( BYUV[(tm>>14)&0x7C].YU +
//       GYUV[(tm>>19)&0x7C].YU +
//       RYUV[(tm>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t = ( BYUV[(tm<< 2)&0x7C].YU +
//       GYUV[(tm>> 8)&0x7C].YU +
//       RYUV[(tm>>13)&0x7C].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 1
	mov 	eax, [esi]
	nop
// 2
	mov 	ebx, eax
	mov 	ecx, eax
// 3
	shr 	eax, 14
	mov 	edx, ebx
// 4
	shr 	ecx, 19
	and 	eax, 0x7C
// 5
	shr 	edx, 24
	and 	ecx, 0x7C
// 6
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 9
	sar 	eax, 8
		and	ebx,  0x1F
// 10
		shl 	ebx, 2
	add 	eax, 8
// 11
		shr 	ecx, 3
	mov	 	[edi + 1], al
// 12
		shr 	edx, 8
		and 	ecx, 0x7C
// 13
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 15
		add	 	eax, [RYUV+edx*8].YU
		nop
// 16
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add	 	eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz 	L9

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop
L9:
// 27
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 4]
// 28
	sub		eax, 2
	lea		edi, [edi + 2]
// 29
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*****************************************************************************
 *
 *  H26X_CLUTtoYUV12()
 * 	
 *  Convert from CLUT8/CLUT4 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0
_STATIC void C_H26X_CLUTtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
    U8 * lpInput,
    U8 * YPlane,
    U8 * UPlane,
    U8 * VPlane,
    UN  FrameWidth,
    UN  FrameHeight,
	UN	pixel_bits,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm, tn;
	int t;
	int i, j, k, m, n;
	int iNextLine, iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int yshift, uvshift;
	int pixel_mask, loop_cnt, loop_limit;
	RGBQUAD *lpCEntry, *lpCTable = (RGBQUAD *)((U8 *)lpbiInput + sizeof(BITMAPINFOHEADER));
	int LumaIters = 0;
	int ypitch_adj = (pitch - FrameWidth);
	int uvpitch_adj = (pitch - (FrameWidth >> 1));

	ASSERT((8 == pixel_bits) || (4 == pixel_bits));
	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = ((lpbiInput->biHeight - (FrameHeight - aspect)) >> 1);
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = lpbiInput->biWidth;
	iBackTwoLines = -((iNextLine + (int)FrameWidth) >> 2);
	if (8 == pixel_bits) {
		yshift = 8;
		uvshift = 16;
		pixel_mask = 0xFF;
		loop_cnt = 2;
		loop_limit = 4;
	} else {
		yshift = 4;
		uvshift = 8;
		pixel_mask = 0xF;
		loop_cnt = 1;
		loop_limit = 8;
		width_adj >>= 1;
		iNextLine >>= 1;
		iBackTwoLines >>= 1;
	}

	// The input image is upside down - process the lines in reverse order.

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					(iNextLine * ((FrameHeight - aspect - 1) + height_adj)) + width_adj);

	for (j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 8) {

				for (n = 0; n < loop_cnt; n++) {
					tm = *pnext++;
					tm = ((4 == pixel_bits) ?
						( ((tm >> 4) & 0x0F0F0F0F) | ((tm << 4) & 0xF0F0F0F0) ) : tm);
					tn = tm;
					for (m = 0; m < loop_limit; m += 4) {
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
					}
					if (0 == (k&1)) {
						for (m = 0; m < loop_limit; m += 2, tn >>= uvshift) {
							lpCEntry = &lpCTable[tn&pixel_mask];
							t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
								  RYUV[lpCEntry->rgbRed>>1].YU +
								  GYUV[lpCEntry->rgbGreen>>1].YU );
							*UPlane++ = (U8)((t>>24)+64);
							t = ( RYUV[lpCEntry->rgbRed>>1].V +
								  GYUV[lpCEntry->rgbGreen>>1].V +
								  BYUV[lpCEntry->rgbBlue>>1].V );
							*VPlane++ = (U8)((t>>8)+64);
						}
					}
				}
			}

			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}

			pnext += iBackTwoLines;

			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}

		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}

	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUTtoYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 1
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
// iBackTwoLines = -(iNextline + FrameWidth)
	mov		edi, [esp + FRAME_WIDTH]
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput +
//            (iNextLine*((FrameHeight-aspect-1) + height_adj)) +
//            width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 2)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*(pnext+1)]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[*pnext]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>>24)+64)
// t = (  VBGR[lpCEntry->rgbRed>>1].V +
//        VBGR[lpCEntry->rgbGreen>>1].V +
//        VBGR[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	xor		eax, eax
	mov		ebp, [esp + LPCTABLE]
// 2
	mov		al, [esi + 1]
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
		xor		ebx, ebx
// 9
	add		eax, [RYUV+edx*4].YU
		mov		bl, [esi]
// 10
	sar		eax, 8
		lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
		mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
		mov		cl, (LPRGBQUAD)[ebp].rgbGreen
		and		bl, 0xFE
// 14
		mov		dl, (LPRGBQUAD)[ebp].rgbRed
		and		cl, 0xFE
// 15
		mov		eax, [BYUV+ebx*4].YU
		and		dl, 0xFE
// 16
		add		eax, [GYUV+ecx*4].YU
		mov		ebp, ebx
// 17
		add		eax, [RYUV+edx*4].YU
		nop
// 18
		sar		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
		add		eax, 8
	and		ebx, 1
// 20
		mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 29
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 2]
// 30
	sub		eax, 2
	lea		edi, [edi + 2]
// 31
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

__declspec(naked)
_STATIC void IA_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 2
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 2
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth >> 1
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
	shr		ebx, 1
// iBackTwoLines = -(iNextline + (FrameWidth >> 1))
	mov		edi, [esp + FRAME_WIDTH]
	shr		edi, 1
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput+(iNextLine*((FrameHeight-aspect-1)+height_adj))+ width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext++)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*pnext&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[(*pnext>>4)&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>24)+64)
// t = ( RYUV[lpCEntry->rgbRed>>1].V +
//       GYUV[lpCEntry->rgbGreen>>1].V +
//       BYUV[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	mov		al, [esi]
	mov		ebp, [esp + LPCTABLE]
// 2
	and		eax, 0xF
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
	mov		bl, [esi]
// 9
	add		eax, [RYUV+edx*4].YU
	and		ebx, 0xF0
//
	shr		ebx, 4
	nop
// 10
	shr		eax, 8
	lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
	mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
	mov		cl, (LPRGBQUAD)[ebp].rgbGreen
	and		bl, 0xFE
// 14
	mov		dl, (LPRGBQUAD)[ebp].rgbRed
	and		cl, 0xFE
// 15
	mov		eax, [BYUV+ebx*4].YU
	and		dl, 0xFE
// 16
	add		eax, [GYUV+ecx*4].YU
	mov		ebp, ebx
// 17
	add		eax, [RYUV+edx*4].YU
	nop
// 18
	shr		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
	add		eax, 8
	and		ebx, 1
// 20
	mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 32
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 1]
// 33
	sub		eax, 2
	lea		edi, [edi + 2]
// 34
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill(esi, pnext)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		edi, [esp + PYSPACE]
	 mov	ebp, [esp + FRAME_WIDTH]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YVU9toYUV12()
 *  Convert from YVU9 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 * uv_plane_common()
 *  Helper function to convert V and U plane information.
 *  Since the process is similar for both planes, the
 *  conversion code was included in this subroutine.
 *
 ***************************************************/	

#if 0
#define READ_DWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned int *)(src))), ((val) &= 0xFEFEFEFE), ((val) >>= 1))

#define READ_QWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned __int64 *)(src))), ((val) &= 0xFEFEFEFEFEFEFEFE), ((val) >>= 1))

#define WRITE_DWORD(dest,val) ((*(unsigned int *)(dest)) = (val))

#define WRITE_QWORD(dest,val) ((*(unsigned __int64 *)(dest)) = (val))

#define AVERAGE_DWORDS(out,in1,in2)  ((out) = ((((in1) + (in2)) & 0xFEFEFEFE) >> 1))

#define DUP_LOWER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = (((val) & 0x000000FF) |	(((val) << 8) & 0x0000FF00) | \
							  	(((val) << 8) & 0x00FF0000) | (((val) << 16) & 0xFF000000)))

#define DUP_UPPER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = ((((val) >> 16) & 0x000000FF) |	(((val) >> 8) & 0x0000FF00) | \
							  	(((val) >> 8) & 0x00FF0000) | ((val) & 0xFF000000)))


_STATIC void C_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj) {

U8* pnext = psrc + (OutputFrameWidth>>1) + spitch_adj;
U8* pdest_copy = Plane;
U8* pdest_avg = Plane + pitch;
int dpitch_adj = pitch - OutputFrameWidth;
int stretch = (spitch_adj ? 1 : 0);
int mark = 6 - stretch;
int flag = stretch;
int i, j, k;
UN t1,t2;

	for (j = ChromaIters; j > 0; j--) {
		for (k = mark + (flag & 1); k > 0; k--) {
			if (!stretch && (1 == j) && (1 == k)) {
				pnext = psrc;
			}
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_copy += 8,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				DUP_LOWER_TWO_BYTES(pdest_copy,t1);
				DUP_UPPER_TWO_BYTES((pdest_copy+4),t1);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
		}
		if (stretch) {
			psrc -= ((OutputFrameWidth>>1) + spitch_adj);
			pnext -= ((OutputFrameWidth>>1) + spitch_adj);
			pdest_avg = pdest_copy;
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
			flag++;
		}
	}
}

_STATIC void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn;
U8  *pvsrc, *pusrc;
int width_adj, height_adj;
int stretch, mark, aspect;
int iNextLine;
int i, j, k, t;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);

	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = width_adj << 1;
	pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj;
	for (j = LumaIters; j > 0; j--) {
		for (k = mark; k > 0; k--) {
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4) {
				*(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
			}
			pnext += iNextLine;
			YPlane += ypitch_adj;
		}
		if (stretch) {
			plast = pnext - lpbiInput->biWidth;
			pbn = pnext;
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, plast += 4, pbn += 4) {
				*(U32 *)YPlane =
					( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
				        ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}

	pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight);
	pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight>>2));
	t = ((lpbiInput->biWidth>>2) * (height_adj>>2)) + (width_adj>>2);
	pvsrc += t;
	pusrc += t;
	C_uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
	C_uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
}
#endif

__declspec(naked)
_STATIC void IA_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | spitch_adj      |  + 64
//    | ChromaIters     |  + 60
//    | OutputFrameWidth|  + 56
//    | pitch           |  + 52
//    | Plane           |  + 48
//    | psrc            |  + 44
//  -----------------------------
//    | return addr     |  + 40
//    | saved ebp       |  + 36
//    | saved ebx       |  + 32
//    | saved esi       |  + 28
//    | saved edi       |  + 24

//    | dpitch_adj      |  + 20
//    | stretch         |  + 16
//    | mark            |  + 12
//    | flag            |  +  8
//    | j               |  +  4
//    | k               |  +  0

#define LOCALSIZE           24

#define SPITCH_ADJ          64
#define CHROMA_ITERS        60
#define OUTPUT_FRAME_WIDTH  56
#define PITCH_PARM          52
#define PLANE               48
#define PSRC                44

#define DPITCH_ADJ          20
#define STRETCH             16
#define MARK                12
#define FLAG                 8
#define LOOP_J               4
#define LOOP_K               0

	_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// pnext = psrc + (OuputFrameWidth>>1) + uvpitch_adj
// pdest_copy = Plane
// pdest_avg = Plane + pitch
// assign (esi, psrc)
// assign (ecx, pnext)
// assign (edi, pdest_copy)
// assign (edx, pdest_avg)
// assign (ebp, i)
	mov		esi, [esp + PSRC]
	mov		ecx, esi
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	add		ecx, eax
	mov		edi, [esp + PLANE]
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// dpitch_adj = pitch - OutputFrameWidth
	mov		eax, [esp + PITCH_PARM]
	sub		eax, [esp + OUTPUT_FRAME_WIDTH]
	mov		[esp + DPITCH_ADJ], eax
// stretch = (spitch_adj ? 1 : 0)
	xor		ebx, ebx
	mov		eax, [esp + SPITCH_ADJ]
	test	eax, eax
	jz		L1
	inc		ebx
L1:
	mov		[esp + STRETCH], ebx
// mark = 6 - stretch
	mov		eax, 6
	sub		eax, ebx
	mov		[esp + MARK], eax
// flag = stretch
	mov		DWORD PTR [esp + FLAG], ebx

// for (j = ChromaIters; j > 0; j--)
	mov		eax, [esp + CHROMA_ITERS]
	mov		[esp + LOOP_J], eax
L2:
// for (k = mark + (flag & 1); k > 0; k--)
	mov		eax, [esp + FLAG]
	and		eax, 1
	add		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
L3:
// if (!stretch && (0 == j) && (0 == k))
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jnz		L4
	mov		eax, [esp + LOOP_J]
	cmp		eax, 1
	jne		L4
	mov		eax, [esp + LOOP_K]
	cmp		eax, 1
	jne		L4
// pnext = psrc
	mov		ecx, esi
L4:
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4,
//                                           pdest_copy += 8, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L5:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_copy,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi], ebx
// DUP_UPPER_TWO_BYTES((pdest_copy+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi+4], ebx
// READ_DWORD_AND_SHIFT(t2,pnext)
// AVERAGE_DWORDS(t1,t1,t2)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edi, [edi + 8]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L5

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + pitch_adj
// pdest_avg = pdest_copy + pitch
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// end of k loop
	dec		DWORD PTR [esp + LOOP_K]
	jnz		L3

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	jz		L6

// psrc -= ((OutputFrameWidth>>1)+spitch_adj)
// pnext -= ((OutputFrameWidth>>1)+spitch_adj)
// pdest_avg = pdest_copy
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	sub		esi, eax
	sub		ecx, eax
	mov		edx, edi
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L7:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// READ_DWORD_AND_SHIFT(t2,pnext)
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
// AVERAGE_DWORDS(t1,t1,t2)
// AVERAGE_DWORDS(t1,t1,t2)
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L7

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + dpitch_adj
// pdest_avg = pdest_copy + pitch
// flag++
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
	inc		DWORD PTR [esp + FLAG]

// end of j loop
L6:
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L2

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SPITCH_ADJ
#undef CHROMA_ITERS
#undef OUTPUT_FRAME_WIDTH
#undef PITCH_PARM
#undef PLANE
#undef PSRC

#undef DPITCH_ADJ
#undef STRETCH
#undef MARK
#undef FLAG
#undef LOOP_J
#undef LOOP_K

__declspec(naked)
_STATIC void IA_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 88
//    | FrameHeight     |  + 84
//    | FrameWidth      |  + 80
//    | VPlane          |  + 76
//    | UPlane          |  + 72
//    | YPlane          |  + 68
//    | lpInput         |  + 64
//    | lpbiInput       |  + 60
//  -----------------------------
//    | return addr     |  + 56
//    | saved ebp       |  + 52
//    | saved ebx       |  + 48
//    | saved esi       |  + 44
//    | saved edi       |  + 40

//    | width_adj       |  + 36
//    | height_adj      |  + 32
//    | stretch         |  + 28
//    | mark            |  + 24
//    | iNextLine       |  + 20
//    | j               |  + 16
//    | k               |  + 12
//    | LumaIters       |  +  8
//    | ypitch_adj      |  +  4
//    | uvpitch_adj     |  +  0

#define LOCALSIZE        40

#define PITCH_PARM       88
#define FRAME_HEIGHT     84
#define FRAME_WIDTH      80
#define VPLANE           76
#define UPLANE           72
#define YPLANE           68
#define LP_INPUT         64
#define LPBI_INPUT       60

#define WIDTH_ADJ        36
#define HEIGHT_ADJ       32
#define STRETCH          28
#define MARK             24
#define NEXT_LINE        20
#define LOOP_J           16
#define LOOP_K           12
#define LUMA_ITERS        8
#define YPITCH_ADJ        4
#define UVPITCH_ADJ       0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	shr		esi, 1
	mov		[esp + WIDTH_ADJ], esi
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
	mov		[esp + HEIGHT_ADJ], edx
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iNextLine = width_adj << 1
	mov		ebp, esi
	shl		ebp, 1
	mov		[esp + NEXT_LINE], ebp
// pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = LumaIters; j > 0; j--)
	mov		eax, [esp + LUMA_ITERS]
	mov		[esp + LOOP_J], eax
// for (k = mark; k > 0; k--)
L4:
	mov		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
L5:
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// *(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
// 1
	mov		eax, [esi]
	lea		esi, [esi + 4]
// 2
	and		eax, 0xFEFEFEFE
	lea		edi, [edi + 4]
// 3
	shr		eax, 1
	sub		ebp, 4
// 4
	mov		[edi - 4], eax
	jnz		L6

// pnext += iNextLine
// YPlane += ypitch_adj
	add		esi, [esp + NEXT_LINE]
	add		edi, [esp + YPITCH_ADJ]

// end of k loop
	mov		eax, [esp + LOOP_K]
	sub		eax, 1
	mov		[esp + LOOP_K], eax
	jnz		L5

// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L7

// plast = pnext - lpbiInput->biWidth
// pn = pnext
// assign (ecx, plast)
// assign (edx, pn)
	mov		ecx, esi
	mov		eax, [esp + LPBI_INPUT]
	sub		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		edx, esi

// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here just to make sure the loop code starts with the U pipe
	jmp		L8
L8:
// *(U32 *)YPlane =
//  ( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
//      ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1
// 1
	mov		eax, [ecx]
	lea		ecx, [ecx + 4]
// 2
	shr		eax, 1
// 3
	and		eax, 0x7F7F7F7F
	mov		ebx, [edx]
// 4
	shr		ebx, 1
	lea		edi, [edi + 4]
// 5
	and		ebx, 0x7F7F7F7F
// 6
	add		eax, ebx
// 7
	and		eax, 0xFEFEFEFE
// 8
	shr		eax, 1
// 9
	mov		[edi - 4], eax
	sub		ebp, 4
// 10
	lea		edx, [edx + 4]
	jnz		L8

// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]

L7:
// end of the LumaIters loop
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L4

// pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight)
// assign (esi, pvsrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	imul	ebx
	add		eax, [esp + LP_INPUT]
	mov		esi, eax
// pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight)>>2)
// assign (edi, pusrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		ecx, 2
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	shr		eax, 2
	imul	ecx
	add		eax, esi
	mov		edi, eax
// t = ((lpbiInput->biWidth>>2) * (height>>2)) + (width_adj>>2)
// assign (eax, t)
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		eax, 2
	mov		ebx, [esp + HEIGHT_ADJ]
	shr		ebx, 2
	imul	ebx
	mov		ebx, [esp + WIDTH_ADJ]
	shr		ebx, 2
	add		eax, ebx
// pvsrc += t
// pusrc += t
	add		esi, eax
	add		edi, eax

// uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + UPLANE]
	push	edi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

// uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + VPLANE]
	push	esi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef WIDTH_ADJ
#undef HEIGHT_ADJ
#undef STRETCH
#undef MARK
#undef NEXT_LINE
#undef LOOP_J
#undef LOOP_K
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YUV12toEncYUV12()
 *  Copy YUV12 data to encoder memory at the
 *  appropriate location. It is assumed that the input
 *  data is stored as rows of Y, followed by rows of U,
 *  then rows of V.
 *
 ***************************************************/

#if 0
_STATIC void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

	int i, j;
	U32 *pnext = (U32 *)lpInput;

	int ypitch_adj = pitch - FrameWidth;
	int yinput_height = lpbiInput->biHeight;
	int yinput_width = lpbiInput->biWidth;
	int yheight_diff = FrameHeight - yinput_height;
	int ywidth_diff = FrameWidth - yinput_width;

	int uvpitch_adj = pitch - (FrameWidth >> 1);
	int uvoutput_width = FrameWidth >> 1;
	int uvinput_height = yinput_height >> 1;
	int uvinput_width = yinput_width >> 1;
	int uvheight_diff = yheight_diff >> 1;
	int uvwidth_diff = ywidth_diff >> 1;

	for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj) {
			for (i = yinput_width; i > 0; i -= 8) {
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
				}
			for (i = ywidth_diff; i > 0; i -= 8) {
					*(U32 *)YPlane = 0; YPlane += 4;
					*(U32 *)YPlane = 0; YPlane += 4;
				}
	}
	for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj) {
			for (i = FrameWidth; i > 0; i -= 8) {
				*(U32 *)YPlane = 0; YPlane += 4;
				*(U32 *)YPlane = 0; YPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
			}
	}

}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 92
//    | FrameHeight     |  + 88
//    | FrameWidth      |  + 84
//    | VPlane          |  + 80
//    | UPlane          |  + 76
//    | YPlane          |  + 72
//    | lpInput         |  + 68
//    | lpbiInput       |  + 64
//  -----------------------------
//    | return addr     |  + 60
//    | saved ebp       |  + 56
//    | saved ebx       |  + 52
//    | saved esi       |  + 48
//    | saved edi       |  + 44

//    | ypitch_adj      |  + 40
//    | yinput_height   |  + 36
//    | yinput_width    |  + 32
//    | yheight_diff    |  + 28
//    | ywidth_diff     |  + 24
//    | uvpitch_adj     |  + 20
//    | uvoutput_width  |  + 16
//    | uvinput_height  |  + 12
//    | uvinput_width   |  +  8
//    | uvheight_diff   |  +  4
//    | uvwidth_diff    |  +  0

#define LOCALSIZE        44

#define PITCH_PARM       92
#define FRAME_HEIGHT     88
#define FRAME_WIDTH      84
#define VPLANE           80
#define UPLANE           76
#define YPLANE           72
#define LP_INPUT         68
#define LPBI_INPUT       64

#define YPITCH_ADJ       40
#define YINPUT_HEIGHT    36
#define YINPUT_WIDTH     32
#define YHEIGHT_DIFF     28
#define YWIDTH_DIFF      24
#define UVPITCH_ADJ      20
#define UVOUTPUT_WIDTH   16
#define UVINPUT_HEIGHT   12
#define UVINPUT_WIDTH     8
#define UVHEIGHT_DIFF     4
#define UVWIDTH_DIFF      0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

		mov		ebx, [esp + FRAME_HEIGHT]
		mov		ecx, [esp + FRAME_WIDTH]
		mov		edx, [esp + PITCH_PARM]
// ypitch_adj = pitch - FrameWidth
		mov		eax, edx
		sub		eax, ecx
		mov		[esp + YPITCH_ADJ], eax
// uvoutput_width = FrameWidth >> 1
		mov		ebp, ecx
		shr		ebp, 1
		mov		[esp + UVOUTPUT_WIDTH], ebp
// uvpitch_adj = pitch - (FrameWidth >> 1)
		sub		edx, ebp
		mov		[esp + UVPITCH_ADJ], edx
// yinput_height = lpbiInput->biHeight
// uvinput_height = yinput_height >> 1
// yinput_width = lpbiInput->biWidth
// uvinput_width = yinput_width >> 1
		mov		ebx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biHeight
		mov		[esp + YINPUT_HEIGHT], eax
		shr		eax, 1
		mov		[esp + UVINPUT_HEIGHT], eax
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
// yheight_diff = FrameHeight - yinput_height
// uvheight_diff = yheight_diff >> 1;
		mov		eax, [esp + FRAME_HEIGHT]
		mov		ebx, eax
		sub		eax, [esp + YINPUT_HEIGHT]
		jns		NoCrop0
		xor		eax, eax
		mov		[esp + YINPUT_HEIGHT], ebx
		shr		ebx, 1
		mov		[esp + UVINPUT_HEIGHT], ebx
NoCrop0:
		mov		[esp + YHEIGHT_DIFF], eax
		shr		eax, 1
		mov		[esp + UVHEIGHT_DIFF], eax
// ywidth_diff = FrameWidth - yinput_width
// uvwidth_diff = ywidth_diff >> 1;
		mov		eax, [esp + FRAME_WIDTH]
		xor		ebx, ebx
		sub		eax, [esp + YINPUT_WIDTH]
		jns		NoCrop1
		mov		eax, [esp + FRAME_WIDTH]
		mov		ebx, [esp + YINPUT_WIDTH]
		sub		ebx, eax
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
		xor		eax, eax
NoCrop1:
		mov		[esp + YWIDTH_DIFF], eax
		shr		eax, 1
		mov		[esp + UVWIDTH_DIFF], eax
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]

// assign (edi, YPlane)
		mov		edi, [esp + YPLANE]
// for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YINPUT_HEIGHT]
L1:
// for (i = yinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + YINPUT_WIDTH]
L2:
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L2
// for (i = ywidth_diff; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + YWIDTH_DIFF]
		test	ebp, ebp
		jz		L3
L4:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L4
// j--, YPlane += ypitch_adj
L3:
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L1

// for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YHEIGHT_DIFF]
		test	ecx, ecx
		jz		L7
L5:
// for (i = FrameWidth; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + FRAME_WIDTH]
L6:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L6
// j--, YPlane += ypitch_adj
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L5

L7:
// recompute start of input U plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
// assign (edi, UPlane)
		mov		edi, [esp + UPLANE]
		shr		ebx, 1
// for (j = uvinput_height; j > 0; j--, UPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L8:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L9:
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L9
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L11
L10:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L10
// j--, UPlane += uvpitch_adj
L11:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L8

// for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L14
L12:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L13:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L13
// j--, UPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L12

L14:
// recompute start of input V plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
		shr		eax, 2
		add		esi, eax
// assign (edi, VPlane)
		mov		edi, [esp + VPLANE]
// for (j = uvinput_height; j > 0; j--, VPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L15:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L16:
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L16
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L18
L17:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L17
// j--, VPlane += uvpitch_adj
L18:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L15

// for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L21
L19:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L20:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L20
// j--, VPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L19

L21:
		add		esp, LOCALSIZE
		pop		edi
		pop		esi
		pop		ebx
		pop		ebp
		ret
	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef YPITCH_ADJ
#undef YINPUT_HEIGHT
#undef YINPUT_WIDTH
#undef YHEIGHT_DIFF
#undef YWIDTH_DIFF
#undef UVPITCH_ADJ
#undef UVOUTPUT_WIDTH
#undef UVINPUT_HEIGHT
#undef UVINPUT_WIDTH
#undef UVHEIGHT_DIFF
#undef UVWIDTH_DIFF

#if defined(_CODEC_STATS)
void NOC_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn, *peol;
int width_adj, height_adj;
int stretch, mark, aspect;
int iBackTwoLines;
int j, k;
int LumaIters = 0;
int ypitch_adj = 0;
int uvpitch_adj = 0;
int nextline = -(lpbiInput->biWidth << 1);

	for (j = FrameHeight; j > 0; j -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) << 1);
	// Point to the beginning of the last line.
	pnext = lpInput + ((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj))
			        + width_adj;

	for (j = LumaIters; j > 0; j--) {
		for (k = 0; k < mark; k++) {
			for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8) {
				if (0 == (k & 1)) {
					*(YPlane+0) = *(pnext+ 0);	*(YPlane+1) = *(pnext+ 2);
					*(YPlane+2) = *(pnext+ 4);	*(YPlane+3) = *(pnext+ 6);
					*(YPlane+4) = *(pnext+ 8);	*(YPlane+5) = *(pnext+10);
					*(YPlane+6) = *(pnext+12);	*(YPlane+7) = *(pnext+14);
					*(UPlane+0) = ((*(pnext+ 1)>>1) + (*(pnext+ 1+nextline)>>1));
					*(UPlane+1) = ((*(pnext+ 5)>>1) + (*(pnext+ 5+nextline)>>1));
					*(UPlane+2) = ((*(pnext+ 9)>>1) + (*(pnext+ 9+nextline)>>1));
					*(UPlane+3) = ((*(pnext+13)>>1) + (*(pnext+13+nextline)>>1));
					*(VPlane+0) = ((*(pnext+ 3)>>1) + (*(pnext+ 3+nextline)>>1));
					*(VPlane+1) = ((*(pnext+ 7)>>1) + (*(pnext+ 7+nextline)>>1));
					*(VPlane+2) = ((*(pnext+11)>>1) + (*(pnext+11+nextline)>>1));
					*(VPlane+3) = ((*(pnext+15)>>1) + (*(pnext+15+nextline)>>1));
					UPlane += 4; VPlane += 4;
				} else {
					*(YPlane+0) = *(pnext+ 0);	*(YPlane+1) = *(pnext+ 2);
					*(YPlane+2) = *(pnext+ 4);	*(YPlane+3) = *(pnext+ 6);
					*(YPlane+4) = *(pnext+ 8);	*(YPlane+5) = *(pnext+10);
					*(YPlane+6) = *(pnext+12);	*(YPlane+7) = *(pnext+14);
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth << 1);
			pbn = pnext;
			for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4,
															  plast += 8,
															  pbn += 8) {
				*(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1));
				*(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1));
				*(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1));
				*(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1));
			}
			YPlane += ypitch_adj;
		}
	}
}
#endif

#if 0
void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn, *peol;
int width_adj, height_adj;
int stretch, mark, aspect;
int iBackTwoLines;
int j, k;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);
int nextline = -(lpbiInput->biWidth << 1);

	for (j = FrameHeight; j > 0; j -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) << 1);
	// Point to the beginning of the last line.
	pnext = lpInput + ((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj))
			        + width_adj;

	for (j = LumaIters; j > 0; j--) {
		for (k = 0; k < mark; k++) {
			for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8) {
				if (0 == (k & 1)) {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
					*(UPlane+0) = ((*(pnext+ 1)>>1) + (*(pnext+ 1+nextline)>>1)) >> 1;
					*(UPlane+1) = ((*(pnext+ 5)>>1) + (*(pnext+ 5+nextline)>>1)) >> 1;
					*(UPlane+2) = ((*(pnext+ 9)>>1) + (*(pnext+ 9+nextline)>>1)) >> 1;
					*(UPlane+3) = ((*(pnext+13)>>1) + (*(pnext+13+nextline)>>1)) >> 1;
					*(VPlane+0) = ((*(pnext+ 3)>>1) + (*(pnext+ 3+nextline)>>1)) >> 1;
					*(VPlane+1) = ((*(pnext+ 7)>>1) + (*(pnext+ 7+nextline)>>1)) >> 1;
					*(VPlane+2) = ((*(pnext+11)>>1) + (*(pnext+11+nextline)>>1)) >> 1;
					*(VPlane+3) = ((*(pnext+15)>>1) + (*(pnext+15+nextline)>>1)) >> 1;
					UPlane += 4; VPlane += 4;
				} else {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth << 1);
			pbn = pnext;
			for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4,
															  plast += 8,
															  pbn += 8) {
				*(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1;
				*(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1;
				*(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1;
				*(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}
}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define PEOL				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * Y 0 * U 0 * Y 1 * V 0 * Y 2 * U 1 * Y 3 * V 1 * Y 4 * U 2 * Y 5 * V 2 * Y 6 * U 3 * Y 7 * V 3 *
//         *************************************************************************************************
// Y Offsets  0			  2			  4			  6			  8			  10		  12		  14
// U Offsets        1                       5                       9   					13
// Y Offsets                    3                       7                       11                      15
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+9]			; U2
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+13]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+11]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+15]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi]			; Y0
; 6
	mov		bh, [esi+5]			; U1
	mov		ah, [esi+2]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi+1]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+7]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+3]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+12]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+14]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+8]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+10]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+12]		; Y6
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+14]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi]			; Y0
; 5
	mov		ah, [esi+2]			; Y1
	mov		bh, [esi+10]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+8]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+4]
	mov		bl, [ebp+4]
	mov		bh, [ebp+6]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+6]
	mov		bl, [ebp]
; 2
	shl		eax, 16
	mov		bh, [ebp+2]
; 3
	mov		al, [edx]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+2]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+4]
; 9
	shr		eax, 1
	mov		bh, [ebp+6]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+4]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

bool UYVY_to_YUV12_Flip(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * pImage,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	DWORD dwFrameWidthHalf, dwFrameHeightHalf;
	BYTE *pRowStartY, *pRowStartSrc, *pRowStartU, *pRowStartV;
	int offset;

	int nRowsToSkip=0, nColsToSkip=0, nRowSkipDelta=0xffffff, nColSkipDelta=0xffffff;
	int nSrcRowIndex, nDstRowIndex, nSrcColIndex, nDstColIndex, COLUMNSTOSKIP=0, ROWSTOSKIP=0;


	if ((FrameWidth != (DWORD)(lpbiInput->biWidth)) || (FrameHeight != (DWORD)(lpbiInput->biHeight)))
	{
		nColsToSkip = COLUMNSTOSKIP = lpbiInput->biWidth - FrameWidth;
		nRowsToSkip = ROWSTOSKIP = lpbiInput->biHeight - FrameHeight;
		if ((nColsToSkip < 0) || (nRowsToSkip < 0))
		{
			return false;
		}

		// nXXXSkipDelta dictate how often we "skip" a row or col
		if (nRowsToSkip)
		{
			nRowSkipDelta = (lpbiInput->biHeight + (nRowsToSkip - 1)) / nRowsToSkip;
		}

		if (nColsToSkip)
		{
			nColSkipDelta = (lpbiInput->biWidth + (nColsToSkip - 1)) / nColsToSkip;
		}
	
	}

	// quick check to make sure we're processing CIF, QCIF, or SQCIF
	if ((FrameWidth % 4) || (FrameHeight % 4))
	{
		return false;
	}

	dwFrameWidthHalf = FrameWidth / 2;
	dwFrameHeightHalf = FrameHeight / 2;

	nSrcRowIndex = 0;
	nDstRowIndex = 0;

	// step 1, convert the Y values over
	while ((DWORD)nDstRowIndex < FrameHeight)
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		pRowStartY = YPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 1;

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		// Copy the Y values of the input row into the destination row		
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;

		while ((DWORD)nDstColIndex < FrameWidth)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nColsToSkip--;
				nSrcColIndex++;
				continue;
			}

			pRowStartY[nDstColIndex] = pRowStartSrc[nSrcColIndex * 2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}


	nSrcRowIndex = 0;
	nDstRowIndex = 0;
	nRowsToSkip = ROWSTOSKIP;

	// step 2, process U and V values
	while ((DWORD)nDstRowIndex < dwFrameHeightHalf)  // dest is only half as many rows as src
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		// don't process odd numbered rows
		if (nSrcRowIndex % 2)
		{
			
			// if we were supposed to skip this src row anyway, make sure
			// we update our decrement
			if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
			{
				nRowsToSkip--;
			}

			nSrcRowIndex++;

			continue;
		}

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		pRowStartU = UPlane + (pitch * nDstRowIndex);
		pRowStartV = VPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 0;

		// Copy the U and V values of the input row into the destination row
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;  // reset column skip count

		while ((DWORD)nDstColIndex < dwFrameWidthHalf)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// skip odd numbered columns
			if (nSrcColIndex % 2)
			{

				// if we were supposed to skip this src row anyway, make sure
				// we update our decrement

				if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
				{
					nColsToSkip--;
				}

				nSrcColIndex++;

				continue;
			}

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nSrcColIndex++;
				nColsToSkip--;
				continue;
			}

			offset = nSrcColIndex * 2;
			pRowStartU[nDstColIndex] = pRowStartSrc[offset] >> 1;
			pRowStartV[nDstColIndex] = pRowStartSrc[offset+2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}



	// and we are done!
	return true;

}



__declspec(naked)
_STATIC void IA_H26X_UYVYtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * U 0 * Y 0 * V 0 * Y 1 * U 1 * Y 2 * V 1 * Y 3 * U 2 * Y 4 * V 2 * Y 5 * U 3 * Y 6 * V 3 * Y 7 *
//         *************************************************************************************************
// Y Offsets        1           3           5           7           9           11          13          15
// U Offsets  0                       4                       8                       12       
// Y Offsets              2                       6                       10                      14      
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+8]			; U2
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+12]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+10]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+14]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi+1]			; Y0
; 6
	mov		bh, [esi+4]			; U1
	mov		ah, [esi+3]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+6]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+2]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+13]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+15]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+9]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+11]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+13]		; Y6
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+15]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi+1]			; Y0
; 5
	mov		ah, [esi+3]			; Y1
	mov		bh, [esi+11]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+9]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+5]
	mov		bl, [ebp+5]
	mov		bh, [ebp+7]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+7]
	mov		bl, [ebp+1]
; 2
	shl		eax, 16
	mov		bh, [ebp+3]
; 3
	mov		al, [edx+1]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+3]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+5]
; 9
	shr		eax, 1
	mov		bh, [ebp+7]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+5]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef PEOL
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*************************************************************
 *  Name:         colorCnvtFrame
 *  Description:  Color convert and copy input frame.
 ************************************************************/
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
)
{
    U8 *RGBCursor = (U8 *) lpicComp->lpInput;
	LPBITMAPINFOHEADER	lpbiInput = lpicComp->lpbiInput;
	bool bRet;

	FX_ENTRY("colorCnvtFrame")

    /*  The Connectix Quick Cam requires RGB to YUV12 conversion.
     *  The B/W camera generates palette versions (8 and 4 bit).
     *  The color camera generates RGB24 for million colors and
     *  RGB16555 for thousands colors.
     */

    if (BI_RGB == lpicComp->lpbiInput->biCompression)
	{
        if (24 == lpicComp->lpbiInput->biBitCount) {
#if 0
		if ((128 == lpbiInput->biWidth) && (96 == lpbiInput->biHeight)) {
			U8 YTest[12288];
			U8 UTest[6144];
			U8 VTest[6144];
			int i, j, k;
			U8 R,G,B;
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YTest, UTest, VTest,
				EC->FrameWidth, EC->FrameHeight, 128);
			for (i = 0; i < 96; i++) {
				for (j = 0; j < 128; j++) {
					k = (i*128)+j;
					if (1 < abs(YPlane[(i*384)+j]-YTest[(i*128)+j])) {
						B = RGBCursor[(((95-i)*128)+j)*3];
						G = RGBCursor[(((95-i)*128)+j)*3+1];
						R = RGBCursor[(((95-i)*128)+j)*3+2];
					}
					if ((0 == (i%2)) && (0 == (j%2))) {
						k =	((i>>1)*128)+(j>>1);
						if (1 < abs(UPlane[((i>>1)*384)+(j>>1)]-UTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
						if (1 < abs(VPlane[((i>>1)*384)+(j>>1)] != VTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
					}
				}
			}
		}
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#else
			IA_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(16 == lpicComp->lpbiInput->biBitCount)
		{
		// To use a common routine for all possible combinations of RGB16,
		// a bitfield number is passed. This number identifies the proper bit shift
		// and masking values to extract the color information
		// from the 16-bit pixel words.
		//
		//   number             shift              mask
		//                     B, G, R
		//   ------          -----------       ----------------
		//    555              2, 3, 8         0x7C, 0x7C, 0x7C
		//    664              3, 3, 9         0x78, 0x7E, 0x7E
		//    565              2, 4, 9         0x7C, 0x7E, 0x7C
		//    655              2, 3, 9         0x7C, 0x7C, 0x7E
		//
		// Only 555 falls under BI_RGB. The others are specified using the
		// BI_BITFIELDS compression specification. For BI_BITFIELDS, call
		// Build16bitModeID to get the actual bitfield number. This routine requires the
		// three array elements in the bmiColors field of a BITMAPINFO object.
		//
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR16toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 555, PITCH);
#else
			IA_H26X_BGR16555toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(8 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 8, PITCH);
#else
			IA_H26X_CLUT8toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(4 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 4, PITCH);
#else
			IA_H26X_CLUT4toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else
		{
			ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
		}
    }
    else if (FOURCC_YVU9 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if ((FOURCC_YUV12 == lpicComp->lpbiInput->biCompression) || (FOURCC_IYUV == lpicComp->lpbiInput->biCompression))
	{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
	}
    else if (FOURCC_YUY2 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if (FOURCC_UYVY == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif



		// UYVY images are upside-down in relation to I420
		// call the "flipped" version of the UYVY-I420 translator.

	bRet = UYVY_to_YUV12_Flip(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
	                          EC->FrameWidth, EC->FrameHeight, PITCH);


//          IA_H26X_UYVYtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
//            EC->FrameWidth, EC->FrameHeight, PITCH);


#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else
    {
		ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
    }
}

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12162.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cxm12162.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12162.asv  $
;// 
;//    Rev 1.10   01 Apr 1997 12:51:50   BNICKERS
;// Fix bugs # 153 and 156 -- wrong color when U is small;  right edge flickeri
;// 
;//    Rev 1.9   09 Dec 1996 15:20:40   BECHOLS
;// Brian fixed ARC bug #94.
;// 
;//    Rev 1.8   06 Sep 1996 16:07:58   BNICKERS
;// Re-written to filter new points.
;// 
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for Intel Microprocessors with MMX Technology
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by two.
; ||||||||
; cxm12162 -- This function performs zoom-by-2 YUV12-to-RGB16 color conversion
;             for H26x.  It is tuned for best performance on Intel
;             Microprocessors with MMX Technology.  It handles any format in
;             which there are three fields, the low order field being B and
;             starting in bit 0, the second field being G, and the high order
;             field being R.  Present support for 555, 565, 655, and 644
;             formats only.  This version adds new rows and columns by
;             averaging them with the originals to either side.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be QWORD aligned.  Pitch and Width must
;             be a multiple of eight.  Height may be any amount, but must be
;             a multiple of two.  The U and V planes may have a different
;             pitch than the Y plane, subject to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include ccinst.inc

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCCDATA SEGMENT PAGE
ALIGN 16

Luma0020004000200000 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW 0
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00100H
 DW (CNT*04A7FH)/00200H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 00000H
 DW 01FFFH
 DW 03FFFH
 DW 01FFFH
ENDM

UContribToBandG LABEL DWORD
DW -(-128*0C83H)/00040H
DW	08000H
DW -(-127*0C83H)/00040H
DW  08000H
CNT = -126
REPEAT 253
 DW -(CNT*00C83H)/00040H
 DW  (CNT*0408BH)/00040H
 CNT = CNT + 1
ENDM
DW  (127*0C83H)/00040H
DW  07FFFH

VContribToRandG LABEL DWORD
CNT = -128
REPEAT 256
 DW -(CNT*01A04H)/00040H
 DW  (CNT*03312H)/00040H
 CNT = CNT + 1
ENDM

MMXCCDATA ENDS

.CODE

ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

PUBLIC MMX_YUV12ToRGB16ZoomBy2

MMX_YUV12ToRGB16ZoomBy2 proc DIST LANG AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

MAXWIDTH = 768
LocalFrameSize = MAXWIDTH*20+128+64
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType                    = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

DitherB                  EQU  [esp+  0]
DitherG                  EQU  [esp+  8]
DitherR                  EQU  [esp+ 16]
SelectBBits              EQU  [esp+ 24]
SelectGBits              EQU  [esp+ 32]
SelectRBits              EQU  [esp+ 40]

ShiftCountForB           EQU  [esp+ 48]
ShiftCountForG           EQU  [esp+ 52]
ShiftCountForR           EQU  [esp+ 56]

CCOCursor                EQU  [esp+ 60]
CCOPitch                 EQU  [esp+MAXWIDTH*20+128+ 0]
YCursor                  EQU  [esp+MAXWIDTH*20+128+ 4]

YLimit                   EQU  [esp+MAXWIDTH*20+128+ 8]
YPitch                   EQU  [esp+MAXWIDTH*20+128+12]
UCursor                  EQU  [esp+MAXWIDTH*20+128+16]
DistanceFromUToV         EQU  [esp+MAXWIDTH*20+128+20]
ChromaPitch              EQU  [esp+MAXWIDTH*20+128+24]
AspectCount              EQU  [esp+MAXWIDTH*20+128+28]
AspectAdjustmentCount    EQU  [esp+MAXWIDTH*20+128+32]
StartIndexOfYLine        EQU  [esp+MAXWIDTH*20+128+36]
StashESP                 EQU  [esp+MAXWIDTH*20+128+40]

FiltLine0                EQU  [esp+ 64]  ; Must be 32 byte aligned.
FiltLine1                EQU  [esp+ 72]
FiltLine2                EQU  [esp+ 80]
FiltLine3                EQU  [esp+ 88]
HFiltLinePrev            EQU  [esp+ 96]

  push       esi
  push       edi
  push       ebp
  push       ebx

  mov        edi,esp
  and        esp,0FFFFF000H
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,LocalFrameSize-12288
  mov        eax,[esp]

  mov        eax,768
  sub        eax,[edi+FrameWidth_arg]
  imul       eax,20
  mov        StartIndexOfYLine,eax

  mov        eax,[edi+YPlane_arg]
  mov        YCursor,eax

  mov        ebx,[edi+YPitch_arg]
  mov        YPitch,ebx
  mov        ecx,[edi+FrameHeight]
  imul       ebx,ecx
  add        eax,ebx
  mov        YLimit,eax

  mov        eax,[edi+UPlane_arg]
  mov        ebx,[edi+VPlane_arg]
  mov        UCursor,eax
  sub        ebx,eax
  mov        DistanceFromUToV,ebx

  mov        eax,[edi+ColorConvertedFrame]
  add        eax,[edi+DCIOffset]
  add        eax,[edi+CCOffsetToLine0]
  mov        CCOCursor,eax

  mov        eax,[edi+ChromaPitch_arg]
  mov        ChromaPitch,eax

  mov        eax,[edi+CCOPitch_arg]
  mov        CCOPitch,eax

  mov        eax,[edi+AspectAdjustmentCount_arg]
  mov        AspectAdjustmentCount,eax
  mov        AspectCount,eax

  mov        StashESP,edi

  mov        eax,[edi+CCType]
  cmp        eax,CCTYPE_RGB16555ZoomBy2
  je         CCTypeIs555
  cmp        eax,CCTYPE_RGB16555ZoomBy2DCI
  je         CCTypeIs555
  cmp        eax,CCTYPE_RGB16565ZoomBy2
  je         CCTypeIs565
  cmp        eax,CCTYPE_RGB16565ZoomBy2DCI
  je         CCTypeIs565
  cmp        eax,CCTYPE_RGB16655ZoomBy2
  je         CCTypeIs655
  cmp        eax,CCTYPE_RGB16655ZoomBy2DCI
  je         CCTypeIs655
  cmp        eax,CCTYPE_RGB16664ZoomBy2DCI
  je         CCTypeIs664
  cmp        eax,CCTYPE_RGB16664ZoomBy2
  je         CCTypeIs664
  mov        eax,0DEADBEEFH
  mov        YCursor,eax

CCTypeIs555:

  mov        eax,000000200H   ; Dither pattern.
   mov       ebx,002000000H
  mov        DitherB,eax
   mov       DitherB+4,eax
  mov        DitherG,ebx
   mov       DitherG+4,ebx
  mov        DitherR,eax
   mov       DitherR+4,eax
  mov        eax,003E003E0H       ; Bits to extract for fields
   mov       ebx,07C007C00H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0001F001FH
   xor       ecx,ecx              ; Left shift count for R
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax
  mov        eax,10               ; Right shift count for B
   mov       ebx,5                ; Right shift count for G
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx
   jmp       CCTypeInitialized
   
CCTypeIs565:

  mov        eax,000000200H
   mov       ebx,004000000H
  mov        DitherB,eax
   mov       DitherB+4,eax
  mov        DitherG,ebx
   mov       DitherG+4,ebx
  mov        DitherR,eax
   mov       DitherR+4,eax
  mov        eax,007E007E0H
   mov       ebx,0F800F800H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0001F001FH
   mov       ecx,1
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax 
  mov        eax,10
   mov       ebx,4
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx
   jmp       CCTypeInitialized

CCTypeIs655:

  mov        eax,000000200H   ; Dither pattern.
   mov       ebx,004000000H
  mov        DitherB,eax
   mov       DitherB+4,eax
  mov        DitherG,eax
   mov       DitherG+4,eax
  mov        DitherR,ebx
   mov       DitherR+4,ebx
  mov        eax,003E003E0H       ; Bits to extract for fields
   mov       ebx,0FC00FC00H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0001F001FH
   mov       ecx,1                ; Left shift count for R
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax
  mov        eax,10               ; Right shift count for B
   mov       ebx,5                ; Right shift count for G
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx
   jmp       CCTypeInitialized

CCTypeIs664:

  mov        eax,000000400H   ; Dither pattern.
   mov       ebx,001000000H
  mov        DitherB,ebx
   mov       DitherB+4,ebx
  mov        DitherG,eax
   mov       DitherG+4,eax
  mov        DitherR,eax
   mov       DitherR+4,eax
  mov        eax,003F003F0H       ; Bits to extract for fields
   mov       ebx,0FC00FC00H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0000F000FH
   mov       ecx,1                ; Left shift count for R
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax
  mov        eax,11               ; Right shift count for B
   mov       ebx,5                ; Right shift count for G
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx

CCTypeInitialized:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   xor       eax,eax
  lea        edx,[esi+ebp*2]
   xor       ebx,ebx
  mov        YCursor,edx
   mov       bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOfFirst2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  mov        al,[esi+1]                       ; Get B.
   add       edi,40                           ; Inc filtered luma temp stg idx.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >

  movq       HFiltLinePrev[edi-40],mm1        ; Save L1 as next iters LPrev.
   paddw     mm1,mm0                          ; L0+L1
  paddw      mm0,mm0                          ; 2L0
   add       esi,2                            ; Increment input index.
  movq       FiltLine3[edi-40],mm1            ; Save filtered line L0+L1.
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi-40],mm0            ; Save filtered line 2L0.
   movq      mm0,mm2                          ; Next iters A.
  mov        bl,[esi+ebp*1+2]                 ; Get c.
   cmp       edi,MAXWIDTH*20-40               ; Done yet.
  mov        al,[esi+2]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  mov        ebp,DistanceFromUToV
   lea       eax,FiltLine2
  mov        esi,UCursor
   mov       edx,StartIndexOfYLine
  jmp        DoOutputLine


Last2OutputLines:

  mov        ebp,DistanceFromUToV
   lea       esi,[edi+40]
  ja         Done

;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  mm0-mm6 -- Scratch.


  movq       mm0,HFiltLinePrev[edi]   ; Fetch horizontally filtered line LP.
  paddw      mm0,mm0                  ; 2LP

Next2PelsOfLast2LumaLines:

  movq       FiltLine3[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       FiltLine2[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       mm0,HFiltLinePrev[edi+40]; Fetch horizontally filtered line LP.
  add        edi,40
   paddw     mm0,mm0                  ; 2LP
  cmp        edi,MAXWIDTH*20          ; Done yet.
   jne       Next2PelsOfLast2LumaLines

  lea        eax,FiltLine2
   mov       edx,StartIndexOfYLine
  mov        esi,UCursor
   jmp       DoOutputLine


Next4OutputLines:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   mov       ecx,YLimit
  lea        edx,[esi+ebp*2]
   xor       eax,eax
  mov        YCursor,edx
   xor       ebx,ebx
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).
   cmp       esi,ecx
  mov        bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
   jae       Last2OutputLines

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOf2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  movq       mm4,HFiltLinePrev[edi]           ; LP
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   movq      mm5,mm4                          ; LP
  mov        al,[esi+1]                       ; Get B.
   add       esi,2                            ; Increment input index.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >
   paddw     mm5,mm5                          ; 2LP
  movq       HFiltLinePrev[edi],mm1           ; Save L1 as next iters LPrev.
   paddw     mm4,mm0                          ; LP+L0
  movq       FiltLine0[edi],mm5               ; Save 2LP
   paddw     mm1,mm0                          ; L0+L1
  movq       FiltLine1[edi],mm4               ; Save LP+L0
   paddw     mm0,mm0                          ; 2L0
  movq       FiltLine3[edi],mm1               ; Save L0+L1
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi],mm0               ; Save 2L0
   movq      mm0,mm2                          ; Next iters A.
  add        edi,40                           ; Inc filtered luma temp stg idx.
   mov       bl,[esi+ebp*1+2]                 ; Get c.
  cmp        edi,MAXWIDTH*20-40               ; Done yet.
   mov       al,[esi+2]                       ; Get C.
  jl         Next2PelsOf2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOf2LumaLines

  mov        ebp,DistanceFromUToV
   mov       esi,UCursor
  lea        eax,FiltLine0
   mov       edx,StartIndexOfYLine

DoOutputLine:

  mov        edi,CCOCursor
   mov       ecx,AspectCount
  dec        ecx                    ; If count is non-zero, we keep the line.
   mov       ebx,CCOPitch
  mov        AspectCount,ecx
   je        SkipOutputLine

  add        ebx,edi
   xor       ecx,ecx
  mov        cl,[esi]
   add       eax,MAXWIDTH*20
  movdt      mm3,ShiftCountForB
   pcmpeqw   mm6,mm6
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gu >
  mov        cl,[esi+ebp*1]
   sub       edx,MAXWIDTH*20
  movdt      mm4,ShiftCountForG
   psllw     mm6,15                        ; Four words of -32768
  movdt      mm5,ShiftCountForR
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >
  movq       mm7,SelectBBits
  mov        CCOCursor,ebx
   jmp       StartDoOutputLine

; ebp -- Distance from U to V
; esi -- Cursor over U
; edi -- Cursor over output
; edx -- Index over Y storage area
; eax -- Base address of Y line
; mm6 -- Four words of -32768, to clamp at floor.
; mm3, mm4, mm5 -- Shift counts to apply to R, G, and B.

DoNext4OutputPels:

  movq       [edi-8],mm2                   ; Save 4 output pels.
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >

StartDoOutputLine:

  movdt      mm2,VContribToRandG[ecx*4]    ; <  0    0   Rv   Gv  >
   punpcklwd mm2,mm2                       ; < Rv   Rv   Gv   Gv  >
  movq       mm1,mm0                       ; < junk junk Gu   Gu  >
   punpckhdq mm0,mm0                       ; < Bu   Bu   Bu   Bu  >
  paddsw     mm0,[eax+edx]                 ; < B B B B > with ceiling clamped.
   paddw     mm1,mm2                       ; < junk junk Guv  Guv >
  paddsw     mm0,DitherB                   ; B with dither added.
   punpckldq mm1,mm1                       ; < Guv  Guv  Guv  Guv >
  paddsw     mm1,[eax+edx]                 ; < G G G G > with ceiling clamped.
   punpckhdq mm2,mm2                       ; < Rv   Rv   Rv   Rv  >
  paddsw     mm1,DitherG                   ; G with dither added.
   paddsw    mm0,mm6                       ; B with floor clamped.
  paddsw     mm2,[eax+edx]                 ; < R R R R > with ceiling clamped.
   paddsw    mm1,mm6                       ; G with floor clamped.
  paddsw     mm2,DitherR                   ; R with dither added.
   psrlw     mm0,mm3                       ; Position B bits.
  paddsw     mm2,mm6                       ; R with floor clamped.
   psrlw     mm1,mm4                       ; Position G bits.
  pand       mm1,SelectGBits               ; Eliminate fractional bits.
   psllw     mm2,mm5                       ; Position R bits.
  inc        esi                           ; Advance input cursor
   xor       ecx,ecx
  pand       mm2,SelectRBits               ; Eliminate fractional bits.
   pand      mm0,mm7
  mov        cl,[esi]                      ; Fetch next U.
   add       edi,8                         ; Advance output cursor.
  por        mm2,mm0                       ; R and B combined.
   add       edx,40                        ; Increment Y index.
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gv  > next iter.
   por       mm2,mm1                       ; Completed RGB16 for 4 output pels.
  mov        cl,[esi+ebp*1]                ; Fetch next V.
   jne       DoNext4OutputPels

  movq       [edi-8],mm2                   ; Save 4 output pels.

  movq       mm0,DitherB                   ; Reverse dither patterns.
  movq       mm1,DitherG
   psrlq     mm0,16
  movq       mm2,DitherR
   psrlq     mm1,16
  psrlq      mm2,16
  punpckldq  mm0,mm0
  punpckldq  mm1,mm1
  movq       DitherB,mm0
   punpckldq mm2,mm2
  movq       DitherG,mm1
  movq       DitherR,mm2

PrepareForNextOutputLine:

  mov        edx,StartIndexOfYLine
   add       eax,8-MAXWIDTH*20            ; Advance to next filtered line of Y.
  mov        esi,UCursor
   test      al,8                         ; Jump if just did line 0 or 2.
  mov        ebx,ChromaPitch
   jne       DoOutputLine

  add        esi,ebx                      ; Advance to next chroma line.
   test      al,16                        ; Jump if about to do line 2.
  mov        UCursor,esi
   jne       DoOutputLine

  sub        esi,ebx                      ; Done with 4 lines.  Restore UCursor.
  mov        UCursor,esi
   jmp       Next4OutputLines

SkipOutputLine:
  mov        ecx,AspectAdjustmentCount
   add       eax,MAXWIDTH*20
  mov        AspectCount,ecx
   jmp       PrepareForNextOutputLine

Done:

  mov        esp,StashESP
  pop        ebx
  pop        ebp
  pop        edi
  pop        esi
  rturn

MMX_YUV12ToRGB16ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx5128a2.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a2.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a2.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:57:48   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:32   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:02   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:59:12   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:52   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:45:24   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:24   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by two
; cx5128a2  -- This function performs YUV12 to CLUT8, zoom by two color
;              conversion for H26x.  It converts the input to the clut8
;              index dyncamically computed for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a2>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8APZoomBy2 (U8 * YPlane,
;                                              U8 * VPlane,
;                                              U8 * UPlane,
;                                              UN  FrameWidth,
;                                              UN  FrameHeight,
;                                              UN  YPitch,
;                                              UN  VPitch,
;                                              UN  AspectAdjustmentCount,
;                                              U8 FAR * ColorConvertedFrame,
;                                              U32 DCIOffset,
;                                              U32 CCOffsetToLine0,
;                                              IN  CCOPitch,
;                                              IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8APZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8APZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  xor   eax,eax
   xor  ebx,ebx
  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledi  CCOCursor                    ; Re-load color converted output cursor.
   Sebp EndOfLine
  sub   edi,esi
   Lebp YPitch

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+0]        ; 01UL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1]        ; 01UR  Fetch UV contrib to Active Pal addr
  sub   edi,esi
   mov  PB [esi+1],cl                ; 01    Stash 7 bit luma for next line

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+2]        ; 00UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shr   cl,1                         ; 00    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+3]        ; 00UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 01    Position high order pels
   mov  PB [esi+0],cl                ; 00    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 03UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  shr   cl,1                         ; 03    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+1]        ; 03UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  PB [esi+3],cl                ; 03    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 02UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shr   cl,1                         ; 02    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+3]        ; 02UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 03    Position high order pels
   mov  PB [esi+2],cl                ; 02    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+0+4]      ; 01UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1+4]      ; 01UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  PB [esi+1+4],cl              ; 01    Stash 7 bit luma for next line
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  Lesi  YPlane                       ; Reload luma cursor.
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine1

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*1-4+2]        ; 01LL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  mov   bh,PB [esi-768*1-4+3]        ; 01LR  Fetch UV contrib to Active Pal addr
   sub  edi,esi

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+0]        ; 00LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shl   edx,16                       ; 01    Position high order pels
   mov  bh,PB [esi-768*1-4+1]        ; 00LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 03LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*2-8+3]        ; 03LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 02LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shl   edx,16                       ; 03    Position high order pels
   mov  bh,PB [esi-768*2-8+1]        ; 02LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+2+4]      ; 01LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*1-4+3+4]      ; 01LR  Fetch UV contrib to Active Pal addr
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine1:

  Sedi  CCOCursor
   Lesi YPlane                       ; Reload luma cursor.
  sub   edi,esi
   xor  eax,eax

; ebp -- Luma pitch
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  sub   edi,esi
   mov  bh,PB [esi-768*1-4+0]

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+0]
  shl   edx,16
   mov  bh,PB [esi-768*1-4+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+3]
  mov   PD es:[edi+esi*2],edx
   mov  bh,PB [esi-768*2-8+0]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+2]
  shl   edx,16
   mov  bh,PB [esi-768*2-8+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  bh,PB [esi-768*1-4+0+4]
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor
  Lesi  YPlane
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine3

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0]
  sub   edi,esi
   mov  PB [esi+ebp*1+1],cl

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+0]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+2]
  shl   edx,16
   mov  PB [esi+ebp*1+0],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+3]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+0]
  mov   PD es:[edi+esi*2],edx
   mov  PB [esi+ebp*1+3],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+2]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+2]
  shl   edx,16
   mov  PB [esi+ebp*1+2],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  PB [esi+ebp*1+1+4],cl
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine3:

  add   ebp,ebp
   Lesi YPlane
  Sedi  CCOCursor
   add  esi,ebp
  Sesi  YPlane
   Ledx YLimit
  cmp   esi,edx
   jne  NextFourLines


IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8APZoomBy2 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512y2.asm ===
OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUY2


YUV12ToYUY2   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  52
RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

ASMTMP1            = 48         ; 13
Y                  = 44         ; 12
U                  = 40         ; 11
V                  = 36         ; 10
Outt               = 32         ; 9
YTemp              = 28         ; 8
UTemp              = 24         ; 7 
VTemp              = 20         ; 6
ASMTMP2            = 16         ; 5
Col                = 12         ; 4
OutTemp            = 8          ; 3
VAL                = 4          ; 2
LineCount          = 0          ; 1

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_ASMTMP1                 EQU    [esp + ASMTMP1]
_Y                       EQU    [esp + Y]
_U                       EQU    [esp + U]
_V                       EQU    [esp + V]
_Out                     EQU    [esp + Outt]
_YTemp                   EQU    [esp + YTemp]
_UTemp                   EQU    [esp + UTemp]
_VTemp                   EQU    [esp + VTemp]
_ASMTMP2                 EQU    [esp + ASMTMP2]
_Col                     EQU    [esp + Col]
_OutTemp                 EQU    [esp + OutTemp]
_VAL                     EQU    [esp + VAL]
_LineCount               EQU    [esp + LineCount]


; Save registers and start working

        push       ebx
         push      esi
        push       edi
         push      ebp

        sub        esp, LocalFrameSize

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
         mov       ecx, DWORD PTR _uYPlane         ; ecx = uYPlane
        dec        eax                             ; eax = bShapingFlag - 1
         mov       edx, DWORD PTR _uUPlane         ; edx = uUPlane
        mov        DWORD PTR _LineCount, eax       ; eax = FREE, LineCount 
         mov       DWORD PTR _Y, ecx               ; ecx = FREE, Y

        mov        eax, DWORD PTR _uVPlane         ; eax = uVPlane
         mov       ecx, DWORD PTR _uOffsetToLine0  ; ecx = uOffsetToLine0
        mov        DWORD PTR _U, edx               ; edx = FREE, U
         add       ecx, DWORD PTR _lOutput         ; ecx = uOffsetToLine0 +

        mov        DWORD PTR _V, eax               ; eax = FREE, V
        mov        eax, DWORD PTR _uCCOutputBuffer ; eax = uCCOutputBuffer
        add        eax, ecx                        ; eax = uCCOutputBuffer +
                                                   ;       uOffsetToLine0 +
                                                   ;       lOutput
                                                   ;       ecx = FREE
        mov        DWORD PTR _Out, eax             ; eax = FREE, Out
        mov        eax, DWORD PTR _uHeight         ; eax = uHeight

	      sar	       eax, 1                          ; eax = uHeight/2
        mov        DWORD PTR _ASMTMP2, eax         ; eax = FREE, Row ready to 
                                                   ; count down

RowLoop:; L27704 outer loop over all rows


        mov        ecx, DWORD PTR _Y               ; ecx = Y: ecx EQU YTemp
         mov       edi, DWORD PTR _U               ; edi = U: edi EQU UTemp
        mov        ebp, DWORD PTR _V               ; ebp = V: ebp EQU VTemp 
         mov       esi, DWORD PTR _Out             ; esi = OutTemp
        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
	      test	     eax, eax                        ; is LineCount == 0? eax = FREE
        je         SHORT SkipEvenRow               ; L27708 loop if so, skip the even loop
        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2                          ; eax = uWidth/4	** assume uWidth/4 != 0


EvenRowPels:; L27709 loop over columns in even row - two YUY2 pels at a time.

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         jne       SHORT EvenRowPels               ; L27709 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
        jmp        SHORT UpdatePointers						 ; L27770

SkipEvenRow:; L27708

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out
         
UpdatePointers:	; L27770


        mov        ecx, DWORD PTR _Y               ; ecx = Y
         dec       eax                             ; eax = LineCount-1 OR bShapingFlag - 1
        mov        edx, DWORD PTR _intPitch        ; edx = intPitch
         mov       esi, DWORD PTR _Out             ; esi = Out
				mov        DWORD PTR _LineCount, eax       ; store decremented linecount
                                                   ; eax = FREE
        add        esi, edx                        ; (esi) Out += intPitch ***
         mov       eax, DWORD PTR _uYPitch         ; eax = uYPitch
        mov        edi, DWORD PTR _U               ; edi = U	***
         add       ecx, eax                        ; (ecx) Y += uYPitch ***
        mov        ebp, DWORD PTR _V               ; ebp = V	***
         mov       DWORD PTR _Y, ecx               ; store updated Y 
      
        mov        DWORD PTR _Out, esi             ; store Out
         mov       eax, DWORD PTR _LineCount       ; eax = LineCount
    
        test       eax, eax                        ; is LineCount == 0?
                                                   ; if so, ignore the odd
                                                   ; row loop over columns
         je        SHORT SkipOddRow						  	 ; L27714

        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2											 ; eax = uWidth/4
	      

OddRowPels: ;L27715 loop over columns of odd rows

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         
        jne        SHORT OddRowPels                ; L27715 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
         jmp       SHORT UpdateAllPointers	  		 ; L27771

SkipOddRow: ;L27714 

        mov        eax, DWORD PTR _bShapingFlag		 ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out

UpdateAllPointers: ; L27771 update pointers

      	dec	       eax														 ; eax = LineCount-1 OR bShapingFlag - 1
         mov       ecx, DWORD PTR _Y							 ; ecx = Y
        mov        edx, DWORD PTR _intPitch				 ; edx = intPitch
         mov       ebx, DWORD PTR _Out						 ; ebx = Out
	      add	       ebx, edx												 ; ebx = Out + intPitch
         mov       ebp, DWORD PTR _ASMTMP2				 ; ebp = row loop counter
        mov        DWORD PTR _LineCount, eax			 ; store updated LineCount
         mov       DWORD PTR _Out, ebx						 ; store updated Out
				mov        edx, DWORD PTR _uUVPitch        ; edx = uUVPitch
				 mov       eax, DWORD PTR _U               ; eax = U
				mov        esi, DWORD PTR _V               ; esi = V
				 add       eax, edx                        ; eax = U + uUVPitch
				add        esi, edx                        ; esi = V + uUVPitch
				 mov       DWORD PTR _U, eax               ; store updated U
				mov        DWORD PTR _V, esi               ; store updated V
         add       ecx, DWORD PTR _uYPitch				 ; ecx = Y + uYPitch
	      dec	       ebp														 ; decrement loop counter
         mov       DWORD PTR _Y, ecx							 ; store updated Y
        mov        DWORD PTR _ASMTMP2, ebp				 ; store updated loop counter
        
        jne        RowLoop                         ; back to L27704 row loop



CleanUp:

        add        esp, LocalFrameSize             ; restore esp to registers                               


      	pop	ebp
	       pop	edi
	      pop	esi
	       pop	ebx

        ret     52                                 ; 13*4 bytes of arguments

YUV12ToYUY2 ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12161.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cx512161.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12161.asv  $
;// 
;//    Rev 1.9   24 May 1996 11:12:10   AGUPTA2
;// 
;// Modified version of final drop from IDC.  Fixed alignment, global var,
;// referencing beyond stack pointer problems.  Cosmetic changes to adhere
;// to a common coding convention in all MMX color convertor files.
;//
;//    Rev 1.8   17 Apr 1996 09:51:08   ISRAELH
;// Added AspectRatio adjustement, emms.
;//
;//    Rev 1.7   11 Apr 1996 09:51:08   RMCKENZX
;// Changed return to pop the stack.
;//
;//    Rev 1.6   09 Apr 1996 10:00:44   RMCKENZX
;//
;// Changed calling sequence to __stdcall.
;//
;//    Rev 1.5   05 Apr 1996 10:40:20   RMCKENZX
;// Hacked in Aspect Ratio correction.  This is accomplished
;// by simply overwriting the next even line after the aspect
;// count has been matched or exceeded.
;//
;//    Rev 1.4   29 Mar 1996 07:52:56   RMCKENZX
;// re-fixed bug in 655 setup.
;//
;//    Rev 1.3   28 Mar 1996 14:35:38   RMCKENZX
;// Cleaned up code, added comments, revised calling sequence,
;// moved global variables onto stack.
;//
;//    Rev 1.2   21 Mar 1996 08:10:06   RMCKENZX
;// Fixed 655 case -- initialized GLeftShift at 5.
;//
;//    Rev 1.1   20 Mar 1996 11:18:52   RMCKENZX
;// March 96 version.
;
;     Rev 1.3   19 Feb 1996 11:49:42   israelh
;  bug fix.
;  new algorithm for RGB16 bit pack.
;
;     Rev 1.3   18 Feb 1996 20:58:44   israelh
;  better algorithm and bug fix
;
;     Rev 1.2   29 Jan 1996 19:53:50   mikeh
;
;  added Ifdef timing
;
;     Rev 1.1   29 Jan 1996 16:29:16   mikeh
;  remvoed $LOG stuff
;
;     Rev 1.0   29 Jan 1996 11:49:44   israelh
;  Initial revision.
;//
;// MMX 1.3 14 Jan 1996 IsraelH
;// Implementing runtime RGB bit allocation according to BValLo[0]:
;// It contains the ColorConvertor value from d1color.cpp module.
;// Compiler flag RTIME16 for using runtime allocation.
;//
;// MMX 1.2 10 Jan 1996 IsraelH
;// Implementing RGB16x565 (5-R 5-G 5-B) as default
;// Compiler flag MODE555 for RGB16555 (5-R 5-G 5-B)
;//
;// MMX 1.1 09 Jan 1996 IsraelH
;// Implementing RGB16x555 (5-R 5-G 5-B)
;// Commenting out RGB16664 (6-R 6-G 4-B)
;// Adding performance measurements in runtime
;//
;// MMX 1.0 25 Dec 1995 IsraelH
;// Port to MMX(TM) without using tables
;
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cxm12161 -- This function performs YUV12-to-RGB16 color conversion for H26x.
;             It handles any format in which there are three fields, the low
;             order field being B and fully contained in the low order byte, the
;             second field being G and being somewhere in bits 4 through 11,
;             and the high order field being R and fully contained in the high
;             order byte.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
Minusg              DWORD   00800080h, 00800080h
Yadd                DWORD   10101010h, 10101010h
VtR                 DWORD   00660066h, 00660066h ;01990199h,01990199h
VtG                 DWORD   00340034h, 00340034h ;00d000d0h,00d000d0h
UtG                 DWORD   00190019h, 00190019h ;00640064h,00640064h
UtB                 DWORD   00810081h, 00810081h ;02050205h,02050205h
Ymul                DWORD   004a004ah, 004a004ah ;012a012ah,012a012ah
UVtG                DWORD   00340019h, 00340019h ;00d00064h,00d00064h
VtRUtB              DWORD   01990205h, 01990205h
fourbitu            DWORD  0f0f0f0f0h, 0f0f0f0f0h
fivebitu            DWORD  0e0e0e0e0h, 0e0e0e0e0h
sixbitu             DWORD  0c0c0c0c0h, 0c0c0c0c0h
MMXDATA1 ENDS

MMXCODE1 SEGMENT
MMX_YUV12ToRGB16 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

LocalFrameSize           = 256
RegisterStorageSize      = 16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU argument_base +  4
VPlane                   EQU argument_base +  8
UPlane                   EQU argument_base + 12
FrameWidth               EQU argument_base + 16
FrameHeight              EQU argument_base + 20
YPitch                   EQU argument_base + 24
ChromaPitch              EQU argument_base + 28
AspectAdjustmentCount    EQU argument_base + 32
ColorConvertedFrame      EQU argument_base + 36
DCIOffset                EQU argument_base + 40
CCOffsetToLine0          EQU argument_base + 44
CCOPitch                 EQU argument_base + 48
CCType                   EQU argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
localFrameWidth          EQU local_base + 0
localYPitch              EQU local_base + 4
localChromaPitch         EQU local_base + 8
localAspectAdjustmentCount EQU local_base + 12
localCCOPitch            EQU local_base + 16
CCOCursor                EQU local_base + 20
CCOSkipDistance          EQU local_base + 24
YLimit                   EQU local_base + 28
DistanceFromVToU         EQU local_base + 32
currAspectCount          EQU local_base + 36
YCursorEven              EQU local_base + 40
YCursorOdd               EQU local_base + 44
tmpCCOPitch              EQU local_base + 48
StashESP                 EQU local_base + 52
; space for two DWORD locals
temp_mmx                 EQU local_base + 64  ; note it is 64 bytes
RLeftShift               EQU local_base +128
GLeftShift               EQU local_base +136
RRightShift              EQU local_base +144
GRightShift              EQU local_base +152
BRightShift              EQU local_base +160
RUpperLimit              EQU local_base +168
GUpperLimit              EQU local_base +176
BUpperLimit              EQU local_base +184

; Switches used by RGB color convertors to determine the exact conversion type.
RGB16555 =  9
RGB16664 = 14
RGB16565 = 18
RGB16655 = 22

  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32
   mov       [StashESP], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Save some parameters on local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [FrameWidth]
   ;
  mov        [localFrameWidth], ebx
   mov       ebx, [YPitch]
  mov        [localYPitch], ebx
   mov       ebx, [ChromaPitch]
  mov        [localChromaPitch], ebx
   mov       ebx, [AspectAdjustmentCount]
  mov        [localAspectAdjustmentCount], ebx
   mov       ebx, [CCOPitch]
  mov        [localCCOPitch], ebx
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Set-up rest of the local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov       al, [CCType]
  cmp        al, RGB16555
   je        RGB555
  cmp        al, RGB16664
   je        RGB664
  cmp        al, RGB16565
   je        RGB565
  cmp        al, RGB16655
   je        RGB655
RGB555:
  xor        eax, eax
   mov       ebx, 2   ; 10-8 for byte shift
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 5
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 9
  mov        [RRightShift], ebx
   mov       [RRightShift+4], eax
  mov        [GRightShift], ebx
   mov       [GRightShift+4], eax
  mov        [BRightShift], ebx
   mov       [BRightShift+4], eax
  movq       mm0, fivebitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       [GUpperLimit], mm0
   ;
  movq       [BUpperLimit], mm0
   jmp       RGBEND

RGB664:
  xor        eax, eax
   mov       ebx, 2   ; 8-6
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 4
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 8
  mov        [RRightShift], ebx
   mov       [RRightShift+4], eax
  mov        [GRightShift], ebx
   mov       [GRightShift+4], eax
  mov        ebx, 10
   mov       [BRightShift+4], eax
  mov        [BRightShift], ebx
   ;
  movq       mm0, sixbitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       [GUpperLimit], mm0
   ;
  movq       mm0, fourbitu
   ;
  movq       [BUpperLimit], mm0
   jmp       RGBEND

RGB565:
  xor        eax, eax
   mov       ebx, 3   ; 8-5
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 5
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 9
  mov        [RRightShift+4], eax
   mov       [RRightShift], ebx
  mov        [BRightShift], ebx
   mov       [BRightShift+4], eax
  mov        ebx, 8
   mov       [GRightShift+4], eax
  mov        [GRightShift], ebx
   ;
  movq       mm0, fivebitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       [BUpperLimit], mm0
   ;
  movq       mm0, sixbitu
   ;
  movq       [GUpperLimit], mm0
   jmp       RGBEND

RGB655:
  xor        eax, eax
   mov       ebx, 2   ; 8-6
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 5
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 8
  mov        [RRightShift], ebx
   mov       [RRightShift+4], eax
  mov        ebx, 9
   mov       [GRightShift+4], eax
  mov        [GRightShift], ebx
   mov       [BRightShift], ebx
  mov        [BRightShift+4], eax
   ;
  movq       mm0, sixbitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       mm0, fivebitu
   ;
  movq       [GUpperLimit], mm0
   ;
  movq       [BUpperLimit], mm0
   jmp       RGBEND

RGBEND:
  mov        ebx, [VPlane]
   mov       ecx, [UPlane]
  sub        ecx, ebx
   mov       eax, [ColorConvertedFrame]
  mov        [DistanceFromVToU], ecx
   mov       edx, [DCIOffset]
  add        eax, edx
   mov       edx, [CCOffsetToLine0]
  add        eax, edx
   mov       edx, [FrameHeight]
  mov        [CCOCursor], eax
   mov       ecx, [YPitch]
  imul       edx, ecx                        ; FrameHeight*YPitch
   ;
  mov        ebx, [FrameWidth]
   mov       eax, [CCOPitch]
  sub        eax, ebx                        ; CCOPitch-FrameWidth
   mov       esi, [YPlane]                   ; Fetch cursor over luma plane.
  sub        eax, ebx                        ; CCOPitch-2*FrameWidth
   mov       [CCOSkipDistance], eax          ; CCOPitch-2*FrameWidth
  add        edx, esi                        ; YPlane+Size_of_Y_array
   ;
  mov        [YLimit], edx
   mov       edx, [AspectAdjustmentCount]
  cmp        edx,1
   je        finish
  mov        esi, [VPlane]
   mov       [currAspectCount], edx
  mov        [localAspectAdjustmentCount], edx
   xor       eax, eax
  mov        edi, [CCOCursor]
   mov       edx, [DistanceFromVToU]
  mov        ebp, [YPlane]
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  cannot access parameters beyond this point
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov       ebx, [localFrameWidth]
  mov        eax, [localYPitch]
   add       ebp, ebx
  mov        [YCursorEven], ebp				 ; YPlane + FrameWidth
   add       ebp, eax						 
  sar        ebx, 1							 ; FrameWidth/2
   mov       [YCursorOdd], ebp				 ; YPlane + FrameWidth + YPitch
  add        esi, ebx						 ; VPlane + FrameWidth/2
   ;
  add        edx, esi						 ; UPlane + FrameWidth/2
   neg       ebx
  mov       [localFrameWidth], ebx           ; -FrameWidth/2

;  Register Usage:
;
;------------------------------------------------------------------------------
PrepareChromaLine:
  mov        ebp, [currAspectCount]
   mov       ebx, [localFrameWidth]
  sub        ebp, 2
   mov       eax, [localCCOPitch]
  mov        [tmpCCOPitch], eax
   ja        continue
  xor        eax, eax
   add       ebp, [localAspectAdjustmentCount]
  mov        [tmpCCOPitch], eax

continue:
  mov       [currAspectCount], ebp

do_next_8x2_block:
  mov        ebp, [YCursorEven]
; here is even line
  movdt      mm1, [edx+ebx]                  ; 4 u values
   pxor      mm0, mm0                        ; mm0=0
  movdt      mm2, [esi+ebx]                  ; 4 v values
   punpcklbw mm1, mm0                        ; get 4 unsign u
  psubw      mm1, Minusg                     ; get 4 unsign u-128
   punpcklbw mm2, mm0                        ; get unsign v
  psubw      mm2, Minusg                     ; get unsign v-128
   movq      mm3, mm1                        ; save the u-128 unsign
  movq       mm5, mm1                        ; save u-128 unsign
   punpcklwd mm1, mm2                        ; get 2 low u, v unsign pairs
  pmaddwd    mm1, UVtG
   punpckhwd mm3, mm2                        ; create high 2 unsign uv pairs
  pmaddwd    mm3, UVtG
   ;
  movq       [temp_mmx], mm2                 ; save v-128
   ;
  movq       mm6, [ebp+2*ebx]                ; mm6 has 8 y pixels
   ;
  psubusb    mm6, Yadd                       ; mm6 has 8 y-16 pixels
   packssdw  mm1, mm3                        ; packed the results to signed words
  movq       mm7, mm6                        ; save the 8 y-16 pixels
   punpcklbw mm6, mm0                        ; mm6 has 4 low y-16 unsign
  pmullw     mm6, Ymul
   punpckhbw mm7, mm0                        ; mm7 has 4 high y-16 unsign
  pmullw     mm7, Ymul
   movq      mm4, mm1
  movq       [temp_mmx+8], mm1               ; save 4 chroma G values
   punpcklwd mm1, mm1                        ; chroma G replicate low 2
  movq       mm0, mm6                        ; low  y
   punpckhwd mm4, mm4                        ; chroma G replicate high 2
  movq       mm3, mm7                        ; high y
   psubw     mm6, mm1                        ;  4 low G
  psraw      mm6, [GRightShift]
   psubw     mm7, mm4                        ; 4 high G values in signed 16 bit
  movq       mm2, mm5
   punpcklwd mm5, mm5                        ; replicate the 2 low u pixels
  pmullw     mm5, UtB
   punpckhwd mm2, mm2
  psraw      mm7, [GRightShift]
   pmullw    mm2, UtB
  packuswb   mm6, mm7                        ; mm6: G7 G6 G5 G4 G3 G2 G1 G0
   ;
  movq       [temp_mmx+16], mm5              ; low chroma B
   paddw     mm5, mm0                        ; 4 low B values in signed 16 bit
  movq       [temp_mmx+40], mm2              ; high chroma B
   paddw     mm2, mm3                        ; 4 high B values in signed 16 bit
  psraw      mm5, [BRightShift]              ; low B scaled down by 6+(8-5)
   ;
  psraw      mm2, [BRightShift]              ; high B scaled down by 6+(8-5)
   ;
  packuswb   mm5, mm2                        ; mm5: B7 B6 B5 B4 B3 B2 B1 B0
   ;
  movq       mm2, [temp_mmx]                 ; 4 v values
   movq      mm1, mm5                        ; save B
  movq       mm7, mm2
   punpcklwd mm2, mm2                        ; replicate the 2 low v pixels
  pmullw     mm2, VtR
   punpckhwd mm7, mm7
  pmullw     mm7, VtR
   ;
  paddusb    mm1, [BUpperLimit]              ; mm1: saturate B+0FF-15
   ;
  movq       [temp_mmx+24], mm2              ; low chroma R
   ;
  paddw      mm2, mm0                        ; 4 low R values in signed 16 bit
   ;
  psraw      mm2, [RRightShift]              ; low R scaled down by 6+(8-5)
   pxor      mm4, mm4                        ; mm4=0 for 8->16 conversion
  movq       [temp_mmx+32], mm7              ; high chroma R
   paddw     mm7, mm3                        ; 4 high R values in signed 16 bit
  psraw      mm7, [RRightShift]              ; high R scaled down by 6+(8-5)
   ;
  psubusb    mm1, [BUpperLimit]
   packuswb  mm2, mm7                        ; mm2: R7 R6 R5 R4 R3 R2 R1 R0
  paddusb    mm6, [GUpperLimit]              ; G fast patch ih
   ;
  psubusb    mm6, [GUpperLimit]              ; fast patch ih
   ;
  paddusb    mm2, [RUpperLimit]              ; R
   ;
  psubusb    mm2, [RUpperLimit]
   ;

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; here we are packing from RGB24 to RGB16
  ; input:
  ; mm6: G7 G6 G5 G4 G3 G2 G1 G0
  ; mm1: B7 B6 B5 B4 B3 B2 B1 B0
  ; mm2: R7 R6 R5 R4 R3 R2 R1 R0
  ; assuming 8 original pixels in 0-H representation on mm6, mm5, mm2
  ; when  H=2**xBITS-1 (x is for R G B)
  ; output:
  ;        mm1- result: 4 low RGB16
  ;        mm7- result: 4 high RGB16
  ; using: mm0- zero register
  ;        mm3- temporary results
  ; algorithm:
  ;   for (i=0; i<8; i++) {
  ;     RGB[i]=256*(R[i]<<(8-5))+(G[i]<<5)+B[i];
  ;   }
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  psllq      mm2, [RLeftShift]  ; position R in the most significant part of the byte
   movq      mm7, mm1                        ; mm1: Save B

  ; note: no need for shift to place B on the least significant part of the byte
  ;   R in left position, B in the right position so they can be combined

  punpcklbw  mm1, mm2                        ; mm1: 4 low 16 bit RB
   pxor      mm0, mm0                        ; mm0: 0
  punpckhbw  mm7, mm2                        ; mm5: 4 high 16 bit RB
   movq      mm3, mm6                        ; mm3: G
  punpcklbw  mm6, mm0                        ; mm6: low 4 G 16 bit
   ;
  psllw      mm6, [GLeftShift]               ; shift low G 5 positions
   ;
  punpckhbw  mm3, mm0                        ; mm3: high 4 G 16 bit
   por       mm1, mm6                        ; mm1: low RBG16
  psllw      mm3, [GLeftShift]               ; shift high G 5 positions
   ;
  por        mm7, mm3                        ; mm5: high RBG16
   ;
  mov        ebp, [YCursorOdd]               ; moved to here to save cycles before odd line
   ;
  movq       [edi], mm1                      ; !! aligned
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;- start odd line
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       mm1, [ebp+2*ebx]                ; mm1 has 8 y pixels
   pxor      mm2, mm2
  psubusb    mm1, Yadd                       ; mm1 has 8 pixels y-16
   ;
  movq       mm5, mm1
   punpcklbw mm1, mm2                        ; get 4 low y-16 unsign pixels word
  pmullw     mm1, Ymul                       ; low 4 luminance contribution
   punpckhbw mm5, mm2                        ; 4 high y-16
  pmullw     mm5, Ymul                       ; high 4 luminance contribution
   ;
  movq       [edi+8], mm7                    ; !! aligned
   movq      mm0, mm1
  paddw      mm0, [temp_mmx+24]              ; low 4 R
   movq      mm6, mm5
  psraw      mm0, [RRightShift]              ; low R scaled down by 6+(8-5)
   ;
  paddw      mm5, [temp_mmx+32]              ; high 4 R
   movq      mm2, mm1
  psraw      mm5, [RRightShift]              ; high R scaled down by 6+(8-5)
   ;
  paddw      mm2, [temp_mmx+16]              ; low 4 B
   packuswb  mm0, mm5                        ; mm0: R7 R6 R5 R4 R3 R2 R1 R0
  psraw      mm2, [BRightShift]              ; low B scaled down by 6+(8-5)
   movq      mm5, mm6
  paddw      mm6, [temp_mmx+40]              ; high 4 B
   ;
  psraw      mm6, [BRightShift]              ; high B scaled down by 6+(8-5)
   ;
  movq       mm3, [temp_mmx+8]               ; chroma G  low 4
   ;
  packuswb   mm2, mm6                        ; mm2: B7 B6 B5 B4 B3 B2 B1 B0
   movq      mm4, mm3
  punpcklwd  mm3, mm3                        ; replicate low 2
   ;
  punpckhwd  mm4, mm4                        ; replicate high 2
   psubw     mm1, mm3                        ;  4 low G
  psraw      mm1, [GRightShift]              ; low G scaled down by 6+(8-5)
   psubw     mm5, mm4                        ;  4 high G values in signed 16 bit
  psraw      mm5, [GRightShift]              ; high G scaled down by 6+(8-5)
   ;
  paddusb    mm2, [BUpperLimit]              ; mm1: saturate B+0FF-15
   packuswb  mm1, mm5                        ; mm1: G7 G6 G5 G4 G3 G2 G1 G0
  psubusb    mm2, [BUpperLimit]
   ;
  paddusb    mm1, [GUpperLimit]              ; G
   ;
  psubusb    mm1, [GUpperLimit]
   ;
  paddusb    mm0, [RUpperLimit]              ; R
   ;
  mov        eax, [tmpCCOPitch]
   ;
  psubusb    mm0, [RUpperLimit]
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; here we are packing from RGB24 to RGB16
  ; mm1: G7 G6 G5 G4 G3 G2 G1 G0
  ; mm2: B7 B6 B5 B4 B3 B2 B1 B0
  ; mm0: R7 R6 R5 R4 R3 R2 R1 R0
  ; output:
  ;        mm2- result: 4 low RGB16
  ;        mm7- result: 4 high RGB16
  ; using: mm4- zero register
  ;        mm3- temporary results
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  psllq      mm0, [RLeftShift]               ; position R in the most significant part of the byte
   movq      mm7, mm2                        ; mm7: Save B

  ; note: no need for shift to place B on the least significant part of the byte
  ;   R in left position, B in the right position so they can be combined

  punpcklbw  mm2, mm0                        ; mm1: 4 low 16 bit RB
   pxor      mm4, mm4                        ; mm4: 0
  movq       mm3, mm1                        ; mm3: G
   punpckhbw mm7, mm0                        ; mm7: 4 high 16 bit RB
  punpcklbw  mm1, mm4                        ; mm1: low 4 G 16 bit
   ;
  punpckhbw  mm3, mm4                        ; mm3: high 4 G 16 bit
   ;
  psllw      mm1, [GLeftShift]               ; shift low G 5 positions
   por       mm2, mm1                        ; mm2: low RBG16
  psllw      mm3, [GLeftShift]               ; shift high G 5 positions
   ;
  por        mm7, mm3                        ; mm7: high RBG16
   ;
  movq       [edi+eax], mm2
   ;
  movq       [edi+eax+8], mm7                ; aligned
   ;
  add        edi, 16                         ; ih take 16 bytes (8 pixels-16 bit)
   add       ebx, 4                          ; ? to take 4 pixels together instead of 2
  jl         do_next_8x2_block               ; ? update the loop for 8 y pixels at once
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Update:
  ;    edi: output RGB plane pointer for odd and even line
  ;    ebp: Y Plane address
  ;    esi: V Plane address
  ;    edx: U Plane address
  ;    YcursorEven: Even Y line address
  ;    YCursorOdd:  Odd Y line address
  ;  Note:  eax, ebx, ecx can be used as scratch registers
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ecx, [CCOSkipDistance]
   mov       eax, [localYPitch]
  add        edi, ecx                        ; go to begin of next even line
   mov       ecx, [tmpCCOPitch]
  add        edi, ecx                        ; skip odd line
   mov       ecx, [localChromaPitch]
  add        esi, ecx
   add       ebp, eax                        ; skip two lines
  mov        [YCursorEven], ebp              ; save even line address
   mov       ecx, [localChromaPitch]
  add        edx, ecx
   add       ebp, eax                        ; odd line address
  mov        [YCursorOdd], ebp               ; save odd line address
   mov       eax, [YLimit]                   ; Done with last line?
  cmp        ebp, eax
   jbe       PrepareChromaLine
;  ADDedi     CCOSkipDistance        ; go to begin of next line
;  ADDedi     tmpCCOPitch           ; skip odd line (if it is needed)
;  Leax       YPitch
;  Lebp       YCursorOdd
;  add        ebp, eax       ; skip one line
;  Sebp       YCursorEven
;
;  add        ebp, eax       ; skip one line
;  Sebp       tmpYCursorOdd
;  ADDesi     ChromaPitch
;  ADDedx     ChromaPitch
;  Leax       YLimit                  ; Done with last line?
;  cmp        ebp, eax
;  jbe        PrepareChromaLine

finish:
  mov        esp, [StashESP]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToRGB16 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12242.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cxm12242.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12242.asv  $
;// 
;//    Rev 1.4   01 Apr 1997 12:53:18   BNICKERS
;// Fix bugs # 153 and 156 -- wrong color when U is small;  right edge flickeri
;// 
;//    Rev 1.3   11 Mar 1997 13:49:36   JMCVEIGH
;// Same ARC bug fix (#94) as was done in cxm12162.asm. Without
;// this, zoom by 2 and ARC causes black lines in output (every 12th).
;// 
;//    Rev 1.2   06 Sep 1996 16:08:14   BNICKERS
;// Re-written to filter new points.
;// 
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for Intel Microprocessors with MMX Technology
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cxm12242 -- This function performs zoom-by-2 YUV12-to-RGB24 color conversion
;             for H26x.  It is tuned for best performance on Intel
;             Microprocessors with MMX Technology.  It handles the format in
;             which B is the low order field, then G, then R.  This version
;             adds new rows and columns by averaging them with the originals
;             to either side.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be QWORD aligned.  Pitch and Width must
;             be a multiple of eight.  Height may be any amount, but must be
;             a multiple of two.  The U and V planes may have a different
;             pitch than the Y plane, subject to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCCDATA SEGMENT PAGE
ALIGN 16

Luma0040002000200000 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW 0
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00100H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 00000H
 DW 01FFFH
 DW 01FFFH
 DW 03FFFH
ENDM

Luma0020004000000020 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW (CNT*04A7FH)/00200H
 DW 0
 DW (CNT*04A7FH)/00100H
 DW (CNT*04A7FH)/00200H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 01FFFH
 DW 00000H
 DW 03FFFH
 DW 01FFFH
ENDM

UContribToBandG LABEL DWORD
DW -(-128*0C83H)/00040H
DW	08000H
DW -(-127*0C83H)/00040H
DW  08000H
CNT = -126
REPEAT 253
 DW -(CNT*00C83H)/00040H
 DW  (CNT*0408BH)/00040H
 CNT = CNT + 1
ENDM
DW  (127*0C83H)/00040H
DW  07FFFH

VContribToRandG LABEL DWORD
CNT = -128
REPEAT 256
 DW -(CNT*01A04H)/00040H
 DW  (CNT*03312H)/00040H
 CNT = CNT + 1
ENDM


C0001000001000001 DD  001000001H, 000010000H
C0200020002000200 DD  002000200H, 002000200H
C0000000001000000 DD  001000000H, 000000000H
C000000FF00000000 DD  000000000H, 0000000FFH
C0000010000010000 DD  000010000H, 000000100H

MMXCCDATA ENDS

.CODE

ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

PUBLIC MMX_YUV12ToRGB24ZoomBy2

MMX_YUV12ToRGB24ZoomBy2 proc DIST LANG AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

MAXWIDTH = 768
LocalFrameSize = MAXWIDTH*20+64
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType                    = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+  0]
CCOPitch                 EQU  [esp+  4]
YCursor                  EQU  [esp+  8]
YLimit                   EQU  [esp+ 12]
YPitch                   EQU  [esp+ 16]
UCursor                  EQU  [esp+ 20]
DistanceFromUToV         EQU  [esp+ 24]
ChromaPitch              EQU  [esp+ 28]
AspectCount              EQU  [esp+ 32]
AspectAdjustmentCount    EQU  [esp+ 36]
StartIndexOfYLine        EQU  [esp+ 40]
StashESP                 EQU  [esp+ 44]

FiltLine0                EQU  [esp+ 64]  ; Must be 32 byte aligned.
FiltLine1                EQU  [esp+ 72]
FiltLine2                EQU  [esp+ 80]
FiltLine3                EQU  [esp+ 88]
HFiltLinePrev            EQU  [esp+ 96]

  push       esi
  push       edi
  push       ebp
  push       ebx

  mov        edi,esp
  and        esp,0FFFFF000H
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,LocalFrameSize-12288
  mov        eax,[esp]

  mov        eax,768
  sub        eax,[edi+FrameWidth_arg]
  imul       eax,20
  mov        StartIndexOfYLine,eax

  mov        eax,[edi+YPlane_arg]
  mov        YCursor,eax

  mov        ebx,[edi+YPitch_arg]
  mov        YPitch,ebx
  mov        ecx,[edi+FrameHeight]
  imul       ebx,ecx
  add        eax,ebx
  mov        YLimit,eax

  mov        eax,[edi+UPlane_arg]
  mov        ebx,[edi+VPlane_arg]
  mov        UCursor,eax
  sub        ebx,eax
  mov        DistanceFromUToV,ebx

  mov        eax,[edi+ColorConvertedFrame]
  add        eax,[edi+DCIOffset]
  add        eax,[edi+CCOffsetToLine0]
  mov        CCOCursor,eax

  mov        eax,[edi+ChromaPitch_arg]
  mov        ChromaPitch,eax

  mov        eax,[edi+CCOPitch_arg]
  mov        CCOPitch,eax

  mov        eax,[edi+AspectAdjustmentCount_arg]
  mov        AspectAdjustmentCount,eax
  mov        AspectCount,eax

  mov        StashESP,edi

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   xor       eax,eax
  lea        edx,[esi+ebp*2]
   xor       ebx,ebx
  mov        YCursor,edx
   mov       bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).

  movq       mm1,Luma0020004000000020[ebx*8]  ; L1:< 32a 64a     0       32a >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000000020[eax*8]  ; L0:< 32A 64A     0       32A >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOfFirst2LumaLines:

  movq       mm3,Luma0020004000000020[ebx*8]  ; L1:< 32c 64c     0       32c >
   psrlq     mm1,32                           ; L1:< 0   0       32a     64a >
  movq       mm2,Luma0020004000000020[eax*8]  ; L0:< 32C 64C     0       32C >
   punpckldq mm1,mm3                          ; L1:< 0   32c     32a     64a >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   psrlq     mm0,32                           ; L0:< 0   0       32A     64A >
  mov        al,[esi+1]                       ; Get B.
   add       edi,40                           ; Inc filtered luma temp stg idx.
  paddw      mm1,Luma0040002000200000[ebx*8]  ; L1:< 64b 32b+32c 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 0   32C     32A     64A >
  paddw      mm0,Luma0040002000200000[eax*8]  ; L0:< 64B 32B+32C 32A+32B 64A >

  movq       HFiltLinePrev[edi-40],mm1        ; Save L1 as next iters LPrev.
   paddw     mm1,mm0                          ; L0+L1
  paddw      mm0,mm0                          ; 2L0
   add       esi,2                            ; Increment input index.
  movq       FiltLine3[edi-40],mm1            ; Save filtered line L0+L1.
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi-40],mm0            ; Save filtered line 2L0.
   movq      mm0,mm2                          ; Next iters A.
  mov        bl,[esi+ebp*1+2]                 ; Get c.
   cmp       edi,MAXWIDTH*20-40               ; Done yet.
  mov        al,[esi+2]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  mov        ebp,DistanceFromUToV
   lea       eax,FiltLine2
  mov        esi,UCursor
   mov       edx,StartIndexOfYLine
  jmp        DoOutputLine


Last2OutputLines:

  mov        ebp,DistanceFromUToV
   lea       esi,[edi+40]
  ja         Done

;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  mm0-mm6 -- Scratch.


  movq       mm0,HFiltLinePrev[edi]   ; Fetch horizontally filtered line LP.
  paddw      mm0,mm0                  ; 2LP

Next2PelsOfLast2LumaLines:

  movq       FiltLine3[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       FiltLine2[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       mm0,HFiltLinePrev[edi+40]; Fetch horizontally filtered line LP.
  add        edi,40
   paddw     mm0,mm0                  ; 2LP
  cmp        edi,MAXWIDTH*20          ; Done yet.
   jne       Next2PelsOfLast2LumaLines

  lea        eax,FiltLine2
   mov       edx,StartIndexOfYLine
  mov        esi,UCursor
   jmp       DoOutputLine


Next4OutputLines:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   mov       ecx,YLimit
  lea        edx,[esi+ebp*2]
   xor       eax,eax
  mov        YCursor,edx
   xor       ebx,ebx
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).
   cmp       esi,ecx
  mov        bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
   jae       Last2OutputLines

  movq       mm1,Luma0020004000000020[ebx*8]  ; L1:< 32a 64a     0       32a >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000000020[eax*8]  ; L0:< 32A 64A     0       32A >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOf2LumaLines:

  movq       mm3,Luma0020004000000020[ebx*8]  ; L1:< 32c 64c     0       32c >
   psrlq     mm1,32                           ; L1:< 0   0       32a     64a >
  movq       mm2,Luma0020004000000020[eax*8]  ; L0:< 32C 64C     0       32C >
   punpckldq mm1,mm3                          ; L1:< 0   32c     32a     64a >
  movq       mm4,HFiltLinePrev[edi]           ; LP
   psrlq     mm0,32                           ; L0:< 0   0       32A     64A >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   movq      mm5,mm4                          ; LP
  mov        al,[esi+1]                       ; Get B.
   add       esi,2                            ; Increment input index.
  paddw      mm1,Luma0040002000200000[ebx*8]  ; L1:< 64b 32b+32c 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 0   32C     32A     64A >
  paddw      mm0,Luma0040002000200000[eax*8]  ; L0:< 64B 32B+32C 32A+32B 64A >
   paddw     mm5,mm5                          ; 2LP
  movq       HFiltLinePrev[edi],mm1           ; Save L1 as next iters LPrev.
   paddw     mm4,mm0                          ; LP+L0
  movq       FiltLine0[edi],mm5               ; Save 2LP
   paddw     mm1,mm0                          ; L0+L1
  movq       FiltLine1[edi],mm4               ; Save LP+L0
   paddw     mm0,mm0                          ; 2L0
  movq       FiltLine3[edi],mm1               ; Save L0+L1
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi],mm0               ; Save 2L0
   movq      mm0,mm2                          ; Next iters A.
  add        edi,40                           ; Inc filtered luma temp stg idx.
   mov       bl,[esi+ebp*1+2]                 ; Get c.
  cmp        edi,MAXWIDTH*20-40               ; Done yet.
   mov       al,[esi+2]                       ; Get C.
  jl         Next2PelsOf2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOf2LumaLines

  mov        ebp,DistanceFromUToV
   mov       esi,UCursor
  lea        eax,FiltLine0
   mov       edx,StartIndexOfYLine

DoOutputLine:

  mov        edi,CCOCursor
   mov       ecx,AspectCount
  dec        ecx                    ; If count is non-zero, we keep the line.
   mov       ebx,CCOPitch
  mov        AspectCount,ecx
   je        SkipOutputLine

  add        ebx,edi
   xor       ecx,ecx
  mov        cl,[esi]
   add       eax,MAXWIDTH*20
  movq       mm7,C0001000001000001
   pcmpeqw   mm6,mm6
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gu >
   psllw     mm6,15                        ; Four words of -32768
  mov        cl,[esi+ebp*1]
   sub       edx,MAXWIDTH*20
  pxor       mm3,mm3
   movq      mm5,mm7
  mov        CCOCursor,ebx
   jmp       StartDoOutputLine

; ebp -- Distance from U to V
; esi -- Cursor over U
; edi -- Cursor over output
; edx -- Index over Y storage area
; eax -- Base address of Y line
; mm6 -- Four words of -32768, to clamp at floor.
; mm7 -- <0x0100 0x0000 0x0100 0x0001>

DoNext4OutputPels:

  movdf      [edi-4],mm4                   ; Store <R3 G3 B3 R2>
   movq      mm5,mm7                       ; < 0100 0000 0100 0001 >

StartDoOutputLine:

  movdt      mm2,VContribToRandG[ecx*4]    ; <  0    0   Rv   Gv  >
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >
  movq       mm1,mm0                       ; < junk junk Gu   Gu  >
   punpcklwd mm2,mm2                       ; < Rv   Rv   Gv   Gv  >
  paddw      mm1,mm2                       ; < junk junk Guv  Guv >
   punpckhdq mm0,mm0                       ; < Bu   Bu   Bu   Bu  >
  paddsw     mm0,[eax+edx]                 ; < B2 B3 B1 B0 > w/ ceiling clamped.
   punpckldq mm1,mm1                       ; < Guv  Guv  Guv  Guv >
  paddsw     mm1,[eax+edx]                 ; < G2 G3 G1 G0 > w/ ceiling clamped.
   punpckhdq mm2,mm2                       ; < Rv   Rv   Rv   Rv  >
  paddsw     mm2,[eax+edx]                 ; < R2 R3 R1 R0 > w/ ceiling clamped.
   paddsw    mm0,mm6                       ; B with floor clamped.
  psubsw     mm0,mm6                       ; B back in range.
   paddsw    mm1,mm6                       ; G with floor clamped.
  psubsw     mm1,mm6                       ; G back in range.
   paddsw    mm2,mm6                       ; R with floor clamped.
  psubsw     mm2,mm6                       ; R back in range.
   psrlw     mm0,7                         ; <  0 B2  0 B3  0 B1  0 B0 >
  pmulhw     mm1,C0200020002000200         ; <  0 G2  0 G3  0 G1  0 G0 >
   punpckhwd mm3,mm0                       ; < -- -- -- --  0 B3 -- -- >
  pmaddwd    mm3,C0000000001000000         ; < -- -- -- --  0  0 B3  0 >
   psrlw     mm2,7                         ; <  0 R2  0 R3  0 R1  0 R0 >
  pmullw     mm5,mm2                       ; < -- --  0  0 R1  0  0 R0 >
   punpckhdq mm2,mm2                       ; < -- --  0 R3  0 R2 -- -- >
  pmullw     mm0,mm7                       ; <  0 B2  0  0 B1  0  0 B0 >
   movq      mm4,mm1                       ; < -- -- -- G3 -- -- -- -- >
  pand       mm4,C000000FF00000000         ; < -- --  0 G3  0  0 -- -- >
   pmullw    mm1,mm7                       ; <  0 G2  0  0 G1  0  0 G0 >
  pmullw     mm2,C0000010000010000         ; < -- -- R3  0  0 R2 -- -- >
   psllq     mm5,16                        ; <  0  0 R1  0  0 R0  0  0 >
  xor        ecx,ecx
   por       mm5,mm0                       ; <  0 B2 R1  0 B1 R0  0 B0 >
  mov        cl,[esi+1]                    ; Fetch next U.
   psllq     mm1,8                         ; < G2  0  0 G1  0  0 G0  0 >
  por        mm4,mm2                       ; < -- -- R3 G3  0 R2 -- -- >
   por       mm5,mm1                       ; < G2 B2 R1 G1 B1 R0 G0 B0 >
  inc        esi                           ; Advance input cursor
   psrlq     mm4,16                        ; < -- -- -- -- R3 G3  0 R2 >
  movdf      [edi],mm5                     ; Store < B1 R0 G0 B0 >
   psrlq     mm5,32                        ; < -- -- -- -- G2 B2 R1 G1 >
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gv  > next iter.
   por       mm4,mm3                       ; < -- -- -- -- R3 G3 B3 R2 >
  movdf      [edi+4],mm5                   ; Store < G2 B2 R1 G1 >
   ;
  add        edi,12                        ; Advance output cursor.
   add       edx,40                        ; Increment Y index.
  mov        cl,[esi+ebp*1]                ; Fetch next V.
   jne       DoNext4OutputPels

  movdf      [edi-4],mm4                   ; Store <R3 G3 B3 R2>

PrepareForNextOutputLine:

  mov        edx,StartIndexOfYLine
   add       eax,8-MAXWIDTH*20            ; Advance to next filtered line of Y.
  mov        esi,UCursor
   test      al,8                         ; Jump if just did line 0 or 2.
  mov        ebx,ChromaPitch
   jne       DoOutputLine

  add        esi,ebx                      ; Advance to next chroma line.
   test      al,16                        ; Jump if about to do line 2.
  mov        UCursor,esi
   jne       DoOutputLine

  sub        esi,ebx                      ; Done with 4 lines.  Restore UCursor.
  mov        UCursor,esi
   jmp       Next4OutputLines

SkipOutputLine:
  mov        ecx,AspectAdjustmentCount
   add       eax,MAXWIDTH*20
  mov        AspectCount,ecx
   jmp       PrepareForNextOutputLine

Done:

  mov        esp,StashESP
  pop        ebx
  pop        ebp
  pop        edi
  pop        esi
  rturn

MMX_YUV12ToRGB24ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12241.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;//
;// $Header:   S:\h26x\src\dec\cx512241.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12241.asv  $
;// 
;//    Rev 1.7   28 May 1996 17:57:10   AGUPTA2
;// Cosmetic changes to adhere to common coding convention in all MMX 
;// color convertors plus bug fixes.
;// 
;//
;//    Rev 1.2   26 Mar 1996 11:15:30   RMCKENZX
;//
;// Changed calling sequence to MMX_..., changed parameters to
;// new type (eliminated YUV base, etc.).  put data in MMXDATA1 segment
;// and code in MMXCODE1 segment.  cleaned and commented code.
;//
;//    Rev 1.1   20 Mar 1996 11:19:20   RMCKENZX
;// March 96 version.
;
;     Rev 1.3   18 Feb 1996 20:57:18   israelh
;  new mmx version
;
;     Rev 1.2   29 Jan 1996 19:53:52   mikeh
;
;  added Ifdef timing
;
;     Rev 1.1   29 Jan 1996 16:29:16   mikeh
;  remvoed $LOG stuff
;
;     Rev 1.0   29 Jan 1996 11:49:48   israelh
;  Initial revision.
;//
;//
;// MMX 1.2 26 Jan 1996 IsraelH
;// Optimized code.
;// Adding runtime performane measurments
;//
;// MMX 1.1 23 Dec 1995 IsraelH
;// Using direct calculations with 10.6 precission.
;// Using 8x2 loop to use the same U,V contibutions for both of the lines.
;//
;// MMX 1.0 16 Dec 1995 IsraelH
;// Port to MMX(TM) without using look up tables
;//
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cxm12241 -- This function performs YUV12-to-RGB24 color conversion for H26x.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of 8.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
;constants for direct RGB calculation: 4x10.6 values
;PUBLIC Minusg, VtR, VtG, UtG, UtB, Ymul, Yadd, UVtG, lowrgb, lowrgbn, higp, 
;       highpn, highwn, mzero
Minusg              DWORD   00800080h,  00800080h
VtR                 DWORD   00660066h,  00660066h
VtG                 DWORD   00340034h,  00340034h
UtG                 DWORD   00190019h,  00190019h
UtB                 DWORD   00810081h,  00810081h
Ymul                DWORD   004a004ah,  004a004ah
Yadd                DWORD   10101010h,  10101010h
UVtG                DWORD   00340019h,  00340019h
lowrgb              DWORD   00ffffffh,  00000000h
lowrgbn             DWORD  0ff000000h, 0ffffffffh
highp               DWORD   00000000h, 0ff000000h
highpn              DWORD  0ffffffffh,  00ffffffh
highwn              DWORD  0ffffffffh,  0000ffffh
mzero               DWORD   00000000h,  00000000h
MMXDATA1 ENDS

MMXCODE1 SEGMENT

MMX_YUV12ToRGB24 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

LocalFrameSize           =   128
RegisterStorageSize      =   16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU   argument_base +  4
VPlane                   EQU   argument_base +  8
UPlane                   EQU   argument_base + 12
FrameWidth               EQU   argument_base + 16
FrameHeight              EQU   argument_base + 20
YPitch                   EQU   argument_base + 24
ChromaPitch              EQU   argument_base + 28
AspectAdjustmentCount    EQU   argument_base + 32
ColorConvertedFrame      EQU   argument_base + 36
DCIOffset                EQU   argument_base + 40
CCOffsetToLine0          EQU   argument_base + 44
CCOPitch                 EQU   argument_base + 48
CCType                   EQU   argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
localFrameWidth          EQU   local_base + 0
localYPitch              EQU   local_base + 4
localChromaPitch         EQU   local_base + 8
localAspectAdjustmentCount EQU local_base + 12
localCCOPitch            EQU   local_base + 16
CCOCursor                EQU   local_base + 20
CCOSkipDistance          EQU   local_base + 24
YLimit                   EQU   local_base + 28
DistanceFromVToU         EQU   local_base + 32
currAspectCount          EQU   local_base + 36
YCursorEven              EQU   local_base + 40
YCursorOdd               EQU   local_base + 44
tmpCCOPitch              EQU   local_base + 48
StashESP                 EQU   local_base + 52
; space for two DWORD locals
temp_mmx                 EQU   local_base + 64  ; note it is 64 bytes, align at QWORD

  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32                        ; align at cache line boundary
   mov       [StashESP], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Save some parameters on local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [FrameWidth]
   ;
  mov        [localFrameWidth], ebx
   mov       ebx, [YPitch]
  mov        [localYPitch], ebx
   mov       ebx, [ChromaPitch]
  mov        [localChromaPitch], ebx
   mov       ebx, [AspectAdjustmentCount]
  mov        [localAspectAdjustmentCount], ebx
   mov       ebx, [CCOPitch]
  mov        [localCCOPitch], ebx
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Set-up rest of the local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov       ebx, [VPlane]
  mov        ecx, [UPlane]
   mov       eax, [ColorConvertedFrame]
  sub        ecx, ebx
   mov       edx, [DCIOffset]
  mov        [DistanceFromVToU], ecx         ; UPlane - VPlane
   mov       ecx, [CCOffsetToLine0]
  add        eax, edx                        ; ColorConvertedFrame+DCIOffset
   mov       edx, [FrameHeight]
  add        eax, ecx                        ; ColorConvertedFrame+DCIOffset+CCOffsetToLine0
   mov       ecx, [localYPitch]
  mov        [CCOCursor],eax                 ; ColorConvertedFrame+DCIOffset+CCOffsetToLine0
   mov       ebx, [localFrameWidth]
  mov        eax, [CCOPitch]
   ;
  imul       edx, ecx                        ; FrameHeight*YPitch
   ;
  sub        eax, ebx                         ; CCOPitch-FrameWidth
   mov       esi, [YPlane]                   ; Fetch cursor over luma plane.
  sub        eax, ebx                         ; CCOPitch-2*FrameWidth
   add       edx, esi                         ; YPlane+Size_of_Y_array
  sub        eax, ebx                         ; CCOPitch-3*FrameWidth
   mov       [YLimit], edx                   ; YPlane+Size_of_Y_array
  mov        [CCOSkipDistance], eax          ; CCOPitch-3*FrameWidth
   mov       edx, [localAspectAdjustmentCount]
  mov       esi, [VPlane]
   cmp        edx,1
  je        finish
  mov        [currAspectCount], edx
   mov       eax, [localYPitch]
  mov        edi, [CCOCursor]
   mov       edx, [DistanceFromVToU]
  mov        ebp, [YPlane]                
   mov       ebx, [localFrameWidth]
  add        ebp,ebx
   ;
  mov        [YCursorEven], ebp
   add       ebp,eax
  mov        [YCursorOdd], ebp
   ;
  sar        ebx,1
   ;
  add        esi,ebx
   ;
  add        edx,esi
   neg       ebx
  mov        [localFrameWidth], ebx          ; -FrameWidth/2
   ;

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;
  ;  The following loops do two lines of Y (one line of UV).
  ;  The inner loop (do_next_8x2_block) does 8 pels on the even line and
  ;  the 8 pels immediately below them (sharing the same chroma) on the
  ;  odd line.
  ;
  ;  Core Register Usage:
  ;    eax    output pitch (for odd line writes)
  ;    ebx    cursor within the line.  Starts at -Width, runs up to 0
  ;    ecx        -- unused --
  ;    edx    U plane base address
  ;    ebp    Y plane base address
  ;    esi    V plane base address
  ;    edi    output RGB plane pointer
  ;
  ;  The YUV plane base addresses are previously biased by -Width and are
  ;  used in conjunction with ebx.
  ;
  ;  CAUTION:  Parameters should not be referenced beyond this point.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PrepareChromaLine:
  mov        ebp, [currAspectCount]
   mov       ebx, [localFrameWidth]
  sub        ebp, 2
   mov       eax, [localCCOPitch]
  mov        [tmpCCOPitch], eax
   ja        continue
  xor        eax, eax
   add       ebp, [localAspectAdjustmentCount]
  mov        [tmpCCOPitch], eax

continue:
  mov       [currAspectCount], ebp

do_next_8x2_block:
  mov        ebp, [YCursorEven]
   ;
  movdt      mm1, [edx+ebx]                  ; mm1 = xxxxxxxx U76 U54 U32 U10
   pxor      mm0, mm0                        ; mm0 = 0
  movdt      mm2, [esi+ebx]                  ; mm2 = xxxxxxxx V76 V54 V32 V10
   punpcklbw mm1, mm0                        ; mm1 = .U76 .U54 .U32 .U10
  psubw      mm1, Minusg                     ; unbias U (sub 128)
   punpcklbw mm2, mm0                        ; mm2 = .V76 .V54 .V32 .V10
  psubw      mm2, Minusg                     ; unbias V (sub 128)
   movq      mm3, mm1                        ; mm3 = .U76 .U54 .U32 .U10
                                             ; *** delay cycle for store ***
  movq       [temp_mmx+48], mm1               ; stash .U76 .U54 .U32 .U10
   punpcklwd mm1, mm2                        ; mm1 = .V32 .U32 .V10 .U10
  pmaddwd    mm1, UVtG                       ; mm1 = .....G32 .....G10 (from chroma)
   punpckhwd mm3, mm2                        ; mm3 = .V76 .U76 .V54 .U54
  pmaddwd    mm3, UVtG                       ; mm3 = .....G76 .....G54 (from chroma)
   ;
  movq       [temp_mmx], mm2                 ; stash .V76 .V54 .V32 .V10
   ;
  movq       mm6, [ebp+2*ebx]                ; mm6 = Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   ;
  psubusb    mm6, Yadd                       ; unbias Y (sub 16) & clip at 0
   packssdw  mm1, mm3                        ; mm1 = .G76 .G54 .G32 .G10 (from chroma)
  movq       mm7, mm6                        ; mm7 = Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   punpcklbw mm6, mm0                        ; mm6 = ..Y3 ..Y2 ..Y1 ..Y0
  pmullw     mm6, Ymul                       ; mm6 = ..G3 ..G2 ..G1 ..G0 (from luma)
   punpckhbw mm7, mm0                        ; mm7 = ..Y7 ..Y6 ..Y5 ..Y4
  pmullw     mm7, Ymul                       ; mm7 = ..G7 ..G6 ..G5 ..G4 (from luma)
   movq      mm4, mm1                        ; mm4 = .G76 .G54 .G32 .G10 (from chroma)
  movq       [temp_mmx+8], mm1               ; stash .G76 .G54 .G32 .G10 (from chroma)
   punpcklwd mm1, mm1                        ; mm1 = .G32 .G32 .G10 .G10 (from chroma)
  punpckhwd  mm4, mm4                        ; mm4 = .G76 .G76 .G54 .G54 (from chroma)
   movq      mm0, mm6                        ; mm0 = RGB3 RGB2 RGB1 RGB0 (from luma)
  movq       mm3, mm7                        ; mm3 = RGB7 RGB6 RGB5 RGB4 (from luma)
   psubw     mm6, mm1                        ; mm6 = ..G3 ..G2 ..G1 ..G0 (scaled total)
  movq       mm1, [temp_mmx+48]           ; mm1 = .U76 .U54 .U32 .U10
   psubw     mm7, mm4                        ; mm1 = ..G7 ..G6 ..G5 ..G4 (scaled total)
  psraw      mm6, 6                          ; mm6 = ..G3 ..G2 ..G1 ..G0 (total)
   movq      mm2, mm1                        ; mm2 = .U76 .U54 .U32 .U10
  punpcklwd  mm1, mm1                        ; mm1 = .U32 .U32 .U10 .U10
   ;
  pmullw     mm1, UtB                        ; mm1 = .B32 .B32 .B10 .B10 (from U)
   punpckhwd mm2, mm2                        ; mm2 = .U76 .U76 .U54 .U54
  pmullw     mm2, UtB                        ; mm2 = .B76 .B76 .B54 .B54 (from U)
   psraw     mm7, 6                          ; mm6 = ..G7 ..G6 ..G5 ..G4 (total)
  packuswb   mm6, mm7                        ; mm6: G7 G6 G5 G4 G3 G2 G1 G0
   ;                                         ; -------- green done --------
  movq       [temp_mmx+16], mm1           ; stash .B32 .B32 .B10 .B10 (from U)
   ;
  movq       [temp_mmx+40], mm2           ; stash .B76 .B76 .B54 .B54 (from U)
   paddw     mm1, mm0                        ; mm1 = ..B3 ..B2 ..B1 ..B0 (scaled total)
  paddw      mm2, mm3                        ; mm1 = ..B7 ..B6 ..B5 ..B4 (scaled total)
   psraw     mm1, 6                          ; mm1 = ..B3 ..B2 ..B1 ..B0 (total)
  psraw      mm2, 6                          ; mm1 = ..B7 ..B6 ..B5 ..B4 (total)
   ;
  packuswb   mm1, mm2                        ; mm1: B7 B6 B5 B4 B3 B2 B1 B0
   ;                                         ; -------- blue  done --------
  movq       mm2, [temp_mmx]                 ; mm2 = .V76 .V54 .V32 .V10
   ;
  movq       mm7, mm2                        ; mm7 = .V76 .V54 .V32 .V10
   punpcklwd mm2, mm2                        ; mm2 = .V32 .V32 .V10 .V10
  pmullw     mm2, VtR                        ; mm2 = .R32 .R32 .R10 .R10 (from V)
   punpckhwd mm7, mm7                        ; mm7 = .V76 .V76 .V54 .V54
  pmullw     mm7, VtR                        ; mm7 = .R76 .R76 .R54 .R54 (from V)
   ;
                                             ; *** delay for multiply ***
  movq       [temp_mmx+24], mm2           ; stash .R32 .R32 .R10 .R10 (from V)
   paddw     mm2, mm0                        ; mm2 = ..R3 ..R2 ..R1 ..R0 (total scaled)
  psraw      mm2, 6                          ; mm2 = ..R3 ..R2 ..R1 ..R0 (total)
   ;
  movq       [temp_mmx+32], mm7           ; stash .R76 .R76 .R54 .R54 (from V)
   paddw     mm7, mm3                        ; mm7 = ..R7 ..R6 ..R5 ..R4 (total scaled)
  psraw      mm7, 6                          ; mm7 = ..R7 ..R6 ..R5 ..R4 (total)
   movq      mm5, mm1                        ; mm5 = B7 B6 B5 B4 B3 B2 B1 B0
  packuswb   mm2, mm7                        ; mm2: R7 R6 R5 R4 R3 R2 R1 R0
   ;                                          ; --------  red done  --------
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; shuffle up the results:
  ;   red = mm2
  ; green = mm6
  ;  blue = mm1
  ; into red-green-blue order and store
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  punpcklbw  mm5, mm6                        ; mm5: G3 B3 G2 B2 G1 B1 G0 B0
   movq      mm4, mm2                        ; mm4 = R7 R6 R5 R4 R3 R2 R1 R0
  punpcklbw  mm4, mm4                        ; mm4: R3 R3 R2 R2 R1 R1 R0 R0
   movq      mm3, mm5                        ; mm3 = G3 B3 G2 B2 G1 B1 G0 B0
  punpcklwd  mm5, mm4                        ; mm5: R1 R1 G1 B1 R0 R0 G0 B0
   ;
  movq       mm0, mm5                        ; mm0 = R1 R1 G1 B1 R0 R0 G0 B0
   ;
  pand       mm5, lowrgb                     ; mm5: 0 0 0 0 0 R0 G0 B0
   ;
  pand       mm0, lowrgbn                    ; mm0: R1 R1 G1 B1 R0 0 0 0
   ;
  psrlq      mm0, 8                          ; mm0: 0 R1 R1 G1 B1 R0 0 0
   ;
  por        mm0, mm5                        ; mm0: x x  R1 G1 B1 R0 G0 B0
   ;
  pand       mm0, highwn                     ; mm3: 0 0 R1 G1 B1 R0 G0 B0
   movq      mm5, mm3                        ; mm5 = G3 B3 G2 B2 G1 B1 G0 B0
  punpckhwd  mm5, mm4                        ; mm5: R3 R3 G3 B3 R2 R2 G2 B2
   ;
  movq       mm4, mm5                        ; mm4 = R3 R3 G3 B3 R2 R2 G2 B2
   ;
  psllq      mm4, 48                         ; mm4: G2 B2 0 0 0 0 0 0
   ;
  por        mm0, mm4                        ; mm0: G2 B2 R1 G1 B1 R0 G0 B0
   psrlq     mm5, 24                         ; mm5: 0 0 0 R3 R3 G3 B3 R2

  punpckhbw  mm1, mm6                        ; mm1: G7 B7 G6 B6 G5 B5 G4 B4
   ;
  punpckhbw  mm2, mm2                        ; mm2: R7 R7 R6 R6 R5 R5 R4 R4
   ;
  movq       [edi], mm0                      ; !! aligned
   movq      mm7, mm1                        ; mm7: G7 B7 G6 B6 G5 B5 G4 B4
  punpcklwd  mm1, mm2                        ; mm1: R5 R5 G5 B5 R4 R4 G4 B4
   ;
  movq       mm6, mm1                        ; mm6: R5 R5 G5 B5 R4 R4 G4 B4
   punpckldq mm5, mm1                        ; mm5: R4 R4 G4 B4 R3 G3 B3 R2
  pand       mm5, highpn                     ; mm5: 0 R4 G4 B4 R3 G3 B3 R2
   psllq     mm6, 24                         ; mm6: B5 R4 R4 G4 B4 0 0 0
  pand       mm6, highp                      ; mm6: B5 0 0 0 0 0 0 0
   psrlq     mm1, 40                         ; mm1: 0 0 0 0 0 R5 R5 G5
  mov        ebp, [YCursorOdd]               ; moved to here to save cycles before odd line
   por       mm5, mm6                        ; mm5: B5 R4 G4 B4 R3 G3 B3 R2
  punpckhwd  mm7, mm2                        ; mm7: R7 R7 G7 B7 R6 R6 G6 B6
   ;
  punpcklwd  mm1, mm7                        ; mm1: x x x x G6 B6 R5 G5
   ;
  movq       [edi+8], mm5                    ; !! aligned
   ;
  movdf      [edi+16], mm1                   ; !!!!  aligned
   ;
  ;
  ; start odd line
  ;
  movq       mm1, [ebp+2*ebx]                ; mm1 has 8 y pixels
   psrlq     mm7, 24                         ; belong to even line - for cycles saving
  movdf      [edi+20], mm7                   ; !!!!  aligned
   ;
  psubusb    mm1, Yadd                       ; mm1 has 8 pixels y-16
   ;
  movq       mm5, mm1
   ;
  punpcklbw  mm1, mzero                      ; get 4 low y-16 unsign pixels word
   ;
  punpckhbw  mm5, mzero                      ; 4 high y-16
   ;
  pmullw     mm1, Ymul                       ; low 4 luminance contribution
   ;
  pmullw     mm5, Ymul                       ; high 4 luminance contribution
   movq      mm0, mm1
  paddw      mm0, [temp_mmx+24]           ; low 4 R
   movq      mm6, mm5
  paddw      mm5, [temp_mmx+32]           ; high 4 R
   psraw     mm0, 6
  psraw      mm5, 6
   ;
  movq       mm2, mm1
   packuswb  mm0, mm5                        ; mm0: R7 R6 R5 R4 R3 R2 R1 R0
                                             ; --------  red done  --------
  paddw      mm2, [temp_mmx+16]           ; low 4 B
   movq      mm5, mm6
  paddw      mm5, [temp_mmx+40]           ; high 4 B
   psraw     mm2, 6
  psraw      mm5, 6
   ;
  packuswb   mm2, mm5                        ; mm2: B7 B6 B5 B4 B3 B2 B1 B0
   ;                                         ; -------- blue  done --------

  movq       mm3, [temp_mmx+8]            ; chroma G  low 4
   ;
  movq       mm4, mm3
   punpcklwd mm3, mm3                        ; replicate low 2
  punpckhwd  mm4, mm4                        ; replicate high 2
   psubw     mm1, mm3                        ; 4 low G
  psubw      mm6, mm4                        ; 4 high G values in signed 16 bit
   psraw     mm1, 6                          ; low G
  psraw      mm6, 6                          ; high G
   ;
  packuswb   mm1, mm6                        ; mm1: G7 G6 G5 G4 G3 G2 G1 G0
   ;                                         ; -------- green done --------

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; shuffle up the results:
  ;   red = mm0
  ; green = mm1
  ;  blue = mm2
  ; into red-green-blue order and store
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       mm3, mm2                        ; B
   ;
  punpcklbw  mm3, mm1                        ; mm3: G3 B3 G2 B2 G1 B1 G0 B0
   movq      mm4, mm0                        ;  R
  punpcklbw  mm4, mm4                        ; mm4: R3 R3 R2 R2 R1 R1 R0 R0
   movq      mm5, mm3                        ;  BG
  mov        eax, [tmpCCOPitch]
   punpcklwd mm3, mm4                        ; mm3: R1 R1 G1 B1 R0 R0 G0 B0
  movq       mm6, mm3                        ; save mm3
   ;
  pand       mm6, lowrgb                     ; mm6: 0 0 0 0 0 R0 G0 B0
   ;
  pand       mm3, lowrgbn                    ; mm3: R1 R1 G1 B1 R0 0 0 0
   ;
  psrlq      mm3, 8                          ; mm3: 0 R1 R1 G1 B1 R0 0 0
   ;
  por        mm3, mm6                        ; mm3: x x R1 G1 B1 R0 G0 B0
   ;
  pand       mm3, highwn                     ; mm3: 0 0 R1 G1 B1 R0 G0 B0
   movq      mm6, mm5                        ; BG
  punpckhwd  mm6, mm4                        ; mm6: R3 R3 G3 B3 R2 R2 G2 B2
   ;
  movq       mm4, mm6
   ;
  psllq      mm4, 48                         ; mm4: G2 B2 0 0 0 0 0 0
   ;
  por        mm3, mm4                        ; mm3: G2 B2 R1 G1 B1 R0 G0 B0
   ;
  movq       [edi+eax],  mm3
  psrlq      mm6, 24                         ; mm6: 0 0 0 R3 R3 G3 B3 R2
   punpckhbw mm2, mm1                        ; mm2: G7 B7 G6 B6 G5 B5 G4 B4
  punpckhbw  mm0, mm0                        ; mm0: R7 R7 R6 R6 R5 R5 R4 R4
   movq      mm7, mm2                        ; mm7: G7 B7 G6 B6 G5 B5 G4 B4
  punpcklwd  mm7, mm0                        ; mm7: x  R5 G5 B5 x  R4 G4 B4
   ;
  punpckldq  mm6, mm7                        ; mm6: R4 R4 G4 B4 R3 G3 B3 R2
   movq      mm4, mm7
  psllq      mm4, 24                         ; mm4: B5 R4 R4 G4 B4 0 0 0
   ;
  pand       mm6, highpn                     ; mm6: 0 R4 G4 B4 R3 G3 B3 R2
   psrlq     mm7, 40                         ; mm7: 0 0 0 0 0 R5 R5 G5
  pand       mm4, highp                      ; mm4: B5 0 0 0 0 0 0 0 0
   punpckhwd mm2, mm0                        ; mm2: R7 R7 G7 B7 R6 R6 G6 B6
  por        mm6, mm4                        ; mm6: B5 R4 G4 B4 R3 G3 B3 R2
   punpcklwd mm7, mm2                        ; mm7  x x x x G6 B6 R5 G5
  psrlq      mm2, 24
   ;
  punpckldq  mm7, mm2
   ;
  movq       [edi+eax+8], mm6                ; aligned
   ;
  movq       [edi+eax+16], mm7
   add       edi, 24                         ; ih take 24 instead of 12 output
  add        ebx, 4                          ; ? to take 4 pixels together instead of 2
   jl        do_next_8x2_block               ; ? update the loop for 8 y pixels at once
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Update:
  ;    edi: output RGB plane pointer for odd and even line
  ;    ebp: Y Plane address
  ;    esi: V Plane address
  ;    edx: U Plane address
  ;    YcursorEven: Even Y line address
  ;    YCursorOdd:  Odd Y line address
  ;  Note:  eax, ebx, ecx can be used as scratch registers
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ecx, [CCOSkipDistance]
   mov       eax, [localYPitch]
  add        edi, ecx                        ; go to begin of next even line
   mov       ecx, [tmpCCOPitch]
  add        edi, ecx                        ; skip odd line
   mov       ecx, [localChromaPitch]
  add        esi, ecx
   add       ebp, eax                        ; skip two lines
  mov        [YCursorEven], ebp              ; save even line address
   mov       ecx, [localChromaPitch]
  add        edx, ecx
   add       ebp, eax                        ; odd line address
  mov        [YCursorOdd], ebp               ; save odd line address
   mov       eax, [YLimit]                   ; Done with last line?
  cmp        ebp, eax
   jbe       PrepareChromaLine
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do 2 lines loop
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

finish:
  mov        esp, [StashESP]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToRGB24 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12321.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

; $Header:   S:\h26x\src\dec\cxm12321.asv   1.4   24 May 1996 10:30:20   AGUPTA2  $
; $Log:   S:\h26x\src\dec\cxm12321.asv  $
;// 
;//    Rev 1.4   24 May 1996 10:30:20   AGUPTA2
;// Cosmetic changes to adhere to a common coding convention in all
;// MMX color convertor files.
;// 
;// 
;//    Rev 1.3   11 Apr 1996 09:51:14   RMCKENZX
;// Changed return to pop the stack.
;// 
;//    Rev 1.2   09 Apr 1996 17:15:30   RMCKENZX
;// Optimized.
;// 
;//    Rev 1.1   09 Apr 1996 09:50:32   RMCKENZX
;// Added aspect correction, fixed wrap-around, changed calling sequence.
;// 
;//    Rev 1.0   06 Apr 1996 17:06:06   RMCKENZX
;// Initial revision.
;
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cxm12321 -- This function performs YUV12-to-RGB32 color conversion for H26x.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the third byte is R, and the high order
;             byte is 0.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of 8.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
;
; constants for direct RGB calculation:  4x10.6 values
; chroma constants are multiplied by 64 (6 fraction bits) and 255/224 (scale).
; luma constant is 64 * (255/219) = 74.55055, so it is dithered.
; 
PUBLIC C VtR, VtG, UtG, UtB, Ymul0, Ymul1, Ysub, UVsub
VtR                     DWORD       00660066h,  00660066h  ; 1.402   -> 102.14571
VtG                     DWORD      0ffccffcch, 0ffccffcch  ; -.71414 -> -52.03020
UtG                     DWORD      0ffe7ffe7h, 0ffe7ffe7h  ; -.34414 -> -25.07306
UtB                     DWORD       00810081h,  00810081h  ; 1.772   -> 129.10286
Ymul0                   DWORD       004a004bh,  004a004bh  ;             74.55055
Ymul1                   DWORD       004b004ah,  004b004ah  ;             74.55055
Ysub                    DWORD       00100010h,  00100010h  ; bias for y
UVsub                   DWORD       00800080h,  00800080h  ; bias for uv
MMXDATA1 ENDS

MMXCODE1 SEGMENT

MMX_YUV12ToRGB32 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

LocalSize                 =         20h                   ; for 7 local variables
RegisterSize              =         10h                   ; for the 4 push/pops
StashSize                 =         1200h                 ; 768 (max width) * 6 
LocalFrameSize            =         LocalSize + StashSize
FrameAdjustOne            =         800h
FrameAdjustTwo            =         LocalFrameSize - FrameAdjustOne
argument_base            EQU        ebp + RegisterSize            
local_base               EQU        esp
stash_base               EQU        esp	+ LocalSize

; Arguments:
YPlane                   EQU        argument_base + 04h
VPlane                   EQU        argument_base + 08h
UPlane                   EQU        argument_base + 0ch
FrameWidth               EQU        argument_base + 10h
FrameHeight              EQU        argument_base + 14h
LumaPitch                EQU        argument_base + 18h
ChromaPitch              EQU        argument_base + 1ch
AspectAdjustmentCount    EQU        argument_base + 20h
ColorConvertedFrame      EQU        argument_base + 24h
DCIOffset                EQU        argument_base + 28h
CCOffsetToLine0          EQU        argument_base + 2ch
CCOPitch                 EQU        argument_base + 30h


; Locals (on local stack frame)
localAspectCount         EQU        local_base + 00h
localAspectAdjustment    EQU        local_base + 04h
localWidth               EQU        local_base + 08h
localYPitch              EQU        local_base + 0ch
localUVPitch             EQU        local_base + 10h
localOutPitch            EQU        local_base + 14h
localStashEsp            EQU        local_base + 18h


; symbolic register names for shuffle segments
mmx_zero                 EQU    mm0            ; mmx_zero
											   
  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   and       esp, -32                        ; align to cache-line size
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Initialize: 'x'=live, '-'=dead, 'o'=live(ALU op)
  ;                                            esi eax ebx ecx edx edi ebp
  pxor       mmx_zero, mmx_zero              ;
   sub       esp, FrameAdjustOne             ;
  mov        edi, [CCOPitch]                 ;           			x
   mov       ecx, [ChromaPitch]              ;              x       |
  mov        ebx, [esp]                      ;      |   -   |       |
   sub       esp, FrameAdjustTwo             ;      |       |       |
  mov        eax, [LumaPitch]                ;      x       |       |
   nop
  mov        [localStashEsp], ebp            ;      |       |       |
   mov       [localOutPitch], edi            ;      | 		|	 	-
  mov        [localUVPitch], ecx             ;      |       -        
   mov       [localYPitch], eax              ;      -                
  mov        eax, [AspectAdjustmentCount]    ;	 	x
   mov       edi, [ColorConvertedFrame]      ;      |               x
  mov        [localAspectCount], eax         ;	                    |
   mov       esi, [FrameWidth]               ;  x   |        
  mov        ebx, [DCIOffset]                ;  |   |   x           |
   mov       edx, [CCOffsetToLine0]          ;  |   |   |       x   |
  add        edi, ebx                        ;  |   |   -       |   o
   add       edi, edx                        ;  |   |           -   o
  mov        [localAspectAdjustment], eax    ;	|   -               |
   mov       eax, [YPlane]                   ;  |   x               |
  lea        edi, [edi+4*esi]                ;  |   |               o           RGB plane base
   mov       ecx, [UPlane]                   ;  |   |       x       |     
  mov        edx, [VPlane]                   ;  |   |       |   x   |      
   mov       ebx, [FrameHeight]              ;  |   |   x   |   |   |           Outer loop control
  sar        esi, 1                          ;  o   |   |   |   |   |
   xor       ebp, ebp                        ;  |   |   |   |   |   |   +                         
  add        ecx, esi                        ;  +   |   |   o   |   |   |       U plane base       
   add       edx, esi                        ;  +   |   |   |   o   |   |       V plane base       
  lea        eax, [eax+2*esi]                ;  +   o   |   |   |   |   |       Y plane base             
   sub       ebp, esi                        ;  -   |   |   |   |   |   o       Inner loop control
  mov        [localWidth], ebp               ;  +   |   |   |   |   |   |       
   xor       esi, esi                        ; 	x   |   |   |   |   |   |       Stash pointer
                                             ;  v   v   v   v   v   v   v           
                                             ; esi eax ebx ecx esi edi ebp

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;
  ; ALGORITHM:
  ;  The following outer loop (do_two_lines) does two lines of Y (sharing 
  ;  one line of UV) per iteration.  It contains two inner loops.
  ;
  ;  The first inner loop (do_next_even_line) does 8 pels of the even line 
  ;  per iteration and stashes the chroma contribution on the stack.
  ;
  ;  The second inner loop (do_next_odd_line) reads the stashed chroma and 
  ;  does 8 pels of the odd line per iteration.
  ;
  ;  Aspect Adjustment is accomplished by skipping the second inner loop
  ;  if needed.
  ;
  ; CORE REGISTERS:
  ;  (all registers are pre-loaded):
  ;    eax    Y plane base address.
  ;    ebx    outer loop control.  Starts at Height, runs down to 0.
  ;    ecx    U plane base address.
  ;    edx    V plane base address.
  ;    esi    stash pointer.
  ;    edi    output RGB plane base address.
  ;    ebp    inner loop control.  Starts at -Width/2, runs up to 0.
  ;
  ;  All plane base addresses are previously biased by Width (y plane),
  ;  Width/2 (uv plane), or 4*Width (rgb plane) and are used in conjunction 
  ;  with the inner loop control, ebp.  The base addresses are updated after 
  ;  the first inner loop (Y/U/V/RGB), and after the second inner loop (Y/RGB).
  ;
  ;  The stash pointer is referenced in chromaC (with esp).  It is updated 
  ;  inside each inner loop and reset to 0 after each inner loop.
  ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; start outer loop
  ;    start first inner loop
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
do_two_lines:
do_next_even_line:
  movd       mm3, [ecx+ebp]                  ; ...3....  xxxxxxxx U76 U54 U32 U10
   ;
  movd       mm4, [edx+ebp]                  ; ...34...  xxxxxxxx V76 V54 V32 V10
   punpcklbw mm3, mmx_zero                   ; ...34...  .U76 .U54 .U32 .U10
  psubw      mm3, UVsub                      ; ...34...  unbias U (sub 128)
   punpcklbw mm4, mmx_zero                   ; ...34...  .V76 .V54 .V32 .V10
  psubw      mm4, UVsub                      ; ...34...  unbias V (sub 128)
   movq      mm1, mm3                        ; .1.34...  .U76 .U54 .U32 .U10
  pmullw     mm3, UtG                        ; .1.34...  .G76 .G54 .G32 .G10 (from U)
   movq      mm2, mm4                        ; .1234...  .V76 .V54 .V32 .V10
  pmullw     mm4, VtG                        ; .1234...  .G76 .G54 .G32 .G10 (from V)
   ;
  movq       mm6, [eax+2*ebp]                ; .123..6.  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   ;
  movq       mm7, mm6                        ; .123..67  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   punpcklbw mm6, mmx_zero                   ; .123..67  ..Y3 ..Y2 ..Y1 ..Y0
  psubw      mm6, Ysub                       ; .123..67  unbias Y (sub 16) & clip at 0
   punpckhbw mm7, mmx_zero                   ; .123..67  ..Y7 ..Y6 ..Y5 ..Y4
  psubw      mm7, Ysub                       ; .123..67  unbias Y (sub 16) & clip at 0
   paddsw    mm3, mm4                        ; .123..67  .G76 .G54 .G32 .G10 (from chroma)
  pmullw     mm6, Ymul0                      ; .123..67  RGB3 RGB2 RGB1 RGB0 (from luma) 
   movq      mm5, mm3                        ; .123.567  .G76 .G54 .G32 .G10 (from chroma)
  pmullw     mm7, Ymul0                      ; .123.567  RGB7 RGB6 RGB5 RGB4 (from luma)
   punpcklwd mm3, mm3                        ; .123.567  ..G3 ..G2 ..G1 ..G0 (from chroma)
  pmullw     mm1, UtB                        ; .123.567  .B76 .B54 .B32 .B10 (from U)
   punpckhwd mm5, mm5                        ; .123.567  ..G7 ..G6 ..G5 ..G4 (from chroma)
  movq       [stash_base+esi+00h], mm3       ; .123.567  stash low green from chroma
   paddsw    mm3, mm6                        ; .123.567  ..G3 ..G2 ..G1 ..G0 (scaled total)
  movq       [stash_base+esi+08h], mm5       ; .123.567  stash high green from chroma
   paddsw    mm5, mm7                        ; .123.567  ..G7 ..G6 ..G5 ..G4 (scaled total)
  movq       mm4, mm1                        ; .1234567  .B76 .B54 .B32 .B10 (from U)
   psraw     mm3, 6                          ; .1234567  ..G3 ..G2 ..G1 ..G0 (total)
  pmullw     mm2, VtR                        ; .1234567  .R76 .R54 .R32 .R10 (from V)
   psraw     mm5, 6                          ; .1234567  ..G7 ..G6 ..G5 ..G4 (total)
  packuswb   mm3, mm5                        ; .1234.67  G7 G6 G5 G4 G3 G2 G1 G0
   movq      mm5, mm2                        ; .1234567  .R76 .R54 .R32 .R10 (from V)
                                             ;           -------- green done --------

  punpcklwd  mm1, mm1                        ; .1234567  ..B3 ..B2 ..B1 ..B0 (from U)
   ;
  punpckhwd  mm4, mm4                        ; .1234567  ..B7 ..B6 ..B5 ..B4 (from U)
   ;
  movq       [stash_base+esi+10h], mm1       ; .1234567  stash low blue from chroma
   punpcklwd mm2, mm2                        ; .1234567  ..R3 ..R2 ..R1 ..R0 (from V)
  movq       [stash_base+esi+18h], mm4       ; .1234567  stash high blue from chroma
   punpckhwd mm5, mm5                        ; .1234567  ..R7 ..R6 ..R5 ..R4 (from V)
  paddsw     mm1, mm6                        ; .1234567  ..B3 ..B2 ..B1 ..B0 (scaled total)
   paddsw    mm4, mm7                        ; .1234567  ..B7 ..B6 ..B5 ..B4 (scaled total)
  movq       [stash_base+esi+20h], mm2       ; .1234567  stash low red from chroma
   psraw     mm1, 6                          ; .1234567  ..B3 ..B2 ..B1 ..B0 (total)
  movq       [stash_base+esi+28h], mm5       ; .1234567  stash high red from chroma
   psraw     mm4, 6                          ; .1234567  ..B7 ..B6 ..B5 ..B4 (total)
  paddsw     mm2, mm6                        ; .12345.7  ..R3 ..R2 ..R1 ..R0 (total scaled)
   packuswb  mm1, mm4                        ; .123.5.7  B7 B6 B5 B4 B3 B2 B1 B0
                                             ;           -------- blue  done --------
  paddsw     mm5, mm7                        ; .123.5..  ..R7 ..R6 ..R5 ..R4 (total scaled)
   psraw     mm2, 6                          ; .123.5..  ..R3 ..R2 ..R1 ..R0 (total)
  psraw      mm5, 6                          ; .123.5..  ..R7 ..R6 ..R5 ..R4 (total)
   ;
  packuswb   mm2, mm5                        ; .123....  R7 R6 R5 R4 R3 R2 R1 R0
   ;                                         ;           --------  red done  --------
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; shuffle up the results:
  ;   red = mm2
  ; green = mm4
  ;  blue = mm1
  ; into red-green-blue order and store
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       mm5, mm1                        ; .123.5..  blue copy
   punpcklbw mm1, mm3                        ; .123.5..  G3 B3 G2 B2 G1 B1 G0 B0
  movq       mm4, mm2                        ; .12345..  red copy
   punpcklbw mm2, mmx_zero                   ; .12345..  -- R3 -- R2 -- R1 -- R0
  movq       mm6, mm1                        ; .123456.  G3 B3 G2 B2 G1 B1 G0 B0
   punpcklwd mm1, mm2                        ; .123456.  R1 G1 B1 -- R0 G0 B0
  punpckhwd  mm6, mm2                        ; .1.3456.  -- R3 G3 B3 -- R2 G2 B2
   ;
  movq       [edi+8*ebp+00], mm1             ; ...3456.  write first two pels
   punpckhbw mm5, mm3                        ; ....456.  G7 B7 G6 B6 G5 B5 G4 B4
  movq       [edi+8*ebp+08], mm6             ; ....45..  write second two pels
   punpckhbw mm4, mmx_zero                   ; ....45..  -- R7 -- R6 -- R5 -- R4
  movq       mm7, mm5                        ; ....45.7  G7 B7 G6 B6 G5 B5 G4 B4
   punpcklwd mm5, mm4                        ; ....45.7  -- R5 G5 B5 -- R4 G4 B4
  punpckhwd  mm7, mm4                        ; .....5.7  -- R7 G7 B7 -- R6 G6 B6
   add       esi, 30h                        ; increment stash pointer
  movq       [edi+8*ebp+16], mm5             ; .......7  write third two pels
   ;
  movq       [edi+8*ebp+24], mm7             ; ........  write fourth two pels
   ;
  add        ebp, 4                          ; increment loop control
   jl        do_next_even_line               ; back up if not done
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do next even line loop 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; add pitches to base plane addresses and check aspect
  mov        ebp, [localOutPitch]
   mov       esi, [localUVPitch]
  add        edi, ebp                        ; update RGB plane base address
   add       edx, esi                        ; update V plane base address
  add        ecx, esi                        ; update U plane base address
   mov       esi, [localYPitch]
  add        eax, esi                        ; update Y plane base address
   mov       ebp, [localAspectCount]
  sub        ebp, 2
   jle       skip_odd_line
  mov        [localAspectCount], ebp         ; store aspect count
   mov       ebp, [localWidth]               ; load inner loop control
  xor        esi, esi                        ; reset stash pointer
   ;
  movq       mm7, Ymul1                      ; pre-load Y scaling factor to mm7
   ;
  ;
  ; start odd line loop
  ;
do_next_odd_line:
  movq       mm3, [eax+2*ebp]                ; ...3....  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   ;
  movq       mm4, mm3                        ; ...34...  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   punpcklbw mm3, mmx_zero                   ; ...34...  ..Y3 ..Y2 ..Y1 ..Y0
  psubw      mm3, Ysub                       ; ...34...  unbias Y
   punpckhbw mm4, mmx_zero                   ; ...34...  ..Y7 ..Y6 ..Y5 ..Y4
  psubw      mm4, Ysub                       ; ...34...  unbias Y
   pmullw    mm3, mm7                        ; ...34...  RGB3 RGB2 RGB1 RGB0 (from luma)
  movq       mm2, [stash_base+esi+20h]       ; ..234...  ..R3 ..R2 ..R1 ..R0 (from V)
   pmullw    mm4, mm7                        ; ...34...  RGB7 RGB6 RGB5 RGB4 (from luma)
  movq       mm5, [stash_base+esi+28h]       ; ..2345..  ..R7 ..R6 ..R5 ..R4 (from V)
   paddsw    mm2, mm3                        ; ..2345..  ..R3 ..R2 ..R1 ..R0 (scaled total)
  movq       mm1, [stash_base+esi+10h]       ; .12345..  ..B3 ..B2 ..B1 ..B0 (from U)
   paddsw    mm5, mm4                        ; .12345..  ..R7 ..R6 ..R5 ..R4 (scaled total)
  movq       mm6, [stash_base+esi+18h]       ; .123456.  ..B7 ..B6 ..B5 ..B4 (from U)
   psraw     mm2, 6                          ; .123456.  ..R3 ..R2 ..R1 ..R0 (total) 
  paddsw     mm1, mm3                        ; .123456.  ..B3 ..B2 ..B1 ..B0 (scaled total)
   psraw     mm5, 6                          ; .123456.  ..R7 ..R6 ..R5 ..R4 (total)
  paddsw     mm6, mm4                        ; .123456.  ..B7 ..B6 ..B5 ..B4 (scaled total)
   packuswb  mm2, mm5                        ; .1234.6.  R7 R6 R5 R4 R3 R2 R1 R0
                                             ;           --------  red done  --------
  paddsw     mm3, [stash_base+esi+00h]       ; .1234.6.  ..G3 ..G2 ..G1 ..G0 (scaled total)
   psraw     mm1, 6                          ; .1234.6.  ..B3 ..B2 ..B1 ..B0 (total)
  paddsw     mm4, [stash_base+esi+08h]       ; .1234.6.  ..G7 ..G6 ..G5 ..G4 (scaled total)
   psraw     mm6, 6                          ; .1234.6.  ..B7 ..B6 ..B5 ..B4 (total)
  packuswb   mm1, mm6                        ; .1234...  B7 B6 B5 B4 B3 B2 B1 B0
   ;                                         ;           -------- blue  done --------
  psraw      mm3, 6                          ; .1234...  ..G3 ..G2 ..G1 ..G0 (total)
   ;
  psraw      mm4, 6                          ; .1234...  ..G7 ..G6 ..G5 ..G4 (total)
   ;
  packuswb   mm3, mm4                        ; .123....  G7 G6 G5 G4 G3 G2 G1 G0
   ;                                         ;           -------- green done --------
  ;
  ; shuffle up the results:
  ;   red = mm2
  ; green = mm3
  ;  blue = mm1
  ; into red-green-blue order and store
  ;
  movq       mm5, mm1                        ; .123.5..  blue copy
   punpcklbw mm1, mm3                        ; .123.5..  G3 B3 G2 B2 G1 B1 G0 B0
  movq       mm4, mm2                        ; .12345..  red copy
   punpcklbw mm2, mmx_zero                   ; .12345..  -- R3 -- R2 -- R1 -- R0
  movq       mm6, mm1                        ; .123456.  G3 B3 G2 B2 G1 B1 G0 B0
   punpcklwd mm1, mm2                        ; .123456.  R1 G1 B1 -- R0 G0 B0
  punpckhwd  mm6, mm2                        ; .1.3456.  -- R3 G3 B3 -- R2 G2 B2
   ;
  movq       [edi+8*ebp+00], mm1             ; ...3456.  write first two pels
   punpckhbw mm5, mm3                        ; ....456.  G7 B7 G6 B6 G5 B5 G4 B4
  movq       [edi+8*ebp+08], mm6             ; ....45..  write second two pels
   punpckhbw mm4, mmx_zero                   ; ....45..  -- R7 -- R6 -- R5 -- R4
  movq       mm1, mm5                        ; .1..45..  G7 B7 G6 B6 G5 B5 G4 B4
   punpcklwd mm5, mm4                        ; .1..45..  -- R5 G5 B5 -- R4 G4 B4
  punpckhwd  mm1, mm4                        ; .1...5..  -- R7 G7 B7 -- R6 G6 B6
   add       esi, 30h                        ; increment stash pointer
  movq       [edi+8*ebp+16], mm5             ; .1......  write third two pels
   ;
  movq       [edi+8*ebp+24], mm1             ; ........  write fourth two pels
   ;
  add        ebp, 4                          ; increment loop control
   jl        do_next_odd_line                ; back up if not done
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do next odd line loop 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [localYPitch]
   mov       esi, [localOutPitch]
  add        eax, ebp                        ; update Y plane base address
   add       edi, esi                        ; update RGB plane base address
  mov        ebp, [localWidth]               ; load inner loop control
   xor       esi, esi                        ; reset stash pointer
  sub        ebx, 2                          ; decrement outer loop control
   jg        do_two_lines
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do two lines loop 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

finish:
  mov        esp, [localStashEsp]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret        52

skip_odd_line:
  add        eax, esi                        ; update Y plane base address
   mov       esi, [localAspectAdjustment]
  add        ebp, esi                        ; reset aspect adjustment count
   xor       esi, esi                        ; reset stash pointer
  mov        [localAspectCount], ebp         ; store aspect count
   mov       ebp, [localWidth]               ; load inner loop control
  sub        ebx, 2                          ; decrement outer loop control
   jg        do_two_lines                    ; back up if not done
; else go home
  mov        esp, [localStashEsp]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret
MMX_YUV12ToRGB32 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm1282.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;// $Header:   S:\h26x\src\dec\cx51282.asv
;//
;// $Log:   S:\h26x\src\dec\cxm1282.asv  $
;// 
;//    Rev 1.7   14 Jun 1996 16:30:00   AGUPTA2
;// Cosmetic changes to adhere to common coding convention.
;// 
;//    Rev 1.6   13 May 1996 11:03:42   AGUPTA2
;// Final drop from IDC.
;//
;//    Rev 1.3   02 Apr 1996 16:30:54   RMCKENZX
;// Corrected two bugs in set-up.
;//
;//    Rev 1.1   20 Mar 1996 11:19:28   RMCKENZX
;// March 96 version.
;//
;//    Rev 1.2   05 Feb 1996 11:45:02   vladip
;// initial mmx almost optimized version
;//
;//    Rev 1.1   29 Jan 1996 18:53:38   vladip
;//
;// IFDEF TIMING is added
;//
;//    Rev 1.0   29 Jan 1996 17:28:08   vladip
;// Initial revision.
;//
;//    Rev 1.2   03 Nov 1995 14:39:42   BNICKERS
;// Support YUV12 to CLUT8 zoom by 2.
;//
;//    Rev 1.1   26 Oct 1995 09:46:10   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;//
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by two.
; |||||||
; cxm1282  -- This function performs YUV12 to CLUT8 zoom-by-2 color conversion
;             for H26x.  It dithers among 9 chroma points and 26 luma
;             points, mapping the 8 bit luma pels into the 26 luma points by
;             clamping the ends and stepping the luma by 8.
;
;             1. The color convertor is destructive;  the input Y, U, and V
;                planes will be clobbered.  The Y plane MUST be preceded by
;                1544 bytes of space for scratch work.
;             2. U and V planes should be preceded by 4 bytes (for read only)
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list


MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

;------------------------------------------------------------
PQ      equ PD
;------------------------------------------------------------

;=============================================================================
MMXDATA1 SEGMENT
ALIGN 8

EXTRN convert_to_sign   : DWORD              ; Defined in cxm1281.asm
EXTRN V2_U0low_bound    : DWORD
EXTRN V2_U0high_bound   : DWORD
EXTRN U2_V0low_bound    : DWORD
EXTRN U2_V0high_bound   : DWORD
EXTRN U_low_value       : DWORD
EXTRN V_low_value       : DWORD
EXTRN Y0_low            : DWORD
EXTRN Y1_low            : DWORD
EXTRN clean_MSB_mask    : DWORD
EXTRN saturate_to_Y_high: DWORD
EXTRN return_from_Y_high: DWORD

Y0_correct               EQU Y1_low+8
Y1_correct               EQU Y0_low+8
Y2_correct               EQU Y1_low
Y3_correct               EQU Y0_low
U_high_value             EQU U_low_value
V_high_value             EQU V_low_value

MMXDATA1 ENDS

MMXCODE1 SEGMENT

MMX_YUV12ToCLUT8ZoomBy2 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD
LocalFrameSize           = 56
RegisterStorageSize      = 16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU   argument_base +  4
VPlane                   EQU   argument_base +  8
UPlane                   EQU   argument_base + 12
FrameWidth               EQU   argument_base + 16
FrameHeight              EQU   argument_base + 20
YPitch                   EQU   argument_base + 24
ChromaPitch              EQU   argument_base + 28
AspectAdjustmentCount    EQU   argument_base + 32
ColorConvertedFrame      EQU   argument_base + 36
DCIOffset                EQU   argument_base + 40
CCOffsetToLine0          EQU   argument_base + 44
CCOPitch                 EQU   argument_base + 48
CCType                   EQU   argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
localVPlane              EQU   local_base + 0
localFrameWidth          EQU   local_base + 4
localYPitch              EQU   local_base + 8
localChromaPitch         EQU   local_base + 12
localAspectAdjustmentCount EQU local_base + 16
localCCOPitch            EQU   local_base + 20
CCOCursor                EQU   local_base + 24
YLimit                   EQU   local_base + 28
DistanceFromVToU         EQU   local_base + 32
AspectCount              EQU   local_base + 36
CCOLine1                 EQU   local_base + 40
CCOLine2                 EQU   local_base + 44
CCOLine3                 EQU   local_base + 48
StashESP                 EQU   local_base + 52
  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32                        ; align at cache line boundary
   mov       [StashESP], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Save some parameters on local stack frame
  ;  localVPlane
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [VPlane]
   ;
  mov        [localVPlane], ebx
   mov       ebx, [FrameWidth]
  mov        [localFrameWidth], ebx
   mov       ebx, [YPitch]
  mov        [localYPitch], ebx
   mov       ebx, [ChromaPitch]
  mov        [localChromaPitch], ebx
   mov       ebx, [AspectAdjustmentCount]
  mov        [localAspectAdjustmentCount], ebx
   mov       ebx, [CCOPitch]
  mov        [localCCOPitch], ebx
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Set-up rest of the local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [localVPlane]
   mov       ecx, [UPlane]
  sub        ecx, ebx
   mov       eax, [ColorConvertedFrame]
  mov        [DistanceFromVToU], ecx
   ;
  add        eax, [DCIOffset]
   ;
  add        eax, [CCOffsetToLine0]
   ;
  mov        [CCOCursor], eax
   mov       edx, [FrameHeight]
  mov        ecx, [localYPitch]
   ;
  imul       edx, ecx
   ;
  mov        edi, [localCCOPitch]
   mov       esi, [YPlane]                    ; Fetch cursor over luma plane.
  mov        [CCOCursor], eax
   add       edx, esi
  mov        [YLimit], edx
   mov       edx, [localAspectAdjustmentCount]
  mov        [AspectCount], edx
   mov       edi, esi
  mov        ebx, [localFrameWidth]
   mov       eax, [CCOCursor]                ; CCOLine0
  sar        ebx, 1
   sub       ebx, 4                          ; counter starts from maxvalue-4, and in last iteration it equals 0
  mov        ecx, eax
   ;
  add        edi, [localYPitch]              ; edi = odd Y line cursor
   ;
  add        ecx, [localCCOPitch]
   mov       [localFrameWidth], ebx
  mov        [CCOLine1], ecx
   mov       ebx, [localCCOPitch]
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  in each outer loop iteration,  4 lines of output are done.
  ;  in each inner loop iteration block 4x16 of output is done.
  ;  main task of outer loop is to prepare pointers for inner loop
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Arguments should not be referenced beyond this point
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NextFourLines:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  eax : CCOLine0
  ;  ebx : CCOPitch
  ;  ecx : CCOLine1
  ;  edx : available
  ;  esi : Cursor over even Y line
  ;  edi : Cursor over odd Y line
  ;  ebp : available
  ;  prepare output pointers : CCOLine1, CCOLine2, CCOLine3
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [AspectCount]
   ;
  sub        ebp, 2
   jg        continue1                       ; jump if it still>0
  add        ebp, [localAspectAdjustmentCount]
   mov       ecx, eax                        ; Output1 will overwrite Output0 line
  mov        [CCOLine1], ecx
continue1:
  lea        edx, [ecx+ebx]                  ; CCOLine2
   sub       ebp, 2
  mov        [CCOLine2], edx
   jg        continue2                       ; jump if it still>0
  add        ebp, [localAspectAdjustmentCount]
   xor       ebx, ebx                        ; Output3 will overwrite Output2 line
continue2:
  mov        [AspectCount], ebp
   lea       ebp, [edx+ebx]
  mov        [CCOLine3], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Inner loop does 4x16 block of output points (2x8 of input points)
  ;  Register Usage
  ;    eax : cursor over Output
  ;    ebx : counter
  ;    ecx : cursor over Output1,2,3
  ;    edx : Cursor over V line
  ;    esi : Cursor over even Y line
  ;    edi : Cursor over odd Y line
  ;    ebp : Cursor over U line.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [localVPlane]
   mov       ebx, [localFrameWidth]
  mov        edx, ebp
   add       ebp, [DistanceFromVToU]         ; Cursor over U line.
  movdt      mm3, [ebp+ebx]                  ; read 4 U points
   ;
  movdt      mm2, [edx+ebx]                  ; read 4 V points
   punpcklbw mm3, mm3                        ; u3:u3:u2:u2|u1:u1:u0:u0
prepare_next4x8:
  psubb      mm3, convert_to_sign
   punpcklbw mm2, mm2                        ; v3:v3:v2:v2|v1:v1:v0:v0
  psubb      mm2, convert_to_sign
   movq      mm4, mm3
  movdt      mm7, [esi+2*ebx]                ; read even Y line
   punpcklwd mm3, mm3                        ; u1:u1:u1:u1|u0:u0:u0:u0
  mov        ecx, [CCOLine1]
   movq      mm1, mm3
  pcmpgtb    mm3, V2_U0low_bound
   punpcklbw mm7, mm7                        ; y3:y3:y2:y2|y1:y1:y0:y0
  pand       mm3, U_low_value
   movq      mm5, mm7
  psubusb    mm7, Y0_correct
   movq      mm6, mm2
  pcmpgtb    mm1, V2_U0high_bound
   punpcklwd mm2, mm2                        ; v1:v1:v1:v1|v0:v0:v0:v0
  pand       mm1, U_high_value
   psrlq     mm7, 3
  pand       mm7, clean_MSB_mask
   movq      mm0, mm2
  pcmpgtb    mm2, U2_V0low_bound
   ;
  pcmpgtb    mm0, U2_V0high_bound
   paddb     mm3, mm1
  pand       mm2, V_low_value
   pand      mm0, V_high_value
  paddusb    mm7, saturate_to_Y_high
   paddb     mm3, mm2
  psubusb    mm7, return_from_Y_high         ; Y impact on line0
   paddd     mm3, mm0                        ; common U,V impact on line 0
  psubusb    mm5, Y1_correct
   paddb     mm7, mm3                        ; final value of line 0
  movq       mm0, mm3                        ; u31:u21:u11:u01|u30:u20:u10:u00
   psrlq     mm5, 3
  pand       mm5, clean_MSB_mask
   psrld     mm0, 16                         ;    :   :u31:u21|   :   :u30:u20
  paddusb    mm5, saturate_to_Y_high
   pslld     mm3, 16                         ; u11:u01:   :   |u10:u00:   :
  psubusb    mm5, return_from_Y_high         ; Y impact on line0
   por       mm0, mm3                        ; u11:u01:u31:u21|u10:u00:u30:u20
  movdt      mm3, [edi+2*ebx]                ; odd Y line
   paddb     mm5, mm0                        ; final value of line 0
  punpcklbw  mm3, mm3                        ; y3:y3:y2:y2|y1:y1:y0:y0
   movq      mm2, mm0                        ; u11:u01:u31:u21|u10:u00:u30:u20
  movq       [ecx+4*ebx], mm5                ; write Output1 line
   movq      mm1, mm3
  movq       [eax+4*ebx], mm7                ; write Output0 line
   psrlw     mm0, 8                          ; :u11:   :u31|   :u10:   :u30
  psubusb    mm1, Y3_correct
   psllw     mm2, 8                          ; u01:   :u21:   |u00:   :u20:
  psubusb    mm3, Y2_correct
   psrlq     mm1, 3
  pand       mm1, clean_MSB_mask
   por       mm0, mm2                        ; u01:u11:u21:u31|u00:u10:u20:u30
  paddusb    mm1, saturate_to_Y_high
   psrlq     mm3, 3
  psubusb    mm1, return_from_Y_high
   movq      mm5, mm0                        ; u01:u11:u21:u31|u00:u10:u20:u30
  pand       mm3, clean_MSB_mask
   paddb     mm1, mm0
  paddusb    mm3, saturate_to_Y_high
   psrld     mm5, 16
  psubusb    mm3, return_from_Y_high
   pslld     mm0, 16
  mov        ecx, [CCOLine3]
   por       mm5, mm0                        ; u21:u31:u01:u11|u20:u30:u00:u10
  movdt      mm2, [esi+2*ebx+4]              ; read next even Y line
   paddb     mm5, mm3
  movq       [ecx+4*ebx], mm1                ; write Output3 line
   punpckhwd mm4, mm4                        ; u3:u3:u3:u3|u2:u2:u2:u2
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  start next 4x8 block of output
  ;  SECOND uv-QWORD
  ;  mm6, mm4 are live
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ecx, [CCOLine2]
   movq      mm3, mm4
  pcmpgtb    mm4, V2_U0low_bound
   punpckhwd mm6,mm6
  movq       [ecx+4*ebx], mm5                ; write Output2 line
   movq      mm7, mm6
  pand       mm4, U_low_value
   punpcklbw mm2, mm2                        ; y3:y3:y2:y2|y1:y1:y0:y0
  pcmpgtb    mm3, V2_U0high_bound
   movq      mm5, mm2
  pand       mm3, U_high_value
   ;
  pcmpgtb    mm6, U2_V0low_bound
   paddb     mm4, mm3
  pand       mm6, V_low_value
   ;
  pcmpgtb    mm7, U2_V0high_bound
   paddb     mm4, mm6
  pand       mm7, V_high_value
   ;
  psubusb    mm2, Y0_correct
   paddd     mm4, mm7
  psubusb    mm5, Y1_correct
   psrlq     mm2, 3
  pand       mm2, clean_MSB_mask
   movq      mm3, mm4                        ; u31:u21:u11:u01|u30:u20:u10:u00
  paddusb    mm2, saturate_to_Y_high
   pslld     mm3, 16                         ; u11:u01:   :   |u10:u00:   :
  psubusb    mm2, return_from_Y_high
   psrlq     mm5, 3
  pand       mm5, clean_MSB_mask
   paddb     mm2, mm4                        ; MM4=u31:u21:u11:u01|u30:u20:u10:u00, WHERE U STANDS FOR UNATED U AND V IMPACTS
  paddusb    mm5, saturate_to_Y_high
   psrld     mm4, 16                         ;    :   :u31:u21|   :   :u30:u20
  psubusb    mm5, return_from_Y_high
   por       mm4, mm3                        ; u11:u01:u31:u21|u10:u00:u30:u20
  paddb      mm5, mm4
   mov       ecx, [CCOLine1]
  movdt      mm0, [edi+2*ebx+4]              ; read odd Y line
   movq      mm7, mm4                        ; u11:u01:u31:u21|u10:u00:u30:u20
  movq       [ecx+4*ebx+8], mm5              ; write Output1 line
   punpcklbw mm0, mm0                        ; y3:y3:y2:y2|y1:y1:y0:y0
  movq       [eax+4*ebx+8], mm2              ; write Output0 line
   movq      mm1, mm0
  psubusb    mm1, Y2_correct
   psrlw     mm4, 8                          ;    :u11:   :u31|   :u10:   :u30
  psubusb    mm0, Y3_correct
   psrlq     mm1, 3
  pand       mm1, clean_MSB_mask
   psllw     mm7, 8                          ; u01:   :u21:   |u00:   :u20:
  paddusb    mm1, saturate_to_Y_high
   por       mm4, mm7                        ; u01:u11:u21:u31|u00:u10:u20:u30
  psubusb    mm1, return_from_Y_high
   psrlq     mm0, 3
  pand       mm0, clean_MSB_mask
   movq      mm5, mm4                        ; u01:u11:u21:u31|u00:u10:u20:u30
  paddusb    mm0, saturate_to_Y_high
   psrld     mm5, 16
  psubusb    mm0, return_from_Y_high
   ;
  paddb      mm0, mm4
   mov       ecx, [CCOLine3]
  movdt      mm3, [ebp+ebx-4]                ; read next 4 U points
   pslld     mm4, 16
  movq       [ecx+4*ebx+8], mm0              ; write Output3 line
   por       mm5, mm4                        ; u21:u31:u01:u11|u20:u30:u00:u10
  paddb      mm5, mm1
   mov       ecx, [CCOLine2]
  movdt      mm2, [edx+ebx-4]                ; read next 4 V points
   punpcklbw mm3, mm3                        ; u3:u3:u2:u2|u1:u1:u0:u0
  movq       [ecx+4*ebx+8], mm5              ; write Output2 line
   ;
  sub        ebx, 4
   jae       prepare_next4x8
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  ebp must point to arguments
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [localCCOPitch]
   mov       ecx, [CCOLine3]
  mov        ebp, [localYPitch]
   mov       edx, [localVPlane]
  lea        eax, [ecx+ebx]                  ; next Output0 = old Output3 + CCOPitch
   lea       ecx, [ecx+2*ebx]                ; next Output1 = old Output3 + 2* CCOPitch
  add        edx, [localChromaPitch]
   mov       [CCOLine1], ecx
  lea        esi, [esi+2*ebp]                ; even Y line cursor goes to next line
   lea       edi, [edi+2*ebp]                ; odd  Y line cursor goes to next line
  mov        [localVPlane], edx              ; edx will point to V plane
   cmp       esi, [YLimit]
  jb         NextFourLines
done:
  mov        esp, [StashESP]

  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToCLUT8ZoomBy2 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12322.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cxm12322.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12322.asv  $
;// 
;//    Rev 1.6   01 Apr 1997 12:53:20   BNICKERS
;// Fix bugs # 153 and 156 -- wrong color when U is small;  right edge flickeri
;// 
;//    Rev 1.5   11 Mar 1997 13:50:24   JMCVEIGH
;// Same ARC bug fix (#94) as was done in cxm12162.asm. Without
;// this, zoom by 2 and ARC causes black lines in output (every 12th).
;// 
;//    Rev 1.4   06 Sep 1996 16:08:16   BNICKERS
;// Re-written to filter new points.
;// 
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for Intel Microprocessors with MMX Technology
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by two.
; ||||||||
; cxm12322 -- This function performs zoom-by-2 YUV12-to-RGB32 color conversion
;             for H26x.  It is tuned for best performance on Intel
;             Microprocessors with MMX Technology.  This version adds new rows
;             and columns by averaging them with the originals to either side.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be QWORD aligned.  Pitch and Width must
;             be a multiple of eight.  Height may be any amount, but must be
;             a multiple of two.  The U and V planes may have a different
;             pitch than the Y plane, subject to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include ccinst.inc

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCCDATA SEGMENT PAGE
ALIGN 16

Luma0020004000200000 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW 0
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00100H
 DW (CNT*04A7FH)/00200H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 00000H
 DW 01FFFH
 DW 03FFFH
 DW 01FFFH
ENDM

UContribToBandG LABEL DWORD
DW -(-128*0C83H)/00040H
DW	08000H
DW -(-127*0C83H)/00040H
DW  08000H
CNT = -126
REPEAT 253
 DW -(CNT*00C83H)/00040H
 DW  (CNT*0408BH)/00040H
 CNT = CNT + 1
ENDM
DW  (127*0C83H)/00040H
DW  07FFFH

VContribToRandG LABEL DWORD
CNT = -128
REPEAT 256
 DW -(CNT*01A04H)/00040H
 DW  (CNT*03312H)/00040H
 CNT = CNT + 1
ENDM

CFF00FF00FF00FF00 DD 0FF00FF00H, 0FF00FF00H

MMXCCDATA ENDS

.CODE

ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

PUBLIC MMX_YUV12ToRGB32ZoomBy2

MMX_YUV12ToRGB32ZoomBy2 proc DIST LANG AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

MAXWIDTH = 768
LocalFrameSize = MAXWIDTH*20+64
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType                    = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+  0]
CCOPitch                 EQU  [esp+  4]
YCursor                  EQU  [esp+  8]

YLimit                   EQU  [esp+ 12]
YPitch                   EQU  [esp+ 16]
UCursor                  EQU  [esp+ 20]
DistanceFromUToV         EQU  [esp+ 24]
ChromaPitch              EQU  [esp+ 28]
AspectCount              EQU  [esp+ 32]
AspectAdjustmentCount    EQU  [esp+ 36]
StartIndexOfYLine        EQU  [esp+ 40]
StashESP                 EQU  [esp+ 44]

FiltLine0                EQU  [esp+ 64]  ; Must be 32 byte aligned.
FiltLine1                EQU  [esp+ 72]
FiltLine2                EQU  [esp+ 80]
FiltLine3                EQU  [esp+ 88]
HFiltLinePrev            EQU  [esp+ 96]

  push       esi
  push       edi
  push       ebp
  push       ebx

  mov        edi,esp
  and        esp,0FFFFF000H
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,LocalFrameSize-12288
  mov        eax,[esp]

  mov        eax,768
  sub        eax,[edi+FrameWidth_arg]
  imul       eax,20
  mov        StartIndexOfYLine,eax

  mov        eax,[edi+YPlane_arg]
  mov        YCursor,eax

  mov        ebx,[edi+YPitch_arg]
  mov        YPitch,ebx
  mov        ecx,[edi+FrameHeight]
  imul       ebx,ecx
  add        eax,ebx
  mov        YLimit,eax

  mov        eax,[edi+UPlane_arg]
  mov        ebx,[edi+VPlane_arg]
  mov        UCursor,eax
  sub        ebx,eax
  mov        DistanceFromUToV,ebx

  mov        eax,[edi+ColorConvertedFrame]
  add        eax,[edi+DCIOffset]
  add        eax,[edi+CCOffsetToLine0]
  mov        CCOCursor,eax

  mov        eax,[edi+ChromaPitch_arg]
  mov        ChromaPitch,eax

  mov        eax,[edi+CCOPitch_arg]
  mov        CCOPitch,eax

  mov        eax,[edi+AspectAdjustmentCount_arg]
  mov        AspectAdjustmentCount,eax
  mov        AspectCount,eax

  mov        StashESP,edi

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   xor       eax,eax
  lea        edx,[esi+ebp*2]
   xor       ebx,ebx
  mov        YCursor,edx
   mov       bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOfFirst2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  mov        al,[esi+1]                       ; Get B.
   add       edi,40                           ; Inc filtered luma temp stg idx.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >

  movq       HFiltLinePrev[edi-40],mm1        ; Save L1 as next iters LPrev.
   paddw     mm1,mm0                          ; L0+L1
  paddw      mm0,mm0                          ; 2L0
   add       esi,2                            ; Increment input index.
  movq       FiltLine3[edi-40],mm1            ; Save filtered line L0+L1.
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi-40],mm0            ; Save filtered line 2L0.
   movq      mm0,mm2                          ; Next iters A.
  mov        bl,[esi+ebp*1+2]                 ; Get c.
   cmp       edi,MAXWIDTH*20-40               ; Done yet.
  mov        al,[esi+2]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  mov        ebp,DistanceFromUToV
   lea       eax,FiltLine2
  mov        esi,UCursor
   mov       edx,StartIndexOfYLine
  jmp        DoOutputLine


Last2OutputLines:

  mov        ebp,DistanceFromUToV
   lea       esi,[edi+40]
  ja         Done

;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  mm0-mm6 -- Scratch.


  movq       mm0,HFiltLinePrev[edi]   ; Fetch horizontally filtered line LP.
  paddw      mm0,mm0                  ; 2LP

Next2PelsOfLast2LumaLines:

  movq       FiltLine3[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       FiltLine2[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       mm0,HFiltLinePrev[edi+40]; Fetch horizontally filtered line LP.
  add        edi,40
   paddw     mm0,mm0                  ; 2LP
  cmp        edi,MAXWIDTH*20          ; Done yet.
   jne       Next2PelsOfLast2LumaLines

  lea        eax,FiltLine2
   mov       edx,StartIndexOfYLine
  mov        esi,UCursor
   jmp       DoOutputLine


Next4OutputLines:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   mov       ecx,YLimit
  lea        edx,[esi+ebp*2]
   xor       eax,eax
  mov        YCursor,edx
   xor       ebx,ebx
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).
   cmp       esi,ecx
  mov        bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
   jae       Last2OutputLines

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOf2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  movq       mm4,HFiltLinePrev[edi]           ; LP
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   movq      mm5,mm4                          ; LP
  mov        al,[esi+1]                       ; Get B.
   add       esi,2                            ; Increment input index.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >
   paddw     mm5,mm5                          ; 2LP
  movq       HFiltLinePrev[edi],mm1           ; Save L1 as next iters LPrev.
   paddw     mm4,mm0                          ; LP+L0
  movq       FiltLine0[edi],mm5               ; Save 2LP
   paddw     mm1,mm0                          ; L0+L1
  movq       FiltLine1[edi],mm4               ; Save LP+L0
   paddw     mm0,mm0                          ; 2L0
  movq       FiltLine3[edi],mm1               ; Save L0+L1
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi],mm0               ; Save 2L0
   movq      mm0,mm2                          ; Next iters A.
  add        edi,40                           ; Inc filtered luma temp stg idx.
   mov       bl,[esi+ebp*1+2]                 ; Get c.
  cmp        edi,MAXWIDTH*20-40               ; Done yet.
   mov       al,[esi+2]                       ; Get C.
  jl         Next2PelsOf2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOf2LumaLines

  mov        ebp,DistanceFromUToV
   mov       esi,UCursor
  lea        eax,FiltLine0
   mov       edx,StartIndexOfYLine

DoOutputLine:

  mov        edi,CCOCursor
   mov       ecx,AspectCount
  dec        ecx                    ; If count is non-zero, we keep the line.
   mov       ebx,CCOPitch
  mov        AspectCount,ecx
   je        SkipOutputLine

  add        ebx,edi
   xor       ecx,ecx
  mov        cl,[esi]
   add       eax,MAXWIDTH*20
  mov        CCOCursor,ebx
   pcmpeqw   mm6,mm6
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gu >
   psllw     mm6,15                        ; Four words of -32768
  mov        cl,[esi+ebp*1]
   sub       edx,MAXWIDTH*20
  jmp        StartDoOutputLine

; ebp -- Distance from U to V
; esi -- Cursor over U
; edi -- Cursor over output
; edx -- Index over Y storage area
; eax -- Base address of Y line
; mm6 -- Four words of -32768, to clamp at floor.

DoNext4OutputPels:

  movq       [edi-8],mm3                   ; Save 2 output pels.
   movq      mm0,mm4

StartDoOutputLine:

  movdt      mm2,VContribToRandG[ecx*4]    ; <  0    0   Rv   Gv  >
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >
  movq       mm1,mm0                       ; < junk junk Gu   Gu  >
   punpcklwd mm2,mm2                       ; < Rv   Rv   Gv   Gv  >
  paddw      mm1,mm2                       ; < junk junk Guv  Guv >
   punpckhdq mm0,mm0                       ; < Bu   Bu   Bu   Bu  >
  paddsw     mm0,[eax+edx]                 ; < B B B B > with ceiling clamped.
   punpckldq mm1,mm1                       ; < Guv  Guv  Guv  Guv >
  paddsw     mm1,[eax+edx]                 ; < G G G G > with ceiling clamped.
   punpckhdq mm2,mm2                       ; < Rv   Rv   Rv   Rv  >
  paddsw     mm2,[eax+edx]                 ; < R R R R > with ceiling clamped.
   paddsw    mm0,mm6                       ; B with floor clamped.
  psubsw     mm0,mm6                       ; B back in range.
   paddsw    mm1,mm6                       ; G with floor clamped.
  psubsw     mm1,mm6                       ; G back in range.
   paddsw    mm2,mm6                       ; R with floor clamped.
  add        edi,16                        ; Advance output cursor.
   xor       ecx,ecx
  psubsw     mm2,mm6                       ; R back in range.
   psrlw     mm0,7                         ; Position B bits.
  mov        cl,[esi+1]                    ; Fetch next U.
   paddw     mm1,mm1                       ; Position G bits.
  pand       mm1,CFF00FF00FF00FF00         ; Extract G bits.
   psrlw     mm2,7                         ; Position R bits.
  movdt      mm4,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gv  > next iter.
   por       mm1,mm0                       ; <G3 B3 G2 B2 G1 B1 G0 B0>
  movq       mm3,mm1
   punpcklwd mm1,mm2                       ; < 0 R1 G1 B1  0 R0 G0 B0>
  inc        esi                           ; Advance input cursor
   add       edx,40                        ; Increment Y index.
  movq       [edi-16],mm1                  ; Store 2 output pels.
   punpckhwd mm3,mm2                       ; < 0 R3 G3 B3  0 R2 G2 B2>
  mov        cl,[esi+ebp*1]                ; Fetch next V.
   jne       DoNext4OutputPels

  movq       [edi-8],mm3                   ; Save 2 output pels.

PrepareForNextOutputLine:

  mov        edx,StartIndexOfYLine
   add       eax,8-MAXWIDTH*20                        ; Advance to next filtered line of Y.
  mov        esi,UCursor
   test      al,8                         ; Jump if just did line 0 or 2.
  mov        ebx,ChromaPitch
   jne       DoOutputLine

  add        esi,ebx                      ; Advance to next chroma line.
   test      al,16                        ; Jump if about to do line 2.
  mov        UCursor,esi
   jne       DoOutputLine

  sub        esi,ebx                      ; Done with 4 lines.  Restore UCursor.
  mov        UCursor,esi
   jmp       Next4OutputLines

SkipOutputLine:
  mov        ecx,AspectAdjustmentCount
   add       eax,MAXWIDTH*20
  mov        AspectCount,ecx
   jmp       PrepareForNextOutputLine

Done:

  mov        esp,StashESP
  pop        ebx
  pop        ebp
  pop        edi
  pop        esi
  rturn

MMX_YUV12ToRGB32ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm1281.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;// $Header:   S:\h26x\src\dec\cx51281.asv
;//
;// $Log:   S:\h26x\src\dec\cxm1281.asv  $
;// 
;//    Rev 1.7   25 Jul 1996 13:47:58   AGUPTA2
;// Fixed blockiness problem; dither matrices were not created properly.
;// 
;//    Rev 1.6   14 Jun 1996 16:28:24   AGUPTA2
;// Cosmetic changes to adhere to common coding convention.
;// 
;//    Rev 1.5   13 May 1996 11:01:34   AGUPTA2
;// Final drop from IDC.
;//
;//    Rev 1.1   20 Mar 1996 11:19:24   RMCKENZX
;// March 96 version.
;//
;//    Rev 1.2   01 Feb 1996 10:45:58   vladip
;// Reduced number of locals, DataSegment changed to PARA
;//
;//    Rev 1.1   29 Jan 1996 18:53:40   vladip
;//
;// IFDEF TIMING is added
;//
;//    Rev 1.0   29 Jan 1996 17:28:06   vladip
;// Initial mmx verision.
;//
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by one, i.e. non-zoom.
; |||||||
; cxm1281  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;             It dithers among 9 chroma points and 26 luma points, mapping the
;             8 bit luma pels into the 26 luma points by clamping the ends and
;             stepping the luma by 8.
;
;                Color convertor is not destructive.
; Requirement:
;                U and V plane SHOULD be followed by 4 bytes (for read only)
;                Y plane SHOULD be followed by 8 bytes (for read only)

OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8

PUBLIC Y0_low
PUBLIC Y1_low
PUBLIC U_low_value
PUBLIC V_low_value
PUBLIC U2_V0high_bound
PUBLIC U2_V0low_bound
PUBLIC V2_U0high_bound
PUBLIC V2_U0low_bound
PUBLIC return_from_Y_high
PUBLIC saturate_to_Y_high
PUBLIC clean_MSB_mask
PUBLIC convert_to_sign

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  U,V,Y impacts are calculated as follows:
;              0    U < 64h
;    U impact  1ah  64h <= U < 84h
;              24h  U >= 84h
;
;              0    V < 64h
;    V impact  4eh  64h <= V < 84h
;              9ch  V >= 84h
;
;              0    Y < 1bh
;    Y impact  Y/8  1bh <= Y < ebh
;              19h  Y >= ebh
;  and the dither pattern is added to the input Y,U,V values and is a
;  4X4 matrix as defined below:
;    U
;      10h  8   18h  0
;      18h  0   10h  8
;      8    10h 0    18h
;      0    18h 8    10h
;    V 
;      8    10h 0    18h
;      0    18h 8    10h
;      10h  8   18h  0
;      18h  0   10h  8
;    Y
;      4    2   6    0
;      6    0   4    2
;      2    4   0    6
;      0    6   2    4
;  Note the following equalities in dither matrices which will explain funny
;  data declarations below:
;    U0=V2
;    U1=V3
;    U2=V0
;    U3=V1
;  More gory details can be found in the color convertor document written 
;  by IDC.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
V2_U0low_bound   DWORD  0f3ebfbe3h, 0f3ebfbe3h   ; 746c7c64746c7c64 - 8080808080808080
U2_V0low_bound   DWORD  0ebf3e3fbh, 0ebf3e3fbh,  ; 6c74647c6c74647c - 8080808080808080
                        0f3ebfbe3h, 0f3ebfbe3h   ; 746c7c64746c7c64 - 8080808080808080

U3_V1low_bound   DWORD  0e3fbebf3h, 0e3fbebf3h   ; 647c6c74647c6c74 - 8080808080808080
V3_U1low_bound   DWORD  0fbe3f3ebh, 0fbe3f3ebh,  ; 7c64746c7c64746c - 8080808080808080
                        0e3fbebf3h, 0e3fbebf3h   ; 647c6c74647c6c74 - 8080808080808080

V2_U0high_bound  DWORD  0130b1b03h, 0130b1b03h   ; 948c9c84948c9c84 - 8080808080808080
U2_V0high_bound  DWORD  00b13031bh, 00b13031bh,  ; 8c94849c8c94849c - 8080808080808080
                        0130b1b03h, 0130b1b03h   ; 948c9c84948c9c84 - 8080808080808080

U3_V1high_bound  DWORD  0031b0b13h, 0031b0b13h   ; 849c8c94849c8c94 - 8080808080808080
V3_U1high_bound  DWORD  01b03130bh, 01b03130bh,  ; 9c84948c9c84948c - 8080808080808080
                        0031b0b13h, 0031b0b13h   ; 849c8c94849c8c94 - 8080808080808080


U_low_value      DWORD  01a1a1a1ah, 01a1a1a1ah
V_low_value      DWORD  04e4e4e4eh, 04e4e4e4eh
convert_to_sign  DWORD  080808080h, 080808080h


; Y0_low,Y1_low are arrays
Y0_low           DWORD  01719151bh, 01719151bh,  ; 1b1b1b1b1b1b1b1b - 0402060004020600 ; for line%4=0
                        019171b15h, 019171b15h   ; 1b1b1b1b1b1b1b1b - 0204000602040006 ; for line%4=2

Y1_low           DWORD  0151b1719h, 0151b1719h,  ; 1b1b1b1b1b1b1b1b - 0600040206000402 ; for line%4=1
                        01b151917h, 01b151917h   ; 1b1b1b1b1b1b1b1b - 0006020400060204 ; for line%4=3

clean_MSB_mask      DWORD  01f1f1f1fh, 01f1f1f1fh
saturate_to_Y_high  DWORD  0e6e6e6e6h, 0e6e6e6e6h   ; ffh-19h
return_from_Y_high  DWORD  0dcdcdcdch, 0dcdcdcdch   ; ffh-19h-ah (return back and ADD ah);

MMXDATA1 ENDS

MMXCODE1 SEGMENT
MMX_YUV12ToCLUT8 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD
LocalFrameSize           =   108
RegisterStorageSize      =   16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU   argument_base +  4
VPlane                   EQU   argument_base +  8
UPlane                   EQU   argument_base + 12
FrameWidth               EQU   argument_base + 16
FrameHeight              EQU   argument_base + 20
YPitch                   EQU   argument_base + 24
ChromaPitch              EQU   argument_base + 28
AspectAdjustmentCount    EQU   argument_base + 32
ColorConvertedFrame      EQU   argument_base + 36
DCIOffset                EQU   argument_base + 40
CCOffsetToLine0          EQU   argument_base + 44
CCOPitch                 EQU   argument_base + 48
CCType                   EQU   argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tmpV2_U0low_bound        EQU   local_base + 0       ; qword
tmpU2_V0low_bound        EQU   local_base + 8       ; qword
tmpU3_V1low_bound        EQU   local_base + 16      ; qword
tmpV3_U1low_bound        EQU   local_base + 24      ; qword
tmpV2_U0high_bound       EQU   local_base + 32      ; qword
tmpU2_V0high_bound       EQU   local_base + 40      ; qword
tmpU3_V1high_bound       EQU   local_base + 48      ; qword
tmpV3_U1high_bound       EQU   local_base + 56      ; qword
tmpY0_low                EQU   local_base + 64      ; qword
tmpY1_low                EQU   local_base + 72      ; qword
tmpBlockParity           EQU   local_base + 80
YLimit                   EQU   local_base + 84
AspectCount              EQU   local_base + 88
tmpYCursorEven           EQU   local_base + 92
tmpYCursorOdd            EQU   local_base + 96
tmpCCOPitch              EQU   local_base + 100
StashESP                 EQU   local_base + 104

U_low                    EQU   mm6
V_low                    EQU   mm7
U_high                   EQU   U_low
V_high                   EQU   V_low
		
  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32                        ; align at cache line boundary
   mov       [StashESP], ebp

  mov        ecx, [YPitch]
   mov       edx, [FrameHeight]
  mov        ebx, [FrameWidth]
   ;
  imul       edx, ecx
   ;
  mov        eax, [YPlane]
   add       edx, eax                        ; edx is relative to YPlane
  add        eax, ebx                        ; Points to end of Y even line
   ;
  mov        [tmpYCursorEven], eax
   add       eax, ecx                        ; add YPitch
  mov        [tmpYCursorOdd], eax
   lea       edx, [edx+2*ebx]                ; final value of Y-odd-pointer
  mov        [YLimit], edx
   mov       esi, [VPlane]
  mov        edx, [UPlane]
   mov       eax, [ColorConvertedFrame]
  add        eax, [DCIOffset]
   ;
  add        eax, [CCOffsetToLine0]
   sar       ebx, 1
  add        esi, ebx
   add       edx, ebx
  lea        edi, [eax+2*ebx]                ; CCOCursor
   mov       ecx, [AspectAdjustmentCount]
  mov        [AspectCount], ecx
   test      ecx, ecx                        ; if AspectCount=0 we should not drop any lines
  jnz        non_zero_AspectCount
   dec       ecx
non_zero_AspectCount:
  mov        [AspectCount], ecx
   cmp       ecx, 1
  jbe        finish
   ;
  neg        ebx
   ;
  mov        [FrameWidth], ebx
   ;
  movq       mm6, U_low_value                ; store some frequently used values in registers
   ;
  movq       mm7, V_low_value
   xor       eax, eax
  mov        [tmpBlockParity], eax

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Register Usage:
  ;
  ;  esi -- points to the end of V Line
  ;  edx -- points to the end of U Line.
  ;  edi -- points to the end of even line of output.
  ;  ebp -- points to the end of odd  line of output.
  ;
  ;  ecx -- points to the end of even/odd Y Line
  ;  eax -- 8*(line&2) == 0,  on line%4=0,1
  ;                    == 8,  on line%4=2,3
  ;         in the loop, eax points to the end of even Y line
  ;  ebx -- Number of points, we havn't done yet. (multiplyed by -0.5)
  ;
  ;
  ; Noise matrix is of size 4x4 , so we have different noise values in even 
  ; pair of lines, and in odd pair of lines. But in our loop we are doing 2 
  ; lines. So here we are prepairing constants for next two lines.  This code
  ; is done each time we are starting to convert next pair of lines.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PrepareNext2Lines:
  mov        eax, [tmpBlockParity]
   ;
  ;constants for odd line
  movq       mm0, V3_U1low_bound[eax]
   ;
  movq       mm1, V3_U1high_bound[eax]
   ;
  movq       mm2, U3_V1low_bound[eax]
   ;
  movq       mm3, U3_V1high_bound[eax]
   ;
  movq       [tmpV3_U1low_bound], mm0
   ;
  movq       [tmpV3_U1high_bound], mm1
   ;
  movq       [tmpU3_V1low_bound], mm2
   ;
  movq       [tmpU3_V1high_bound], mm3
   ;
  ;
  ;constants for even line
  ;
  movq       mm0, V2_U0low_bound[eax]
   ;
  movq       mm1, V2_U0high_bound[eax]
   ;
  movq       mm2, U2_V0low_bound[eax]
   ;
  movq       mm3, U2_V0high_bound[eax]
   ;
  movq       [tmpV2_U0low_bound], mm0
   ;
  movq       [tmpV2_U0high_bound], mm1
   ;
  movq       [tmpU2_V0low_bound], mm2
   ;
  movq       [tmpU2_V0high_bound], mm3
   ;
  ;
  ; Constants for Y values
  ;
  movq       mm4, Y0_low[eax]
   ;
  movq       mm5, Y1_low[eax]
   ;
  xor        eax, 8
   mov       [tmpBlockParity], eax
  movq       [tmpY0_low], mm4
   ;
  movq       [tmpY1_low], mm5
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; if AspectCount<2 we should skip a line. In this case we are still doing two
  ; lines, but output pointers are the same, so we just overwriting line 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        eax, [CCOPitch]
   mov       ebx, [AspectCount]
  xor        ecx, ecx
   sub       ebx, 2
  mov        [tmpCCOPitch], eax
   ja        continue
  mov        eax, [AspectAdjustmentCount]
   mov       [tmpCCOPitch], ecx              ; 0
  lea        ebx, [ebx+eax]                  ; calculate new AspectCount
   jnz       continue                        ; skiping even line
  ;
  ;skip_odd_line
  ;
  mov       eax, [tmpYCursorEven]
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; set odd constants to be equal to even_constants
  ; Odd line will be performed as even
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       [tmpV3_U1low_bound], mm0
   ;
  movq       [tmpV3_U1high_bound], mm1
   ;
  movq       [tmpU3_V1low_bound], mm2
   ;
  movq       [tmpU3_V1high_bound], mm3
   ;
  movq       [tmpY1_low], mm4
   ;
  mov        [tmpYCursorOdd], eax
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; when we got here, we already did all preparations.
  ; we are entering a main loop which is starts at do_next_2x8_block label
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
continue:
  mov        [AspectCount], ebx
   mov       ebx, [FrameWidth]
  mov        ebp, edi
   ;
  add        ebp, [tmpCCOPitch]              ; ebp points to the end of odd line
   mov       eax, [tmpYCursorEven]
  mov        ecx, [tmpYCursorOdd]
   ;
  movdt      mm0, [edx+ebx]                  ; 0:0:0:0|u3:u2:u1:u0 unsigned
   ;
  movdt      mm2, [esi+ebx]                  ; 0:0:0:0|v3:v2:v1:v0 unsigned
   punpcklbw mm0, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0 unsigned
  psubb      mm0, convert_to_sign            ; u3:u3:u2:u2|u1:u1:u0:u0 signed
   punpcklbw mm2, mm2                        ; v3:v3:v2:v2|v1:v1:v0:v0 unsigned
  movq       mm4, [eax+2*ebx]                ; y7|..|y0
   ;
  movq       mm1, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0
   ;
do_next_2x8_block:
  psubb      mm2, convert_to_sign            ; v3:v3:v2:v2|v1:v1:v0:v0 signed
   movq      mm5, mm1                        ; u3:u3:u2:u2|u1:u1:u0:u0
  pcmpgtb    mm0, [tmpV2_U0low_bound]
   movq      mm3, mm2
  pcmpgtb    mm1, [tmpV2_U0high_bound]
   pand      mm0, U_low
  psubusb    mm4, [tmpY0_low]
   pand      mm1, U_high
  pcmpgtb    mm2, [tmpU2_V0low_bound]
   psrlq     mm4, 3
  pand       mm4, clean_MSB_mask
   pand      mm2, V_low
  paddusb    mm4, saturate_to_Y_high
   paddb     mm0, mm1                        ; U03:U03:U02:U02|U01:U01:U00:U00
  psubusb    mm4, return_from_Y_high
   movq      mm1, mm5
  pcmpgtb    mm5, [tmpV3_U1low_bound]
   paddd     mm0, mm2
  pcmpgtb    mm1, [tmpV3_U1high_bound]
   pand      mm5, U_low
  paddd      mm0, mm4
   movq      mm2, mm3
  pcmpgtb    mm3, [tmpU2_V0high_bound]
   pand      mm1, U_high
  movq       mm4, [ecx+2*ebx]                ; read next 8 Y points from odd line
   paddb     mm5, mm1                        ; u impact on odd line
  psubusb    mm4, [tmpY1_low]
   movq      mm1, mm2
  pcmpgtb    mm2, [tmpU3_V1low_bound]
   psrlq     mm4, 3
  pand       mm4, clean_MSB_mask
   pand      mm2, V_low
  paddusb    mm4, saturate_to_Y_high
   paddd     mm5, mm2
  psubusb    mm4, return_from_Y_high
   pand      mm3, V_high
  pcmpgtb    mm1, [tmpU3_V1high_bound]
   paddb     mm3, mm0
  movdt      mm0, [edx+ebx+4]                ; read next 4 U points
   pand      mm1, V_high
  movdt      mm2, [esi+ebx+4]                ; read next 4 V points
   paddd     mm5, mm4
  movq       mm4, [eax+2*ebx+8]              ; read next 8 Y points from even line
   paddb     mm5, mm1
  psubb      mm0, convert_to_sign
   punpcklbw mm2, mm2                        ; v3:v3:v2:v2|v1:v1:v0:v0
  movq       [edi+2*ebx], mm3                ; write even line
   punpcklbw mm0, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0
  movq       [ebp+2*ebx], mm5                ; write odd line
   movq      mm1, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0
  add        ebx, 4
   jl        do_next_2x8_block
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; update pointes to input and output buffers, to point to the next lines
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [StashESP]
   mov       eax, [tmpYCursorEven]
  mov        ecx, [YPitch]
   add       edi, [CCOPitch]                 ; go to the end of next line
  add        edi, [tmpCCOPitch]              ; skip odd line
   lea       eax, [eax+2*ecx]
  mov        [tmpYCursorEven], eax
   add       eax, [YPitch]
  mov        [tmpYCursorOdd], eax
   add       esi, [ChromaPitch]
  mov        ecx, [YLimit]                   ; Done with last line?
   add       edx, [ChromaPitch]
  cmp        eax, ecx
   jb        PrepareNext2Lines

finish:
  mov        esp, [StashESP]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToCLUT8 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3madvpr.asm ===
;--------------------------------------------------------------------------;
;
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------;
;
;	$Header:   S:\h26x\src\dec\d3madvpr.asv   1.6   01 Oct 1996 16:45:38   KLILLEVO  $
;	$Log:   S:\h26x\src\dec\d3madvpr.asv  $
;// 
;//    Rev 1.6   01 Oct 1996 16:45:38   KLILLEVO
;// removed unneccessary local variable and added code to verify
;// PITCH is 384 at compile-time
;// 
;//    Rev 1.5   01 Oct 1996 11:57:52   KLILLEVO
;// pairing done, saved about 5*4 = 20 cycles per block = 11880 cycles
;// per QCIF picture
;// 
;//    Rev 1.4   27 Sep 1996 17:28:40   KLILLEVO
;// added clipping of extended motion vectors, but pairing is horrible and
;// needs to be improved
;// 
;//    Rev 1.3   01 Apr 1996 12:35:14   RMCKENZX
;// 
;// Added MMXCODE1 and MMXDATA1 segments, moved global data
;// to MMXDATA1 segment.
;// 
;//    Rev 1.2   07 Mar 1996 18:32:16   RMCKENZX
;// 
;// Re-organized and optimized routine.  Interpolaters now
;// interpolate & weight, driver accumulates and averages.  Interpolaters
;// return results in mm4-mm7.  Eliminated include file.
;// 
;//    Rev 1.0   27 Feb 1996 15:03:42   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;
;
; File:
;	d3madvpr.asm
;
; Routines:
;	MMX_AdvancePredict				Driver
;	MMxInterpolateAndAccumulate		Assembly-called interpolate accumulate
;
;--------------------------------------------------------------------------;

.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

;--------------------------------------------------------------------------;
;
; MMX_AdvancePredict
;
; Description:
;	This routine performs advanced prediction, including overlapped
;	block motion compensation.  It uses the assembly routine 
;	MMxInterpolateAndAccumulate.
;
;	This routine is the assembly equivalent of NewAdvancePredict.
;
; Inputs:			(dwords pushed onto stack by caller)
;	DC				flat pointer to decoder catalog.
;	fpBlockAction	flat pointer to block action stream.
;	iNext			flat pointer to offsets for 4 neighboring blocks.
;						0 = left
;						1 = right
;						2 = above
;						3 = below
;
;
; Register Usage:
;
;
; Notes:
;    
;--------------------------------------------------------------------------;

; register storage
;	ebp						esp+00
;	ebx						esp+04
;	edi						esp+08
;	esi						esp+12

; local variable definitions
	lpBlockAction	EQU		esp+16		; local block action stream pointer
	lNext			EQU		esp+20		; local block action offsets pointer
    lClipX          EQU     esp+24      ; local copy of pointer to x vector clipping table
    lClipY          EQU     esp+28      ; local copy of pointer to y vector clipping table
	lNext			EQU		esp+32		; local offsets (4 DWORDS = 16 bytes)
	lAccum			EQU		esp+64		; accumulator (64 WORDS = 128 bytes)

	zero            EQU     mm0
	lDst			EQU		edi			; local destination pointer

; C input parameters
	fpBlockAction	EQU		ebp+08		; block action stream pointer
	iNext			EQU		esp+12		; block action offsets pointer
	pDst			EQU		ebp+16		; destination pointer
    pClipX          EQU     ebp+20      ; x vector clipping table
    pClipY          EQU     ebp+24      ; y vector clipping table

; MMX globals
;  the weight tables are each 64 WORDS stored in Quadrant ascending order
	WtCt			EQU		gMMX_WeightCenter
	WtLR			EQU		gMMX_WeightLeftRight
	WtAB			EQU		gMMX_WeightAboveBelow
	Round1			EQU		gMMX_Round1
	Round2			EQU		gMMX_Round2
	Round4			EQU		gMMX_Round4

PITCH = 384
FRAMESIZE = 256

; **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT ****
;
;  		ANY CHANGES TO THE BLOCK ACTION STRUCTURE
;  		IN d3dec.h MUST BE ECHOED HERE!!!!
;
; **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT ****

; Offsets into Block Action structure T_BlkAction of length 20
;	see the definition in d3dec.h
i8MVx2				=	1		; I8 = signed byte
i8MVy2				=	2		; I8 = signed byte
pRefBlock			=	8		; U32 = unsigned dword

MMXDATA1 SEGMENT
ALIGN 8
gMMX_WeightCenter LABEL DWORD
WORD 5, 5, 5, 4,  5, 5, 5, 5,  6, 6, 5, 5,  6, 6, 5, 5		; Quadrant I 
WORD 4, 5, 5, 5,  5, 5, 5, 5,  5, 5, 6, 6,  5, 5, 6, 6	 	; Quadrant II
WORD 5, 5, 6, 6,  5, 5, 6, 6,  5, 5, 5, 5,  4, 5, 5, 5	 	; Quadrant III
WORD 6, 6, 5, 5,  6, 6, 5, 5,  5, 5, 5, 5,  5, 5, 5, 4	 	; Quadrant IV

gMMX_WeightLeftRight LABEL DWORD
WORD 1, 1, 1, 2,  1, 1, 2, 2,  1, 1, 2, 2,  1, 1, 2, 2		; Quadrant I 
WORD 2, 1, 1, 1,  2, 2, 1, 1,  2, 2, 1, 1,  2, 2, 1, 1		; Quadrant II 
WORD 2, 2, 1, 1,  2, 2, 1, 1,  2, 2, 1, 1,  2, 1, 1, 1		; Quadrant III 
WORD 1, 1, 2, 2,  1, 1, 2, 2,  1, 1, 2, 2,  1, 1, 1, 2		; Quadrant IV 

gMMX_WeightAboveBelow LABEL DWORD
WORD 2, 2, 2, 2,  2, 2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1		; Quadrant I 
WORD 2, 2, 2, 2,  1, 1, 2, 2,  1, 1, 1, 1,  1, 1, 1, 1		; Quadrant II 
WORD 1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 2, 2,  2, 2, 2, 2		; Quadrant III 
WORD 1, 1, 1, 1,  1, 1, 1, 1,  2, 2, 1, 1,  2, 2, 2, 2		; Quadrant IV 

gMMX_Round1 DWORD 00010001h, 00010001h
gMMX_Round2 DWORD 00020002h, 00020002h
gMMX_Round4 DWORD 00040004h, 00040004h
MMXDATA1 ENDS
;--------------------------------------------------------------------------;


;--------------------------------------------------------------------------;
MMXCODE1 SEGMENT

PUBLIC C MMX_AdvancePredict

IF PITCH-384
   ** error: this code assumes PITCH is 384
ENDIF

;--------------------------------------------------------------------------;
;	Start Code
;--------------------------------------------------------------------------;
MMX_AdvancePredict:
	push	ebp
	mov 	ebp, esp

	mov 	edx, [iNext]
	and 	esp, -32					; align stack on cache boundary

	sub 	esp, FRAMESIZE
	pxor	zero, zero					; zero for unpacking

	push	esi
	push	edi

	push	ebx
	push	ebp

    mov eax, [pClipX]
    mov ebx, [pClipY]

    mov [lClipX], eax
    mov [lClipY], ebx

	mov 	lDst, [pDst]
	mov 	eax, 00[edx]

	mov 	ebp, [fpBlockAction]
	mov 	ebx, 04[edx]

	lea 	eax, [eax+4*eax]
	mov 	ecx, 08[edx]

	lea 	ebx, [ebx+4*ebx]
	mov 	edx, 12[edx]

	lea 	ecx, [ecx+4*ecx]
	mov 	00[lNext], eax

	lea 	edx, [edx+4*edx]
	mov 	04[lNext], ebx

	mov 	08[lNext], ecx
	mov 	12[lNext], edx


;-----------------------------------------------------------------------;
;																		;
;								Center                                  ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtCt + 32]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]

	add esi, edx

	; Quadrant II
	call      MMxInterpolateAndAccumulate

	movq      mm3, [Round4]

	paddw     mm4, mm3
	add       esi, 4

	paddw     mm5, mm3
	sub       ebx, 32

	movq      [lAccum+00], mm4
	paddw     mm6, mm3

	movq      [lAccum+16], mm5
	paddw     mm7, mm3

	movq      [lAccum+32], mm6

	movq      [lAccum+48], mm7


	; Quadrant I
	call	  MMxInterpolateAndAccumulate
 
	movq      mm3, [Round4]

	paddw     mm4, mm3
	add       esi, 4*PITCH-4

	paddw     mm5, mm3
	add       ebx, 64

	movq      [lAccum+08], mm4
	paddw     mm6, mm3

	movq      [lAccum+24], mm5
	paddw     mm7, mm3

	movq      [lAccum+40], mm6

	movq      [lAccum+56], mm7


	; Quadrant III
	call	  MMxInterpolateAndAccumulate

	movq      mm3, [Round4]

	paddw     mm4, mm3
	add       esi, 4

	paddw     mm5, mm3
	add       ebx, 32

	movq      [lAccum+64], mm4
	paddw     mm6, mm3

	movq      [lAccum+80], mm5
	paddw     mm7, mm3

	movq      [lAccum+96], mm6

	movq      [lAccum+112], mm7


	; Quadrant IV
	call	  MMxInterpolateAndAccumulate

	movq      mm3, [Round4]

	paddw     mm4, mm3
	mov       ebx, 00[lNext]

	paddw     mm5, mm3

	movq      [lAccum+72], mm4
	paddw     mm6, mm3

	movq      [lAccum+88], mm5
	paddw     mm7, mm3

	movq      [lAccum+104], mm6

	movq      [lAccum+120], mm7


;-----------------------------------------------------------------------;
;																		;
;								Left                                    ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtLR + 32]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]

	add esi, edx

	; Quadrant II
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+00]

	paddw     mm5, [lAccum+16]

	paddw     mm6, [lAccum+32]

	paddw     mm7, [lAccum+48]

	movq      [lAccum+00], mm4

	movq      [lAccum+16], mm5

	movq      [lAccum+32], mm6

	movq      [lAccum+48], mm7


	; Quadrant III
	add       esi, 4*PITCH
	add       ebx, 32

	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+64]

	paddw     mm5, [lAccum+80]

	paddw     mm6, [lAccum+96]

	paddw     mm7, [lAccum+112]

	movq      [lAccum+64], mm4

	movq      [lAccum+80], mm5

	movq      [lAccum+96], mm6
	mov       ebx, 04[lNext]

	movq      [lAccum+112], mm7


;-----------------------------------------------------------------------;
;																		;
;								Right                                   ;
;																		;
;-----------------------------------------------------------------------;
	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtLR]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]
	add esi, 4

	add esi, edx

	; Quadrant I
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+08]

	paddw     mm5, [lAccum+24]

	paddw     mm6, [lAccum+40]

	paddw     mm7, [lAccum+56]

	movq      [lAccum+08], mm4

	movq      [lAccum+24], mm5

	movq      [lAccum+40], mm6

	movq      [lAccum+56], mm7


	; Quadrant IV
	add       esi, 4*PITCH
	add       ebx, 96

	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+72]

	paddw     mm5, [lAccum+88]

	paddw     mm6, [lAccum+104]

	paddw     mm7, [lAccum+120]

	movq      [lAccum+72], mm4

	movq      [lAccum+88], mm5

	movq      [lAccum+104], mm6
	mov       ebx, 08[lNext]

	movq      [lAccum+120], mm7


;-----------------------------------------------------------------------;
;																		;
;								Above                                   ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtAB]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]
	add esi, 4

	add esi, edx

	; Quadrant I
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+08]

	paddw     mm5, [lAccum+24]
	psraw     mm4, 3

	paddw     mm6, [lAccum+40]
	psraw     mm5, 3

	paddw     mm7, [lAccum+56]
	psraw     mm6, 3

	movq      [lAccum+08], mm4
	psraw     mm7, 3

	movq      [lAccum+24], mm5

	movq      [lAccum+40], mm6

	movq      [lAccum+56], mm7


	; Quadrant II
	sub       esi, 4
	add       ebx, 32
	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+00]

	paddw     mm5, [lAccum+16]

	paddw     mm6, [lAccum+32]
	psraw     mm4, 3

	paddw     mm7, [lAccum+48]
	psraw     mm5, 3

	packuswb  mm4, [lAccum+08]

	packuswb  mm5, [lAccum+24]

	movq      [lDst+00], mm4
	psraw     mm6, 3

	movq      [lDst+PITCH], mm5
	psraw     mm7, 3

	packuswb  mm6, [lAccum+40]

	packuswb  mm7, [lAccum+56]

	movq      [lDst+2*PITCH], mm6
	mov       ebx, 12[lNext]

	movq      [lDst+3*PITCH], mm7


;-----------------------------------------------------------------------;
;																		;
;								Below                                   ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtAB + 96]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]
	add esi, 4*PITCH+4

	add esi, edx

	; Quadrant IV
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+72]

	paddw     mm5, [lAccum+88]
	psraw     mm4, 3

	paddw     mm6, [lAccum+104]
	psraw     mm5, 3

	paddw     mm7, [lAccum+120]
	psraw     mm6, 3

	movq      [lAccum+72], mm4
	psraw     mm7, 3

	movq      [lAccum+88], mm5

	movq      [lAccum+104], mm6

	movq      [lAccum+120], mm7


	; Quadrant III
	sub       esi, 4
	sub       ebx, 32

	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+64]

	paddw     mm5, [lAccum+80]

	paddw     mm6, [lAccum+96]
	psraw     mm4, 3

	paddw     mm7, [lAccum+112]
	psraw     mm5, 3

	packuswb  mm4, [lAccum+72]

	packuswb  mm5, [lAccum+88]

	movq      [lDst+4*PITCH], mm4
	psraw     mm6, 3

	movq      [lDst+5*PITCH], mm5
	psraw     mm7, 3

	packuswb  mm6, [lAccum+104]

	packuswb  mm7, [lAccum+120]

	movq      [lDst+6*PITCH], mm6

	movq      [lDst+7*PITCH], mm7



	pop 	ebp
	pop 	ebx

	pop 	edi
	pop 	esi

	mov 	esp, ebp

	pop 	ebp

	ret


;--------------------------------------------------------------------------;
;
; Routine:
;	MMxInterpolateAndAccumulate
;
; Inputs:
;	esi			flat pointer to Reference Block Source.
;               it is already adjusted by the motion vector.
;	 al			x component of motion vector.
;	 ah			y component of motion vector.
;	ebx			flat pointer to Weighting values.
;
; Outputs
;	mm4-mm7     Weighted, interpolated values for rows 0-3.
;               Values are in packed word format.
;
; Description:
;	This routine performs motion compensation interpolation, weights the
;	results, and returns them in mmx registers 4-7.
;	It works on a single 4x4 Quadrant per call.  It is an assembly
;	callable routine with its parameters in registers.
;
; Register Usage:
;	This routine modifies no integer registers.
;	All MMx registers are modified.
;
; Notes:
;    
;--------------------------------------------------------------------------;

; asm input parameters
	lpSrc		EQU		esi				; motion compensated source pointer
	lpWt		EQU		ebx				; pointer to matrix of weights 4x4xWORD

MMxInterpolateAndAccumulate:
	test      eax, 100h					; test mvy's parity bit
	jnz       IAAhalf					; jump when it was odd

	test      eax, 1					; test mvx's parity bit
	jnz       IAAhalf_int				; jump when it was odd


IAAint_int:
	movd      mm4, [lpSrc]		; 1 - fetch row
										
	movd      mm5, [PITCH+lpSrc]		; 2 - fetch row  
	punpcklbw mm4, zero					; 1 - unpack row

	pmullw    mm4, 00[lpWt]				; 1 - multiply by weights

	movq      mm6, [PITCH*2+lpSrc]		; 3 - fetch row
	punpcklbw mm5, zero					; 2 - unpack row

	pmullw    mm5, 08[lpWt]				; 2 - multiply by weights
	punpcklbw mm6, zero					; 3 - unpack row

	movq      mm7, [PITCH*3+lpSrc]		; 4 - fetch row

	pmullw    mm6, 16[lpWt]				; 3 - multiply by weights
	punpcklbw mm7, zero					; 4 - unpack row

	pmullw    mm7, 24[lpWt]				; 4 - multiply by weights

	ret


IAAhalf_int:
	movq      mm4, [lpSrc]		; 0 - fetch row

	movq      mm1, mm4					; 0 - copy row
	psrlq     mm4, 8					; 0 - shift row

	movq      mm5, [PITCH+lpSrc]		; 1 - fetch row
	punpcklbw mm4, zero					; 0 - unpack shifted row

	movq      mm6, [PITCH*2+lpSrc]		; 2 - fetch row
	punpcklbw mm1, zero					; 0 - unpack row

	movq      mm2, mm5					; 1 - copy row
	psrlq     mm5, 8					; 1 - shift row

	paddw     mm4, [Round1]				; 0 - add in Round
	punpcklbw mm5, zero					; 1 - unpack shifted row

	paddw     mm4, mm1					; 0 - sum copies of row
 	punpcklbw mm2, zero					; 1 - unpack row

	movq      mm3, mm6					; 2 - copy row
	psrlq     mm6, 8					; 2 - shift row

	paddw     mm5, [Round1]				; 1 - add in Round								 
	punpcklbw mm6, zero					; 2 - unpack shifted row

	paddw     mm5, mm2					; 1 - sum copies of row
	punpcklbw mm3, zero					; 2 - unpack row
									 
	movq      mm7, [PITCH*3+lpSrc]		; 3 - fetch row
	psraw     mm4, 1					; 0 - divide by 2

	pmullw    mm4, 00[lpWt]				; 0 - multiply by weights
	psraw     mm5, 1					; 1 - divide by 2

	movq      mm1, mm7					; 3 - copy row
	psrlq     mm7, 8					; 3 - shift row

	paddw     mm6, [Round1]				; 2 - add in Round
	punpcklbw mm7, zero					; 3 - unpack shifted row

	paddw     mm6, mm3					; 2 - sum copies of rows
	punpcklbw mm1, zero					; 3 - unpack row

	paddw     mm7, [Round1]				; 3 - add in Round
	psraw     mm6, 1					; 2 - divide by 2

	pmullw    mm5, 08[lpWt]				; 1 - multiply by weights
	paddw     mm7, mm1					; 3 - sum copies of row

	pmullw    mm6, 16[lpWt]				; 2 - multiply by weights
	psraw     mm7, 1					; 3 - divide by 2

	pmullw    mm7, 24[lpWt]				; 3 - multiply by weights

	ret


IAAhalf:
	test      eax, 1					; test mvx's parity bit
	jnz       IAAhalf_half				; jump when it was odd


IAAint_half:
	movd      mm4, [lpSrc]		; 0 - fetch row
										
	movd      mm5, [PITCH+lpSrc]		; 1 - fetch row
	punpcklbw mm4, zero					; 0 - unpack row

	movd      mm6, [PITCH*2+lpSrc]		; 2 - fetch row
	punpcklbw mm5, zero					; 1 - unpack row

	paddw     mm4, [Round1]				; 0 - add in Round								 
	punpcklbw mm6, zero					; 2 - unpack row

	paddw     mm4, mm5					; 0 - sum rows
	paddw     mm5, [Round1]				; 1 - add in Round

	movd      mm7, [PITCH*3+lpSrc]		; 3 - fetch row
	psraw     mm4, 1					; 0 - divide by 2

	pmullw    mm4, 00[lpWt]				; 0 - multiply by weights
	paddw     mm5, mm6					; 1 - sum rows

	movd      mm3, [PITCH*4+lpSrc]		; 4 - fetch row
	punpcklbw mm7, zero					; 3 - unpack row

	paddw     mm6, [Round1]				; 2 - add in Round
	psraw     mm5, 1					; 1 - divide by 2

	pmullw    mm5, 08[lpWt]				; 1 - multiply by weights
	punpcklbw mm3, zero					; 4 - unpack row

	paddw     mm6, mm7					; 2 - sum rows
 	paddw     mm7, [Round1]				; 3 - add in Round

	paddw     mm7, mm3					; 3 - sum rows
	psraw     mm6, 1					; 2 - divide by 2

	pmullw    mm6, 16[lpWt]				; 2 - multiply by weights
 	psraw     mm7, 1					; 3 - divide by 2

	pmullw    mm7, 24[lpWt]				; 3 - multiply by weights

	ret


IAAhalf_half:
	movq      mm4, [lpSrc]		; 0 - fetch row

	movq      mm5, [PITCH+lpSrc]		; 1 - fetch row
	movq      mm1, mm4					; 0 - copy row

	movq      mm2, mm5					; 1 - copy row
	psrlq     mm4, 8					; 0 - shift row

	movq      mm6, [PITCH*2+lpSrc]		; 2 - fetch row
	punpcklbw mm4, zero					; 0 - unpack shifted row

	movq      mm3, mm6					; 2 - copy row
	punpcklbw mm1, zero					; 0 - unpack row

	paddw     mm4, mm1					; 0 - parital sum both copies of row
	psrlq     mm5, 8					; 1 - shift row

	paddw     mm4, [Round2]				; 0 - add in Round								 
	punpcklbw mm5, zero					; 1 - unpack shifted row

	movq      mm7, [PITCH*3+lpSrc]		; 3 - fetch row
	punpcklbw mm2, zero					; 1 - unpack row

	paddw     mm5, mm2					; 1 - parital sum both copies of row
	psrlq     mm6, 8					; 2 - shift row

	paddw     mm4, mm5					; 0 - add partial sums
	punpcklbw mm6, zero					; 2 - unpack shifted row

	paddw     mm5, [Round2]				; 1 - add in Round								 
	punpcklbw mm3, zero					; 2 - unpack row

	paddw     mm6, mm3					; 2 - parital sum both copies of row
	movq      mm1, mm7					; 3 - copy row

	movq      mm2, [PITCH*4+lpSrc]		; 4 - fetch row
	psraw     mm4, 2					; 0 - divide by 2

	paddw     mm5, mm6					; 1 - add partial sums
	psrlq     mm7, 8					; 3 - shift row

	paddw     mm6, [Round2]				; 2 - add in Round								 
	punpcklbw mm7, zero					; 3 - unpack shifted row

	movq      mm3, mm2					; 4 - copy row
	punpcklbw mm1, zero					; 3 - unpack row

	paddw     mm7, mm1					; 3 - parital sum both copies of row
	psrlq     mm2, 8					; 4 - shift row

	pmullw    mm4, 00[lpWt]				; 0 - multiply by weights
	punpcklbw mm2, zero					; 4 - unpack shifted row

	paddw     mm6, mm7					; 2 - add partial sums
	punpcklbw mm3, zero					; 4 - unpack row

	paddw     mm7, [Round2]				; 3 - add in Round								 
	psraw     mm5, 2					; 1 - divide by 2

	pmullw    mm5, 08[lpWt]				; 1 - multiply by weights
	paddw     mm2, mm3					; 4 - parital sum both copies of row

	paddw     mm7, mm2					; 3 - add partial sums
	psraw     mm6, 2					; 2 - divide by 2

	pmullw    mm6, 16[lpWt]				; 2 - multiply by weights
	psraw     mm7, 2					; 3 - divide by 2

	pmullw    mm7, 24[lpWt]				; 3 - multiply by weights

	ret	 
MMXCODE1 ENDS

;        11111111112222222222333333333344444444445555555555666666666677777777778
;2345678901234567890123456789012345678901234567890123456789012345678901234567890
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12y2.asm ===
OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXCODE1 SEGMENT
MMX_YUV12ToYUY2   proc DIST LANG PUBLIC,
AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  52
RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane			= LocalFrameSize + RegisterStorageSize + 4
uVPlane			= LocalFrameSize + RegisterStorageSize + 8
uUPlane			= LocalFrameSize + RegisterStorageSize + 12
uWidth			= LocalFrameSize + RegisterStorageSize + 16
uHeight			= LocalFrameSize + RegisterStorageSize + 20
uYPitch			= LocalFrameSize + RegisterStorageSize + 24
uUVPitch		= LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag	= LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer	= LocalFrameSize + RegisterStorageSize + 36
lOutput			= LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0	= LocalFrameSize + RegisterStorageSize + 44
intPitch		= LocalFrameSize + RegisterStorageSize + 48
CCType			= LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

ASMTMP1            = 48         ; 13
Y                  = 44         ; 12
U                  = 40         ; 11
V                  = 36         ; 10
Outt               = 32         ; 9
YTemp              = 28         ; 8
UTemp              = 24         ; 7 
VTemp              = 20         ; 6
ASMTMP2            = 16         ; 5
Col                = 12         ; 4
OutTemp            = 8          ; 3
VAL                = 4          ; 2
LineCount          = 0          ; 1

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_ASMTMP1                 EQU    [esp + ASMTMP1]
_Y                       EQU    [esp + Y]
_U                       EQU    [esp + U]
_V                       EQU    [esp + V]
_Out                     EQU    [esp + Outt]
_YTemp                   EQU    [esp + YTemp]
_UTemp                   EQU    [esp + UTemp]
_VTemp                   EQU    [esp + VTemp]
_ASMTMP2                 EQU    [esp + ASMTMP2]
_Col                     EQU    [esp + Col]
_OutTemp                 EQU    [esp + OutTemp]
_VAL                     EQU    [esp + VAL]
_LineCount               EQU    [esp + LineCount]

; Save registers and start working

	push	ebx
	push	esi
	push	edi
	push	ebp

	sub		esp, LocalFrameSize

	mov		eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
	mov		ecx, DWORD PTR _uYPlane         ; ecx = uYPlane
	dec		eax                             ; eax = bShapingFlag - 1
	mov		edx, DWORD PTR _uUPlane         ; edx = uUPlane
	mov		DWORD PTR _LineCount, eax       ; eax = FREE, LineCount 
	mov		DWORD PTR _Y, ecx               ; ecx = FREE, Y

	mov		eax, DWORD PTR _uVPlane         ; eax = uVPlane
	mov		ecx, DWORD PTR _uOffsetToLine0  ; ecx = uOffsetToLine0
	mov		DWORD PTR _U, edx               ; edx = FREE, U
	add		ecx, DWORD PTR _lOutput         ; ecx = uOffsetToLine0 +

	mov		DWORD PTR _V, eax               ; eax = FREE, V
	mov		eax, DWORD PTR _uCCOutputBuffer ; eax = uCCOutputBuffer
	add		eax, ecx                        ; eax = uCCOutputBuffer +
											;       uOffsetToLine0 +
											;       lOutput
											;       ecx = FREE
	mov		DWORD PTR _Out, eax             ; eax = FREE, Out
	mov		eax, DWORD PTR _uHeight         ; eax = uHeight

	sar		eax, 1                          ; eax = uHeight/2
	mov		DWORD PTR _ASMTMP2, eax         ; eax = FREE, Row ready to 
											; count down

RowLoop:; L27704 outer loop over all rows

	mov		ecx, DWORD PTR _Y               ; ecx = Y: ecx EQU YTemp
	mov		edi, DWORD PTR _U               ; edi = U: edi EQU UTemp
	mov		ebp, DWORD PTR _V               ; ebp = V: ebp EQU VTemp 
	mov		esi, DWORD PTR _Out             ; esi = OutTemp
	mov		eax, DWORD PTR _LineCount       ; eax = LineCount
	test	eax, eax                        ; is LineCount == 0? eax = FREE
	je		SkipEvenRow						; L27708 loop if so, skip the even loop
	mov		eax, DWORD PTR _uWidth          ; eax = uWidth

; Due to the fact that YUV12 non-compressed input files can be
; any dimension that is a multiple of 4x4 up to CIF, we must
; check for extra bytes that can't be processed in the following
; loop. Here, we don't have the luxury of buffer padding to overrun
; the frame size.

	test	eax, 0FFFFFFF0H
	jz		L100

EvenRowPels:; L27709 loop over columns in even row - two YUY2 pels at a time.

	movq		mm0, [ecx]			; [ Y07 Y06 Y05 Y04 Y03 Y02 Y01 Y00 ]
	movq		mm1, [edi]			; [ U07 U06 U05 U04 U03 U02 U01 U00 ]
	movq		mm2, [ebp]			; [ V07 V06 V05 V04 V03 V02 V01 V00 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V03 U03 V02 U02 V01 U01 V00 U00 ]

	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V01 Y03 U01 Y02 V00 Y01 U00 Y00 ]
	movq		[esi], mm4			; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V03 U03 V02 U02 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y07 Y06 Y05 Y04 ]
	punpcklbw	mm0, mm3			; [ V03 Y07 U03 Y06 V02 Y05 U02 Y04 ]
	movq		[esi+8], mm0		; Write out 8 data values.
	movq		mm0, [ecx+8]		; [ Y15 Y14 Y13 Y12 Y11 Y10 Y09 Y08 ]
	psrlq		mm1, 32				; [   0   0   0   0 U07 U06 U05 U04 ]
	psrlq		mm2, 32				; [   0   0   0   0 V07 V06 V05 V04 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V07 U07 V06 U06 V05 U05 V04 U04 ]
	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V05 Y11 U05 Y10 V04 Y09 U04 Y08 ]
	movq		[esi+16], mm4		; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V07 U07 V06 U06 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y15 Y14 Y13 Y12 ]
	punpcklbw	mm0, mm3			; [ V07 Y15 U07 Y14 V06 Y13 U06 Y12 ]
	movq		[esi+24], mm0		; Write out 8 data values.
	lea			ecx, [ecx+16]		; Advance Y pointer.
	lea			edi, [edi+8]		; Advance U pointer.
	lea			ebp, [ebp+8]		; Advance V pointer.
	lea			esi, [esi+32]		; Advance Out pointer.
	sub			eax, 16
	test		eax, 0FFFFFFF0H
	jnz			EvenRowPels

	test		eax, eax
	jz			L101

; eax can be 4, 8 or 12
L100:
	mov			ebx, [ecx]			; [ Y03 Y02 Y01 Y00 ]
	mov			dl, [edi]			; [ U00 ]
	mov			dh, [ebp]			; [ V00 ]
	mov			[esi], bl
	mov			[esi+1], dl
	mov			[esi+2], bh
	mov			[esi+3], dh
	shr			ebx, 16
	mov			dl, [edi+1]			; [ U01 ]
	mov			dh, [ebp+1]			; [ V01 ]
	mov			[esi+4], bl
	mov			[esi+5], dl
	mov			[esi+6], bh
	mov			[esi+7], dh
	sub			eax, 4
	jz			L101

	mov			ebx, [ecx+4]		; [ Y07 Y06 Y05 Y04 ]
	mov			dl, [edi+2]			; [ U02 ]
	mov			dh, [ebp+2]			; [ V02 ]
	mov			[esi+8], bl
	mov			[esi+9], dl
	mov			[esi+10], bh
	mov			[esi+11], dh
	shr			ebx, 16
	mov			dl, [edi+3]			; [ U03 ]
	mov			dh, [ebp+3]			; [ V03 ]
	mov			[esi+12], bl
	mov			[esi+13], dl
	mov			[esi+14], bh
	mov			[esi+15], dh
	sub			eax, 4
	jz			L101

	mov			ebx, [ecx+8]		; [ Y11 Y10 Y09 Y08 ]
	mov			dl, [edi+4]			; [ U04 ]
	mov			dh, [ebp+4]			; [ V04 ]
	mov			[esi+16], bl
	mov			[esi+17], dl
	mov			[esi+18], bh
	mov			[esi+19], dh
	shr			ebx, 16
	mov			dl, [edi+5]			; [ U05 ]
	mov			dh, [ebp+5]			; [ V05 ]
	mov			[esi+20], bl
	mov			[esi+21], dl
	mov			[esi+22], bh
	mov			[esi+23], dh

L101:
	mov		eax, DWORD PTR _LineCount	; eax = LineCount
	jmp		SHORT UpdatePointers		; L27770

SkipEvenRow:; L27708

	mov		eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
	mov		edx, DWORD PTR _Out             ; edx = Out
	mov		ebx, DWORD PTR _intPitch        ; edx = intPitch
	sub		edx, ebx                        ; edx = Out - intPitch
	mov		DWORD PTR _Out, edx             ; save Out
         
UpdatePointers:	; L27770

	mov		ecx, DWORD PTR _Y               ; ecx = Y
	dec		eax                             ; eax = LineCount-1 OR bShapingFlag - 1
	mov		edx, DWORD PTR _intPitch        ; edx = intPitch
	mov		esi, DWORD PTR _Out             ; esi = Out
	mov		DWORD PTR _LineCount, eax       ; store decremented linecount
											; eax = FREE
	add		esi, edx                        ; (esi) Out += intPitch ***
	mov		eax, DWORD PTR _uYPitch         ; eax = uYPitch
	mov		edi, DWORD PTR _U               ; edi = U	***
	add		ecx, eax                        ; (ecx) Y += uYPitch ***
	mov		ebp, DWORD PTR _V               ; ebp = V	***
	mov		DWORD PTR _Y, ecx               ; store updated Y 
      
	mov		DWORD PTR _Out, esi             ; store Out
	mov		eax, DWORD PTR _LineCount       ; eax = LineCount
    
	test	eax, eax                        ; is LineCount == 0?
											; if so, ignore the odd
											; row loop over columns
	je		SkipOddRow						; L27714

	mov		eax, DWORD PTR _uWidth          ; eax = uWidth

; Due to the fact that YUV12 non-compressed input files can be
; any dimension that is a multiple of 4x4 up to CIF, we must
; check for extra bytes that can't be processed in the following
; loop. Here, we don't have the luxury of buffer padding to overrun
; the frame size.

	test	eax, 0FFFFFFF0H
	jz		L102
	      
OddRowPels: ;L27715 loop over columns of odd rows

	movq		mm0, [ecx]			; [ Y07 Y06 Y05 Y04 Y03 Y02 Y01 Y00 ]
	movq		mm1, [edi]			; [ U07 U06 U05 U04 U03 U02 U01 U00 ]
	movq		mm2, [ebp]			; [ V07 V06 V05 V04 V03 V02 V01 V00 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V03 U03 V02 U02 V01 U01 V00 U00 ]
	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V01 Y03 U01 Y02 V00 Y01 U00 Y00 ]
	movq		[esi], mm4			; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V03 U03 V02 U02 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y07 Y06 Y05 Y04 ]
	punpcklbw	mm0, mm3			; [ V03 Y07 U03 Y06 V02 Y05 U02 Y04 ]
	movq		[esi+8], mm0		; Write out 8 data values.
	movq		mm0, [ecx+8]		; [ Y15 Y14 Y13 Y12 Y11 Y10 Y09 Y08 ]
	psrlq		mm1, 32				; [   0   0   0   0 U07 U06 U05 U04 ]
	psrlq		mm2, 32				; [   0   0   0   0 V07 V06 V05 V04 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V07 U07 V06 U06 V05 U05 V04 U04 ]
	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V05 Y11 U05 Y10 V04 Y09 U04 Y08 ]
	movq		[esi+16], mm4		; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V07 U07 V06 U06 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y15 Y14 Y13 Y12 ]
	punpcklbw	mm0, mm3			; [ V07 Y15 U07 Y14 V06 Y13 U06 Y12 ]
	movq		[esi+24], mm0		; Write out 8 data values.
	lea			ecx, [ecx+16]		; Advance Y pointer.
	lea			edi, [edi+8]		; Advance U pointer.
	lea			ebp, [ebp+8]		; Advance V pointer.
	lea			esi, [esi+32]		; Advance Out pointer.
	sub			eax, 16
	test		eax, 0FFFFFFF0H
	jnz			OddRowPels

	test		eax, eax
	jz			L103

; eax can be 4, 8 or 12
L102:
	mov			ebx, [ecx]			; [ Y03 Y02 Y01 Y00 ]
	mov			dl, [edi]			; [ U00 ]
	mov			dh, [ebp]			; [ V00 ]
	mov			[esi], bl
	mov			[esi+1], dl
	mov			[esi+2], bh
	mov			[esi+3], dh
	shr			ebx, 16
	mov			dl, [edi+1]			; [ U01 ]
	mov			dh, [ebp+1]			; [ V01 ]
	mov			[esi+4], bl
	mov			[esi+5], dl
	mov			[esi+6], bh
	mov			[esi+7], dh
	sub			eax, 4
	jz			L103

	mov			ebx, [ecx+4]		; [ Y07 Y06 Y05 Y04 ]
	mov			dl, [edi+2]			; [ U02 ]
	mov			dh, [ebp+2]			; [ V02 ]
	mov			[esi+8], bl
	mov			[esi+9], dl
	mov			[esi+10], bh
	mov			[esi+11], dh
	shr			ebx, 16
	mov			dl, [edi+3]			; [ U03 ]
	mov			dh, [ebp+3]			; [ V03 ]
	mov			[esi+12], bl
	mov			[esi+13], dl
	mov			[esi+14], bh
	mov			[esi+15], dh
	sub			eax, 4
	jz			L103

	mov			ebx, [ecx+8]		; [ Y11 Y10 Y09 Y08 ]
	mov			dl, [edi+4]			; [ U04 ]
	mov			dh, [ebp+4]			; [ V04 ]
	mov			[esi+16], bl
	mov			[esi+17], dl
	mov			[esi+18], bh
	mov			[esi+19], dh
	shr			ebx, 16
	mov			dl, [edi+5]			; [ U05 ]
	mov			dh, [ebp+5]			; [ V05 ]
	mov			[esi+20], bl
	mov			[esi+21], dl
	mov			[esi+22], bh
	mov			[esi+23], dh

L103:
	mov			eax, DWORD PTR _LineCount	; eax = LineCount
	jmp			SHORT UpdateAllPointers		; L27771

SkipOddRow: ;L27714 

	mov		eax, DWORD PTR _bShapingFlag	; eax = bShapingFlag
	mov		edx, DWORD PTR _Out             ; edx = Out
	mov		ebx, DWORD PTR _intPitch        ; edx = intPitch
	sub		edx, ebx                        ; edx = Out - intPitch
	mov		DWORD PTR _Out, edx             ; save Out

UpdateAllPointers: ; L27771 update pointers

	dec		eax								; eax = LineCount-1 OR bShapingFlag - 1
	mov		ecx, DWORD PTR _Y				; ecx = Y
	mov		edx, DWORD PTR _intPitch		; edx = intPitch
	mov		ebx, DWORD PTR _Out				; ebx = Out
	add		ebx, edx						; ebx = Out + intPitch
	mov		ebp, DWORD PTR _ASMTMP2			; ebp = row loop counter
	mov		DWORD PTR _LineCount, eax		; store updated LineCount
	mov		DWORD PTR _Out, ebx				; store updated Out
	mov		edx, DWORD PTR _uUVPitch        ; edx = uUVPitch
	mov		eax, DWORD PTR _U               ; eax = U
	mov		esi, DWORD PTR _V               ; esi = V
	add		eax, edx                        ; eax = U + uUVPitch
	add		esi, edx                        ; esi = V + uUVPitch
	mov		DWORD PTR _U, eax               ; store updated U
	mov		DWORD PTR _V, esi               ; store updated V
	add		ecx, DWORD PTR _uYPitch			; ecx = Y + uYPitch
	dec		ebp								; decrement loop counter
	mov		DWORD PTR _Y, ecx				; store updated Y
	mov		DWORD PTR _ASMTMP2, ebp			; store updated loop counter

	jne		RowLoop							; back to L27704 row loop

CleanUp:

	add		esp, LocalFrameSize             ; restore esp to registers                               

	pop		ebp
	pop		edi
	pop		esi
	pop		ebx

	ret		52								; 13*4 bytes of arguments

MMX_YUV12ToYUY2 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\decconst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\decconst.inv   1.1   27 Dec 1995 14:36:22   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\decconst.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:22   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

;//
;// DECCONST.INC - derived from MRV
;//

IFDEF _DECCONST_INC_
ELSE
_DECCONST_INC = 1

; Constants used by MRV decoder, post filtering functions, and color convertors.

YARCHIVEOFFSET    = 311688
UOFFSET           = 168
VPITCH            = 336

BEFTRIGGER        = 143
BEFWILLING        = 125
BEFUNWILLING      =  10
BEFENDOFLINE      =  21
BEFENDOFFRAME     = 246

YPITCH      = 384           
YSTARTOFF   = YPITCH*16+16  ; offset into output buffer of first pixel to write

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d35xpand.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995, 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;--------------------------------------------------------------------------;
;
;  d3xpand.asm
;
;  Description:
;    This routine expands a picture frame by 16 or 8 bytes in all
;    directions for unrestricted motion vector mode.  It assumes
;    that there is space in memory around the existing frame
;    and simply writes to there (i.e., clobbers it), and that
;    the pitch is 384 (distance in bytes between vertically
;    adjacent pels).  See Below.
;
;  Routines:                          prototypes in:
;    ExpandPlane                      d3dec.cpp
;
;  Data:
;    This routine assumes that the PITCH is 384.
;
;  Inputs (dwords pushed onto stack by caller):
;    StartPtr     flat pointer to the first byte of the
;                 original frame.
;    FrameWidth   Width (in bytes) of the original frame.
;                 THIS MUST BE AT LEAST 32 & A MULTIPLE OF 4.
;    FrameHeight  Height (in rows) of the original frame.
;    Pels         Number of pels to expand the plane.
;                 16 for lumina, 8 for chroma.  This MUST
;                 BE A MULTIPLE OF 8.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35xpand.asv   1.2   08 Mar 1996 16:48:16   AGUPTA2  $
;  $Log:   S:\h26x\src\dec\d35xpand.asv  $
;// 
;//    Rev 1.2   08 Mar 1996 16:48:16   AGUPTA2
;// Changed the meaning of last parameter.  New and faster way to expand planes.
;// 
;// 
;//    Rev 1.0   27 Nov 1995 11:28:30   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;


.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE

.CODE
;--------------------------------------------------------------------------;
;
;  The algorithm fills in (1) the bottom (not including corners),
;  then (2) the sides (including the bottom corners, but not the
;  top corners), then (3) the top (including the top
;  corners) as shown below, replicating the outermost bytes
;  of the original frame outward:
;
;               ----------------------------
;              |                            |
;              |            (3)             |
;              |                            |
;              |----------------------------|
;              |     |                |     |
;              |     |                |     |
;              |     |                |     |
;              |     |    original    |     |
;              |     |     frame      |     |
;              |     |                |     |
;              | (2) |                | (2) |
;              |     |                |     |
;              |     |                |     |
;              |     |----------------|     |
;              |     |                |     |
;              |     |      (1)       |     |
;              |     |                |     |
;               ----------------------------
;
;  Register Usage:
;
;    esi        pointer for stages (1) and (2).
;    edi        pointer for stages (2) and (3).
;    ecx        loop control.
;    eax, ebx   dword to be written.  In stage (2), it is formed
;               from 4 (shifted) copies of the border byte.  (i.e.,
;               byte 0d2h replicates to 0d2d2d2d2h.)
;    edx, ebp   pointers.
;
;--------------------------------------------------------------------------;
;
;    Version:   5.0
;    Date:      4 March 1996
;    Author:    R. McKenzie
;
;    Notes:     The essential features of this version are:
;               1.  Re-organized to fill bottom first, then sides,
;                   finally top
;               2.  Code is optimized for the case that the expanded 
;                   plane is 32-byte aligned.  No checking is performed
;                   to verify this assumption and this routine will run
;                   significantly SLOWER (though correctly) if this
;                   assumption is not true.
;
;--------------------------------------------------------------------------;

;-------------------;
;    Stack Usage    ;
;-------------------;
; register storage
;   edi               esp+00
;   esi               esp+04
;   ebx               esp+08
;   ebp               esp+12

; return address      esp+16

; C input parameters
    StartPtr     EQU  esp+20
    FrameWidth   EQU  esp+24
    FrameHeight  EQU  esp+28
    Pels         EQU  esp+32

PITCH   =   384


PUBLIC C ExpandPlane

ExpandPlane:
  push     ebp
  push     ebx

  push     esi
  push     edi


;--------------------------------------;
;          fill the bottom             ;
;--------------------------------------;
  mov      esi, [StartPtr]             ; ptr1 = StartPtr
  mov      edi, [FrameHeight]

  shl      edi, 7
  mov      ebp, PITCH

  lea      edi, [edi+2*edi-PITCH]      ; PITCH * (FrameHeight-1)
  mov      edx, [FrameWidth]           ; column bound

  add      esi, edi					   ; esi = bottom left corner
  nop


;-------Start Outer Bottom Loop--------;
OuterBottomLoop:
  mov      edi, esi                    ; destination pointer
  mov      ecx, [Pels]                 ; row bound

  mov      eax, 0[esi]
  mov      ebx, 4[esi]


;-------Start Inner Bottom Loop--------;
InnerBottomLoop:
  mov      0[edi+ebp], eax
  mov      4[edi+ebp], ebx

  add      edi, ebp
  dec      ecx

  jne      InnerBottomLoop
;--------End Inner Bottom Loop---------;


  add      esi, 8
  sub      edx, 8

  jne      OuterBottomLoop
;--------End Outer Bottom Loop---------;


;--------------------------------------;
;    Fill both sides from bottom up    ;
;--------------------------------------;
  mov      ecx, [FrameHeight]
  mov      edx, [Pels]

  add      ecx, edx                    ; ecx = row count
  add      edi, 8                      ; edi = Right pointer

  mov      eax, [FrameWidth]
  mov      esi, edi

  sub      esi, eax                    ; esi = Left pointer
  nop


;--------Start Outer Sides Loop--------;
OuterSidesLoop:
  xor      eax, eax
  xor      ebx, ebx

  mov      al, [esi]
  push     ecx                         ; save row counter

  mov      bl, [edi-1]
  mov      ah, [esi]

  mov      bh, [edi-1]
  mov      ebp, eax

  shl      eax, 16
  mov      edx, ebx

  shl      ebx, 16
  or       eax, ebp

  or       ebx, edx
  mov      ebp, esi                    ; Left Pointer

  mov      edx, edi                    ; Right Pointer
  mov      ecx, [Pels+4]               ; column counter


;--------Start Inner Sides Loop--------;
InnerSidesLoop:
  mov      [ebp-4], eax
  mov      [ebp-8], eax

  mov      [edx], ebx
  mov      [edx+4], ebx

  sub      ebp, 8
  add      edx, 8

  sub      ecx, 8
  jne      InnerSidesLoop
;---------End Inner Sides Loop---------;


  pop      ecx
  sub      esi, PITCH

  sub      edi, PITCH
  dec      ecx

  jne      OuterSidesLoop
;---------End Outer Sides Loop---------;


;--------------------------------------;
;          Fill the Top                ;
;--------------------------------------;
  mov      ecx, [Pels]                 ; ptr1 = StartPtr
  mov      edx, [FrameWidth]           ; column bound

  add      esi, PITCH
  mov      ebp, -PITCH

  sub      esi, ecx
  lea      edx, [edx+2*ecx]            ; FrameWidth + 2 * Pels


;---------Start Outer Top Loop---------;
OuterTopLoop:
  mov      edi, esi                    ; destination pointer
  mov      ecx, [Pels]                 ; row bound

  mov      eax, 0[esi]
  mov      ebx, 4[esi]


;---------Start Inner Top Loop---------;
InnerTopLoop:
  mov      0[edi+ebp], eax
  mov      4[edi+ebp], ebx

  add      edi, ebp
  dec      ecx

  jne      InnerTopLoop
;----------End Inner Top Loop----------;


  add      esi, 8
  sub      edx, 8

  jne      OuterTopLoop
;----------End Outer Top Loop----------;

;--------------------------------------;
;          Wrap up and go home         ;
;--------------------------------------;
  pop      edi
  pop      esi

  pop      ebx
  pop      ebp

  ret

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mbvriq.asm ===
;--------------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------------

;--------------------------------------------------------------------------------
;
; $Author:   RMCKENZX  $
; $Date:   03 Apr 1996 17:31:22  $
; $Archive:   S:\h26x\src\dec\d3mbvriq.asv  $
; $Header:   S:\h26x\src\dec\d3mbvriq.asv   1.6   03 Apr 1996 17:31:22   RMCKENZX  $
; $Log:   S:\h26x\src\dec\d3mbvriq.asv  $
;// 
;//    Rev 1.6   03 Apr 1996 17:31:22   RMCKENZX
;// Additional optimizations.
;// 
;//    Rev 1.5   01 Apr 1996 11:37:50   AGUPTA2
;// Moved the routine to IACODE1 segment.
;// 
;//    Rev 1.4   14 Mar 1996 14:21:56   AGUPTA2
;// Moved tables from mmxtable.c to this file.  Added segment decls.
;// 
;//    Rev 1.3   13 Mar 1996 11:17:08   RMCKENZX
;// Added scaling of INTRA DC coefficient.
;// 
;//    Rev 1.2   12 Mar 1996 08:39:34   RMCKENZX
;// changed to fixed point scaling tables.
;// 
;//    Rev 1.0   27 Feb 1996 15:24:14   RMCKENZX
;// Initial revision.
; 
;--------------------------------------------------------------------------------

;--------------------------------------------------------------------------------
;
;  d3mbvriq.asm
;
;  Description:
;    This routine performs run length decoding and inverse quantization
;    of transform coefficients for one block.
;	 MMx version.
;
;  Routines:
;    VLD_RLD_IQ_Block
;
;  Inputs (dwords pushed onto stack by caller):
;    lpBlockAction  pointer to Block action stream for current block.
;
;	 lpSrc			The input bitstream.
;
;	 lBitsInOut		Number of bits already read.
;
;    pIQ_INDEX		Pointer to coefficients and indices.
;
;    pN				Pointer to number of coefficients read.
;
;  Returns:
;     				total number of bits read (including number read
;					prior to call).  On error, returns 0.
;
;--------------------------------------------------------------------------------
;
; TABLES 
;	The structure of the MMx tables (DWORD entries) is:
;		bits    name    description
;		31-16   level   signed 16-bit quantized value
;		15      last    0 = more coef., 1 = last coef.
;		14-8    bits    number of bits used by VLC
;		7-0     run     number of preceeding 0s + 1
;	
;	special table values:  (all signaled by run == 0)
;		0x00000000      escape code
;		0x80000000      illegal code
;		0xffffff00      major table miss
;
;
; ALGORITHM
;	We use the following 4 cases to compute the reconstructed value
;	depending on the sign of L=level and the parity of Q=quantizer:
;
;				L pos		L neg
;	Q even		2QL+(Q-1)	2QL-(Q-1)
;	Q odd		2QL+(Q)		2QL-(Q)
;
;	The Q or Q-1 term is formed by subtracting 1 and then oring
;   with 1.  This leaves odd Qs unchanged, and decreases even Qs by 1.
;   This is done in the function header and kept in mm3.
;
;	The + or - on this term (moved to mm4) is gotten by using a mask 
;	in mm1 formed from the sign bit of L.  This mask is exclusive or'd
;   with the term and then subtracted from the result.  When the mask is 0, 
;   this leaves the term unchanged.  When the mask is -1, it first forms 
;   the one's complement, then changes it to the 2's complement.
;
;
; SCALING
;	The scale factor is stored as a fixed point WORD.  After multiplication 
;   by the scale and shifting , we have 8 fraction bits.  Then a round   
;	bit is added in, and a final shift leaves 7 fraction bits.
;
;
; CLIPPING
;	Clipping of the reconstructed coefficient to the range of -2048, ... 
;	+2047 is done for the (escape signalled) fixed length decodes.  It is
;   not needed for the variable length decodes as the most extreme level
;   for any of the variable length coded events is +-12.  Since the maximum
;   quantizer is 31, this can generate at most a coefficient of +-775.
;
;   Clipping is done by:
;		1.  Adding (with SIGNED Saturation) TopClip	(30720 or 0x7800)
;		2.  Subtracting (with UNSIGNED Saturation) LowClip (28672 or 0x7000)
;		3.  Adding MidClip (-2048 or 0xf800)
; 
;	since TopClip - LowClip + MidClip = 0, This will leave the coefficient
;   unchanged unless:
;		(1) the result of the first add is negative, or
;		(2) saturation takes place.
;        
;	Since the maximum level is +-127, the most extreme coefficient (prior to 
;	clipping) is +-7905.  Thus the result of the first add will always be
;	positive.
;
;	If the input value is 2047 or larger, the result of the first add will
;	clip to 32767, then subtract to 4095, then add to +2047 as desired.
;
;	If the input value is -2048 or smaller, the result of the first add
;	will be 28672 or smaller (but at least 22815), hence the unsigned 
;	subtract will clip to 0.  The final add will then yield -2048 as desired.
;
;--------------------------------------------------------------------------------
;
;	Register Usage:
;       eax = bitstream value
;		ebx = lBitsInOut>>3 (byte offset into bitstream)
;		 cl = lBitsInOut&7 (bit offset into bitstream)
;		 dl = block type ([lpBlockAction])
;		esi = bitstream source pointer (lpSrc)
;		edi = coefficient destination pointer (pIQ_INDEX)
;		ebp = coefficent counter (init to 0)
;
;       mm0 = accumulator (initially level, finally coefficient*scale)
;       mm1 = mask (0 when level positive, -1 when level negative)
;       mm2 = 2Q 2*quantizer
;       mm3 = term (see description above)
;       mm4 = +- term (see description above)
;       mm5 = rounding value
;       mm6 = TopClip
;       mm7 = LowClip
;
;--------------------------------------------------------------------------------

.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

IACODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
MMX_Scale LABEL DWORD
DWORD 040000000H, 058c50000H, 0539f0000H, 04b420000H, 040000000H, 032490000H, 022a30000H, 011a80000H  ; row 0
DWORD 058c50000H, 07b210000H, 073fc0000H, 068620000H, 058c50000H, 045bf0000H, 0300b0000H, 0187e0000H  ; row 1
DWORD 0539f0000H, 073fc0000H, 06d410000H, 062540000H, 0539f0000H, 041b30000H, 02d410000H, 017120000H  ; row 2
DWORD 04b420000H, 068620000H, 062540000H, 0587e0000H, 04b420000H, 03b210000H, 028ba0000H, 014c30000H  ; row 3
DWORD 040000000H, 058c50000H, 0539f0000H, 04b420000H, 040000000H, 032490000H, 022a30000H, 011a80000H  ; row 4
DWORD 032490000H, 045bf0000H, 041b30000H, 03b210000H, 032490000H, 027820000H, 01b370000H, 00de00000H  ; row 5
DWORD 022a30000H, 0300b0000H, 02d410000H, 028ba0000H, 022a30000H, 01b370000H, 012bf0000H, 0098e0000H  ; row 6
DWORD 011a80000H, 0187e0000H, 017120000H, 014c30000H, 011a80000H, 00de00000H, 0098e0000H, 004df0000H   ; row 7

ALIGN 8
MidClip         DWORD      0f800f800h	; = Low

ALIGN 4
Round           DWORD       00000200h 
TopClip         DWORD       78007800h	; = max_pos - High
LowClip         DWORD       70007000h 	; = TopClip + Low

ALIGN 4
MMX_TCOEFF_MAJOR LABEL DWORD 
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 000000000H, 000000000H  ; 0-7
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H  ; 8-15
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H  ; 16-23
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H  ; 24-31
DWORD 000018809H, 0ffff8809H, 000018808H, 0ffff8808H, 000018807H, 0ffff8807H, 000018806H, 0ffff8806H  ; 32-39
DWORD 00001080dH, 0ffff080dH, 00001080cH, 0ffff080cH, 00001080bH, 0ffff080bH, 000040801H, 0fffc0801H  ; 40-47
DWORD 000018705H, 000018705H, 0ffff8705H, 0ffff8705H, 000018704H, 000018704H, 0ffff8704H, 0ffff8704H  ; 48-55
DWORD 000018703H, 000018703H, 0ffff8703H, 0ffff8703H, 000018702H, 000018702H, 0ffff8702H, 0ffff8702H  ; 56-63
DWORD 00001070aH, 00001070aH, 0ffff070aH, 0ffff070aH, 000010709H, 000010709H, 0ffff0709H, 0ffff0709H  ; 64-71
DWORD 000010708H, 000010708H, 0ffff0708H, 0ffff0708H, 000010707H, 000010707H, 0ffff0707H, 0ffff0707H  ; 72-79
DWORD 000020702H, 000020702H, 0fffe0702H, 0fffe0702H, 000030701H, 000030701H, 0fffd0701H, 0fffd0701H  ; 80-87
DWORD 000010606H, 000010606H, 000010606H, 000010606H, 0ffff0606H, 0ffff0606H, 0ffff0606H, 0ffff0606H  ; 88-95
DWORD 000010605H, 000010605H, 000010605H, 000010605H, 0ffff0605H, 0ffff0605H, 0ffff0605H, 0ffff0605H  ; 96-103
DWORD 000010604H, 000010604H, 000010604H, 000010604H, 0ffff0604H, 0ffff0604H, 0ffff0604H, 0ffff0604H  ; 104-111
DWORD 000018501H, 000018501H, 000018501H, 000018501H, 000018501H, 000018501H, 000018501H, 000018501H  ; 112-119
DWORD 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H  ; 120-127
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 128-135
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 136-143
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 144-151
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 152-159
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 160-167
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 168-175
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 176-183
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 184-191
DWORD 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H  ; 192-199
DWORD 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H  ; 200-207
DWORD 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H  ; 208-215
DWORD 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H  ; 216-223
DWORD 000010503H, 000010503H, 000010503H, 000010503H, 000010503H, 000010503H, 000010503H, 000010503H  ; 224-231
DWORD 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H  ; 232-239
DWORD 000020501H, 000020501H, 000020501H, 000020501H, 000020501H, 000020501H, 000020501H, 000020501H  ; 240-247
DWORD 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H   ; 248-255

ALIGN 4
MMX_TCOEFF_MINOR LABEL DWORD 
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 0-7  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 8-15  ILLEGAL CODES
DWORD 000028c02H, 000028c02H, 0fffe8c02H, 0fffe8c02H, 000038c01H, 000038c01H, 0fffd8c01H, 0fffd8c01H  ; 16-23
DWORD 0000b0c01H, 0000b0c01H, 0fff50c01H, 0fff50c01H, 0000a0c01H, 0000a0c01H, 0fff60c01H, 0fff60c01H  ; 24-31
DWORD 000018b1dH, 000018b1dH, 000018b1dH, 000018b1dH, 0ffff8b1dH, 0ffff8b1dH, 0ffff8b1dH, 0ffff8b1dH  ; 32-39
DWORD 000018b1cH, 000018b1cH, 000018b1cH, 000018b1cH, 0ffff8b1cH, 0ffff8b1cH, 0ffff8b1cH, 0ffff8b1cH  ; 40-47
DWORD 000018b1bH, 000018b1bH, 000018b1bH, 000018b1bH, 0ffff8b1bH, 0ffff8b1bH, 0ffff8b1bH, 0ffff8b1bH  ; 48-55
DWORD 000018b1aH, 000018b1aH, 000018b1aH, 000018b1aH, 0ffff8b1aH, 0ffff8b1aH, 0ffff8b1aH, 0ffff8b1aH  ; 56-63
DWORD 000020b0aH, 000020b0aH, 000020b0aH, 000020b0aH, 0fffe0b0aH, 0fffe0b0aH, 0fffe0b0aH, 0fffe0b0aH  ; 64-71
DWORD 000020b09H, 000020b09H, 000020b09H, 000020b09H, 0fffe0b09H, 0fffe0b09H, 0fffe0b09H, 0fffe0b09H  ; 72-79
DWORD 000020b08H, 000020b08H, 000020b08H, 000020b08H, 0fffe0b08H, 0fffe0b08H, 0fffe0b08H, 0fffe0b08H  ; 80-87
DWORD 000020b07H, 000020b07H, 000020b07H, 000020b07H, 0fffe0b07H, 0fffe0b07H, 0fffe0b07H, 0fffe0b07H  ; 88-95
DWORD 000020b06H, 000020b06H, 000020b06H, 000020b06H, 0fffe0b06H, 0fffe0b06H, 0fffe0b06H, 0fffe0b06H  ; 96-103
DWORD 000030b04H, 000030b04H, 000030b04H, 000030b04H, 0fffd0b04H, 0fffd0b04H, 0fffd0b04H, 0fffd0b04H  ; 104-111
DWORD 000030b03H, 000030b03H, 000030b03H, 000030b03H, 0fffd0b03H, 0fffd0b03H, 0fffd0b03H, 0fffd0b03H  ; 112-119
DWORD 000040b02H, 000040b02H, 000040b02H, 000040b02H, 0fffc0b02H, 0fffc0b02H, 0fffc0b02H, 0fffc0b02H  ; 120-127
DWORD 0000c0c01H, 0000c0c01H, 0fff40c01H, 0fff40c01H, 000050c02H, 000050c02H, 0fffb0c02H, 0fffb0c02H  ; 128-135
DWORD 000010c18H, 000010c18H, 0ffff0c18H, 0ffff0c18H, 000010c19H, 000010c19H, 0ffff0c19H, 0ffff0c19H  ; 136-143
DWORD 000018c1eH, 000018c1eH, 0ffff8c1eH, 0ffff8c1eH, 000018c1fH, 000018c1fH, 0ffff8c1fH, 0ffff8c1fH  ; 144-151
DWORD 000018c20H, 000018c20H, 0ffff8c20H, 0ffff8c20H, 000018c21H, 000018c21H, 0ffff8c21H, 0ffff8c21H  ; 152-159
DWORD 000060d02H, 0fffa0d02H, 000040d03H, 0fffc0d03H, 000030d05H, 0fffd0d05H, 000030d06H, 0fffd0d06H  ; 160-167
DWORD 000030d07H, 0fffd0d07H, 000020d0bH, 0fffe0d0bH, 000010d1aH, 0ffff0d1aH, 000010d1bH, 0ffff0d1bH  ; 168-175
DWORD 000018d22H, 0ffff8d22H, 000018d23H, 0ffff8d23H, 000018d24H, 0ffff8d24H, 000018d25H, 0ffff8d25H  ; 176-183
DWORD 000018d26H, 0ffff8d26H, 000018d27H, 0ffff8d27H, 000018d28H, 0ffff8d28H, 000018d29H, 0ffff8d29H  ; 184-191
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 192-199  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 200-207  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 208-215  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 216-223  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 224-231  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 232-239  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 240-247  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 248-255  ILLEGAL CODES
DWORD 000090b01H, 000090b01H, 000090b01H, 000090b01H, 0fff70b01H, 0fff70b01H, 0fff70b01H, 0fff70b01H  ; 256-263
DWORD 000080b01H, 000080b01H, 000080b01H, 000080b01H, 0fff80b01H, 0fff80b01H, 0fff80b01H, 0fff80b01H  ; 264-271
DWORD 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H  ; 272-279
DWORD 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H  ; 280-287
DWORD 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H  ; 288-295
DWORD 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H  ; 296-303
DWORD 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H  ; 304-311
DWORD 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H  ; 312-319
DWORD 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H  ; 320-327
DWORD 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H  ; 328-335
DWORD 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H  ; 336-343
DWORD 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H  ; 344-351
DWORD 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H  ; 352-359
DWORD 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H  ; 360-367
DWORD 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H  ; 368-375
DWORD 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H  ; 376-383
DWORD 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H  ; 384-391
DWORD 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H  ; 392-399
DWORD 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H  ; 400-407
DWORD 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H  ; 408-415
DWORD 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H  ; 416-423
DWORD 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H  ; 424-431
DWORD 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H  ; 432-439
DWORD 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H  ; 440-447
DWORD 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H  ; 448-455
DWORD 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H  ; 456-463
DWORD 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H  ; 464-471
DWORD 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H  ; 472-479
DWORD 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H  ; 480-487
DWORD 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H  ; 488-495
DWORD 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H  ; 496-503
DWORD 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H  ; 504-511
DWORD 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H  ; 512-519
DWORD 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H  ; 520-527
DWORD 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H  ; 528-535
DWORD 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H  ; 536-543
DWORD 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H  ; 544-551
DWORD 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H  ; 552-559
DWORD 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H  ; 560-567
DWORD 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H  ; 568-575
DWORD 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H  ; 576-583
DWORD 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H  ; 584-591
DWORD 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H  ; 592-599
DWORD 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H  ; 600-607
DWORD 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H  ; 608-615
DWORD 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H  ; 616-623
DWORD 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H  ; 624-631
DWORD 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H  ; 632-639
DWORD 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H  ; 640-647
DWORD 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H  ; 648-655
DWORD 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H  ; 656-663
DWORD 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H  ; 664-671
DWORD 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH  ; 672-679
DWORD 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH  ; 680-687
DWORD 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH  ; 688-695
DWORD 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH  ; 696-703
DWORD 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH  ; 704-711
DWORD 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH  ; 712-719
DWORD 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH  ; 720-727
DWORD 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH  ; 728-735
DWORD 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH  ; 736-743
DWORD 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH  ; 744-751
DWORD 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH  ; 752-759
DWORD 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH  ; 760-767
DWORD 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH  ; 768-775
DWORD 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH  ; 776-783
DWORD 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH  ; 784-791
DWORD 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH  ; 792-799
DWORD 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH  ; 800-807
DWORD 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH  ; 808-815
DWORD 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH  ; 816-823
DWORD 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH  ; 824-831
DWORD 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH  ; 832-839
DWORD 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH  ; 840-847
DWORD 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH  ; 848-855
DWORD 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH  ; 856-863
DWORD 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH  ; 864-871
DWORD 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH  ; 872-879
DWORD 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH  ; 880-887
DWORD 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH  ; 888-895
DWORD 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH  ; 896-903
DWORD 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH  ; 904-911
DWORD 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH  ; 912-919
DWORD 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH  ; 920-927
DWORD 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H  ; 928-935
DWORD 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H  ; 936-943
DWORD 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H  ; 944-951
DWORD 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H  ; 952-959
DWORD 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H  ; 960-967
DWORD 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H  ; 968-975
DWORD 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H  ; 976-983
DWORD 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H  ; 984-991
DWORD 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H  ; 992-999
DWORD 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H  ; 1000-1007
DWORD 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H  ; 1008-1015
DWORD 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H  ; 1016-1023

ALIGN 4
TAB_ZZ_RUN LABEL DWORD
DWORD  0,  1,  8,  16, 9,  2,  3,  10
DWORD 17, 24, 32, 25, 18, 11, 4,  5
DWORD 12, 19, 26, 33, 40, 48, 41, 34
DWORD 27, 20, 13, 6,  7,  14, 21, 28
DWORD 35, 42, 49, 56, 57, 50, 43, 36
DWORD 29, 22, 15, 23, 30, 37, 44, 51
DWORD 58, 59, 52, 45, 38, 31, 39, 46
DWORD 53, 60, 61, 54, 47, 55, 62, 63

MMXDATA1 ENDS

; global tables
MajorTbl        EQU     MMX_TCOEFF_MAJOR
MinorTbl        EQU     MMX_TCOEFF_MINOR
RunTbl          EQU     TAB_ZZ_RUN
Scale           EQU     MMX_Scale
PITCH   		=   384

IACODE1 SEGMENT

MMX_VLD_RLD_IQ_Block PROC C

;  Stack Use
FRAMESIZE		=	 12					; 12 bytes locals

;  local variables
lpN				EQU		esp+00			; pointer to number of coef. decoded
lBitsInOut      EQU		esp+04			; bit offset
lCumulativeRun	EQU		esp+08			; cumulative run

;  saved registers
;	ebx					esp+12
;	edi					esp+16
;	esi					esp+20
;	ebp					esp+24

;  return address       esp+28

;  input parameters
lpBlockAction 	EQU		esp+32		
lpSrc			EQU		esp+36
uBitsReadIn		EQU		esp+40
pN				EQU		esp+44
pIQ_INDEX		EQU		esp+48

; save registers
	push      ebp
	push      esi
	 
	push      edi			
	push      ebx

	sub       esp, FRAMESIZE
 	xor       eax, eax					; zero eax for quantizer & coef. counter

;
; initialize
;
	movd      mm5, [Round]				; mm5 = rounding value

	movd      mm6, [TopClip]			; mm6 = TopClip

	movd      mm7, [LowClip]			; mm7 = LowClip

	mov       ebx, -1					; beginning cumulative run value
 	mov       edx, [pN]					; fetch pointer to coefficient read

	mov       [lpN], edx				; store pN pointer locally
	mov       ecx, [uBitsReadIn]		; fetch bits read in

	mov       [lCumulativeRun], ebx		; init cumulative run to -1
	mov       ebx, ecx					; copy bits read to ebx

	mov       [lBitsInOut], ecx			; store bits read locally
	mov       edx, [lpBlockAction]      ; fetch block action pointer

	and       ecx, 7					; mask the shift value for input
	mov       esi, [lpSrc]  			; fetch bitstream source pointer

	shr       ebx, 3					; compute offset for input
	mov       al, [edx+3]				; fetch quantizer

 	shl	      eax, 16					; 2*quantizer to high order word
	mov       dl, [edx]					; fetch block type (save it in dl)

	movd      mm2, eax					; mm2 = quantizer (Q)

	sub       eax, 10000h
	xor       ebp, ebp					; got inputs, init coefficient counter

	or        eax, 10000h
	cmp       dl, 1						; check for INTRA block type

	movd      mm3, eax					; mm3 = Q if odd, else = Q-1
	paddw     mm2, mm2                  ; mm2 = 2*quantizer (2Q)

	mov       edi, [pIQ_INDEX]			; fetch coefficient output pointer
	ja        get_next_coefficient		; if type 2 or larger, no INTRADC
	 
;
; Decode INTRADC
;
;	uses dword load & bitswap to achieve big endian ordering.
;	prior code prepares ebx, cl, and dl as follows:
;		ebx = lBitsInOut>>3
;		cl  = lBitsInOut&7
;		dl  = BlockType (0=INTRA_DC, 1=INTRA, 2=INTER, etc.)
;
	mov       eax, [esi+ebx]			; *** PROBABLE MALALIGNMENT ***
	inc       ebp						; one coefficient decoded

	bswap     eax						; big endian order
										; *** NOT PAIRABLE ***

	shl       eax, cl					; left justify bitstream buffer
										; *** NOT PAIRABLE ***
										; *** 4 CYCLES ***

	shr       eax, 17					; top 11 bits to bits 14-04
 	mov       ecx, [lBitsInOut]			; ecx = lBitsInOut

	and       eax, 07f80h				; mask to get scaled coeff.
	add       ecx, 8					; bits used += 8 for INTRADC

	cmp       eax, 07f80h				; check for 11111111 codeword
	jne       @f

	mov       eax, 04000h				; 11111111 decodes to 400h = 1024 

@@:
	mov       [lBitsInOut], ecx			;  update bits used
	xor       ebx, ebx

	mov       [lCumulativeRun], ebx		; save total run (starts with zero)
	mov       [edi], eax				; save decoded DC coefficient

	mov       [edi+4], ebx				; save 0 index
	mov       ebx, ecx					; ebx = lBitsInOut

	shr       ebx, 3					; offset for input
	add       edi, 8					; update coefficient pointer

;  check for last
	test      dl, dl					; check for INTRA-DC (block type=0)
	jz	      finish					; if only the INTRADC present


;
; Get Next Coefficient
;
;	prior codes prepares ebx and ecx as follows:
;		ebx = lBitsInOut>>3
;		ecx = lBitsInOut
;

get_next_coefficient:
;  use dword load & bitswap to achieve big endian ordering
	mov       eax, [esi+ebx]			; *** PROBABLE MALALIGNMENT ***
	and       ecx, 7					; shift value

	bswap     eax						; big endian order
										; *** NOT PAIRABLE ***

	shl       eax, cl					; left justify buffer
										; *** NOT PAIRABLE ***
										; *** 4 CYCLES ***
 	
;  do table lookups
	mov       ebx, eax					; ebx for major table
	mov       ecx, eax					; ecx for minor table

	shr       ebx, 24					; major table lookup

	shr       ecx, 17					; minor table lookup (with garbage)

	and       ecx, 0ffch				; mask off garbage for minor table
	mov       edx, [MajorTbl+4*ebx]		; get the major table value

	cmp       dl, 0						; run != 0 signals major table hit
	jne       @f						; if hit major

	test      edx, edx					; escape code's value is 0
	jz 	      escape_code				; handle escape by major table.

	mov       edx, [MinorTbl+ecx]		; else use minor table
											 
;
;  Input is edx = Table Value.
;  See function header for the meaning of its fields.
;  Now we decode the event, extracting the run, value, last.
;
@@:	
	cmp       dl, 0						; test for invalid code (run == 0)
	je        error

	movd      mm1, edx					; mm0 = table value
										;  (level = bits 31-16)
	movq      mm0, mm1
	psrad     mm1, 31					; dword mask = -1|0 for L neg|pos

	pmullw    mm0, mm2					; L *= 2Q
	mov       ecx, edx					; codeword to ecx to get run

	movq      mm4, mm3					; Q or Q-1
	and       ecx, 0ffh					; run for this coefficient

	pxor      mm4, mm1					; 1s complement if L negative
 	mov       ebx, [lCumulativeRun]		; ebx = old total run

	psubw     mm4, mm1					; 2s complement if L negative
	add       ebx, ecx					; ebx = new cumulative run

	paddw     mm0, mm4					; L +-== Q
	cmp       ebx, 03fh					; check run for bitstream error

	jg        error

  	mov       [lCumulativeRun], ebx		; update the cumulative run
	mov       ebx, [RunTbl+4*ebx]		; ebx = index of the current coefficient

	mov       [edi+4], ebx				; save coefficient's index
	add       edi, 8					; increment coefficient pointer

	movd      mm4, [Scale+4*ebx]		; get normalized scale factor

	shr       edx, 8					; last & bits to bottom
	pmaddwd   mm0, mm4					; multiply by normalized scale factor

	mov       ecx, [lBitsInOut]			; ecx = old number of bits used
	mov       eax, edx					; codeword to eax to get bits

	inc       ebp						; increment number of coefficients read
	and       eax, 07fh					; bits used for this coefficient

	add       ecx, eax					; ecx = new total bits used
	paddd     mm0, mm5					; add rounding bit

 	mov       ebx, ecx					; ebx = lBitsInOut
	psrad     mm0, 10					; shift to get 7 fraction bits rounded

	shr       ebx, 3					; offset for bitstream load
	mov       [lBitsInOut], ecx			; update number of bits used

 	movd      [edi-8], mm0				; save coefficient's signed, scaled value

	cmp       dl, 080h					; check last bit
	jb        get_next_coefficient	 	

finish:
	pop       ecx						; lpN = pointer to number of coeffients
	pop       eax						; lBitsInOut = total bits used

	pop       edx						; lCumulativeRun								
	pop       ebx								

	mov       [ecx], ebp				; store number of coefficients read
	pop       edi

	pop       esi
	pop       ebp

	ret


;
;  Input is eax = bitstream.  
;  See the H.263 spec for the meaning of its fields.
;  Now we decode the event, extracting the run, value, last.
;
escape_code:								
	test      eax, 0001fc00h			; test for invalid codes
	jz        error

	movd      mm0, eax					; mm0 = table value 
										;  (level = bits 17-10)

	mov       ecx, eax					; preserve codeword in eax
	pslld     mm0, 14					; move up to dword boundary
										;  (level = bits 31-24)

	movq      mm1, mm0					; mm1 = mask
	psraw     mm0, 8					; sign extend level

	psrad     mm1, 31					; dword mask = -1|0 for L neg|pos
	pmullw    mm0, mm2					; L *= 2Q

	shr       ecx, 18					; run to bottom
	movq      mm4, mm3					; Q or Q-1

 	mov       ebx, [lCumulativeRun]		; ebx = old total run
	pxor      mm4, mm1					; 1s complement if L negative

	and       ecx, 3fh					; mask off bottom 6 bits for run
	psubw     mm4, mm1					; 2s complement if L negative

	inc       ebx						; old run ++
	paddw     mm0, mm4					; L +-== Q
	
	add       ebx, ecx					; ebx = new cumulative run
	mov       ecx, [lBitsInOut]			; ebx = number of bits used

	cmp       ebx, 03fh					; check run for bitstream error
	ja        error

  	mov       [lCumulativeRun], ebx		; update the cumulative run
	paddsw    mm0, mm6					; add max_pos - High

	mov       ebx, [RunTbl+4*ebx]		; ebx = index of the current coefficient
	psubusw   mm0, mm7					; sub max_pos - High + Low

	paddw     mm0, [MidClip]			; add Low

	movd      mm4, [Scale+4*ebx]		; fetch normalized scale factor

	pmaddwd   mm0, mm4					; multiply by normalized scale factor
	add       ecx, 22					; escape code uses 22 bits

	mov       [edi+4], ebx				; save coefficient's index
	add       edi, 8					; increment coefficient pointer

	inc       ebp						; increment number of coefficients read
 	mov       ebx, ecx					; ebx = lBitsInOut

	shr       ebx, 3					; offset for bitstream load
	paddd     mm0, mm5					; add rounding bit

	mov       [lBitsInOut], ecx			; update number of bits used
	psrad     mm0, 10					; shift to get 7 fraction bits rounded

										; *** 1 cycle load penalty delay ***
 	movd      [edi-8], mm0				; save coefficient's signed, scaled value

	test      eax, 01000000h			; check last bit
	jz        get_next_coefficient	 	

	jmp       finish
				
error:
	pop       ecx						; lpN = pointer to number of coeffients
	pop       eax						; lBitsInOut = total bits used

	pop       edx						; lCumulativeRun
	xor       eax, eax					; zero bits used indicates ERROR

	pop	      ebx								
	pop       edi

	pop	      esi
	pop       ebp

	ret

;         11111111112222222222333333333344444444445555555555666666666677777777778
;12345678901234567890123456789012345678901234567890123456789012345678901234567890
;--------------------------------------------------------------------------------
MMX_VLD_RLD_IQ_Block ENDP

IACODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mmc.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/
;/* *************************************************************************
;** $Header:   S:\h26x\src\dec\d3mmc.asv   1.1   14 Mar 1996 14:34:54   AGUPTA2  $
;** $Log:   S:\h26x\src\dec\d3mmc.asv  $
;// 
;//    Rev 1.1   14 Mar 1996 14:34:54   AGUPTA2
;// 
;// Added alignment directives.
;// 
;//    Rev 1.0   14 Mar 1996 14:32:58   AGUPTA2
;// Initial revision.
;** *************************************************************************
;*/
.586
.model flat
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
C0101010101010101H DD 001010101H, 001010101H
CfefefefefefefefeH DD 0fefefefeH, 0fefefefeH
CfcfcfcfcfcfcfcfcH DD 0fcfcfcfcH, 0fcfcfcfcH
C0303030303030303H DD 003030303H, 003030303H
TWO                DD 002020202H, 002020202H
MMXDATA1 ENDS

PITCH TEXTEQU <384>

MMXCODE1 SEGMENT
;  @MMX_Interpolate_Int_Half
;    This routine computes interpolated pels shown by 'x' for a an 8x8 block
;    of pels.  'x' is computed by the formula (A+B+1)/2.  The input and output
;    pitch is assumed to be 384 (PITCH).
;      A   .   .   .   .   .   .   .
;      x   x   x   x   x   x   x   x
;      B   .   .   .   .   .   .   .
;    The basic instruction sequence is:
;      movq  V0, A
;      movq  V2, B
;      movq  V1, V0
;      por   V1, V2
;      pand  V1, 0x0101010101010101
;      pand  V0, 0xfefefefefefefefe
;      psrlq V0, 1
;      pand  V2, 0xfefefefefefefefe
;      psrlq V2, 1
;      paddb V0, V1
;      paddb V0, V2
;      movq  dest, V0
;    The instruction sequence for line 0 is 12 instructions.  The instruction
;    sequence for line 1 should be 12 instructions but is not because some of
;    the values needed for line 1 have already been computed for line 0.
;
;    Registers used for lines 0-7 are:
;      line 0: mm0, mm1, mm2
;      line 1: mm2, mm3, mm4
;      line 2: mm4, mm5, mm0
;      line 3: mm0, mm1, mm2
;      line 4: mm2, mm3, mm4
;      line 5: mm4, mm5, mm0
;      line 6: mm0, mm1, mm2
;      line 7: mm2, mm3, mm4
;    Constants 0x0101010101010101 and 0xfefefefefefefefe are in mm6 and mm7,
;    respectively.
;  Parameters:
;    The source block parameter should be in ecx and the destination block
;    parameter should be in edx; i.e. it uses fastcall calling convention.
;    (I am not aware of a way to declare a MASM function of type __fastcall.)
;  Performance:
;    41 cycles ignoring unaligned memory accesses
;    68 cycles if all loads are unaligned (41+9*3); stores should always be
;    aligned.
ALIGN 4
@MMX_Interpolate_Int_Half@8 PROC
  EXTRACTLOWBIT TEXTEQU <mm6>
  CLEARLOWBIT   TEXTEQU <mm7>
  movq       mm0, [ecx]                      ;0
   ;
  movq       mm2, [ecx+PITCH]                ;0
   movq      mm1, mm0                        ;0
  movq       mm6, C0101010101010101H         ;
   movq      mm3, mm2                        ;1
  movq       mm7, CfefefefefefefefeH         ;
   por       mm1, mm2                        ;0
  pand       mm0, CLEARLOWBIT                ;0
   pand      mm2, CLEARLOWBIT                ;0
  psrlq      mm0, 1                          ;0
   pand      mm1, EXTRACTLOWBIT              ;0
  movq       mm4, [ecx+2*PITCH]              ;1
   psrlq     mm2, 1                          ;0
  paddb      mm0, mm1                        ;0
   movq      mm5, mm4                        ;2
  paddb      mm0, mm2                        ;0
   por       mm3, mm4                        ;1
  pand       mm4, CLEARLOWBIT                ;1
   pand      mm3, EXTRACTLOWBIT              ;1
  movq       [edx+0*PITCH], mm0              ;0
   psrlq     mm4, 1                          ;1
  movq       mm0, [ecx+3*PITCH]              ;2
   paddb     mm2, mm3                        ;1
  movq       mm1, mm0                        ;3
   paddb     mm2, mm4                        ;1
  por        mm5, mm0                        ;2
   pand      mm0, CLEARLOWBIT                ;2
  movq       [edx+1*PITCH], mm2              ;1
   psrlq     mm0, 1                          ;2
  paddb      mm4, mm0                        ;2
   pand      mm5, EXTRACTLOWBIT              ;2
  movq       mm2, [ecx+4*PITCH]              ;3
   paddb     mm4, mm5                        ;2
  por        mm1, mm2                        ;3
   movq      mm3, mm2                        ;4
  movq       [edx+2*PITCH],mm4               ;2
   pand      mm2, CLEARLOWBIT                ;3
  psrlq      mm2, 1                          ;3
   pand      mm1, EXTRACTLOWBIT              ;3
  movq       mm4, [ecx+5*PITCH]              ;4
   paddb     mm0, mm1                        ;3
  movq       mm5, mm4                        ;5
   paddb     mm0, mm2                        ;3
  por        mm3, mm4                        ;4
   pand      mm4, CLEARLOWBIT                ;4
  movq       [edx+3*PITCH],mm0               ;3
   pand      mm3, EXTRACTLOWBIT              ;4
  movq       mm0, [ecx+6*PITCH]              ;5
   psrlq     mm4, 1                          ;4
  movq       mm1, mm0                        ;6
   paddb     mm2, mm3                        ;4
  paddb      mm2, mm4                        ;4
   por       mm5, mm0                        ;5
  pand       mm0, CLEARLOWBIT                ;5
   pand      mm5, EXTRACTLOWBIT              ;5
  movq       [edx+4*PITCH], mm2              ;4
   psrlq     mm0, 1                          ;5
  movq       mm2, [ecx+7*PITCH]              ;6
   paddb     mm4, mm5                        ;5
  movq       mm3, mm2                        ;7
   paddb     mm4, mm0                        ;5
  por        mm1, mm2                        ;6
   pand      mm2, CLEARLOWBIT                ;6
  movq       [edx+5*PITCH], mm4              ;5
   pand      mm1, EXTRACTLOWBIT              ;6
  movq       mm4, [ecx+8*PITCH]              ;7
   psrlq     mm2, 1                          ;6
  por        mm3, mm4                        ;7
   paddb     mm0, mm1                        ;6
  paddb      mm0, mm2                        ;6
   pand      mm3, EXTRACTLOWBIT              ;7
  pand       mm4, CLEARLOWBIT                ;7
   paddb     mm3, mm2                        ;7
  movq       [edx+6*PITCH], mm0              ;6
   psrlq     mm4, 1                          ;7
  paddb      mm3, mm4                        ;7
   ;
  ;
   ;
  movq       [edx+7*PITCH], mm3              ;7
   ret
  EXTRACTLOWBIT TEXTEQU <>
  CLEARLOWBIT   TEXTEQU <>
@MMX_Interpolate_Int_Half@8 endp


;  @MMX_Interpolate_Half_Int
;    This routine computes interpolated pels shown by 'x' for a an 8x8 block
;    of pels.  'x' is computed by the formula (A+B+1)/2.  The input and output
;    pitch is assumed to be 384 (PITCH).
;      A X B X . X . X . X . X . X . X
;    The basic instruction sequence is:
;      movq  V0, A
;      movq  V2, B
;      movq  V1, V0
;      por   V1, V2
;      pand  V1, 0x0101010101010101
;      pand  V0, 0xfefefefefefefefe
;      psrlq V0, 1
;      pand  V2, 0xfefefefefefefefe
;      psrlq V2, 1
;      paddb V0, V1
;      paddb V0, V2
;      movq  dest, V0
;    The instruction sequence for all lines is 12 instructions.
;
;    Registers used for lines 0-7 are:
;      line 0: mm0, mm1, mm2
;      line 1: mm3, mm4, mm5
;      line 2: mm0, mm1, mm2
;      line 3: mm3, mm4, mm5
;      line 4: mm0, mm1, mm2
;      line 5: mm3, mm4, mm5
;      line 6: mm0, mm1, mm2
;      line 7: mm3, mm4, mm5
;    Constants 0x0101010101010101 and 0xfefefefefefefefe are in mm6 and mm7,
;    respectively.
;  Parameters:
;    The source block parameter should be in ecx and the destination block
;    parameter should be in edx; i.e. it uses fastcall calling convention.
;  Performance:
;    51 cycles ignoring unaligned memory accesses
;    99 cycles if all loads are unaligned (51+8*6); stores should always be
;    aligned.
ALIGN 4
@MMX_Interpolate_Half_Int@8  proc
  EXTRACTLOWBIT TEXTEQU <mm6>
  CLEARLOWBIT   TEXTEQU <mm7>
  movq       mm0, [ecx]                      ;0 mm0,mm1=left pels
   ;                                         ;  mm2    =right pels
  movq       mm2, [ecx+1]                    ;0 mm1    =interp pels
   movq      mm1, mm0                        ;0
  movq       mm7, CfefefefefefefefeH         ;
   por       mm1, mm2                        ;0
  movq       mm6, C0101010101010101H         ;
   pand      mm0, CLEARLOWBIT                ;0
  pand       mm2, CLEARLOWBIT                ;0
   psrlq     mm0, 1                          ;0
  psrlq      mm2, 1                          ;0
   pand      mm1, EXTRACTLOWBIT              ;0
  movq       mm3, [ecx+1*PITCH]              ;1 mm3,mm4=left pels
   paddb     mm1, mm0                        ;0 mm5    =right pels
  movq       mm5, [ecx+1*PITCH+1]            ;1 mm4    =interp pels
   paddb     mm1, mm2                        ;0
  movq       mm4, mm3                        ;1
   pand      mm3, CLEARLOWBIT                ;1
  movq       [edx], mm1                      ;0
   por       mm4, mm5                        ;1
  psrlq      mm3, 1                          ;1
   pand      mm5, CLEARLOWBIT                ;1
  psrlq      mm5, 1                          ;1
   pand      mm4, EXTRACTLOWBIT              ;1
  movq       mm0, [ecx+2*PITCH]              ;2 mm0,mm1=left pels
   paddb     mm4, mm3                        ;1 mm2    =right pels
  movq       mm2, [ecx+2*PITCH+1]            ;2 mm1    =interp pels
   paddb     mm4, mm5                        ;1
  movq       mm1, mm0                        ;2
   pand      mm0, CLEARLOWBIT                ;2
  movq       [edx+1*PITCH], mm4              ;1
   por       mm1, mm2                        ;2
  psrlq      mm0, 1                          ;2
   pand      mm2, CLEARLOWBIT                ;2
  psrlq      mm2, 1                          ;2
   pand      mm1, EXTRACTLOWBIT              ;2
  movq       mm3, [ecx+3*PITCH]              ;3 mm3,mm4=left pels
   paddb     mm1, mm0                        ;2 mm5    =right pels
  movq       mm5, [ecx+3*PITCH+1]            ;3 mm4    =interp pels
   paddb     mm1, mm2                        ;2
  movq       mm4, mm3                        ;3
   pand      mm3, CLEARLOWBIT                ;3
  movq       [edx+2*PITCH], mm1              ;2
   por       mm4, mm5                        ;3
  psrlq      mm3, 1                          ;3
   pand      mm5, CLEARLOWBIT                ;3
  psrlq      mm5, 1                          ;3
   pand      mm4, EXTRACTLOWBIT              ;3
  movq       mm0, [ecx+4*PITCH]              ;4 mm0,mm1=left pels
   paddb     mm4, mm3                        ;3 mm2    =right pels
  movq       mm2, [ecx+4*PITCH+1]            ;4 mm1    =interp pels
   paddb     mm4, mm5                        ;3
  movq       mm1, mm0                        ;4
   pand      mm0, CLEARLOWBIT                ;4
  movq       [edx+3*PITCH], mm4              ;3
   por       mm1, mm2                        ;4
  psrlq      mm0, 1                          ;4
   pand      mm2, CLEARLOWBIT                ;4
  psrlq      mm2, 1                          ;4
   pand      mm1, EXTRACTLOWBIT              ;4
  movq       mm3, [ecx+5*PITCH]              ;5 mm3,mm4=left pels
   paddb     mm1, mm0                        ;4 mm5    =right pels
  movq       mm5, [ecx+5*PITCH+1]            ;5 mm4    =interp pels
   paddb     mm1, mm2                        ;4
  movq       mm4, mm3                        ;5
   pand      mm3, CLEARLOWBIT                ;5
  movq       [edx+4*PITCH], mm1              ;4
   por       mm4, mm5                        ;5
  psrlq      mm3, 1                          ;5
   pand      mm5, CLEARLOWBIT                ;5
  psrlq      mm5, 1                          ;5
   pand      mm4, EXTRACTLOWBIT              ;5
  movq       mm0, [ecx+6*PITCH]              ;6 mm0,mm1=left pels
   paddb     mm4, mm3                        ;5 mm2    =right pels
  movq       mm2, [ecx+6*PITCH+1]            ;6 mm1    =interp pels
   paddb     mm4, mm5                        ;5
  movq       mm1, mm0                        ;6
   pand      mm0, CLEARLOWBIT                ;6
  movq       [edx+5*PITCH], mm4              ;5
   por       mm1, mm2                        ;6
  psrlq      mm0, 1                          ;6
   pand      mm2, CLEARLOWBIT                ;6
  psrlq      mm2, 1                          ;6
   pand      mm1, EXTRACTLOWBIT              ;6
  movq       mm3, [ecx+7*PITCH]              ;7 mm3,mm4=left pels
   paddb     mm1, mm0                        ;6 mm5    =right pels
  movq       mm5, [ecx+7*PITCH+1]            ;7 mm4    =interp pels
   paddb     mm1, mm2                        ;6
  movq       mm4, mm3                        ;7
   pand      mm3, CLEARLOWBIT                ;7
  por        mm4, mm5                        ;7
   psrlq     mm3, 1                          ;7
  pand       mm4, EXTRACTLOWBIT              ;7
   pand      mm5, CLEARLOWBIT                ;7
  psrlq      mm5, 1                          ;7
   paddb     mm4, mm3                        ;7
  movq       [edx+6*PITCH], mm1              ;6
   paddb     mm4, mm5                        ;7
  ;
   ;
  movq       [edx+7*PITCH], mm4              ;7
   ret
  EXTRACTLOWBIT TEXTEQU <>
  CLEARLOWBIT   TEXTEQU <>
@MMX_Interpolate_Half_Int@8 endp


;  @MMX_Interpolate_Half_Half
;    This routine computes interpolated pels shown by 'X' for a an 8x8 block
;    of pels.  'x' is computed by the formula (A+B+C+D+2)/4.  The input and
;    output pitch is assumed to be 384 (PITCH).
;      A   B
;        X
;      C   D
;    The value (A+B+C+D+2)/4 is computed as (A'+B'+C'+D')+((A*+B*+C*+D*+2)/4)
;    where A = 4*A' + A*, etc.
;  Parameters:
;    The source block parameter should be in ecx and the destination block
;    parameter should be in edx; i.e. it uses fastcall calling convention.
;  Performance:
;    84  cycles ignoring unaligned memory accesses
;    138 cycles if all loads are unaligned (84+9*2*3); stores should always be
;    aligned.  Average cycle count will be less than 138.
ALIGN 4
@MMX_Interpolate_Half_Half@8 proc
  EXTRACTLOWBITS TEXTEQU <mm6>
  CLEARLOWBITS   TEXTEQU <mm7>
  movq       mm0, [ecx]                      ;0   A(mm0,mm1)  B(mm4,mm5)
   ;                                                     0
  movq       mm7, CfcfcfcfcfcfcfcfcH         ;    C(mm2,mm3)  D(mm4,mm5)
   movq      mm1, mm0                        ;0
  movq       mm4, [ecx+1]                    ;0
   pand      mm0, CLEARLOWBITS               ;0
  movq       mm6, C0303030303030303H         ;
   movq      mm5, mm4                        ;0
  pand       mm4, CLEARLOWBITS               ;0
   pand      mm1, EXTRACTLOWBITS             ;0
  psrlq      mm0, 2                          ;0
   pand      mm5, EXTRACTLOWBITS             ;0
  psrlq      mm4, 2                          ;0
   paddb     mm1, mm5                        ;0 (A+B) low
  movq       mm2, [ecx+1*PITCH]              ;0
   paddb     mm0, mm4                        ;0 (A+B)/4 high
  movq       mm4, [ecx+1*PITCH+1]            ;0
   movq      mm3, mm2                        ;0
  pand       mm3, EXTRACTLOWBITS             ;0
   movq      mm5, mm4                        ;0
  pand       mm5, EXTRACTLOWBITS             ;0
   pand      mm2, CLEARLOWBITS               ;0
  pand       mm4, CLEARLOWBITS               ;0
   paddb     mm3, mm5                        ;0 (C+D) low
  paddb      mm3, TWO                        ;0 (C+D+2) low = mm3
   psrlq     mm2, 2                          ;0
  paddb      mm1, mm3                        ;0 (A+B+C+D+2) low
   psrlq     mm4, 2                          ;0
  paddb      mm2, mm4                        ;0 (C+D)/4 high = mm2
   psrlq     mm1, 2                          ;0 (A+B+C+D+2)/4 low dirty
  paddb      mm0, mm2                        ;0 (A+B+C+D)/4 high
   pand      mm1, EXTRACTLOWBITS             ;0 (A+B+C+D+2)/4 low clean
  movq       mm4, [ecx+2*PITCH]              ;1   high(mm2)   low(mm3)
   paddb     mm0, mm1                        ;0	         1
  movq       mm1, [ecx+2*PITCH+1]            ;1   C(mm4,mm5)  D(mm0,mm1)
   movq      mm5, mm4                        ;1
  movq       [edx], mm0                      ;0
   movq      mm0, mm1                        ;1
  pand       mm0, CLEARLOWBITS               ;1
   pand      mm4, CLEARLOWBITS               ;1
  psrlq      mm0, 2                          ;1
   pand      mm1, EXTRACTLOWBITS             ;1
  psrlq      mm4, 2                          ;1
   pand      mm5, EXTRACTLOWBITS             ;1
  paddb      mm0, mm4                        ;1 (C+D)/4 high = mm0
   paddb     mm1, mm5                        ;1 (C+D) low
  paddb      mm2, mm0                        ;1 (A+B+C+D)/4 high
   paddb     mm3, mm1                        ;1 (A+B+C+D+2) low
  movq       mm4, [ecx+3*PITCH]              ;2
   psrlq     mm3, 2                          ;1 (A+B+C+D+2)/4 low dirty
  movq       mm5, mm4                        ;2   high(mm0)   low(mm1)
   pand      mm3, EXTRACTLOWBITS             ;1	         2
  paddb      mm2, mm3                        ;1	  C(mm4,mm5)  D(mm2,mm3)
   pand      mm5, EXTRACTLOWBITS             ;2
  movq       mm3, [ecx+3*PITCH+1]            ;2
   pand      mm4, CLEARLOWBITS               ;2
  movq       [edx+1*PITCH], mm2              ;1
   movq      mm2, mm3                        ;2
  pand       mm3, EXTRACTLOWBITS             ;2
   pand      mm2, CLEARLOWBITS               ;2
  psrlq      mm4, 2                          ;2
   paddb     mm3, mm5                        ;2
  paddb      mm3, TWO                        ;2 (C+D+2) low = mm3
   psrlq     mm2, 2                          ;2
  paddb      mm1, mm3                        ;2 (A+B+C+D+2) low
   paddb     mm2, mm4                        ;2 (C+D)/4 hign = mm2
  psrlq      mm1, 2                          ;2 (A+B+C+D+2)/4 low dirty
   paddb     mm0, mm2                        ;2 (A+B+C+D)/4 high
  movq       mm4, [ecx+4*PITCH]              ;3   high(mm2)   low(mm3)
   pand      mm1, EXTRACTLOWBITS             ;2	         3
  movq       mm5, mm4                        ;3	  C(mm4,mm5)  D(mm0,mm1)
   paddb     mm0, mm1                        ;2
  movq       mm1, [ecx+4*PITCH+1]            ;3
   pand      mm4, CLEARLOWBITS               ;3
  movq       [edx+2*PITCH], mm0              ;2
   movq      mm0, mm1                        ;3
  pand       mm0, CLEARLOWBITS               ;3
   pand      mm1, EXTRACTLOWBITS             ;3
  psrlq      mm0, 2                          ;3
   pand      mm5, EXTRACTLOWBITS             ;3
  psrlq      mm4, 2                          ;3
   paddb     mm1, mm5                        ;3 (C+D) low = mm1
  paddb      mm0, mm4                        ;3 (C+D)/4 high = mm0
   paddb     mm3, mm1                        ;3 (A+B+C+D+2) low
  paddb      mm2, mm0                        ;3 (A+B+C+D)/4 high
   psrlq     mm3, 2                          ;3 (A+B+C+D+2)/4 low dirty
  movq       mm4, [ecx+5*PITCH]              ;4
   pand      mm3, EXTRACTLOWBITS             ;3 (A+B+C+D+2)/4 low clean
  movq       mm5, mm4                        ;4
   paddb     mm2, mm3                        ;3   high(mm0)   low(mm1)
  movq       mm3, [ecx+5*PITCH+1]            ;4	         4
   pand      mm4, CLEARLOWBITS               ;4	  C(mm4,mm5)  D(mm2,mm3)
  movq       [edx+3*PITCH], mm2              ;3
   movq      mm2, mm3                        ;4
  pand       mm2, CLEARLOWBITS               ;4
   pand      mm5, EXTRACTLOWBITS             ;4
  psrlq      mm4, 2                          ;4
   pand      mm3, EXTRACTLOWBITS             ;4
  psrlq      mm2, 2                          ;4
   paddb     mm3, mm5                        ;4
  paddb      mm3, TWO                        ;4 (C+D+2) low  = mm3
   paddb     mm2, mm4                        ;4 (C+D)/4 high = mm2
  paddb      mm1, mm3                        ;4 (A+B+C+D+2) low
   paddb     mm0, mm2                        ;4 (A+B+C+D)/4 high
  movq       mm4, [ecx+6*PITCH]              ;5
   psrlq     mm1, 2                          ;4 (A+B+C+D+2)/4 low dirty
  movq       mm5, mm4                        ;5
   pand      mm1, EXTRACTLOWBITS             ;4 (A+B+C+D+2)/4 low clean
  paddb      mm0, mm1                        ;4
   pand      mm4, CLEARLOWBITS               ;5   high(mm2)   low(mm3)
  movq       mm1, [ecx+6*PITCH+1]            ;5	         5
   psrlq     mm4, 2                          ;5	  C(mm4,mm5)  D(mm0,mm1)
  movq       [edx+4*PITCH], mm0              ;4
   movq      mm0, mm1                        ;5
  pand       mm1, EXTRACTLOWBITS             ;5
   pand      mm5, EXTRACTLOWBITS             ;5
  pand       mm0, CLEARLOWBITS               ;5
   paddb     mm1, mm5                        ;5 (C+D) low = mm1
  psrlq      mm0, 2                          ;5
   paddb     mm3, mm1                        ;5 (A+B+C+D+2) low
  psrlq      mm3, 2                          ;5 (A+B+C+D+2)/4 low dirty
   paddb     mm0, mm4                        ;5 (C+D)/4 high = mm0
  pand       mm3, EXTRACTLOWBITS             ;5 (A+B+C+D+2)/4 low clean
   paddb     mm2, mm0                        ;5 (A+B+C+D)/4 high
  movq       mm4, [ecx+7*PITCH]              ;6   high(mm0)   low(mm1)
   paddb     mm2, mm3                        ;5	         6
  movq       mm3, [ecx+7*PITCH+1]            ;6	  C(mm4,mm5)  D(mm2,mm3)
   movq      mm5, mm4                        ;6
  movq       [edx+5*PITCH], mm2              ;5
   movq      mm2, mm3                        ;6
  pand       mm5, EXTRACTLOWBITS             ;6
   pand      mm3, EXTRACTLOWBITS             ;6
  pand       mm2, CLEARLOWBITS               ;6
   paddb     mm3, mm5                        ;6
  pand       mm4, CLEARLOWBITS               ;6
   psrlq     mm2, 2                          ;6
  paddb      mm3, TWO                        ;6 (C+D+2) low = mm3
   psrlq     mm4, 2                          ;6
  paddb      mm2, mm4                        ;6 (C+D)/4 high = mm2
   paddb     mm1, mm3                        ;6 (A+B+C+D+2) low
  paddb      mm0, mm2                        ;6 (A+B+C+D)/4 high
   psrlq     mm1, 2                          ;6 (A+B+C+D+2)/4 low dirty
  movq       mm4, [ecx+8*PITCH]              ;7   high(mm2)   low(mm3)
   pand      mm1, EXTRACTLOWBITS             ;6	         7
  movq       mm5, mm4                        ;7	  C(mm4,mm5)  D(mm0,mm1)
   paddb     mm0, mm1                        ;6
  movq       mm1, [ecx+8*PITCH+1]            ;7
   pand      mm4, CLEARLOWBITS               ;7
  movq       [edx+6*PITCH], mm0              ;6
   movq      mm0, mm1                        ;7
  pand       mm0, CLEARLOWBITS               ;7
   pand      mm5, EXTRACTLOWBITS             ;7
  psrlq      mm4, 2                          ;7
   pand      mm1, EXTRACTLOWBITS             ;7
  psrlq      mm0, 2                          ;7
   paddb     mm1, mm5                        ;7 (C+D) low
  paddb      mm0, mm4                        ;7 (C+D)/4 high
   paddb     mm3, mm1                        ;7 (A+B+C+D+2) low
  psrlq      mm3, 2                          ;7 (A+B+C+D+2)/4 low dirty
   paddb     mm2, mm0                        ;7 (A+B+C+D)/4 high
  pand       mm3, EXTRACTLOWBITS             ;7 (A+B+C+D+2)/4 low clean
   ;
  paddb      mm2, mm3                        ;7
   ;
  ;
   ;
  movq       [edx+7*PITCH], mm2              ;7
   ret
  EXTRACTLOWBITS TEXTEQU <>
  CLEARLOWBITS   TEXTEQU <>
@MMX_Interpolate_Half_Half@8 endp

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mbimot.asm ===
;--------------------------------------------------------------------------;
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  D3mBiMot.asm
;
;  Description:
;    This module does bi-directional motion compensated prediction for 
;    B frames.  It is called after forward prediction has been computed
;    and will average in the backward prediction for those pels where 
;    the backward motion vector points inside of the referenced P frame.
;
;  MMx Version
;
;  Routines:                          prototypes in:
;    MMX_BiMotionComp                 none
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d3mbimot.asv   1.2   01 Apr 1996 12:35:48   RMCKENZX  $
;  $Log:   S:\h26x\src\dec\d3mbimot.asv  $
;// 
;//    Rev 1.2   01 Apr 1996 12:35:48   RMCKENZX
;// 
;// Added MMXCODE1 and MMXDATA1 segments, moved global data
;// to MMXDATA1 segment.
;// 
;//    Rev 1.1   14 Mar 1996 13:58:00   RMCKENZX
;// 
;// Optimized routine for speed of execution.
;// 
;//    Rev 1.0   07 Mar 1996 18:36:36   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  Routine Name:
;    MMX_BiMotionComp(U32, U32, I32, I32, I32)
;
;  Inputs -- C calling convention:
;    pPrev       flat pointer to prediction from previous P frame
;                used for "forward" motion vector prediction.
;    pCurr       flat pointer into current P frame
;                to be used for "backward" motion vector prediction.
;    mvx         x component of backward motion vector.
;    mvy         y component of backward motion vector.
;    iNum        block number.
;
;  Returns:
;    updates the values pointed to by pPrev.
;
;--------------------------------------------------------------------------;
;
;  Version:     .006
;  Date:        14 March 1996
;  Author:      R. McKenzie
;
;--------------------------------------------------------------------------;

.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

;-------------------;
;     Stack Use     ;
;-------------------;

; register storage (rel to old stack ptr as saved in ebp)
;	esi               ebp+00
;	edi               ebp+04
;	ebp               ebp+08
;	ebx               ebp+12

; return address      ebp+16

; C input parameters
  pPrev        EQU    ebp+20
  pCurr        EQU    ebp+24
  mvx          EQU    ebp+28
  mvy          EQU    ebp+32
  iNum         EQU    ebp+36


; local variables
  uColEnd      EQU    esp+00
  uRowEnd      EQU    esp+02
  uColStart    EQU    esp+04
  uRowStart    EQU    esp+06
  mmxTempL     EQU    esp+08
  mmxTempH     EQU    esp+16


  PITCH         =     384
  FRAMESIZE     =      32

MMXDATA1 SEGMENT
ALIGN 8
                         ;     End        Start
                         ;  Row   Col   Row   Col
                         ;   y     x     y     x
mmxFudge        DWORD       001e001eh,  00010001h 
                DWORD       001e000eh,  0001fff1h 
                DWORD       000e001eh, 0fff10001h 
                DWORD       000e000eh, 0fff1fff1h 
                DWORD       000e000eh,  00010001h
                DWORD       000e000eh,  00010001h

mmxClipT        DWORD       7ff87ff8h,  7ff77ff7h
mmxClipB        DWORD       7ff77ff7h,  7ff77ff7h
                                                    ; start
ColStartMask    DWORD      0ffffffffh, 0ffffffffh   ;   0
                DWORD      0ffffff00h, 0ffffffffh   ;   1      
                DWORD      0ffff0000h, 0ffffffffh   ;   2      
                DWORD      0ff000000h, 0ffffffffh   ;   3      
                DWORD       00000000h, 0ffffffffh   ;   4      
                DWORD       00000000h, 0ffffff00h   ;   5      
                DWORD       00000000h, 0ffff0000h   ;   6      
                DWORD       00000000h, 0ff000000h   ;   7    end      
ColEndMask      DWORD       00000000h,  00000000h   ;   8     0      
                DWORD       000000ffh,  00000000h   ;         1      
                DWORD       0000ffffh,  00000000h   ;         2      
                DWORD       00ffffffh,  00000000h   ;         3      
                DWORD      0ffffffffh,  00000000h   ;         4      
                DWORD      0ffffffffh,  000000ffh   ;         5      
                DWORD      0ffffffffh,  0000ffffh   ;         6      
                DWORD      0ffffffffh,  00ffffffh   ;         7
                DWORD      0ffffffffh, 0ffffffffh   ;         8

ShiftMask       DWORD       7f7f7f7fh,  7f7f7f7fh	; used for byte shifts
BottomBitMask   DWORD       01010101h,  01010101h	; used for packed averages
Round1          DWORD       00010001h,  00010001h

MMXDATA1 ENDS


;-------------------;
;      Set Up       ;
;-------------------;
MMXCODE1 SEGMENT

PUBLIC C MMX_BiMotionComp

MMX_BiMotionComp:
  push       ebx
  push       ebp

  push       edi
  push       esi

  mov        ebp, esp
  and        esp, -32                    ; align the stack on a cache line

  sub        esp, FRAMESIZE              ; make room for locals

  mov        edi, [iNum]
  mov        esi, [pCurr]

                                         ;         start      end
  movd       mm1, [mvx]				     ; mm1 = 0000 0000 .... .mvx

  movd       mm2, [mvy]                  ; mm2 = 0000 0000 .... .mvy

  movq       mm0, [mmxFudge+8*edi]
  punpcklwd  mm1, mm2                    ; mm1 = .... .... .mvy .mvx

  movq       mm3, [mmxClipT]
  punpckldq  mm1, mm1                    ; mm1 = .mvy .mvx .mvy .mvx

  movq       mm4, [mmxClipB]
  psubw      mm0, mm1

  mov        edi, [pPrev]
  psraw      mm0, 1                      ; mm0 = RowStart ColStart RowEnd ColEnd

  mov        ebx, [mvy]
  paddsw     mm0, mm3                    ; clip at 8 or higher

  and        ebx, -2                     ; 2*(mvy>>1)
  psubusw    mm0, mm4				     ; clip at 0 or lower

  shl        ebx, 6                      ; 128*(mvy>>1)
  mov        eax, [mvx]

  movq       [uColEnd], mm0

  sar        eax, 1                      ; mvx>>1
  lea        ebx, [ebx+2*ebx]            ; PITCH*(mvy>>1)

  add        esi, ebx                    ; pCurr += PITCH*(mvy>>1)
  xor        ecx, ecx

  add        esi, eax                    ; pCurr += mvx>>1
  xor        edx, edx

  mov        cl, [uColStart]             ; uColStart
  mov        dl, [uColEnd]               ; uColEnd

  cmp        ecx, edx                    ; iColCount = ColStart - ColEnd
  jge        hasta_la_vista_baby

  movq       mm6, ColStartMask[8*ecx]

  movq       mm7, ColEndMask[8*edx]
  pxor       mm4, mm4                    ; mm4 = 0

  mov        cl, [uRowStart]             ; RowStart
  mov        dl, [uRowEnd]               ; RowEnd

  sub        edx, ecx                    ; iRowCount = RowEnd - RowStart
  jle        hasta_la_vista_baby

  pand       mm7, mm6                    ; mm7 = ff for those cols to use back pred.
  pxor       mm6, mm6

  shl        ecx, 7                      ; 128*RowStart
  mov        eax, [mvx]

  movq       mm5, [ShiftMask]            ; mm5 = 7f 7f 7f 7f  7f 7f 7f 7f
  pcmpeqb    mm6, mm7                    ; mm6 is the complement of mm7
  
  lea        ecx, [ecx+2*ecx]            ; PITCH*RowStart
  mov        ebx, [mvy]

  add        esi, ecx                    ; pCurr += PITCH*RowStart
  add        edi, ecx                    ; pPrev += PITCH*RowStart        

  mov        ecx, PITCH


  and      eax, 1
  je       even_mvx

  and      ebx, 1
  je       odd_even

;
;  mvx is odd (horizontal half pel motion)
;  mvy is odd (vertical half pel motion)
;
odd_odd:
  movq       mm0, [esi+4]

  movq       mm1, mm0
  psrlq      mm0, 8

  movq       mm2, [esi]
  punpcklbw  mm1, mm4

  movq       mm3, mm2
  punpcklbw  mm0, mm4

  paddw      mm0, mm1
  psrlq      mm2, 8

  paddw      mm0, [Round1]
  punpcklbw  mm3, mm4

  punpcklbw  mm2, mm4
  add        esi, ecx

  movq       [mmxTempH], mm0
  paddw      mm2, mm3

  paddw      mm2, [Round1]

  sub        edi, ecx                    ; pre decrement destination pointer

  movq       [mmxTempL], mm2


;
;  This loop is 2-folded and works on 2 results (rows) per pass.
;  It finishes one result per iteration.
;
;  Stage I
;    computes the partial sums of a row with a shifted copy of the row.
;    It stores the partial sums for the next iteration's Stage II.
;  Stage II 
;    reads the partial sums of the prior row and averages them with the
;    just computed (in Stage I) partial sums of the current row to get
;    the backward prediction.  These computations are done unpacked as
;    16-bit words.  A rounding factor is added to each partial sum before
;    storage.  Then stage II averages the result (with truncation) with 
;    the forward prediction.
;
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging of the forward with backward is done packed in 8-bit bytes by 
;    dividing both inputs by 2, adding them together, and then adding in an 
;    adjustment.  To average with truncation, the adjustment is 1 when BOTH 
;    inputs are odd.  Due to the absence of a byte shift instruction, divide
;    by 2 is done by shifting the entire mmx register and then masking off 
;    (zeroing) bits , 15, ..., and 63 (the old low-order bits) using mm5.
;   
OddOddLoop:
  movq       mm1, [esi]                  ; load left half

  movq       mm0, mm1                    ; copy left half
  psrlq      mm1, 8                      ; shift left over

  movq       mm3, [esi+4]                ; load right half
  punpcklbw  mm0, mm4                    ; unpack left half

  movq       mm2, mm3                    ; copy right half
  punpcklbw  mm1, mm4                    ; unpack shifted left half

  paddw      mm1, mm0                    ; add left side
  psrlq      mm3, 8                      ; shift right over

  paddw      mm1, [Round1]               ; add in round to left
  punpcklbw  mm2, mm4                    ; unpack right half

  movq       mm0, [mmxTempL]             ; fetch prior row's left half
  punpcklbw  mm3, mm4                    ; unpack shifted right half

  movq       [mmxTempL], mm1             ; stash this row's left half
  paddw      mm3, mm2                    ; add right side

  paddw      mm3, [Round1]               ; add in round to right
  paddw      mm0, mm1                    ; sum current & prior lefts

  movq       mm2, [mmxTempH]             ; fetch prior row's right half
  psrlw      mm0, 2                      ; divide left sum by four

  movq       [mmxTempH], mm3             ; stash this rows right half
  paddw      mm2, mm3                    ; sum current & prior rights

  movq       mm1, [edi+ecx]              ; fetch forward prediction
  psrlw      mm2, 2                      ; divide right sum by four

  packuswb   mm0, mm2                    ; complete backward prediction
  movq       mm2, mm1                    ; copy forward

  pand       mm0, mm7                    ; mask off unused bytes
  pand       mm2, mm6                    ; create replacement bytes

  por        mm0, mm2                    ; new backward prediction
  movq       mm3, mm1                    ; copy forward for adjustment

  pand       mm3, mm0                    ; adjustment with truncation
  psrlq      mm0, 1                      ; divide new backward by 2

  pand       mm0, mm5                    ; clear extra bits
  psrlq      mm1, 1                      ; divide forward by 2

  pand       mm3, [BottomBitMask]        ; complete adjustment
  pand       mm1, mm5                    ; clear extra bits

  paddb      mm0, mm1                    ; sum quotients
  add        edi, ecx                    ; increment destination pointer

  paddb      mm0, mm3                    ; add addjustment
  add        esi, ecx                    ; increment source pointer

  movq       [edi], mm0                  ; store result
                                         ; *** 1 cycle store penalty ***

  dec        edx                         ; decrement loop control
  jg         OddOddLoop                  ; back up if not done


;  wrap up and go home
  mov        esp, ebp

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  ret


;
;  mvx is odd (horizontal half pel motion)
;  mvy is even (vertical full pel motion)
;
odd_even:
  sub        edi, ecx                    ; pre decrement destination pointer

;
;  This loop is not folded and does 1 result (row) per pass.
;
;    It loads the backward predicted row into mm0 and brings in the last
;    (eighth) byte through al, which is or'd with the shifted row.  It
;    completes the bacward prediction (by averaging the rows with round)
;    and averages the result (with truncation) with the forward prediction.
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging is done by dividing both inputs by 2, adding them together,
;    and then adding in an adjustment.
;    To average with round, the adjustment is 1 when EITHER input is odd. 
;    To average with truncation, the adjustment is 1 when BOTH inputs are odd.
;    Due to the absence of a byte shift instruction, divide by 2 is done
;    by shifting the entire mmx register and then masking off (zeroing) bits
;    7, 15, ..., and 63 (the old low-order bits) using mm5.
;   
OddEvenLoop:
  movq       mm0, [esi]                  ; fetch backward predicted row

  mov        al, [esi+8]                 ; fetch last byte
  movq       mm1, mm0                    ; copy row

  movd       mm2, eax                    ; last byte
  psrlq      mm0, 8	                     ; shift row right 1 byte

  movq       mm3, mm1                    ; copy row for adjustment
  psllq      mm2, 56                     ; move last byte to left end                     

  por        mm0, mm2                    ; or in last byte on left
  psrlq      mm1, 1                      ; divide row by 2

  por        mm3, mm0                    ; averaging with rounding bit
  psrlq      mm0, 1                      ; divide shifted row by 2

  pand       mm0, mm5                    ; clear extra bits
  pand       mm1, mm5                    ; clear extra bits

  pand       mm3, [BottomBitMask]        ; finish adjustment (with round)
  paddb      mm0, mm1                    ; sum quotients

  movq       mm4, [edi+ecx]              ; fetch forward prediction
  paddb      mm3, mm0                    ; add adjustment, got back pred.
  
  movq       mm2, mm4                    ; copy forward
  pand       mm3, mm7                    ; mask off unused bytes

  movq       mm1, mm4                    ; copy forward
  pand       mm2, mm6                    ; mask forward copy

  por        mm3, mm2                    ; backward with forward replacing
  psrlq      mm4, 1                      ; divide forward by 2

  pand       mm1, mm3                    ; adjustment for truncation
  psrlq      mm3, 1                      ; divide bacwards by 2

  pand       mm3, mm5                    ; clear extra bits
  pand       mm4, mm5                    ; clear extra bits

  pand       mm1, [BottomBitMask]        ; finish adjustment (with truncation)
  paddb      mm4, mm3                    ; sum quotients

  paddb      mm4, mm1                    ; add adjusment, have result
  add        edi, ecx                    ; increment destination pointer

  add        esi, ecx                    ; increment source pointer
  dec        edx                         ; decrement loop control

  movq       [edi], mm4                  ; save result

  jg         OddEvenLoop                 ; loop when not done


;  wrap up and go home
  mov        esp, ebp

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  ret

;---------------------------;
;  mvx is even -- test mvy  ;
;---------------------------;
even_mvx:
  and      ebx, 1
  je       even_even

;
;  mvx is even (horizontal full pel motion)
;  mvy is odd (vertical half pel motion)
;
even_odd:
  movq       mm0, [esi]                  ; 1:  first row

  movq       mm1, [esi+ecx]              ; 1:  second row
  movq       mm2, mm0                    ; 1:  copy for rounding

  por        mm2, mm1                    ; 1:  averaging with round
  sub        edi, ecx                    ; pre deccrement destination pointer

  dec        edx                         ; note that edx is positive on entry 
  jz         EvenOddPost

;
;  This loop is 2-folded and works on 2 results (rows) per pass.
;  It finishes one result per iteration.
;  Stage I
;    loads both backward predicted rows into mm0 and mm1, copies the first
;    into mm2, and ors with the second for the rounding adjustment.
;  Stage II
;    completes the bacward prediction (by averaging the rows with round)
;    and averages the result (with truncation) with the forward prediction.
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging is done by dividing both inputs by 2, adding them together,
;    and then adding in an adjustment (in mm2).
;    To average with round, the adjustment is 1 when EITHER input is odd. 
;    To average with truncation, the adjustment is 1 when BOTH inputs are odd.
;    Due to the absence of a byte shift instruction, divide by 2 is done
;    by shifting the entire mmx register and then masking off (zeroing) bits
;    7, 15, ..., and 63 (the old low-order bits) using mm5.
;   
EvenOddLoop:
  psrlq      mm0, 1                      ; 2:  divide first row by 2
  add        edi, ecx                    ; increment destination pointer

  psrlq      mm1, 1                      ; 2:  divide second row by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  rounding bits
  pand       mm1, mm5                    ; 2:  clear extra bits

  movq       mm3, [edi]                  ; 2:  fetch forward prediction
  paddb      mm1, mm0                    ; 2:  average backward rows

  paddb      mm1, mm2                    ; 2:  add in round
  movq       mm4, mm3                    ; 2:  copy for mask  

  pand       mm1, mm7                    ; 2:  masked backward prediction
  pand       mm4, mm6                    ; 2:  masked forward prediction

  por        mm4, mm1                    ; 2:  adjusted backwards prediction
  movq       mm2, mm3                    ; 2:  copy for rounding

  pand       mm2, mm4                    ; 2:  averaging with truncation
  psrlq      mm4, 1                      ; 2:  divide bacwards by 2

  psrlq      mm3, 1                      ; 2:  divide forwards by 2
  pand       mm4, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  "no-round" bits
  pand       mm3, mm5                    ; 2:  clear extra bits

  movq       mm0, [esi+ecx]              ; 1:  first row
  paddb      mm4, mm3                    ; 2:  average forward & backwards

  movq       mm1, [esi+2*ecx]            ; 1:  second row
  paddb      mm4, mm2                    ; 2:  add in "no-round" bits 

  movq       mm2, mm0                    ; 1:  copy for rounding
  add        esi, ecx                    ; increment source pointer

  movq       [edi], mm4                  ; 2:  store resulting row
  por        mm2, mm1                    ; 1:  averaging with rounding bit

  dec        edx                         ; decrement loop count
  jg         EvenOddLoop                 ; back up if not done

EvenOddPost:
  psrlq      mm0, 1                      ; 2:  divide first row by 2
  add        edi, ecx                    ; increment destination pointer

  psrlq      mm1, 1                      ; 2:  divide second row by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  rounding bits
  pand       mm1, mm5                    ; 2:  clear extra bits

  movq       mm3, [edi]                  ; 2:  fetch forward prediction
  paddb      mm1, mm0                    ; 2:  average backward rows

  paddb      mm1, mm2                    ; 2:  add in round
  movq       mm4, mm3                    ; 2:  copy for mask  

  pand       mm1, mm7                    ; 2:  masked backward prediction
  pand       mm4, mm6                    ; 2:  masked forward prediction

  por        mm4, mm1                    ; 2:  adjusted backwards prediction
  movq       mm2, mm3                    ; 2:  copy for rounding

  pand       mm2, mm4                    ; 2:  averaging with truncation
  psrlq      mm4, 1                      ; 2:  divide bacwards by 2

  psrlq      mm3, 1                      ; 2:  divide forwards by 2
  pand       mm4, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  "no-round" bits
  pand       mm3, mm5                    ; 2:  clear extra bits

  paddb      mm4, mm3                    ; 2:  average forward & backwards
  mov        esp, ebp

  paddb      mm4, mm2                    ; 2:  add in "no-round" bits 
  mov        ecx, edi

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  movq       [ecx], mm4                  ; 2:  store resulting row

  ret


;
;  mvx is even (horizontal full pel motion)
;  mvy is even (vertical full pel motion)
;
even_even:
  movq       mm1, [edi]                  ; 1:  forward prediction

  movq       mm0, [esi]                  ; 1:  backward prediction
  movq       mm2, mm1                    ; 1:  copy forward for mask

  pand       mm0, mm7                    ; 1:  mask off unused bytes
  sub        edi, ecx                    ; pre deccrement destination pointer

  dec        edx                         ; note that edx is positive on entry 
  jz         EvenEvenPost

;
;  This loop is 2-folded and works on 2 results (rows) per pass.
;  It finishes one result per iteration.
;  Stage I
;    loads mm0 and mm1 with the predictions and begins the replacement
;    procedure for the forward prediction.
;  Stage II
;    finishes the replacement procedure for the forward prediction and 
;    averages that (with truncation) with the bacwards prediction.
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging is done by dividing both inputs by 2, adding them together,
;    and then adding in an adjustment (in mm2).
;    To average with round, the adjustment is 1 when EITHER input is odd. 
;    To average with truncation, the adjustment is 1 when BOTH inputs are odd.
;    Due to the absence of a byte shift instruction, divide by 2 is done
;    by shifting the entire mmx register and then masking off (zeroing) bits
;    7, 15, ..., and 63 (the old low-order bits) using mm5.
;          
EvenEvenLoop:
  pand       mm2, mm6                    ; 2:  mask corresponding bytes
  add        edi, ecx                    ; increment destination pointer

  por        mm0, mm2                    ; 2:  replace unused back with for.
  movq       mm3, mm1                    ; 2:  copy forward for adjustment

  pand       mm3, mm0                    ; 2:  adjustment for truncation
  psrlq      mm0, 1                      ; 2:  divide back by 2

  psrlq      mm1, 1                      ; 2:  divide forward by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm3, [BottomBitMask]        ; 2:  finish adjustment
  pand       mm1, mm5                    ; 2:  clear extra bits

  paddb      mm0, mm1                    ; 2:  sum quotients
  add        esi, ecx                    ; increment source pointer

  movq       mm1, [edi+ecx]              ; 1:  forward prediction
  paddb      mm3, mm0                    ; 2:  add in adjusment

  movq       mm0, [esi]                  ; 1:  backward prediction
  movq       mm2, mm1                    ; 1:  copy forward for mask

  movq       [edi], mm3                  ; 2:  store result
  pand       mm0, mm7                    ; 1:  mask off unused bytes

  dec        edx                         ; decrement loop control
  jg         EvenEvenLoop                ; loop back when not done
          
EvenEvenPost:
  pand       mm2, mm6                    ; 2:  mask corresponding bytes
  add        ecx, edi

  por        mm0, mm2                    ; 2:  replace unused back with for.
  movq       mm3, mm1                    ; 2:  copy forward for adjustment

  pand       mm3, mm0                    ; 2:  adjustment for truncation
  psrlq      mm0, 1                      ; 2:  divide back by 2

  psrlq      mm1, 1                      ; 2:  divide forward by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm3, [BottomBitMask]        ; 2:  finish adjustment
  pand       mm1, mm5                    ; 2:  clear extra bits

  paddb      mm0, mm1                    ; 2:  sum quotients
  mov        esp, ebp

  paddb      mm3, mm0                    ; 2:  add in adjusment
  nop

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  movq       [ecx], mm3

  ret

;
;  "Remember when I promised to kill you last?"
;
bye_bye:
hasta_la_vista_baby:
  mov        esp, ebp

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  ret
MMXCODE1 ENDS

;        1111111111222222222233333333334444444444555555555566666666667777777
;234567890123456789012345678901234567890123456789012345678901234567890123456
;--------------------------------------------------------------------------;
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d35bimot.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35bimot.asv   1.5   08 Mar 1996 16:46:04   AGUPTA2  $
;  $Log:   S:\h26x\src\dec\d35bimot.asv  $
;// 
;//    Rev 1.5   08 Mar 1996 16:46:04   AGUPTA2
;// Added segment declaration to place the rtn in the right segment.
;// 
;// 
;//    Rev 1.4   19 Jan 1996 17:51:16   RMCKENZX
;// changed local variables to live on the stack
;// 
;//    Rev 1.3   19 Jan 1996 13:30:34   RMCKENZX
;// Added rounding to int-half bidirectional prediction
;// 
;//    Rev 1.2   05 Jan 1996 15:58:36   RMCKENZX
;// Eliminated separate chroma entry point, using a 
;// block number check instead
;// 
;//    Rev 1.1   27 Dec 1995 14:35:50   RMCKENZX
;// Added copyright notice
;
;  D35BiMot.asm
;
;  Description:
;    This module does bi-directional motion compensated prediction for 
;    B frames.  It is called after forward prediction has been computed
;    and will average in the backward prediction for those pels where 
;    the backward motion vector points inside of the referenced P frame.
;
;  Routines:                          prototypes in:
;    H263BiMotionComp                 none
;
;  Data
;    This routine assumes that the PITCH is 384.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35bimot.asv   1.5   08 Mar 1996 16:46:04   AGUPTA2  $
;  $Log$
;// 
;//    Rev 1.0   22 Nov 1995 13:33:52   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;


.586

  uDst         EQU    [esp+44]
  uRef         EQU    [esp+48]
  mvx          EQU    [esp+52]
  mvy          EQU    [esp+56]
  iNum         EQU    [esp+60]

  uColStart    EQU    [esp+04]
  uColEnd      EQU    [esp+08]
  uRowStart    EQU    [esp+12]
  uRowEnd      EQU    [esp+16]
  iColCount    EQU    [esp+20]

  PITCH         =     384

IACODE2 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE2 ENDS


IACODE2 SEGMENT
  PUBLIC _H263BiMotionComp


;--------------------------------------------------------------------------;
;
;  Name:
;    H263BiMotionComp(U32, U32, I32, I32, I32)
;
;  Inputs -- C calling convention:
;    uDst        flat pointer to block's forward predicted values.
;    uRef        flat pointer to backward predicted values.
;    mvx         x component of backward motion vector for this block.
;    mvy         y component of backward motion vector for this block.
;    iNum        block number.
;
;  Returns:
;    updates the values pointed to by uDst.
;
;--------------------------------------------------------------------------;
;
;  Version:     2.0
;  Date:        9 November 1995
;  Author:      R. McKenzie
;
;--------------------------------------------------------------------------;


;
;  set up
;
_H263BiMotionComp:
  push     edi
   push    ebx
  push     esi
   push    ebp
  sub      esp, 24
   ;
  mov      ebx, mvy
   mov     edx, iNum
  cmp      edx, 4					    ; check block number
   jge     Chroma						; do things differently for chroma                        

;  compute adjusted_mvx and adjusted_mvy
  mov      ecx, edx
   and     edx, 2
  and      ecx, 1
   mov     eax, mvx
  sal      ecx, 4
   lea     ebx, [ebx+8*edx]             ; avoid the shift with lea
  add      eax, ecx                     ; adjusted_mvx
   mov     edi, uDst

;  check bounds  
  cmp      eax, -14
   jl      hasta_la_vista_baby
  cmp      eax, 30
   jg      hasta_la_vista_baby
  cmp      ebx, -14
   jl      hasta_la_vista_baby
  cmp      ebx, 30
   jg      hasta_la_vista_baby

;  compute row and column start & end positions
;      17 cycles
  mov      esi, 1
   mov     edi, 30
  sub      esi, eax                    ; 1 - adjusted_mvx
   sub     edi, eax                    ; 30 - adjusted_mvx
  sar      edi, 1                      ; End = (30 - adjusted_mvx) >> 1
   mov     eax, 1                      ; DELAY SLOT, preload 1
  sar      esi, 1                      ; Start = (1 - adjusted_mvx) >> 1
   sub     edi, 7                      ; End-7
  mov      ecx, esi                    ; Start
   mov     edx, edi                    ; End-7
  sar      esi, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     ebp, 30                     ; DELAY SLOT, preload 30
  sar      edi, 31                     ; end_mask = 0fffffffh if End < 7
   xor     esi, -1                     ; toggle start_mask
  and      esi, ecx                    ; max(0, Start)
   and     edi, edx                    ; min(0, End-7)
  mov      uColStart, esi              ; save Start
   add     edi, 7                      ; min(7, End)

  sub      eax, ebx                    ; 1 - adjusted_mvy
   sub     ebp, ebx                    ; 30 - adjusted_mvy
  sar      ebp, 1                      ; End = (30 - adjusted_mvy) >> 1
   mov     uColEnd, edi                ; DELAY SLOT, save End
  sar      eax, 1                      ; Start = (1 - adjusted_mvy) >> 1
   sub     ebp, 7                      ; End-7
  mov      ecx, eax                    ; Start
   mov     edx, ebp                    ; End-7
  sar      eax, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     esi, uRef                   ; DELAY SLOT, preload ref. pointer
  sar      ebp, 31                     ; end_mask = 0fffffffh if End < 7
   xor     eax, -1                     ; toggle start mask
  and      ecx, eax                    ; max(0, Start)
   and     ebp, edx                    ; min(0, End-7)
  mov      uRowStart, ecx              ; save Start
   add     ebp, 7                      ; min(7, End)


;  Compute pBackRef for BBlockAdjust
  mov      eax, mvx
   mov     ebx, mvy
  sar      eax, 1
   and     ebx, -2
  shl      ebx, 6                      ; (mvy>>1) << 7 = (mvy&(-2)) << 6
   add     esi, eax                    ; pBackRef += mvx>>1
  add      esi, ebx                    ; pBackRef += 128*(mvy>>1)
   mov     uRowEnd, ebp
  shl      ebx, 1
   mov     eax, mvx
  add      esi, ebx                    ; pBackRef += 256*(mvy>>1)
   mov     ebx, mvy
  mov      edi, uDst
   jmp     H263BBlockAdjust			   ; Off to do the actual adjustment


Chroma:
  mov      eax, mvx
   mov     ebx, mvy

;  check bounds  
  cmp      eax, -14
   jl      hasta_la_vista_baby
  cmp      eax, 14
   jg      hasta_la_vista_baby
  cmp      ebx, -14
   jl      hasta_la_vista_baby
  cmp      ebx, 14
   jg      hasta_la_vista_baby

;  compute row and column start & end positions
;      17 cycles
;  note that mvy slides through the following code in register ebx!
  mov      esi, 1
   mov     edi, 14
  sub      esi, eax                    ; 1 - mvx
   sub     edi, eax                    ; 14 - mvx
  sar      edi, 1                      ; End = (14 - mvx) >> 1
   mov     eax, 1                      ; DELAY SLOT, preload 1
  sar      esi, 1                      ; Start = (1 - mvx) >> 1
   sub     edi, 7                      ; End-7
  mov      ecx, esi                    ; Start
   mov     edx, edi                    ; End-7
  sar      esi, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     ebp, 14                     ; DELAY SLOT, preload 14
  sar      edi, 31                     ; end_mask = 0fffffffh if End < 7
   xor     esi, -1                     ; toggle start_mask
  and      esi, ecx                    ; max(0, Start)
   and     edi, edx                    ; min(0, End-7)
  mov      uColStart, esi              ; save Start
   add     edi, 7                      ; min(7, End)

  sub      eax, ebx                    ; 1 - mvy
   sub     ebp, ebx                    ; 14 - mvy
  sar      ebp, 1                      ; End = (14 - mvy) >> 1
   mov     uColEnd, edi                ; DELAY SLOT, save End
  sar      eax, 1                      ; Start = (1 - mvy) >> 1
   sub     ebp, 7                      ; End-7
  mov      ecx, eax                    ; Start
   mov     edx, ebp                    ; End-7
  sar      eax, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     esi, uRef                   ; DELAY SLOT, preload ref. pointer
  sar      ebp, 31                     ; end_mask = 0fffffffh if End < 7
   xor     eax, -1                     ; toggle start mask
  and      ecx, eax                    ; max(0, Start)
   and     ebp, edx                    ; min(0, End-7)
  mov      uRowStart, ecx              ; save Start
   add     ebp, 7                      ; min(7, End)


;  Compute pBackRef for BBlockAdjust
  mov      eax, mvx
   mov     edi, uDst                   ; DELAY SLOT, preload dest. pointer
  sar      eax, 1
   and     ebx, -2
  shl      ebx, 6                      ; (mvy>>1) << 7 = (mvy&(-2)) << 6
   add     esi, eax                    ; pBackRef += mvx>>1
  add      esi, ebx                    ; pBackRef += 128*(mvy>>1)
   mov     uRowEnd, ebp                ; DELAY SLOT, save End
  shl      ebx, 1
   mov     eax, mvx                    ; DELAY SLOT, restore mvx
  add      esi, ebx                    ; pBackRef += 256*(mvy>>1)
   mov     ebx, mvy                    ; DELAY SLOT, restore mvy


;--------------------------------------------------------------------------;
;
;  Name:
;    H263BBlockAdjust
;
;  Inputs:
;    pBiRef      edi    flat pointer to block's forward predicted values
;    pBackRef    esi    flat pointer to block's bacward predicted values as
;                       adjusted by the motion vectors
;    mvx         eax    x component of backward motion vector,
;                       used for parity only
;    mvy         ebx    y component of backward motion vector,
;                       used for parity only
;    uColStart          starting index for columns
;    uColEnd            ending index for columns
;    uRowStart          starting index for rows
;    uRowEnd            ending index for rows
;
;  Returns:
;    Updated values pointed to by pBiRef.
;
;  Notes:
;    1.  This routine is jumped into from either H263BiMotionCompLuma or
;        H263BiMotionCompChroma and effects the returns for those routines.
;
;    2.  The values of the starting and ending indicies MUST satisfy:
;            0  <=  Start  <=  End  <=  7
;
;    3.  Only the last (least significant) bits of mvx and mvy are used
;        to determine whether we need to use half-pel or full-pel 
;        prediction.
;
;    4.  The address in pBackRef must have been adjusted by the motion
;        vectors to point to the target pels.
;
;--------------------------------------------------------------------------;
;
;  Version:     1.1
;  Date:        10 November 1995
;  Author:      R. McKenzie
;
;--------------------------------------------------------------------------;

;-------------------------------;
;  common set up for all loops  ;
;-------------------------------;
H263BBlockAdjust:
  mov      ecx, uRowStart              ; row = uRowStart
   mov     edx, uColEnd
  shl      ecx, 7                      ; 128*row
   mov     ebp, uColStart
  sub      ebp, edx                    ; uColStart - uColEnd
   add     edx, ecx                    ; uColEnd += 128*row
  shl      ecx, 1                      ; 256*row
   mov     iColCount, ebp              ; inner loop starting position
  add      edx, ecx                    ; uColEnd += 256*row
   xor     ecx, ecx                    ; clear ecx
  add      esi, edx                    ; pBackRef += PITCH*row+uColEnd
   add     edi, edx                    ; pBiRef += PITCH*row+uColEnd


  and      eax, 1
   je      even_mvx
  and      ebx, 1
   je      odd_even

;
;  mvx is odd (horizontal half pel motion)
;  mvy is odd (vertical half pel motion)
;
odd_odd:
  mov      ebx, uRowStart
   mov     eax, uRowEnd
  xor      edx, edx
   sub     eax, ebx

loopoo_preamble:
  push     eax                         ; save outer count
   mov     al, [esi+ebp]               ; I
  mov      bl, [esi+ebp+1]             ; I unpaired instruction
  add      eax, ebx                    ; I
   mov     bl, [esi+ebp+PITCH]         ; I
  add      eax, ebx                    ; I
   mov     cl, [esi+ebp+PITCH+1]       ; I
  add      ecx, eax                    ; I
   inc     ebp                         ; I
  mov      eax, 0                      ; I
   jg      loopoo_postamble

loopoo_inner:
  add      ecx, 2                      ; II
   mov     al, [esi+ebp]               ; I
  shr      ecx, 2                      ; II
   mov     bl, [esi+ebp+1]             ; I
  mov      dl, [edi+ebp-1]             ; II
   add     eax, ebx                    ; I
  add      edx, ecx                    ; II
   mov     bl, [esi+ebp+PITCH]         ; I
  shr      edx, 1                      ; II
   add     eax, ebx                    ; I
  mov      [edi+ebp-1], dl             ; II
   mov     cl, [esi+ebp+PITCH+1]       ; I
  add      ecx, eax                    ; I
   inc     ebp
  mov      eax, 0                      ; I
   jle     loopoo_inner

loopoo_postamble:
  add      ecx, 2                      ; II
   add     esi, PITCH
  shr      ecx, 2                      ; II
   mov     dl, [edi+ebp-1]             ; II
  add      edx, ecx                    ; II
   add     edi, PITCH
  shr      edx, 1                      ; II
   pop     eax                         ; fetch outer count
  mov      [edi+ebp-1-PITCH], dl       ; II
   mov     ebp, iColCount
  dec      eax
   jge     loopoo_preamble

  add	   esp, 24
   jmp	   bye_bye


;
;  mvx is odd (horizontal half pel motion)
;  mvy is even (vertical full pel motion)
;
odd_even:
  mov      dl, BYTE PTR uRowStart
   mov     cl, BYTE PTR uRowEnd
  sub      dl, cl                      ; outer loop control
   sub     edi, PITCH                  ; adjust destination pointer

loopoe_preamble:
  mov      al, [esi+ebp]               ; I
   mov     bl, [esi+ebp+1]             ; I Probable (75%) Bank Conflict
  add      edi, PITCH
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jg      loopoe_postamble

loopoe_inner:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   mov     al, [esi+ebp]               ; I
  shr      ecx, 1                      ; II
   mov     bl, [esi+ebp+1]             ; I
  mov      [edi+ebp-1], cl             ; II
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jle     loopoe_inner

loopoe_postamble:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   add     esi, PITCH
  shr      ecx, 1                      ; II
   inc     dl
  mov      [edi+ebp-1], cl             ; II
   mov     ebp, iColCount
  jle      loopoe_preamble             ; unpaired

  add	   esp, 24
   jmp     bye_bye


;---------------------------;
;  mvx is even -- test mvy  ;
;---------------------------;
even_mvx:
  and      ebx, 1
   je      even_even

;
;  mvx is even (horizontal full pel motion)
;  mvy is odd (vertical half pel motion)
;
even_odd:
  mov      dl, BYTE PTR uRowStart
   mov     cl, BYTE PTR uRowEnd
  sub      dl, cl                      ; outer loop control
   sub     edi, PITCH                  ; adjust destination pointer

loopeo_preamble:
  mov      al, [esi+ebp]               ; I
   mov     bl, [esi+ebp+PITCH]         ; I Probable (75%) Bank Conflict
  add      edi, PITCH
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jg      loopeo_postamble

loopeo_inner:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   mov     al, [esi+ebp]               ; I
  shr      ecx, 1                      ; II
   mov     bl, [esi+ebp+PITCH]         ; I
  mov      [edi+ebp-1], cl             ; II
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jle     loopeo_inner

loopeo_postamble:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   add     esi, PITCH
  shr      ecx, 1                      ; II
   inc     dl
  mov      [edi+ebp-1], cl             ; II
   mov     ebp, iColCount
  jle      loopeo_preamble             ; unpaired

  add	   esp, 24
   jmp     bye_bye


;
;  mvx is even (horizontal full pel motion)
;  mvy is even (vertical full pel motion)
;
even_even:
  mov      dl, BYTE PTR uRowStart
   mov     cl, BYTE PTR uRowEnd
  sub      dl, cl

loopee_preamble:
  mov      al, [esi+ebp]               ; I
   mov     bl, [edi+ebp]               ; I possbile bank conflict
  test     ebp, ebp
   je      loopee_postamble

loopee_inner:
  lea      ecx, [eax+ebx]              ; II
   mov     al, [esi+ebp+1]             ; I
  shr      ecx, 1                      ; II
   mov     bl, [edi+ebp+1]             ; I
  mov      [edi+ebp], cl               ; II
   inc     ebp
  jl       loopee_inner                ; unpaired

loopee_postamble:
  add      eax, ebx                    ; II
   add     edi, PITCH
  shr      eax, 1                      ; II
   add     esi, PITCH
  mov      [edi+ebp-PITCH], al         ; II
   mov     ebp, iColCount
  inc      dl
   jle     loopee_preamble


;
;  "Remember when I promised to kill you last?"
;
hasta_la_vista_baby:
  add	   esp, 24
bye_bye:
  pop      ebp
   pop     esi
  pop      ebx
   pop     edi
  ret

;  biMotionCompLuma ENDP
;        1111111111222222222233333333334444444444555555555566666666667777777
;234567890123456789012345678901234567890123456789012345678901234567890123456
;--------------------------------------------------------------------------;
IACODE2 ENDS

END
//  bimot.asm	page 9	1:41 PM, 11/21/95  //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dx5frmcp.asm ===
;* *************************************************************************
;*    INTEL Corporation Proprietary Information
;*
;*    This listing is supplied under the terms of a license
;*    agreement with INTEL Corporation and may not be copied
;*    nor disclosed except in accordance with the terms of
;*    that agreement.
;*
;*    Copyright (c) 1995 Intel Corporation.
;*    All Rights Reserved.
;*
;* *************************************************************************
;//
;//
;// $Header:   S:\h26x\src\dec\dx5frmcp.asv
;//
;// $Log:   S:\h26x\src\dec\dx5frmcp.asv  $
;// 
;//    Rev 1.1   20 Dec 1995 15:55:42   RMCKENZX
;// Added FrameMirror function to file to support mirror imaging
;// 
;//    Rev 1.0   25 Oct 1995 18:11:36   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; File:
;   dx5frmcp 
;
; Functions:
;   FrameCopy
;     This function copies a frame from one frame buffer to another.
;     It is tuned for best performance on the Pentium(r) Microprocessor.
;
;     It is assumed that the frames have the same height, width, and
;     pitch, and that, if width is NOT a multiple of 8, it is okay
;     to copy up to the next multiple of 8.
;
;   FrameMirror
;     This function mirror images a frame from one frame buffer to
;     another.  It is tuned for best performance on the Pentium.
;
;     It is assumed that the frames have the same height, width, and
;     pitch.  The width may be any (non-negative) value.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_FrameCopy>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE FrameCopy (U8 FAR * InputBase,
;                                  X32 InputPlane,
;                                  U8 FAR * OutputBase,
;                                  X32 OutputPlane,
;                                  UN  FrameHeight,
;                                  UN  FrameWidth,
;                                  UN  Pitch)

PUBLIC  FrameCopy

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        FrameCopy    proc DIST LANG AInputPlane:        DWORD,
                                    AOutputPlane:       DWORD,
                                    AFrameHeight:       DWORD,
                                    AFrameWidth:        DWORD,
                                    APitch:             DWORD

IFDEF WIN32

RegisterStorageSize = 16

; Arguments:

InputPlane                 = RegisterStorageSize +  4
OutputPlane                = RegisterStorageSize +  8
FrameHeight                = RegisterStorageSize + 12
FrameWidth                 = RegisterStorageSize + 16
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 24

ELSE

; Arguments:

RegisterStorageSize = 24           ; Put local variables on stack.
InputPlane                 = RegisterStorageSize +  4
InputPlane_SegNum          = RegisterStorageSize +  6
OutputPlane                = RegisterStorageSize +  8
OutputPlane_SegNum         = RegisterStorageSize + 10
OutputPlane                = RegisterStorageSize + 12
FrameHeight                = RegisterStorageSize + 16
FrameWidth                 = RegisterStorageSize + 18
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 22

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  mov  esi,PD [esp+InputPlane]
   mov  edi,PD [esp+OutputPlane]
  mov   ebp,PD [esp+Pitch]
   mov  edx,PD [esp+FrameWidth]
  mov   ecx,PD [esp+FrameHeight]
ELSE
  mov   ax,ds
  mov   bx,es
  push  eax
   push ebx
  mov   ax,PW [esp+InputBase_SegNum]
  movzx esi,PW [esp+InputPlane]
  mov   bx,PW [esp+OutputBase_SegNum]
  movzx edi,PW [esp+OutputPlane]
  mov   ds,ebx
  mov   es,eax
  movzx ebp,PW [esp+Pitch]
  movzx edx,PW [esp+FrameWidth]
  movzx ecx,PW [esp+FrameHeight]
ENDIF
  add   edx,7
  and   edx,0FFFFFFF8H
  sub   ebp,edx
  sub   edi,esi

  push  edx

CopyLineLoop:

  mov   eax,Ze PD [esi]
   mov  ebx,PD [esi+edi]      ; Load output cache line
  mov   ebx,Ze PD [esi+4]
   mov  PD [esi+edi],eax
  mov   PD [esi+edi+4],ebx
   add  esi,8
  sub   edx,8
   jg   CopyLineLoop

  add   esi,ebp
   dec  ecx                  ; Reduce count of lines.
  mov   edx,PD [esp]         ; Reload frame width.
   jg   CopyLineLoop

  pop   edx

IFDEF WIN32
ELSE
  pop   ebx
  mov   es,ebx
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FrameCopy endp



PUBLIC  FrameMirror

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

FrameMirror    proc DIST LANG BInputPlane:        DWORD,
                              BOutputPlane:       DWORD,
                              BFrameHeight:       DWORD,
                              BFrameWidth:        DWORD,
                              BPitch:             DWORD

;  save registers
  push    esi
   push   edi
  push    ebp
   push   ebx

;  setup and get parameters
IFDEF WIN32
  mov     esi, PD [esp+InputPlane]
   mov    edi, PD [esp+OutputPlane]
  mov     ebp, PD [esp+Pitch]
   mov    edx, PD [esp+FrameWidth]
  mov     ecx, PD [esp+FrameHeight]

ELSE
  mov     ax, ds
   mov    bx, es
  push    eax
   push   ebx
  mov     ax, PW [esp+InputBase_SegNum]
   movzx  esi, PW [esp+InputPlane]
  mov     bx, PW [esp+OutputBase_SegNum]
   movzx  edi, PW [esp+OutputPlane]
  mov     ds, ebx
   mov    es, eax
  movzx   ebp, PW [esp+Pitch]
   movzx  edx, PW [esp+FrameWidth]
  movzx   ecx, PW [esp+FrameHeight]
ENDIF

;  start processing

;  prepare for the loop
   push   edx                   ; save width

per_line_loop:
  test    edx, 7				; check for short count
   je     skip_short_count		; skip when no short count

short_count_loop:
  mov     al, [esi+edx-1]
   dec    edx
  mov     [edi], al
   inc    edi
  test    edx, 7
   jne    short_count_loop

skip_short_count:
  test    edx, edx
   je     skip_inner_loop

;  inner loop is unrolled to do 8 bytes per iteration
inner_loop:
  mov     al, [edi]			  ; heat cache
   add    edi, 8
  mov     al, [esi+edx-1]
   mov    bl, [esi+edx-5]
  mov     [edi-8], al
   mov    [edi-4], bl
  mov     al, [esi+edx-2]
   mov    bl, [esi+edx-6]
  mov     [edi-7], al
   mov    [edi-3], bl
  mov     al, [esi+edx-3]
   mov    bl, [esi+edx-7]
  mov     [edi-6], al
   mov    [edi-2], bl
  mov     al, [esi+edx-4]
   mov    bl, [esi+edx-8]
  mov     [edi-5], al
   mov    [edi-1], bl
  sub     edx, 8
   jne    inner_loop

;  now move down to the next line
skip_inner_loop:
  mov     edx, [esp]		; restore width
   add    edi, ebp			; increment destination
  add     esi, ebp			; increment source
   sub    edi, edx			; correct destination by width
  dec     ecx
   jne    per_line_loop

;  restore stack pointer
  pop     eax

IFDEF WIN32
ELSE
  pop     ebx
   pop    eax
  mov     es, bx
   mov    ds, ax
ENDIF

;  restore registers and return
  pop     ebx
   pop    ebp
  pop     edi
   pop    esi
  rturn

FrameMirror endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mbkadd.asm ===
;--------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
;
; $Author:   SCDAY  $
; $Date:   31 Oct 1996 09:00:56  $
; $Archive:   S:\h26x\src\dec\d3mbkadd.asv  $
; $Header:   S:\h26x\src\dec\d3mbkadd.asv   1.8   31 Oct 1996 09:00:56   SCDAY  $
; $Log:   S:\h26x\src\dec\d3mbkadd.asv  $
;// 
;//    Rev 1.8   31 Oct 1996 09:00:56   SCDAY
;// Raj added IFDEF H261 MMX_BlockAddSpecial and MMX_BlockCopySpecial
;// 
;//    Rev 1.7   09 Jul 1996 16:50:42   AGUPTA2
;// DC value for INTRA blocks is added back in ClipAndMove routine.
;// Cleaned-up code.
;// 
;//    Rev 1.6   04 Apr 1996 13:42:58   AGUPTA2
;// Removed a store stall from MMX_BlockAdd
;// 
;//    Rev 1.5   03 Apr 1996 17:42:30   AGUPTA2
;// Added MMX version of BlockCopy routine.
;// 
;//    Rev 1.4   03 Apr 1996 11:08:22   RMCKENZX
;// Added clearing of IDCT output.  Cleaned comments.
;// 
;//    Rev 1.3   22 Mar 1996 15:43:30   AGUPTA2
;// Fixed fastcall bug: return from rtns with more than 2 params.
;// 
;//    Rev 1.2   14 Mar 1996 17:15:14   AGUPTA2
;// 
;// Included Bob's MMX_ClipAndMove rtn.  This rtn works on INTRA output.
;// 
;//    Rev 1.1   27 Feb 1996 16:48:52   RMCKENZX
;// Added rounding of IDCT output.
; 
;--------------------------------------------------------------------------

;==========================================================================
;
;  d3mbkadd.asm
;
;  Routines:
;    MMX_BlockAdd
;    MMX_ClipAndMove
;
;  Prototypes in d3mblk.h:
;		extern "C" {
;			void __fastcall MMX_BlockAdd(
;				U32 uResidual,   // pointer to IDCT output
;				U32 uRefBlock,   // pointer to predicted values
;				U32 uDstBlock);  // pointer to destination
;
;			void __fastcall MMX_ClipAndMove(
;				U32 uResidual,   // pointer to IDCT output
;				U32 uDstBlock,   // pointer to destination
;               U32 ScaledDC);   // scaled DC
;		}
;
;==========================================================================


;--------------------------------------------------------------------------
;
;  MMX_BlockAdd
;
;  Description:
;    This routine performs block addition of the IDCT output with the
;    predicted value to find the final value.  The IDCT values are converted
;    to integers then added to the prediction.  The result of the addition is 
;    then clipped to 0...255. The routine is called with the __fastcall option,
;    with the first two parameters in ecx and edx and the third on the stack.
;
;    The routine clears the IDCT output after reading it.    
;  Parameters:
;    ecx = uSrc1 pointer to IDCT output.  Values are signed, 16 bit values with
;          6 fractional bits.  They are not clipped to -256 ... +255.
;          They are packed into a qword aligned 8x8 array of dwords.
;
;    edx = uSrc2 pointer to prediction values.  Vaules are unsigned, 8-bit 
;          values. They are packed into a (possibly unaligned) 8x8 array of 
;          bytes.
;    esp+4 = uDst pointer to output values.  Values will be unsigned, 8-bit 
;            values.  They will be written into a qword aligned 8x8 array 
;            of bytes with a PITCH of 384 in between rows. 
;
;--------------------------------------------------------------------------

.586
.MODEL FLAT
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS


MMXDATA1 SEGMENT
ALIGN 8
MMX_Round32 DWORD 000200020H, 000200020H
MMXDATA1 ENDS

MMXCODE1 SEGMENT

ALIGN 4
@MMX_BlockAdd@12 PROC 
;  Parameters
pSrc1       EQU      ecx      
pSrc2       EQU      edx
pDst        EQU      eax
PITCH       EQU      384


  ;
  ;	This loop is 2-folded and fully unrolled.  2-folded means that
  ;	it works on 2 results per "pass" (8-pixel line).  Fully unrolled means that
  ;	it doesn't really loop at all -- all 8 "passes" are placed
  ;	in succession.
  ;
  ;	The result which each instruction is working on is identified
  ;	by a number as the first item in the comment field.
  ;
  movq       mm6, [MMX_Round32]              ; rounding for IDC output
   ;
  movq       mm3, [ecx+8]                    ; 1 - last 4 words of In1
   pxor      mm7, mm7                        ; zero for PUNPCK and clearing.
  movq       mm1, [ecx]                      ; 1 - first 4 words of In1
   ;
  movq       [ecx+8], mm7                    ; 1 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 1 - add in rounding
  movq       [ecx], mm7                      ; 1 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 1 - add in rounding
  mov        eax, [esp+4]                    ; destination pointer
   psraw     mm3, 6                          ; 1 - convert to int
  movq       mm2, [edx]                      ; 1 - 8 bytes of In2
   psraw     mm1, 6                          ; 1 - convert to int
  ; pass 1
  movq       mm0, mm2                        ; 1 - second copy of In2
   punpckhbw mm2, mm7                        ; 1 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 1 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 1 - first 4 bytes of In2
  movq       mm3, [ecx+24]                   ; 2 - last 4 words of In1
   paddw     mm0, mm1                        ; 1 - sum first 4 bytes
  movq       mm1, [ecx+16]                   ; 2 - first 4 words of In1
   packuswb  mm0, mm2                        ; 1 - combine & clip sum
  movq       [ecx+24], mm7                   ; 2 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 2 - add in rounding
  movq       [ecx+16], mm7                   ; 2 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 2 - add in rounding
  movq       mm2, [edx+PITCH]                ; 2 - 8 bytes of In2   
   psraw     mm3, 6                          ; 2 - convert to int
  movq       [eax], mm0                      ; 1 - store result
   psraw     mm1, 6                          ; 2 - convert to int
  ; pass 2
  movq       mm0, mm2                        ; 2 - second copy of In2
   punpckhbw mm2, mm7                        ; 2 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 2 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 2 - first 4 bytes of In2
  movq       mm3, [ecx+40]                   ; 3 - last 4 words of In1
   paddw     mm0, mm1                        ; 2 - sum first 4 bytes
  movq       mm1, [ecx+32]                   ; 3 - first 4 words of In1
   packuswb  mm0, mm2                        ; 2 - combine & clip sum
  movq       [ecx+40], mm7                   ; 3 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 3 - add in rounding
  movq       [ecx+32], mm7                   ; 3 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 3 - add in rounding
  movq       mm2, [edx+2*PITCH]              ; 3 - 8 bytes of In2
   psraw     mm3, 6                          ; 3 - convert to int
  movq       [eax+PITCH], mm0                ; 2 - store result
   psraw     mm1, 6                          ; 3 - convert to int
  ; pass 3
  movq       mm0, mm2                        ; 3 - second copy of In2
   punpckhbw mm2, mm7                        ; 3 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 3 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 3 - first 4 bytes of In2
  movq       mm3, [ecx+56]                   ; 4 - last 4 words of In1
   paddw     mm0, mm1                        ; 3 - sum first 4 bytes
  movq       mm1, [ecx+48]                   ; 4 - first 4 words of In1
   packuswb  mm0, mm2                        ; 3 - combine & clip sum
  movq       [ecx+56], mm7                   ; 4 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 4 - add in rounding
  movq       [ecx+48], mm7                   ; 4 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 4 - add in rounding
  movq       mm2, [edx+3*PITCH]              ; 4 - 8 bytes of In2   
   psraw     mm3, 6                          ; 4 - convert to int
  movq       [eax+2*PITCH], mm0              ; 3 - store result
   psraw     mm1, 6                          ; 4 - convert to int
  ; pass 4
  movq       mm0, mm2                        ; 4 - second copy of In2
   punpckhbw mm2, mm7                        ; 4 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 4 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 4 - first 4 bytes of In2
  movq       mm3, [ecx+72]                   ; 5 - last 4 words of In1
   paddw     mm0, mm1                        ; 4 - sum first 4 bytes
  movq       mm1, [ecx+64]                   ; 5 - first 4 words of In1
   packuswb  mm0, mm2                        ; 4 - combine & clip sum
  movq       [ecx+72], mm7                   ; 5 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 5 - add in rounding
  movq       [ecx+64], mm7                   ; 5 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 5 - add in rounding
  movq       mm2, [edx+4*PITCH]              ; 5 - 8 bytes of In2   
   psraw     mm3, 6                          ; 5 - convert to int
  movq       [eax+3*PITCH], mm0              ; 4 - store result
   psraw     mm1, 6                          ; 5 - convert to int
  ; pass 5
  movq       mm0, mm2                        ; 5 - second copy of In2
   punpckhbw mm2, mm7                        ; 5 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 5 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 5 - first 4 bytes of In2
  movq       mm3, [ecx+88]                   ; 6 - last 4 words of In1
   paddw     mm0, mm1                        ; 5 - sum first 4 bytes
  movq       mm1, [ecx+80]                   ; 6 - first 4 words of In1
   packuswb  mm0, mm2                        ; 5 - combine & clip sum
  movq       [ecx+88], mm7                   ; 6 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 6 - add in rounding
  movq       [ecx+80], mm7                   ; 6 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 6 - add in rounding
  movq       mm2, [edx+5*PITCH]              ; 6 - 8 bytes of In2   
   psraw     mm3, 6                          ; 6 - convert to int
  movq       [eax+4*PITCH], mm0              ; 5 - store result
   psraw     mm1, 6                          ; 6 - convert to int
  ; pass 6
  movq       mm0, mm2                        ; 6 - second copy of In2
   punpckhbw mm2, mm7                        ; 6 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 6 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 6 - first 4 bytes of In2
  movq       mm3, [ecx+104]                  ; 7 - last 4 words of In1
   paddw     mm0, mm1                        ; 6 - sum first 4 bytes
  movq       mm1, [ecx+96]                   ; 7 - first 4 words of In1
   packuswb  mm0, mm2                        ; 6 - combine & clip sum
  movq       [ecx+104], mm7                  ; 7 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 7 - add in rounding
  movq       [ecx+96], mm7                   ; 7 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 7 - add in rounding
  movq       mm2, [edx+6*PITCH]              ; 7 - 8 bytes of In2   
   psraw     mm3, 6                          ; 7 - convert to int
  movq       [eax+5*PITCH], mm0              ; 6 - store result
   psraw     mm1, 6                          ; 7 - convert to int
  ; pass 7
  movq       mm0, mm2                        ; 7 - second copy of In2
   punpckhbw mm2, mm7                        ; 7 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 7 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 7 - first 4 bytes of In2
  movq       mm3, [ecx+120]                  ; 8 - last 4 words of In1
   paddw     mm0, mm1                        ; 7 - sum first 4 bytes
  movq       mm1, [ecx+112]                  ; 8 - first 4 words of In1
   packuswb  mm0, mm2                        ; 7 - combine & clip sum
  movq       [ecx+120], mm7                  ; 8 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 8 - add in rounding
  movq       [ecx+112], mm7                  ; 8 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 8 - add in rounding
  movq       mm2, [edx+7*PITCH]              ; 8 - 8 bytes of In2   
   psraw     mm3, 6                          ; 8 - convert to int
  movq       [eax+6*PITCH], mm0              ; 7 - store result
   psraw     mm1, 6                          ; 8 - convert to int
  ;
  ; pass 8
  ; wrap up
  ;
  movq       mm0, mm2                        ; 8 - second copy of In2
   punpckhbw mm2, mm7                        ; 8 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 8 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 8 - first 4 bytes of In2
  paddw      mm0, mm1                        ; 8 - sum first 4 bytes
   ;
  packuswb   mm0, mm2                        ; 8 - combine & clip sum
   ;
  movq       [eax+7*PITCH], mm0              ; 8 - store result
   ret       4

@MMX_BlockAdd@12 ENDP

IFDEF H261
ALIGN 4
@MMX_BlockAddSpecial@12 PROC 
;  Parameters
pSrc1       EQU      ecx      
pSrc2       EQU      edx
pDst        EQU      eax
PITCH       EQU      384


  ;
  ;	This loop is 2-folded and fully unrolled.  2-folded means that
  ;	it works on 2 results per "pass" (8-pixel line).  Fully unrolled means that
  ;	it doesn't really loop at all -- all 8 "passes" are placed
  ;	in succession.
  ;
  ;	The result which each instruction is working on is identified
  ;	by a number as the first item in the comment field.
  ;
  movq       mm6, [MMX_Round32]              ; rounding for IDC output
   ;
  movq       mm3, [ecx+8]                    ; 1 - last 4 words of In1
   pxor      mm7, mm7                        ; zero for PUNPCK and clearing.
  movq       mm1, [ecx]                      ; 1 - first 4 words of In1
   ;
  movq       [ecx+8], mm7                    ; 1 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 1 - add in rounding
  movq       [ecx], mm7                      ; 1 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 1 - add in rounding
  mov        eax, [esp+4]                    ; destination pointer
   psraw     mm3, 6                          ; 1 - convert to int
  movq       mm2, [edx]                      ; 1 - 8 bytes of In2
   psraw     mm1, 6                          ; 1 - convert to int
  ; pass 1
  movq       mm0, mm2                        ; 1 - second copy of In2
   punpckhbw mm2, mm7                        ; 1 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 1 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 1 - first 4 bytes of In2
  movq       mm3, [ecx+24]                   ; 2 - last 4 words of In1
   paddw     mm0, mm1                        ; 1 - sum first 4 bytes
  movq       mm1, [ecx+16]                   ; 2 - first 4 words of In1
   packuswb  mm0, mm2                        ; 1 - combine & clip sum
  movq       [ecx+24], mm7                   ; 2 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 2 - add in rounding
  movq       [ecx+16], mm7                   ; 2 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 2 - add in rounding
  movq       mm2, [edx+8]                ; 2 - 8 bytes of In2   
   psraw     mm3, 6                          ; 2 - convert to int
  movq       [eax], mm0                      ; 1 - store result
   psraw     mm1, 6                          ; 2 - convert to int
  ; pass 2
  movq       mm0, mm2                        ; 2 - second copy of In2
   punpckhbw mm2, mm7                        ; 2 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 2 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 2 - first 4 bytes of In2
  movq       mm3, [ecx+40]                   ; 3 - last 4 words of In1
   paddw     mm0, mm1                        ; 2 - sum first 4 bytes
  movq       mm1, [ecx+32]                   ; 3 - first 4 words of In1
   packuswb  mm0, mm2                        ; 2 - combine & clip sum
  movq       [ecx+40], mm7                   ; 3 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 3 - add in rounding
  movq       [ecx+32], mm7                   ; 3 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 3 - add in rounding
  movq       mm2, [edx+2*8]              ; 3 - 8 bytes of In2
   psraw     mm3, 6                          ; 3 - convert to int
  movq       [eax+PITCH], mm0                ; 2 - store result
   psraw     mm1, 6                          ; 3 - convert to int
  ; pass 3
  movq       mm0, mm2                        ; 3 - second copy of In2
   punpckhbw mm2, mm7                        ; 3 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 3 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 3 - first 4 bytes of In2
  movq       mm3, [ecx+56]                   ; 4 - last 4 words of In1
   paddw     mm0, mm1                        ; 3 - sum first 4 bytes
  movq       mm1, [ecx+48]                   ; 4 - first 4 words of In1
   packuswb  mm0, mm2                        ; 3 - combine & clip sum
  movq       [ecx+56], mm7                   ; 4 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 4 - add in rounding
  movq       [ecx+48], mm7                   ; 4 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 4 - add in rounding
  movq       mm2, [edx+3*8]              ; 4 - 8 bytes of In2   
   psraw     mm3, 6                          ; 4 - convert to int
  movq       [eax+2*PITCH], mm0              ; 3 - store result
   psraw     mm1, 6                          ; 4 - convert to int
  ; pass 4
  movq       mm0, mm2                        ; 4 - second copy of In2
   punpckhbw mm2, mm7                        ; 4 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 4 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 4 - first 4 bytes of In2
  movq       mm3, [ecx+72]                   ; 5 - last 4 words of In1
   paddw     mm0, mm1                        ; 4 - sum first 4 bytes
  movq       mm1, [ecx+64]                   ; 5 - first 4 words of In1
   packuswb  mm0, mm2                        ; 4 - combine & clip sum
  movq       [ecx+72], mm7                   ; 5 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 5 - add in rounding
  movq       [ecx+64], mm7                   ; 5 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 5 - add in rounding
  movq       mm2, [edx+4*8]              ; 5 - 8 bytes of In2   
   psraw     mm3, 6                          ; 5 - convert to int
  movq       [eax+3*PITCH], mm0              ; 4 - store result
   psraw     mm1, 6                          ; 5 - convert to int
  ; pass 5
  movq       mm0, mm2                        ; 5 - second copy of In2
   punpckhbw mm2, mm7                        ; 5 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 5 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 5 - first 4 bytes of In2
  movq       mm3, [ecx+88]                   ; 6 - last 4 words of In1
   paddw     mm0, mm1                        ; 5 - sum first 4 bytes
  movq       mm1, [ecx+80]                   ; 6 - first 4 words of In1
   packuswb  mm0, mm2                        ; 5 - combine & clip sum
  movq       [ecx+88], mm7                   ; 6 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 6 - add in rounding
  movq       [ecx+80], mm7                   ; 6 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 6 - add in rounding
  movq       mm2, [edx+5*8]              ; 6 - 8 bytes of In2   
   psraw     mm3, 6                          ; 6 - convert to int
  movq       [eax+4*PITCH], mm0              ; 5 - store result
   psraw     mm1, 6                          ; 6 - convert to int
  ; pass 6
  movq       mm0, mm2                        ; 6 - second copy of In2
   punpckhbw mm2, mm7                        ; 6 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 6 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 6 - first 4 bytes of In2
  movq       mm3, [ecx+104]                  ; 7 - last 4 words of In1
   paddw     mm0, mm1                        ; 6 - sum first 4 bytes
  movq       mm1, [ecx+96]                   ; 7 - first 4 words of In1
   packuswb  mm0, mm2                        ; 6 - combine & clip sum
  movq       [ecx+104], mm7                  ; 7 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 7 - add in rounding
  movq       [ecx+96], mm7                   ; 7 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 7 - add in rounding
  movq       mm2, [edx+6*8]              ; 7 - 8 bytes of In2   
   psraw     mm3, 6                          ; 7 - convert to int
  movq       [eax+5*PITCH], mm0              ; 6 - store result
   psraw     mm1, 6                          ; 7 - convert to int
  ; pass 7
  movq       mm0, mm2                        ; 7 - second copy of In2
   punpckhbw mm2, mm7                        ; 7 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 7 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 7 - first 4 bytes of In2
  movq       mm3, [ecx+120]                  ; 8 - last 4 words of In1
   paddw     mm0, mm1                        ; 7 - sum first 4 bytes
  movq       mm1, [ecx+112]                  ; 8 - first 4 words of In1
   packuswb  mm0, mm2                        ; 7 - combine & clip sum
  movq       [ecx+120], mm7                  ; 8 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 8 - add in rounding
  movq       [ecx+112], mm7                  ; 8 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 8 - add in rounding
  movq       mm2, [edx+7*8]              ; 8 - 8 bytes of In2   
   psraw     mm3, 6                          ; 8 - convert to int
  movq       [eax+6*PITCH], mm0              ; 7 - store result
   psraw     mm1, 6                          ; 8 - convert to int
  ;
  ; pass 8
  ; wrap up
  ;
  movq       mm0, mm2                        ; 8 - second copy of In2
   punpckhbw mm2, mm7                        ; 8 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 8 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 8 - first 4 bytes of In2
  paddw      mm0, mm1                        ; 8 - sum first 4 bytes
   ;
  packuswb   mm0, mm2                        ; 8 - combine & clip sum
   ;
  movq       [eax+7*PITCH], mm0              ; 8 - store result
   ret       4

@MMX_BlockAddSpecial@12 ENDP
ENDIF

;----------------------------------------------------------------------------
;
;  MMX_ClipAndMove
;
;  Description:
;   This routine takes the MMx IDCT output, converts (with round)
;   to integer, and clips to 0...255.  Routine is called with the
;   __fastcall option, with the two parameters in ecx and edx.
;
;   The routine clears the IDCT output after reading it.    
;
;  	MMx version.
;
;  Parameters:
;    ecx = uSrc1 pointer to IDCT output.  Values are signed, 16 bit values  
;               with 6 fractional bits.  They are not clipped to -256 ...
;               +255.  They are packed into a qword aligned 8x8 array
;               of words.     
;
;    edx = uDst pointer to output values.  Values will be unsigned, 8-bit 
;               values.  They will be written into a qword aligned 8x8 array 
;               of bytes with a PITCH of 384 in between rows. 
;    esp + 4 =  Scaled DC value with 7 fraction bits
;----------------------------------------------------------------------------
ALIGN 4
@MMX_ClipAndMove@12 PROC
;  Parameters
pSrc1     EQU      ecx      
pDst      EQU      edx
ScaledDC  EQU      DWORD PTR [esp + 4]
;
; preamble
;
  movd       mm0, ScaledDC                   ; Scaled DC value 
   pxor      mm6, mm6                        ; zero
  movq       mm1, mm0
   psllq     mm0, 16
  movq       mm2, [ecx]                      ; 3:  fetch first 4 words
   por       mm0, mm1			             ; lower 2 WORDS have ScaledDC
  movq       mm7, mm0
   psllq     mm0, 32
  por        mm7, mm0			             ; all 4 WORDS have ScaledDC
   mov       eax, 3                          ; loop control
  movq       mm3, [ecx+8]                    ; 3:  fetch last 4 words
   psrlw     mm7, 1			                 ; DC with 6 bits of fraction
  paddw      mm7, [MMX_Round32]              ; rounding+DC for IDCT output
   ; 
  movq       [ecx], mm6                      ; 3:  zero first 4 words
   paddw     mm2, mm7                        ; 3:  add in round
  movq       [ecx+8], mm6                    ; 3:  zero first 4 words
   paddw     mm3, mm7                        ; 3:  add in round
  psraw      mm2, 6                          ; 3:  convert to integer
   ; 
  ;
  ;  main loop:
  ;	This loop is 3-folded and 2-unrolled.  3-folded means that it
  ;	works on 3 different results per iteration.  2-unrolled that
  ;	it produces 2 results per iteration.
  ;
  ;	The result which each instruction works on is identified by a 
  ;	number (1:, 2:, or 3:) at the start of the comment field.  These
  ;	identify 3 stages as follows:
  ;
  ;	Stage	Description
  ;	-----	-----------
  ;	1		Convert the last 4 words of a line to integer, pack together
  ;			into 8 bytes, and write the result. 
  ;	2		Do all processing for the next line:  load and clear 8 words, 
  ;			add in round, convert to integer, pack to bytes, and write
  ;			the result. 
  ;	3		Load and zero all 8 words of a line, add in round,
  ;			and convert the first 4 of them to integers.  (Processing
  ;			of this stage is completed as stage 1 of the next pass.)
  ;
MainLoop:
  movq       mm0, [ecx+16]                   ; 2:  fetch first 4 words
   psraw     mm3, 6                          ; 1:  convert to integer
  movq       mm1, [ecx+24]                   ; 2:  fetch last 4 words
   packuswb  mm2, mm3                        ; 1:  pack and clip
  movq       [ecx+16], mm6                   ; 2:  zero first 4 words
   paddw     mm0, mm7                        ; 2:  add in round
  movq       [ecx+24], mm6                   ; 2:  zero last 4 words
   paddw     mm1, mm7                        ; 2:  add in round
  movq       [edx], mm2                      ; 1:  store result
   psraw     mm0, 6                          ; 2:  convert to integer
  movq       mm2, [ecx+32]                   ; 3:  fetch first 4 words
   psraw     mm1, 6                          ; 2:  convert to integer
  movq       mm3, [ecx+40]                   ; 3:  fetch last 4 words
   packuswb  mm0, mm1                        ; 2:  pack and clip
  movq       [ecx+32], mm6                   ; 2:  zero first 4 words
   paddw     mm2, mm7                        ; 3:  add in round
  movq       [ecx+40], mm6                   ; 2:  zero first 4 words
   paddw     mm3, mm7                        ; 3:  add in round
  movq       [edx+PITCH], mm0                ; 2:  store result
   psraw     mm2, 6                          ; 3:  convert to integer
  add        ecx, 32                         ; increment source pointer
   add       edx, 2*PITCH                    ; increment destination pointer
  dec        eax                             ; decrement loop control
   jne       MainLoop                        ; repeat three times
  ;
  ;  postamble
  ;
  movq       mm0, [ecx+16]                   ; 2:  fetch first 4 words
   psraw     mm3, 6                          ; 1:  convert to integer
  movq       mm1, [ecx+24]                   ; 2:  fetch last 4 words
   packuswb  mm2, mm3                        ; 1:  pack and clip
  paddw      mm0, mm7                        ; 2:  add in round
   paddw     mm1, mm7                        ; 2:  add in round
  movq       [edx], mm2                      ; 1:  store result
   psraw     mm0, 6                          ; 2:  convert to integer
  movq       [ecx+16], mm6                   ; 2:  zero first 4 words
   psraw     mm1, 6                          ; 2:  convert to integer
  movq       [ecx+24], mm6                   ; 2:  zero last 4 words
   packuswb  mm0, mm1                        ; 2:  pack and clip
  movq       [edx+PITCH], mm0                ; 2:  store result
   ret       4

@MMX_ClipAndMove@12 ENDP

;----------------------------------------------------------------------------
;
;  MMX_BlockCopy
;    Copy in chunks of 4 as suggested in MMX guide.  (
;  Parameters:
;    ecx = Pointer to output values
;
;    edx = Pointer to input values
;----------------------------------------------------------------------------
ALIGN 4
@MMX_BlockCopy@8 PROC
;  Parameters
pDst      EQU      ecx      
pSrc      EQU      edx
  movq       mm0, [pSrc]
   ;
  movq       mm1, [pSrc + PITCH]
   ;
  movq       mm2, [pSrc + PITCH*2]
   ;
  movq       mm3, [pSrc + PITCH*3]
   ;
  movq       [pDst], mm0
   ;
  movq       [pDst + PITCH], mm1
   ;
  movq       [pDst + PITCH*2], mm2
   ;
  movq       [pDst + PITCH*3], mm3
   ;
  movq       mm4, [pSrc + PITCH*4]
   ;
  movq       mm5, [pSrc + PITCH*5]
   ;
  movq       mm6, [pSrc + PITCH*6]
   ;
  movq       mm7, [pSrc + PITCH*7]
   ;
  movq       [pDst + PITCH*4], mm4
   ;
  movq       [pDst + PITCH*5], mm5
   ;
  movq       [pDst + PITCH*6], mm6
   ;
  movq       [pDst + PITCH*7], mm7
   ;
  ret
@MMX_BlockCopy@8 ENDP

IFDEF H261
;----------------------------------------------------------------------------
;
;  MMX_BlockCopySpecial
;    Copy in chunks of 4 as suggested in MMX guide.  (
;  Parameters:
;    ecx = Pointer to output values
;
;    edx = Pointer to input values
;----------------------------------------------------------------------------
ALIGN 4
@MMX_BlockCopySpecial@8 PROC
;  Parameters
pDst      EQU      ecx      
pSrc      EQU      edx
PITCH8    EQU      8

  movq       mm0, [pSrc]
   ;
  movq       mm1, [pSrc + PITCH8]
   ;
  movq       mm2, [pSrc + PITCH8*2]
   ;
  movq       mm3, [pSrc + PITCH8*3]
   ;
  movq       [pDst], mm0
   ;
  movq       [pDst + PITCH], mm1
   ;
  movq       [pDst + PITCH*2], mm2
   ;
  movq       [pDst + PITCH*3], mm3
   ;
  movq       mm4, [pSrc + PITCH8*4]
   ;
  movq       mm5, [pSrc + PITCH8*5]
   ;
  movq       mm6, [pSrc + PITCH8*6]
   ;
  movq       mm7, [pSrc + PITCH8*7]
   ;
  movq       [pDst + PITCH*4], mm4
   ;
  movq       [pDst + PITCH*5], mm5
   ;
  movq       [pDst + PITCH*6], mm6
   ;
  movq       [pDst + PITCH*7], mm7
   ;
  ret
@MMX_BlockCopySpecial@8 ENDP
ENDIF


MMXCODE1 ENDS
   
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d35obmc.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/



;--------------------------------------------------------------------------;
;  $Header:   S:\h26x\src\dec\d35obmc.asv   1.2   08 Mar 1996 16:46:06   AGUPTA2  $
;  $Log:   S:\h26x\src\dec\d35obmc.asv  $
;// 
;//    Rev 1.2   08 Mar 1996 16:46:06   AGUPTA2
;// Faster and smaller version of the routine.  Code size reduction achieved
;// by avoiding 32-bit displacement in instructions.
;// 
;// 
;//    Rev 1.1   27 Dec 1995 14:35:52   RMCKENZX
;// Added copyright notice
;
;  d35obmc.asm
;
;  Description
;    This routine performs overlapped block motion compensation for
;    advanced prediction mode.
;
;  Routines:
;    H263OBMC
;
;  Data:
;    This routine assumes that the PITCH is 384.
;
;  Inputs (dwords pushed onto stack by caller):
;    pCurr     flat pointer to current block.
;              Holds values predicted using the
;              motion vector from this block.
;    pLeft     flat pointer to block left of pCurr.
;              Holds values predicted using the
;              motion vector of the left-hand block.
;    pRight    flat pointer to block right of pCurr
;              Holds values predicted using the
;              motion vector of the right-hand block.
;    pAbove    flat pointer to block above pCurr
;              Holds values predicted using the
;              motion vector of the above block.
;    pBelow    flat pointer to block below pCurr
;              Holds values predicted using the
;              motion vector of the below block.
;    pRef      flat pointer to the new predicted values
;              to be computed by this routine.
;
;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35obmc.asv   1.2   08 Mar 1996 16:46:06   AGUPTA2  $
;  $Log$
;// 
;//    Rev 1.0   29 Nov 1995 12:47:28   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;
;
;  Register Usage:
;
    Cent      EQU    esi    ; pCurr
    Comp      EQU    edi    ; pRef
    Horz      EQU    ebp    ; pLeft or pRight
    Vert      EQU    edx    ; pAbove or pBelow
;
;              eax, ebx       accumulators for new predicted values
;                   ecx       temporary
;
;--------------------------------------------------------------------------;
;
;  Notes:  	
;	This routine is fully unrolled.
;
;	The basic computational unit consists of 8 instructions and is 2-folded,
;	meaning that it works on 2 results (the new one in Stage I, the old one
;   in Stage II, see below) at a time.  It uses 3 loads, 3 additions (1 or
;   2 of which are done by the lea instruction), 1 shift, and one store per
;	result computed.  The two stages are interleaved on a 1-1 basis.
;
;  Stage 1:
;	Load Accumulator with Center Value
;	Load Temporary with Horz/Vert Value
;	Accumulator =(lea) x1 times Accumulator plus r0
;	Accumulator =(lea or add) x2 times Accumulator plus x3 times Temporary
;  Stage 2:
;	Load Temporary with other Horz/Vert Value
;	Accumulator =(add) Accumlator plus Temporary
;	Shift Accumlator right s0 bits
; 	Store Accumulator
;
;	where with various values for x1, x2, x3, round, and shift we achieve
;	the needed weighted averages:
;
;                Weights	
;            Cent    Horz/Vert         x1     x2     x3     r0     s0
;   corners   4      2       2          2      1      1      2      2      
;   edges     5      2       1          5      1      2      4      3
;   center    6      1       1          3      2      1      2      3
;
;	This routine uses 4 pointers -- 3 of the 5 input pointers and one
;	output pointer.  The horizontal pointer is adjusted at the middle
;	of each line, and all 4 pointers at the end of each line in order
;	to avoid using large offsets.  This sacrifices some speed in order
;	to hold down code size.  
;
;	If all of its inputs were at some small,
;   fixed offset from a single address, it could be considerably
;	simplified. 
;    
;--------------------------------------------------------------------------;

PITCH   =   384
.586
IACODE2 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE2 ENDS

IACODE2 SEGMENT

PUBLIC _H263OBMC
; input parameters before locals
  pCurr       EQU    esp+20
  pLeft       EQU    esp+24
  pRight      EQU    esp+28
  pAbove      EQU    esp+32
  pBelow      EQU    esp+36
  pRef        EQU    esp+40

; locals
  LeftToRight    EQU    esp+00
  RightToLeft    EQU    esp+04
  AboveToBelow   EQU    esp+08

; saved registers and other stuff
; unused             esp+12
; ebp                esp+16
; esi                esp+20
; ebx                esp+24
; edi                esp+28
; return address     esp+32

; input parameters after locals
  nCurr       EQU    esp+36
  nLeft       EQU    esp+40
  nRight      EQU    esp+44
  nAbove      EQU    esp+48
  nBelow      EQU    esp+52
  nRef        EQU    esp+56

  FRAMESIZE = 16

_H263OBMC:

;  set up
  push     edi
  push     ebx

  push     esi
  push     ebp

  mov      Vert, [pAbove]
  mov      Horz, [pLeft]

  mov      Cent, [pCurr]
  mov      ecx, [pRight]

  mov      eax, [pBelow]
  sub      esp, FRAMESIZE

  sub      ecx, Horz
  sub      eax, Vert

  mov      ebx, PITCH
  mov      [LeftToRight], ecx         ; pRight - pLeft

  add      eax, ebx
  sub      ebx, ecx

  mov      [AboveToBelow], eax        ; pBelow - pAbove + PITCH
  xor      eax, eax


;
;  We start with the upper left corner
;  we go left to right, then drop down
;  to the next row and repeat.
;
  xor      ecx, ecx
  mov      al, [Cent]                  ; start ->00=eax

  mov      [RightToLeft], ebx          ; PITCH + pLeft - pRight
  mov      cl, [Vert]                  ; 00

  xor      ebx, ebx
  lea      eax, [2*eax+2]              ; 00

  mov      Comp, [nRef]
  add      eax, ecx                    ; 00



  mov      cl, [Horz]                  ; 00
  mov      bl, 1[Cent]                 ; start ->01=ebx

  add      eax, ecx                    ; 00
  mov      cl, 1[Vert]                 ; 01

  sar      eax, 2                      ; 00
  lea      ebx, [ebx+4*ebx+4]          ; 01

  mov      [Comp], al                  ; complete <-00=al
  lea      ebx, [ebx+2*ecx]            ; 01



  mov      cl, 1[Horz]                 ; 01
  mov      al, 2[Cent]                 ; start ->02=eax

  add      ebx, ecx                    ; 01
  mov      cl, 2[Vert]                 ; 02

  sar      ebx, 3                      ; 01
  lea      eax, [eax+4*eax+4]          ; 02

  mov      1[Comp], bl                 ; complete <-01=bl
  lea      eax, [eax+2*ecx]            ; 02



  mov      cl, 2[Horz]                 ; 02
  mov      bl, 3[Cent]                 ; start ->03=ebx

  add      eax, ecx                    ; 02
  mov      cl, 3[Vert]                 ; 03

  sar      eax, 3                      ; 02
  lea      ebx, [ebx+4*ebx+4]          ; 03

  mov      2[Comp], al                 ; complete <-02=al
  lea      ebx, [ebx+2*ecx]            ; 03



  mov      cl, 3[Horz]                 ; 03
  mov      al, 4[Cent]                 ; start ->04=eax

  mov      Horz, [nRight]
  add      ebx, ecx                    ; 03

  mov      cl, 4[Vert]                 ; 04

  sar      ebx, 3                      ; 03
  lea      eax, [eax+4*eax+4]          ; 04

  mov      3[Comp], bl                 ; complete <-03=bl
  lea      eax, [eax+2*ecx]            ; 04



  mov      cl, 4[Horz]                 ; 04
  mov      bl, 5[Cent]                 ; start ->05=ebx

  add      eax, ecx                    ; 04
  mov      cl, 5[Vert]                 ; 05

  sar      eax, 3                      ; 04
  lea      ebx, [ebx+4*ebx+4]          ; 05

  mov      4[Comp], al                 ; complete <-04=al
  lea      ebx, [ebx+2*ecx]            ; 05



  mov      cl, 5[Horz]                 ; 05
  mov      al, 6[Cent]                 ; start ->06=eax

  add      ebx, ecx                    ; 05
  mov      cl, 6[Vert]                 ; 06

  sar      ebx, 3                      ; 05
  lea      eax, [eax+4*eax+4]          ; 06

  mov      5[Comp], bl                 ; complete <-05=bl
  lea      eax, [eax+2*ecx]            ; 06



  mov      cl, 6[Horz]                 ; 06
  mov      bl, 7[Cent]                 ; start ->07=ebx

  add      eax, ecx                    ; 06
  mov      cl, 7[Horz]                 ; 07

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 06
  lea      ebx, [2*ebx+2]              ; 07

  mov      6[Comp], al                 ; complete <-06=al
  add      ebx, ecx                    ; 07



  mov      cl, 7[Vert]                 ; 07
  mov      al, 0[Cent]                 ; start ->10=eax

  add      ebx, ecx                    ; 07
  mov      cl, 0[Horz]                 ; 10

  sar      ebx, 2                      ; 07
  lea      eax, [eax+4*eax+4]          ; 10

  mov      7[Comp], bl                 ; complete <-07=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 10
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 10
  mov      bl, 1[Cent]                 ; start ->11=ebx

  add      eax, ecx                    ; 10
  mov      cl, 1[Horz]                 ; 11

  sar      eax, 3                      ; 10
  lea      ebx, [ebx+4*ebx+4]          ; 11

  mov      0[Comp], al                 ; complete <-10=al
  lea      ebx, [ebx+2*ecx]            ; 11



  mov      cl, 1[Vert]                 ; 11
  mov      al, 2[Cent]                 ; start ->12=eax

  add      ebx, ecx                    ; 11
  mov      cl, 2[Vert]                 ; 12

  sar      ebx, 3                      ; 11
  lea      eax, [eax+4*eax+4]          ; 12

  mov      1[Comp], bl                 ; complete <-11=bl
  lea      eax, [eax+2*ecx]            ; 12



  mov      cl, 2[Horz]                 ; 12
  mov      bl, 3[Cent]                 ; start ->13=ebx

  add      eax, ecx                    ; 12
  mov      cl, 3[Vert]                 ; 13

  sar      eax, 3                      ; 12
  lea      ebx, [ebx+4*ebx+4]          ; 13

  mov      2[Comp], al                 ; complete <-12=al
  lea      ebx, [ebx+2*ecx]            ; 13



  mov      cl, 3[Horz]                 ; 13
  mov      al, 4[Cent]                 ; start ->14=eax

  add      ebx, ecx                    ; 13
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 14

  sar      ebx, 3                      ; 13
  lea      eax, [eax+4*eax+4]          ; 14

  mov      3[Comp], bl                 ; complete <-13=bl
  lea      eax, [eax+2*ecx]            ; 14



  mov      cl, 4[Horz]                 ; 14
  mov      bl, 5[Cent]                 ; start ->15=ebx

  add      eax, ecx                    ; 14
  mov      cl, 5[Vert]                 ; 15

  sar      eax, 3                      ; 14
  lea      ebx, [ebx+4*ebx+4]          ; 15

  mov      4[Comp], al                 ; complete <-14=al
  lea      ebx, [ebx+2*ecx]            ; 15



  mov      cl, 5[Horz]                 ; 15
  mov      al, 6[Cent]                 ; start ->16=eax

  add      ebx, ecx                    ; 15
  mov      cl, 6[Horz]                 ; 16

  sar      ebx, 3                      ; 15
  lea      eax, [eax+4*eax+4]          ; 16

  mov      5[Comp], bl                 ; complete <-15=bl
  lea      eax, [eax+2*ecx]            ; 16



  mov      cl, 6[Vert]                 ; 16
  mov      bl, 7[Cent]                 ; start ->17=ebx

  add      eax, ecx                    ; 16
  mov      cl, 7[Horz]                 ; 17

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 16
  lea      ebx, [ebx+4*ebx+4]          ; 17

  mov      6[Comp], al                 ; complete <-16=al
  lea      ebx, [ebx+2*ecx]            ; 17



  mov      cl, 7[Vert]                 ; 17
  mov      al, 0[Cent]                 ; start ->20=eax

  add      ebx, ecx                    ; 17
  mov      cl, 0[Horz]                 ; 20

  sar      ebx, 3                      ; 17
  lea      eax, [eax+4*eax+4]          ; 20

  mov      7[Comp], bl                 ; complete <-17=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 20
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 20
  mov      bl, 1[Cent]                 ; start ->21=ebx

  add      eax, ecx                    ; 20
  mov      cl, 1[Horz]                 ; 21

  sar      eax, 3                      ; 20
  lea      ebx, [ebx+4*ebx+4]          ; 21

  mov      0[Comp], al                 ; complete <-20=al
  lea      ebx, [ebx+2*ecx]            ; 21



  mov      cl, 1[Vert]                 ; 21
  mov      al, 2[Cent]                 ; start ->22=eax

  add      ebx, ecx                    ; 21
  mov      cl, 2[Vert]                 ; 22

  sar      ebx, 3                      ; 21
  lea      eax, [eax+2*eax+2]          ; 22

  mov      1[Comp], bl                 ; complete <-21=bl
  lea      eax, [2*eax+ecx]            ; 22



  mov      cl, 2[Horz]                 ; 22
  mov      bl, 3[Cent]                 ; start ->23=ebx

  add      eax, ecx                    ; 22
  mov      cl, 3[Vert]                 ; 23

  sar      eax, 3                      ; 22
  lea      ebx, [ebx+2*ebx+2]          ; 23

  mov      2[Comp], al                 ; complete <-22=al
  lea      ebx, [2*ebx+ecx]            ; 23



  mov      cl, 3[Horz]                 ; 23
  mov      al, 4[Cent]                 ; start ->24=eax

  add      ebx, ecx                    ; 23
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 24

  sar      ebx, 3                      ; 23
  lea      eax, [eax+2*eax+2]          ; 24

  mov      3[Comp], bl                 ; complete <-23=bl
  lea      eax, [2*eax+ecx]            ; 24



  mov      cl, 4[Horz]                 ; 24
  mov      bl, 5[Cent]                 ; start ->25=ebx

  add      eax, ecx                    ; 24
  mov      cl, 5[Vert]                 ; 25

  sar      eax, 3                      ; 24
  lea      ebx, [ebx+2*ebx+2]          ; 25

  mov      4[Comp], al                 ; complete <-24=al
  lea      ebx, [2*ebx+ecx]            ; 25



  mov      cl, 5[Horz]                 ; 25
  mov      al, 6[Cent]                 ; start ->26=eax

  add      ebx, ecx                    ; 25
  mov      cl, 6[Horz]                 ; 26

  sar      ebx, 3                      ; 25
  lea      eax, [eax+4*eax+4]          ; 26

  mov      5[Comp], bl                 ; complete <-25=bl
  lea      eax, [eax+2*ecx]            ; 26



  mov      cl, 6[Vert]                 ; 26
  mov      bl, 7[Cent]                 ; start ->27=ebx

  add      eax, ecx                    ; 26
  mov      cl, 7[Horz]                 ; 27

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 26
  lea      ebx, [ebx+4*ebx+4]          ; 27

  mov      6[Comp], al                 ; complete <-26=al
  lea      ebx, [ebx+2*ecx]            ; 27



  mov      cl, 7[Vert]                 ; 27
  mov      al, 0[Cent]                 ; start ->30=eax

  add      ebx, ecx                    ; 27
  mov      cl, 0[Horz]                 ; 30

  sar      ebx, 3                      ; 27
  lea      eax, [eax+4*eax+4]          ; 30

  mov      7[Comp], bl                 ; complete <-27=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 30
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 30
  mov      bl, 1[Cent]                 ; start ->31=ebx

  add      eax, ecx                    ; 30
  mov      cl, 1[Horz]                 ; 31

  sar      eax, 3                      ; 30
  lea      ebx, [ebx+4*ebx+4]          ; 31

  mov      0[Comp], al                 ; complete <-30=al
  lea      ebx, [ebx+2*ecx]            ; 31



  mov      cl, 1[Vert]                 ; 31
  mov      al, 2[Cent]                 ; start ->32=eax

  add      ebx, ecx                    ; 31
  mov      cl, 2[Vert]                 ; 32

  sar      ebx, 3                      ; 31
  lea      eax, [eax+2*eax+2]          ; 32

  mov      1[Comp], bl                 ; complete <-31=bl
  lea      eax, [2*eax+ecx]            ; 32



  mov      cl, 2[Horz]                 ; 32
  mov      bl, 3[Cent]                 ; start ->33=ebx

  add      eax, ecx                    ; 32
  mov      cl, 3[Vert]                 ; 33

  sar      eax, 3                      ; 32
  lea      ebx, [ebx+2*ebx+2]          ; 33

  mov      2[Comp], al                 ; complete <-32=al
  lea      ebx, [2*ebx+ecx]            ; 33



  mov      cl, 3[Horz]                 ; 33
  mov      al, 4[Cent]                 ; start ->34=eax

  add      ebx, ecx                    ; 33
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 34

  sar      ebx, 3                      ; 33
  lea      eax, [eax+2*eax+2]          ; 34

  mov      3[Comp], bl                 ; complete <-33=bl
  lea      eax, [2*eax+ecx]            ; 34



  mov      cl, 4[Horz]                 ; 34
  mov      bl, 5[Cent]                 ; start ->35=ebx

  add      eax, ecx                    ; 34
  mov      cl, 5[Vert]                 ; 35

  sar      eax, 3                      ; 34
  lea      ebx, [ebx+2*ebx+2]          ; 35

  mov      4[Comp], al                 ; complete <-34=al
  lea      ebx, [2*ebx+ecx]            ; 35



  mov      cl, 5[Horz]                 ; 35
  mov      al, 6[Cent]                 ; start ->36=eax

  add      ebx, ecx                    ; 35
  mov      cl, 6[Horz]                 ; 36

  sar      ebx, 3                      ; 35
  lea      eax, [eax+4*eax+4]          ; 36

  mov      5[Comp], bl                 ; complete <-35=bl
  lea      eax, [eax+2*ecx]            ; 36



  mov      cl, 6[Vert]                 ; 36
  mov      bl, 7[Cent]                 ; start ->37=ebx

  add      eax, ecx                    ; 36
  mov      cl, 7[Horz]                 ; 37

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 36
  lea      ebx, [ebx+4*ebx+4]          ; 37

  mov      6[Comp], al                 ; complete <-36=al
  lea      ebx, [ebx+2*ecx]            ; 37



  mov      cl, 7[Vert]                 ; 37
  mov      al, 0[Cent]                 ; start ->40=eax

  add      ebx, ecx                    ; 37
  mov      cl, 0[Horz]                 ; 40

  sar      ebx, 3                      ; 37
  lea      eax, [eax+4*eax+4]          ; 40

  mov      7[Comp], bl                 ; complete <-37=bl
  add      Vert, [AboveToBelow]

  lea      eax, [eax+2*ecx]            ; 40
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 40
  mov      bl, 1[Cent]                 ; start ->41=ebx

  add      eax, ecx                    ; 40
  mov      cl, 1[Horz]                 ; 41

  sar      eax, 3                      ; 40
  lea      ebx, [ebx+4*ebx+4]          ; 41

  mov      0[Comp], al                 ; complete <-40=al
  lea      ebx, [ebx+2*ecx]            ; 41



  mov      cl, 1[Vert]                 ; 41
  mov      al, 2[Cent]                 ; start ->42=eax

  add      ebx, ecx                    ; 41
  mov      cl, 2[Vert]                 ; 42

  sar      ebx, 3                      ; 41
  lea      eax, [eax+2*eax+2]          ; 42

  mov      1[Comp], bl                 ; complete <-41=bl
  lea      eax, [2*eax+ecx]            ; 42



  mov      cl, 2[Horz]                 ; 42
  mov      bl, 3[Cent]                 ; start ->43=ebx

  add      eax, ecx                    ; 42
  mov      cl, 3[Vert]                 ; 43

  sar      eax, 3                      ; 42
  lea      ebx, [ebx+2*ebx+2]          ; 43

  mov      2[Comp], al                 ; complete <-42=al
  lea      ebx, [2*ebx+ecx]            ; 43



  mov      cl, 3[Horz]                 ; 43
  mov      al, 4[Cent]                 ; start ->44=eax

  add      ebx, ecx                    ; 43
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 44

  sar      ebx, 3                      ; 43
  lea      eax, [eax+2*eax+2]          ; 44

  mov      3[Comp], bl                 ; complete <-43=bl
  lea      eax, [2*eax+ecx]            ; 44



  mov      cl, 4[Horz]                 ; 44
  mov      bl, 5[Cent]                 ; start ->45=ebx

  add      eax, ecx                    ; 44
  mov      cl, 5[Vert]                 ; 45

  sar      eax, 3                      ; 44
  lea      ebx, [ebx+2*ebx+2]          ; 45

  mov      4[Comp], al                 ; complete <-44=al
  lea      ebx, [2*ebx+ecx]            ; 45



  mov      cl, 5[Horz]                 ; 45
  mov      al, 6[Cent]                 ; start ->46=eax

  add      ebx, ecx                    ; 45
  mov      cl, 6[Horz]                 ; 46

  sar      ebx, 3                      ; 45
  lea      eax, [eax+4*eax+4]          ; 46

  mov      5[Comp], bl                 ; complete <-45=bl
  lea      eax, [eax+2*ecx]            ; 46



  mov      cl, 6[Vert]                 ; 46
  mov      bl, 7[Cent]                 ; start ->47=ebx

  add      eax, ecx                    ; 46
  mov      cl, 7[Horz]                 ; 47

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 46
  lea      ebx, [ebx+4*ebx+4]          ; 47

  mov      6[Comp], al                 ; complete <-46=al
  lea      ebx, [ebx+2*ecx]            ; 47



  mov      cl, 7[Vert]                 ; 47
  mov      al, 0[Cent]                 ; start ->50=eax

  add      ebx, ecx                    ; 47
  mov      cl, 0[Horz]                 ; 50

  sar      ebx, 3                      ; 47
  lea      eax, [eax+4*eax+4]          ; 50

  mov      7[Comp], bl                 ; complete <-47=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 50
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 50
  mov      bl, 1[Cent]                 ; start ->51=ebx

  add      eax, ecx                    ; 50
  mov      cl, 1[Horz]                 ; 51

  sar      eax, 3                      ; 50
  lea      ebx, [ebx+4*ebx+4]          ; 51

  mov      0[Comp], al                 ; complete <-50=al
  lea      ebx, [ebx+2*ecx]            ; 51



  mov      cl, 1[Vert]                 ; 51
  mov      al, 2[Cent]                 ; start ->52=eax

  add      ebx, ecx                    ; 51
  mov      cl, 2[Vert]                 ; 52

  sar      ebx, 3                      ; 51
  lea      eax, [eax+2*eax+2]          ; 52

  mov      1[Comp], bl                 ; complete <-51=bl
  lea      eax, [2*eax+ecx]            ; 52



  mov      cl, 2[Horz]                 ; 52
  mov      bl, 3[Cent]                 ; start ->53=ebx

  add      eax, ecx                    ; 52
  mov      cl, 3[Vert]                 ; 53

  sar      eax, 3                      ; 52
  lea      ebx, [ebx+2*ebx+2]          ; 53

  mov      2[Comp], al                 ; complete <-52=al
  lea      ebx, [2*ebx+ecx]            ; 53



  mov      cl, 3[Horz]                 ; 53
  mov      al, 4[Cent]                 ; start ->54=eax

  add      ebx, ecx                    ; 53
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 54

  sar      ebx, 3                      ; 53
  lea      eax, [eax+2*eax+2]          ; 54

  mov      3[Comp], bl                 ; complete <-53=bl
  lea      eax, [2*eax+ecx]            ; 54



  mov      cl, 4[Horz]                 ; 54
  mov      bl, 5[Cent]                 ; start ->55=ebx

  add      eax, ecx                    ; 54
  mov      cl, 5[Vert]                 ; 55

  sar      eax, 3                      ; 54
  lea      ebx, [ebx+2*ebx+2]          ; 55

  mov      4[Comp], al                 ; complete <-54=al
  lea      ebx, [2*ebx+ecx]            ; 55



  mov      cl, 5[Horz]                 ; 55
  mov      al, 6[Cent]                 ; start ->56=eax

  add      ebx, ecx                    ; 55
  mov      cl, 6[Horz]                 ; 56

  sar      ebx, 3                      ; 55
  lea      eax, [eax+4*eax+4]          ; 56

  mov      5[Comp], bl                 ; complete <-55=bl
  lea      eax, [eax+2*ecx]            ; 56



  mov      cl, 6[Vert]                 ; 56
  mov      bl, 7[Cent]                 ; start ->57=ebx

  add      eax, ecx                    ; 56
  mov      cl, 7[Horz]                 ; 57

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 56
  lea      ebx, [ebx+4*ebx+4]          ; 57

  mov      6[Comp], al                 ; complete <-56=al
  lea      ebx, [ebx+2*ecx]            ; 57



  mov      cl, 7[Vert]                 ; 57
  mov      al, 0[Cent]                 ; start ->60=eax

  add      ebx, ecx                    ; 57
  mov      cl, 0[Horz]                 ; 60

  sar      ebx, 3                      ; 57
  lea      eax, [eax+4*eax+4]          ; 60

  mov      7[Comp], bl                 ; complete <-57=bl
  add      Vert, PITCH

  lea      eax, [eax+2*ecx]            ; 60
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 60
  mov      bl, 1[Cent]                 ; start ->61=ebx

  add      eax, ecx                    ; 60
  mov      cl, 1[Horz]                 ; 61

  sar      eax, 3                      ; 60
  lea      ebx, [ebx+4*ebx+4]          ; 61

  mov      0[Comp], al                 ; complete <-60=al
  lea      ebx, [ebx+2*ecx]            ; 61



  mov      cl, 1[Vert]                 ; 61
  mov      al, 2[Cent]                 ; start ->62=eax

  add      ebx, ecx                    ; 61
  mov      cl, 2[Vert]                 ; 62

  sar      ebx, 3                      ; 61
  lea      eax, [eax+4*eax+4]          ; 62

  mov      1[Comp], bl                 ; complete <-61=bl
  lea      eax, [eax+2*ecx]            ; 62



  mov      cl, 2[Horz]                 ; 62
  mov      bl, 3[Cent]                 ; start ->63=ebx

  add      eax, ecx                    ; 62
  mov      cl, 3[Vert]                 ; 63

  sar      eax, 3                      ; 62
  lea      ebx, [ebx+4*ebx+4]          ; 63

  mov      2[Comp], al                 ; complete <-62=al
  lea      ebx, [ebx+2*ecx]            ; 63



  mov      cl, 3[Horz]                 ; 63
  mov      al, 4[Cent]                 ; start ->64=eax

  add      ebx, ecx                    ; 63
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 64

  sar      ebx, 3                      ; 63
  lea      eax, [eax+4*eax+4]          ; 64

  mov      3[Comp], bl                 ; complete <-63=bl
  lea      eax, [eax+2*ecx]            ; 64



  mov      cl, 4[Horz]                 ; 64
  mov      bl, 5[Cent]                 ; start ->65=ebx

  add      eax, ecx                    ; 64
  mov      cl, 5[Vert]                 ; 65

  sar      eax, 3                      ; 64
  lea      ebx, [ebx+4*ebx+4]          ; 65

  mov      4[Comp], al                 ; complete <-64=al
  lea      ebx, [ebx+2*ecx]            ; 65



  mov      cl, 5[Horz]                 ; 65
  mov      al, 6[Cent]                 ; start ->66=eax

  add      ebx, ecx                    ; 65
  mov      cl, 6[Horz]                 ; 66

  sar      ebx, 3                      ; 65
  lea      eax, [eax+4*eax+4]          ; 66

  mov      5[Comp], bl                 ; complete <-65=bl
  lea      eax, [eax+2*ecx]            ; 66



  mov      cl, 6[Vert]                 ; 66
  mov      bl, 7[Cent]                 ; start ->67=ebx

  add      eax, ecx                    ; 66
  mov      cl, 7[Horz]                 ; 67

  add      Cent, PITCH
  add      Horz, [RightToLeft]

  sar      eax, 3                      ; 66
  lea      ebx, [ebx+4*ebx+4]          ; 67

  mov      6[Comp], al                 ; complete <-66=al
  lea      ebx, [ebx+2*ecx]            ; 67



  mov      cl, 7[Vert]                 ; 67
  mov      al, 0[Cent]                 ; start ->70=eax

  add      ebx, ecx                    ; 67
  mov      cl, 0[Horz]                 ; 70

  sar      ebx, 3                      ; 67
  lea      eax, [2*eax+2]              ; 70

  mov      7[Comp], bl                 ; complete <-67=bl
  add      Vert, PITCH

  add      eax, ecx                    ; 70
  add      Comp, PITCH



  mov      cl, 0[Vert]                 ; 70
  mov      bl, 1[Cent]                 ; start ->71=ebx

  add      eax, ecx                    ; 70
  mov      cl, 1[Vert]                 ; 71

  sar      eax, 2                      ; 70
  lea      ebx, [ebx+4*ebx+4]          ; 71

  mov      0[Comp], al                 ; complete <-70=al
  lea      ebx, [ebx+2*ecx]            ; 71



  mov      cl, 1[Horz]                 ; 71
  mov      al, 2[Cent]                 ; start ->72=eax

  add      ebx, ecx                    ; 71
  mov      cl, 2[Vert]                 ; 72

  sar      ebx, 3                      ; 71
  lea      eax, [eax+4*eax+4]          ; 72

  mov      1[Comp], bl                 ; complete <-71=bl
  lea      eax, [eax+2*ecx]            ; 72



  mov      cl, 2[Horz]                 ; 72
  mov      bl, 3[Cent]                 ; start ->73=ebx

  add      eax, ecx                    ; 72
  mov      cl, 3[Vert]                 ; 73

  sar      eax, 3                      ; 72
  lea      ebx, [ebx+4*ebx+4]          ; 73

  mov      2[Comp], al                 ; complete <-72=al
  lea      ebx, [ebx+2*ecx]            ; 73



  mov      cl, 3[Horz]                 ; 73
  mov      al, 4[Cent]                 ; start ->74=eax

  add      ebx, ecx                    ; 73
  add      Horz, [LeftToRight]

  mov      cl, 4[Vert]                 ; 74

  sar      ebx, 3                      ; 73
  lea      eax, [eax+4*eax+4]          ; 74

  mov      3[Comp], bl                 ; complete <-73=bl
  lea      eax, [eax+2*ecx]            ; 74



  mov      cl, 4[Horz]                 ; 74
  mov      bl, 5[Cent]                 ; start ->75=ebx

  add      eax, ecx                    ; 74
  mov      cl, 5[Vert]                 ; 75

  sar      eax, 3                      ; 74
  lea      ebx, [ebx+4*ebx+4]          ; 75

  mov      4[Comp], al                 ; complete <-74=al
  lea      ebx, [ebx+2*ecx]            ; 75



  mov      cl, 5[Horz]                 ; 75
  mov      al, 6[Cent]                 ; start ->76=eax

  add      ebx, ecx                    ; 75
  mov      cl, 6[Vert]                 ; 76

  sar      ebx, 3                      ; 75
  lea      eax, [eax+4*eax+4]          ; 76

  mov      5[Comp], bl                 ; complete <-75=bl
  lea      eax, [eax+2*ecx]            ; 76



  mov      cl, 6[Horz]                 ; 76
  mov      bl, 7[Cent]                 ; start ->77=ebx

  add      eax, ecx                    ; 76
  mov      cl, 7[Horz]                 ; 77

  sar      eax, 3                      ; 76
  lea      ebx, [2*ebx+2]              ; 77

  mov      6[Comp], al                 ; complete <-76=al
  add      ebx, ecx                    ; 77



  mov      cl, 7[Vert]                 ; 77
  add      esp, FRAMESIZE

  add      ebx, ecx                    ; 77

  sar      ebx, 2                      ; 77
  pop      ebp

  mov      7[Comp], bl                 ; complete <-77=bl
  pop      esi

;
;  wrap up and go home with the job well done
;


  pop      ebx
  pop      edi

  ret

IACODE2 ENDS

END
//  h263obmc1.asm	page 17	5:02 PM, 10/29/95  //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dx5aspec.asm ===
;* *************************************************************************
;*    INTEL Corporation Proprietary Information
;*
;*    This listing is supplied under the terms of a license
;*    agreement with INTEL Corporation and may not be copied
;*    nor disclosed except in accordance with the terms of
;*    that agreement.
;*
;*    Copyright (c) 1995 Intel Corporation.
;*    All Rights Reserved.
;*
;* *************************************************************************

;* -------------------------------------------------------------------------
;* PVCS Source control information:
;*
;*	$Header:   S:\h26x\src\dec\dx5aspec.asv   1.2   01 Sep 1995 17:12:12   DBRUCKS  $
;*
;*	$Log:   S:\h26x\src\dec\dx5aspec.asv  $
;// 
;//    Rev 1.2   01 Sep 1995 17:12:12   DBRUCKS
;// fix shaping
;// 
;//    Rev 1.1   29 Aug 1995 16:49:02   DBRUCKS
;// cleanup comment
;// 
;//    Rev 1.0   23 Aug 1995 12:20:32   DBRUCKS
;// Initial revision.
;*  
;*  NOTE: 
;*			The starting source for this routine came from the PVCS database
;*			for the H261 decoder (aspeccor.asm version 1.1, which is a working
;*          16-bit version).
;* -------------------------------------------------------------------------

;////////////////////////////////////////////////////////////////////////////
; AspectCorrect  -- This function converts the U & V data from 8 bits to 7 bits
;                   and moves the data into the YVU9 format the MRV color
;                   convertors want.  Note: the Y data was already converted
;                   from 8 bits to 7 bits in Convert_Y_8to7_Bit.
;
; 	if (Input Format == YVU9)
;		/* This is needed for looking glass output */
;		copy U and V from src to dst
;	else { /* Input Format == YVU12 */
;		if (shaping) {
;			copy Y from src to dst skiping every 12th line
;			copy UV from src to dst subsampling and dropping one in 12 lines 
;				(although not every 12th).
;		} else {
;			copy UV from src to dst subsampling
;		}
;	}
;        
;	Notes: 
;	* the MRV color converters expect YVU9
;	* we may need to drop every 12th line for aspect ratio correction of the
;	  YVU12 input.
;
;   ASSUMPTIONS/LIMITATIONS:
;   * IF input in YVU12, only 128x96, 176x144, & 352x288 resolutions are 
;     supported.  YVU9 should support all sizes.
;
;-------------------------------------------------------------------------------

include decconst.inc

ifndef WIN32
.MODEL SMALL
endif

.486

ifdef WIN32
.MODEL FLAT
.DATA

else ;; WIN16
_DATA	SEGMENT PUBLIC 'DATA'
endif

;;	Toss lines for aspect ratio correction 12 to 9
;;        6, 19, 30, 43, 54, 67,
;;       78, 91,102,115,126,139

;;	Lookup Table for 8->7 bit conversion and clamping.
;;  U and V range from 16..240->8..120
gTAB_UVtbl8to7  BYTE      8,  8,  8,  8,  8,  8,  8,  8
				BYTE      8,  8,  8,  8,  8,  8,  8,  8  
				BYTE      8,  8,  9,  9, 10, 10, 11, 11
				BYTE     12, 12, 13, 13, 14, 14, 15, 15
				BYTE     16, 16, 17, 17, 18, 18, 19, 19
				BYTE     20, 20, 21, 21, 22, 22, 23, 23
				BYTE     24, 24, 25, 25, 26, 26, 27, 27
				BYTE     28, 28, 29, 29, 30, 30, 31, 31
				BYTE     32, 32, 33, 33, 34, 34, 35, 35
				BYTE     36, 36, 37, 37, 38, 38, 39, 39
				BYTE     40, 40, 41, 41, 42, 42, 43, 43 
				BYTE     44, 44, 45, 45, 46, 46, 47, 47
				BYTE     48, 48, 49, 49, 50, 50, 51, 51
				BYTE     52, 52, 53, 53, 54, 54, 55, 55
				BYTE     56, 56, 57, 57, 58, 58, 59, 59
				BYTE     60, 60, 61, 61, 62, 62, 63, 63
				BYTE     64, 64, 65, 65, 66, 66, 67, 67
				BYTE     68, 68, 69, 69, 70, 70, 71, 71
				BYTE     72, 72, 73, 73, 74, 74, 75, 75
				BYTE     76, 76, 77, 77, 78, 78, 79, 79
				BYTE     80, 80, 81, 81, 82, 82, 83, 83
				BYTE     84, 84, 85, 85, 86, 86, 87, 87
				BYTE     88, 88, 89, 89, 90, 90, 91, 91
				BYTE     92, 92, 93, 93, 94, 94, 95, 95
				BYTE     96, 96, 97, 97, 98, 98, 99, 99
				BYTE    100,100,101,101,102,102,103,103
				BYTE    104,104,105,105,106,106,107,107
				BYTE    108,108,109,109,110,110,111,111
				BYTE    112,112,113,113,114,114,115,115
				BYTE    116,116,117,117,118,118,119,119
				BYTE    120,120,120,120,120,120,120,120
				BYTE    120,120,120,120,120,120,120,120

_DATA	ENDS

ifdef WIN32
.CODE
assume cs : flat
assume ds : flat
assume es : flat
assume fs : flat
assume gs : flat

else
_TEXT32 SEGMENT PUBLIC READONLY USE32 'CODE'
ASSUME	DS:_DATA
ASSUME	CS:_TEXT32
ASSUME	ES:nothing
ASSUME	FS:nothing
ASSUME	GS:nothing
endif

;C function prototype
;
;long AspectCorrect(
;			HPBYTE      pYPlaneInput,  /*ptr Y plane*/
;		    HPBYTE      pVPlaneInput,  /*ptr V plane*/
;		    HPBYTE      pUPlaneInput,  /*ptr U plane*/
;		    DWORD       YResolution,   /*Y plane height*/
;		    DWORD       XResolution,   /*Y plane width*/
;		    WORD far  * pyNewHeight,   /*Pitch of Y plane in*/
;		    DWORD		YVU9InputFlag, /*flag = YUV9 or YUV12*/
;		    HPBYTE      pYPlaneOutput, /*pYOut*/
;		    HPBYTE      pVPlaneOutput, /*pUOut*/
;		    DWORD       YPitchOut,     /*Pitch of Y plane out*/
;		    DWORD		ShapingFlag	   /*flag = Shaping or not*/
;		    )

PUBLIC _AspectCorrect

ifdef WIN32
_AspectCorrect proc

else
_AspectCorrect proc far
;   parmD    pYPlaneIn        ;ptr to Y input plane
;   parmD    pVPlaneIn        ;ptr to V input plane
;   parmD    pUPlaneIn        ;ptr to U input plane
;   parmD    YRes             ;Y plane height
;   parmD    XRes             ;Y plane width
;   parmD    pYNewHeight      ;Pitch of Y plane input
;   parmD    YVU9Flag         ;Flag=1 if YUV9
;   parmD    pYPlaneOut       ;ptr to Y output plane
;   parmD    pVPlaneOut       ;ptr to V output plane
;   parmD    YPitchOut        ;Pitch of Y plane output
;   parmD    ShapingFlag      ;Flag=1 if Shaping

endif


;set up equates
pYPlaneIn   EQU  DWORD PTR[ebp+8]
pVPlaneIn   EQU  DWORD PTR[ebp+12]
pUPlaneIn   EQU  DWORD PTR[ebp+16]
YRes        EQU  DWORD PTR[ebp+20]
XRes        EQU  DWORD PTR[ebp+24]
pYNewHeight EQU  DWORD PTR[ebp+28]
YVU9Flag    EQU  DWORD PTR[ebp+32]
pYPlaneOut  EQU  DWORD PTR[ebp+36]
pVPlaneOut  EQU  DWORD PTR[ebp+40]
YPitchOut   EQU  DWORD PTR[ebp+44]
ShapingFlag EQU  DWORD PTR[ebp+48]

;; stack usage
; previous ebp at ebp 
; previous edi at ebp - 4
; previous esi at ebp - 8
; lXRes        at ebp -12
; lYRes        at ebp -16
; lYPitchOut   at ebp -20
; YDiff        at ebp -24
; outloopcnt   at ebp -28
; uvWidth      at ebp -32
; inloopcnt    at ebp -36
; luvcounter   at ebp -40
; uvoutloopcnt at ebp -44
; VDiff        at ebp -48
; VInDiff	   at ebp -52

lXRes        EQU  DWORD PTR[ebp-12]
lYRes        EQU  DWORD PTR[ebp-16]
lYPitchOut   EQU  DWORD PTR[ebp-20]
YDiff        EQU  DWORD PTR[ebp-24]
outloopcnt   EQU  DWORD PTR[ebp-28]
uvWidth      EQU  DWORD PTR[ebp-32]
inloopcnt    EQU  DWORD PTR[ebp-36]
luvcounter   EQU  DWORD PTR[ebp-40]
uvoutloopcnt EQU  DWORD PTR[ebp-44]
VDiff        EQU  DWORD PTR[ebp-48]
VInDiff      EQU  DWORD PTR[ebp-52]

  xor   ax,ax           ; These two instructions give definitive proof we are
  mov   eax,0CCCCCCCCH  ; in a 32-bit code segment.  INT 3 occurs if not.

;get params
	push    ebp

ifdef WIN32
	mov     ebp, esp
else
	movzx  	ebp, sp	        ;ebp now pointing to last pushed reg
endif
	  push    edi
	push    esi

; zero out registers
	xor 	edx, edx

	xor	esi, esi
	xor	edi, edi

; move stack variables to local space
	mov	eax, XRes
	push	eax		; store lXRes on stack

	mov	ebx, YRes
	push	ebx		; store lYRes on stack

	mov	ecx, YPitchOut
	push	ecx		; store lYpitchOut on stack
	sub	ecx, eax	; YDiff = YPitchOut - XRes
	push	ecx		; store YDiff on stack

; push stack with 0 6 additional times to make room for other locals
	push	edx		; outloopcnt
	push	edx		; uvWidth
	push	edx		; inloopcnt
	push	edx		; luvcounter
	push	edx		; uvoutloopcnt
	push	edx		; VDiff
	push    edx     ; VInDiff

; test if YUV9 mode
	mov     edx, YVU9Flag
	test    edx,edx
	jz      YVU12;      ; If the flag is false it must be YVU12

;**********************************************************************
;**********************************************************************
; know input was YVU9, Y Plane was processed in cc12to7.asm

	mov esi, pYNewHeight
	mov	WORD PTR [esi], bx	; store YRes into address pYNewHeight

; ********************
; Copy V and U Plane from source to destination converting to 7 bit
; ********************
; Description of V & U Plane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes/4 lines 
;       Collp1 loops for number of columns
;         - Read 1 U
;	  - Read 1 V
;         - Convert each value from 8-bit to 7-bit
;         - Store 1 U
;         - Store 1 V
;
; Register usage
;   eax	U plane input address
;   ebx	source value and index into gTAB_UVtbl8to7
;   ecx	source value and index into gTAB_UVtbl8to7
;   edx	inner most loop counter 
;   esi	V plane src address
;   edi	des address
;   ebp	stack pointer stuff
;
; if (16-bit)
;   es	input plane segment
;   fs	output plane segment
;   ds	table segment
; endif
;
; local variables
;  outloopcnt
;  lXRes
;  lYRes
;  uvWidth
;  VDiff
;
; know input was YVU9
	mov	ecx, lYRes
	  mov	ebx, lXRes
	shr	ebx, 2			; uvWidth=XRes/4
	  mov	eax, VPITCH		; get Fixed offset
	shr	ecx, 2			; outloopcnt=YRes/4
	  mov	uvWidth,ebx		; uvWidth=XRes/4
	sub	eax, ebx		; VPITCH - uvWidth

	mov	esi,  pVPlaneIn		; Initialize input cursor
	mov	edi,  pVPlaneOut	; Initialize output cursor
	  mov	VDiff, eax		; store V difference
	mov	eax,  pUPlaneIn		; Initialize input cursor
	
Row9lp2:
	mov	outloopcnt,ecx		; store updated outer loop count
	  mov	edx, uvWidth		; init dx
	xor	ebx, ebx
	  xor	ecx, ecx

Col9lpv1:
  	mov  	cl, BYTE PTR [eax]	      ; Fetch *PUtemp_IN
	  inc	edi			              ; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	      ; Fetch *pVtemp_IN
	  inc	eax			              ; pUtemp+=1
	mov	    cl, gTAB_UVtbl8to7[ecx]	  ; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  inc	esi			              ; Inc source by 1,pVtemp+=1
	mov  	BYTE PTR [edi+167],cl     ; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	  ; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	      ; store in PVtemp_OUT
	  xor	ecx, ecx	              ; dummy op
	dec	edx
	  jg  	Col9lpv1

;; increment to beginning of next line
	mov	edx, VDiff

	mov	ecx, outloopcnt		; get outer loop count
	  add	edi,edx			; Point to next output row
	dec	ecx
	  jnz	Row9lp2			; if more to do loop

	jmp	Cleanup

;*****************************************************************
;*****************************************************************
; know input was YVU12
;
;    if (!ShapingFlag) {
;        goto YVU12_NO_SHAPING;
;    } else {
;        switch (YRes) {  // YRes = YRes * 11 / 12;
;        case  96: *pyNewHeight =  88; break;
;        case 144: *pyNewHeight = 132; break;
;        case 288: *pyNewHeight = 264; break;
;        default: error;
;        }
;    }
;
YVU12:
	mov  eax, ShapingFlag
	test eax, eax
	jz   YVU12_NO_SHAPING
	
	cmp lYRes, 96       ; If 96
	je  YRes96
	cmp	lYRes, 144		; If 144 
	je	YRes144
	cmp	lYRes, 288		; If 288
	je	YRes288
	jmp	Error
;
YRes96:
	mov	ax, 88          ; pyNewHeight = ax = 132
	mov	ecx, 7			; for YRes lines loopcounter=11
	mov	uvoutloopcnt, 1	; process 1 full set of 13&11 lines
	jmp	Rejoin2

YRes144:
	mov	ax, 132			; pyNewHeight = ax = 132
	mov	ecx, 11			; for YRes lines loopcounter=11
	mov	uvoutloopcnt, 2	; process 2 full sets of 13&11 lines
	jmp	Rejoin2

YRes288:
	mov	ax, 264			; pyNewHeight = ax = 264
	mov	ecx, 23			; for YRes lines loopcounter=23
	mov	uvoutloopcnt, 5	; process 5 full sets of 13&11 lines

Rejoin2:
	mov	esi, pYNewHeight
	mov	[esi], ax	    ; store adjusted height into 
					            ; address pYNewHeight
; ********************
; Copy Y Plane from soure to dest skipping every 12th line 
; ********************
; Description of YPlane processing:
;
; Triple nested loop with 
; Outlp1 executed 11 or 23 times based on 144 or 288 lines respectively
;   Rowlp1 is executed 11 times 
;     Collp1 loops for number of columns
;
; Register usage
;  eax	rows loop count
;  ebx	input and output
;  ecx	outer loop count
;  edx	column loop counter 
;  esi	src address
;  edi	des address
;  ebp	stack pointer stuff
;
;  es	input plane segment
;  fs	output plane segment
;  ds	table segment
;
; local variables
;  lXRes
;  YDiff
;  lYPitchOut
;
	mov esi,  pYPlaneIn		; Initialize input cursor
	mov	edi,  pYPlaneOut		; Initialize output cursor

; No need to re-copy first 11 lines
	mov	eax, lYPitchOut
	  mov	edx, YDiff
	add	edi, eax		; des + 1*lYPitchOut
	shl	eax, 1			; lYPitchOut*2
;;;	add	esi, edx		; Adjust for difference in YPitchOut
					;   and XRes
	  add	edi, eax		; des + 3*lYpitchOut
	shl	eax, 1			; lYPirchOut*4
;;;	add	edi, edx		; Adjust for difference in YPitchOut
					;   and XRes
	  add	esi, eax		; source + 4*lYpitchOut
	shl	eax, 1			; lYPitchOut*8
	add	esi, eax		; source +12*lYpitchOut
	  add	edi, eax		; des + 11*lYPitchOut

Outlp1:
	mov	eax, 11 		; Initialize rows loop cnter
	  mov	edx, lXRes		; edx = number of columns

Rowlp1:
Collp1:
  	mov  	ebx, [esi+edx-4]	; Fetch source, 4 at a time
	  sub  	edx,4			; decrement loop counter
	mov  	[edi+edx],ebx	; Store 4 converted values
	  jnz  	Collp1			; if not done loop

	mov	edx, lYPitchOut
	  mov	ebx, YDiff
	add	edi, edx		; Increment to where just processed
	  add	esi, edx
;;;	add	edi, ebx		; Adjust for difference in YPitchOut
;;;	  add	esi, ebx		;  and XRes
	dec	eax			; decrement rows loop counter
	  jg	Rowlp1

	mov	eax,lYPitchOut		; Skip 12th line
	add	esi,eax			; Point to next input row

	dec	ecx			; decrement outer loop counter
	  jg	Outlp1			; if more to do loop

; ************************************************************
; Copy V and U Plane from source to destination converting to 7 bit
;   skipping every other line and sometimes two moving only ever other 
;   pixel in a row.
; ********************
;
; Description of V & U Plane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes/4 lines 
;       Collp1 loops for number of columns
;         - Read 1 U
;	  - Read 1 V
;         - Convert each value from 8-bit to 7-bit
;         - Store 1 U
;         - Store 1 V
;
; Register usage
;   eax	U plane input address
;   ebx	source value and index into gTAB_UVtbl8to7
;   ecx	source value and index into gTAB_UVtbl8to7
;   edx	counter
;   esi	V plane src address
;   edi	des address, V Plane and U Plane
;   ebp	stack pointer stuff
;
;   es	input plane segment
;   fs	output plane segment
;   ds	table segment
;
; local variables
;  luvcounter
;  uvoutloopcnt
;  inloopcnt
;  lXRes
;  uvWidth
;  VDiff
;
	mov	ebx, lXRes
	  mov	eax, VPITCH		; get Fixed offset
	shr	ebx, 1			; uvWidth=XRes/2
	mov	uvWidth, ebx		; uvWidth=XRes/2
	shr	ebx, 1
	sub	eax, ebx		; VPITCH - uvWidth
	mov	VDiff, eax		; store V difference
	  mov	luvcounter, ebx		; luvcounter = XRes/4

	mov     ecx, YPITCH		; Distance to the next V
	  add   ecx, ecx
	sub     ecx, uvWidth           
	  mov   VInDiff, ecx    ;	 = YPITCH + YPITCH - uvWidth 

	mov	esi,  pVPlaneIn		; Initialize input cursor
	mov	edi,  pVPlaneOut		; Initialize output cursor
	mov	eax,  pUPlaneIn		; Initialize input cursor

; Process 6 first lines special
	mov	ebx, 3			; initialize inner loop count 
	
Rowlp2_6:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1

; increment to beginning of next line then skip next input line
	add	    edi,VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 6 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_6		; if more to do loop

; Skipping extra line
	mov	edx,YPITCH		; Need same sized for add
	  mov	ecx, uvoutloopcnt
	add	esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

; Process groups of 13 and 11 lines
Outlp2:

;   Process 13 lines
	mov	ebx, 6			; initialize inner loop count 
	  mov	uvoutloopcnt, ecx

Rowlp2_13:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_13:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_13

; increment to beginning of next line then skip next input line
	add	    edi,VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 13 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_13		; if more to do loop

; Skipping extra line
	mov	    edx,YPITCH 		; Need same sized for add
	  mov	ebx, 5			; initialize inner loop count 
	add	    esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

;   Process 11 lines
Rowlp2_11:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_11:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_11

; increment to beginning of next line, then skip next input line
	add	    edi, VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 11 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_11		; if more to do loop

; Skipping extra line
	mov	    edx,YPITCH		; Need same sized for add
	  mov	ecx, uvoutloopcnt
	add	    esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

	dec	ecx
	  jnz	Outlp2			; if more to do loop

;
; Process last set of 13
;
	mov	ebx, 6			; initialize inner loop count 

Rowlp2_13l:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_13l:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_13l

; increment to beginning of next line then skip next input line
	add	    edi,VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 13 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_13l		; if more to do loop

; Skipping extra line
	mov	    edx,YPITCH		; Need same sized for add
	  mov	ebx, 2			; initialize inner loop count 
	add	    esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

; Process final 4 lines
Rowlp2_f:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_f:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_f

; increment to beginning of next line then skip next input line
	add	    edi, VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed last lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_f		; if more to do loop

	jmp	Cleanup

; ************************************************************
; Copy V and U Plane from source to destination converting to 7 bit
;   skipping every other line moving only ever other pixel in a row.
; ********************
;
; Description of V & U Plane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes/4 lines 
;       Collp1 loops for number of columns
;         - Read 1 U
;	  - Read 1 V
;         - Convert each value from 8-bit to 7-bit
;         - Store 1 U
;         - Store 1 V
;
; Register usage
;   eax	U plane input address
;   ebx	source value and index into gTAB_UVtbl8to7
;   ecx	source value and index into gTAB_UVtbl8to7
;   edx	counter
;   esi	V plane src address
;   edi	des address, V Plane and U Plane
;   ebp	stack pointer stuff
;
;   es	input plane segment
;   fs	output plane segment
;   ds	table segment
;
; local variables
;  luvcounter
;  inloopcnt
;  lYRes
;  lXRes
;  uvWidth
;  VDiff
;  VInDiff
;
YVU12_NO_SHAPING:   
	cmp lYRes, 98
	je  YRes98_NS
	cmp	lYRes, 144		 
	je	YRes144_NS
	cmp	lYRes, 288		
	je	YRes288_NS
	jmp	Error
;
YRes98_NS:    ;  98 No Shaping           
YRes144_NS:	  ; 144 No Shaping
YRes288_NS:   ; 288 No Shaping
	mov	eax, lYRes		; pyNewHeight = ax = YRes
	mov	esi, pYNewHeight
	mov	[esi], ax	; store adjusted height into 

	shr	eax, 2			; inloopcnt=YRes/2
	 mov	ebx, lXRes
	shr	ebx, 1			; uvWidth=XRes/2
	  mov	inloopcnt, eax		; initialize inner loop count 
	mov	uvWidth, ebx		; uvWidth=XRes/2
	  mov	ecx, VPITCH		; get output plane V pitch
	shr	ebx, 1
	  sub	ecx, ebx		; VPITCH - uvWidth/2
	mov	luvcounter, ebx		; luvcounter = XRes/4
	  mov	VDiff, ecx		; Store VDiff

	mov     ecx, YPITCH		; Distance to the next V
	  add   ecx, ecx
	sub     ecx, uvWidth           
	  mov   VInDiff, ecx    ;	 = YPITCH + YPITCH - uvWidth 

	mov	esi,  pVPlaneIn		; Initialize input cursor
	mov	edi,  pVPlaneOut		; Initialize output cursor
	mov	eax,  pUPlaneIn		; Initialize input cursor
	  mov	ecx, inloopcnt

; Process all lines skipping just every other

Rowlp2_NS:
	mov	inloopcnt, ecx		; store update inloopcnt
	  xor	ebx, ebx
	mov	edx, luvcounter		; init dx
	  xor	ecx, ecx

Collpv1_NS:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_NS

; increment to beginning of next line then skip next input line
	add	edi, VDiff		; Point to next output row
	  mov	edx,VInDiff	; Skip to next input row
	add	esi,edx			; 
	  add	eax,edx			; 
	mov	ecx, inloopcnt		; get inloopcnt

; test if have processed all lines yet
	dec	ecx			; Process next line
	  jne	Rowlp2_NS		; if more to do loop

Error:
Cleanup:
; clean out local variables on stack
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop ecx

;clear special seg registers, restore stack, pop saved registers
ifndef WIN32
	xor     ecx, ecx
	xor     ebx, ebx
	mov     es, cx
	mov     fs, bx
endif
	  pop     esi
	pop     edi
	  pop     ebp

ifdef WIN32
	ret
else
	db      066h
	retf
endif

_AspectCorrect endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3dctc.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3dctc.inv   1.2   27 Dec 1995 15:32:58   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCDCTC_INC_
ELSE
_ENCDCTC_INC = 1

;
; Field offsets for DCT coefficients for the H26x encoder.
;

T_CoeffBlk STRUCT
  UNION
    C50C52      DWORD ?   ;    0
    BlockAddr   DWORD ?   ;    0
  ENDS
  UNION
    C00C02        DWORD ?  ;   4
    LinesDefined  BYTE  ?  ;   4
  ENDS
  UNION
    C10C12        DWORD ?  ;   8
    Cols03Defined DWORD ?  ;   8
  ENDS
  UNION
    C30C32        DWORD ?  ;  12
    Cols47Defined DWORD ?  ;  12
  ENDS
  C20C22      DWORD ?   ;   16
  C40C42      DWORD ?   ;   20
  C60C62      DWORD ?   ;   24
  C70C72      DWORD ?   ;   28
  C51C53      DWORD ?   ;   32
  C01C03      DWORD ?   ;   36
  C31C33      DWORD ?   ;   40
  C11C13      DWORD ?   ;   44
  C21C23      DWORD ?   ;   48
  C41C43      DWORD ?   ;   52
  C61C63      DWORD ?   ;   56
  C71C73      DWORD ?   ;   60
  C54C56      DWORD ?   ;   64
  C04C06      DWORD ?   ;   68
  C14C16      DWORD ?   ;   72
  C34C36      DWORD ?   ;   76
  C24C26      DWORD ?   ;   80
  C44C46      DWORD ?   ;   84
  C64C66      DWORD ?   ;   88
  C74C76      DWORD ?   ;   92
  C57C55      DWORD ?   ;   96
  C07C05      DWORD ?   ;  100
  C17C15      DWORD ?   ;  104
  C37C35      DWORD ?   ;  108
  C27C25      DWORD ?   ;  112
  C47C45      DWORD ?   ;  116
  C67C65      DWORD ?   ;  120
  C77C75      DWORD ?   ;  124
T_CoeffBlk ENDS


ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3inst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\e3inst.inv   1.6   27 Dec 1995 15:33:00   RMCKENZX  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENCINST_INC_
ELSE
_ENCINST_INC = 1

;
; Global definitions for the H26x encoder.
;
;

PITCH = 384     ; Pitch for each plane
VOFFSET = 192   ; Dist from U to corresponding V

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3mbad.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3mbad.inv   1.10   04 Oct 1996 08:47:58   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\e3mbad.inv  $
;// 
;//    Rev 1.10   04 Oct 1996 08:47:58   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.9   14 May 1996 12:18:46   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.8   02 May 1996 13:41:08   BNICKERS
;// started integration of MMX PB-frames
;// 
;//    Rev 1.7   22 Feb 1996 15:02:38   BNICKERS
;// Add unionized field for MMx implementation.
;// 
;//    Rev 1.6   22 Jan 1996 17:13:44   BNICKERS
;// Add MBEdgeType to MacroBlock Action Descriptor.
;// 
;//    Rev 1.5   27 Dec 1995 15:33:00   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _ENDMBAD_INC_
ELSE
_ENDMBAD_INC = 1

;
; Fields for MacroBlock Action Stream Descriptors for the H26x encoder.
;


T_Blk STRUCT
  BlkOffset         DWORD ? ;  0  -- Offset from upper left viewable pel of Y
                            ;        plane to upper left pel of block.
  UNION
    PastRef         DWORD ? ;  4  -- Addr of 8*8 reference block, passed from
                            ;        P-Frame ME to P-Frame frame differencing.
    STRUCT
      CandidateHMVf BYTE ?  ;  4  -- Scratch area for figuring BestHMVf values.
      CandidateVMVf BYTE ?  ;  5  -- Must be 4 bytes after Best...
      CandidateHMVb BYTE ?  ;  6
      CandidateVMVb BYTE ?  ;  7
    ENDS
    CandidateBiDiMVs DWORD ? ; 4
  ENDS
  UNION
    STRUCT
      BestHMVf      BYTE ?  ;  8  -- "Real" MVs for B-Frame block, passed from
      BestVMVf      BYTE ?  ;  9  -- B-Frame ME to P-Frame frame differencing.
      BestHMVb      BYTE ?  ; 10  -- (Biased by 060H)
      BestVMVb      BYTE ?  ; 11
    ENDS
    BestBiDiMVs     DWORD ? ;  8
  ENDS
  UNION
    STRUCT
      PHMV        BYTE  ?   ; 12  -- Horz motion vector for P frame ref blk.
      PVMV        BYTE  ?   ; 13  -- Vert motion vector for P frame ref blk.
      BHMV        BYTE  ?   ; 14  -- Horz motion vector adjustment for B frm.
      BVMV        BYTE  ?   ; 15  -- Vert motion vector adjustment for B frame.
    ENDS
    MVs           DWORD ?   ; 12
  ENDS
T_Blk ENDS

; Symbolic offsets for MMx version:

T_MacroBlockActionDescr STRUCT 
  BlockType     BYTE  ? ;  0  -- See Block Types below.
  MBEdgeType    BYTE  ? ;  1  -- 1 left | 2 right | 4 top | 8 bottom
  Unassigned1   BYTE  ?
  FirstMEState  BYTE  ? ;  3  -- First State Num for Motion Estimation engine.
  UNION
    STRUCT
      CodedBlocks   BYTE  ? ;  4  -- [6] End-Of-Stream indicator
                            ;        [0] indicates Y1 non-empty.
                            ;        [1..5] indicate Y2, Y3, Y4, U, V non-empty.
                            ;        Other bits zero.
      CodedBlocksB  BYTE  ? ;  5  -- [0..5] like CodedBlocks, but for B frame.
                            ;        Set 0 for non-bi-di prediction.
      BestFullPelMBHMV BYTE ? ; 6 -- Best full pel HMV at macroblock level.
      BestFullPelMBVMV BYTE ? ; 7 -- Best full pel VMV at macroblock level.
    ENDS
    BestFullPelMBMVs DWORD ? ; 4
  ENDS
  SWD           DWORD ? ;  8  -- Sum of weighted diffs, from motion estimation.
  SWDB          DWORD ? ; 12  -- Sum of weighted diffs, from ME for B frame.
  BlkY1         T_Blk { }
  Blk           EQU       BlkY1
  BlkY2         T_Blk { }
  BlkY3         T_Blk { }
  BlkY4         T_Blk { }
  BlkU          T_Blk { }
  BlkV          T_Blk { }
  Unassigned4	BYTE  16 DUP (?) ; pad out 16 bytes to 128 bytes total to match C struct
T_MacroBlockActionDescr ENDS
T_MBAD TEXTEQU <T_MacroBlockActionDescr>

IF SIZEOF T_MacroBlockActionDescr-128
**** Size of T_MacroBlockActionDescr MUST BE a power of 2 bytes long.
ENDIF

IF 3*SIZEOF T_MBAD-PITCH
  **** Next instr works if PITCH==384 and SizeOf T_MacroBlockActionDescr==128.
  **** Here and throughout this file.
ELSE
BlkLvlSWD       TEXTEQU <BestBiDiMVs>
CandBlkLvlSWD   TEXTEQU <[CONST_384*1-128+CandidateBiDiMVs]>
BestBlkLvlSWD   TEXTEQU <[CONST_384*1-128+BestBiDiMVs]>
BlkLvlSWD0Delta TEXTEQU <[CONST_384*1-128+MVs]>
CandBiDiMVs     TEXTEQU <[CONST_384*1+CandidateBiDiMVs]>
CandHMVf        TEXTEQU <[CONST_384*1+CandidateHMVf]>
CandVMVf        TEXTEQU <[CONST_384*1+CandidateVMVf]>
CandHMVb        TEXTEQU <[CONST_384*1+CandidateHMVb]>
CandVMVb        TEXTEQU <[CONST_384*1+CandidateVMVb]>
BiDiMVs0Delta   TEXTEQU <[CONST_384*1+BestBiDiMVs]>
HMVf0Delta      TEXTEQU <[CONST_384*1+BestHMVf]>
VMVf0Delta      TEXTEQU <[CONST_384*1+BestVMVf]>
HMVb0Delta      TEXTEQU <[CONST_384*1+BestHMVb]>
VMVb0Delta      TEXTEQU <[CONST_384*1+BestVMVb]>
ENDIF

; Memory layout constraints:
;
; T_MacroBlockActionDescr structure must be 16-byte aligned.
; Each T_Blk structure must be 16-byte aligned.
; FirstMEState must be 3rd byte of a DWORD.
; CodedBlocks must be DWORD aligned.
; CodedBlocksB must be CodedBlocks plus one.
; CodedBlocks & CodedBlocksB should be in different memory bank than BlockType.
; Offset must be 16-byte aligned.
; PastRef must be at Targ plus four.
; Candidate MVs must be at DWORD before Best MVs.  MVs must be in order given.
;

; Block Types
;
;  Only INTER, INTRA, and INTERSLF used for H261.
;  Only INTER1MV, INTRA, INTER4MV used presently for H263.

INTER1MV  = 0
INTER     = INTER1MV
INTRA     = 1
INTERBIDI = 2
INTRABIDI = 3
INTER4MV  = 4
INTERSLF  = 2

IsINTRA   = 1  ; Mask to check for INTRA or INTER
IsBIDI    = 2  ; Mask to check for BIDI or not
Is4MV     = 4  ; Mask to check for 4 motion vectors or just 1.

LeftEdge   = 1 ; Mask to indicate MB is at left edge of picture.
RightEdge  = 2 ; Mask to indicate MB is at right edge of picture.
TopEdge    = 4 ; Mask to indicate MB is at top edge of picture.
BottomEdge = 8 ; Mask to indicate MB is at bottom edge of picture.
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e35vlc.asm ===
; ++ ========================================================================
;
;              INTEL CORPORATION PROPRIETARY INFORMATION
;
;       This software is supplied under the terms of a license
;       agreement or nondisclosure agreement with Intel Corporation
;       and may not be copied or disclosed except in accordance
;       with the terms of that agreement.
;
;       Copyright (c) 1995 Intel Corporation.  All Rights Reserved.
;
;    ========================================================================
;
;       Declaration:
;               void MBEncodeVLC (
;                       char *                  pMBRVS_Luma,
;                       char *                  pMBRVS_Chroma,
;                       unsigned int            CodedBlkPattern,
;                       unsigned char **        pBitStream,
;                       unsigned char *         pBitOffset,
;                       int                     IntraFlag,
;                       int                     MMxFlag
;               );
;
;       Description:
;               This function encodes a macroblock's worth of RLE values.
;               The RLE values are provided to me in a list of triplets
;               where the triplets consist of RUN, LEVEL, and SIGN, where
;               each element is a BYTE.
;
;       Register Usage:
;               ESI -- RLE stream cursor
;               EDI -- Bit stream cursor
;               EDX -- Bit stream offset
;
; $Header:   S:\h26x\src\enc\e35vlc.asv   1.6   11 Oct 1996 16:44:22   BECHOLS  $
;
; $Log:   S:\h26x\src\enc\e35vlc.asv  $
;// 
;//    Rev 1.6   11 Oct 1996 16:44:22   BECHOLS
;// Added a check, so that I won't choke on a zero level, even though
;// by rights the level should never be zero.
;// 
;//    Rev 1.5   05 Sep 1996 18:37:46   KLILLEVO
;// fixed bug which occured when value is zero after quantization
;// and run-length encoding
;// 
;//    Rev 1.4   15 Mar 1996 15:56:48   BECHOLS
;// 
;// Changed to support separate passes over the luma and chroma.
;// 
;//    Rev 1.3   03 Oct 1995 20:40:40   BECHOLS
;// 
;// Modified the code to reduce the code size to about .5K of cache and 
;// about 4K of data.  Added cache preloading, and write the VLC and sign
;// in one operation.  I believe I handle the clamping correctly.
;// 
;//    Rev 1.2   22 Sep 1995 18:31:04   BECHOLS
;// Added clamping for the positive values as well as the negative.
;// 
;//    Rev 1.1   14 Sep 1995 11:45:36   BECHOLS
;// I used WDIS.EXE to determine where I could get better performance.
;// The changes I made have improved the performance by 30%.
;
; -- ========================================================================
.486
.MODEL flat, c

; ++ ========================================================================
; Name mangling in C++ forces me to declare these tables in the ASM file
; and make them externally available to C++ as extern "C" ...
; -- ========================================================================
PUBLIC FLC_INTRADC
PUBLIC VLC_TCOEF_TBL
PUBLIC VLC_TCOEF_LAST_TBL

; ++ ========================================================================
; These constants were variable in the C version, but will actually never
; change being set by the H263 specification.
; -- ========================================================================
TCOEF_ESCAPE_FIELDLEN   EQU     7
TCOEF_ESCAPE_FIELDVAL   EQU     3
TCOEF_RUN_FIELDLEN      EQU     6
TCOEF_LEVEL_FIELDLEN    EQU     8

; ++ ========================================================================
; RLS (Run Level Sign) Structure is defined just to make the code a little
; more readable.
; -- ========================================================================
RLS     STRUCT
        Run     BYTE    ?
        Level   BYTE    ?
        Sign    BYTE    ?
RLS     ENDS

; ++ ========================================================================
; The PutBits macro puts a Variable Length Code into the bit stream.  It
; expects registers to contain the correct information as follows.
;       EDX -- Field Length
;       EAX -- Field Value
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutBits MACRO
        push    esi
        push    ecx
        xor     ecx, ecx
        mov     cl,  BYTE PTR [ebx]     ;; Get the Bit Offset.
        add     edx, ecx                ;;  Add it to the field length.
        mov     ecx, 32                 ;; EAX <<= (32 - (EDX + [EBX]))
        sub     ecx, edx                ;;  EDX = Field Length + Bit Offset.
        mov     esi, DWORD PTR [edi]    ;; Set ESI to Bit Stream.
        shl     eax, cl                 ;;
        bswap   eax                     ;; Swaps byte order in EAX.
        mov     ecx, DWORD PTR [esi]    ;; Preload cache.
        or      DWORD PTR [esi], eax    ;; Write value to bit stream.
        mov     eax, edx
        shr     eax, 3
        add     [edi], eax              ;; Update Bit Stream Pointer.
        and     edx, 000000007h
        mov     BYTE PTR [ebx], dl      ;; Update Bit Stream Offset.
        pop     ecx
        pop     esi
ENDM

; ++ ========================================================================
; PutRunLev macro writes the ESCAPE code and Last bit, then the RUN length,
; and then the LEVEL into the stream.  It assumes the following registers.
;       ECX -- Last Bit
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutRunLev MACRO
        LOCAL   NoClamp, NotNegative, NotZero
        mov     eax, TCOEF_ESCAPE_FIELDVAL
        mov     edx, TCOEF_ESCAPE_FIELDLEN
        PutBits                         ;; Write ESCAPE.
        mov     eax, ecx                ;; Retrieve Last Bit.
        mov     edx, 1
        PutBits
        mov     al, (RLS PTR [esi]).Run ;; Retrieve Run Length.
        mov     edx, TCOEF_RUN_FIELDLEN
        PutBits                         ;; Write RUN length.
        mov     al, (RLS PTR [esi]).Level ;; Retrieve Level.
        sub     eax, 1  ; in case it is zero we want it to be modified to 127
NotZero:
        cmp     eax, 127
        jb      NoClamp
        mov     eax, 126
NoClamp:
        add     eax, 1
        cmp     (RLS PTR [esi]).Sign, 0FFh
        jne     NotNegative
        mov     ecx, eax
        xor     eax, eax
        sub     eax, ecx
        and     eax, 0000000FFh         
NotNegative:
        mov     edx, TCOEF_LEVEL_FIELDLEN
        PutBits                         ;; Write LEVEL.
ENDM

; ++ ========================================================================
; PutVLC macro writes the Variable Length Code and its sign bit into the
; bit stream.  It expects the registers to be set up as follows.
;       EDX -- VLC Code Length
;       EAX -- VLC Bit Code
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX and EAX are trashed.
; -- ========================================================================
PutVLC MACRO
        mov     cl, (RLS PTR [esi]).Sign ;; Get sign bit which is [ 0 | -1 ]
        and     ecx, 000000001h         ;;  Mask off all but the low bit
        or      eax, ecx                ;;  and place it in VLC.
        PutBits                         ;; Write the signed VLC into stream.
ENDM

; ++ ========================================================================
; CheckLast macro determines whether this is last RLE code for the block.
; It assumes the following register.
;       ESI -- Pointer to RLE stream.
; It sets the following registers for subsequent use.
;       EAX -- Last bit.
;       ECX -- Max Table Level.
;       EDX -- Pointer to the appropriate VLC table.
; -- ========================================================================
CheckLast MACRO
        LOCAL   IsLast, CheckDone
        cmp     (RLS PTR [esi + 3]).Run, 0FFh ;; Check if the last RLE.
        je      IsLast
        xor     eax, eax                ;; If not then clear last bit,
        lea     edx, VLC_TCOEF_TBL      ;;  and point to proper table,
        mov     ecx, 12                 ;;  and set max table level.
        jmp     CheckDone
IsLast:
        mov     eax, 1                  ;; Otherwise set the last bit,
        lea     edx, VLC_TCOEF_LAST_TBL ;;  and point to last coef table,
        mov     ecx, 3                  ;;  and set the max table level.
CheckDone:
ENDM

; ++ ========================================================================
; IndexTable macro determines the pointer value as indexed into the table
; of coefficients.  It assumes the following registers.
;       ESI -- Pointer to RLE stream.
;       EAX -- The level which is one (1) based.
;       EDX -- The base pointer to the coefficient array.
; The EDX register is modified, EAX is trashed, and ECX is preserved
; -- ========================================================================
IndexTable MACRO
        push    ecx                     ;; Save the last bit
        dec     eax                     ;; Zero base the level value.
        shl     eax, 6                  ;; EAX is # of run values per level
        mov     ecx, eax                ;;  added to the run value.
        xor     eax, eax                ;;
        mov     al, (RLS PTR [esi]).Run ;;
        add     eax, ecx                ;;
        shl     eax, 2                  ;; The array has DWORDs (4 bytes)
        add     edx, eax                ;; Add the index to the array.
        pop     ecx                     ;; Restore the last bit.
ENDM

; ++ ========================================================================
; WriteOneCode macro takes one RLE code from the triplet list and VLC
; encodes it, and writes it to the bit stream.  It expects that the
; following registers will be set as shown.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified and EDX , ECX, and EAX
; are trashed.
; -- ========================================================================
WriteOneCode MACRO
        LOCAL   RunLevel, VLCDone, NotZero
        CheckLast
        push    eax                     ;; Save last bit
        mov     al, (RLS PTR [esi]).Level ;; Get the level value and check
        test    al, al                  ;; The level should never be zero
        jnz     NotZero                 ;;  but this fixes the unlikely
        mov     al, 127                 ;;  event.
NotZero:
        cmp     eax, ecx                ;;  it against the max table level.
        pop     ecx                     ;; Restore the last bit.
        jg      RunLevel                ;; 
        IndexTable                      ;; Sets EDX to table index
        mov     eax, DWORD PTR [edx]    ;; Get the VLC code from table.
        cmp     eax, 00000FFFFh         ;; Is this an escape indicator?
        je      RunLevel                ;; If so then do RLE processing.
        mov     edx, eax
        and     eax, 00000FFFFh
        shr     edx, 16
        PutVLC                          ;; Write the Variable code.
        jmp     VLCDone
RunLevel:
        PutRunLev                       ;; Write the ESC RUN LEV stuff.
VLCDone:
ENDM

; ++ ========================================================================
; WriteIntraDC macro writes the Intra DC value into the bit stream.  It
; expects the following registers to be set correctly.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
; The contents of EDI and EBX are modified, ESI is updated, and EDX and
; EAX are preserved.
; -- ========================================================================
WriteIntraDC MACRO
        push    eax
        push    edx
        lea     edx, FLC_INTRADC        ;; Form index into Intra DC
        mov     al, (RLS PTR [esi]).Level ;;  array.
        add     edx, eax                ;;
        mov     al, BYTE PTR [edx]      ;; Get Intra DC value.
        mov     edx, 8                  ;; Set size of write to 8 bits.
        PutBits                         ;; Write the Intra DC value.
        add     esi, SIZEOF RLS         ;; Point to next triplet.
        pop     edx
        pop     eax
ENDM

; ++ ========================================================================
; WriteOneBlock macro writes all the coefficients for a single block of the
; macroblock.  It assumes that the registers will be set as follows.
;       ESI -- Pointer to RLE stream.
;       EDI -- Pointer to the Bitstream Pointer
;       EBX -- Pointer to the Bitstream Offset
;       EDX -- Coded Block Pattern (CBP)
;       ECX -- Intra/Inter Flag
;       EAX -- CBP Mask.
; The contents of EDI and EBX are modified and EDX , ECX, and EAX are
; preserved.
; -- ========================================================================
WriteOneBlock MACRO
        LOCAL   NotIntra, WriteDone, WriteCodes, WriteExit
        push    eax
        push    edx
        cmp     ecx, 1                  ;; Check to see if this is an 
        jne     NotIntra                ;;  Intra block, and if so,
        WriteIntraDC                    ;;  write the DC value.
NotIntra:
        and     eax, edx                ;; Check CBP to see if done.
        jz      WriteExit
WriteCodes:
        mov     al, BYTE PTR [esi]      ;; Get the RUN value.
        cmp     eax, 0000000FFh         ;; Check to see if done.
        je      WriteDone
        WriteOneCode                    ;; Continue to write the codes
        add     esi, SIZEOF RLS         ;;  in this block until done.
        jmp     WriteCodes              ;;
WriteDone:
        add     esi, SIZEOF RLS         ;; Bump to next block.
WriteExit:
        pop     edx
        pop     eax
ENDM

.DATA

FLC_INTRADC             DB      256 DUP (?)
VLC_TCOEF_TBL           DD      (64*12) DUP (?)
VLC_TCOEF_LAST_TBL      DD      (64*3) DUP (?)

.CODE

; ++ ========================================================================
; This is the C function call entry point.  This function variable length
; encodes an entire macroblock, one block at a time.
; -- ========================================================================
MBEncodeVLC     PROC PUBLIC USES edi esi ebx ecx, pMBRVS_Luma:DWORD, pMBRVS_Chroma:DWORD, CodedBlockPattern:DWORD, ppBitStream:DWORD, pBitOffset:DWORD, IntraFlag:DWORD, MMxFlag:DWORD

        mov     esi, pMBRVS_Luma
        mov     edi, ppBitStream
        mov     ebx, pBitOffset
        mov     edx, CodedBlockPattern
        mov     esi, [esi]
        mov     eax, 1                  ; CBP Mask.
LumaWriteLoop:
        test    eax, 000000010h         ; When EAX bit shifts to this
        jnz     LumaBlocksDone          ;  position, we are done with Luma.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     LumaWriteLoop
LumaBlocksDone:
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      ChromaWriteLoop
        mov     ecx, pMBRVS_Luma
        mov     [ecx],esi
        mov     ecx, pMBRVS_Chroma
        mov     esi,[ecx]
ChromaWriteLoop:
        test    eax, 000000040h         ; When EAX bit shifts to this
        jnz     ChromaBlocksDone          ;  position, we are done.
        mov     ecx, IntraFlag
        WriteOneBlock
        shl     eax, 1                  ; Shift CBP mask to next block.
        jmp     ChromaWriteLoop
ChromaBlocksDone:
        mov     eax, pMBRVS_Chroma
        mov     ecx, MMxFlag
        test    ecx, 1
        jz      MacroBlockDone
        mov     [eax],esi
MacroBlockDone:

        ret

MBEncodeVLC     ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3mbme.asm ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3mbme.asv   1.5   18 Oct 1996 16:57:08   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\e3mbme.asv  $
;// 
;//    Rev 1.5   18 Oct 1996 16:57:08   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.4   12 Sep 1996 10:56:16   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.3   22 Jul 1996 15:22:48   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.2   14 May 1996 12:18:48   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.1   03 May 1996 14:03:30   BNICKERS
;// 
;// Minor bug fixes and integration refinements.
;// 
;//    Rev 1.0   02 May 1996 12:00:56   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; MMxBFrameMotionEstimation -- This function performs motion estimation for the
;                              B frame macroblocks identified in the input list.
;                              This is the MMx version.
;

OPTION M510
OPTION CASEMAP:NONE

BFRMNONZEROMVDIFFERENTIAL    =  400
BFRMEMPTYTHRESHOLD           =  256

.xlist
include e3inst.inc
include memmodel.inc
include iammx.inc
include exEDTQ.inc
include e3mbad.inc
.list

.CODE EDTQ

EXTERN MMxDoForwardDCT:NEAR

PUBLIC MMxDoBFrameLumaBlocks
PUBLIC MMxDoBFrameChromaBlocks

StackOffset TEXTEQU <4>
CONST_384   TEXTEQU <ebp>

MMxDoBFrameLumaBlocks:

  mov        eax,QPDiv2        ; Swap these so Quantizer uses right level.
   mov       ebx,BQPDiv2
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       cl,INTER1MV
  mov        BRecip2QPToUse,eax
   mov       StashBlockType,cl

BFrameSWDLoop_0MV:

  mov        ecx,[edx].BlkY1.MVs
   xor       ebx,ebx
  mov        bl,[edx].BlkY1.PVMV          ; P-frame Vertical MV
   lea       edi,WeightForwardMotion
  xor        eax,eax
   and       ecx,0FFH                     ; P-frame Horizontal MV
  mov        al,[edi+ebx]                 ; VMV for past ref.
   mov       bl,[edi+ebx+64]              ; VMV for future ref.
  mov        [edx].BlkY1.VMVb0Delta,bl
   mov       bl,[edi+ecx+64]              ; HMV for future ref.
  mov        [edx].BlkY1.HMVb0Delta,bl
   mov       bl,[edi+ecx]                 ; HMV for past ref.
  mov        [edx].BlkY1.VMVf0Delta,al    ; Record candidate VMVf.
   xor       ecx,ecx                      ; Keep pairing happy.
  mov        [edx].BlkY1.HMVf0Delta,bl    ; Record candidate HMVf.
   mov       edi,[edx].BlkY1.BlkOffset    ; Address of 0-MV blk within frame.

  call       ComputeBFrameSWDForCandRef

  movdf      [edx].BlkY1.BlkLvlSWD0Delta,mm7   ; Stash SWD.
  add        edx,SIZEOF T_Blk
   lea       edi,WeightForwardMotion
  test       dl,4*SIZEOF T_Blk          ; Quit when fourth block done.
  je         BFrameSWDLoop_0MV

  mov        eax,[edx-4*SIZEOF T_Blk].BlkY1.MVs
   mov       cl,[edx-4*SIZEOF T_Blk].BlockType
  xor        cl,INTER1MV 
   or        al,ah
  lea        esi,[edx-4*SIZEOF T_Blk]     ; Reset MacroBlockActionDescr cursor.
   or        al,cl
  mov        ecx,[edx-SIZEOF T_Blk].BlkY1.BlkLvlSWD0Delta
   je        BelowBFrmZeroThreshold  ; Jump if P frm macroblock uses 0 motion vector.
  
  xor        eax,eax
   cmp       ecx,BFrmZeroVectorThreshold
  mov        CurrSWDState,eax             ; Record ME engine state.
   jle       BelowBFrmZeroThreshold

  mov        edx,[esi].BlkY1.BlkLvlSWD0Delta    ; Remember 0-MV SWDs.
   mov       ecx,[esi].BlkY2.BlkLvlSWD0Delta
  mov        [esi].BlkY1.BestBlkLvlSWD,edx 
   mov       [esi].BlkY2.BestBlkLvlSWD,ecx
  mov        edx,[esi].BlkY3.BlkLvlSWD0Delta
   mov       ecx,[esi].BlkY4.BlkLvlSWD0Delta
  mov        [esi].BlkY3.BestBlkLvlSWD,edx
   mov       [esi].BlkY4.BestBlkLvlSWD,ecx
  mov        [esi].BlkU.BestBlkLvlSWD,ecx ; Avoid unintended early out, below.
   xor       edx,edx                      ; Set best MV to zero.

BFrmSWDLoop:

  mov        ecx,PD BFrmSWDState[eax]     ; cl == HMV; ch == VMV offsets to try.
   mov       BestMV,edx                   ; Record what the best MV so far is.
  add        cl,dl                        ; Try this horizontal MV delta.
   je        HMVdIsZero

  mov        PB CandidateMV,cl            ; Record the candidate HMV delta.
   add       ch,dh                        ; Try this vertical MV delta.
  mov        PB CandidateMV+1,ch          ; Record the candidate VMV delta.
   je        VMVdIsZero

VMVdAndHMVdAreNonZero_Loop:

  mov        edx,[esi].BlkY1.MVs
   xor       ebx,ebx
  mov        bl,dl
   xor       eax,eax
  mov        al,dh
   add       esi,SIZEOF T_Blk
  mov        bl,[edi+ebx]                 ; TRb * HMV / TRd
   pxor      mm7,mm7                      ; Initialize SWD accumulator
  add        bl,cl                        ; HMVf = TRb * HMV / TRd + HMVd
   mov       al,[edi+eax]                 ; TRb * VMV / TRd
  cmp        bl,040H                      ; If too far left or right, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVf,bl
   add       al,ch                        ; VMVf = TRb * VMV / TRd + VMVd
  cmp        al,040H                      ; If too far up or down, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVf,al
   sub       bl,dl                        ; -HMVb = -(HMVf - HMV)
  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVb,bl
   sub       al,dh                        ; -VMVb = -(VMVf - VMV)
  test       esi,4*SIZEOF T_Blk
  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVb,al
   je        VMVdAndHMVdAreNonZero_Loop

  sub        esi,4*SIZEOF T_Blk
   jmp       CandidateMVsGotten

VMVdIsZero:
VMVdIsZero_Loop:

  mov        edx,[esi].BlkY1.MVs
   xor       eax,eax
  mov        al,dh
   xor       ebx,ebx
  mov        bl,dl
   add       esi,SIZEOF T_Blk
  mov        dh,[edi+eax+64]              ; -VMVb = -((TRb - TRd) * VMV) / TRd
   mov       al,[edi+eax]                 ; TRb * VMV / TRd
  mov        bl,[edi+ebx]                 ; TRb * HMV / TRd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandVMVf,al
  add        bl,cl                        ; HMVf = TRb * HMV / TRd + HMVd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandVMVb,dh
  cmp        bl,040H                      ; If too far left or right, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVf,bl
   sub       bl,dl                        ; -HMVb = -(HMVf - HMV)
  test       esi,4*SIZEOF T_Blk
  mov        [esi-SIZEOF T_Blk].BlkY1.CandHMVb,bl
   je        VMVdIsZero_Loop

  sub        esi,4*SIZEOF T_Blk
   pxor      mm7,mm7                      ; Initialize SWD accumulator
  jmp        CandidateMVsGotten

BFrameEarlyOutForCandidateMV:
MVDeltaOutOfRange:

  and        esi,-1-7*SIZEOF T_Blk        ; Reset block action descr cursor.
   mov       ebx,CurrSWDState             ; Reload ME engine state.
  xor        eax,eax
   mov       edx,BestMV                   ; Previous best MV is still best.
  mov        al,BFrmSWDState[ebx+2]       ; Get next State number.
   jmp       ProceedWithNextCand

HMVdIsZero:

  mov        PB CandidateMV,cl            ; Record the candidate HMV delta.
   add       ch,dh                        ; Try this vertical MV delta.
  mov        PB CandidateMV+1,ch          ; Record the candidate VMV delta.

HMVdIsZeroLoop:

  mov        edx,[esi].BlkY1.MVs
   xor       ebx,ebx
  mov        bl,dl
   xor       eax,eax
  mov        al,dh
   add       esi,SIZEOF T_Blk
  mov        dl,[edi+ebx+64]              ; -HMVb = -((TRb - TRd) * HMV) / TRd
   mov       bl,[edi+ebx]                 ; TRb * HMV / TRd
  mov        al,[edi+eax]                 ; TRb * VMV / TRd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandHMVf,bl
  add        al,ch                        ; VMVf = TRb * VMV / TRd + VMVd
   mov       [esi-SIZEOF T_Blk].BlkY1.CandHMVb,dl
  cmp        al,040H                      ; If too far up or down, quick out.
   jbe       MVDeltaOutOfRange

  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVf,al
   sub       al,dh                        ; -VMVb = -(VMVf - VMV)
  test       esi,4*SIZEOF T_Blk
  mov        [esi-SIZEOF T_Blk].BlkY1.CandVMVb,al
   je        HMVdIsZeroLoop

  sub        esi,4*SIZEOF T_Blk
   pxor      mm7,mm7                      ; Initialize SWD accumulator

CandidateMVsGotten:
BFrameSWDLoop_Non0MVCandidate:

  xor        eax,eax
   xor       ebx,ebx
  mov        al,[esi].BlkY1.CandVMVf
   mov       edi,[esi].BlkY1.BlkOffset    ; Address of 0-MV blk within frame.
  mov        bl,[esi].BlkY1.CandHMVf
   mov       edx,esi

  call       ComputeBFrameSWDForCandRef

  movdf      ecx,mm7
  mov        eax,[edx].BlkY2.BestBlkLvlSWD
   lea       esi,[edx+SIZEOF T_Blk]       ; Early out if the first N blocks for
  cmp        ecx,eax                      ; this cand are worse than the first
   jge       BFrameEarlyOutForCandidateMV ; N+1 blocks for previous best.

  test       esi,4*SIZEOF T_Blk           ; Quit when fourth block done.
  mov        [esi-SIZEOF T_Blk].BlkY1.CandBlkLvlSWD,ecx   ; Stash SWD.
   je        BFrameSWDLoop_Non0MVCandidate

  ; This candidate is best so far.

  mov        [esi-4*SIZEOF T_Blk].BlkY4.BestBlkLvlSWD,ecx
   mov       ebx,CurrSWDState             ; Reload ME engine state.
  mov        [esi-4*SIZEOF T_Blk].BlkU.BestBlkLvlSWD,ecx
   sub       esi,4*SIZEOF T_Blk
  xor        eax,eax
   mov       edx,CandidateMV              ; Candidate was best MV.
  mov        ecx,[esi].BlkY3.CandBlkLvlSWD
  mov        [esi].BlkY3.BestBlkLvlSWD,ecx
   mov       ecx,[esi].BlkY2.CandBlkLvlSWD
  mov        [esi].BlkY2.BestBlkLvlSWD,ecx
   mov       ecx,[esi].BlkY1.CandBlkLvlSWD
  mov        [esi].BlkY1.BestBlkLvlSWD,ecx
   mov       ecx,[esi].BlkY4.CandBiDiMVs
  mov        [esi].BlkY4.BestBiDiMVs,ecx
   mov       ecx,[esi].BlkY3.CandBiDiMVs
  mov        [esi].BlkY3.BestBiDiMVs,ecx
   mov       ecx,[esi].BlkY2.CandBiDiMVs
  mov        [esi].BlkY2.BestBiDiMVs,ecx
   mov       ecx,[esi].BlkY1.CandBiDiMVs
  mov        [esi].BlkY1.BestBiDiMVs,ecx
   mov       al,BFrmSWDState[ebx+3]       ; Get next State number.

ProceedWithNextCand:

  mov        CurrSWDState,eax             ; Record ME engine state.
   test      eax,eax
  lea        edi,WeightForwardMotion
   jne       BFrmSWDLoop

  mov        ecx,[esi].BlkY4.BlkLvlSWD0Delta          ; 0MV SWD
  sub        ecx,BFRMNONZEROMVDIFFERENTIAL
   mov       ebx,[esi].BlkY4.BestBlkLvlSWD            ; Best non-0 MV SWD.
  cmp        ebx,ecx
   jge       NonZeroBFrmVectorNotGoodEnoughGain

  mov        [esi].BlkY1.BHMV,dl
   mov       [esi].BlkY2.BHMV,dl
  mov        [esi].BlkY3.BHMV,dl
   mov       [esi].BlkY4.BHMV,dl
  mov        [esi].BlkY1.BVMV,dh
   mov       [esi].BlkY2.BVMV,dh
  mov        [esi].BlkY3.BVMV,dh
   mov       [esi].BlkY4.BVMV,dh
  mov        eax,[esi].BlkY4.BestBlkLvlSWD
   mov       ebx,[esi].BlkY3.BestBlkLvlSWD
  sub        eax,ebx
   mov       ecx,[esi].BlkY2.BestBlkLvlSWD
  sub        ebx,ecx
   mov       edx,[esi].BlkY1.BestBlkLvlSWD
  sub        ecx,edx
   mov       [esi].BlkY4.BestBlkLvlSWD,eax
  mov        [esi].BlkY3.BestBlkLvlSWD,ebx
   mov       [esi].BlkY2.BestBlkLvlSWD,ecx
  mov        [esi].BlkY1.BestBlkLvlSWD,edx
   jmp       BFrmMVSettled

BelowBFrmZeroThreshold:
NonZeroBFrmVectorNotGoodEnoughGain:

  mov        ebx,[esi].BlkY4.BlkLvlSWD0Delta
   mov       ecx,[esi].BlkY3.BlkLvlSWD0Delta
  sub        ebx,ecx
   mov       edx,[esi].BlkY2.BlkLvlSWD0Delta
  sub        ecx,edx
   mov       edi,[esi].BlkY1.BlkLvlSWD0Delta
  sub        edx,edi
   mov       [esi].BlkY4.BestBlkLvlSWD,ebx
  mov        [esi].BlkY3.BestBlkLvlSWD,ecx
   mov       [esi].BlkY2.BestBlkLvlSWD,edx
  mov        [esi].BlkY1.BestBlkLvlSWD,edi
   mov       eax,[esi].BlkY1.BiDiMVs0Delta
  mov        [esi].BlkY1.BestBiDiMVs,eax
   mov       eax,[esi].BlkY2.BiDiMVs0Delta
  mov        [esi].BlkY2.BestBiDiMVs,eax
   mov       eax,[esi].BlkY3.BiDiMVs0Delta
  mov        [esi].BlkY3.BestBiDiMVs,eax
   mov       eax,[esi].BlkY4.BiDiMVs0Delta
  mov        [esi].BlkY4.BestBiDiMVs,eax
   xor       eax,eax
  mov        [esi].BlkY1.BHMV,al
   mov       [esi].BlkY2.BHMV,al
  mov        [esi].BlkY3.BHMV,al
   mov       [esi].BlkY4.BHMV,al
  mov        [esi].BlkY1.BVMV,al
   mov       [esi].BlkY2.BVMV,al
  mov        [esi].BlkY3.BVMV,al
   mov       [esi].BlkY4.BVMV,al

BFrmMVSettled:

  mov        edx,esi
   mov       bl,8                       ; Init coded block pattern

BFrmLumaBlkLoop:

  mov        esi,[edx].BlkY1.BestBlkLvlSWD  ; Get SWD for block.
   xor       eax,eax
  mov        BFrmCBP,bl
   cmp       esi,BFRMEMPTYTHRESHOLD     ; Below threshold for forcing empty?
  mov        ecx,BSWDTotal
   jl        BFrmLumaBlkEmpty

  mov        eax,[edx].BlkY1.BestBiDiMVs
   xor       ebx,ebx
  add        ecx,esi
   mov       bl,ah
  mov        BSWDTotal,ecx
   and       eax,0FFH

  call       BFrameDTQ

  mov        bl,BlkEmptyFlag[ebx]       ; Fetch 16 if block not empty; else 0.
   mov       al,BFrmCBP

BFrmLumaBlkEmpty:

  or         bl,al                      ; Factor in CBP bit for this block.
   add       edx,SIZEOF T_Blk
  shr        bl,1                       ; CF == 1 when sentinel shifted off
   jnc       BFrmLumaBlkLoop

  mov        [edx-4*SIZEOF T_Blk].CodedBlocksB,bl
   sub       edx,4*SIZEOF T_Blk
  mov        eax,QPDiv2                 ; Restore these for P frame blocks.
   mov       ebx,BQPDiv2
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       BRecip2QPToUse,eax
  ret

MMxDoBFrameChromaBlocks:

; mov        eax,QPDiv2        ; Swap these so Quantizer uses right level.
;  mov       ebx,BQPDiv2       ; (Loaded in caller.)
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       cl,INTER1MV
  mov        BRecip2QPToUse,eax
   mov       StashBlockType,cl
  mov        eax,[edx].BlkU.BestBiDiMVs
   xor       ebx,ebx
  mov        bl,ah
   and       eax,0FFH
  add        edx,4*SIZEOF T_Blk			; To know we're working on chroma.

  call       BFrameDTQ

  mov        bl,BlkEmptyFlag[ebx]       ; Fetch 16 if block not empty; else 0.
   mov       al,[edx-4*SIZEOF T_Blk].CodedBlocksB
  or         bl,al                      ; Factor in CBP bit for this block.
   mov       eax,[edx-4*SIZEOF T_Blk].BlkV.BestBiDiMVs
  mov        [edx-4*SIZEOF T_Blk].CodedBlocksB,bl
   xor       ebx,ebx
  mov        bl,ah
   and       eax,0FFH
  add        edx,SIZEOF T_Blk

  call       BFrameDTQ

  mov        bl,BlkEmptyFlag[ebx+2]     ; Fetch 32 if block not empty; else 0.
   mov       al,[edx-5*SIZEOF T_Blk].CodedBlocksB
  or         bl,al                      ; Factor in CBP bit for this block.
   mov       eax,QPDiv2                 ; Restore these for P frame blocks.
  mov        [edx-5*SIZEOF T_Blk].CodedBlocksB,bl
   mov       ebx,BQPDiv2
  mov        QPDiv2,ebx
   mov       BQPDiv2,eax
  mov        eax,CodeStreamCursor
   mov       ebx,BCodeStreamCursor
  mov        CodeStreamCursor,ebx
   mov       BCodeStreamCursor,eax
  mov        eax,Recip2QPToUse
   mov       ebx,BRecip2QPToUse
  mov        Recip2QPToUse,ebx
   mov       BRecip2QPToUse,eax
  sub        edx,5*SIZEOF T_Blk
  ret


;===============================================================================

; ebp -- Pitch
; edi -- Address of (0-MV) block within frame.
; edx -- Block Action Decriptor cursor
; ebx -- HMVf (HMV to apply to past reference) biased by 96.
; eax -- VMVf (VMV to apply to past reference) biased by 96.

StackOffset TEXTEQU <8>
ComputeBFrameSWDForCandRef:

  test       al,1
   mov       ecx,PreviousFrameBaseAddress
  lea        eax,[eax+eax*2]                 ; Start of VMVf*384
   jne       ME_VMVfAtHalfPelPosition

ME_VMVfAtFullPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF

  shl        eax,6
   add       ecx,edi
  shr        ebx,1                      ; CF == 1 iff HMVf is at half pel.
   jc        ME_VMVfAtFull_HMVfAtHalfPelPosition

ME_VMVfAtFull_HMVfAtFullPelPosition:

  lea        esi,[ecx+eax-48*PITCH-48]
   lea       ecx,[ebp+ebp*2]
  add        esi,ebx                     ; Address of past reference block.
   mov       eax,BFrameBaseAddress
  add        edi,eax                     ; Address of target block.
   lea       ebx,[ebp+ebp*4]
  movq       mm0,[esi+ebp*1]
  psubw      mm0,[edi+ebp*1]   ; Get diff for line 1.
  movq       mm1,[esi+ecx]     ; Ref MB, upper left block, Line 3.
   psllw     mm0,8             ; Extract diffs for line 1 even pels.
  psubw      mm1,[edi+ecx]     ; Diff for line 3.
   pmaddwd   mm0,mm0           ; Square of diffs for even pels of line 1.
  movq       mm2,[esi+ebx]
   psllw     mm1,8
  psubw      mm2,[edi+ebx]
   pmaddwd   mm1,mm1
  movq       mm3,[esi+PITCH*7]
   psllw     mm2,8
  psubw      mm3,[edi+PITCH*7]
   pmaddwd   mm2,mm2
  movq       mm4,[esi]         ; Ref MB, upper left blk, Line 0.
   psllw     mm3,8
  psubw      mm4,[edi]         ; Diff for line 0.
   paddusw   mm0,mm1           ; Accumulate SWD (lines 0 and 2).
  movq       mm1,[esi+ebp*2]
   pmaddwd   mm3,mm3
  psubw      mm1,[edi+ebp*2]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebp*4]
   pmaddwd   mm4,mm4           ; Square of diffs for odd pels of line 0.
  psubw      mm2,[edi+ebp*4]
   paddusw   mm0,mm3
  movq       mm3,[esi+ecx*2]
   pmaddwd   mm1,mm1
  psubw      mm3,[edi+ecx*2]
   pmaddwd   mm2,mm2
  paddusw    mm0,mm4
   pmaddwd   mm3,mm3
  paddusw    mm0,mm1
   ;
  paddusw    mm0,mm2
   ;
  paddusw    mm0,mm3
   ;
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   ;
  paddusw    mm0,mm1           ; mm0[48:63] is SWD for block.
   ;
  psrlq      mm0,48            ; SWD for block.
   ;
  paddd      mm7,mm0           ; mm7 is SWD for all four blocks.
   ;
  ret

ME_VMVfAtFull_HMVfAtHalfPelPosition:

  lea        esi,[ecx+eax-48*PITCH-48]
   mov       eax,BFrameBaseAddress
  add        esi,ebx                     ; Address of past reference block.
   add       edi,eax                     ; Address of target block.
  lea        ecx,[ebp+ebp*2]
   movq      mm0,mm6                     ; 8 bytes of 1
  pmullw     mm0,[esi]                   ; <(P07+P06)*256+junk ...>
   movq      mm1,mm6
  pmullw     mm1,[esi+ebp*2]
   movq      mm2,mm6
  pmullw     mm2,[esi+ebp*4]
   movq      mm3,mm6
  movq       mm4,[edi]                   ; <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlw     mm0,1                       ; <(P07+P06)*256/2+junk ...>
  pmullw     mm3,[esi+ecx*2]
   psllw     mm4,8                       ; <C06*256 C04*256 C02*256 C00*256>
  movq       mm5,[edi+ebp*2]
   psrlw     mm1,1
  psubw      mm0,mm4                     ; <(P07+P06)*256/2-C06*256+junk ...>
   psllw     mm5,8
  movq       mm4,[edi+ebp*4]
   psrlw     mm2,1
  psubw      mm1,mm5
   psllw     mm4,8
  movq       mm5,[edi+ecx*2]
   psrlw     mm3,1
  psubw      mm2,mm4
   pmaddwd   mm0,mm0                     ; SSD fof even pels of line 0.
  pmaddwd    mm1,mm1
   psllw     mm5,8
  psubw      mm3,mm5
   pmaddwd   mm2,mm2
  pmaddwd    mm3,mm3
   movq      mm5,mm6
  pmullw     mm6,[esi+ebp*1+1]           ; <(P18+P17)*256+junk ...>
   movq      mm4,mm5
  pmullw     mm5,[esi+ecx+1]
   paddusw   mm0,mm1                     ; Accum SSD for lines 0 and 2.
  paddusw    mm2,mm3
   movq      mm1,mm4
  pmullw     mm4,[esi+PITCH*5+1]
   paddusw   mm0,mm2
  pmullw     mm1,[esi+PITCH*7+1]
   psrlw     mm6,1                       ; <(P18+P17)*256/2+junk ...>
  psubw      mm6,[edi+ebp*1]             ; <(P18+P17)*256/2-C17*256+junk ...>
   psrlw     mm5,1
  psubw      mm5,[edi+ecx]
   psrlw     mm4,1
  psubw      mm4,[edi+PITCH*5]
   pmaddwd   mm6,mm6                     ; SSD for odd pels of line 1.
  pmaddwd    mm5,mm5
   psrlw     mm1,1
  psubw      mm1,[edi+PITCH*7]
   pmaddwd   mm4,mm4
  pmaddwd    mm1,mm1
   paddusw   mm0,mm6
  pxor       mm6,mm6
   paddusw   mm0,mm5
  pcmpeqb    mm5,mm5
   paddusw   mm0,mm4
  psubb      mm6,mm5                     ; Restore 8 bytes of -1.
   paddusw   mm0,mm1
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   ;
  paddusw    mm0,mm1           ; mm0[48:63] is SWD for block.
   ;
  psrlq      mm0,48            ; SWD for block.
   ;
  paddd      mm7,mm0           ; mm7 is SWD for all four blocks.
   ;
  ret

ME_VMVfAtHalfPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
  shl        eax,6
   lea       ecx,[ecx+edi-48*PITCH-48-PITCH/2]
  add        ecx,eax
   mov       eax,BFrameBaseAddress
  shr        ebx,1             ; CF == 1 iff HMVf is at half pel.
   mov       esi,ecx           ; esi and ecx same if HMVf at full pel,
  adc        ecx,ebx           ; but inc ecx if HMVf is at half pel.
   add       esi,ebx
  add        edi,eax           ; Address of target block.
   lea       ebx,[ebp+ebp*2]

  movq       mm0,[esi]         ; <P07 P06 ...>
   pcmpeqb   mm6,mm6
  movq       mm1,[ecx+ebp*1]   ; <P17 P16 ...> or <P18 P17 ...>
   psrlw     mm6,8
  movq       mm2,[esi+ebp*2]   ; <P27 P26 ...>
   paddb     mm0,mm1           ; <P07+P17 junk ...> or <P07+P18 junk ...>
  movq       mm3,[ecx+ebx]     ; <P37 P36 ...> or <P38 P37 ...>
   paddb     mm1,mm2           ; <junk P16+P26 ...> or <junk P17+P26 ...>
  movq       mm4,[esi+ebp*4]   ; <P47 P46 ...>
   paddb     mm2,mm3           ; <P27+P37 junk ...> or <P27+P38 junk ...>
  paddb      mm3,mm4           ; <junk P36+P46 ...> or <junk P37+P46 ...>
   psrlw     mm0,1             ; <(P07+P17)/2 junk ...> or (P07+P18)/2 junk ...>
  pand       mm1,mm6           ; <P16+P26 ...> or <P17+P26 ...>
   psrlw     mm2,1             ; <(P27+P37)/2 junk ...> or (P27+P38)/2 junk ...>
  movq       mm5,[edi+ebp*1]   ; <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm3,mm6           ; <P36+P46 ...> or <P37+P46 ...>
  movq       mm6,[edi+ebx]     ; <C37 C36 C35 C34 C33 C32 C31 C30>
   psllw     mm5,8             ; <C16   0 C14   0 C12   0 C10   0>
  psubw      mm0,[edi]         ; <(P07+P17)/2-C07 junk ...> or ...
   psllw     mm1,7             ; <(P16+P26)/2 ...> or <(P17+P26)/2 ...>
  psubw      mm2,[edi+ebp*2]   ; <(P27+P37)/2-C27 junk ...> or ...
   psllw     mm6,8             ; <C36   0 C34   0 C32   0 C30   0>
  pmaddwd    mm0,mm0           ; SSD of even pels of line 0.
   psubw     mm1,mm5           ; <(P16+P26)/2-C16 junk ...> or ...
  pmaddwd    mm1,mm1           ; SSD of odd pels of line 1.
   psllw     mm3,7             ; <(P36+P46)/2 ...> or <(P37+P46)/2 ...>
  pmaddwd    mm2,mm2           ; SSD of even pels of line 2.
   psubw     mm3,mm6           ; <(P36+P46)/2-C36 junk ...> or ...
  pmaddwd    mm3,mm3           ; SSD of odd pels of line 3.
   pcmpeqb   mm6,mm6
  paddusw    mm0,mm1

  movq       mm1,[ecx+PITCH*5]
   paddusw   mm0,mm2
  movq       mm2,[esi+ebx*2]
   paddusw   mm0,mm3
  movq       mm3,[ecx+PITCH*7]
   paddb     mm4,mm1
  paddb      mm1,mm2
   paddb     mm2,mm3
  paddb      mm3,[esi+ebp*8]
   psrlw     mm6,8
  pand       mm1,mm6
   psrlw     mm4,1
  movq       mm5,[edi+PITCH*5]
   psrlw     mm2,1
  pand       mm3,mm6
   psllw     mm5,8
  movq       mm6,[edi+PITCH*7]
   psllw     mm1,7
  psubw      mm4,[edi+ebp*4]
   psllw     mm3,7
  psubw      mm2,[edi+ebx*2]
   psllw     mm6,8
  pmaddwd    mm4,mm4
   psubw     mm1,mm5
  pmaddwd    mm2,mm2
   psubw     mm3,mm6
  pmaddwd    mm1,mm1
   pxor      mm6,mm6
  pmaddwd    mm3,mm3
   paddusw   mm0,mm4
  pcmpeqb    mm5,mm5
   paddusw   mm0,mm1
  psubb      mm6,mm5  ; Restore 8 bytes of 1.
   paddusw   mm0,mm2
  paddusw    mm0,mm3
   ;
  punpckldq  mm1,mm0           ; Get low order SWD accum to high order of mm1.
   ;
  paddusw    mm0,mm1           ; mm0[48:63] is SWD for block.
   ;
  psrlq      mm0,48            ; SWD for block.
   ;
  paddd      mm7,mm0           ; mm7 is SWD for all four blocks.
   ;
  ret

;===============================================================================

; ebp -- Pitch
; edx -- Block Action Decriptor cursor
; ebx -- VMVf (VMV to apply to past reference) biased by 96.
; eax -- HMVf (HMV to apply to past reference) biased by 96.

StackOffset TEXTEQU <8>

BFrameDTQ:

  test       bl,1
   lea       ebx,[ebx+ebx*2]                 ; Start of VMVf*384
  mov        ecx,PreviousFrameBaseAddress
   jne       Diff_VMVfAtHalfPelPosition

Diff_VMVfAtFullPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
  shl        ebx,6
   mov       edi,[edx].BlkY1.BlkOffset   ; Address of 0-MV blk within frame.
  shr        eax,1                       ; CF == 1 iff HMVf is at half pel.
   jc        Diff_VMVfAtFull_HMVfAtHalfPelPosition

Diff_VMVfAtFull_HMVfAtFullPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48]
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   mov       ecx,PITCH/4                 ; Pitch for past reference blk, div 4.
  mov        eax,BFrameBaseAddress       ; Address of target block.
   mov       PastRefPitchDiv4,ecx
  add        edi,eax                     ; Address of target block.
   jmp       Diff_GetFutureContribToPred

Diff_VMVfAtHalfPelPosition:

IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
  shl        ebx,6
   mov       edi,[edx].BlkY1.BlkOffset   ; Address of 0-MV blk within frame.
  shr        eax,1                       ; CF == 1 iff HMVf is at half pel.
   jc        Diff_VMVfAtHalf_HMVfAtHalfPelPosition

Diff_VMVfAtHalf_HMVfAtFullPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48-PITCH/2]; Begin get pastrefaddr. Del bias.
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   lea       eax,PelDiffs-32
  pcmpeqb    mm6,mm6
   pcmpeqb   mm7,mm7                     ; 8 bytes -1
  movq       mm2,[esi]                   ; Line0
   paddb     mm6,mm6                     ; 8 bytes of 0xFE.

@@:

  movq       mm1,[esi+ebp*1]             ; Line1
   movq      mm0,mm2                     ; Line0
  movq       mm2,[esi+ebp*2]             ; Line2
   psubb     mm1,mm7                     ; Line1+1
  paddb      mm0,mm1                     ; Line0+Line1+1
   paddb     mm1,mm2                     ; Line1+Line2+1
  pand       mm0,mm6                     ; pre-clean
   pand      mm1,mm6                     ; pre-clean
  add        eax,32                      ; Advance pointer for PelDiffs output.
   psrlq     mm0,1                       ; (Line0+Line1+1)/2
  lea        esi,[esi+ebp*2]             ; Advance input ptr 2 lines.
   psrlq     mm1,1                       ; (Line1+Line2+1)/2
  movq       [eax],mm0                   ; Store Past Ref for Line0
  movq       [eax+16],mm1                ; Store Past Ref for Line1
  test       al,32                       ; Iterate twice
   jne       @b

  test       al,64                       ; Iterate twice.
   mov       ecx,4                       ; Pitch for past reference blk, div 4.
  mov        PastRefPitchDiv4,ecx
   jne       @b

  mov        eax,BFrameBaseAddress
   lea       esi,PelDiffs                ; Address of interpolated past ref blk.
  add        edi,eax                     ; Address of target block.
   jmp       Diff_GetFutureContribToPred
  
Diff_VMVfAtFull_HMVfAtHalfPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48]   ; Begin get pastrefaddr. Del bias.
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   lea       eax,PelDiffs-32
  lea        ebx,Pel_Rnd
   xor       ecx,ecx

@@:

  movq       mm0,[esi+1]                 ; <P08 P07 P06 P05 P04 P03 P02 P01>
   pcmpeqb   mm7,mm7
  mov        cl,[esi]                    ; P00
   movq      mm2,mm0                     ; <P08 P07 P06 P05 P04 P03 P02 P01>
  movq       mm1,[esi+ebp*1+1]
   psllq     mm2,8                       ; <P07 P06 P05 P04 P03 P02 P01   0>
  paddb      mm0,[ebx+ecx*8]             ; <P08+1 P07+1 ... P01+P00+1>
   movq      mm3,mm1
  mov        cl,[esi+ebp*1]
   psllq     mm3,8
  paddb      mm1,mm3
   paddb     mm0,mm2                     ; <P08+P07+1 P07+P06+1 ... P01+P00+1>
  paddb      mm1,[ebx+ecx*8]
   paddb     mm7,mm7                     ; 8 bytes of 0xFE.
  pand       mm0,mm7                     ; pre-clean
   pand      mm1,mm7                     ; pre-clean
  add        eax,32                      ; Advance pointer for PelDiffs output.
   psrlq     mm0,1                       ; <(P08+P07+1)/2 ...>
  lea        esi,[esi+ebp*2]             ; Advance input ptr 2 lines.
   psrlq     mm1,1
  movq       [eax],mm0                   ; Store Past Ref for Line0
  movq       [eax+16],mm1                ; Store Past Ref for Line1
  test       al,32                       ; Iterate twice
   jne       @b

  test       al,64                       ; Iterate twice.
   mov       cl,4                        ; Pitch for past reference blk, div 4.
  mov        PastRefPitchDiv4,ecx
   jne       @b

  mov        eax,BFrameBaseAddress
   lea       esi,PelDiffs                ; Address of interpolated past ref blk.
  add        edi,eax                     ; Address of target block.
   jmp       Diff_GetFutureContribToPred

Diff_VMVfAtHalf_HMVfAtHalfPelPosition:

  lea        esi,[ecx+ebx-48*PITCH-48-PITCH/2]; Begin get pastrefaddr. Del bias.
   add       eax,edi
  add        esi,eax                     ; Address of past reference block.
   lea       eax,PelDiffs-32
  lea        ebx,Pel_Rnd
   xor       ecx,ecx

  movq       mm3,[esi+1]             ; 0A: <P08 P07 P06 P05 P04 P03 P02 P01>
   pcmpeqb   mm7,mm7
  mov        cl,[esi]                ; 0B: P00
   movq      mm0,mm3                 ; 0C: <P08 P07 P06 P05 P04 P03 P02 P01>
  paddb      mm7,mm7                 ;     8 bytes of 0xFE.
   psllq     mm0,8                   ; 0D: <P07 P06 P05 P04 P03 P02 P01   0>
  paddb      mm3,[ebx+ecx*8]         ; 0E: <P08+1 P07+1 ... P01+P00+1>
   movq      mm6,mm7                 ;     8 bytes of 0xFE.

@@:

  movq       mm1,[esi+ebp*1+1]       ; 1A: <P18 P17 P16 P15 P14 P13 P12 P11>
   paddb     mm0,mm3                 ; 0F: <P08+P07+1 ... P01+P00+1>
  mov        cl,[esi+ebp*1]          ; 1B: P10
   movq      mm3,mm1                 ; 1C: <P18 P17 P16 P15 P14 P13 P12 P11>
  movq       mm2,[esi+ebp*2+1]       ; 2A: <P28 P27 P26 P25 P24 P23 P22 P21>
   psllq     mm3,8                   ; 1D: <P17 P16 P15 P14 P13 P12 P11   0>
  paddb      mm1,[ebx+ecx*8]         ; 1E: <P18+1 P17+1 ... P11+P10+1>
   movq      mm4,mm2                 ; 2C: <P28 P27 P26 P25 P24 P23 P22 P21>
  mov        cl,[esi+ebp*2]          ; 2B: P20
   paddb     mm1,mm3                 ; 1F: <P18+P17+1 ... P11+P10+1>
  pandn      mm6,mm1                 ; 0G: <(P18+P17+1)&1 ...>
   psllq     mm4,8                   ; 2D: <P27 P26 P25 P24 P23 P22 P21   0>
  paddb      mm2,[ebx+ecx*8]         ; 2E: <P28+1 P27+1 ... P21+P20+1>
   movq      mm5,mm6                 ; 1G: <(P18+P17+1)&1 ...>
  paddb      mm2,mm4                 ; 2F: <P28+P27+1 ... P21+P20+1>
   pand      mm6,mm0                 ; 0H: <(P18+P17+1)&(P08+P07+1)&1 ...>
  pand       mm5,mm2                 ; 1H: <(P18+P17+1)&(P28+P27+1)&1 ...>
   pand      mm0,mm7                 ; 0I: pre-clean for divide
  pand       mm1,mm7                 ; 1I: pre-clean for divide
   psrlq     mm0,1                   ; 0J: <(P08+P07+1)/2 ...>
  movq       mm3,mm2                 ;     Save line 2 for next iter's line 0.
   psrlq     mm1,1                   ; 1J: <(P18+P17+1)/2 ...>
  pand       mm2,mm7                 ; 2I: pre-clean for divide
   paddb     mm0,mm1                 ; 0K: <(P08+P07+1)/2+(P18+P17+1)/2 ...>
  paddb      mm6,mm0                 ; 0L: <(P08+P07+P18+P17+2)/2 ...>
   psrlq     mm2,1                   ; 2J: <(P28+P27+1)/2 ...>
  paddb      mm1,mm2                 ; 1K: <(P18+P17+1)/2+(P28+P27+1)/2 ...>
   pand      mm6,mm7                 ; 0M: pre-clean for divide
  paddb      mm5,mm1                 ; 1L: <(P18+P17+P28+P27+2)/2 ...>
   psrlq     mm6,1                   ; 0M: <(P08+P07+P18+P17+2)/4 ...>
  add        eax,32                  ;     Advance pointer for PelDiffs output.
   pand      mm5,mm7                 ; 1M: pre-clean for divide
  lea        esi,[esi+ebp*2]         ;     Advance input ptr 2 lines.
   psrlq     mm5,1                   ; 1N: <(P18+P17+P28+P27+2)/4 ...>
  movq       [eax],mm6               ; 0O: Store Past Ref for Line0
   pxor      mm0,mm0                 ;     So that add of mm3 is just like movq.
  movq       [eax+16],mm5            ; 1O: Store Past Ref for Line1
   movq      mm6,mm7                 ;     8 bytes of 0xFE.
  test       al,32                   ;     Iterate twice
   jne       @b

  test       al,64                       ; Iterate twice.
   mov       cl,4                        ; Pitch for past reference blk, div 4.
  jne        @b

  mov        eax,BFrameBaseAddress
   lea       esi,PelDiffs                ; Address of interpolated past ref blk.
  add        edi,eax                     ; Address of target block.
   mov       PastRefPitchDiv4,ecx

Diff_GetFutureContribToPred:

;===============================================================================
;
; Registers at entry:
; edi -- Pointer to target block.
; esi -- Pointer to past reference.
; edx -- Block Descriptor within MacroBlockActionDescritptorStream
;
; Subsequent assignments:
;
; ebp -- Pitch for past reference block, div 4.  Loop counter in high 2 bits.
; ecx -- Pointer to future reference block
; ebx -- Pointer to list of indices of multipliers to wt past and future refs.
; eax,edx -- Index of multiplier to weight past and future ref.

  xor        ecx,ecx
   mov       eax,edx
IF SIZEOF T_Blk-16
  **** The magic leaks out if size of block descriptor is not 16.
ENDIF
  mov        cl,[edx].BlkY1.BestHMVb      ; HMV for future reference block.
   and       edx,112                      ; Extract block number (times 16).
  xor        ebx,ebx
   mov       BlockActionDescrCursor,eax
  mov        bl,[eax].BlkY1.BestVMVb      ; VMV for future reference block.
   mov       eax,LeftRightBlkPosition[edx]
  mov        ebp,ecx
CONST_384   TEXTEQU <384>
   mov       edx,UpDownBlkPosition[edx]
  mov        cl,[eax+ecx*2]              ; Get horz part of past/future wt sel.
IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
   lea       eax,[ebx+ebx*2]             ; Start of VMVb*384
  mov        bl,[edx+ebx*2]              ; Get vert part of past/future wt sel.
  shl        eax,6
   mov       edx,BFrameToFuture
  lea        ebx,Diff_IdxRefWts[ecx+ebx] ; Addr of list of wts for refs.
   test      al,64                       ; Is VMVb odd?
  lea        eax,[eax+edx]               ; Begin to get addr futr ref.
   jne       Diff_VMVbAtHalfPelPosition

Diff_VMVbAtFullPelPosition:

CONST_384   TEXTEQU <384>

  shr        ebp,1                     ; CF == 1 iff HMVf is at half pel.
   lea       esp,[esp-128]
StackOffset TEXTEQU <136>
  lea        ecx,[eax+edi-48*PITCH-48]
   jc        Diff_VMVbAtFull_HMVbAtHalfPelPosition

Diff_VMVbAtFull_HMVbAtFullPelPosition:

CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   xor       edx,edx

@@:

StackOffset TEXTEQU <undefined>

  mov        al,[ebx]                  ; 0A: Index of weights for line 0.
   add       esp,32                    ;     Advance Pel Difference cursor
  mov        dl,[ebx+1]                ; 1A: Index of weights for line 1.
   add       ebx,2                     ;     Advance list ptr for ref weights.
  movq       mm0,[ecx]                 ; 0B: <F07 F06 F05 F04 F03 F02 F01 F00>
   pcmpeqb   mm7,mm7
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   paddb     mm7,mm7                   ;     8 bytes of 0xFE
  movq       mm3,[esi]                 ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   pand      mm0,mm2                   ; 0E: <In?F07:00 In?F06:00 ...>
  pandn      mm2,mm3                   ; 0F: <In?00:P07 In?00:P06 ...>
   paddb     mm0,mm3                   ; 0G: <In?F07+P07:P07 ...>
  movq       mm1,[ecx+PITCH]           ; 1B: <F17 F16 F15 F14 F13 F12 F11 F10>
   paddb     mm0,mm2                   ; 0H: <In?F07+P07:2P07 ...>
  movq       mm2,FutureWt_FF_or_00[edx]; 1C: <In?FF:00 ...>
   pand      mm0,mm7                   ; 0I: pre-clean
  movq       mm3,[esi+ebp*4]           ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   pand      mm1,mm2                   ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm2,mm3                   ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                   ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]                 ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                     ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                   ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   paddb     mm1,mm2                   ; 1H: <In?F17+P17:2P17 ...>
  movq       mm4,[edi+PITCH]           ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm1,mm7                   ; 1I: pre-clean
  add        edi,PITCH*2               ;     Advance Target Blk cursor
   psrlq     mm1,1                     ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3              ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm4,mm1                   ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  add        ecx,PITCH*2               ;     Advance Future Ref Blk cursor
   lea       esi,[esi+ebp*8]           ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm4           ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
  add        ebp,080000000H            ;     Iterate twice
   jnc       @b

  test       ebp,040000000H            ;     Iterate twice
  lea        ebp,[ebp+040000000H]
   je        @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

Diff_VMVbAtHalfPelPosition:

CONST_384   TEXTEQU <384>

  shr        ebp,1                     ; CF == 1 iff HMVf is at half pel.
   lea       esp,[esp-128]
StackOffset TEXTEQU <136>
  lea        ecx,[eax+edi-48*PITCH-48-PITCH/2]
   jc        Diff_VMVbAtHalf_HMVbAtHalfPelPosition

Diff_VMVbAtHalf_HMVbAtFullPelPosition:

CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   xor       edx,edx
  movq       mm6,[ecx]                 ; 0B: <F07 F06 F05 F04 F03 F02 F01 F00>
   pcmpeqb   mm7,mm7                   ;     8 bytes -1

@@:

StackOffset TEXTEQU <undefined>

  movq       mm1,[ecx+PITCH]           ; 1a: <f17 f16 f15 f14 f13 f12 f11 f10>
   movq      mm0,mm6                   ; 0a: <f07 f06 f05 f04 f03 f02 f01 f00>
  mov        al,[ebx]                  ; 0A: Index of weights for line 0.
   psubb     mm1,mm7                   ;  b: <f17+1 ...>
  movq       mm6,[ecx+PITCH*2]         ; 2a: <f27 f26 f25 f24 f23 f22 f21 f20>
   paddb     mm0,mm1                   ; 0c: <f07+f17+1..>
  mov        dl,[ebx+1]                ; 1A: Index of weights for line 1.
   paddb     mm7,mm7                   ;     8 bytes of 0xFE
  paddb      mm1,mm6                   ; 1c: <f17+f27+1..>
   pand      mm0,mm7                   ; 0d: pre-clean
  pand       mm1,mm7                   ; 1d: pre-clean
   psrlq     mm0,1                     ; 0B: <(F07 = f07+f17+1)/2>
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   psrlq     mm1,1                     ; 1B: <(F17 = f17+f27+1)/2>
  movq       mm3,[esi]                 ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   pand      mm0,mm2                   ; 0E: <In?F07:00 In?F06:00 ...>
  pandn      mm2,mm3                   ; 0F: <In?00:P07 In?00:P06 ...>
   paddb     mm0,mm3                   ; 0G: <In?F07+P07:P07 ...>
  add        ebx,2                     ;     Advance list ptr for ref weights.
   paddb     mm0,mm2                   ; 0H: <In?F07+P07:2P07 ...>
  movq       mm2,FutureWt_FF_or_00[edx]; 1C: <In?FF:00 ...>
   pand      mm0,mm7                   ; 0I: pre-clean
  movq       mm3,[esi+ebp*4]           ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   pand      mm1,mm2                   ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm2,mm3                   ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                   ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]                 ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                     ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                   ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   add       esp,32                    ;     Advance Pel Difference cursor
  movq       mm4,[edi+PITCH]           ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   paddb     mm1,mm2                   ; 1H: <In?F17+P17:2P17 ...>
  add        ecx,PITCH*2               ;     Advance Future Ref Blk cursor
   pand      mm1,mm7                   ; 1I: pre-clean
  add        edi,PITCH*2               ;     Advance Target Blk cursor
   psrlq     mm1,1                     ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3              ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm4,mm1                   ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  pcmpeqb    mm7,mm7                   ;     8 bytes -1
   lea       esi,[esi+ebp*8]           ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm4           ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
   pcmpeqb   mm7,mm7                   ;     8 bytes -1
  add        ebp,080000000H            ;     Iterate twice
   jnc       @b

  add        ebp,040000000H            ;     Iterate twice
  test       ebp,ebp
   jns       @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

Diff_VMVbAtFull_HMVbAtHalfPelPosition:

StackOffset TEXTEQU <136>
CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   lea       edx,Pel_Rnd

@@:

StackOffset TEXTEQU <undefined>

  movq       mm0,[ecx+1]               ; 0a: <f08 f07 f06 f05 f04 f03 f02 f01>
   pcmpeqb   mm7,mm7
  mov        al,[ecx]                  ; 0b: f00
   movq      mm2,mm0                   ; 0c: <f08 f07 f06 f05 f04 f03 f02 f01>
  movq       mm1,[ecx+PITCH+1]         ; 1a: <f18 f17 f16 f15 f14 f13 f12 f11>
   psllq     mm2,8                     ; 0d: <f07 f06 f05 f04 f03 f02 f01   0>
  paddb      mm0,[edx+eax*8]           ; 0e: <f08+1 f07+1 ... f01+f00+1>
   movq      mm3,mm1                   ; 1c: <f18 f17 f16 f15 f14 f13 f12 f11>
  mov        al,[ecx+PITCH]            ; 1b: f10
   psllq     mm3,8                     ; 1d: <f17 f16 f15 f14 f13 f12 f11   0>
  paddb      mm0,mm2                   ; 0f: <f08+f07+1 f07+f06+1 ... f01+f00+1>
   paddb     mm1,mm3                   ; 1f: <f18+f17   f17+f16   ... f11      >
  paddb      mm1,[edx+eax*8]           ; 1e: <f18+f17+1 f17+f16+1 ... f11+f10+1>
   paddb     mm7,mm7                   ;     8 bytes of 0xFE.
  mov        al,[ebx]                  ; 0A: Index of weights for line 0.
   pand      mm0,mm7                   ; 0g: pre-clean
  movq       mm3,[esi]                 ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   psrlq     mm0,1                     ; 0B: <F07 = (f08+f07+1)/2 ...>
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   pand      mm1,mm7                   ; 1g: pre-clean
  mov        al,[ebx+1]                ; 1A: Index of weights for line 1.
   psrlq     mm1,1                     ; 1B: <F17 = (f18+f17+1)/2 ...>
  pand       mm0,mm2                   ; 0E: <In?F07:00 In?F06:00 ...>
   pandn     mm2,mm3                   ; 0F: <In?00:P07 In?00:P06 ...>
  movq       mm4,FutureWt_FF_or_00[eax]; 1C: <In?FF:00 ...>
   paddb     mm0,mm3                   ; 0G: <In?F07+P07:P07 ...>
  movq       mm3,[esi+ebp*4]           ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   paddb     mm0,mm2                   ; 0H: <In?F07+P07:2P07 ...>
  pand       mm0,mm7                   ; 0I: pre-clean
   pand      mm1,mm4                   ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm4,mm3                   ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                   ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]                 ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                     ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                   ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   add       esp,32                    ;     Advance Pel Difference cursor
  add        ecx,PITCH*2               ;     Advance Future Ref Blk cursor
   paddb     mm1,mm4                   ; 1H: <In?F17+P17:2P17 ...>
  movq       mm4,[edi+PITCH]           ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm1,mm7                   ; 1I: pre-clean
  add        edi,PITCH*2               ;     Advance Target Blk cursor
   psrlq     mm1,1                     ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3              ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm4,mm1                   ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  add        ebx,2                     ;     Advance list ptr for ref weights.
   lea       esi,[esi+ebp*8]           ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm4           ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
  add        ebp,080000000H            ;     Iterate twice
   jnc       @b

  add        ebp,040000000H            ;     Iterate twice
  test       ebp,ebp
   jns       @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

Diff_VMVbAtHalf_HMVbAtHalfPelPosition:

StackOffset TEXTEQU <136>
CONST_384   TEXTEQU <384>

  add        ecx,ebp                   ; Address of future reference block.
   mov       ebp,PastRefPitchDiv4
  xor        eax,eax
   lea       edx,Pel_Rnd
  movq       mm4,[ecx+1]               ; 0a: <f08 f07 f06 f05 f04 f03 f02 f01>
   pcmpeqb   mm7,mm7
  mov        al,[ecx]                  ; 0b: f00
   movq      mm0,mm4                   ; 0c: <f08 f07 f06 f05 f04 f03 f02 f01>
  paddb      mm7,mm7                   ;     8 bytes of 0xFE.
   psllq     mm0,8                     ; 0d: <f07 f06 f05 f04 f03 f02 f01   0>
  paddb      mm4,[edx+eax*8]           ; 0e: <f08+1 f07+1 ... f01+f00+1>
   movq      mm6,mm7                   ;     8 bytes of 0xFE.

@@:

StackOffset TEXTEQU <undefined>

  movq       mm1,[ecx+PITCH+1]       ; 1a: <f18 f17 f16 f15 f14 f13 f12 f11>
   paddb     mm0,mm4                 ; 0f: <f08+f07+1 ... f01+f00+1>
  mov        al,[ecx+PITCH]          ; 1b: f10
   movq      mm3,mm1                 ; 1c: <f18 f17 f16 f15 f14 f13 f12 f11>
  movq       mm2,[ecx+PITCH*2+1]     ; 2a: <f28 f27 f26 f25 f24 f23 f22 f21>
   psllq     mm3,8                   ; 1d: <f17 f16 f15 f14 f13 f12 f11   0>
  paddb      mm1,[edx+eax*8]         ; 1e: <f18+1 f17+1 ... f11+f10+1>
   movq      mm4,mm2                 ; 2c: <f28 f27 f26 f25 f24 f23 f22 f21>
  mov        al,[ecx+PITCH*2]        ; 2b: f20
   paddb     mm1,mm3                 ; 1f: <f18+f17+1 ... f11+f10+1>
  pandn      mm6,mm1                 ; 0g: <(f18+f17+1)&1 ...>
   psllq     mm4,8                   ; 2d: <f27 f26 f25 f24 f23 f22 f21   0>
  paddb      mm2,[edx+eax*8]         ; 2e: <f28+1 f27+1 ... f21+f20+1>
   movq      mm5,mm6                 ; 1g: <(f18+f17+1)&1 ...>
  paddb      mm2,mm4                 ; 2f: <f28+f27+1 ... f21+f20+1>
   pand      mm6,mm0                 ; 0h: <(f18+f17+1)&(f08+f07+1)&1 ...>
  pand       mm5,mm2                 ; 1h: <(f18+f17+1)&(f28+f27+1)&1 ...>
   pand      mm0,mm7                 ; 0i: pre-clean for divide
  pand       mm1,mm7                 ; 1i: pre-clean for divide
   psrlq     mm0,1                   ; 0j: <(f08+f07+1)/2 ...>
  movq       mm4,mm2                 ;     Save line 2 for next iter's line 0.
   psrlq     mm1,1                   ; 1j: <(f18+f17+1)/2 ...>
  pand       mm2,mm7                 ; 2i: pre-clean for divide
   paddb     mm0,mm1                 ; 0k: <(f08+f07+1)/2+(f18+f17+1)/2 ...>
  paddb      mm0,mm6                 ; 0l: <(f08+f07+f18+f17+2)/2 ...>
   psrlq     mm2,1                   ; 2j: <(f28+f27+1)/2 ...>
  paddb      mm1,mm2                 ; 1k: <(f18+f17+1)/2+(f28+f27+1)/2 ...>
   pand      mm0,mm7                 ; 0m: pre-clean for divide
  mov        al,[ebx]                ; 0A: Index of weights for line 0.
   paddb     mm1,mm5                 ; 1l: <(f18+f17+f28+f27+2)/2 ...>
  movq       mm3,[esi]               ; 0D: <P07 P06 P05 P04 P03 P02 P01 P00>
   pand      mm1,mm7                 ; 1m: pre-clean for divide
  movq       mm2,FutureWt_FF_or_00[eax]; 0C: <In?FF:00 ...>
   psrlq     mm0,1                   ; 0B: <F07 = (f08+f07+f18+f17+2)/4 ...>
  mov        al,[ebx+1]              ; 1A: Index of weights for line 1.
   psrlq     mm1,1                   ; 1B: <F17 = (f18+f17+f28+f27+2)/4 ...>
  pand       mm0,mm2                 ; 0E: <In?F07:00 In?F06:00 ...>
   pandn     mm2,mm3                 ; 0F: <In?00:P07 In?00:P06 ...>
  movq       mm5,FutureWt_FF_or_00[eax]; 1C: <In?FF:00 ...>
   paddb     mm0,mm3                 ; 0G: <In?F07+P07:P07 ...>
  movq       mm3,[esi+ebp*4]         ; 1D: <P17 P16 P15 P14 P13 P12 P11 P10>
   paddb     mm0,mm2                 ; 0H: <In?F07+P07:2P07 ...>
  pand       mm0,mm7                 ; 0I: pre-clean
   pand      mm1,mm5                 ; 1E: <In?F17:00 In?F16:00 ...>
  pandn      mm5,mm3                 ; 1F: <In?00:P17 In?00:P16 ...>
   paddb     mm1,mm3                 ; 1G: <In?F17+P17:P17 ...>
  movq       mm3,[edi]               ; 0J: <C07 C06 C05 C04 C03 C02 C01 C00>
   psrlq     mm0,1                   ; 0K: <In?(F07+P07)/2:P07 ...>
  psubb      mm3,mm0                 ; 0L: <In?C07-(F07+P07)/2:C07-P07 ...>
   add       esp,32                  ;     Advance Pel Difference cursor
  paddb      mm1,mm5                 ; 1H: <In?F17+P17:2P17 ...>
   add       ecx,PITCH*2             ;     Advance Future Ref Blk cursor
  movq       mm5,[edi+PITCH]         ; 1J: <C17 C16 C15 C14 C13 C12 C11 C10>
   pand      mm1,mm7                 ; 1I: pre-clean
  add        edi,PITCH*2             ;     Advance Target Blk cursor
   psrlq     mm1,1                   ; 1K: <In?(F17+P17)/2:P17 ...>
StackOffset TEXTEQU <8+96>
  movq       PelDiffs,mm3            ; 0M: Save pel differences for line 0.
StackOffset TEXTEQU <undefined>
   psubb     mm5,mm1                 ; 1L: <In?C17-(F17+P17)/2:C17-P17 ...>
  add        ebx,2                   ;     Advance list ptr for ref weights.
   lea       esi,[esi+ebp*8]         ;     Advance Past Ref Blk cursor
StackOffset TEXTEQU <8+96>
  movq       PelDiffs+16,mm5         ; 1M: Save pel differences for line 1.
StackOffset TEXTEQU <undefined>
   pxor      mm0,mm0                 ;     So that add of mm4 is just like movq.
  add        ebp,080000000H          ;     Iterate twice
   movq      mm6,mm7                 ;     8 bytes of 0xFE.
  jnc        @b

  add        ebp,040000000H            ;     Iterate twice
  test       ebp,ebp
   jns       @b

StackOffset TEXTEQU <8>

  mov        ebp,16
   lea       esi,PelDiffs
  mov        edx,BlockActionDescrCursor
   jmp       MMxDoForwardDCT

CONST_384   TEXTEQU <ebp>

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dx5cnvy.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;* -------------------------------------------------------------------------
;* PVCS Source control information:
;*
;*  $Header:   S:\h26x\src\dec\dx5cnvy.asv   1.1   29 Aug 1995 16:50:02   DBRUCKS  $
;*
;*  $Log:   S:\h26x\src\dec\dx5cnvy.asv  $
;// 
;//    Rev 1.1   29 Aug 1995 16:50:02   DBRUCKS
;// add in and out pitch parameters
;// 
;//    Rev 1.0   23 Aug 1995 12:20:32   DBRUCKS
;// Initial revision.
;*  
;*  NOTE:
;*         The starting source for this routine came for the PVCS database 
;*         for the H.261 decoder.  cc12to7.asm version 1.6.  This is a 
;*         working 16-bit version.
;* -------------------------------------------------------------------------

;////////////////////////////////////////////////////////////////////////////
;  Convert_Y_8to7_Bit -- This function converts the Y data from 8 bits to 7 bits
;                        and moves the data into the format the MRV color
;                        convertors want.
;
;                        Input to this function is either YVU12 from the decoder,
;                        or YVU9 for looking glass.
;
; NOTES:
;   Routine uses 4 DWORDs on stack for local variables
;   The 16-bit code is not up to date.
;
; ASSUMPTIONS/LIMITATIONS:
;   -- YPitchOut >= XResolution
;   -- YPitch    >= XResolution
;
;-------------------------------------------------------------------------------

ifndef WIN32
.MODEL SMALL
endif

.486

ifdef WIN32
.MODEL FLAT
.DATA

else ;; WIN16
_DATA	SEGMENT PUBLIC 'DATA'
endif


;;	Lookup Table for 8->7 bit conversion and clamping.
tbl8to7	BYTE      8,  8,  8,  8,  8,  8,  8,  8
        BYTE      8,  8,  8,  8,  8,  8,  8,  8  
        BYTE      8,  8,  9,  9, 10, 10, 11, 11
        BYTE     12, 12, 13, 13, 14, 14, 15, 15
        BYTE     16, 16, 17, 17, 18, 18, 19, 19
        BYTE     20, 20, 21, 21, 22, 22, 23, 23
        BYTE     24, 24, 25, 25, 26, 26, 27, 27
        BYTE     28, 28, 29, 29, 30, 30, 31, 31
        BYTE     32, 32, 33, 33, 34, 34, 35, 35
        BYTE     36, 36, 37, 37, 38, 38, 39, 39
        BYTE     40, 40, 41, 41, 42, 42, 43, 43 
        BYTE     44, 44, 45, 45, 46, 46, 47, 47
        BYTE     48, 48, 49, 49, 50, 50, 51, 51
        BYTE     52, 52, 53, 53, 54, 54, 55, 55
        BYTE     56, 56, 57, 57, 58, 58, 59, 59
        BYTE     60, 60, 61, 61, 62, 62, 63, 63
        BYTE     64, 64, 65, 65, 66, 66, 67, 67
        BYTE     68, 68, 69, 69, 70, 70, 71, 71
        BYTE     72, 72, 73, 73, 74, 74, 75, 75
        BYTE     76, 76, 77, 77, 78, 78, 79, 79
        BYTE     80, 80, 81, 81, 82, 82, 83, 83
        BYTE     84, 84, 85, 85, 86, 86, 87, 87
        BYTE     88, 88, 89, 89, 90, 90, 91, 91
        BYTE     92, 92, 93, 93, 94, 94, 95, 95
        BYTE     96, 96, 97, 97, 98, 98, 99, 99
        BYTE    100,100,101,101,102,102,103,103
        BYTE    104,104,105,105,106,106,107,107
        BYTE    108,108,109,109,110,110,111,111
        BYTE    112,112,113,113,114,114,115,115
        BYTE    116,116,117,117,118,118,119,119
        BYTE    120,120,120,120,120,120,120,120
        BYTE    120,120,120,120,120,120,120,120

_DATA	ENDS

ifdef WIN32
.CODE
assume cs : flat
assume ds : flat
assume es : flat
assume fs : flat
assume gs : flat
assume ss : flat

else
_TEXT32 SEGMENT PUBLIC READONLY USE32 'CODE'
ASSUME	DS:_DATA
ASSUME	CS:_TEXT32
ASSUME	ES:nothing
ASSUME	FS:nothing
ASSUME	GS:nothing
endif

;32-bit version of call
;C function prototype
;
;long Convert_Y_8to7_Bit(HPBYTE      pYPlaneInput,  /* ptr Y plane */
;			             DWORD       YResolution,   /* Y plane height */
;			             DWORD       XResolution,   /* Y plane width */
;			             DWORD		 YInPitch,      /* Y input pitch */
;			             HPBYTE      pYPlaneOutput, /* pYOut */
;                        DWORD       YOutPitch      /* Y output pitch */
;			            )
;
;16-bit version of call
;C function prototype  -- not up to date
;
;long Convert_Y_8to7_Bit(HPBYTE      pYPlaneInput,  /*ptr Y plane*/
;			WORD        YResolution,   /*Y plane height*/
;			WORD        XResolution,   /*Y plane width*/
;			HPBYTE      pYPlaneOutput, /*pYOut*/
;			WORD        YPitchOut      /*Pitch of Y plane Out*/
;			)

PUBLIC _Convert_Y_8to7_Bit

ifdef WIN32
_Convert_Y_8to7_Bit proc
;   parmD    pYPlaneIn        ;ptr to Y input plane
;   parmD    YRes             ;Y plane height
;   parmD    XRes             ;Y plane width
;   parmD    YInPitch         ;Y input pitch
;   parmD    pYPlaneOut       ;ptr to Y output plane
;   parmD    YOutPitch        ;ptr to Y output pitch
else
_Convert_Y_8to7_Bit proc far
;   parmD    pYPlaneIn        ;ptr to Y input plane
;   parmW    YRes             ;Y plane height
;   parmW    XRes             ;Y plane width
;   parmD    pYPlaneOut       ;ptr to Y output plane
;   parmW    YPitchOut        ;Pitch of Y plane output

endif

;set up equates
ifdef WIN32
pYPlaneIn   EQU  DWORD PTR[ebp+8]
YRes        EQU  DWORD PTR[ebp+12]
XRes        EQU  DWORD PTR[ebp+16]
YInPitch    EQU  DWORD PTR[ebp+20]
pYPlaneOut  EQU  DWORD PTR[ebp+24]
YOutPitch   EQU  DWORD PTR[ebp+28]
else
pYPlaneIn   EQU  DWORD PTR[ebp+8]
YRes        EQU  WORD  PTR[ebp+12]
XRes        EQU  WORD  PTR[ebp+14]
pYPlaneOut  EQU  DWORD PTR[ebp+16]
YPitchOut   EQU  WORD  PTR[ebp+20]
endif

;; stack usage
; previous ebp at ebp 
; previous edi at ebp - 4
; previous esi at ebp - 8
; lXResDiv4    at ebp -12
; YInDiff      at ebp -16
; YOutDiff     at ebp -20
; outloopcnt   at ebp -24
; inloopcnt    at ebp -28

lXResDiv4    EQU  DWORD PTR[ebp-12]
YInDiff      EQU  DWORD PTR[ebp-16]
YOutDiff	 EQU  DWORD PTR[ebp-20]
outloopcnt   EQU  DWORD PTR[ebp-24]
inloopcnt    EQU  DWORD PTR[ebp-28]

    xor   ax,ax           ; These two instructions give definitive proof we are
    mov   eax,0CCCCCCCCH  ; in a 32-bit code segment.  INT 3 occurs if not.

;get params
    push    ebp

ifdef WIN32

      mov   ebp, esp
else
	movzx  	ebp, sp	   
endif
	push    edi
	  push  esi

ifdef WIN32
; zero out registers

else
; zero out registers
   	xor     esi, esi
      xor	edi, edi
endif

; move variables to local space on stack
ifdef WIN32
    mov     eax, XRes
      mov   ecx, YInPitch
    mov     edx, YOutPitch    
else
	movzx	eax, XRes
	movzx	ecx, YPitchOut
endif
	  sub   ecx, eax       ; YInDiff = YInPitch - XRes
	sub     edx, eax       ; YOutDiff = YOutPitch - XRes
	shr     eax, 2
	push	eax            ; store lXResDiv4 == XRes/4 on stack
	  push	ecx            ; store YInDiff on stack
	push    edx            ; store YOutDiff on stack

; push stack with 0 2 additional times to make room for other locals
	xor     edx, edx
	  push  edx            ; outloopcnt
	push    edx            ; inloopcnt

; ********************
; Copy Y Plane from soure to dest and convert to 7 bits
; ********************
; Description of YPlane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes lines 
;       Collp1 loops for number of columns/4
;         - Read 4 inputs in one DWORD
;         - Convert each value from 8-bit to 7-bit
;         - Store 4 output in one DWORD
;
; Register usage
;  eax	holds 4 output value 8 bits each
;  ebx	holds 4 source value and index into tbl8to7
;  ecx	index into tbl8to7
;  edx	index into tbl8to7
;  esi	src address
;  edi	des address
;  ebp	stack pointer stuff
;
; if 16-bit
;  es	input plane segment
;  fs	output plane segment
;  ds	table segment
; endif
;
; local variables
;  outloopcnt
;  inloopcnt
;  lXResDiv4
;  YInDiff
;  YOutDiff
;
ifdef WIN32
    mov     esi, pYPlaneIn  ; Initialize input cursor
      mov   edi, pYPlaneOut ; Initialize output cursor
    mov     ebx, YRes		; get YResolution
    sub     edi, YOutDiff	; Pre-adjust for add in loop of
							;   difference between YPitchOut and
							;   XRes
	sub		esi, YInDiff
else
	les	si,  pYPlaneIn		; Initialize input cursor
	lfs	di,  pYPlaneOut		; Initialize output cursor
	sub	edi, YOutDiff		; Pre-adjust for add in loop of
							;   difference between YPitchOut and
							;   XRes
	sub esi, YInDiff
	movzx	ebx, YRes		; get YResolution
endif

Outlp:
    mov	    edx, lXResDiv4	; edx = number of columns/4
      mov	outloopcnt, ebx	; initialize/store updated outloopcnt
    add     edi, YOutDiff	; adjust for difference
      mov   inloopcnt, edx	; set inner loop count
	add		esi, YInDiff	; adjust for difference

; Preamble
ifdef WIN32
    mov     ebx, [esi]		; Fetch source, 4 at a time
      nop
	mov	    ecx, ebx		; Move source to temp
      nop
else
  	mov	    ebx, es:[esi]	; Fetch source, 4 at a time
	mov	    ecx,ebx			; Move source to temp
endif
    shr	    ecx,24			; shift to get 4th address
      mov   edx,ebx			; Move source to temp
    shr     edx,16			; Shift to get 3rd address
      add   esi,4			; increment source to next 4
    mov     ah, tbl8to7[ecx]; convert 4th element to 7 bits
      and   edx,0000000ffh	; and off 3rd element
    mov     ecx,ebx			; Move source to temp
      add   edi,4			; incrment to next destination
    shr     ecx,8			; Shift to get 2nd address
      and   ebx,0000000ffh	; and off 1st element
    and     ecx,0000000ffh	; And off 2nd element
      mov   al, tbl8to7[edx]; convert 3rd element to 7 bits
    shl     eax,16			; Shift output up
      mov   edx, inloopcnt	; get inner loop count
    mov     al, tbl8to7[ebx]; convert 1st element to 7 bits
      dec   edx				; decrement inner loop counter
    mov     ah, tbl8to7[ecx]; convert 2nd element to 7 bits

Collp:
ifdef WIN32
  	mov  	ebx, [esi]		; Fetch source, 4 at a time
	  mov	inloopcnt, edx	; store updated inner loop count
	mov  	[edi-4],eax		; Store 4 converted values
else
  	mov  	ebx, es:[esi]	; Fetch source, 4 at a time
	  mov	inloopcnt, edx	; store updated inner loop count
	mov  	fs:[edi-4],eax	; Store 4 converted values
endif
       mov  ecx,ebx			; Move source to temp
    shr     ecx,24			; shift to get 4th address
      mov   edx,ebx			; Move source to temp
    shr     edx,16			; Shift to get 3rd address
      add   esi,4			; increment source to next 4
    mov     ah, tbl8to7[ecx]; convert 4th element to 7 bits
      and   edx,0000000ffh	; and off 3rd element
    mov     ecx,ebx			; Move source to temp
      add   edi,4			; incrment to next destination
    shr     ecx,8			; Shift to get 2nd address
      and   ebx,0000000ffh	; and off 1st element
    and     ecx,0000000ffh	; And off 2nd element
      mov   al, tbl8to7[edx]; convert 3rd element to 7 bits
    shl     eax,16			; Shift output up
      mov   edx, inloopcnt	; get inner loop count
    mov     al, tbl8to7[ebx]; convert 1st element to 7 bits
      dec   edx				; decrement inner loop counter
    mov     ah, tbl8to7[ecx]; convert 2nd element to 7 bits
      jg    Collp			; if not done loop

; Postscript
ifdef WIN32
    mov  	[edi-4],eax		; Store 4 converted values
else
    mov  	fs:[edi-4],eax	; Store 4 converted values
endif
      mov	ebx, outloopcnt	; get outer loop count
    dec	ebx					; decrement outer loop count
      jnz	Outlp			; if more to do loop

; clean out local variables on stack
    pop     ecx
      pop   eax
    pop     ecx
      pop   eax
	pop		ecx

;clear special seg registers, restore stack, pop saved registers
ifndef WIN32
    xor     ecx, ecx
    mov     es, cx
    mov     fs, cx
endif

    pop     esi
      pop   edi
    pop     ebp

ifdef WIN32
    ret
else
    db      066h
    retf
endif

_Convert_Y_8to7_Bit endp


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dxmidct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    Copyright (c) 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/
;/* *************************************************************************
;** $Header:   S:\h26x\src\dec\dxmidct.asv   1.5   09 Jul 1996 16:51:26   AGUPTA2  $
;** $Log:   S:\h26x\src\dec\dxmidct.asv  $
;// 
;//    Rev 1.5   09 Jul 1996 16:51:26   AGUPTA2
;// IDCT now expects actual number of coeffs.
;// 
;//    Rev 1.4   08 Jul 1996 11:42:50   AGUPTA2
;// Fixed the accuracy problem where a shift was in the wrong place.
;// 
;//    Rev 1.3   30 May 1996 12:25:02   AGUPTA2
;// Fixed the overflow problem in computing u0-u3 in first four columns.
;// 
;//    Rev 1.2   09 Apr 1996 09:42:08   agupta2
;// Code to clear IDCT buffer moved to MMX_BlockCopy and MMX_BlockMove.
;// 
;//    Rev 1.1   22 Mar 1996 10:17:26   agupta2
;// Initial revision of MMX version of IDCT.
;// 
;//    Rev 1.0   14 Mar 1996 14:38:02   AGUPTA2
;// Initial revision.
;** *************************************************************************
;*/
.586
.model flat
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
;
;Constants CONSTBITS, BETA1, NEGBETA2, BETA3, BETA4, and BETA5 are used in the 
;IDCT.  All *BETA* constants are represented in CONSTBITS fraction bits.  Their
;floating-point values are:
;  BETA1 = 1.414213562
;  BETA2 = 2.613125930
;  BETA3 = 1.414213562
;  BETA4 = 1.082392200
;  BETA5 = 0.765366865
;Thus scaled integral value of BETA1 is computed as:
; BETA1 = ROUND(1.414213562*2^13) = 02D41H
;
CONSTBITS = 13
ALIGN 8
BETA1 LABEL DWORD
BETA3 LABEL DWORD
  DWORD 02D410000H, 02D410000H
ALIGN 8
NEGBETA2 LABEL DWORD
  DWORD 0AC610000H, 0AC610000H
ALIGN 8
BETA4 LABEL DWORD
  DWORD 022A30000H, 022A30000H
ALIGN 8
BETA5 LABEL DWORD
  DWORD 0187E0000H, 0187E0000H
ALIGN 8
CONSTBITS_P_1_RND LABEL DWORD
  DWORD 02000H, 02000H
ALIGN 8
CONSTBITS_RND LABEL DWORD
  DWORD 01000H, 01000H
ALIGN 8
ONE  LABEL DWORD
  DWORD 000010001H, 000010001H
MMXDATA1 ENDS

MMXCODE1 SEGMENT
;
;
;
@MMX_DecodeBlock_IDCT@12 PROC
;  Parameters:
;    pIQ_INDEX:  DWORD PTR (in ecx)
;      Pointer to an array of coeff. structures; each structure consists of 
;      DWORD of inverse quantized and scaled coeff. and a DWORD of its index.
;    CountCoeff: DWORD (in edx)
;      Number of coefficients <= 64.
;    pBuf:       WORD PTR (at <[esp+4]> at the entry of this routine
;      Output area for the IDCT; an 8X8 matrix of WORD values with 6 frac. bits
;  Algorithm:
;    It uses scaled IDCT algorithm credited to Arai, Agui, and Nakajima (AAN).
;    High-level steps are:
;      1) Decode pIQ_INDEX array and populate the output buffer
;      2) IDCT and write to output buffer
;  Note:
;    If called from a C function, this routine must be declared as:
;    extern "C" void _fastcall MMX_DecodeBlock_IDCT(...)
;
  LocalFrameSize = 24

  Tu7      textequ <[esp+0]>
  Tv5      textequ <[esp+8]>
  StashESP textequ <[esp+16]>

  push      esi
   push     edi
  mov       edi, esp
   sub      esp, LocalFrameSize
  and       esp, 0FFFFFFF8H                ;Align at 8-byte boundary
   pxor     mm0, mm0
  mov       StashESP, edi
   mov      edi, DWORD PTR [edi+12]        ;pBuf
  add       edi, 64                        ;pBuf+64
   xor      eax, eax

  ;
  ;  Decode coefficients and place them in the output buffer
  ;    ecx: pIQ_INDEX
  ;    edx: No_Coeff
  ;    edi: pBuf+64
  ;    eax, esi: available
  ;
decode_coeff:
  mov       esi, [ecx+edx*8-4]              ;Index
   mov      eax, [ecx+edx*8-8]              ;Inverse quantized scaled coeff
  mov       WORD PTR [edi+esi*2-64], ax     ;
   dec      edx
  jnz       decode_coeff

IDCT_Start:

cols_0_3:
  CLINE0 = 0  - 64
  CLINE1 = 16 - 64
  CLINE2 = 32 - 64
  CLINE3 = 48 - 64
  CLINE4 = 64 - 64
  CLINE5 = 80 - 64
  CLINE6 = 96 - 64
  CLINE7 = 112- 64

   pxor      mm4, mm4                        ;
  movq       mm0, [edi+CLINE5]               ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+CLINE1]               ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+CLINE3]               ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+CLINE7]               ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_P_1_RND          ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_P_1_RND          ;s4h rounded
   psrad     mm4, CONSTBITS+1                ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS+1                ;s4h rounded descaled
  paddd      mm6, CONSTBITS_P_1_RND          ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_P_1_RND          ;s6h rounded
   psrad     mm6, CONSTBITS+1                ;s6l rounded descaled
  movq       mm0, [edi+CLINE1]               ;
   psrad     mm7, CONSTBITS+1                ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+CLINE7]               ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+CLINE3]               ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+CLINE5]               ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   psraw     mm7, 1                          ;q5>>1
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   psraw     mm2, 1                          ;q7>>1
  movq       mm0, [edi+CLINE2]
   paddw     mm7, mm2                        ;r7=s7=u7
  paddd      mm5, CONSTBITS_P_1_RND          ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_P_1_RND          ;s5h rounded
   psrad     mm5, CONSTBITS+1                ;s5l rounded descaled
  psubw      mm0, [edi+CLINE6]               ;r2
   psrad     mm3, CONSTBITS+1                ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  movq       Tu7, mm7                        ;Save u7
   pxor      mm7, mm7
  movq       mm2, [edi+CLINE0]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+CLINE2]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=u7
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+CLINE6]               ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+CLINE4]               ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  psraw      mm0, 1                          ;t3>>1
   ;
  psraw      mm2, 1                          ;t1>>1
   ;
  psraw      mm1, 1                          ;t2>>1
   ;
  paddw      mm3, [edi+CLINE4]               ;t0
   movq      mm7, mm0                        ;t3>>1 copy
  psraw      mm3, 1                          ;t0>>1
   ;
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
;  psraw      mm3, 1                          ;u3>>1
   movq      mm7, mm1                        ;t2
  paddw      mm1, mm2                        ;u1=t2+t1
   psubw     mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
;  psraw      mm2, 1                          ;u2>>1
   movq      mm7, mm3                        ;u3>>1
  psubw      mm3, mm4                        ;v3=u3-(-u4)
   paddw     mm4, mm7                        ;v4=-u4+u3
;  psraw      mm1, 1                          ;u1>>1
   movq      mm7, mm2                        ;u2>>1
;  psraw      mm0, 1                          ;u0>>1
   psubw     mm2, mm5                        ;v5=u2-u5
  paddw      mm5, mm7                        ;v2=u5+u2
   movq      mm7, mm1                        ;u1>>1
  psubw      mm1, mm6                        ;v6=u1-u6
   paddw     mm6, mm7                        ;v1=u6+u1
  movq       Tv5, mm2                        ;Save v5
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;v0
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;v7
   punpckldq mm7, mm5                        ;T1
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+CLINE2], mm7               ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+CLINE3], mm6               ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+CLINE0], mm3               ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+CLINE1], mm5               ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+CLINE6], mm4               ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+CLINE7], mm2               ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+CLINE5], mm1               ;T2
   ;                                         ;cols 4-7
  movq       [edi+CLINE4], mm7               ;T2
   ;                                         ;cols 4-7
cols_4_7:
; Add 8 to CLINE offsets
   pxor      mm4, mm4                        ;
  movq       mm0, [edi+CLINE5+8]             ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+CLINE1+8]             ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+CLINE3+8]             ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+CLINE7+8]             ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_RND              ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_RND              ;s4h rounded
   psrad     mm4, CONSTBITS                  ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS                  ;s4h rounded descaled
  paddd      mm6, CONSTBITS_RND              ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_RND              ;s6h rounded
   psrad     mm6, CONSTBITS                  ;s6l rounded descaled
  movq       mm0, [edi+CLINE1+8]             ;
   psrad     mm7, CONSTBITS                  ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+CLINE7+8]             ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+CLINE3+8]             ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+CLINE5+8]             ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   ;TODO
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   ;TODO
  movq       mm0, [edi+CLINE2+8]
   paddw     mm7, mm2                        ;r7=s7=u7
  paddd      mm5, CONSTBITS_RND              ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_RND              ;s5h rounded
   psrad     mm5, CONSTBITS                  ;s5l rounded descaled
  psubw      mm0, [edi+CLINE6+8]             ;r2
   psrad     mm3, CONSTBITS                  ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  movq       Tu7, mm7                        ;Save u7
   pxor      mm7, mm7
  movq       mm2, [edi+CLINE0+8]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+CLINE2+8]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=u7
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+CLINE6+8]             ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+CLINE4+8]             ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  paddw      mm3, [edi+CLINE4+8]             ;t0
   movq      mm7, mm0                        ;t3
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
  movq       mm7, mm1                        ;t2
   paddw     mm1, mm2                        ;u1=t2+t1
  psubw      mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
  
   movq      mm7, mm3                        ;
  psubw      mm3, mm4                        ;u3-(-u4)
   paddw     mm4, mm7                        ;-u4+u3
  psraw      mm3, 1                          ;v3
   movq      mm7, mm2                        ;
  psraw      mm4, 1                          ;v4
   psubw     mm2, mm5                        ;u2-u5
  psraw      mm2, 1                          ;v5
   paddw     mm5, mm7                        ;u5+u2
  psraw      mm5, 1                          ;v2
   movq      mm7, mm1                        ;
  psubw      mm1, mm6                        ;u1-u6
   paddw     mm6, mm7                        ;u6+u1
  movq       Tv5, mm2                        ;Save v5
   psraw     mm1, 1                          ;v6
  psraw      mm6, 1                          ;v1
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;
   ;TODO
  psraw      mm7, 1                          ;v0
   ;TODO
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;
   punpckldq mm7, mm5                        ;T1
  psraw      mm0, 1                          ;v7
   ;TODO
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+CLINE2+8], mm7             ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+CLINE3+8], mm6             ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+CLINE0+8], mm3             ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+CLINE1+8], mm5             ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+CLINE6+8], mm4             ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+CLINE7+8], mm2             ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+CLINE5+8], mm1             ;T2
   ;                                         ;cols 4-7
  movq       [edi+CLINE4+8], mm7             ;T2
   ;                                         ;cols 4-7
rows_0_3:

RLINE0 = 0  - 64
RLINE1 = 16 - 64
RLINE2 = 32 - 64
RLINE3 = 48 - 64
RLINE4 = 8  - 64
RLINE5 = 24 - 64
RLINE6 = 40 - 64
RLINE7 = 56 - 64
   pxor      mm4, mm4                        ;
  movq       mm0, [edi+RLINE5]               ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+RLINE1]               ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+RLINE3]               ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+RLINE7]               ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_P_1_RND          ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_P_1_RND          ;s4h rounded
   psrad     mm4, CONSTBITS+1                ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS+1                ;s4h rounded descaled
  paddd      mm6, CONSTBITS_P_1_RND          ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_P_1_RND          ;s6h rounded
   psrad     mm6, CONSTBITS+1                ;s6l rounded descaled
  movq       mm0, [edi+RLINE1]               ;
   psrad     mm7, CONSTBITS+1                ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+RLINE7]               ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+RLINE3]               ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+RLINE5]               ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   paddw     mm7, mm2                        ;r7=q5+q7
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   ;TODO
  paddw      mm7, ONE                        ;
   ;TODO
  movq       mm0, [edi+RLINE2]
   psraw     mm7, 1                          ;s7
  paddd      mm5, CONSTBITS_P_1_RND          ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_P_1_RND          ;s5h rounded
   psrad     mm5, CONSTBITS+1                ;s5l rounded descaled
  psubw      mm0, [edi+RLINE6]               ;r2
   psrad     mm3, CONSTBITS+1                ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  psllw      mm7, 1                          ;u7<<1
   ;
  movq       Tu7, mm7                        ;Save u7<<1
   pxor      mm7, mm7
  movq       mm2, [edi+RLINE0]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+RLINE2]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+RLINE6]               ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+RLINE4]               ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  paddw      mm3, [edi+RLINE4]               ;t0
   movq      mm7, mm0                        ;t3
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
  ;TODO
   movq      mm7, mm1                        ;t2
  paddw      mm1, mm2                        ;u1=t2+t1
   psubw     mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
  psllw      mm4, 1                          ;-u4<<1
   movq      mm7, mm3                        ;
  psubw      mm3, mm4                        ;v3=u3-(-u4<<1)
   paddw     mm4, mm7                        ;v4=(-u4<<1)+u3
  psllw      mm5, 1                          ;u5<<1
   movq      mm7, mm2                        ;
  psubw      mm2, mm5                        ;v5=u2-(u5<<1)
   paddw     mm5, mm7                        ;v2=(u5<<1)+u2
  psllw      mm6, 1                          ;u6<<1
   movq      mm7, mm1                        ;
  psubw      mm1, mm6                        ;v6=u1-(u6<<1)
   paddw     mm6, mm7                        ;v1=(u6<<1)+u1
  movq       Tv5, mm2                        ;Save v5
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;v0=u0+(u7<<1)
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;v7=u0-(u7<<1)
   punpckldq mm7, mm5                        ;T1
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+RLINE2], mm7               ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+RLINE3], mm6               ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+RLINE0], mm3               ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+RLINE1], mm5               ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+RLINE6], mm4               ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+RLINE7], mm2               ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+RLINE5], mm1               ;T2
   ;                                         ;cols 4-7
  movq       [edi+RLINE4], mm7               ;T2
   ;                                         ;cols 4-7
rows_4_7:
; Add 64 to RLINE offsets
   pxor      mm4, mm4                        ;
  movq       mm0, [edi+RLINE5+64]            ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+RLINE1+64]            ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+RLINE3+64]            ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+RLINE7+64]            ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_P_1_RND          ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_P_1_RND          ;s4h rounded
   psrad     mm4, CONSTBITS+1                ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS+1                ;s4h rounded descaled
  paddd      mm6, CONSTBITS_P_1_RND          ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_P_1_RND          ;s6h rounded
   psrad     mm6, CONSTBITS+1                ;s6l rounded descaled
  movq       mm0, [edi+RLINE1+64]            ;
   psrad     mm7, CONSTBITS+1                ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+RLINE7+64]            ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+RLINE3+64]            ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+RLINE5+64]            ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   paddw     mm7, mm2                        ;r7=q5+q7
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   ;TODO
  paddw      mm7, ONE                        ;
   ;TODO
  movq       mm0, [edi+RLINE2+64]
   psraw     mm7, 1                          ;s7
  paddd      mm5, CONSTBITS_P_1_RND          ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_P_1_RND          ;s5h rounded
   psrad     mm5, CONSTBITS+1                ;s5l rounded descaled
  psubw      mm0, [edi+RLINE6+64]            ;r2
   psrad     mm3, CONSTBITS+1                ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  psllw      mm7, 1                          ;u7<<1
   ;
  movq       Tu7, mm7                        ;Save u7<<1
   pxor      mm7, mm7
  movq       mm2, [edi+RLINE0+64]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+RLINE2+64]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+RLINE6+64]               ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+RLINE4+64]            ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  paddw      mm3, [edi+RLINE4+64]            ;t0
   movq      mm7, mm0                        ;t3
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
  ;TODO
   movq      mm7, mm1                        ;t2
  paddw      mm1, mm2                        ;u1=t2+t1
   psubw     mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
  psllw      mm4, 1                          ;-u4<<1
   movq      mm7, mm3                        ;
  psubw      mm3, mm4                        ;v3=u3-(-u4<<1)
   paddw     mm4, mm7                        ;v4=(-u4<<1)+u3
  psllw      mm5, 1                          ;u5<<1
   movq      mm7, mm2                        ;
  psubw      mm2, mm5                        ;v5=u2-(u5<<1)
   paddw     mm5, mm7                        ;v2=(u5<<1)+u2
  psllw      mm6, 1                          ;u6<<1
   movq      mm7, mm1                        ;
  psubw      mm1, mm6                        ;v6=u1-(u6<<1)
   paddw     mm6, mm7                        ;v1=(u6<<1)+u1
  movq       Tv5, mm2                        ;Save v5
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;v0=u0+(u7<<1)
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;v7=u0-(u7<<1)
   punpckldq mm7, mm5                        ;T1
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+RLINE2+64], mm7            ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+RLINE3+64], mm6            ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+RLINE0+64], mm3            ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+RLINE1+64], mm5            ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+RLINE6+64], mm4            ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+RLINE7+64], mm2            ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+RLINE5+64], mm1            ;T2
   ;                                         ;cols 4-7
  movq       [edi+RLINE4+64], mm7            ;T2
   ;                                         ;cols 4-7
IDCT_Done:
  mov        esp, StashESP
  pop        edi
  pop        esi
  ret        4

@MMX_DecodeBlock_IDCT@12 endp

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e3msig.asm ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e3msig.asv   1.2   04 Oct 1996 08:47:58   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\e3msig.asv  $
;// 
;//    Rev 1.2   04 Oct 1996 08:47:58   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.1   08 Jul 1996 16:55:42   BNICKERS
;// Fix register initialization
;// 
;//    Rev 1.0   25 Jun 1996 14:24:54   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; MMXMotionEstimationSignaturePrep -- This function pre-computes the signature
;                                     inputs for the reference frame.  It is
;                                     used only by MMX ME, and only in AP mode.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510
OPTION CASEMAP:NONE

include iammx.inc
include e3inst.inc

.xlist
include memmodel.inc
.list

;=============================================================================

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

MMxMESignaturePrep  proc C APrev:   DWORD,
ASig:    DWORD,
AFrmWd:  DWORD,
AFrmHt:  DWORD

RegStoSize = 16

; Arguments:

PreviousFrameBaseAddress     = RegStoSize +  4
SignatureFrameBaseAddress    = RegStoSize +  8
FrameWidth                   = RegStoSize + 12
FrameHeight                  = RegStoSize + 16
EndOfArgList                 = RegStoSize + 20

  push       esi
  push       edi
  push       ebp
  push       ebx

; ebp -- PITCH
; esi -- Cursor over reference frame.
; edi -- Cursor over frame of signature sums.
; edx -- Skip distance.
; ebx -- Outer loop counter.
; cl  -- Initial value for inner loop counter.
; al  -- Inner loop counter.
; ch  -- Scratch.
; ah  -- Scratch.

  mov        esi,[esp+PreviousFrameBaseAddress]
   mov       edi,[esp+SignatureFrameBaseAddress]
  mov        ebx,[esp+FrameHeight]
   mov       eax,[esp+FrameWidth]

  mov        edx,PITCH*4-32
   mov       ebp,PITCH
  sub        edx,eax           ; Distance from end of one row to start of next.
   add       eax,32            ; Add the macroblocks off left and right edges.
  shr        eax,4             ; Number of macroblocks in row.
   sub       esi,16            ; Start at macroblock off left edge.
  mov        cl,al             ; To re-init inner loop counter.
   sub       edi,16            ; Start at macroblock off left edge.

  pxor       mm5,mm5
   pcmpeqb   mm0,mm0
  pcmpeqb    mm4,mm4
   psrlw     mm0,8                 ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  pxor       mm6,mm6
   psrlw     mm4,15                ; W:<0x0001  0x0001  0x0001  0x0001>
  movq       mm2,[esi]             ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   movq      mm1,mm0               ; W:<   00FF    00FF    00FF    00FF>
  movq       mm3,[esi+8]
   pand      mm0,mm2               ; W:<P06 P04 P02 P00>
  pxor       mm7,mm7

@@:

  pand       mm1,mm3
   psllw     mm0,2                 ; W:<P06*4 P04*4 P02*4 P00*4>
  mov        ah,[edi-PITCH*12]
   psrlw     mm2,7                 ; W:<P07*2 P05*2 P03*2 P01*2>
  movq       [edi-PITCH*12],mm0    ; Save W:<P06*4 P04*4 P02*4 P00*4>
   pmaddwd   mm2,mm4               ; D:<(P07+P05)*2 (P03+P01)*2>
  mov        ch,[edi-PITCH*8+16]
   mov       ah,[edi-PITCH*4]   
  movq       [edi-PITCH*8],mm0     ; Save W:<P06*4 P04*4 P02*4 P00*4>
   psllw     mm1,2
  mov        ch,[edi+16]
   psrlw     mm3,7                 ; W:<P07*2 P05*2 P03*2 P01*2>
  movq       [edi-PITCH*4],mm0     ; Save W:<P06*4 P04*4 P02*4 P00*4>
   pmaddwd   mm3,mm4
  movq       [edi],mm0             ; Save W:<P06*4 P04*4 P02*4 P00*4>
   psllq     mm0,2                 ; W:<P06*16 P04*16 P02*16 P00*16>
  mov        ah,[edi-PITCH*10-16]
   mov       ch,[edi-PITCH*16]
  movq       [edi-PITCH*16],mm0    ; Save W:<P06*16 P04*16 P02*16 P00*16>
   packssdw  mm2,mm2               ; [0:31] W:<(P07+P05)*2 (P03+P01)*2>
  movq       [edi-PITCH*12+8],mm1
   punpcklwd mm2,mm2               ; W:<(P07+P05)*2 (P07+P05)*2 (P03+P01)*2 ...>
  movq       [edi-PITCH*8+8],mm1
   psubw     mm2,mm5           ; Subtract sum of pels 15, 13, 11, and 9 to left.
  movq       [edi-PITCH*4+8],mm1
   paddw     mm7,mm2           ; Low DWORD: W:<sum(P0*)*2 sum(P0*)*2>, where
   ;                           ; "*" is odd columns from -11 thru +3.
  movq       [edi+8],mm1
   paddw     mm5,mm2           ; Save W:<(P27+P37+P25+P35) (P07+P17+P05+P15)...>
  mov        ah,[edi-PITCH*14-32]
  mov        ah,[edi-PITCH*6-32]
   mov       ch,[edi-PITCH*2-16]
  movdf      [edi-PITCH*14-12],mm7; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
  movdf      [edi-PITCH*10-12],mm7; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
   psrlq     mm2,32            ; Position 7, 5, and negative of 9, 11 to left.
  movdf      [edi-PITCH*6-12],mm7 ; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
   paddw     mm2,mm7           ; Low DWORD: W:<sum(P0*)*2 sum(P0*)*2>, where
   ;                           ; "*" is odd columns from -7 thru +7.
  movdf      [edi-PITCH*2-12],mm7 ; Save DWORD: W:<sum(P0*)*2 sum (P0*)*2>
   packssdw  mm3,mm3
  movdf      [edi-PITCH*10-8],mm2
   punpcklwd mm3,mm3
  movdf      [edi-PITCH*6-8],mm2
   psubw     mm3,mm6
  movdf      [edi-PITCH*2-8],mm2
   paddw     mm2,mm3
  add        esi,16            ; Advance input cursor.
   dec       al
  movdf      [edi-PITCH*14-4],mm2
  movdf      [edi-PITCH*10-4],mm2
   paddw     mm6,mm3
  movdf      [edi-PITCH*6-4],mm2
   psrlq     mm3,32
  movdf      [edi-PITCH*2-4],mm2
   paddw     mm3,mm2
  movq       mm2,[esi]             ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   movq      mm7,mm3
  movq       mm3,[esi+8]
   psllq     mm1,2
  movdf      [edi-PITCH*10],mm7
   pcmpeqb   mm0,mm0
  movq       [edi-PITCH*16+8],mm1
   psrlw     mm0,8
  movdf      [edi-PITCH*6],mm7
   movq      mm1,mm0
  movdf      [edi-PITCH*2],mm7
   pand      mm0,mm2
  lea        edi,[edi+16]      ; Advance output cursor.
   jne       @b


  lea        esi,[esi+edx-PITCH*4] ; Get back to start of line 0.
   lea       edi,[edi+edx-PITCH*4] ; Get back to start of line 0.
  pxor       mm7,mm7 
   add       ebx,16            ; Do 4 extra sets of 4 lines at bottom.
  mov        al,cl

Next4LinesRefQuickSig:

  pxor       mm5,mm5
   pcmpeqb   mm0,mm0
  movq       mm3,[esi+ebp*2]   ; B:<P27 P26 P25 P24 P23 P22 P21 P20>
   psrlw     mm0,8             ; W:<0x00FF  0x00FF  0x00FF  0x00FF>
  paddb      mm3,[esi+PITCH*3] ; B:<P27+P37 P26+P36 P25+P35 P24+P34 ...>
   pcmpeqb   mm4,mm4
  pxor       mm6,mm6
   psrlw     mm4,15            ; W:<0x0001  0x0001  0x0001  0x0001>

@@:

  movq       mm2,[esi]         ; B:<P07 P06 P05 P04 P03 P02 P01 P00>
   movq      mm1,mm3           ; B:<P27+P37 P26+P36 P25+P35 P24+P34 ...>
  paddb      mm2,[esi+ebp*1]   ; B:<P07+P17 P06+P16 P05+P15 P04+P14 ...>
   psrlw     mm3,8             ; W:<P27+P37 P25+P35 P23+P33 P21+P31>
  pmaddwd    mm3,mm4           ; D:<P27+P37+P25+P35 P23+P33+P21+P31>
   pand      mm1,mm0           ; W:<P26+P36 P24+P34 P22+P32 P20+P30>
  pand       mm0,mm2           ; W:<P06+P16 P04+P14 P02+P12 P00+P10>
   psrlw     mm2,8             ; W:<P07+P17 P05+P15 P03+P13 P01+P11>
  pmaddwd    mm2,mm4           ; D:<P07+P17+P05+P15 P03+P13+P01+P11>
   paddw     mm1,mm0           ; W:<(P06+P16+P26+P36) (P04+P14+P24+P34) ...>
  mov        ah,[edi+ebp*2-16] ; Initiate cache line load.
   pslld     mm3,16            ; D:<(P27+P37+P25+P35)<<16 (P23+P33+P21+P31)<<16>
  movq       [edi+ebp*4],mm1   ; Save W:<(P06+P16+P26+P36) ...>
   pcmpeqb   mm0,mm0
  paddw      mm1,[edi-PITCH*16]; W:<Sum(P*6) Sum(P*4) Sum(P*2) Sum(P*0)>, where
  ;                            ;   "*" is the 20 lines P-16 thru P3
   por       mm2,mm3           ; W:<(P27+P37+P25+P35) (P07+P17+P05+P15)
   ;                           ;    (P23+P33+P21+P31) (P03+P13+P01+P11)>
  psubw      mm1,[edi-PITCH*12]; W:<Sum(P*6) Sum(P*4) Sum(P*2) Sum(P*0)>, where
   ;                           ;   "*" is the 16 lines P-12 thru P3
   psubw     mm2,mm5           ; Subtract sum of pels 15, 13, 11, and 9 to left.
  movq       mm3,[esi+ebp*2+8]
   paddw     mm7,mm2           ; Low DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)> where
   ;                           ; "*" is odd columns from -11 thru +3.
  movq       [edi-PITCH*12],mm1; Save W:<P*6 P*4 P*2 P*0> where * is 16 rows.
   paddw     mm5,mm2           ; Save W:<(P27+P37+P25+P35) (P07+P17+P05+P15)...>
  movdf      [edi+ebp*2-12],mm7; Save DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)>
   psrlq     mm2,32            ; Position 7, 5, and negative of 9, 11 to left.
  paddb      mm3,[esi+PITCH*3+8]
   paddw     mm7,mm2           ; Low DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)> where
   ;                           ; "*" is odd columns from -7 thru +7.
  movq       mm2,[esi+8]
   psrlw     mm0,8
  movdf      [edi+ebp*2-8],mm7 ; Save DWORD: W:<sum(P2*+P3*) sum (P0*+P1*)>
   movq      mm1,mm3
  paddb      mm2,[esi+ebp*1+8]
   psrlw     mm3,8
  pmaddwd    mm3,mm4
   pand      mm1,mm0
  pand       mm0,mm2
   psrlw     mm2,8
  pmaddwd    mm2,mm4
   paddw     mm1,mm0
  mov        ch,[edi+ebp*4+16] ; Initiate cache line load.
   pslld     mm3,16
  movq       [edi+ebp*4+8],mm1
   pcmpeqb   mm0,mm0
  paddw      mm1,[edi-PITCH*16+8]
   por       mm2,mm3
  psubw      mm1,[edi-PITCH*12+8]
   psubw     mm2,mm6
  movq       mm3,[esi+ebp*2+16]
   paddw     mm7,mm2
  movq       [edi-PITCH*12+8],mm1
   paddw     mm6,mm2
  movdf      [edi+ebp*2-4],mm7
   psrlq     mm2,32
  paddb      mm3,[esi+PITCH*3+16]
   paddw     mm7,mm2
  add        esi,16            ; Advance input cursor.
   dec       al
  movdf      [edi+ebp*2],mm7
   psrlw     mm0,8
  lea        edi,[edi+16]      ; Advance output cursor.
   jne       @b

  add        esi,edx
   add       edi,edx
  mov        al,cl
   sub       ebx,4
  pxor       mm7,mm7 
   jne       Next4LinesRefQuickSig

  emms
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  rturn

MMxMESignaturePrep endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\e35bme.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\e35bme.asv   1.10   29 May 1996 15:37:38   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\e35bme.asv  $
;// 
;//    Rev 1.10   29 May 1996 15:37:38   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.9   14 May 1996 12:18:18   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.8   09 Jan 1996 16:14:46   BNICKERS
;// Avoid generating delta MV's that make B frame MV's out of range.
;// 
;//    Rev 1.7   27 Dec 1995 15:32:34   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////
;
; BFrameMotionEstimation -- This function performs B frame motion estimation for the macroblocks identified in the
;                           input list.  This is only applicable for H263.  This version is tuned for best performance
;                           on the Pentium Microprocessor.
;
;                           This function works correctly only if Unrestricted Motion Vectors is enabled.  It is not
;                           possible to select full pel resolution only;  half pel resolution is always selected.
;
; Input Arguments:
;
;   MBlockActionStream
;
;     The list of macroblocks for which we need to perform motion estimation.
;
;     Upon input, the following fields must be defined:
;
;       CodedBlocks -- Bit 6 must be set for the last macroblock to be processed.
;
;       BlkOffset -- must be defined for each of the blocks in the macroblocks.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.
;
;   PreviousFrameBaseAddress -- Address of upper left viewable pel in the Y plane of the previous P frame.  Whether this
;                               is the reconstructed previous frame, or the original, is up to the caller to decide.
;
;   FutureFrameBaseAddress -- Address of upper left viewable pel in the Y plane of the future P frame.  Whether this
;                             is the reconstructed previous frame, or the original, is up to the caller to decide.
;
;   WeightForwardMotion -- Array of 64 signed chars, each element I equal to ((TRb * (I-32)) / TRd).  (See H263 spec.)
;
;   WeightBackwardMotion -- Array of 64 signed chars, each element I equal to ((TRb - TRd) * (I-32) / TRd).  (See spec.)
;
;   ZeroVectorThreshold -- If the SWDB for a macroblock is less than this threshold, we do not bother searching for a
;                          better motion vector.  Compute as follows, where D is the average tolerable pel difference
;                          to satisfy this threshold.  (Initial recommendation:  D=2  ==> ZVT=384)
;                             ZVT = (128 * ((int)((D**1.6)+.5)))
;
;   NonZeroDifferential -- After searching for the best motion vector (or individual block motion vectors, if enabled),
;                          if the macroblock's SWDB is not better than it was for the zero vector -- not better by at
;                          least this amount -- then we revert to the zero vector.  We are comparing two macroblock
;                          SWDs, both calculated as follows:   (Initial recommendation:	 NZD=128)
;                            For each of 128 match points, where D is its Abs Diff, accumulate ((int)(M**1.6)+.5)))
;
;   EmptyThreshold -- If the SWD for a block is less than this, the block is forced empty.  Compute as follows, where D
;                     is the average tolerable pel diff to satisfy threshold.  (Initial recommendation:  D=3 ==> ET=96)
;                        ET = (32 * ((int)((D**1.6)+.5)))
;
; Output Arguments
;
;   MBlockActionStream
;
;     These fields are defined as follows upon return:
;
;       BHMV and BVMV -- The horizontal and vertical motion vectors,  in units of a half pel.  These values are intended
;                        for coding in the macroblock layer.
;
;                  If Horizontal MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+1.
;
;                  If Vertical MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+PITCH.
;
;                  If both MVs indicate half pel positions, the prediction for the upper left pel of the block is the
;                  average of the pels at PastRef, PastRef+1, PastRef+PITCH, and PastRef+PITCH+1.
;
;       BestHMVf, BestVMVf, BestHMVb, BestVMVb -- Motion vector components, as described in H263 spec.  They are biased
;                                                 by 060H.  Only defined for luma blocks.  Caller must define for
;                                                 chroma blocks.
;
;       CandidateHMVf, CandidateVMVf, CandidateHMVb, CandidateVMVb -- Scratch space for this function.
;
;       CodedBlocksB -- Bits 4 and 5 are turned on, indicating that the U and V blocks should be processed.  (If the
;                       FDCT function finds them to quantize to empty, it will mark them as empty.)
;
;                       Bits 0 thru 3 are cleared for each of blocks 1 thru 4 that BFrameMotionEstimation forces empty;
;                       they are set otherwise.
;
;                       Bits 6 and 7 are left unchanged.
;                      
;       SWDB -- Set to the sum of the SWDBs for the four luma blocks in the macroblock.  The SWD for any block that is
;               forced empty, is NOT included in the sum.
;
;   InterSWDTotal  -- The sum of the block SWDBs for all Intercoded macroblocks.  None of the blocks forced empty are
;                     included in this.
;
;   InterSWDBlocks -- The number of blocks that make up the InterSWDTotal.
;
;
; Other assumptions:
;
;   For performance reasons, it is assumed that the current and previous frame are 32-byte aligned, and the pitch is a
;   constant 384.  Moreover, the current and previous frames must be out of phase by 2K bytes, i.e.  must be an odd
;   multiple of 2K bytes apart.  This will assure best utilization of the on-chip cache.
;
; Many of the techniques described in MotionEstimation are used here.  It is wise to study that module before trying
;to understand this one.
;
; Data structures used for bi-directional motion search:
;
;  Target Macroblock:
;
;     The target macroblock is copied to the stack frame so that esp can be used as an induction variable for the block:
;
;     esp+   0  AAAABBBB        AAAABBBB        AAAABBBB        AAAABBBB
;     esp+  64  CCCCDDDDEEEEFFFFCCCCDDDDEEEEFFFFCCCCDDDDEEEEFFFFCCCCDDDDEEEEFFFF
;     esp+ 128  LLLLDDDDLLLLLLLLLLLLLLLLLLLLLLLL
;     esp+ 160  +------++------++------++------++------++------++------++------+
;     esp+ 224  | Blk1 || Blk1 || Blk2 || Blk2 || Blk3 || Blk3 || Blk4 || Blk4 |
;     esp+ 288  |Ln 0-3||Ln 4-7||Ln 0-3||Ln 4-7||Ln 0-3||Ln 4-7||Ln 0-3||Ln 4-7|
;     esp+ 352  +------++------++------++------++------++------++------++------+
;     esp+ 416
;
;     AAAA is the address of the Future Reference Block to be used.
;     BBBB is the address of the Past Reference Block to be used.
;         AAAA, BBBB, and the next 8 bytes are overwritten by the offset to apply when interpolating future ref block or
;         past ref block.
;     CCCC is the accumulated SWD for the current candidate motion vector.
;     DDDD is the accumulated SWD for the best motion vector so far.
;          One extra DDDD occupies esp+132.
;     EEEE is the address at which to transfer control after calculating SWD.
;     FFFF is the accumulated SWD for the zero motion vector.
;     LLLL is space for local variables.
;
;   Future reference:
;
;     For each macroblock, the corresponding macroblock from the future frame is copied into the following reference
;     area, wherein all the X's are bytes initialized to 255.  When the projection of the B-frame's future motion
;     vector component falls on a byte valued at 255, we know that it is outside the future macroblock, and thus this
;     is a pel that is only predicted from the past reference.
;
;     esp+ 704    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  \
;     esp+ 744    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \
;     esp+ 784    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    \ 
;     esp+ 824    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     \
;     esp+ 864    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \
;     esp+ 904    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       > Rarely used
;     esp+ 944    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      /
;     esp+ 984    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     /
;     esp+1024    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    /
;     esp+1064    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   /
;     esp+1104    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  /
;     esp+1144    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1184    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1224    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1264    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1304    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1344    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1384    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1424    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1464    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1504    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1544    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+1584    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+1624    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+1664    XXXXXXXXXXXXXXXXXXXXXXXX|Future||Future|
;     esp+1704    XXXXXXXXXXXXXXXXXXXXXXXX| Ref  || Ref  |
;     esp+1744    XXXXXXXXXXXXXXXXXXXXXXXX| Blk  || Blk  |
;     esp+1784    XXXXXXXXXXXXXXXXXXXXXXXX|  1   ||  2   |
;     esp+1824    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+1864    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+1904    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+1944    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+1984    XXXXXXXXXXXXXXXXXXXXXXXX|Future||Future|
;     esp+2024    XXXXXXXXXXXXXXXXXXXXXXXX| Ref  || Ref  |
;     esp+2064    XXXXXXXXXXXXXXXXXXXXXXXX| Blk  || Blk  |
;     esp+2104    XXXXXXXXXXXXXXXXXXXXXXXX|  3   ||  4   |
;     esp+2144    XXXXXXXXXXXXXXXXXXXXXXXX|      ||      |
;     esp+2184    XXXXXXXXXXXXXXXXXXXXXXXX+------++------+
;     esp+2224    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2264    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2304    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2344    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2384    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2424    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2464    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2504    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2544    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2584    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2624    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;     esp+2664    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  \
;     esp+2704    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \
;     esp+2744    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    \
;     esp+2784    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     \
;     esp+2824    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \
;     esp+2864    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX       > Rarely used
;     esp+2904    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      /
;     esp+2944    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     /
;     esp+2984    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    /
;     esp+3024    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   /
;     esp+3064    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  /
;     esp+3104    XXXXXXXXXXXXXXXXXXXXXXXX________         /
;     esp+3136
;
;  Past Reference:
;
;     The past reference search area is taken directly from the past frame.  It is not necessary to copy any portion
;     of the past frame to a scratch area.
;
;
; Memory layout of the target macroblock, the future reference macroblock, and the full range for the reference area
; (as restricted to +/- 7 in vertical, and +/- 7 (expandable to +/- 15) in horizontal, is as shown here.  Each box
; represents a cache line (32 bytes), increasing incrementally from left to right, and then to the next row (like
; reading a book).  The 128 boxes taken as a whole represent 4Kbytes.  The boxes are populated as follows:
;
;   R -- Data from the past reference area.  Each box contains 23 of the pels belonging to a line of the reference
;   area.  The remaining 7 pels of the line is either in the box to the left (for reference areas used to provide
;   predictions for target macroblocks that begin at an address 0-mod-32), or to the right (for target MBs that begin
;   at an address 16-mod-32).  There are 30 R's corresponding to the 30-line limit on the vertical distance we might
;   search.  The lowercase r's correspond to the lines above and below zero-vertical-motion.
;
;   F -- Data from the future reference area.  Eacg box contains a full line (16 pels) for each of two adjacent
;   macroblocks.  There are 16 F's corresponding to the 16 lines of the macroblocks.
; 
;   T -- Data from the target macroblock.  Each box contains a full line (16 pels) for each of two adjacent
;   macroblocks.  There are 16 C's corresponding to the 16 lines of the macroblocks.
;
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | T |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | r |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | F |   | R |   | F |   | r |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | F |   | R |   |
;      +---+---+---+---+---+---+---+---+
;
; Thus, in a logical sense, the above data fits into one of the 4K data cache pages, leaving the other for all other
; data.  Care has been taken to assure that the tables and the stack space needed by this function fit nicely into
; the other data cache page.    Only the MBlockActionStream remains to conflict with the above data structures.  That
; is both unavoidable, and of minimal consequence.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list
.DATA

LocalStorage LABEL DWORD  ; Local storage goes on the stack at addresses whose lower 12 bits match this address.

DB 544 DUP (?)   ; Low 12 bits match those of heavily used part of stack frame.

SWDState LABEL BYTE  ; State engine rules for finding best motion vector.

; 1st number:  Horizontal Motion displacement to try, in half pel increments.
; 2nd number:  Vertical Motion displacement to try, in half pel increments.
; 3rd number:  Next state to enter if this motion is better than previous best.
; 4th number:  Next state to enter if previous best is still best.

   DB    -2,   0,  8,  4   ;  0 -- ( 0, 0) Try (-2, 0)
   DB     2,   0, 12, 12   ;  4 -- ( 0, 0) Try ( 2, 0)
   DB     4,   0, 12, 12   ;  8 -- (-2, 0) Try ( 2, 0)
   DB     0,  -2, 20, 16   ; 12 -- ( N, 0) Try ( N,-2)  (N = {-2,0,2})
   DB     0,   2, 24, 24   ; 16 -- ( N, 0) Try ( N, 2)
   DB     0,   4, 24, 24   ; 20 -- ( N,-2) Try ( N, 2)

   DB    -1,   0, 32, 28   ; 24
   DB     1,   0, 36, 36   ; 28
   DB     2,   0, 36, 36   ; 32
   DB     0,  -1, 44, 40   ; 36
   DB     0,   1,  0,  0   ; 40
   DB     0,   2,  0,  0   ; 44

   DB    48 DUP (?)        ; Additional space for more states, if needed.

DB 64 DUP (?)   ; Low 12 bits match those of heavily used part of stack frame.

InterpFutureRef LABEL BYTE  ; Map FPEL+FPEL to its average.  If one FPEL is out
                            ; of range (255), map FPEL+FPEL to 255.
CNT = 0
REPEAT 127
  DB CNT,CNT
  CNT = CNT + 1
ENDM
  DB 127
  DB 257 DUP (255)

DB 1472 DUP (?)  ; Low 12 bits match those of heavily used part of stack frame.

Interp2PastAndFutureRef LABEL BYTE  ; Map PPEL+PPEL+FPELavg*2 to 2*average.  If
                                    ; FPELavg out of range, map PPEL+PPEL to
                                    ; -(PPEL+PPEL).
CNT = 0
REPEAT 255
  DB CNT,CNT
  CNT = CNT - 1
ENDM
InterpPastAndFutureRef LABEL BYTE   ; Map PPEL+FPELavg to 2*average.  If
                                    ; FPELavg out of range, map PPEL to
                                    ; 2(PPEL).
CNT = 0
REPEAT 255
  DB CNT
  CNT = CNT + 1
ENDM
CNT = 0
REPEAT 128
  DB CNT
  CNT = CNT + 2
ENDM
  DB ?,?,?
  
  DB 255
WeightedDiff LABEL BYTE  ; Label placed here because negative pel value is
                         ; not sign extended, so we need to subtract 256.
  DB 191 DUP (255)
  DB 255,250,243,237,231,225,219,213,207,201,195,189,184,178,172,167
  DB 162,156,151,146,141,135,130,126,121,116,111,107,102, 97, 93, 89
  DB  84, 80, 76, 72, 68, 64, 61, 57, 53, 50, 46, 43, 40, 37, 34, 31
  DB  28, 25, 22, 20, 18, 15, 13, 11,  9,  7,  6,  4,  3,  2,  1,  0
  DB   0
  DB   0,  1,  2,  3,  4,  6,  7,  9, 11, 13, 15, 18, 20, 22, 25, 28
  DB  31, 34, 37, 40, 43, 46, 50, 53, 57, 61, 64, 68, 72, 76, 80, 84
  DB  89, 93, 97,102,107,111,116,121,126,130,135,141,146,151,156,162
  DB 167,172,178,184,189,195,201,207,213,219,225,231,237,243,250,255
  DB 191 DUP (255)

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

BFRAMEMOTIONESTIMATION  proc C AMBAS:   DWORD,
ATFBA: DWORD,
APFBA: DWORD,
AFFBA: DWORD,
AWFM:  DWORD,
AWBM:  DWORD,
AZVT:  DWORD,
ANZMVD:DWORD,
AEBT:  DWORD,
ASWDT: DWORD,
ASWDB: DWORD

RegisterStorageSize = 16

; Arguments:

MBlockActionStream_arg       = RegisterStorageSize +  4
TargetFrameBaseAddress_arg   = RegisterStorageSize +  8
PreviousFrameBaseAddress_arg = RegisterStorageSize + 12
FutureFrameBaseAddress_arg   = RegisterStorageSize + 16
WeightForwardMotion_arg      = RegisterStorageSize + 20
WeightBackwardMotion_arg     = RegisterStorageSize + 24
ZeroVectorThreshold_arg      = RegisterStorageSize + 28
NonZeroMVDifferential_arg    = RegisterStorageSize + 32
EmptyBlockThreshold_arg      = RegisterStorageSize + 36
InterSWDTotal_arg            = RegisterStorageSize + 40
InterSWDBlocks_arg           = RegisterStorageSize + 44
EndOfArgList                 = RegisterStorageSize + 48

; Locals (on local stack frame)

; 0 thru 415 are Target MV scratch structure, described above, with room for
; 7 DWORDs of local variables.

Block1                 EQU [esp+   0]
Block2                 EQU [esp+  16]
Block3                 EQU [esp+  32]
Block4                 EQU [esp+  48]
BlockN                 EQU [esp+  64]
BlockNM1               EQU [esp+  48]

TargetBlock            EQU 160
FutureRefBlockAddr     EQU   0
PastRefBlockAddr       EQU   4
FutureRefInterpOffset  EQU FutureRefBlockAddr
CandidateSWDAccum      EQU  64
BestSWDAccum           EQU  68
SWD0MVAccum            EQU  72
TransferCase           EQU  76
TPITCH                 EQU  64

; 416 thru 479 and 640 thru 703 for weighting motion vectors.

WeightForwardMotion    EQU [esp+ 416]   ; 32 bytes at 416 for positive MV; 32
                                        ; bytes at 640 for negative MV.
WeightBackwardMotion   EQU [esp+ 448]   ; 32 bytes at 448 for positive MV; 32
                                        ; bytes at 672 for negative MV.

; 480 thru 543 are stack storage for more local variables.
; 128:131, 136:159, and 480:543 are available for local variables.

TargetFrameBaseAddress    EQU [esp+  128]
PreviousFrameBaseAddress  EQU [esp+  136]
FutureFrameBaseAddress    EQU [esp+  140]
MBlockActionStream        EQU [esp+  144]
ZeroVectorThreshold       EQU [esp+  148]
NonZeroMVDifferential     EQU [esp+  152]
EmptyBlockThreshold       EQU [esp+  156]
InterSWDTotal             EQU [esp+  480]
InterSWDBlocks            EQU [esp+  484]
StashESP                  EQU [esp+  488]
PastMBAddr                EQU [esp+  492]
CurrSWDState              EQU [esp+  496]
CandidateMV               EQU [esp+  500]
BestMV                    EQU [esp+  504]
BlkY1_0deltaBiDiMVs       EQU [esp+  508]
BlkY2_0deltaBiDiMVs       EQU [esp+  512]
BlkY3_0deltaBiDiMVs       EQU [esp+  516]
BlkY4_0deltaBiDiMVs       EQU [esp+  520]
FirstTransferCase         EQU [esp+  524]

; 544: 639 is for static data, namely the state engine rules.
; 640 thru 703, as stated above is for weighting motion vectors.

; 704 thru 1215 hit static data structure to interpolate 2 future pels.

; Future Reference Area also starts at 704 on stack, but collision at 704
; thru 1215 will occur very infrequently.  Future Reference Area continues
; thru 3135.  2688 thru 3135 collide with the static data structure to
; interpolate between past and future pels, but that portion of the Future
; Reference Area is rarely accessed.  3136 thru 3583 continue that static
; structure.  3584 thru 4095 have the static structure to look up the
; weighted difference for a target pel and it's prediction.

FutureRefArea             EQU [esp+ 704]
FutureBlock               EQU [esp+1608]
FPITCH                    EQU  40


  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov   esi,esp
   sub  esp,000001000H
  mov   ebx, [esp]
   sub  esp,000001000H
  and   esp,0FFFFF000H
   mov  ebx,OFFSET LocalStorage+63
  and   ebx,000000FC0H
   mov  edx,PD [esi+MBlockActionStream_arg]
  or    esp,ebx
   mov  eax,PD [esi+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,eax
   mov  eax,PD [esi+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,eax
   mov  eax,PD [esi+FutureFrameBaseAddress_arg]
  mov   FutureFrameBaseAddress,eax
   mov  eax,PD [esi+EmptyBlockThreshold_arg]
  mov   EmptyBlockThreshold,eax
   mov  eax,PD [esi+ZeroVectorThreshold_arg]
  mov   ZeroVectorThreshold,eax
   mov  eax,PD [esi+NonZeroMVDifferential_arg]
  mov   NonZeroMVDifferential,eax
   mov  ebx,3116
@@:
  mov   [esp+ebx],0FFFFFFFFH
   sub  ebx,4
  cmp   ebx,688
   jae  @b
  xor   ebx,ebx
   mov  StashESP,esi
  mov   edi,[esi+WeightForwardMotion_arg]
   mov  esi,[esi+WeightBackwardMotion_arg]
  mov   InterSWDBlocks,ebx
   mov  InterSWDTotal,ebx
  mov   eax,[edi]
   mov  ebx,[edi+4]
  mov   ecx,03F3F3F3FH
   mov 	ebp,060606060H
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+224,eax
   mov  WeightForwardMotion+228,ebx
  mov   eax,[edi+8]
   mov  ebx,[edi+12]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+232,eax
   mov  WeightForwardMotion+236,ebx
  mov   eax,[edi+16]
   mov  ebx,[edi+20]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+240,eax
   mov  WeightForwardMotion+244,ebx
  mov   eax,[edi+24]
   mov  ebx,[edi+28]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+248,eax
   mov  WeightForwardMotion+252,ebx
  mov   eax,[edi+32]
   mov  ebx,[edi+36]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+0,eax
   mov  WeightForwardMotion+4,ebx
  mov   eax,[edi+40]
   mov  ebx,[edi+44]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+8,eax
   mov  WeightForwardMotion+12,ebx
  mov   eax,[edi+48]
   mov  ebx,[edi+52]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+16,eax
   mov  WeightForwardMotion+20,ebx
  mov   eax,[edi+56]
   mov  ebx,[edi+60]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightForwardMotion+24,eax
   mov  WeightForwardMotion+28,ebx
  mov   eax,[esi]
   mov  ebx,[esi+4]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+224,eax
   mov  WeightBackwardMotion+228,ebx
  mov   eax,[esi+8]
   mov  ebx,[esi+12]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+232,eax
   mov  WeightBackwardMotion+236,ebx
  mov   eax,[esi+16]
   mov  ebx,[esi+20]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+240,eax
   mov  WeightBackwardMotion+244,ebx
  mov   eax,[esi+24]
   mov  ebx,[esi+28]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+248,eax
   mov  WeightBackwardMotion+252,ebx
  mov   eax,[esi+32]
   mov  ebx,[esi+36]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+0,eax
   mov  WeightBackwardMotion+4,ebx
  mov   eax,[esi+40]
   mov  ebx,[esi+44]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+8,eax
   mov  WeightBackwardMotion+12,ebx
  mov   eax,[esi+48]
   mov  ebx,[esi+52]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+16,eax
   mov  WeightBackwardMotion+20,ebx
  mov   eax,[esi+56]
   mov  ebx,[esi+60]
  and   eax,ecx
   and  ebx,ecx
  xor   eax,ebp
   xor  ebx,ebp
  mov   WeightBackwardMotion+24,eax
   mov  WeightBackwardMotion+28,ebx
  jmp   FirstMacroBlock

ALIGN 16

NextMacroBlock:

  mov   bl,[edx].CodedBlocks
   add  edx,SIZEOF T_MacroBlockActionDescr
  and   ebx,000000040H                ; Check for end-of-stream
   jne  Done

FirstMacroBlock:

  mov   esi,[edx].BlkY1.BlkOffset     ; Get address of next macroblock to do.
   mov  edi,TargetFrameBaseAddress
  mov   eax,FutureFrameBaseAddress
   mov  ebp,PreviousFrameBaseAddress
  lea   edi,[esi+edi+PITCH*3]
   mov  MBlockActionStream,edx        ; Stash list ptr.
  add   ebp,esi
   lea  esi,[esi+eax+PITCH*15]
  mov   PastMBAddr,ebp                ; Stash addr of past MB w/ zero motion.
   mov  ecx,FPITCH*15
  mov   ebp,PITCH
   xor  eax,eax


@@:                                   ; Copy future reference to scratch area
                                      ; that is surrounded by "255" so we can
                                      ; handle access to this surrounding area
                                      ; as the future ref falls out of the MB.
  mov   eax,[esi]
   mov  ebx,[esi+4]
  mov   FutureBlock[ecx],eax
   mov  FutureBlock[ecx+4],ebx
  mov   eax,[esi+8]
   mov  ebx,[esi+12]
  mov   FutureBlock[ecx+8],eax
   mov  FutureBlock[ecx+12],ebx
  sub   esi,ebp
   sub  ecx,FPITCH
  lea   edx,Block1.TargetBlock
   jge  @b

  sar   ecx,31
   lea  ebx,Block1.TargetBlock+TPITCH*3
   
@@:                                   ; Copy target macroblock to scratch area
                                      ; so that we can pick up the target points
                                      ; from a static offset added to esp.  
  mov   eax,[edi]
   mov  esi,[edi+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx],eax
   mov  [ebx+16],esi
  mov   eax,[edi+ebp*4]
   mov  esi,[edi+ebp*4+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx+8],eax
   mov  [ebx+24],esi
  mov   eax,[edi+ebp*8]
   mov  esi,[edi+ebp*8+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx+32],eax
   mov  [ebx+48],esi
  mov   eax,[edi+PITCH*12]
   mov  esi,[edi+PITCH*12+8]
  add   eax,eax
   add  esi,esi
  xor   eax,ecx
   xor  esi,ecx
  mov   [ebx+40],eax
   mov  [ebx+56],esi
  sub   edi,ebp
   sub  ebx,TPITCH
  cmp   ebx,edx
   jge  @b

  mov   eax,16
   lea  edi,[edi+ebp*4+4]
  test  edi,4
  lea   ebx,Block1.TargetBlock+TPITCH*3+4
   jne  @b

  mov   edx,MBlockActionStream
   xor  ebx,ebx
  mov   Block4.TransferCase,eax       ; After block 4, transfer to done 0-MV.
   xor  ecx,ecx
  mov   bl,[edx].BlkY4.PVMV
   mov  esi,PastMBAddr
  mov   al,[edx].BlkY4.PHMV
   xor  ebp,ebp
  mov   bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY4.BestVMVf,bl
  sar   ebx,1                         ; CF == 1 if past vert is at half pel.
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp                       ; ebp == 1 if past vert is at half pel.
   mov  [edx].BlkY4.BestHMVf,cl
  sar   ecx,1                         ; CF == 1 if past horz is at half pel.
IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
   lea  edi,[ebx+ebx*2]               ; Multiply vertical component by PITCH.
  adc   ebp,ebp                       ; ebp odd if past horz is at half pel.
   mov  bl,[edx].BlkY4.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH+PITCH*8+8]; Add horz full pel disp to ref addr.
  add   esi,edi                       ; Add vert full pel disp to past ref addr.
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY4.BestVMVb,bl
   mov  Block4.PastRefBlockAddr,esi   ; Stash address of ref block from past.
  sar   ebx,1                         ; CF == 1 if future vert is at half pel.
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp                       ; ebp odd if future vert is at half pel.
   mov  [edx].BlkY4.BestHMVb,al
  sar   eax,1                         ; CF == 1 if future horz is at half pel.
IF FPITCH-40
  **** The magic leaks out if FPITCH != 40
ENDIF
   lea  edi,[ebx+ebx*4]               ; Multiply vertical component by FPITCH.
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   lea  esi,FutureBlock+80-48-48*FPITCH+FPITCH*8+8
  lea   edi,[eax+edi*8]               ; Linearized MV for future ref.
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  add   esi,edi
   mov  bl,[edx].BlkY3.PVMV
  mov   Block4.FutureRefBlockAddr,esi ; Stash address of ref block from future.
   mov  al,[edx].BlkY3.PHMV
  mov   esi,PastMBAddr
   mov  bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY3.BestVMVf,bl
   xor  ebp,ebp
  sar   ebx,1
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY3.BestHMVf,cl
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[edx].BlkY3.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH+PITCH*8]
  add   esi,edi
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY3.BestVMVb,bl
   mov  Block3.PastRefBlockAddr,esi
  sar   ebx,1
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY3.BestHMVb,al
  sar   eax,1
   lea  edi,[ebx+ebx*4]
  adc   ebp,ebp
   lea  esi,FutureBlock+80-48-48*FPITCH+FPITCH*8
  lea   edi,[eax+edi*8]
   mov  Block2.TransferCase,ebp
  add   esi,edi
   mov  bl,[edx].BlkY2.PVMV
  mov   Block3.FutureRefBlockAddr,esi
   mov  al,[edx].BlkY2.PHMV
  mov   esi,PastMBAddr
   mov  bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY2.BestVMVf,bl
   xor  ebp,ebp
  sar   ebx,1
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY2.BestHMVf,cl
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[edx].BlkY2.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH+8]
  add   esi,edi
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY2.BestVMVb,bl
   mov  Block2.PastRefBlockAddr,esi
  sar   ebx,1
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY2.BestHMVb,al
  sar   eax,1
   lea  edi,[ebx+ebx*4]
  adc   ebp,ebp
   lea  esi,FutureBlock+80-48-48*FPITCH+8
  lea   edi,[eax+edi*8]
   mov  Block1.TransferCase,ebp
  add   esi,edi
   mov  bl,[edx].BlkY1.PVMV
  mov   Block2.FutureRefBlockAddr,esi
   mov  al,[edx].BlkY1.PHMV
  mov   esi,PastMBAddr
   mov  bl,WeightForwardMotion[ebx]
  mov   [edx].BlkY1.BestVMVf,bl
   xor  ebp,ebp
  sar   ebx,1
   mov  cl,WeightForwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY1.BestHMVf,cl
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[edx].BlkY1.PVMV
  shl   edi,7
   lea  esi,[esi+ecx-48-48*PITCH]
  add   esi,edi
   mov  bl,WeightBackwardMotion[ebx]
  mov   [edx].BlkY1.BestVMVb,bl
   mov  Block1.PastRefBlockAddr,esi
  sar   ebx,1
   mov  al,WeightBackwardMotion[eax]
  adc   ebp,ebp
   mov  [edx].BlkY1.BestHMVb,al
  sar   eax,1
   lea  ecx,[ebx+ebx*4]
  adc   ebp,ebp
   lea  edi,FutureBlock+80-48-48*FPITCH
  lea   ecx,[eax+ecx*8]
   mov  eax,ebp
  add   edi,ecx
   mov  ebp,00BADBEEFH
  mov   Block1.BestSWDAccum,ebp
   mov  Block2.BestSWDAccum,ebp
  mov   Block3.BestSWDAccum,ebp
   mov  Block4.BestSWDAccum,ebp
  mov   BlockN.BestSWDAccum,ebp
   xor  ebp,ebp
  sub   esp,64

  jmp   PD JumpTable[eax*4]

ZeroVectorSWDDone:

  mov   eax,ZeroVectorThreshold
   mov  ebx,Block2.CandidateSWDAccum
  cmp   eax,ebp
   mov  edi,Block1.CandidateSWDAccum
  mov   ecx,Block3.CandidateSWDAccum
   mov  Block1.BestSWDAccum,edi
  mov   Block2.BestSWDAccum,ebx
   mov  Block3.BestSWDAccum,ecx
  mov   Block4.BestSWDAccum,ebp
   mov  eax,0                         ; Set best MV to zero.
  mov   esi,MBlockActionStream
   jge  BelowZeroThreshold

  mov   Block1.SWD0MVAccum,edi
   mov  Block2.SWD0MVAccum,ebx
  mov   Block3.SWD0MVAccum,ecx
   mov  Block4.SWD0MVAccum,ebp
  mov   ebx,[esi].BlkY1.BestBiDiMVs
   mov  ecx,[esi].BlkY2.BestBiDiMVs
  mov   BlkY1_0deltaBiDiMVs,ebx
   mov  BlkY2_0deltaBiDiMVs,ecx
  mov   ebx,[esi].BlkY3.BestBiDiMVs
   mov  ecx,[esi].BlkY4.BestBiDiMVs
  mov   BlkY3_0deltaBiDiMVs,ebx
   mov  BlkY4_0deltaBiDiMVs,ecx
  mov   ecx,17
   xor  ebx,ebx                       ; First ME engine state is zero.
  mov   Block4.TransferCase,ecx       ; After block 4, transfer to done non0-MV.
   xor  ecx,ecx
  mov   BlockN.BestSWDAccum,ebp

SWDLoop:

  mov   CurrSWDState,ebx              ; Record ME engine state.
   mov  edx,PD SWDState[ebx]          ; dl == HMV; dh == VMV offsets to try.
  mov   bl,[esi].BlkY4.PVMV
   add  dl,al                         ; Try this horizontal MV delta.
  add   dh,ah                         ; Try this vertical MV delta.
   mov  cl,[esi].BlkY4.PHMV
  mov   BestMV,eax                    ; Record what the best MV so far is.
   mov  CandidateMV,edx               ; Record the candidate MV delta.
  mov   bl,WeightForwardMotion[ebx]   ; TRb * VMV / TRd
   xor  ebp,ebp
  add   bl,dh                         ; VMVf = TRb * VMV / TRd + VMVd
   mov  cl,WeightForwardMotion[ecx]   ; TRb * HMV / TRd
  cmp   bl,040H                       ; If too far up or down, take quick out.
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY4.CandidateVMVf,bl
   add  cl,dl                         ; HMVf = TRb * HMV / TRd + HMVd
  cmp   cl,040H                       ; If too far left or right, quick out.
   jbe  MVDeltaOutOfRange

  sar   ebx,1                         ; CF == 1 if past vert is at half pel.
   mov  [esi].BlkY4.CandidateHMVf,cl
  adc   ebp,ebp                       ; ebp == 1 if past vert is at half pel.
   mov  eax,PastMBAddr
  sar   ecx,1                         ; CF == 1 if past horz is at half pel.
IF PITCH-384
  **** The magic leaks out if PITCH != 384
ENDIF
   lea  edi,[ebx+ebx*2]               ; Multiply vertical component by PITCH.
  adc   ebp,ebp                       ; ebp odd if past horz is at half pel.
   mov  bl,[esi].BlkY3.PVMV
  shl   edi,7
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  lea   ebp,[eax+ecx-48-48*PITCH+PITCH*8+8] ;Add horz full pel disp to ref addr.
   mov  cl,[esi].BlkY3.PHMV
  add   edi,ebp                       ; Add vert full pel disp to past ref addr.
   mov  bl,WeightForwardMotion[ebx]
  mov   Block4.PastRefBlockAddr,edi   ; Stash address of ref block from past.
   xor  ebp,ebp
  add   bl,dh
   mov  cl,WeightForwardMotion[ecx]
  cmp   bl,040H
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY3.CandidateVMVf,bl
   add  cl,dl
  cmp   cl,040H
   jbe  MVDeltaOutOfRange

  sar   ebx,1
   mov  [esi].BlkY3.CandidateHMVf,cl
  adc   ebp,ebp
   sub  eax,48+48*PITCH
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[esi].BlkY2.PVMV
  shl   edi,7
   mov  Block2.TransferCase,ebp
  lea   ebp,[eax+ecx+PITCH*8]
   mov  cl,[esi].BlkY2.PHMV
  add   edi,ebp
   mov  bl,WeightForwardMotion[ebx]
  mov   Block3.PastRefBlockAddr,edi
   xor  ebp,ebp
  add   bl,dh
   mov  cl,WeightForwardMotion[ecx]
  cmp   bl,040H
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY2.CandidateVMVf,bl
   add  cl,dl
  cmp   cl,040H
   jbe  MVDeltaOutOfRange

  sar   ebx,1
   mov  [esi].BlkY2.CandidateHMVf,cl
  adc   ebp,ebp
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   mov  bl,[esi].BlkY1.PVMV
  shl   edi,7
   mov  Block1.TransferCase,ebp
  lea   ebp,[eax+ecx+8]
   mov  cl,[esi].BlkY1.PHMV
  add   edi,ebp
   mov  bl,WeightForwardMotion[ebx]
  mov   Block2.PastRefBlockAddr,edi
   xor  ebp,ebp
  add   bl,dh
   mov  cl,WeightForwardMotion[ecx]
  cmp   bl,040H
   jbe  MVDeltaOutOfRange

  mov   [esi].BlkY1.CandidateVMVf,bl
   add  cl,dl
  cmp   cl,040H
   jbe  MVDeltaOutOfRange

  sar   ebx,1
   mov  [esi].BlkY1.CandidateHMVf,cl
  adc   ebp,ebp
  sar   ecx,1
   lea  edi,[ebx+ebx*2]
  adc   ebp,ebp
   add  eax,ecx
  shl   edi,7
   mov  FirstTransferCase,ebp
  add   edi,eax
   test dh,dh                         ; Is vertical component MV delta zero?
  mov   Block1.PastRefBlockAddr,edi
   je   VMVdIsZero

  lea   edi,FutureBlock+80-48-48*FPITCH
   xor  eax,eax
  mov   bl,[esi].BlkY4.PVMV
   mov  al,[esi].BlkY4.CandidateVMVf
  mov   ebp,Block3.TransferCase       ; Reload transfer case (computed goto idx)
   sub  al,bl                         ; -VMVb = -(VMVf - VMV)
  mov   [esi].BlkY4.CandidateVMVb,al
   mov  cl,[esi].BlkY3.PVMV
  sar   eax,1                         ; CF == 1 if future vert is at half pel.
   mov  bl,[esi].BlkY3.CandidateVMVf
  adc   ebp,ebp                       ; ebp odd if future vert is at half pel.
IF FPITCH-40
  **** The magic leaks out if FPITCH != 40
ENDIF
  mov   Block3.TransferCase,ebp       ; Stash case to do after block 3.
   lea  eax,[eax+eax*4]               ; Multiply vertical component by FPITCH.
  mov   ebp,Block2.TransferCase
   sub  bl,cl
  lea   eax,[edi+eax*8+FPITCH*8+8] ; Addr of ref blk w/ vert MV.
   mov  [esi].BlkY3.CandidateVMVb,bl
  sar   ebx,1
   mov  Block4.FutureRefBlockAddr,eax ; Stash address of ref block from future.
  adc   ebp,ebp
   mov  cl,[esi].BlkY2.PVMV
  mov   Block2.TransferCase,ebp
   lea  eax,[ebx+ebx*4]
  mov   bl,[esi].BlkY2.CandidateVMVf
   mov  ebp,Block1.TransferCase
  lea   eax,[edi+eax*8+FPITCH*8]
   sub  bl,cl
  mov   Block3.FutureRefBlockAddr,eax
   mov  [esi].BlkY2.CandidateVMVb,bl
  sar   ebx,1
   mov  dh,[esi].BlkY1.PVMV		    
  adc   ebp,ebp
   mov  cl,[esi].BlkY1.CandidateVMVf
  mov   Block1.TransferCase,ebp
   sub  cl,dh
  mov   [esi].BlkY1.CandidateVMVb,cl
   lea  eax,[ebx+ebx*4]
  sar   ecx,1
   mov  ebp,FirstTransferCase
  adc   ebp,ebp
   lea  eax,[edi+eax*8+8]
  mov   Block2.FutureRefBlockAddr,eax
   lea  eax,[ecx+ecx*4]
  mov   FirstTransferCase,ebp
   test dl,dl                         ; Is horizontal component MV delta zero?
  lea   edi,[edi+eax*8]
   mov  eax,0
  mov   Block1.FutureRefBlockAddr,edi
   je   HMVdIsZero

HMVdIsNonZero:

  mov   cl,[esi].BlkY4.CandidateHMVf
   mov  bl,[esi].BlkY4.PHMV
  mov   ebp,Block3.TransferCase
   sub  cl,bl                         ; -HMVb = -(HMVf - HMV)
  mov   [esi].BlkY4.CandidateHMVb,cl
   mov  edi,Block4.FutureRefBlockAddr ; Load addr of ref blk to factor in horz.
  sar   ecx,1                         ; CF == 1 if future horz is at half pel.
   mov  bl,[esi].BlkY3.PHMV
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   add  edi,ecx                       ; Factor in HMVb.
  mov   Block3.TransferCase,ebp       ; Stash case to do after block 3.
   mov  cl,[esi].BlkY3.CandidateHMVf
  sub   cl,bl
   mov  Block4.FutureRefBlockAddr,edi ; Stash address of ref block from future.
  mov   ebp,Block2.TransferCase
   mov  [esi].BlkY3.CandidateHMVb,cl
  sar   ecx,1
   mov  edi,Block3.FutureRefBlockAddr
  adc   ebp,ebp
   add  edi,ecx
  mov   Block2.TransferCase,ebp
   mov  Block3.FutureRefBlockAddr,edi
  mov   cl,[esi].BlkY2.CandidateHMVf
   mov  bl,[esi].BlkY2.PHMV
  mov   ebp,Block1.TransferCase
   sub  cl,bl
  mov   [esi].BlkY2.CandidateHMVb,cl
   mov  edi,Block2.FutureRefBlockAddr
  sar   ecx,1
   mov  bl,[esi].BlkY1.PHMV
  adc   ebp,ebp
   add  edi,ecx
  mov   Block1.TransferCase,ebp
   mov  cl,[esi].BlkY1.CandidateHMVf
  sub   cl,bl
   mov  Block2.FutureRefBlockAddr,edi
  mov   eax,FirstTransferCase
   mov  [esi].BlkY1.CandidateHMVb,cl
  sar   ecx,1
   mov  edi,Block1.FutureRefBlockAddr
  adc   eax,eax
   add  edi,ecx
  mov   esi,Block1.PastRefBlockAddr
   sub  esp,64
  xor   ebp,ebp

  jmp   PD JumpTable[eax*4]


VMVdIsZero:

  mov   bl,[esi].BlkY4.PVMV
   mov  cl,[esi].BlkY3.PVMV
  mov   ebp,Block3.TransferCase
   mov  dh,PB Block2.TransferCase
  mov   bl,WeightBackwardMotion[ebx]
   lea  edi,FutureBlock+80-48-48*FPITCH
  mov   [esi].BlkY4.CandidateVMVb,bl
   mov  cl,WeightBackwardMotion[ecx]
  sar   ebx,1                         ; CF == 1 if future vert is at half pel.
   mov  [esi].BlkY3.CandidateVMVb,cl
  adc   ebp,ebp                       ; ebp odd if future vert is at half pel.
  sar   ecx,1
   lea  eax,[ebx+ebx*4]               ; Multiply vertical component by FPITCH.
  adc   dh,dh
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  lea   ebp,[edi+eax*8+FPITCH*8+8]    ; Addr of ref blk w/ vert MV factored in.
   lea  eax,[ecx+ecx*4]
  mov   PB Block2.TransferCase,dh
   mov  Block4.FutureRefBlockAddr,ebp ; Stash address of ref block from future.
  lea   ebp,[edi+eax*8+FPITCH*8]
   mov  bl,[esi].BlkY2.PVMV
  mov   Block3.FutureRefBlockAddr,ebp
   mov  cl,[esi].BlkY1.PVMV
  mov   ebp,Block1.TransferCase
   mov  bl,WeightBackwardMotion[ebx]
  mov   dh,PB FirstTransferCase
   mov  [esi].BlkY2.CandidateVMVb,bl
  sar   ebx,1
   mov  cl,WeightBackwardMotion[ecx]
  adc   ebp,ebp
   mov  [esi].BlkY1.CandidateVMVb,cl
  sar   ecx,1
   lea  eax,[ebx+ebx*4]
  adc   dh,dh
   mov  Block1.TransferCase,ebp
  lea   ebp,[edi+eax*8+8]
   lea  eax,[ecx+ecx*4]
  mov   PB FirstTransferCase,dh
   mov  Block2.FutureRefBlockAddr,ebp
  lea   ebp,[edi+eax*8]
   test dl,dl
  mov   Block1.FutureRefBlockAddr,ebp
   jne  HMVdIsNonZero

HMVdIsZero:

  mov   bl,[esi].BlkY4.PHMV
   mov  cl,[esi].BlkY3.PHMV
  mov   ebp,Block3.TransferCase
   mov  edx,Block2.TransferCase
  mov   bl,WeightBackwardMotion[ebx]
   mov  eax,Block4.FutureRefBlockAddr
  mov   [esi].BlkY4.CandidateHMVb,bl
   mov  cl,WeightBackwardMotion[ecx]
  sar   ebx,1                         ; CF == 1 if future horz is at half pel.
   mov  [esi].BlkY3.CandidateHMVb,cl
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   add  eax,ebx                       ; Addr of ref blk w/ horz MV factored in.
  sar   ecx,1
   mov  Block3.TransferCase,ebp       ; Stash case to do after block 3.
  adc   edx,edx
   mov  edi,Block3.FutureRefBlockAddr
  mov   Block4.FutureRefBlockAddr,eax ; Stash address of ref block from future.
   add  edi,ecx
  mov   Block2.TransferCase,edx
   mov  Block3.FutureRefBlockAddr,edi
  mov   bl,[esi].BlkY2.PHMV
   mov  cl,[esi].BlkY1.PHMV
  mov   ebp,Block1.TransferCase
   mov  edx,FirstTransferCase
  mov   bl,WeightBackwardMotion[ebx]
   mov  eax,Block2.FutureRefBlockAddr
  mov   [esi].BlkY2.CandidateHMVb,bl
   mov  cl,WeightBackwardMotion[ecx]
  sar   ebx,1                         ; CF == 1 if future horz is at half pel.
   mov  [esi].BlkY1.CandidateHMVb,cl
  adc   ebp,ebp                       ; ebp odd if future horz is at half pel.
   add  eax,ebx                       ; Addr of ref blk w/ horz MV factored in.
  sar   ecx,1
   mov  Block1.TransferCase,ebp       ; Stash case to do after block 3.
  adc   edx,edx
   mov  edi,Block1.FutureRefBlockAddr
  mov   Block2.FutureRefBlockAddr,eax ; Stash address of ref block from future.
   add  edi,ecx
  mov   esi,Block1.PastRefBlockAddr
   sub  esp,64
  xor   ebp,ebp

  jmp   PD JumpTable[edx*4]


MVDeltaOutOfRange:

  xor   ebp,ebp
   mov  ebx,CurrSWDState             ; Restore ME engine state.
  jmp   OutOfRangeHandlingDone

TakeEarlyOut:

  sub   esp,4
   xor  ecx,ecx
  and   esp,0FFFFFFC0H
  mov   ebx,CurrSWDState+64
   mov  esi,MBlockActionStream+64
  mov   eax,BestMV+64
   add  esp,64
  mov   bl,SWDState[ebx+3]
  test  bl,bl
   jne  SWDLoop

  mov   ecx,Block4.SWD0MVAccum
   mov  ebp,Block4.BestSWDAccum
  jmp   CandidatesDone

NonZeroVectorSWDDone:

  mov   ebx,CurrSWDState
   mov  esi,MBlockActionStream
  xor   ecx,ecx
   mov  ebp,-1
  mov   eax,[esi].BlkY1.CandidateBiDiMVs
   mov  edx,[esi].BlkY2.CandidateBiDiMVs
  mov   [esi].BlkY1.BestBiDiMVs,eax
   mov  [esi].BlkY2.BestBiDiMVs,edx
  mov   eax,[esi].BlkY3.CandidateBiDiMVs
   mov  edx,[esi].BlkY4.CandidateBiDiMVs
  mov   [esi].BlkY3.BestBiDiMVs,eax
   mov  [esi].BlkY4.BestBiDiMVs,edx
  mov   eax,Block1.CandidateSWDAccum
   mov  edx,Block2.CandidateSWDAccum
  mov   Block1.BestSWDAccum,eax
   mov  Block2.BestSWDAccum,edx
  mov   eax,Block3.CandidateSWDAccum
   mov  edx,Block4.CandidateSWDAccum
  mov   Block3.BestSWDAccum,eax
   mov  Block4.BestSWDAccum,edx
  mov   BlockN.BestSWDAccum,edx

OutOfRangeHandlingDone:

  mov   bl,SWDState[ebx+ebp*1+3]
   mov  eax,BestMV[ebp*4]
  test  bl,bl
   jne  SWDLoop

  mov   ecx,Block4.SWD0MVAccum
   mov  ebp,Block4.BestSWDAccum

CandidatesDone:

  sub   ecx,ebp
   mov  ebx,NonZeroMVDifferential
  cmp   ecx,ebx
   jge  ZeroMVNotGoodEnough

ZeroMVGoodEnough:

  xor   eax,eax
   mov  esi,MBlockActionStream
  mov   edi,Block1.SWD0MVAccum
   mov  ebx,Block2.SWD0MVAccum
  mov   ecx,Block3.SWD0MVAccum
   mov  ebp,Block4.SWD0MVAccum
  mov   Block1.BestSWDAccum,edi
   mov  Block2.BestSWDAccum,ebx
  mov   Block3.BestSWDAccum,ecx
   mov  Block4.BestSWDAccum,ebp
  mov   ebx,BlkY1_0deltaBiDiMVs
   mov  edi,BlkY2_0deltaBiDiMVs
  mov   [esi].BlkY1.BestBiDiMVs,ebx
   mov  [esi].BlkY2.BestBiDiMVs,edi
  mov   ebx,BlkY3_0deltaBiDiMVs
   mov  edi,BlkY4_0deltaBiDiMVs
  mov   [esi].BlkY3.BestBiDiMVs,ebx
   mov  [esi].BlkY4.BestBiDiMVs,edi

BelowZeroThreshold:
ZeroMVNotGoodEnough:

  mov   [esi].BlkY1.BHMV,al
   mov  [esi].BlkY2.BHMV,al
  mov   [esi].BlkY3.BHMV,al
   mov  [esi].BlkY4.BHMV,al
  mov   [esi].BlkY1.BVMV,ah
   mov  [esi].BlkY2.BVMV,ah
  mov   [esi].BlkY3.BVMV,ah
   mov  [esi].BlkY4.BVMV,ah
  mov   al,[esi].CodedBlocksB      ; Fetch coded block pattern.
   mov  edi,EmptyBlockThreshold    ; Get threshold for forcing block empty?
  or    al,03FH                    ; Initially set all blocks coded.
   mov  ecx,Block3.BestSWDAccum
  mov   ebx,InterSWDBlocks
   mov  edx,ebp
  sub   edx,ecx                    ; Get SWD for block 4.
  cmp   edx,edi                    ; Is it below empty threshold?
   jg   @f

  and   al,0F7H                    ; If so, indicate block 4 is NOT coded.
   dec  ebx
  sub   ebp,edx

@@:

  mov   edx,Block2.BestSWDAccum
  sub   ecx,edx
  cmp   ecx,edi
   jg   @f

  and   al,0FBH
   dec  ebx
  sub   ebp,ecx

@@:

  mov   ecx,Block1.BestSWDAccum
  sub   edx,ecx
  cmp   edx,edi
   jg   @f

  and   al,0FDH
   dec  ebx
  sub   ebp,edx

@@:

  mov   edx,InterSWDTotal
  cmp   ecx,edi
   jg   @f

  and   al,0FEH
   dec  ebx
  sub   ebp,ecx

@@:

  mov   [esi].CodedBlocksB,al    ; Store coded block pattern.
   add  ebx,4
  mov   InterSWDBlocks,ebx
   add  edx,ebp                    ; Add to total for this macroblock class.
  mov   InterSWDTotal,edx
   mov  edx,esi
  mov   PD [esi].SWDB,ebp
   jmp  NextMacroBlock




BiDiNoInterp:

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Pointer to block of reference in future frame + 80.
;  al, bl, cl, dl -- Scratch.

  xor   eax,eax
   xor  ebx,ebx
  mov   al,[edi-80]                        ; 00A Fetch pel from future ref.
   mov  bl,[esi]                           ; 00B Fetch pel from previous ref.
  xor   ecx,ecx
   xor  edx,edx
@@:
  mov   al,InterpPastAndFutureRef[eax+ebx] ; 00C (past+future) or 2*past
   mov  bl,BlockN.TargetBlock[0]           ; 00D Fetch -2 * target pel.
  mov   cl,[edi+FPITCH*2+2-80]             ; 22A
   mov  dl,[esi+PITCH*2+2]                 ; 22B
  mov   bl,WeightedDiff[ebx+eax]           ; 00E Weighted difference.
   mov  cl,InterpPastAndFutureRef[ecx+edx] ; 22C
  add   ebp,ebx                            ; 00F Accumulate weighted difference.
   mov  dl,BlockN.TargetBlock[TPITCH*2+2]  ; 22D
  mov   al,[esi+PITCH*0+2]                 ; 02a Fetch pel from previous ref.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2]  ; 02b Fetch -2 * target pel.
  mov   dl,WeightedDiff[edx+ecx]           ; 22E
   mov  cl,[esi+PITCH*2+0]                 ; 20a
  add   ebp,edx                            ; 22F
   mov  dl,BlockN.TargetBlock[TPITCH*2+0]  ; 20b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 02c Weighted difference.
   mov  al,[esi+PITCH*1+1]                 ; 11a
  add   ebp,ebx                            ; 02d Accumulate weighted difference.
   mov  bl,BlockN.TargetBlock[TPITCH*1+1]  ; 11b
  mov   dl,WeightedDiff[edx+ecx*2]         ; 20c
   mov  cl,[esi+PITCH*1+3]                 ; 13a
  add   ebp,edx                            ; 20d
   mov  dl,BlockN.TargetBlock[TPITCH*1+3]  ; 13b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 11c
   mov  al,[esi+PITCH*3+1]                 ; 31a
  add   ebp,ebx                            ; 11d
   mov  bl,BlockN.TargetBlock[TPITCH*3+1]  ; 31b
  mov   dl,WeightedDiff[edx+ecx*2]         ; 13c
   mov  cl,[esi+PITCH*3+3]                 ; 33a
  add   ebp,edx                            ; 13d
   mov  dl,BlockN.TargetBlock[TPITCH*3+3]  ; 33b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 31c
   add  edi,4                              ;      Move to next 4 columns.
  add   ebp,ebx                            ; 31d
   mov  dl,WeightedDiff[edx+ecx*2]         ; 33c
  add   ebp,edx                            ; 33d
   add  esi,4                              ;      Move to next 4 columns.
  add   esp,4                              ;      Move to next 4 columns.
   mov  al,[edi-80]                        ; 04A
  mov   bl,[esi]                           ; 04B
   mov  cl,4
  and   ecx,esp                            ;      Twice, 4 cols each time.
   jne  @b

  mov   al,[edi-80+FPITCH*4-8]             ; 40A
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  mov   cl,8
   add  edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
  and   ecx,esp                            ; Twice, 4 rows each time.
   mov  bl,[esi]                           ; 40B
  jne   @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]


BiDiFutureHorz LABEL DWORD
  mov   edx,1
   xor  ecx,ecx
  jmp   BiDiSWDCalc_InterpFuture

BiDiFutureVert:
  mov   edx,FPITCH
   xor  ecx,ecx
  jmp   BiDiSWDCalc_InterpFuture

BiDiFutureBoth:
  mov   edx,FPITCH+1
   xor  ecx,ecx

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Pointer to block of reference in future frame + 80.
;  edx -- Distance from future pel to other future pel with which to interp.
;  al, bl, cl, dl -- Scratch.

BiDiSWDCalc_InterpFuture:

  mov   al,[edi-80]                        ; 00A Fetch pel from future ref.
   xor  ebx,ebx
@@:

  mov   bl,[edi+edx-80]                    ; 00B Fetch other future ref pel.
   and  eax,0000000FFH
  mov   BlockN.FutureRefInterpOffset,edx   ; Stash interp offset.
   mov  dl,[edi+edx+FPITCH*2+2-80]         ; 22B
  mov   al,InterpFutureRef[eax+ebx]        ; 00C Get interpolated future ref.
   mov  bl,[esi]                           ; 00D Fetch pel from previous ref.
  mov   cl,[edi+FPITCH*2+2-80]             ; 22A
   and  edx,0000000FFH                     ;     Extract pel value.
  mov   al,InterpPastAndFutureRef[eax+ebx] ; 00E (past+future) or 2*past
   mov  bl,BlockN.TargetBlock[0]           ; 00F Fetch -2 * target pel.
  mov   cl,InterpFutureRef[ecx+edx]        ; 22C
   mov  dl,[esi+PITCH*2+2]                 ; 22D
  mov   bl,WeightedDiff[ebx+eax]           ; 00G Weighted difference.
   mov  al,[esi+PITCH*0+2]                 ; 02a Fetch pel from previous ref.
  add   ebp,ebx                            ; 00H Accumulate weighted difference.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2]  ; 02b Fetch -2 * target pel.
  mov   cl,InterpPastAndFutureRef[ecx+edx] ; 22E
   mov  dl,BlockN.TargetBlock[TPITCH*2+2]  ; 22F
  mov   bl,WeightedDiff[ebx+eax*2]         ; 02c Weighted difference.
   mov  al,[esi+PITCH*2+0]                 ; 20a
  mov   dl,WeightedDiff[edx+ecx]           ; 22G
   add  ebp,ebx                            ; 02d Accumulate weighted difference.
  add   ebp,edx                            ; 22H
   mov  bl,BlockN.TargetBlock[TPITCH*2+0]  ; 20b
  mov   cl,[esi+PITCH*1+1]                 ; 11a
   mov  dl,BlockN.TargetBlock[TPITCH*1+1]  ; 11b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 20c
   mov  al,[esi+PITCH*1+3]                 ; 13a
  add   ebp,ebx                            ; 20d
   mov  dl,WeightedDiff[edx+ecx*2]         ; 11c
  add   ebp,edx                            ; 11d
   mov  bl,BlockN.TargetBlock[TPITCH*1+3]  ; 13b
  mov   cl,[esi+PITCH*3+1]                 ; 31a
   mov  dl,BlockN.TargetBlock[TPITCH*3+1]  ; 31b
  mov   bl,WeightedDiff[ebx+eax*2]         ; 13c
   mov  al,[esi+PITCH*3+3]                 ; 33a
  add   ebp,ebx                            ; 13d
   mov  bl,BlockN.TargetBlock[TPITCH*3+3]  ; 33b
  mov   dl,WeightedDiff[edx+ecx*2]         ; 31c
   add  edi,4                              ;      Move to next 4 columns.
  add   ebp,edx                            ; 31d
   mov  bl,WeightedDiff[ebx+eax*2]         ; 33c
  add   ebp,ebx                            ; 33d
   mov  edx,BlockN.FutureRefInterpOffset   ;     Prepare for next iteration.
  add   esi,4                              ;      Move to next 4 columns.
   add  esp,4                              ;      Move to next 4 columns.
  mov   al,[edi-80]                        ; 04A
   mov  cl,4
  and   ecx,esp                            ;      Twice, 4 cols each time.
   jne  @b

  mov   al,[edi-80+FPITCH*4-8]             ; 40A
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  mov   cl,8
   add  edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
  and   ecx,esp                            ; Twice, 4 rows each time.
   jne  @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]


BiDiPastHorz LABEL DWORD
  mov   edx,edi
   mov  edi,1
  xor   eax,eax
   jmp  BiDiSWDCalc_InterpPast

BiDiPastVert:
  mov   edx,edi
   mov  edi,PITCH
  xor   eax,eax
   jmp  BiDiSWDCalc_InterpPast

BiDiPastBoth:
  mov   edx,edi
   mov  edi,PITCH+1
  xor   eax,eax

BiDiSWDCalc_InterpPast:

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Distance from future pel to other future pel with which to interp.
;  edx -- Pointer to block of reference in future frame + 80.
;  al, bl, cl, dl -- Scratch.

  mov   al,[esi]                              ; 00A Fetch pel from previous ref.
   xor  ebx,ebx
  mov   bl,[esi+edi]                          ; 00B Fetch other past ref pel.
   xor  ecx,ecx
@@:
  add   al,bl                                 ; 00C Interp'd past ref, times 2.
   mov  bl,[edx-80]                           ; 00D Fetch pel from future ref.
  mov   BlockN.FutureRefBlockAddr,edx
   mov  dl,[edx+FPITCH*2+2-80]                ; 22D
  mov   al,Interp2PastAndFutureRef[eax+ebx*2] ; 00E (past+future) or 2*past.
   mov  bl,BlockN.TargetBlock[0]              ; 00F Fetch target pel.
  mov   cl,[esi+PITCH*2+2]                    ; 22A
   and  edx,0000000FFH
  mov   bl,WeightedDiff[eax+ebx]              ; 00G Weighted difference.
   mov  al,[esi+edi+PITCH*2+2]                ; 22B
  add   cl,al                                 ; 22C
   mov  al,[esi+PITCH*0+2]                    ; 02a Fetch pel from previous ref.
  add   ebp,ebx                               ; 00H Accumulate weighted diff.
   mov  bl,[esi+edi+PITCH*0+2]                ; 02b Fetch other past ref pel.
  mov   cl,Interp2PastAndFutureRef[ecx+edx*2] ; 22E
   mov  dl,BlockN.TargetBlock[TPITCH*2+2]     ; 22F
  add   al,bl                                 ; 02c Interp'd past ref, times 2.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2]     ; 02d Fetch -2 * target pel.
  mov   dl,WeightedDiff[ecx+edx]              ; 22G Weighted difference.
   mov  cl,[esi+PITCH*2+0]                    ; 20a
  add   ebp,edx                               ; 22H
   mov  dl,[esi+edi+PITCH*2+0]                ; 20b
  add   cl,dl                                 ; 20c
   mov  dl,BlockN.TargetBlock[TPITCH*2+0]     ; 20d
  mov   bl,WeightedDiff[eax+ebx]              ; 02e Weighted difference.
   mov  al,[esi+PITCH*1+1]                    ; 11a
  add   ebp,ebx                               ; 02f Accumulate weighted diff.
   mov  bl,[esi+edi+PITCH*1+1]                ; 11b
  add   al,bl                                 ; 11c
   mov  bl,BlockN.TargetBlock[TPITCH*1+1]     ; 11d
  mov   dl,WeightedDiff[ecx+edx]              ; 20e
   mov  cl,[esi+PITCH*1+3]                    ; 13a
  add   ebp,edx                               ; 20f
   mov  dl,[esi+edi+PITCH*1+3]                ; 13b
  add   cl,dl                                 ; 13c
   mov  dl,BlockN.TargetBlock[TPITCH*1+3]     ; 13d
  mov   bl,WeightedDiff[eax+ebx]              ; 11e
   mov  al,[esi+PITCH*3+1]                    ; 31a
  add   ebp,ebx                               ; 11f
   mov  bl,[esi+edi+PITCH*3+1]                ; 31b
  add   al,bl                                 ; 31c
   mov  bl,BlockN.TargetBlock[TPITCH*3+1]     ; 31d
  mov   dl,WeightedDiff[ecx+edx]              ; 13e
   mov  cl,[esi+PITCH*3+3]                    ; 33a
  add   ebp,edx                               ; 13f
   mov  dl,[esi+edi+PITCH*3+3]                ; 33b
  add   cl,dl                                 ; 33c
   mov  dl,BlockN.TargetBlock[TPITCH*3+3]     ; 33d
  mov   bl,WeightedDiff[eax+ebx]              ; 31e
   add  esi,4                                 ;     Move to next 4 columns.
  add   ebp,ebx                               ; 31f
   mov  dl,WeightedDiff[ecx+edx]              ; 33e
  add   ebp,edx                               ; 33f
   mov  edx,BlockN.FutureRefBlockAddr
  add   edx,4                                 ;     Move to next 4 columns.
   add  esp,4                                 ;     Move to next 4 columns.
  mov   al,[esi]                              ; 04A
   mov  cl,4
  mov   bl,[esi+edi]                          ; 04B
   and  ecx,esp                               ;     Twice, 4 cols each time.
  mov   cl,8
   jne  @b

  add   edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
   mov  al,[esi+PITCH*4-8]                 ; 40A
  mov   bl,[esi+edi+PITCH*4-8]             ; 40B
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  and   ecx,esp                            ; Twice, 4 rows each time.
   jne  @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]


BiDiSWDCalc_InterpBoth MACRO PastRefInterpOffset

;  esp -- Pointer to block of target macroblock.
;  ebp -- SWD accumulator.  Must be initialized by caller.
;  esi -- Pointer to block of reference in past frame.
;  edi -- Pointer to block of reference in future frame + 80.
;  al, bl, cl, dl -- Scratch.

@@:
  
  mov   bl,[edi-80]                        ; 00A Fetch pel from future ref.
   mov  BlockN.FutureRefBlockAddr,edx
  mov   al,[edi+edx-80]                    ; 00B Fetch other future ref pel.
   mov  dl,[edi+edx+FPITCH*2+2-80]                     ; 22B
  mov   cl,[edi+FPITCH*2+2-80]                         ; 22A
   add  esp,4                              ;     Move to next 4 columns.
  mov   bl,InterpFutureRef[eax+ebx]        ; 00C Get interpolated future ref.
   mov  al,[esi]                           ; 00D Fetch pel from previous ref.
  mov   dl,InterpFutureRef[ecx+edx]                    ; 22C
   mov  cl,[esi+PITCH*2+2]                             ; 22D
  lea   ebx,[eax+ebx*2]                    ; 00E Interp'ed future plus one past.
   mov  al,[esi+PastRefInterpOffset]       ; 00F Fetch other pel from past ref.
  lea   edx,[ecx+edx*2]                                ; 22E
   mov  cl,[esi+PITCH*2+2+PastRefInterpOffset]         ; 22F
  mov   al,Interp2PastAndFutureRef[ebx+eax]; 00G (past+future) or 2*past.
   xor  ebx,ebx
  mov   bl,BlockN.TargetBlock[0-4]         ; 00H Fetch target pel.
   mov  cl,Interp2PastAndFutureRef[edx+ecx]            ; 22G
  mov   dl,BlockN.TargetBlock[TPITCH*2+2-4]            ; 22H
   add  esi,4                                 ;     Move to next 4 columns.
  and   edx,0000000FFH
   mov  bl,WeightedDiff[eax+ebx]           ; 00I Weighted difference.
  add   ebp,ebx                            ; 00J Accum weighted difference.
   mov  al,[esi+PITCH*0+2-4]                    ; 02a Fetch pel from prev ref.
  mov   dl,WeightedDiff[ecx+edx]                       ; 22I
   mov  bl,[esi+PastRefInterpOffset+PITCH*0+2-4]; 02b Fetch other past ref pel.
  add   al,bl                                   ; 02c Interp'd past ref, *2.
   mov  bl,BlockN.TargetBlock[TPITCH*0+2-4]     ; 02d Fetch -2 * target pel.
  add   ebp,edx                                        ; 22J
   mov  cl,[esi+PITCH*2+0-4]                    ; 20a
  add   edi,4                              ;     Move to next 4 columns.
   mov  dl,[esi+PastRefInterpOffset+PITCH*2+0-4]; 20b
  mov   bl,WeightedDiff[eax+ebx]                ; 02e Weighted difference.
   mov  al,[esi+PITCH*1+1-4]                    ; 11a
  add   ebp,ebx                                 ; 02f Accumulate weighted diff.
   mov  bl,[esi+PastRefInterpOffset+PITCH*1+1-4]; 11b
  add   cl,dl                                   ; 20c
   mov  dl,BlockN.TargetBlock[TPITCH*2+0-4]     ; 20d
  add   al,bl                                   ; 11c
   mov  bl,BlockN.TargetBlock[TPITCH*1+1-4]     ; 11d
  mov   dl,WeightedDiff[ecx+edx]                ; 20e
   mov  cl,[esi+PITCH*1+3-4]                    ; 13a
  add   ebp,edx                                 ; 20f
   mov  dl,[esi+PastRefInterpOffset+PITCH*1+3-4]; 13b
  mov   bl,WeightedDiff[eax+ebx]                ; 11e
   mov  al,[esi+PITCH*3+1-4]                    ; 31a
  add   ebp,ebx                                 ; 11f
   mov  bl,[esi+PastRefInterpOffset+PITCH*3+1-4]; 31b
  add   cl,dl                                   ; 13c
   mov  dl,BlockN.TargetBlock[TPITCH*1+3-4]     ; 13d
  add   al,bl                                   ; 31c
   mov  bl,BlockN.TargetBlock[TPITCH*3+1-4]     ; 31d
  mov   dl,WeightedDiff[ecx+edx]                ; 13e
   mov  cl,[esi+PITCH*3+3-4]                    ; 33a
  add   ebp,edx                                 ; 13f
   mov  dl,[esi+PastRefInterpOffset+PITCH*3+3-4]; 33b
  add   cl,dl                                   ; 33c
   mov  dl,BlockN.TargetBlock[TPITCH*3+3-4]     ; 33d
  mov   bl,WeightedDiff[eax+ebx]                ; 31e
   mov  al,4
  add   ebp,ebx                                 ; 31f
   mov  dl,WeightedDiff[ecx+edx]                ; 33e
  add   ebp,edx                                 ; 33f
   mov  edx,BlockN.FutureRefBlockAddr-4
  and   eax,esp                                 ;     Twice, 4 cols each time.
   jne  @b

  add   edi,FPITCH*4-8                     ; Move to first 4 cols, next 4 rows.
   add  esi,PITCH*4-8                      ; Move to first 4 cols, next 4 rows.
  mov   cl,8
  and   ecx,esp                            ; Twice, 4 rows each time.
   jne  @b

  mov   BlockNM1.CandidateSWDAccum,ebp   ; Store accumulated SWD.
   mov  eax,BlockN.BestSWDAccum
  cmp   ebp,eax
   jg   TakeEarlyOut

  mov   eax,BlockNM1.TransferCase        ; Fetch next case to execute.
   mov  esi,BlockN.PastRefBlockAddr      ; Fetch next past ref address.
  mov   edi,BlockN.FutureRefBlockAddr    ; Fetch next past ref address.
  jmp   PD JumpTable[eax*4]

ENDM

BiDiPastHorzFutureHorz LABEL DWORD

  xor   ecx,ecx
   mov  edx,1
  jmp   BiDiSWDCalc_InterpBoth_PastByHorz

BiDiPastHorzFutureVert LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH
  jmp   BiDiSWDCalc_InterpBoth_PastByHorz

BiDiPastHorzFutureBoth LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH+1

BiDiSWDCalc_InterpBoth_PastByHorz:

  xor   eax,eax
   xor  ebx,ebx
  BiDiSWDCalc_InterpBoth 1

BiDiPastVertFutureHorz LABEL DWORD

  xor   ecx,ecx
   mov  edx,1
  jmp   BiDiSWDCalc_InterpBoth_PastByVert

BiDiPastVertFutureVert LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH
  jmp   BiDiSWDCalc_InterpBoth_PastByVert

BiDiPastVertFutureBoth LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH+1

BiDiSWDCalc_InterpBoth_PastByVert:

  xor   eax,eax
   xor  ebx,ebx
  BiDiSWDCalc_InterpBoth PITCH

BiDiPastBothFutureHorz LABEL DWORD

  xor   ecx,ecx
   mov  edx,1
  jmp   BiDiSWDCalc_InterpBoth_PastByBoth

BiDiPastBothFutureVert LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH
  jmp   BiDiSWDCalc_InterpBoth_PastByBoth

BiDiPastBothFutureBoth LABEL DWORD

  xor   ecx,ecx
   mov  edx,FPITCH+1

BiDiSWDCalc_InterpBoth_PastByBoth:

  xor   eax,eax
   xor  ebx,ebx
  BiDiSWDCalc_InterpBoth PITCH+1

ALIGN 4
JumpTable:
  
  DD   BiDiNoInterp
  DD   BiDiFutureHorz
  DD   BiDiFutureVert
  DD   BiDiFutureBoth
  DD   BiDiPastHorz
  DD   BiDiPastHorzFutureHorz
  DD   BiDiPastHorzFutureVert
  DD   BiDiPastHorzFutureBoth
  DD   BiDiPastVert
  DD   BiDiPastVertFutureHorz
  DD   BiDiPastVertFutureVert
  DD   BiDiPastVertFutureBoth
  DD   BiDiPastBoth
  DD   BiDiPastBothFutureHorz
  DD   BiDiPastBothFutureVert
  DD   BiDiPastBothFutureBoth
  DD   ZeroVectorSWDDone
  DD   NonZeroVectorSWDDone

Done:

  mov   ecx,InterSWDTotal
  mov   edx,InterSWDBlocks
  mov   esp,StashESP
  mov   edi,[esp+InterSWDTotal_arg]
  mov   [edi],ecx
  mov   edi,[esp+InterSWDBlocks_arg]
  mov   [edi],edx
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn


BFRAMEMOTIONESTIMATION endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ex5fdct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5fdct.asv   1.5   14 May 1996 12:18:50   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\ex5fdct.asv  $
;// 
;//    Rev 1.5   14 May 1996 12:18:50   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.4   11 Apr 1996 16:02:06   AKASAI
;// Updated H261 encoder to new interface and macroblock action stream
;// data structure in e3mbad.inc for FORWARDDCT.  Files updated together
;// e1enc.cpp, e1enc.h, ex5fdct.asm, e3mbad.inc.
;// 
;// Added IFNDEF H261 in ex5fdct so that code used only in H263 is
;// not assembled for H261.
;// 
;//    Rev 1.3   24 Jan 1996 13:21:28   BNICKERS
;// Implement OBMC
;// 
;//    Rev 1.1   27 Dec 1995 15:32:42   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////
;
; e35fdct -- This function performs a Forward Discrete Cosine Transform for H263, on a stream of macroblocks comprised
;            of 8*8 blocks of pels or pel diffs.  This version is tuned for the Pentium Microprocessor.
;
; Arguments:
;
;   MBlockActionStream (Input)
;
;     A stream of MacroBlock Action Descriptors.  Each descriptor indicates which blocks of a macroblock are non-empty
;     and thus need to be transformed.  There are from 0 to 12 non-empty blocks in each macroblock.
;
;     Processing commences with the macroblock described by the first descriptor in the stream (regardless of whether
;     it's End-Of-Stream bit is set).  Processing continues up to but not including the next descriptor that has the
;     End-Of-Stream bit set.
;
;     This function requires each descripgor in the MBlockActionStream to be 16-byte aligned.  Moreover, each of the
;     T_Blk elements in the descriptor must also be 16-byte aligned, and ordered as they are now.  (Note that I am
;     talking about the address of these pointer variables, not the alignement of the data they point to.)
;
;     Best performance will be attained when 8*8 blocks are (or usually are) DWORD aligned.  MMx implementations will
;     probably prefer 8-byte alignment.
;
;     The complete format of the MacroBlock Action Descriptors is provided in e3mbad.inc.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.  When doing B frames, this
;                             is the Target B Frame Base Address.
;
;   PreviousFrameBaseAddress -- Address of the reconstructed previous frame.  This really isn't needed for P-frame
;                               processing, estimation since the address of each block's prediction was recorded by
;                               MotionEstimation.  It's only used by B-frame processing.
;
;   FutureFrameBaseAddress -- Address of the reconstructed future (a.k.a. current) P-frame.  Only used when processing
;                             B frames.
;
;   CoeffStream (Output)
;
;     A stream of storage blocks which receive the DCT output coefficient
;     blocks for each non-empty blocks described in the MBlockActionStream.
;     Each coefficient block is 128 bytes.  The stream must be large enough
;     to hold all the output coefficient blocks.
;
;     Best performance will be attained by assuring the storage is 32-byte
;     aligned.  Best performance will be attained by using the output before
;     the data cache gets changed by other data.  Consuming the coefficient
;     blocks in forward order is best, since they are defined in reverse
;     order (and thus the first blocks are most likely to be in cache).
;
;     The complete format of the coefficient blocks is provided in encdctc.inc.
;
;   IsBFrame (Input)
;
;     0 (False) if doing Key or P frame.  1 (True) if doing B frame.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc   ; Encoder instance data
include e3mbad.inc   ; MacroBlock Action Descriptor struct layout
include e3dctc.inc   ; DCT Coefficient block layout

.xlist
include memmodel.inc
.list
.DATA

InitTbl MACRO WeightHi,WeightLo,TableLabel
TableLabel LABEL DWORD
  CNT = -128
  REPEAT 128
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)+((WeightLo*CNT-08000H)/010000H)
   DWORD ((WeightHi*CNT-08000H)/010000H*010000H)-((WeightLo*CNT-08000H)/010000H)
   CNT = CNT + 1
  ENDM
  REPEAT 128
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)+((WeightLo*CNT+08000H)/010000H)
   DWORD ((WeightHi*CNT+08000H)/010000H*010000H)-((WeightLo*CNT+08000H)/010000H)
   CNT = CNT + 1
  ENDM
ENDM

InitTbl  080000H,04545FH,P80000_P4545F
P80000_N4545F = P80000_P4545F + 4

InitTbl  080000H,0A73D7H,P80000_PA73D7
P80000_NA73D7 = P80000_PA73D7 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl  02350BH, 06491AH,P2350B_P6491A
P2350B_N6491A = P2350B_P6491A + 4

InitTbl -0B18A8H,-096831H,NB18A8_N96831
NB18A8_P96831 = NB18A8_N96831 + 4

BYTE 680 DUP (?)  ; To assure that tables interleave nicely in cache.

InitTbl -096831H, 02350BH,N96831_P2350B
N96831_N2350B = N96831_P2350B + 4

InitTbl 06491AH, 0B18A8H,P6491A_PB18A8
P6491A_NB18A8 = P6491A_PB18A8 + 4


ColsDefined        DD 000000000H,000000000H,07F7F7F7FH,07F7F7F7FH
                   DD 000000000H,07F7F7F00H,07F7F7F7FH,00000007FH
                   DD 000000000H,07F7F0000H,07F7F7F7FH,000007F7FH
                   DD 000000000H,07F000000H,07F7F7F7FH,0007F7F7FH,000000000H

                           ;  Right   Left  Chroma
                   DB   0  ;         -22.0
                   DB   0  ;         -21.5
                   DB   0  ;         -21.0
                   DB   0  ;         -20.5
                   DB   0  ;         -20.0
                   DB   0  ;         -19.5
                   DB   0  ;         -19.0
                   DB   0  ;         -18.5
                   DB   0  ;         -18.0
                   DB   0  ;         -17.5
                   DB   0  ;         -17.0
                   DB   0  ;         -16.5
                   DB   0  ;         -16.0
                   DB   0  ;         -15.5
                   DB   0  ;         -15.0
                   DB   0  ;         -14.5
                   DB   0  ;  -22.0  -14.0
                   DB   0  ;  -21.5  -13.5
                   DB   0  ;  -21.0  -13.0
                   DB   0  ;  -20.5  -12.5
                   DB   0  ;  -20.0  -12.0
                   DB   0  ;  -19.5  -11.5
                   DB   0  ;  -19.0  -11.0
                   DB   0  ;  -18.5  -10.5
                   DB   0  ;  -18.0  -10.0
                   DB   0  ;  -17.5   -9.5
                   DB   0  ;  -17.0   -9.0
                   DB   0  ;  -16.5   -8.5
                   DB   0  ;  -16.0   -8.0
                   DB   0  ;  -15.5   -7.5
                   DB  48  ;  -15.0   -7.0
                   DB  48  ;  -14.5   -6.5
                   DB  32  ;  -14.0   -6.0
                   DB  32  ;  -13.5   -5.5
                   DB  16  ;  -13.0   -5.0
                   DB  16  ;  -12.5   -4.5
                   DB   4  ;  -12.0   -4.0
                   DB   4  ;  -11.5   -3.5
                   DB  52  ;  -11.0   -3.0
                   DB  52  ;  -10.5   -2.5
                   DB  36  ;  -10.0   -2.0
                   DB  36  ;   -9.5   -1.5
                   DB  20  ;   -9.0   -1.0
                   DB  20  ;   -8.5    -.5
LeftYBlkColsDef    DB   8  ;   -8.0      0
                   DB   8  ;   -7.5     .5
                   DB   8  ;   -7.0    1.0
                   DB   8  ;   -6.5    1.5
                   DB   8  ;   -6.0    2.0
                   DB   8  ;   -5.5    2.5
                   DB   8  ;   -5.0    3.0
                   DB   8  ;   -4.5    3.5
                   DB   8  ;   -4.0    4.0
                   DB   8  ;   -3.5    4.5
                   DB   8  ;   -3.0    5.0
                   DB   8  ;   -2.5    5.5
                   DB   8  ;   -2.0    6.0
                   DB   8  ;   -1.5    6.5
                   DB   8  ;   -1.0    7.0
                   DB   8  ;    -.5    7.5
RightYBlkColsDef   DB   8  ;      0    8.0
                   DB  56  ;     .5    8.5
                   DB  56  ;    1.0    9.0
                   DB  40  ;    1.5    9.5
                   DB  40  ;    2.0   10.0
                   DB  24  ;    2.5   10.5
                   DB  24  ;    3.0   11.0
                   DB  12  ;    3.5   11.5
                   DB  12  ;    4.0   12.0
                   DB  60  ;    4.5   12.5
                   DB  60  ;    5.0   13.0
                   DB  44  ;    5.5   13.5
                   DB  44  ;    6.0   14.0
                   DB  28  ;    6.5   14.5
                   DB  28  ;    7.0   15.0
                   DB   0  ;    7.5   15.5
                   DB   0  ;    8.0   16.0
                   DB   0  ;    8.5   16.5
                   DB   0  ;    9.0   17.0
                   DB   0  ;    9.5   17.5
                   DB   0  ;   10.0   18.0
                   DB   0  ;   10.5   18.5
                   DB   0  ;   11.0   19.0
                   DB   0  ;   11.5   19.5
                   DB   0  ;   12.0   20.0
                   DB   0  ;   12.5   20.5
                   DB   0  ;   13.0   21.0
                   DB   0  ;   13.5   21.5
                   DB   0  ;   14.0   22.0
                   DB   0  ;   14.5
                   DB   0  ;   15.0
                   DB   0  ;   15.5
                   DB   0  ;   16.0
                   DB   0  ;   16.5
                   DB   0  ;   17.0
                   DB   0  ;   17.5
                   DB   0  ;   18.0
                   DB   0  ;   18.5         -11.0
                   DB   0  ;   19.0         -10.5
                   DB   0  ;   19.5         -10.0
                   DB   0  ;   20.0          -9.5
                   DB   0  ;   20.5          -9.0
                   DB   0  ;   21.0          -8.5
                   DB   0  ;   21.5          -8.0
                   DB   0  ;   22.0          -7.5
                   DB  48  ;                 -7.0
                   DB  48  ;                 -6.5
                   DB  32  ;                 -6.0
                   DB  32  ;                 -5.5
                   DB  16  ;                 -5.0
                   DB  16  ;                 -4.5
                   DB   4  ;                 -4.0
                   DB   4  ;                 -3.5
                   DB  52  ;                 -3.0
                   DB  52  ;                 -2.5
                   DB  36  ;                 -2.0
                   DB  36  ;                 -1.5
                   DB  20  ;                 -1.0
                   DB  20  ;                  -.5
ChromaColsDef      DB   8  ;                    0
                   DB  56  ;                   .5
                   DB  56  ;                  1.0
                   DB  40  ;                  1.5
                   DB  40  ;                  2.0
                   DB  24  ;                  2.5
                   DB  24  ;                  3.0
                   DB  12  ;                  3.5
                   DB  12  ;                  4.0
                   DB  60  ;                  4.5
                   DB  60  ;                  5.0
                   DB  44  ;                  5.5
                   DB  44  ;                  6.0
                   DB  28  ;                  6.5
                   DB  28  ;                  7.0
                   DB   0  ;                  7.5
                   DB   0  ;                  8.0
                   DB   0  ;                  8.5
                   DB   0  ;                  9.0
                   DB   0  ;                  9.5
                   DB   0  ;                 10.0
                   DB   0  ;                 10.5
                   DB   0  ;                 11.0

                           ;  Lower  Upper  Chroma
                   DB 000H ;         -22.0
                   DB 000H ;         -21.5
                   DB 000H ;         -21.0
                   DB 000H ;         -20.5
                   DB 000H ;         -20.0
                   DB 000H ;         -19.5
                   DB 000H ;         -19.0
                   DB 000H ;         -18.5
                   DB 000H ;         -18.0
                   DB 000H ;         -17.5
                   DB 000H ;         -17.0
                   DB 000H ;         -16.5
                   DB 000H ;         -16.0
                   DB 000H ;         -15.5
                   DB 000H ;         -15.0
                   DB 000H ;         -14.5
                   DB 000H ;  -22.0  -14.0
                   DB 000H ;  -21.5  -13.5
                   DB 000H ;  -21.0  -13.0
                   DB 000H ;  -20.5  -12.5
                   DB 000H ;  -20.0  -12.0
                   DB 000H ;  -19.5  -11.5
                   DB 000H ;  -19.0  -11.0
                   DB 000H ;  -18.5  -10.5
                   DB 000H ;  -18.0  -10.0
                   DB 000H ;  -17.5   -9.5
                   DB 000H ;  -17.0   -9.0
                   DB 000H ;  -16.5   -8.5
                   DB 000H ;  -16.0   -8.0
                   DB 000H ;  -15.5   -7.5
                   DB 001H ;  -15.0   -7.0
                   DB 001H ;  -14.5   -6.5
                   DB 003H ;  -14.0   -6.0
                   DB 003H ;  -13.5   -5.5
                   DB 007H ;  -13.0   -5.0
                   DB 007H ;  -12.5   -4.5
                   DB 00FH ;  -12.0   -4.0
                   DB 00FH ;  -11.5   -3.5
                   DB 01FH ;  -11.0   -3.0
                   DB 01FH ;  -10.5   -2.5
                   DB 03FH ;  -10.0   -2.0
                   DB 03FH ;   -9.5   -1.5
                   DB 07FH ;   -9.0   -1.0
                   DB 07FH ;   -8.5    -.5
UpperYBlkLinesDef  DB 0FFH ;   -8.0      0
                   DB 0FFH ;   -7.5     .5
                   DB 0FFH ;   -7.0    1.0
                   DB 0FFH ;   -6.5    1.5
                   DB 0FFH ;   -6.0    2.0
                   DB 0FFH ;   -5.5    2.5
                   DB 0FFH ;   -5.0    3.0
                   DB 0FFH ;   -4.5    3.5
                   DB 0FFH ;   -4.0    4.0
                   DB 0FFH ;   -3.5    4.5
                   DB 0FFH ;   -3.0    5.0
                   DB 0FFH ;   -2.5    5.5
                   DB 0FFH ;   -2.0    6.0
                   DB 0FFH ;   -1.5    6.5
                   DB 0FFH ;   -1.0    7.0
                   DB 0FFH ;    -.5    7.5
LowerYBlkLinesDef  DB 0FFH ;      0    8.0
                   DB 0FEH ;     .5    8.5
                   DB 0FEH ;    1.0    9.0
                   DB 0FCH ;    1.5    9.5
                   DB 0FCH ;    2.0   10.0
                   DB 0F8H ;    2.5   10.5
                   DB 0F8H ;    3.0   11.0
                   DB 0F0H ;    3.5   11.5
                   DB 0F0H ;    4.0   12.0
                   DB 0E0H ;    4.5   12.5
                   DB 0E0H ;    5.0   13.0
                   DB 0C0H ;    5.5   13.5
                   DB 0C0H ;    6.0   14.0
                   DB 080H ;    6.5   14.5
                   DB 080H ;    7.0   15.0
                   DB 000H ;    7.5   15.5
                   DB 000H ;    8.0   16.0
                   DB 000H ;    8.5   16.5
                   DB 000H ;    9.0   17.0
                   DB 000H ;    9.5   17.5
                   DB 000H ;   10.0   18.0
                   DB 000H ;   10.5   18.5
                   DB 000H ;   11.0   19.0
                   DB 000H ;   11.5   19.5
                   DB 000H ;   12.0   20.0
                   DB 000H ;   12.5   20.5
                   DB 000H ;   13.0   21.0
                   DB 000H ;   13.5   21.5
                   DB 000H ;   14.0   22.0
                   DB 000H ;   14.5
                   DB 000H ;   15.0
                   DB 000H ;   15.5
                   DB 000H ;   16.0
                   DB 000H ;   16.5
                   DB 000H ;   17.0
                   DB 000H ;   17.5
                   DB 000H ;   18.0
                   DB 000H ;   18.5         -11.0
                   DB 000H ;   19.0         -10.5
                   DB 000H ;   19.5         -10.0
                   DB 000H ;   20.0          -9.5
                   DB 000H ;   20.5          -9.0
                   DB 000H ;   21.0          -8.5
                   DB 000H ;   21.5          -8.0
                   DB 000H ;   22.0          -7.5
                   DB 001H ;                 -7.0
                   DB 001H ;                 -6.5
                   DB 003H ;                 -6.0
                   DB 003H ;                 -5.5
                   DB 007H ;                 -5.0
                   DB 007H ;                 -4.5
                   DB 00FH ;                 -4.0
                   DB 00FH ;                 -3.5
                   DB 01FH ;                 -3.0
                   DB 01FH ;                 -2.5
                   DB 03FH ;                 -2.0
                   DB 03FH ;                 -1.5
                   DB 07FH ;                 -1.0
                   DB 07FH ;                  -.5
ChromaLinesDef     DB 0FFH ;                    0
                   DB 0FEH ;                   .5
                   DB 0FEH ;                  1.0
                   DB 0FCH ;                  1.5
                   DB 0FCH ;                  2.0
                   DB 0F8H ;                  2.5
                   DB 0F8H ;                  3.0
                   DB 0F0H ;                  3.5
                   DB 0F0H ;                  4.0
                   DB 0E0H ;                  4.5
                   DB 0E0H ;                  5.0
                   DB 0C0H ;                  5.5
                   DB 0C0H ;                  6.0
                   DB 080H ;                  6.5
                   DB 080H ;                  7.0
                   DB 000H ;                  7.5
                   DB 000H ;                  8.0
                   DB 000H ;                  8.5
                   DB 000H ;                  9.0
                   DB 000H ;                  9.5
                   DB 000H ;                 10.0
                   DB 000H ;                 10.5
                   DB 000H ;                 11.0


.CODE

;ASSUME cs : FLAT
;ASSUME ds : FLAT
;ASSUME es : FLAT
;ASSUME fs : FLAT
;ASSUME gs : FLAT
;ASSUME ss : FLAT

FORWARDDCT proc C AMBlockActionStream:       DWORD,
ATargetFrameBaseAddress: DWORD, APreviousFrameBaseAddress: DWORD, 
AFutureFrameBaseAddress: DWORD, ACoeffStream: DWORD, AIsBFrame: DWORD,
AIsAdvancedPrediction: DWORD, AIsPOfPBPair: DWORD, AScratchBlocks: DWORD,
ANumMBlksInGOB: DWORD

LocalFrameSize = 196
RegisterStorageSize = 16

; Arguments:

MBlockActionStream                    = RegisterStorageSize +  4
TargetFrameBaseAddress_arg            = RegisterStorageSize +  8
PreviousFrameBaseAddress_arg          = RegisterStorageSize + 12
FutureFrameBaseAddress_arg            = RegisterStorageSize + 16
CoeffStream_arg                       = RegisterStorageSize + 20
IsBFrame                              = RegisterStorageSize + 24
IsAdvancedPrediction                  = RegisterStorageSize + 28
IsPOfPBPair                           = RegisterStorageSize + 32
ScratchBlocks                         = RegisterStorageSize + 36
NumMBlksInGOB                         = RegisterStorageSize + 40
EndOfArgList                          = RegisterStorageSize + 44

; Locals (on local stack frame)

P00                      EQU [esp+  8] ; Biased Pels or Biased Pel Differences
P01                      EQU [esp+  9]
P02                      EQU [esp+ 10]
P03                      EQU [esp+ 11]
P04                      EQU [esp+ 12]
P05                      EQU [esp+ 13]
P06                      EQU [esp+ 14]
P07                      EQU [esp+ 15]
P10                      EQU [esp+ 16]
P11                      EQU [esp+ 17]
P12                      EQU [esp+ 18]
P13                      EQU [esp+ 19]
P14                      EQU [esp+ 20]
P15                      EQU [esp+ 21]
P16                      EQU [esp+ 22]
P17                      EQU [esp+ 23]
P20                      EQU [esp+ 24]
P21                      EQU [esp+ 25]
P22                      EQU [esp+ 26]
P23                      EQU [esp+ 27]
P24                      EQU [esp+ 28]
P25                      EQU [esp+ 29]
P26                      EQU [esp+ 30]
P27                      EQU [esp+ 31]
P30                      EQU [esp+ 32]
P31                      EQU [esp+ 33]
P32                      EQU [esp+ 34]
P33                      EQU [esp+ 35]
P34                      EQU [esp+ 36]
P35                      EQU [esp+ 37]
P36                      EQU [esp+ 38]
P37                      EQU [esp+ 39]
P40                      EQU [esp+ 40]
P41                      EQU [esp+ 41]
P42                      EQU [esp+ 42]
P43                      EQU [esp+ 43]
P44                      EQU [esp+ 44]
P45                      EQU [esp+ 45]
P46                      EQU [esp+ 46]
P47                      EQU [esp+ 47]
P50                      EQU [esp+ 48]
P51                      EQU [esp+ 49]
P52                      EQU [esp+ 50]
P53                      EQU [esp+ 51]
P54                      EQU [esp+ 52]
P55                      EQU [esp+ 53]
P56                      EQU [esp+ 54]
P57                      EQU [esp+ 55]
P60                      EQU [esp+ 56]
P61                      EQU [esp+ 57]
P62                      EQU [esp+ 58]
P63                      EQU [esp+ 59]
P64                      EQU [esp+ 60]
P65                      EQU [esp+ 61]
P66                      EQU [esp+ 62]
P67                      EQU [esp+ 63]
P70                      EQU [esp+ 64]
P71                      EQU [esp+ 65]
P72                      EQU [esp+ 66]
P73                      EQU [esp+ 67]
P74                      EQU [esp+ 68]
P75                      EQU [esp+ 69]
P76                      EQU [esp+ 70]
P77                      EQU [esp+ 71]
I00I02                   EQU  P00  ; Intermed for row 0, columns 0 and 2. 
I01I03                   EQU  P04  ; Share storage with pels.
I04I06                   EQU [esp+ 72]
Mask00                   EQU [esp+ 72]
I07I05                   EQU [esp+ 76]
Mask04                   EQU [esp+ 76]
I10I12                   EQU  P10
I11I13                   EQU  P14
I14I16                   EQU [esp+ 80]
Mask10                   EQU [esp+ 80]
I17I15                   EQU [esp+ 84]
Mask14                   EQU [esp+ 84]
I20I22                   EQU  P20
I21I23                   EQU  P24
I24I26                   EQU [esp+ 88]
Mask20                   EQU [esp+ 88]
I27I25                   EQU [esp+ 92]
Mask24                   EQU [esp+ 92]
I30I32                   EQU  P30
I31I33                   EQU  P34
I34I36                   EQU [esp+ 96]
Mask30                   EQU [esp+ 96]
I37I35                   EQU [esp+100]
Mask34                   EQU [esp+100]
I40I42                   EQU  P40
I41I43                   EQU  P44
I44I46                   EQU [esp+104]
Mask40                   EQU [esp+104]
I47I45                   EQU [esp+108]
Mask44                   EQU [esp+108]
I50I52                   EQU  P50
I51I53                   EQU  P54
I54I56                   EQU [esp+112]
Mask50                   EQU [esp+112]
I57I55                   EQU [esp+116]
Mask54                   EQU [esp+116]
I60I62                   EQU  P60
I61I63                   EQU  P64
I64I66                   EQU [esp+120]
Mask60                   EQU [esp+120]
I67I65                   EQU [esp+124]
Mask64                   EQU [esp+124]
I70I72                   EQU  P70
I71I73                   EQU  P74
I74I76                   EQU [esp+128]
Mask70                   EQU [esp+128]
I77I75                   EQU [esp+132]
Mask74                   EQU [esp+132]
S4                       EQU  I10I12  ; Temp storage, shared.
S7                       EQU  I00I02  ; Temp storage, shared.
S3                       EQU  I30I32  ; Temp storage, shared.
S0                       EQU  I40I42  ; Temp storage, shared.

CoeffStreamStart         EQU [esp+  0]
CoeffStream              EQU [esp+  4]
BlkActionDescrAddr       EQU [esp+136]
FutureFrameBaseAddress   EQU [esp+140]
DistFromTargetToPastP    EQU [esp+144]
TargetFrameBaseAddress   EQU [esp+148]
PredictionsBaseAddress   EQU [esp+152]
IsPlainPFrame            EQU [esp+156]
PreviousFrameBaseAddress EQU [esp+160]
DistToBlockToLeft        EQU [esp+164]
DistToBlockAbove         EQU [esp+168]
DistToBlockToRight       EQU [esp+172]
DistToBlockBelow         EQU [esp+176]
DistFromBlk1ToBlk3Above  EQU [esp+180]
MBActionCursor           EQU [esp+184]
CentralRefAddrAndInterps EQU [esp+188]
StashESP                 EQU [esp+192]

  push  esi
   push edi
  push  ebp
   push ebx
  mov   ebx,esp
  sub   esp,LocalFrameSize+4
   mov  edi,[ebx+CoeffStream_arg]           ; Get address of storage for coeffs.
  and   esp,0FFFFFFC0H                      ; Get 64-byte aligned.
   xor  ebp,ebp
  add   esp,4                               ; esp at cache line plus 4.
   mov  esi,[ebx+MBlockActionStream]        ; Get address of MB action stream.
  mov   StashESP,ebx
   mov  edx,[ebx+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,edx
   mov  eax,[ebx+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,eax
   sub  eax,edx
  mov   ecx,[ebx+FutureFrameBaseAddress_arg]
  mov   FutureFrameBaseAddress,ecx
   mov  DistFromTargetToPastP,eax
  mov   CoeffStreamStart,edi
   xor  eax,eax
  xor   ecx,ecx

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
   cmp  ebp,[ebx+IsBFrame]
  mov   edx,PITCH
   jne  NextBMacroBlock

  cmp   ebp,[ebx+IsAdvancedPrediction]
   je   NextMacroBlock

  mov   eax,[ebx+ScratchBlocks]   ; We must do OBMC.
   mov  ecx,[esi].BlkY1.BlkOffset
  sub   eax,ecx
   mov  ebp,[ebx+IsPOfPBPair]
  xor   ebp,1
   mov  PredictionsBaseAddress,eax
  mov   IsPlainPFrame,ebp
   mov  ebp,[ebx+NumMBlksInGOB]
  imul  ebp,-SIZEOF T_MacroBlockActionDescr
  add   ebp,2*SIZEOF T_Blk
  mov   DistFromBlk1ToBlk3Above,ebp
  

;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  edx -- Address of a block to do
;  bl  -- BlockType;
;         MB edge condition:  1 off if left edge | 2: right | 4: top | 8: bottom
;  eax -- Coded block pattern for P block;
;         (Block_number - 1) *  SIZEOF T_Blk

NextMacroBlock_OBMC:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks        ; Bits  0- 3  set for non-empty Y blks.
                                       ; Bit      4  set for non-empty U blk.
                                       ; Bit      5  set for non-empty V blk.
                                       ; Bit      6  clear except at stream end.
                                       ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded_OBMC

  lea   edx,[esi].BlkY1+12             ; Addr of block addr (plus 12).
   test al,1                           ; Check if block 1 empty.
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block1DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax           ; Blk to left is blk 2 of mb to the left, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToLeft,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 2 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 3 of current macroblock.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY1
   jmp  BuildOBMCPrediction

Block1DescrBuilt:

  test  al,2                           ; Check if block 2 empty.
   lea  edx,[esi].BlkY2+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block2DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   ecx,eax          ; Blk to right is blk 1 of mb to right, or off edge.
   mov  al,[esi].MBEdgeType
  shl   eax,29
   mov  DistToBlockToRight,ecx
  sar   eax,31
   mov  ecx,DistFromBlk1ToBlk3Above
  and   ecx,eax           ; Blk above is in macroblock above, or off upper edge.
   mov  eax,-SIZEOF T_Blk ; Blk to left is blk 1 of current macroblock.
  mov   DistToBlockAbove,ecx
   mov  ecx,2*SIZEOF T_Blk; Blk below is blk 4 of current macroblock.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY2
   jmp  BuildOBMCPrediction

Block1or2DescrBuilt:

  mov   al,PB [esi].CodedBlocks         ; Bits  0- 3  set for non-empty Y blks.
   mov  edi,CoeffStream                 ; Restore block descriptor ptr.
  jl    Block1DescrBuilt

Block2DescrBuilt:

  test  al,4                           ; Check if block 3 empty.
   lea  edx,[esi].BlkY3+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block3DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,31
   mov  ecx,-SIZEOF T_MacroBlockActionDescr + SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to left is blk 4 of mb to the left, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 1 of current mb.
  mov   DistToBlockToLeft,eax
   mov  eax,SIZEOF T_Blk  ; Blk to right is blk 4 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToRight,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY3
   jmp  BuildOBMCPrediction

Block3DescrBuilt:

  test  al,8                           ; Check if block 4 empty.
   lea  edx,[esi].BlkY4+12             ; Addr of block addr (plus 12).
  mov   [edi].BlockAddr,edx            ; Store address of block address.
   je   Block4DescrBuilt

  mov   al,[esi].MBEdgeType
   add  edi,T_CoeffBlk                 ; Advance block descriptor ptr.
  shl   eax,30
   mov  ecx,SIZEOF T_MacroBlockActionDescr - SIZEOF T_Blk
  sar   eax,31
   mov  CoeffStream,edi                ; Stash block descriptor ptr.
  and   eax,ecx           ; Blk to right is blk 3 of mb to right, or off edge.
   mov  ecx,-2*SIZEOF T_Blk ; Blk above is blk 2 of current mb.
  mov   DistToBlockToRight,eax
   mov  eax,-SIZEOF T_Blk  ; Blk to left is blk 3 of current macroblock.
  mov   DistToBlockAbove,ecx
   xor  ecx,ecx           ; Blk below is current block.
  mov   DistToBlockToLeft,eax
   mov  DistToBlockBelow,ecx
  mov   ebp,T_MacroBlockActionDescr.BlkY4

BuildOBMCPrediction:

;  esi -- MacroBlockActionStream cursor
;  ebp -- T_MacroBlockActionDescr.BlkYN
;  edi -- Address at which to put prediction block

  mov   edi,PredictionsBaseAddress
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset; BlkOffset
  add   edi,eax                        ; Compute addr at which to put OBMC pred.
   mov  eax,[esi+ebp*1].T_Blk.MVs      ; al = horz MV;  ah = vert MV.
  test  eax,1
   mov  edx,[esi+ebp*1].T_Blk.PastRef  ; Fetch address for ref block.
  mov   MBActionCursor,esi
   jne  HorzInterpInCentralPred

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,PITCH
   jne  VertInterpInCentralPred

  ; No half pel interpolation for central point required.  Just copy it.

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8-080000000H    ; Address of ref, xor 10 in high 2 bits.
  jmp   CentralPredGottenForOBMC

HorzInterpInCentralPred:

  mov   [esi+ebp*1].T_Blk.PastRef,edi  ; Update address for ref block.
   test eax,0100H
  mov   ecx,1
   jne  BothInterpInCentralPred

VertInterpInCentralPred:

@@:

  mov   eax,[edx+0]
   mov  ebx,[edx+4]
  add   eax,[edx+ecx+0]
   add  ebx,[edx+ecx+4]
  add   eax,001010101H
   add  ebx,001010101H
  shr   eax,1
   and  ebx,0FEFEFEFEH
  shr   ebx,1
   and  eax,07F7F7F7FH
  mov   [edi+ 0],eax
   mov  [edi+ 4],ebx
  mov   [edi+ 8],eax
   mov  [edi+12],ebx
  mov   [edi+28],eax
   mov  [edi+32],ebx
  add   edx,PITCH
   add  edi,PITCH
  add   ebp,020000000H
   jnc  @b

  sub   edi,PITCH*8
   sub  edx,PITCH*8
  shl   ecx,30
  xor   edx,ecx            ; Address of ref, xor 00 in high 2 bits if vertically
  ;                        ; interpolated;  xor 01 if horizontally interpolated.
   jmp  CentralPredGottenForOBMC

BothInterpInCentralPred:
@@:
   
  mov   eax,[edx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[edx]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment OBMC prediction block pointer.
  mov   ecx,[edx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[edx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,ecx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  edx,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  eax,4
  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   and  eax,edi
  mov   [edi-4],ebx
   mov  [edi+8-4],ebx
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8         ; Advance to next line of block.
   add  edx,PITCH-8         ; Advance to next line of block.
  add   ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
   jnc  @b

   sub  edx,PITCH*8
  xor   edx,0C0000000H      ; Address of ref, xor 11 in high 2 bits.
   sub  edi,PITCH*8

CentralPredGottenForOBMC:

;  At this point, the central contribution to OBMC prediction is in its scratch
;  block, whose address has been written to PastRef in the block action descr.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to left.

  mov   eax,DistToBlockToLeft
   lea  ebx,[esi+ebp]
  add   ebx,eax            ; Address of block descriptor for block to the left.
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx            ; Address of macroblock descr for block to the left.
   mov  ah,IsPlainPFrame   ; 0 if P of PB;  1 if run-of-the-mill P frame.
  mov   ebx,[ebx].T_Blk.MVs
   mov  CentralRefAddrAndInterps,edx  ; Stash function of ref addr and interps.
  mov   al,[ecx].BlockType ; Bottom bit set if left neighbor is INTRA.
   mov  cl,bh
  and   al,ah              ; 0 if PB frame or if not INTRA
   jne  LeftPredGottenForOBMC  ; Jump if INTRA in plain P frame.  (Use central)
   
  shl   ebx,24             ; Get horz MV in [24:31].
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1              ; CF==1 if interp vertically.
   jc   InterpVertForTheLeftContrib

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpHorzForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,080000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also was not interpolated.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0]
  mov   [edi+PITCH*0+8],ebx
   mov  ebx,[ecx+PITCH*1]
  mov   [edi+PITCH*1+8],ebx
   mov  ebx,[ecx+PITCH*2]
  mov   [edi+PITCH*2+8],ebx
   mov  ebx,[ecx+PITCH*3]
  mov   [edi+PITCH*3+8],ebx
   mov  ebx,[ecx+PITCH*4]
  mov   [edi+PITCH*4+8],ebx
   mov  ebx,[ecx+PITCH*5]
  mov   [edi+PITCH*5+8],ebx
   mov  ebx,[ecx+PITCH*6]
  mov   [edi+PITCH*6+8],ebx
   mov  ebx,[ecx+PITCH*7]
  mov   [edi+PITCH*7+8],ebx
   jmp  LeftPredGottenForOBMC

InterpVertForTheLeftContrib:

  shl   ecx,25
  sar   ebx,25             ; Sign extend horz MV.  CF==1 if interp horizontally.
   jc   InterpBothForTheLeftContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax            ; Continue to accumulate left ref addr in eax.
  ;                        ; Hi 2 bits of central ref same as this ref if
  ;                        ; central ref also interpolated vertically.
  add   ecx,ebx            ; Finish accumulating left ref addr in ecx.
   mov  ebx,PITCH
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

DoInterpHorzForTheLeftContrib:
@@:

  mov   eax,[ecx+0]
   add  edi,PITCH
  mov   edx,[ecx+ebx+0]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+ 8-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpBothForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,0C0000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated both ways.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
  cmp   ecx,edx            ; Is central ref the same?
   je   LeftPredGottenForOBMC

@@:

  mov   eax,[ecx+1]         ; <P04 P03 P02 P01> prediction pels.
   mov  esi,001010101H      ; Get 001010101H mask.
  mov   ebx,[ecx]           ; <P03 P02 P01 P00>.
   add  edi,PITCH           ; Pre-increment OBMC prediction block pointer.
  mov   edx,[ecx+PITCH+1]   ; <P14 P13 P12 P11>.
   add  eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
  mov   ebx,[ecx+PITCH]     ; <P13 P12 P11 P10>.
   and  esi,eax             ; <(P04+P03)&1 ...>.
  shr   eax,1               ; <(P04+P03)/2 ...> (dirty).
   add  ebx,edx             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  and   eax,07F7F7F7FH      ; <(P04+P03)/2 ...> (clean).
   add  ebx,esi             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  ecx,PITCH           ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>.
  add   ebx,eax             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.

  shr   ebx,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  esi,MBActionCursor  ; Speculatively restore esi.
  and   ebx,07F7F7F7FH      ; Interpolated prediction.
   add  ebp,020000000H      ; Iterate 8 times.  Quit when carry flag gets set.
  mov   [edi+8-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  LeftPredGottenForOBMC

InterpHorzForTheLeftContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]    ; Multiply vert by 3 (to affect mult by 384)
   add  eax,ebx            ; Start accumulating left ref addr in eax.
  sar   ecx,18             ; Sign extend vert MV.  It's now linearized.
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx            ; Continue to accumulate left ref addr in eax.
   xor  edx,040000000H     ; Hi 2 bits of central ref same as this ref if
   ;                       ; central ref also interpolated horizontally.
  add   ecx,eax            ; Finish accumulating left ref addr in ecx.
   mov  ebx,1
  cmp   ecx,edx            ; Is central ref the same?
   jne  DoInterpHorzForTheLeftContrib


LeftPredGottenForOBMC:

;  At this point, the left contribution to OBMC prediction is in its scratch
;  half block.  Now do the right contribution.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block to right.

  mov   eax,DistToBlockToRight
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps  ; Reload function of ref addr and interps.
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  RightPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheRightContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

  mov   ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+12],ebx
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+12],ebx
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+12],ebx
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+12],ebx
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+12],ebx
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+12],ebx
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+12],ebx
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+12],ebx
   jmp  RightPredGottenForOBMC

InterpVertForTheRightContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheRightContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   RightPredGottenForOBMC

DoInterpHorzForTheRightContrib:
@@:

  mov   eax,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+ebx+4]
   add  eax,001010101H
  add   eax,edx
   add  ecx,PITCH
  shr   eax,1
   ;
  and   eax,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],eax
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpBothForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   RightPredGottenForOBMC

@@:

  mov   eax,[ecx+5]
   mov  esi,001010101H
  mov   ebx,[ecx+4]
   add  edi,PITCH
  mov   edx,[ecx+PITCH+5]
   add  eax,ebx
  mov   ebx,[ecx+PITCH+4]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,PITCH
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax

  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   add  ebp,020000000H
  mov   [edi+12-PITCH],ebx
   jnc  @b

  sub   edi,PITCH*8
   jmp  RightPredGottenForOBMC

InterpHorzForTheRightContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheRightContrib

RightPredGottenForOBMC:

;  At this point, the left and right contributions to OBMC prediction are in
;  their scratch half blocks.  Now do the contribution for the block above.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockAbove
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  AbovePredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheAboveContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

  mov   edx,[ecx+PITCH*0+0]
   mov  ebx,[ecx+PITCH*0+4]
  mov   [edi+PITCH*0+28],edx
   mov  [edi+PITCH*0+32],ebx
  mov   edx,[ecx+PITCH*1+0]
   mov  ebx,[ecx+PITCH*1+4]
  mov   [edi+PITCH*1+32],ebx
   mov  [edi+PITCH*1+28],edx
  mov   edx,[ecx+PITCH*2+0]
   mov  ebx,[ecx+PITCH*2+4]
  mov   [edi+PITCH*2+28],edx
   mov  [edi+PITCH*2+32],ebx
  mov   edx,[ecx+PITCH*3+0]
   mov  ebx,[ecx+PITCH*3+4]
  mov   [edi+PITCH*3+32],ebx
   mov  [edi+PITCH*3+28],edx
  jmp   AbovePredGottenForOBMC

InterpVertForTheAboveContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheAboveContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   ebx,eax
  add   ecx,ebx
   mov  ebx,PITCH
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

DoInterpHorzForTheAboveContrib:
@@:

  mov   eax,[ecx+0]
   mov  edx,[ecx+4]
  add   eax,[ecx+ebx+0]
   add  edx,[ecx+ebx+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+28],eax
   mov  [edi+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpBothForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   AbovePredGottenForOBMC

@@:

  mov   eax,[ecx+1]
   mov  esi,001010101H
  mov   ebx,[ecx]
   add  edi,4
  mov   edx,[ecx+PITCH+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  AbovePredGottenForOBMC

InterpHorzForTheAboveContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheAboveContrib

AbovePredGottenForOBMC:

;  At this point, the left, right, and above contributions to OBMC prediction
;  are in their scratch half blocks.  Now do contribution for the block below.
;
;  esi -- MacroBlockActionStream cursor
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
;  edx -- Address of central reference.  High 2 bits xor'ed as follows:
;         00 -- If central ref was interpolated vertically.
;         01 -- If central ref was interpolated horizontally.
;         10 -- If central ref was not interpolated.
;         11 -- If central ref was interpolated both ways.
;  eax -- Offset to block descriptor for block above.

  mov   eax,DistToBlockBelow
   lea  ebx,[esi+ebp]
  add   ebx,eax
   mov  ecx,-SIZEOF T_MacroBlockActionDescr
  and   ecx,ebx
   mov  ah,IsPlainPFrame
  mov   ebx,[ebx].T_Blk.MVs
   mov  edx,CentralRefAddrAndInterps
  mov   al,[ecx].BlockType
   mov  cl,bh
  and   al,ah
   jne  BelowPredGottenForOBMC
   
  shl   ebx,24
   mov  eax,[esi+ebp*1].T_Blk.BlkOffset
  sar   ecx,1
   jc   InterpVertForTheBelowContrib

  shl   ecx,25
  sar   ebx,25
   jc   InterpHorzForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,080000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

  mov   edx,[ecx+PITCH*4+0]
   mov  ebx,[ecx+PITCH*4+4]
  mov   [edi+PITCH*4+28],edx
   mov  [edi+PITCH*4+32],ebx
  mov   edx,[ecx+PITCH*5+0]
   mov  ebx,[ecx+PITCH*5+4]
  mov   [edi+PITCH*5+32],ebx
   mov  [edi+PITCH*5+28],edx
  mov   edx,[ecx+PITCH*6+0]
   mov  ebx,[ecx+PITCH*6+4]
  mov   [edi+PITCH*6+28],edx
   mov  [edi+PITCH*6+32],ebx
  mov   edx,[ecx+PITCH*7+0]
   mov  ebx,[ecx+PITCH*7+4]
  mov   [edi+PITCH*7+32],ebx
   mov  [edi+PITCH*7+28],edx
  jmp   BelowPredGottenForOBMC

InterpVertForTheBelowContrib:

  shl   ecx,25
  sar   ebx,25
   jc   InterpBothForTheBelowContrib

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
  add   ecx,eax
   mov  ebx,PITCH
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

DoInterpHorzForTheBelowContrib:
@@:

  mov   eax,[ecx+PITCH*4+0]
   mov  edx,[ecx+PITCH*4+4]
  add   eax,[ecx+ebx+PITCH*4+0]
   add  edx,[ecx+ebx+PITCH*4+4]
  add   eax,001010101H
   add  edx,001010101H
  shr   eax,1
   and  edx,0FEFEFEFEH
  shr   edx,1
   and  eax,07F7F7F7FH
  mov   [edi+PITCH*4+28],eax
   mov  [edi+PITCH*4+32],edx
  add   ecx,PITCH
   add  edi,PITCH
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpBothForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,0C0000000H
  add   ecx,eax
  cmp   ecx,edx
   je   BelowPredGottenForOBMC

@@:

  mov   eax,[ecx+PITCH*4+1]
   mov  esi,001010101H
  mov   ebx,[ecx+PITCH*4]
   add  edi,4
  mov   edx,[ecx+PITCH*5+1]
   add  eax,ebx
  mov   ebx,[ecx+PITCH*5]
   and  esi,eax
  shr   eax,1
   add  ebx,edx
  and   eax,07F7F7F7FH
   add  ebx,esi
  shr   ebx,1
   add  ecx,4
  and   ebx,07F7F7F7FH
   add  eax,001010101H
  add   ebx,eax
   mov  eax,4
  shr   ebx,1
   mov  esi,MBActionCursor
  and   ebx,07F7F7F7FH
   and  eax,edi
  mov   [edi+PITCH*4+28-4],ebx
   jne  @b

  add   edi,PITCH-8
   add  ecx,PITCH-8
  add   ebp,040000000H
   jnc  @b

  sub   edi,PITCH*4
   jmp  BelowPredGottenForOBMC

InterpHorzForTheBelowContrib:

IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF

  lea   ecx,[ecx+ecx*2]
   add  eax,ebx
  sar   ecx,18
   mov  ebx,PreviousFrameBaseAddress
  add   eax,ebx
   xor  edx,040000000H
  add   ecx,eax
   mov  ebx,1
  cmp   ecx,edx
   jne  DoInterpHorzForTheBelowContrib

BelowPredGottenForOBMC:

;  At this point all the contributions to OBMC prediction are in their scratch
; half blocks.  Now combine them to get the OBMC prediction.
;
;  ebp -- (Block_number - 1) *  SIZEOF T_Blk
;  edi -- Address at which to put prediction block
  
@@:

  mov   eax,[edi+4]             ; <C07 C05 C05 C04> or <C77 C76 C75 C74>
   mov  ebx,[edi+12]            ; <R07 R06 R05 R04> or <R77 R76 R75 R74>
  mov   ecx,[edi+32]            ; <A07 A06 A05 A04> or <B77 B76 B75 B74>
   mov  esi,[edi]               ; <C03 C02 C01 C00> or <C73 C72 C71 C70>
  lea   edx,[eax+ebx]           ; <junk C6+R6 C5+R5 C4+R4>
   and  ebx,0FF000000H          ; <R7 __ __ __>
  shr   edx,1                   ; <junk (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> dirty
   add  ecx,ebx                 ; <A7+R7 A6 A5 A4>
  and   edx,0007F7F7FH          ; <__ (C6+R6)/2 (C5+R5)/2 (C4+R4)/2> clean
   mov  ebx,[edi+8]             ; <L03 L02 L01 L00> or <L73 L72 L71 L70>
  add   edx,ecx                 ; <(2A7+2R7)/2 (2A6+C5+R5)/2 ...>
   add  edi,PITCH*7             ; Move from line 0 to 7 (or 7 to 14)
  shr   edx,1                   ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> dirty
   add  ebx,esi                 ; <C3+L3 C2+L2 C1+L1 junk>
  shr   ebx,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> dirty
   and  edx,07F7F7F7FH          ; <(2A7+2R7)/4 (2A6+C5+R5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 junk> clean
   mov  ecx,[edi+28-PITCH*7]    ; <A03 A02 A01 A00> or <B73 B72 B71 B70>
  lea   eax,[eax+edx+001010101H]; <(2A7+4C7+2R7+4)/4 (2A6+5C5+R5+4)/4 ...>
   mov  bl,[edi+8-PITCH*7]      ; <(C3+L3)/2 (C2+L2)/2 (C1+L1)/2 L0>
  shr   eax,1                   ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> dirty
   add  ebx,ecx                 ; <... (2A1+C1+L1)/2 (2A0+2L0)/2>
  shr   ebx,1                   ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> dirty
   and  eax,07F7F7F7FH          ; <(2A7+4C7+2R7+4)/8 (2A6+5C5+R5+4)/8 ...> clean
  and   ebx,07F7F7F7FH          ; <... (2A1+C1+L1)/4 (2A0+2L0)/4> clean
   add  esi,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  add   ebx,esi                 ; <... (2A1+5C1+L1+4)/4 (2A0+4C0+2L0+4)/4>
   mov  [edi+4-PITCH*7],eax     ; Store OBMC pred for pels 4-7 of line 0 or 7.
  shr   ebx,1                   ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> dirty
   lea  esi,[edi-PITCH*13]      ; Speculatively advance to line 1.
  and   ebx,07F7F7F7FH          ; <... (2A1+5C1+L1+4)/8 (2A0+4C0+2L0+4)/8> clean
   add  ebp,080000000H
  mov   [edi-PITCH*7],ebx       ; Store OBMC pred for pels 0-3 of line 0 or 7.
   jnc  @b

@@:

  mov   edx,[esi+28]            ; <A13 A12 A11 A10> or <B63 B62 B61 B60>
   mov  eax,[esi+8]             ; <L13 L12 L11 L10> or <L63 L62 L61 L60>
  mov   ecx,[esi+32]            ; <A17 A16 A15 A14> or <B67 B66 B65 B64>
   mov  ebx,[esi+12]            ; <R17 R16 R15 R14> or <R67 R66 R65 R64>
  mov   edi,[esi]               ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   add  esi,PITCH*5             ; Move from line 1 to 6 (or 6 to 11)
  xchg  dx,ax                   ; edx: <A3 A2 L1 L0>   eax: <L3 L2 A1 A0>
  xchg  cx,bx                   ; ecx: <A7 A6 R5 R4>   ebx: <R7 R6 A5 A4>
  add   eax,edi                 ; <C3+L3 C2+L2 C1+A1 C0+A0>
   mov  edi,[esi+4-PITCH*5]     ; <C17 C15 C15 C14> or <C67 C66 C65 C64>
  shr   eax,1                   ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   add  ecx,edi                 ; <C7+A7 C6+A6 C5+R5 C4+R4>
  shr   ecx,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>dirty
   and  eax,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 (C1+A1)/2 (C0+A0)/2>clean
  add   eax,edx                 ; <(C3+L3+2A3)/2 ... (C1+2L1+A1)/2 ...>
   and  ecx,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+R5)/2 (C4+R4)/2>clean
  shr   eax,1                   ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,ebx                 ; <(C7+2R7+A7)/2 ... (C5+R5+2A5)/2 ...>
  mov   ebx,[esi-PITCH*5]       ; <C13 C12 C11 C10> or <C63 C62 C61 C60>
   and  eax,07F7F7F7FH          ; <(C3+L3+2A3)/4 ... (C1+2L1+A1)/4 ...> clean
  shr   ecx,1                   ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> dirty
   add  edi,001010101H          ; <C7+1 C6+1 C5+1 C4+1>
  and   ecx,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (C5+R5+2A5)/4 ...> clean
   lea  eax,[eax+ebx+001010101H]; <(5C3+L3+2A3+4)/4 ... (5C1+2L1+A1)/4 ...>
  shr   eax,1                   ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>dirty
   add  ecx,edi                 ; <(5C7+2R7+A7+4)/4 ... (5C5+R5+2A5)/4 ...>
  shr   ecx,1                   ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>dirty
   and  eax,07F7F7F7FH          ; <(5C3+L3+2A3+4)/8 ... (5C1+2L1+A1)/8 ...>clean
  and   ecx,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (5C5+R5+2A5)/8 ...>clean
   mov  [esi-PITCH*5],eax       ; Store OBMC pred for pels 4-7 of line 1 or 6.
  mov   [esi+4-PITCH*5],ecx     ; Store OBMC pred for pels 0-3 of line 1 or 6.
   lea  edi,[esi-PITCH*9]       ; Speculatively advance to line 2.
  add   ebp,080000000H
   jnc  @b

@@:

  mov   eax,[edi+4]             ; <C27 C26 C25 C24> ... <C57 C56 C55 C54>
   mov  ebx,[edi+12]            ; <R27 R26 R25 R24> ... <R57 R56 R55 R54>
  add   bl,al                   ; <R7 R6 R5 C4+R4>
   mov  ecx,[edi]               ; <C23 C22 C21 C20> ... <C53 C52 C51 C50>
  shr   bl,1                    ; <R7 R6 R5 (C4+R4)/2>
   mov  edx,[edi+8]             ; <L23 L22 L21 L20> ... <L53 L52 L51 L50>
  add   bh,ah                   ; <R7 R6 C5+R5 (C4+R4)/2>
   add  edx,ecx                 ; <C3+L3 C2+L2 junk junk>
  shr   bh,1                    ; <2R7/2 2R6/2 (C5+R5)/2 (C4+R4)/2>
   mov  esi,[edi+32]            ; <A27 A26 A25 A24> ... <B57 B56 B55 B54>
  shr   edx,1                   ; <(C3+L3)/2 (C2+L2)/2 junk junk> dirty
   add  esi,eax                 ; <C7+A7 C6+A6 C5+A5 C4+A4>
  shr   esi,1                   ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>dirty
   and  edx,07F7F7F7FH          ; <(C3+L3)/2 (C2+L2)/2 junk junk> clean
  and   esi,07F7F7F7FH          ; <(C7+A7)/2 (C6+A6)/2 (C5+A5)/2 (C4+A4)/2>clean
   mov  dl,[edi+8]              ; <(C3+L3)/2 (C2+L2)/2 junk 2L0/2>
  add   esi,ebx                 ; <(C7+2R7+A7)/2 ... (2C5+R5+A5)/2 ...>
   mov  ebx,[edi+28]            ; <A23 A22 A21 A20> ... <B53 B52 B51 B50>
  shr   esi,1                   ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> dirty
   add  ebx,ecx                 ; <C3+A3 C2+A2 C1+A1 C0+A0>
  shr   ebx,1                   ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>dirty
   and  esi,07F7F7F7FH          ; <(C7+2R7+A7)/4 ... (2C5+R5+A5)/4 ...> clean
  and   ebx,07F7F7F7FH          ; <(C3+A3)/2 (C2+A2)/2 (C1+A1)/2 (C0+A0)/2>clean
   mov  dh,[edi+9]              ; <(C3+L3)/2 (C2+L2)/2 2L1/2 2L0/2>
  add   ebx,edx                 ; <(2C3+L3+A3)/2 ... (C1+2L1+A1)/2 ...>
   lea  eax,[eax+esi+001010101H]; <(5C7+2R7+A7+4)/4 ... (6C5+R5+A5+4)/4 ...>
  shr   ebx,1                   ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> dirty
   add  ecx,001010101H          ; <C3+1 C2+1 C1+1 C0+1>
  shr   eax,1                   ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>dirty
   and  ebx,07F7F7F7FH          ; <(2C3+L3+A3)/4 ... (C1+2L1+A1)/4 ...> clean
  add   ebx,ecx                 ; <(6C3+L3+A3+4)/4 ... (5C1+2L1+A1+4)/4 ...>
   and  eax,07F7F7F7FH          ; <(5C7+2R7+A7+4)/8 ... (6C5+R5+A5+4)/8...>clean
  shr   ebx,1                   ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>dirty
   mov  [edi+4],eax             ; Store OBMC pred for pels 4-7 of line 2 thru 5.
  and   ebx,07F7F7F7FH          ; <(6C3+L3+A3+4)/8 ... (5C1+2L1+A1+4)/8...>clean
   mov  [edi],ebx               ; Store OBMC pred for pels 0-3 of line 2 thru 5.
  add   edi,PITCH               ; Advance to next line.
   add  ebp,040000000H
  jnc   @b

  mov   esi,MBActionCursor
   cmp  ebp,T_MacroBlockActionDescr.BlkY2
  jle   Block1or2DescrBuilt

  mov   al,PB [esi].CodedBlocks
   mov  edi,CoeffStream                ; Restore block descriptor ptr.
  cmp   ebp,T_MacroBlockActionDescr.BlkY3
   je   Block3DescrBuilt

Block4DescrBuilt:

  shr   al,5                           ; Check if block 5 (U) empty.
   lea  edx,[esi].BlkU+4               ; Addr of block addr (plus 4).
  sbb   ebp,ebp                        ; -1 iff block not empty.
   mov  [edi].BlockAddr,edx            ; Store address of block address.
  shr   al,1                           ; Check if block 6 (Y) empty.
   lea  edx,[esi].BlkV+4               ; Addr of block addr (plus 4).
  sbb   ebx,ebx                        ; -1 iff block not empty.
   and  ebp,T_CoeffBlk                 ; 0 iff block empty, else inc. 
  and   ebx,T_CoeffBlk                 ; 0 iff block empty, else inc. 
   add  esi,SIZEOF T_MacroBlockActionDescr ; Move to next macroblock descriptor.
  mov   [edi+ebp*1].BlockAddr,edx      ; Store address of block address.
   add  edi,ebp                        ; Inc block descr ptr if blk non-empty.
  add   edi,ebx                        ; Inc block descr ptr if blk non-empty.
   xor  ebp,ebp
  and   al,1                           ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; partial end of section only defined when H261 not defined.
ENDIF
  
BuildBlockActionDescr MACRO BlockNumber,AddrOffset
  shr   al,1                                  ; Check if block empty.
   lea  edi,[edi+ebp]                         ; Adjust BlockActionDescr cursor.
  sbb   ebp,ebp                               ; -1 iff block not empty.
   lea  edx,[esi].Blk[BlockNumber*SIZEOF T_Blk]+AddrOffset ; Addr of block addr.
  and   ebp,T_CoeffBlk                        ; 0 iff block empty, else inc. 
   mov  [edi].BlockAddr,edx                   ; Store address of block address.
ENDM

IFNDEF H261
;; more code only used when H261 not defined

MBIsIntraCoded_OBMC:

  shr   al,1        ; Same as BuildBlockActionDescr macro, except don't inc edi.
  sbb   ebp,ebp
   lea  edx,[esi].BlkY1
  and   ebp,T_CoeffBlk
   mov  [edi].BlockAddr,edx
  BuildBlockActionDescr 1,0  ; If blk 2 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   add  edi,ebp
  test  al,1                                ; Are we at end-of-stream?
   je   NextMacroBlock_OBMC

  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt

;; end of section only defined when H261 not defined.
ENDIF
;===============================================================================
;===============================================================================
; First pass builds block action stream from macroblock action stream.
;===============================================================================
;===============================================================================

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  al  -- Coded block pattern for I or P block
;  bl  -- BlockType

NextMacroBlock:

  mov   bl,PB [esi].BlockType
   mov  al,PB [esi].CodedBlocks  ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
  and   bl,IsINTRA
   jne  MBIsIntraCoded

  BuildBlockActionDescr 0,4  ; If blk 1 non-empty, record BAD to do as inter.
  BuildBlockActionDescr 1,4  ; blk 2
  BuildBlockActionDescr 2,4  ; blk 3
  BuildBlockActionDescr 3,4  ; blk 4
  BuildBlockActionDescr 4,4  ; blk 5
  BuildBlockActionDescr 5,4  ; blk 6
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt
  
MBIsIntraCoded:

  BuildBlockActionDescr 0,0  ; If blk 1 non-empty, record BAD to do as intra.
  BuildBlockActionDescr 1,0  ; blk 2
  BuildBlockActionDescr 2,0  ; blk 3
  BuildBlockActionDescr 3,0  ; blk 4
  BuildBlockActionDescr 4,0  ; blk 5
  BuildBlockActionDescr 5,0  ; blk 6

  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  al,1                                ; Are we at end-of-stream?
  je    NextMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
   jmp  BlockActionStreamBuilt


NextBMacroBlock:

;  esi -- MacroBlockActionStream cursor
;  edi -- BlockActionStream cursor
;  ebp -- Increment for BlockActionStream cursor
;  edx -- Address of a block to do
;  cl  -- Used to compute defined columns mask case.
;  bh  -- Coded block pattern for B block
;  bl  -- Coded block pattern for I or P block
;  al  -- Used to compute defined rows mask.

BuildBBlockActionDescr MACRO BlkNum,LinesDefFutureFrame,ColsDefFutureFrame
  shr   bh,1                                        ; Check if block empty.
   mov  cl,[esi].Blk[BlkNum*SIZEOF T_Blk].BestHMVb  ; HMVb for block.
  lea   edi,[edi+ebp]                               ; Adjust BlockActionDescr.
   mov  al,[esi].Blk[BlkNum*SIZEOF T_Blk].BestVMVb  ; VMVb for block.
  sbb   ebp,ebp                                     ; -1 iff block not empty.
   mov  cl,ColsDefFutureFrame[ecx-96]           ; Case of columns to do bidi.
  and   ebp,T_CoeffBlk                          ; 0 iff block empty, else inc. 
   mov  al,LinesDefFutureFrame[eax-96]          ; Mask for lines to do bidi.
  mov   [edi].LinesDefined,al                   ; Stash it.
   mov  edx,ColsDefined[ecx]
  mov   [edi].Cols03Defined,edx                 ; Stash it.
   mov  edx,ColsDefined[ecx+4]
  mov   [edi].Cols47Defined,edx                 ; Stash it.
   lea  edx,[esi].Blk[BlkNum*SIZEOF T_Blk]+8    ; Addr of block addr.
  mov   [edi].BlockAddr,edx                     ; Store address of blk address.
ENDM

  mov   ebx,PD [esi].CodedBlocks ; Bits  0- 3  set for non-empty Y blks.
                                 ; Bit      4  set for non-empty U blk.
                                 ; Bit      5  set for non-empty V blk.
                                 ; Bit      6  clear except at stream end.
                                 ; Bit      7  clear.  Unused.
                                 ; Bits  8-13  like bits 0-5, but for B frame.
                                 ; Bit  14-15  clear.  Unused.

  BuildBBlockActionDescr 0, UpperYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 1, UpperYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 2, LowerYBlkLinesDef, LeftYBlkColsDef
  BuildBBlockActionDescr 3, LowerYBlkLinesDef, RightYBlkColsDef
  BuildBBlockActionDescr 4, ChromaLinesDef,    ChromaColsDef
  BuildBBlockActionDescr 5, ChromaLinesDef,    ChromaColsDef
  add   esi,SIZEOF T_MacroBlockActionDescr  ; Move to next descriptor
   and  bl,040H                             ; Are we at end-of-stream?
  je    NextBMacroBlock

  add   edi,ebp
  sub   edi,SIZEOF T_CoeffBlk
  
BlockActionStreamBuilt:

  mov   CoeffStream,edi         ; Stash address of last block of coeffs.

NextBlock:

;===============================================================================
;===============================================================================
; Second pass performs frame differencing of Inters and Forward DCT.
;===============================================================================
;===============================================================================

  mov   eax,[edi].BlockAddr          ; Fetch address of block to do
   mov  ebp,PITCH
  test  eax,4                        ; Is it an Inter block.
   jne  InterOrOBMCBlock             ; Jump if doing inter block.

  mov   edx,[eax].T_Blk.BlkOffset    ; BlkOffset if INTRA;  BestMVs if BiDi.
   mov  ecx,TargetFrameBaseAddress
  add   ecx,edx                      ; Target block address if INTRA
   mov  esi,[eax-8].T_Blk.BlkOffset  ; Addr of BlkOffset if BiDi

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;
  test  eax,8                        ; Is it a BiDi block?
   jne  BiDiBlock                    ; Jump if doing BiDi block.
ENDIF

IntraBlock:

; Register usage:
;   ecx,edi -- Address of block.
;   ebp -- Pitch.
;   ebx, eax -- Scratch.

  mov   ebx,[ecx]
   mov  eax,[ecx+4]
  mov   P00,ebx
   mov  P04,eax
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  lea   edi,[ecx+PITCH*5]
   lea  ecx,[ecx+ebp*2]
  mov   P10,eax
   mov  P14,edx
  mov   eax,[ecx]
   mov  edx,[ecx+4]
  mov   P20,eax
   mov  P24,edx
  mov   eax,[ecx+ebp*1]
   mov  edx,[ecx+ebp*1+4]
  mov   P30,eax
   mov  P34,edx
  mov   eax,[ecx+ebp*2]
   mov  edx,[ecx+ebp*2+4]
  mov   P40,eax
   mov  P44,edx
  mov   eax,[edi]
   mov  edx,[edi+4]
  mov   P50,eax
   mov  P54,edx
  mov   eax,[edi+ebp*1]
   mov  edx,[edi+ebp*1+4]
  mov   P60,eax
   mov  P64,edx
  mov   eax,[edi+ebp*2]
   mov  edx,[edi+ebp*2+4]
  mov   P74,edx
   xor  ecx,ecx
  and   ebx,00000007FH                      ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  mov   P70,eax
   jmp  DoForwardDCT

IFNDEF H261
;; H261 does not execute the BiDi code so it is included only when H261 is not defined
;;

BiDiBlock:

  mov   BlkActionDescrAddr,eax               ; Extract VMVb.
   mov  ebp,FutureFrameBaseAddress
  shr   edx,25                               ; CF == 1 iff VMVb is half pel.
   mov  bl,[edi].LinesDefined
  lea   esi,[esi+ebp-48]                     ; Addr 0-MV blk in Future P Frame.
   mov  ebp,[edi].Cols47Defined
IF PITCH-384
**** Magic leaks out if pitch not equal to 384
ENDIF
  lea   ecx,[edx+edx*2-48*3]                 ; Mult integer pel VMVb by PITCH.
   mov  edi,[edi].Cols03Defined
  mov   dl,[eax-8].T_Blk.BestHMVb            ; Fetch HMVb.
   jc   InterpVert_FuturePFrame

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpHorz_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   mov  Mask00+4,eax                    ; 0E  Stash Mask for use with past pred.
  and   eax,ecx                         ; 0F  Select in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  mov   P00+4,eax                       ; 0G  Stash in-range pels.
   and  edx,edi                         ; 1D
  mov   Mask10+4,edx                    ; 1E
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1F
  mov   P10+4,edx                       ; 1G
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   mov  Mask20+4,eax                    ; 2E
  and   eax,ecx                         ; 2F
   mov  ecx,[esi+PITCH*3]               ; 3C
  mov   P20+4,eax                       ; 2G
   and  edx,edi                         ; 3D
  mov   Mask30+4,edx                    ; 3E
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3F
  mov   P30+4,edx                       ; 3G
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   mov  Mask40+4,eax                    ; 4E
  and   eax,ecx                         ; 4F
   mov  ecx,[esi+PITCH*5]               ; 5C
  mov   P40+4,eax                       ; 4G
   and  edx,edi                         ; 5D
  mov   Mask50+4,edx                    ; 5E
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5F
  mov   P50+4,edx                       ; 5G
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   mov  Mask60+4,eax                    ; 6E
  and   eax,ecx                         ; 6F
   mov  ecx,[esi+PITCH*7]               ; 7C
  mov   P60+4,eax                       ; 6G
   and  edx,edi                         ; 7D
  mov   Mask70+4,edx                    ; 7E
   and  edx,ecx                         ; 7F
  mov   P70+4,edx                       ; 7G
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   add  esi,4
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpVert_FuturePFrame:

  shl   ecx,7
  shr   dl,1                                 ; CF == 1 iff HMVb is half pel.
   mov  bh,bl
  lea   esi,[esi+ecx]                        ; Add VMVb contrib to block addr.
   jc   InterpBoth_FuturePFrame

  add   esi,edx                              ; Add HMVb contrib to block addr.

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+PITCH*1]               ; 0E  Fetch Future P10:P13.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P10:P13.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*2]               ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*3]               ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*4]               ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*5]               ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*6]               ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*7]               ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*8-4]             ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpHorz_FuturePFrame:

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Horizontally.

  add   esi,edx                              ; Add HMVb contrib to block addr.

@@:

  xor   esp,4
   add  bl,bl                           ; 0A  CF == 1 iff line 0 in range.
  sbb   eax,eax                         ; 0B  eax == -1 if line 0 in range.
   mov  ecx,[esi]                       ; 0C  Fetch Future P00:P03.
  and   eax,edi                         ; 0D  In range among P00,P01,P02,P03.
   mov  edx,[esi+1]                     ; 0E  Fetch Future P01:P04.
  mov   Mask00+4,eax                    ; 0F  Stash Mask for use with past pred.
   add  ecx,edx                         ; 0G  Add P00:P03 and P01:P04.
  add   ecx,001010101H                  ; 0H  Add rounding.
  shr   ecx,1                           ; 0I  Interpolate (divide by 2).
   add  bl,bl                           ; 1A
  sbb   edx,edx                         ; 1B
   and  eax,ecx                         ; 0J  Select in-range pels (and clean).
  mov   P00+4,eax                       ; 0K  Stash in-range pels.
   mov  ecx,[esi+PITCH*1]               ; 1C
  and   edx,edi                         ; 1D
   mov  eax,[esi+PITCH*1+1]             ; 1E
  mov   Mask10+4,edx                    ; 1F
   add  ecx,eax                         ; 1G
  add   ecx,001010101H                  ; 1H
  shr   ecx,1                           ; 1I
   add  bl,bl                           ; 2A
  sbb   eax,eax                         ; 2B
   and  edx,ecx                         ; 1J
  mov   P10+4,edx                       ; 1K
   mov  ecx,[esi+PITCH*2]               ; 2C
  and   eax,edi                         ; 2D
   mov  edx,[esi+PITCH*2+1]             ; 2E
  mov   Mask20+4,eax                    ; 2F
   add  ecx,edx                         ; 2G
  add   ecx,001010101H                  ; 2H
  shr   ecx,1                           ; 2I
   add  bl,bl                           ; 3A
  sbb   edx,edx                         ; 3B
   and  eax,ecx                         ; 2J
  mov   P20+4,eax                       ; 2K
   mov  ecx,[esi+PITCH*3]               ; 3C
  and   edx,edi                         ; 3D
   mov  eax,[esi+PITCH*3+1]             ; 3E
  mov   Mask30+4,edx                    ; 3F
   add  ecx,eax                         ; 3G
  add   ecx,001010101H                  ; 3H
  shr   ecx,1                           ; 3I
   add  bl,bl                           ; 4A
  sbb   eax,eax                         ; 4B
   and  edx,ecx                         ; 3J
  mov   P30+4,edx                       ; 3K
   mov  ecx,[esi+PITCH*4]               ; 4C
  and   eax,edi                         ; 4D
   mov  edx,[esi+PITCH*4+1]             ; 4E
  mov   Mask40+4,eax                    ; 4F
   add  ecx,edx                         ; 4G
  add   ecx,001010101H                  ; 4H
  shr   ecx,1                           ; 4I
   add  bl,bl                           ; 5A
  sbb   edx,edx                         ; 5B
   and  eax,ecx                         ; 4J
  mov   P40+4,eax                       ; 4K
   mov  ecx,[esi+PITCH*5]               ; 5C
  and   edx,edi                         ; 5D
   mov  eax,[esi+PITCH*5+1]             ; 5E
  mov   Mask50+4,edx                    ; 5F
   add  ecx,eax                         ; 5G
  add   ecx,001010101H                  ; 5H
  shr   ecx,1                           ; 5I
   add  bl,bl                           ; 6A
  sbb   eax,eax                         ; 6B
   and  edx,ecx                         ; 5J
  mov   P50+4,edx                       ; 5K
   mov  ecx,[esi+PITCH*6]               ; 6C
  and   eax,edi                         ; 6D
   mov  edx,[esi+PITCH*6+1]             ; 6E
  mov   Mask60+4,eax                    ; 6F
   add  ecx,edx                         ; 6G
  add   ecx,001010101H                  ; 6H
   add  esi,4
  shr   ecx,1                           ; 6I
   add  bl,bl                           ; 7A
  sbb   edx,edx                         ; 7B
   and  eax,ecx                         ; 6J
  mov   P60+4,eax                       ; 6K
   mov  ecx,[esi+PITCH*7-4]             ; 7C
  and   edx,edi                         ; 7D
   mov  eax,[esi+PITCH*7+1-4]           ; 7E
  mov   Mask70+4,edx                    ; 7F
   add  ecx,eax                         ; 7G
  add   ecx,001010101H                  ; 7H
   mov  bl,bh
  shr   ecx,1                           ; 7I
   and  edx,ecx                         ; 7J
  mov   P70+4,edx                       ; 7K
   mov  edi,ebp
  mov   edx,BlkActionDescrAddr
   mov  ecx,4
  and   ecx,esp
   je   @b

  mov   edi,[edx-8].T_Blk.BlkOffset
   xor  eax,eax
  mov   al,[edx-8].T_Blk.BestVMVf
   jmp  BiDiFuturePredDone


InterpBoth_FuturePFrame:

  add   esi,edx                              ; Add HMVb contrib to block addr.
   sub  esp,68

; esi -- Future P Frame block address.
; edi -- Mask to apply to columns 0-3 of block to select columns in range.
; ebp -- Mask to apply to columns 4-7 of block to select columns in range.
; bl  -- Mask of lines that are in range.

; Interpolate Future Prediction Vertically.

@@:

  add   esp,8
   mov  eax,[esi]           ; Fetch Future P00:P03.
  mov   ecx,001010101H      ; Mask to extract halves.
   mov  edx,[esi+1]         ; Fetch Future P01:P04.
  add   eax,edx             ; <P04+P03 ...>.
   mov  edx,[esi+PITCH+1]   ; Fetch Future P11:P14.
  and   ecx,eax             ; <(P04+P03)&1 ...>.
   add  esi,PITCH           ; Advance to next line.
  xor   eax,ecx             ; <(P04+P03)/2*2 ...>.
   add  edx,ecx             ; <P14+((P04+P03)&1) ...>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   mov  ecx,[esi]           ; Fetch Future P10:P13.
  add   edx,ecx             ; <P14+P13+((P04+P03)&1) ...>.
   add  eax,001010101H      ; <(P04+P03)/2+1 ...>
  shr   edx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  bl,bl               ; CF == 1 iff line 0 in range.
  sbb   ecx,ecx             ; ecx == -1 if line 0 in range.
   and  edx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
  add   eax,edx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   and  ecx,edi             ; In range among P00,P01,P02,P03.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   mov  Mask00+60,ecx       ; Stash Mask for use with past prediction.
  and   eax,ecx             ; Select in-range pels from future pred (and clean).
  test  esp,000000038H
  mov   P00+60,eax          ; Stash in-range pels.
   jne  @b

  sub   esi,PITCH*8-4       ; Move to right 4 columns.
   mov  edx,BlkActionDescrAddr
  mov   edi,ebp
   sub  esp,60
  mov   ecx,4
   mov  bl,bh
  and   ecx,esp
   jne  @b

  add   esp,60
   xor  eax,eax
  mov   edi,[edx-8].T_Blk.BlkOffset
   mov  al,[edx-8].T_Blk.BestVMVf

BiDiFuturePredDone:

  shr   al,1                                 ; CF == 1 iff VMVf is half pel.
   mov  esi,TargetFrameBaseAddress
  mov   cl,[edx-8].T_Blk.BestHMVf
   mov  edx,DistFromTargetToPastP
  lea   edi,[edi+esi]
   jc   InterpVert_PastPFrame

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpHorz_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  ebx,Mask00+64       ; 0B  Fetch bidi-prediction mask.
  mov   ecx,P00+64          ; 0C  Fetch future pred for bidi predicted pels.
   and  ebx,eax             ; 0D  Extract past for bidi predicted pels.
  mov   edx,[esi+4]         ; 4A
   mov  ebp,Mask04+64       ; 4B
  lea   eax,[ecx+eax*2]     ; 0E  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4C
  sub   eax,ebx             ; 0F  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4D
  shr   eax,1               ; 0G  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4E
  and   eax,07F7F7F7FH      ; 0H  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4F
  shr   edx,1               ; 4G
   mov  ebx,[edi]           ; 0I  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4H
   mov  ebp,[edi+4]         ; 4I
  sub   ebx,eax             ; 0J  Compute correction.
   sub  ebp,edx             ; 4J
  add   ebx,080808080H      ; 0K  Bias correction.
   add  ebp,080808080H      ; 4K
  mov   P00+64,ebx          ; 0K  Store correction.
   mov  P04+64,ebp          ; 4K
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT
   

InterpVert_PastPFrame:

  shr   cl,1                                 ; CF == 1 iff HMVf is half pel.
   lea  eax,[eax+eax*2-48*3]                 ; Mult integer pel VMVf by PITCH.
  lea   esi,[edi+edx-48]                     ; Addr 0-MV blk in Future P Frame.
   jc   InterpBoth_PastPFrame

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+PITCH]     ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+PITCH+4]   ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorz_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi]           ; 0A  Fetch past prediction.
   mov  edx,[esi+4]         ; 4A
  add   eax,[esi+1]         ; 0B  Add past prediction with which to interpolate.
   add  edx,[esi+5]         ; 4B
  add   eax,001010101H      ; 0C  Add rounding.
   add  edx,001010101H      ; 0C
  shr   eax,1               ; 0D  Divide by two (dirty).
   and  edx,0FEFEFEFEH      ; 1E
  shr   edx,1               ; 1D  Clean.
   and  eax,07F7F7F7FH      ; 0E
  mov   ebx,Mask00+64       ; 0F  Fetch bidi-prediction mask.
   mov  ecx,P00+64          ; 0G  Fetch future pred for bidi predicted pels.
  and   ebx,eax             ; 0H  Extract past for bidi predicted pels.
   mov  ebp,Mask04+64       ; 4F
  lea   eax,[ecx+eax*2]     ; 0I  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64          ; 4G
  sub   eax,ebx             ; 0J  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx             ; 4H
  shr   eax,1               ; 0K  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]     ; 4I
  and   eax,07F7F7F7FH      ; 0L  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp             ; 4J
  shr   edx,1               ; 4K
   mov  ebx,[edi]           ; 0M  Fetch target pels.
  and   edx,07F7F7F7FH      ; 4L
   mov  ebp,[edi+4]         ; 4M
  sub   ebx,eax             ; 0N  Compute correction.
   sub  ebp,edx             ; 4N
  add   ebx,080808080H      ; 0O  Bias correction.
   add  ebp,080808080H      ; 4O
  mov   P00+64,ebx          ; 0P  Store correction.
   mov  P04+64,ebp          ; 4P
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpBoth_PastPFrame:

  shl   eax,7
   add  esi,ecx                              ; Add HMVf contrib to block addr.
  add   esi,eax                              ; Add VMVf contrib to block addr.
   sub  esp,64

; esi -- Past P Frame block address.
; edi -- Target block address.

@@:

  mov   eax,[esi+1]       ; 0A <P04 P03 P02 P01> prediction pels.
   mov  ebx,001010101H    ; 0B Mask for extraction of halves.
  mov   ebp,[esi+PITCH+1] ; 0C <P14 P13 P12 P11>.
   mov  ecx,[esi]         ; 0D <P03 P02 P01 P00>.
  add   eax,ecx           ; 0E <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ecx,[esi+PITCH]   ; 0F <P13 P12 P11 P10>.
  and   ebx,eax           ; 0G <(P04+P03)&1 ...>.
   and  eax,0FEFEFEFEH    ; 0H Pre-Clean
  shr   eax,1             ; 0I <(P04+P03)/2 ...>.
   add  ecx,ebp           ; 0J <P14+P13 P13+P12 P12+P11 P11+P10>.
  add   eax,001010101H    ; 0K <(P04+P03)/2+1 ...>.
   add  ecx,ebx           ; 0L <P14+P13+((P04+P03)&1) ...>.
  shr   ecx,1             ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   mov  edx,[esi+5]       ; 4A
  and   ecx,07F7F7F7FH    ; 0M <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   mov  ebx,001010101H    ; 4B
  add   eax,ecx           ; 0N <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebp,[esi+PITCH+5] ; 4C
  shr   eax,1             ; 0O <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>
   mov  ecx,[esi+4]       ; 4D
  and   eax,07F7F7F7FH    ; 0P Interpolated prediction.
   add  edx,ecx           ; 4E
  mov   ecx,[esi+PITCH+4] ; 4F
   and  ebx,edx           ; 4G
  and   edx,0FEFEFEFEH    ; 4H
   add  ecx,ebp           ; 4J
  shr   edx,1             ; 4I
   add  ecx,ebx           ; 4L
  shr   ecx,1             ; 4M
   add  edx,001010101H    ; 4K
  and   ecx,07F7F7F7FH    ; 4M
   mov  ebx,Mask00+64     ; 0Q  Fetch bidi-prediction mask.
  add   edx,ecx           ; 4N
   mov  ecx,P00+64        ; 0R  Fetch future pred for bidi predicted pels.
  shr   edx,1             ; 4O
   and  ebx,eax           ; 0S  Extract past for bidi predicted pels.
  and   edx,07F7F7F7FH    ; 4P
   mov  ebp,Mask04+64     ; 4Q
  lea   eax,[ecx+eax*2]   ; 0T  (2*Past) or ((2*Past+Future) for each pel.
   mov  ecx,P04+64        ; 4R
  sub   eax,ebx           ; 0U  (2*Past) or (Past+Future) for each pel.
   and  ebp,edx           ; 4S
  shr   eax,1             ; 0V  (Past) or ((Past+Future)/2) (dirty).
   lea  edx,[ecx+edx*2]   ; 4T
  and   eax,07F7F7F7FH    ; 0W  (Past) or ((Past+Future)/2) (clean).
   sub  edx,ebp           ; 4U
  shr   edx,1             ; 4V
   mov  ebx,[edi]         ; 0X  Fetch target pels.
  and   edx,07F7F7F7FH    ; 4W
   mov  ebp,[edi+4]       ; 4X
  sub   ebx,eax           ; 0Y  Compute correction.
   sub  ebp,edx           ; 4Y
  add   ebx,080808080H    ; 0Z  Bias correction.
   add  ebp,080808080H    ; 4Z
  mov   P00+64,ebx        ; 0a  Store correction.
   mov  P04+64,ebp        ; 4a
  add   esi,PITCH
   add  esp,8
  test  esp,000000038H
  lea   edi,[edi+PITCH]
   jne  @b
   
  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT

;; end of section of code not define when H261 defined
ENDIF

InterOrOBMCBlock:

  mov   esi,TargetFrameBaseAddress
   mov  edi,[eax-4].T_Blk.BlkOffset   ; Compute Addr of Target block.

IFNDEF H261
;; H261 does not execute the OBMC code so it is included only when H261 is not defined
;;
  test  eax,8
   jne  OBMCBlock
ENDIF

  add   edi,esi
   mov  esi,[eax-4].T_Blk.PastRef     ; Addr of PrevRef block.
  mov   eax,[eax-4].T_Blk.MVs         ; al = Horz MV;  ah = Vert MV
   mov  ecx,080808080H

IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;
  test  al,1
   jne  InterpHorzOrBoth

ENDIF

  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]
  test  ah,1
   je   NoInterp


IFNDEF H261
;; H261 does not execute Interp code so it is included only when H261 is not defined
;;

InterpVert:
InterpHorz:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebx -- Address of reference plus either 1 or PITCH, for interpolation.
;   ebp, edx, ecx, eax -- Scratch.

  sub   esp,16

@@:
  add   esp,4
   mov  eax,[esi]               ; 0A  <P03 P02 P01 P00> prediction pels.
  mov   ecx,[ebx]               ; 0B  <P04 ...> or <P13 ...> prediction pels.
   mov  edx,[edi]               ; 0C  <C03 C02 C01 C00> current pels.
  add   edx,080808080H          ; 0D  Add bias.
   mov  ebp,[esi+PITCH*2]       ; 2A
  lea   eax,[eax+ecx+001010101H]; 0E  Sum of pred pels to interpolate.
   mov  ecx,[ebx+PITCH*2]       ; 2B
  shr   eax,1                   ; 0F  Average of prediction pels (dirty).
  and   eax,07F7F7F7FH          ; 0G  Average of prediction pels (clean). 
   lea  ebp,[ebp+ecx+001010101H]; 2E
  sub   edx,eax                 ; 0H  Current - interpolated prediction, biased.
   mov  eax,[edi+PITCH*2]       ; 2C
  mov   P00+12,edx              ; 0I  Save correction.
   add  eax,080808080H          ; 2D
  shr   ebp,1                   ; 2F
   mov  edx,[esi+PITCH*4]       ; 4A
  and   ebp,07F7F7F7FH          ; 2G
   mov  ecx,[ebx+PITCH*4]       ; 4B
  sub   eax,ebp                 ; 2H
   mov  ebp,[edi+PITCH*4]       ; 4C
  mov   P20+12,eax              ; 2I
   lea  ecx,[ecx+edx+001010101H]; 4E
  shr   ecx,1                   ; 4F
   add  ebp,080808080H          ; 4D
  and   ecx,07F7F7F7FH          ; 4G
   mov  eax,[esi+PITCH*6]       ; 6A
  sub   ebp,ecx                 ; 4H
   mov  ecx,[ebx+PITCH*6]       ; 6B
  mov   P40+12,ebp              ; 4I
   mov  ebp,[edi+PITCH*6]       ; 6C
  lea   ecx,[ecx+eax+001010101H]; 6E
   add  ebp,080808080H          ; 6D
  shr   ecx,1                   ; 6F
   add  esi,4
  and   ecx,07F7F7F7FH          ; 6G
   add  ebx,4
  sub   ebp,ecx                 ; 6H
   add  edi,4
  test  esp,4
  mov   P60+12,ebp              ; 6I
   je   @b

  add   esi,PITCH-8
   add  edi,PITCH-8
  test  esp,8
  lea   ebx,[ebx+PITCH-8]
   jne  @b

  xor   ebx,ebx
   xor  ecx,ecx
  mov   bl,P00                              ; Fetch P0.
   mov  cl,P03                              ; Fetch P3.
  jmp   DoForwardDCT


InterpHorzOrBoth:

  lea   ebx,[esi+1]
  test  ah,1
   je   InterpHorz


InterpBoth:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebp -- Pitch and scratch.
;   edx, ebx, eax -- Scratch.

  sub   esp,64

@@:

  mov   eax,[esi+1]         ; <P04 P03 P02 P01> prediction pels.
   lea  edx,[ecx*2+1]       ; Get 001010101H mask.
  mov   ebx,[esi]           ; <P03 P02 P01 P00>.
   add  edi,4               ; Pre-increment target block pointer.
  add   eax,ebx             ; <P04+P03 P03+P02 P02+P01 P01+P00>.
   mov  ebx,[esi+ebp*1+1]   ; <P14 P13 P12 P11>.
  and   edx,eax             ; <(P04+P03)&1 ...>.
   mov  ebp,[esi+ebp*1]     ; <P13 P12 P11 P10>.
  xor   eax,edx             ; Clear insignificant fractional bit in each byte.
   add  ebx,ebp             ; <P14+P13 P13+P12 P12+P11 P11+P10>.
  shr   eax,1               ; <(P04+P03)/2 ...>.
   add  ebx,edx             ; <P14+P13+((P04+P03)&1) ...>.
  shr   ebx,1               ; <(P14+P13+((P04+P03)&1))/2 ...> (dirty).
   add  esi,4               ; Advance reference block pointer.
  and   ebx,07F7F7F7FH      ; <(P14+P13+((P04+P03)&1))/2 ...> (clean).
   lea  eax,[eax+ecx*2+1]   ; <(P04+P03)/2+1 ...>.
  add   eax,ebx             ; <(P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2 ...>.
   mov  ebx,[edi-4]         ; <C03 C02 C01 C00> current pels.
  shr   eax,1               ; <((P04+P03)/2+1+(P14+P13+((P04+P03)&1))/2)/2 ...>.
   add  ebx,ecx             ; Add bias.
  and   eax,07F7F7F7FH      ; Interpolated prediction.
   add  esp,4               ; Advance frame difference pointer.
  sub   ebx,eax             ; Correction.
   mov  ebp,PITCH           ; Reload Pitch.
  test  esp,4
  mov   P00+60,ebx          ; Save correction.
   je   @b

  lea   esi,[esi+ebp-8]
   xor  ebx,ebx
  test  esp,000000038H
  lea   edi,[edi+ebp-8]
   jne  @b

  mov   bl,P00                              ; Fetch P0.
   xor  ecx,ecx
  mov   cl,P03                              ; Fetch P3.
   jmp  DoForwardDCT


OBMCBlock:   ; Do OBMC frame differencing.  OBMC prediction computed above. 

  mov   ecx,080808080H
   mov  edi,[eax-12].T_Blk.BlkOffset  ; Compute Addr of Target block.
  add   edi,esi
   mov  esi,[eax-12].T_Blk.PastRef     ; Addr of PrevRef block.
  lea   edx,[ebp+ebp*2]
   lea  ebx,[esi+ebp]

;; end of section of code not included when H261 defined
ENDIF

NoInterp:

; Register usage:
;   edi -- Address of target block.
;   esi -- Address of reference block.
;   ebp -- Pitch.
;   edx -- Pitch times 3.
;   ecx -- bias value 0x80808080, to make code size smaller.
;   ebx, eax -- Scratch.

@@:

  xor   esp,4                   ; 1st time: Back off to cache line;
   mov  eax,[edi]               ; 0A  <C3 C2 C1 C0> current pels.
  add   eax,ecx                 ; 0C  Add bias.
   mov  ebx,[esi]               ; 0B  <P3 P2 P1 P0> prediction pels.
  sub   eax,ebx                 ; 0D  <Cn-Pn> Current - pred, biased.
   mov  ebx,[esi+ebp*1]         ; 1B
  mov   P00+4,eax               ; 0E  Save <Corr3 Corr2 Corr1 Corr0>
   mov  eax,[edi+ebp*1]         ; 1A
  sub   eax,ebx                 ; 1D
   mov  ebx,[esi+ebp*2]         ; 2B
  add   eax,ecx                 ; 1C
   sub  ebx,ecx                 ; 2C
  mov   P10+4,eax               ; 1E
   mov  eax,[edi+ebp*2]         ; 2A
  sub   eax,ebx                 ; 2D
   mov  ebx,[esi+ebp*4]         ; 4B
  mov   P20+4,eax               ; 2E
   mov  eax,[edi+ebp*4]         ; 4A
  sub   eax,ebx                 ; 4D
   mov  ebx,[esi+edx*1]         ; 3B
  add   eax,ecx                 ; 4C
   sub  ebx,ecx                 ; 3C
  mov   P40+4,eax               ; 4E
   mov  eax,[edi+edx*1]         ; 3A
  sub   eax,ebx                 ; 3D
   mov  ebx,[esi+edx*2]         ; 6B
  mov   P30+4,eax               ; 3E
   lea  esi,[esi+ebp+4]         ; Advance to line 1.
  mov   eax,[edi+edx*2]         ; 6A
   lea  edi,[edi+ebp+4]         ; Advance to line 1.
  sub   eax,ebx                 ; 6D
   mov  ebx,[esi+ebp*4-4]       ; 5B
  add   eax,ecx                 ; 6C
   sub  ebx,ecx                 ; 5C
  mov   P60+4,eax               ; 6E
   mov  eax,[edi+ebp*4-4]       ; 5A
  sub   eax,ebx                 ; 5D
   mov  ebx,[esi+edx*2-4]       ; 7B
  mov   P50+4,eax               ; 5E
   mov  eax,[edi+edx*2-4]       ; 7A
  sub   eax,ebx                 ; 7D
   sub  edi,ebp                 ; Back off to line 0.
  add   eax,ecx                 ; 7C
   sub  esi,ebp                 ; Back off to line 0.
  test  esp,4                   ; Do twice.
  mov   P70+4,eax               ; 7E
   je   @b

  xor   ecx,ecx
   xor  ebx,ebx
  mov   bl,P00                  ; Fetch P0.
   mov  cl,P03                  ; Fetch P3.

DoForwardDCT:

;=============================================================================
;
;  This section does the Forward Discrete Cosine Transform.  It performs a DCT
;  on a 8*8 block of pels or pel differences.  The row transforms are done
;  first using a table lookup method.  Then the columns are done, using
;  computation.
;
;
; Each intermediate and coefficient is a short.  There are four fractional
; bits.  All coefficients except an intrablock's DC are biased by 08000H.

; Perform row transforms.
;
; Register usage:
;   ebp - Accumulator for contributions to intermediates I0 (hi) and I2 (lo).
;   edi - Accumulator for contributions to intermediates I1 (hi) and I3 (lo).
;   esi - Accumulator for contributions to intermediates I4 (hi) and I6 (lo).
;   edx - Accumulator for contributions to intermediates I7 (hi) and I5 (lo).
;   ecx - Pel or pel difference.
;   ebx - Pel or pel difference.
;   eax - Place in which to fetch a pel's contribution to two intermediates.

  mov   esi,PD P80000_P4545F [ebx*8]   ; P0's contribution to I4|I6.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P3's contribution to I4|I6.
  mov   edx,PD P2350B_P6491A [ebx*8]   ; P0's contribution to I7|I5.
   mov  edi,PD NB18A8_P96831 [ecx*8]   ; P3's contribution to I7|I5.
  lea   esi,[esi+eax+40004000H]        ; P0, P3 contribs to   I4|I6, biased.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P3's contribution to I0|I2.
  lea   edx,[edx+edi+40004000H]        ; P0, P3 contribs to   I7|I5, biased.
   mov  ebp,PD P80000_PA73D7 [ebx*8]   ; P0's contribution to I0|I2.
  mov   edi,PD P2350B_N6491A [ecx*8]   ; P3's contribution to I1|I3.
   mov  cl,P01                         ; Fetch P1.
  lea   ebp,[ebp+eax+40004000H]        ; P0, P3 contribs to   I0|I2, biased.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P0's contribution to I1|I3.
  sub   edi,eax                        ; P0, P3 contribs to   I1|I3, unbiased.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P1's contribution to I0|I2.
  add   ebp,eax                        ; P0, P1, P3 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P1's contribution to I1|I3.
  sub   edi,eax                        ; P0, P1, P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P1's contribution to I4|I6.
  sub   esi,eax                        ; P0, P1, P3 contribs to I4|I6.
   mov  bl,P02                         ; Fetch P2.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P1's contribution to I7|I5.
   mov  cl,P04                         ; Fetch P4.
  sub   edx,eax                        ; P0, P1, P3 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P2's contribution to I0|I2.
  add   ebp,eax                        ; P0-P3 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P2's contribution to I1|I3.
  add   edi,eax                        ; P0-P3 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P2's contribution to I4|I6.
  sub   esi,eax                        ; P0-P3 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P2's contribution to I7|I5.
  sub   edx,eax                        ; P0-P3 contribs to I7|I5.
   mov  eax,PD P80000_NA73D7 [ecx*8]   ; P4's contribution to I0|I2.
  add   ebp,eax                        ; P0-P4 contribs to I0|I2.
   mov  eax,PD P2350B_N6491A [ecx*8]   ; P4's contribution to I1|I3.
  sub   edi,eax                        ; P0-P4 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_N4545F [ecx*8]   ; P4's contribution to I4|I6.
  add   esi,eax                        ; P0-P4 contribs to I4|I6.
   mov  bl,P05                         ; Fetch P5.
  mov   eax,PD NB18A8_P96831 [ecx*8]   ; P4's contribution to I7|I5.
   mov  cl,P06                         ; Fetch P6.
  sub   edx,eax                        ; P0-P4 contribs to I7|I5.
   mov  eax,PD P80000_N4545F [ebx*8]   ; P5's contribution to I0|I2.
  add   ebp,eax                        ; P0-P5 contribs to I0|I2.
   mov  eax,PD P6491A_NB18A8 [ebx*8]   ; P5's contribution to I1|I3.
  sub   edi,eax                        ; P0-P5 contribs to I1|I3.
   mov  eax,PD P80000_NA73D7 [ebx*8]   ; P5's contribution to I4|I6.
  sub   esi,eax                        ; P0-P5 contribs to I4|I6.
   mov  eax,PD N96831_N2350B [ebx*8]   ; P5's contribution to I7|I5.
  add   edx,eax                        ; P0-P5 contribs to I3|I4.
   mov  eax,PD P80000_P4545F [ecx*8]   ; P6's contribution to I0|I2.
  add   ebp,eax                        ; P0-P6 contribs to I0|I2.
   mov  eax,PD N96831_P2350B [ecx*8]   ; P6's contribution to I1|I3.
  add   edi,eax                        ; P0-P6 contribs to I1|I3, unbiased.
   mov  eax,PD P80000_PA73D7 [ecx*8]   ; P6's contribution to I4|I6.
  sub   esi,eax                        ; P0-P6 contribs to I4|I6.
   mov  bl,P07                         ; Fetch P7.
  mov   eax,PD P6491A_PB18A8 [ecx*8]   ; P6's contribution to I7|I5.
   mov  cl,P13                         ; Fetch P0.
  add   edx,eax                        ; P0-P6 contribs to I7|I5.
   mov  eax,PD P80000_PA73D7 [ebx*8]   ; P7's contribution to I0|I2.
  add   ebp,eax                        ; P0-P7 contribs to I0|I2.
   mov  eax,PD P80000_P4545F [ebx*8]   ; P7's contribution to I4|I6.
  add   esi,eax                        ; P0-P7 contribs to I4|I6.
   mov  eax,PD NB18A8_N96831 [ebx*8]   ; P7's contribution to I1|I3.
  mov   I00I02,ebp                     ; Store I0|I2 for line 0.
   mov  I04I06,esi                     ; Store I4|I6 for line 0.
  lea   edi,[edi+eax+40004000H]        ; P0-P7 contribs to I1|I3, biased.
   mov  eax,PD P2350B_P6491A [ebx*8]   ; P7's contribution to I7|I5.
  sub   edx,eax                        ; P0-P7 contribs to I7|I5.
   mov  bl,P10                         ; Fetch P3 of line 1.
  mov   I01I03,edi                     ; Store I1|I3 for line 0.
   mov  I07I05,edx                     ; Store I7|I5 for line 0.

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P11
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P12
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P14
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P15
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P16
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P17
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P23
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I10I12,ebp
   mov  I14I16,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P20
  mov   I11I13,edi
   mov  I17I15,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P21
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P22
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P24
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P25
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P26
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P27
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P33
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I20I22,ebp
   mov  I24I26,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P30
  mov   I21I23,edi
   mov  I27I25,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  lea   esi,[esi+eax+40004000H]
   mov  eax,PD P80000_NA73D7 [ecx*8]
  lea   edx,[edx+edi+40004000H]
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P31
  lea   ebp,[ebp+eax+40004000H]
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P32
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P34
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P35
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P36
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P37
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P43
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I30I32,ebp
   mov  I34I36,esi
  lea   edi,[edi+eax+40004000H]
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P40
  mov   I31I33,edi
   mov  I37I35,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P41
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P42
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P44
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P45
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P46
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P47
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P53
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I40I42,ebp
   mov  I44I46,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P50
  mov   I41I43,edi
   mov  I47I45,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P51
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P52
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P54
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P55
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P56
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P57
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P63
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I50I52,ebp
   mov  I54I56,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P60
  mov   I51I53,edi
   mov  I57I55,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P61
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P62
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P64
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P65
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P66
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P67
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P73
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I60I62,ebp
   mov  I64I66,esi
  add   edi,eax
   mov  eax,PD P2350B_P6491A [ebx*8]
  sub   edx,eax
   mov  bl,P70
  mov   I61I63,edi
   mov  I67I65,edx

  mov   esi,PD P80000_P4545F [ebx*8]
   mov  eax,PD P80000_N4545F [ecx*8]
  mov   edx,PD P2350B_P6491A [ebx*8]
   mov  edi,PD NB18A8_P96831 [ecx*8]
  add   esi,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   edx,edi
   mov  ebp,PD P80000_PA73D7 [ebx*8]
  mov   edi,PD P2350B_N6491A [ecx*8]
   mov  cl,P71
  add   ebp,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P72
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  cl,P74
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  add   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  sub   edx,eax
   mov  eax,PD P80000_NA73D7 [ecx*8]
  add   ebp,eax
   mov  eax,PD P2350B_N6491A [ecx*8]
  sub   edi,eax
   mov  eax,PD P80000_N4545F [ecx*8]
  add   esi,eax
   mov  bl,P75
  mov   eax,PD NB18A8_P96831 [ecx*8]
   mov  cl,P76
  sub   edx,eax
   mov  eax,PD P80000_N4545F [ebx*8]
  add   ebp,eax
   mov  eax,PD P6491A_NB18A8 [ebx*8]
  sub   edi,eax
   mov  eax,PD P80000_NA73D7 [ebx*8]
  sub   esi,eax
   mov  eax,PD N96831_N2350B [ebx*8]
  add   edx,eax
   mov  eax,PD P80000_P4545F [ecx*8]
  add   ebp,eax
   mov  eax,PD N96831_P2350B [ecx*8]
  add   edi,eax
   mov  eax,PD P80000_PA73D7 [ecx*8]
  sub   esi,eax
   mov  bl,P77
  mov   eax,PD P6491A_PB18A8 [ecx*8]
   mov  ecx,I00I02                 ; Fetch I0  (upper_lim <skew>) = 2000  4000 
   ;                               ; (lower_lim is -upper_limit)
  add   edx,eax
   mov  eax,PD P80000_PA73D7 [ebx*8]
  add   ebp,eax                    ; I70I72, aka I7.                2000  0000 
   mov  eax,PD P80000_P4545F [ebx*8]
  add   esi,eax
   mov  eax,PD NB18A8_N96831 [ebx*8]
  mov   I74I76,esi
   mov  esi,I30I32                 ; Fetch I3                       2000  4000 
  add   edi,eax
   mov  eax,I40I42                 ; Fetch I4                       2000  0000 
  sub   esi,eax                    ; I3 - I4                        4000  4000 
   sub  ecx,ebp                    ; I0 - I7                        4000  4000 
  shr   ecx,1                      ; R7 = (I0-I7)/2 (dirty)         2000  2000 
   and  esi,0FFFEFFFFH             ; pre-clean R4
  shr   esi,1                      ; R4 = (I3-I4)/2 (dirty)         2000  2000 
   and  ecx,0FFFF7FFFH             ; R7 = (I0-I7)/2 (clean)         2000  2000 
  mov   ebx,PD P2350B_P6491A [ebx*8]
   mov  I71I73,edi
  sub   edx,ebx
   lea  ebx,[ecx+ecx*2]            ; 3R7                            6000  6000
  mov   I77I75,edx
   lea  edi,[esi+esi*2]            ; 3R4                            6000  6000

                                   ; eax:  I4                       2000  0000
                                   ; ebx:  3R7                      6000  6000
                                   ; ecx:  R7                       2000  2000
                                   ; edx:  available
                                   ; esi:  R4                       2000  2000
                                   ; edi:  3R4                      6000  6000
                                   ; ebp:  I7                       2000  0000

  lea   ebp,[ebp+ecx+40004000H]    ; R0 = (I0+I7)/2                 2000  6000
   add  eax,esi                    ; R3 = (I3+I4)/2                 2000  2000
  shr   ecx,1                      ; R7/2 (dirty)                   1000  1000
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; R4/2 (clean)                   1000  1000
   and  ecx,0FFFF7FFFH             ; clean
  add   ebx,ecx                    ; 7R7/2                          7000  7000
   add  edi,esi                    ; 7R4/2                          7000  7000
  shr   ebx,6                      ; 7R7/128 (dirty)                01C0  01C0
   and  edi,0FFC0FFFFH             ; pre-clean
  shr   edi,6                      ; 7R4/128 (clean)                01C0  01C0
   and  ebx,0FFFF03FFH             ; clean
  add   ebx,ecx                    ; 71R7/128                       11C0  11C0
   add  edi,esi                    ; 71R4/128                       11C0  11C0
  lea   edx,[eax+ebp-40004000H]    ; S0 = R0 + R3                   4000  4000
   sub  ebp,eax                    ; S3 = R0 - R3                   4000  4000
  lea   ecx,[ebx+ebx*2+6E406E40H]  ; 213R7/128                      3540  A380
   lea  esi,[edi+edi*2+27402740H]  ; 213R4/128                      3540  5C80
  shr   ecx,1                      ; 213R7/256 (dirty)              1AA0  51C0
   and  esi,0FFFEFFFFH             ; pre-clean
  shr   esi,1                      ; 213R4/256 (clean)              1AA0  2E40
   and  ecx,0FFFF7FFFH             ; clean
  sub   ecx,edi                    ; S7 = (213R7 - 142R4)/256       2C60  4000
   mov  S0,edx                     ; Free register for work.
  mov   S3,ebp                     ; Free register for work.
   lea  esi,[esi+ebx+80008000H]    ; S4 = (142R7 + 213R3)/256       2C60  C000
  mov   S7,ecx                     ; Free register for work.
   mov  eax,I10I12                 ; Fetch I1                       2000  4000
  mov   S4,esi                     ; Free register for work.

                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

   mov  ebx,I20I22                 ; Fetch I2                       2000  4000
  mov   ecx,I50I52                 ; Fetch I5                       2000  0000
   mov  edx,I60I62                 ; Fetch I6                       2000  0000
  sub   eax,edx                    ; I1 - I6                        4000  4000
   sub  ebx,ecx                    ; I2 - I5                        4000  4000
  shr   eax,1                      ; R6 = (I1-I6)/2 (dirty)         2000  2000 
   and  ebx,0FFFEFFFFH             ; pre-clean R4
  shr   ebx,1                      ; R5 = (I2-I5)/2 (dirty)         2000  2000 
   and  eax,0FFFF7FFFH             ; R6 = (I1-I6)/2 (clean)         2000  2000 

                                   ; eax:  R6                       2000  2000
                                   ; ebx:  R5                       2000  2000
                                   ; ecx:  I5                       2000  0000
                                   ; edx:  I6                       2000  0000
                                   ; mem:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S0                       4000  4000
                                   ; mem:  S3                       4000  4000

  mov   esi,ebx                    ; R5                             2000  2000
   mov  edi,eax                    ; R6                             2000  2000
  shr   esi,6                      ; R5/64                          0080  0080
   and  edi,0FFC0FFFFH             ; pre-clean 
  shr   edi,6                      ; R6/65                          0080  0080
   and  esi,0FFFF03FFH             ; clean
  lea   edx,[eax+edx+20002000H]    ; R1 = (I1+I6)/2                 2000  4000
   lea  ecx,[ecx+ebx-20002000H]    ; R2 = (I2+I5)/2                 2000  0000
  lea   ebp,[ebx+ebx*2]            ; 3R5                            6000  6000
   sub  ebx,esi                    ; 63R5/64                        1F80  1F80
  shr   ebp,4                      ; 3R5/16 (dirty)                 0600  0600
   lea  esi,[eax+eax*2]            ; 3R6                            6000  6000
  sub   eax,edi                    ; 63R6/64                        1F80  1F80
   mov  edi,ebx                    ; 63R5/64                        1F80  1F80
  shr   edi,7                      ; 63R5/8192 (dirty)              003F  003F
   and  ebp,0FFFF0FFFH             ; clean
  shr   esi,4                      ; 3R6/16 (dirty)                 0600  0600
   and  edi,0FFFF01FFH             ; clean
  and   esi,0FFFF0FFFH             ; clean
   sub  edx,ecx                    ; S2 = R1 - R2                   4000  4000
  lea   edi,[edi+ebp-46BF46BFH]    ; 1599R5/8192                    063F -4080
   mov  ebp,eax                    ; 63R6/64                        1F80  1F80
  shr   ebp,7                      ; 63R6/8192 (dirty)              003F  003F
   sub  eax,edi                    ; S6 = 8064R6/8192 - 1599R5/8192 25BF  6000
  and   ebp,0FFFF01FFH             ; clean
   lea  ecx,[edx+ecx*2-80008000H]  ; S1 = R1 + R2                   4000 -4000
  add   ebp,esi                    ; 1599R6/8192                    063F  063F
   mov  esi,S0                     ; Reload S0                      4000  4000
  mov   edi,CoeffStream            ; Fetch addr at which to place blk of coeffs.
   sub  esi,ecx                    ; C4 = T1 = S0 - S1              8000  8000
  lea   ebx,[ebx+ebp-45BF45BFH]    ; S5 = 8064R5/8192 + 1599R6/8192 25BF -2000
   mov  ebp,S4                     ; Reload S4                      2C60  C000

                                   ; eax:  S6                       25BF  6000
                                   ; ebx:  S5                       25BF -2000
                                   ; ecx:  S0                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C4                       8000  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S4                       2C60  C000
                                   ; mem:  S7                       2C60  4000
                                   ; mem:  S3                       4000  4000

  sub   ebp,eax                    ; T6 = S4 - S6                   521F  6000
   mov  PD [edi+C40C42],esi        ; Store coeffs C40 and C42.
  lea   ecx,[esi+ecx*2+80008000H]  ; C0 = T0 = S0 + S1              8000  8000
   mov  esi,S7                     ; Reload S7                      2C60  4000
  sub   esi,ebx                    ; T5 = S7 - S5                   521F  6000
   lea  eax,[ebp+eax*2-0C000C000H] ; T4 = S4 + S6                   521F  6000
  mov   PD [edi+C00C02],ecx        ; Store coeffs C00 and C02.
   mov  ecx,ebp                    ; T6                             521F  6000
  shr   ebp,2                      ; T6/4 (dirty)                   1487  1800
   lea  ebx,[esi+ebx*2+0C000C000H] ; T7 = S7 + S5                   521F  E000

                                   ; eax:  T4                       521F  6000
                                   ; ebx:  T7                       521F  6000
                                   ; ecx:  T6                       521F  6000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  T5                       521F  6000
                                   ; edi:  Destination pointer.
                                   ; ebp:  T6/4 (dirty)             1487  1800
                                   ; mem:  S3                       4000  4000
                                   ; done:  C0, C4

  and   ebp,0FFFF3FFFH             ; T6/4 (clean)                   1487  1800
   sub  ebx,eax                    ; C7 = T7 - T4                  <7642> 8000
  add   ecx,ebp                    ; 5T6/4                          66A6  7800
   mov  PD [edi+C70C72],ebx        ; Store coeffs C70 and C72.
  mov   ebp,ecx                    ; 5T6/4                          66A6  7800
   and  ecx,0FFF8FFFFH             ; pre-clean
  shr   ecx,3                      ; 5T6/32 (clean)                 0CD4  0F00
   lea  eax,[ebx+eax*2-0C000C000H] ; C1 = T7 + T4                  <7642> 8000 
  mov   ebx,esi                    ; T5                             521F  6000
   and  esi,0FFFCFFFFH             ; pre-clean
  shr   esi,2                      ; T5/4 (clean)                   1487  1800
   lea  ecx,[ecx+ebp-07000700H]    ; C5 = 45T6/32                   737A  8000
  mov   PD [edi+C50C52],ecx        ; Store coeffs C50 and C52.
   add  esi,ebx                    ; 5T5/4                          66A6  7800
  mov   ebx,esi                    ; 5T5/4                          66A6  7800
   and  esi,0FFF8FFFFH             ; pre-clean
  shr   esi,3                      ; 5T5/32 (clean)                 0CD4  0F00
   mov  ebp,S3                     ; Reload S3                      4000  4000
  mov   ecx,edx                    ; S2                             4000  4000
   lea  esi,[esi+ebx-07000700H]    ; C3 = 45T5/32                   737A  8000
  mov   ebx,ebp                    ; S3                             4000  4000
   ;

                                   ; eax:  C1                       521E  8000
                                   ; ebx:  S3                       4000  4000
                                   ; ecx:  S2                       4000  4000
                                   ; edx:  S2                       4000  4000
                                   ; esi:  C3                       737A  8000
                                   ; edi:  Destination pointer.
                                   ; ebp:  S3                       4000  4000
                                   ; done:  C0, C4, C5, C7

  shr   ebp,2                      ; S3/4 (dirty)                   1000  1000
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/4 (clean)                   1000  1000
   and  ebp,0FFFF3FFFH             ; S3/4 (clean)                   1000  1000
  mov   PD [edi+C10C12],eax        ; Store coeffs C10 and C12.
   mov  PD [edi+C30C32],esi        ; Store coeffs C30 and C32.
  lea   eax,[edx+ecx]              ; 5S2/4                          5000  5000
   lea  esi,[ebx+ebp]              ; 5S3/4                          5000  5000
  shr   ebp,2                      ; S3/16 (dirty)                  0400  0400
   and  ecx,0FFFCFFFFH             ; pre-clean
  shr   ecx,2                      ; S2/16 (clean)                  0400  0400
   and  ebp,0FFFF3FFFH             ; S3/16 (clean)                  0400  0400
  add   ecx,eax                    ; 21S2/16                        5400  5400
   add  ebp,esi                    ; 21S3/16                        5400  5400
  shr   eax,5                      ; 5S2/128 (dirty)                0280  0280
   and  esi,0FFE0FFFFH             ; pre-clean
  shr   esi,5                      ; 5S3/128 (clean)                0280  0280
   and  eax,0FFFF07FFH             ; 5S2/128 (clean)                0280  0280
  shr   edx,1                      ; S2/2 (dirty)                   2000  2000
   and  ebx,0FFFEFFFFH             ; pre-clean
  shr   ebx,1                      ; S3/2 (clean)                   2000  2000
   and  edx,0FFFF7FFFH             ; S2/2 (clean)                   2000  2000
  sub   ebx,ecx                    ; (64S3 - 168S2) / 128           7400 -3400
   add  eax,ebp                    ; (5S2 + 168S3) / 128            5680  5680

  mov   ecx,I01I03
   mov  ebp,I71I73
  lea   ebx,[ebx+esi+0B180B180H]   ; C6 = (69S3 - 168S2) / 128      7680  8000
   lea  edx,[eax+edx+009800980H]   ; C2 = (69S2 + 168S3) / 128      7680  8000
  mov   esi,I31I33
   mov  eax,I41I43
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C60C62],ebx
   mov  PD [edi+C20C22],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I11I13
  mov   S4,esi
   mov  ebx,I21I23
  mov   ecx,I51I53
   mov  edx,I61I63
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C41C43],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C01C03],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C71C73],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C51C53],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C11C13],eax
   mov  PD [edi+C31C33],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I04I06
   mov  ebp,I74I76
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I34I36
   mov  eax,I44I46
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C61C63],ebx
   mov  PD [edi+C21C23],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I14I16
  mov   S4,esi
   mov  ebx,I24I26
  mov   ecx,I54I56
   mov  edx,I64I66
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C44C46],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C04C06],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C74C76],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C54C56],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C14C16],eax
   mov  PD [edi+C34C36],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,I07I05
   mov  ebp,I77I75
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   esi,I37I35
   mov  eax,I47I45
  sub   esi,eax
   sub  ecx,ebp
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  mov   PD [edi+C64C66],ebx
   mov  PD [edi+C24C26],edx
  lea   ebx,[ecx+ecx*2]
   lea  edi,[esi+esi*2]
  lea   ebp,[ebp+ecx+40004000H]
   add  eax,esi
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  add   ebx,ecx
   add  edi,esi
  shr   ebx,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  ebx,0FFFF03FFH
  add   ebx,ecx
   add  edi,esi
  lea   edx,[eax+ebp-40004000H]
   sub  ebp,eax
  lea   ecx,[ebx+ebx*2+6E406E40H]
   lea  esi,[edi+edi*2+27402740H]
  shr   ecx,1
   and  esi,0FFFEFFFFH
  shr   esi,1
   and  ecx,0FFFF7FFFH
  sub   ecx,edi
   mov  S0,edx
  mov   S3,ebp
   lea  esi,[esi+ebx+80008000H]
  mov   S7,ecx
   mov  eax,I17I15
  mov   S4,esi
   mov  ebx,I27I25
  mov   ecx,I57I55
   mov  edx,I67I65
  sub   eax,edx
   sub  ebx,ecx
  shr   eax,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  eax,0FFFF7FFFH
  mov   esi,ebx
   mov  edi,eax
  shr   esi,6
   and  edi,0FFC0FFFFH
  shr   edi,6
   and  esi,0FFFF03FFH
  lea   edx,[eax+edx+20002000H]
   lea  ecx,[ecx+ebx-20002000H]
  lea   ebp,[ebx+ebx*2]
   sub  ebx,esi
  shr   ebp,4
   lea  esi,[eax+eax*2]
  sub   eax,edi
   mov  edi,ebx
  shr   edi,7
   and  ebp,0FFFF0FFFH
  shr   esi,4
   and  edi,0FFFF01FFH
  and   esi,0FFFF0FFFH
   sub  edx,ecx
  lea   edi,[edi+ebp-46BF46BFH]
   mov  ebp,eax
  shr   ebp,7
   sub  eax,edi
  and   ebp,0FFFF01FFH
   lea  ecx,[edx+ecx*2-80008000H]
  add   ebp,esi
   mov  esi,S0
  mov   edi,CoeffStream
   sub  esi,ecx
  lea   ebx,[ebx+ebp-45BF45BFH]
   mov  ebp,S4
  sub   ebp,eax
   mov  PD [edi+C47C45],esi
  lea   ecx,[esi+ecx*2+80008000H]
   mov  esi,S7
  sub   esi,ebx
   lea  eax,[ebp+eax*2-0C000C000H]
  mov   PD [edi+C07C05],ecx
   mov  ecx,ebp
  shr   ebp,2
   lea  ebx,[esi+ebx*2+0C000C000H]
  and   ebp,0FFFF3FFFH
   sub  ebx,eax
  add   ecx,ebp
   mov  PD [edi+C77C75],ebx
  mov   ebp,ecx
   and  ecx,0FFF8FFFFH
  shr   ecx,3
   lea  eax,[ebx+eax*2-0C000C000H]
  mov   ebx,esi
   and  esi,0FFFCFFFFH
  shr   esi,2
   lea  ecx,[ecx+ebp-07000700H]
  mov   PD [edi+C57C55],ecx
   add  esi,ebx
  mov   ebx,esi
   and  esi,0FFF8FFFFH
  shr   esi,3
   mov  ebp,S3
  mov   ecx,edx
   lea  esi,[esi+ebx-07000700H]
  mov   ebx,ebp
   ;
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  mov   PD [edi+C17C15],eax
   mov  PD [edi+C37C35],esi
  lea   eax,[edx+ecx]
   lea  esi,[ebx+ebp]
  shr   ebp,2
   and  ecx,0FFFCFFFFH
  shr   ecx,2
   and  ebp,0FFFF3FFFH
  add   ecx,eax
   add  ebp,esi
  shr   eax,5
   and  esi,0FFE0FFFFH
  shr   esi,5
   and  eax,0FFFF07FFH
  shr   edx,1
   and  ebx,0FFFEFFFFH
  shr   ebx,1
   and  edx,0FFFF7FFFH
  sub   ebx,ecx
   add  eax,ebp

  mov   ecx,CoeffStreamStart
   lea  ebp,[edi-SIZEOF T_CoeffBlk]  ; Advance cursor for block action stream.
  lea   ebx,[ebx+esi+0B180B180H]
   lea  edx,[eax+edx+009800980H]
  mov   PD [edi+C67C65],ebx
   mov  PD [edi+C27C25],edx

; Forward Slant Transform is done

  cmp   ebp,ecx
   mov  edi,ebp
  mov   CoeffStream,edi
   jae  NextBlock               ; Process next block.


Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FORWARDDCT endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ex5me.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\ex5me.asv   1.17   24 Sep 1996 11:27:00   BNICKERS  $
;//
;// $Log:   R:\h26x\h26x\src\enc\ex5me.asv  $
;// 
;//    Rev 1.17   24 Sep 1996 11:27:00   BNICKERS
;// 
;// Fix register colision.
;// 
;//    Rev 1.16   24 Sep 1996 10:40:32   BNICKERS
;// For H261, zero out motion vectors when classifying MB as Intra.
;// 
;//    Rev 1.13   19 Aug 1996 13:48:26   BNICKERS
;// Provide threshold and differential variables for spatial filtering.
;// 
;//    Rev 1.12   17 Jun 1996 15:19:34   BNICKERS
;// Fix recording of block and MB SWDs for Spatial Loop Filtering case in H261.
;// 
;//    Rev 1.11   30 May 1996 16:40:14   BNICKERS
;// Fix order of arguments.
;// 
;//    Rev 1.10   30 May 1996 15:08:36   BNICKERS
;// Fixed minor error in recent IA ME speed improvements.
;// 
;//    Rev 1.9   29 May 1996 15:37:58   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.8   15 Apr 1996 10:48:48   AKASAI
;// Fixed bug in Spatial loop filter code.  Code had been unrolled and
;// the second case had not been updated in the fix put in place of
;// (for) the first case.  Basically an ebx instead of bl that cased 
;// and overflow from 7F to 3F.
;// 
;//    Rev 1.7   15 Feb 1996 15:39:26   BNICKERS
;// No change.
;// 
;//    Rev 1.6   15 Feb 1996 14:39:00   BNICKERS
;// Fix bug wherein access to area outside stack frame was occurring.
;// 
;//    Rev 1.5   15 Jan 1996 14:31:40   BNICKERS
;// Fix decrement of ref area addr when half pel upward is best in block ME.
;// Broadcast macroblock level MV when block gets classified as Intra.
;// 
;//    Rev 1.4   12 Jan 1996 13:16:08   BNICKERS
;// Fix SLF so that 3 7F pels doesn't overflow, and result in 3F instead of 7F.
;// 
;//    Rev 1.3   27 Dec 1995 15:32:46   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   19 Dec 1995 17:11:16   RMCKENZX
;// fixed 2 bugs:
;//   1.  do +-15 pel search if central and NOT 4 mv / macroblock
;//      (was doing when central AND 4 mv / macroblock)
;//   2.  correctly compute motion vectors when doing 4 motion
;//      vectors per block.
;// 
;//    Rev 1.1   28 Nov 1995 15:25:48   AKASAI
;// Added white space so that will complie with the long lines.
;// 
;//    Rev 1.0   28 Nov 1995 14:37:00   BECHOLS
;// Initial revision.
;// 
;// 
;//    Rev 1.13   22 Nov 1995 15:32:42   DBRUCKS
;// Brian made this change on my system.
;// Increased a value to simplify debugging
;// 
;// 
;// 
;//    Rev 1.12   17 Nov 1995 10:43:58   BNICKERS
;// Fix problems with B-Frame ME.
;// 
;// 
;// 
;//    Rev 1.11   31 Oct 1995 11:44:26   BNICKERS
;// Save/restore ebx.
;//
;////////////////////////////////////////////////////////////////////////////
;
; MotionEstimation -- This function performs motion estimation for the macroblocks identified
;                     in the input list.
;                     Conditional assembly selects either the H263 or H261 version.
;
; Input Arguments:
;
;   MBlockActionStream
;
;     The list of macroblocks for which we need to perform motion estimation.
;
;     Upon input, the following fields must be defined:
;
;       CodedBlocks -- Bit 6 must be set for the last macroblock to be processed.
;
;       FirstMEState -- must be 0 for macroblocks that are forced to be Intracoded.  An
;                       IntraSWD will be calculated.
;                       Other macroblocks must have the following values:
;                        1:  upper left, without advanced prediction.  (Advanced prediction
;                            only applies to H263.)
;                        2:  upper edge, without advanced prediction.
;                        3:  upper right, without advanced prediction.
;                        4:  left edge, without advanced prediction.
;                        5:  central block, or any block if advanced prediction is being done.
;                        6:  right edge, without advanced prediction.
;                        7:  lower left, without advanced prediction.
;                        8:  lower edge, without advanced prediction.
;                        9:  lower right, without advanced prediction.
;                       If vertical motion is NOT allowed:
;                       10:  left edge, without advanced prediction.
;                       11:  central block, or any block if advanced prediction is being done.
;                       12:  right edge, without advanced prediction.
;                       *** Note that with advanced prediction, only initial states 0, 4, or
;                           11 can be specified.  Doing block level motion vectors mandates
;                           advanced prediction, but in that case, only initial
;                           states 0 and 4 are allowed.
;
;       BlkOffset -- must be defined for each of the blocks in the macroblocks.
;
;   TargetFrameBaseAddress -- Address of upper left viewable pel in the target Y plane.
;
;   PreviousFrameBaseAddress -- Address of upper left viewable pel in the previous Y plane.  Whether this is the
;                               reconstructed previous frame, or the original, is up to the caller to decide.
;
;   FilteredFrameBaseAddress -- Address of upper left viewable pel in the scratch area that this function can record
;                               the spatially filtered prediction for each block, so that frame differencing can
;                               utilize it rather than have to recompute it.  (H261 only)
;
;   DoRadius15Search -- TRUE if central macroblocks should search a distance of 15 from center.  Else searches 7 out.
;
;   DoHalfPelEstimation -- TRUE if we should do ME to half pel resolution.  This is only applicable for H263 and must
;                          be FALSE for H261.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   DoBlockLevelVectors -- TRUE if we should do ME at block level.  This is only applicable for H263 and must be FALSE
;                          for H261.  (Note:  TRUE must be 1; FALSE must be 0).
;   DoSpatialFiltering -- TRUE if we should determine if spatially filtering the prediction reduces the SWD.  Only
;                         applicable for H261 and must be FALSE for H263.  (Note:  TRUE must be 1;  FALSE must be 0).
;
;   ZeroVectorThreshold -- If the SWD for a macroblock is less than this threshold, we do not bother searching for a
;                          better motion vector.  Compute as follows, where D is the average tolerable pel difference
;                          to satisfy this threshold.  (Initial recommendation:  D=2  ==> ZVT=384)
;                             ZVT = (128 * ((int)((D**1.6)+.5)))
;
;   NonZeroDifferential -- After searching for the best motion vector (or individual block motion vectors, if enabled),
;                          if the macroblock's SWD is not better than it was for the zero vector -- not better by at
;                          least this amount -- then we revert to the zero vector.  We are comparing two macroblock
;                          SWDs, both calculated as follows:   (Initial recommendation:	 NZD=128)
;                            For each of 128 match points, where D is its Abs Diff, accumulate ((int)(M**1.6)+.5)))
;
;   BlockMVDifferential -- The amount by which the sum of four block level SWDs must be better than a single macroblock
;                          level SWD to cause us to choose block level motion vectors.  See NonZeroDifferential for
;                          how the SWDs are calculated.  Only applicable for H261.  (Initial recommendation:  BMVD=128)
;
;   EmptyThreshold -- If the SWD for a block is less than this, the block is forced empty.  Compute as follows, where D
;                     is the average tolerable pel diff to satisfy threshold.  (Initial recommendation:  D=3 ==> ET=96)
;                        ET = (32 * ((int)((D**1.6)+.5)))
;
;   InterCodingThreshold -- If any of the blocks are forced empty, we can simply skip calculating the INTRASWD for the
;                           macroblock.  If none of the blocks are forced empty, we will compare the macroblock's SWD
;                           against this threshold.  If below the threshold, we will likewise skip calculating the
;                           INTRASWD.  Otherwise, we will calculate the INTRASWD, and if it is less than the [Inter]SWD,
;                           we will classify the block as INTRA-coded.  Compute as follows, where D is the average
;                           tolerable pel difference to satisfy threshold.  (Initial recommendation:  D=4 ==> ICT=1152)
;                             ICT = (128 * ((int)((D**1.6)+.5)))
;
;   IntraCodingDifferential -- For INTRA coding to occur, the INTRASWD must be better than the INTERSWD by at least
;                              this amount.
;
; Output Arguments
;
;   MBlockActionStream
;
;     These fields are defined as follows upon return:
;
;       BlockType -- Set to INTRA, INTER1MV, or (H263 only) INTER4MV.
;
;       PHMV and PVMV -- The horizontal and vertical motion vectors,  in units of a half pel.
;
;       BHMV and BVMV -- These fields get clobbered.
;
;       PastRef -- If BlockType != INTRA, set to the address of the reference block.
;
;                  If Horizontal MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+1.
;
;                  If Vertical MV indicates a half pel position, the prediction for the upper left pel of the block
;                  is the average of the pel at PastRef and the one at PastRef+PITCH.
;
;                  If both MVs indicate half pel positions, the prediction for the upper left pel of the block is the
;                  average of the pels at PastRef, PastRef+1, PastRef+PITCH, and PastRef+PITCH+1.
;
;                  Indications of a half pel position can only happen for H263.
;
;                  In H261, when spatial filtering is done, the address will be in the SpatiallyFilteredFrame, where
;                  this function stashes the spatially filtered prediction for subsequent reuse by frame differencing.
;
;       CodedBlocks -- Bits 4 and 5 are turned on, indicating that the U and V blocks should be processed.  (If the
;                      FDCT function finds them to quantize to empty, it will mark them as empty.)
;
;                      Bits 0 thru 3 are cleared for each of blocks 1 thru 4 that MotionEstimation forces empty;
;                      they are set otherwise.
;
;                      Bits 6 and 7 are left unchanged.
;                      
;       SWD -- Set to the sum of the SWDs for the four luma blocks in the macroblock.  The SWD for any block that is
;              forced empty, is NOT included in the sum.
;
;
;
;   IntraSWDTotal  -- The sum of the block SWDs for all Intracoded macroblocks.
;
;   IntraSWDBlocks -- The number of blocks that make up the IntraSWDTotal.
;
;   InterSWDTotal  -- The sum of the block SWDs for all Intercoded macroblocks.
;                     None of the blocks forced empty are included in this.
;
;   InterSWDBlocks -- The number of blocks that make up the InterSWDTotal.
;
;
; Other assumptions:
;
;   For performance reasons, it is assumed that the layout of current and previous frames (and spatially filtered
;   frame for H261) rigourously conforms to the following guide.
;
;   The spatially filtered frame (only present and applicable for H261) is an output frame into which MotionEstimation
;   places spatially filtered macroblocks as it determines if filtering is good for a macroblock.  If it determines
;   such, frame differencing will be able to re-use the spatially filtered macroblock, rather than recomputing it.
;
;   Cache
;   Alignment
;   Points:  v       v       v       v       v       v       v       v       v       v       v       v       v
;             16 | 352 (narrower pictures are left justified)                                            | 16
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Current Frame Y Plane                                                                | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected.)                                                                |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Current Frame U Plane                    | D |  Current Frame V Plane                    |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;            72 dummy bytes.  I.e. enough dummy space to assure that MOD ((Previous_Frame - Current_Frame), 128) == 80
;            +-----------------------------------------------------------------------------------------------+
;            |                                                                                               |
;   16 lines | If Unrestricted Motion Vectors selected, 16 lines must appear above and below previous frame, |
;            | and these lines plus the 16 columns to the left and 16 columns to the right of the previous   |
;            | frame must be initialized to the values at the edges and corners, propagated outward.  If     |
;            | Unrestricted Motion Vectors is off, these lines don't have to be allocated.                   |
;            |                                                                                               |
;            |   +---------------------------------------------------------------------------------------+   +
;   Frame    |   |  Previous Frame Y Plane                                                               |   |
;   Height   |   |                                                                                       |   |
;   Lines    |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   |                                                                                       |   |
;            |   +---------------------------------------------------------------------------------------+   +
;            |                                                                                               |
;   16 lines | See comment above Previous Y Plane                                                            |
;            |                                                                                               |
;            |+--- 8 bytes of dummy space.  Must be there, whether unrestricted MV or not.                   |
;            ||                                                                                              |
;            |v+-----------------------------------------------+---------------------------------------------+-+
;            +-+                                               |                                               |
;              | See comment above Previous Y Plane.           | See comment above Previous Y Plane.           |
;   8 lines    | Same idea here, but 8 lines are needed above  | Same idea here, but 8 lines are needed        |
;              | and below U plane, and 8 columns on each side.| and below V plane, and 8 columns on each side.|
;              |                                               |                                               |
;              |8  176                                        8|8  176                                        8|
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              | |  Previous Frame U Plane                   | | |  Previous Frame V Plane                   | |
;   Frame      | |                                           | | |                                           | |
;   Height     | |                                           | | |                                           | |
;   Div By 2   | |                                           | | |                                           | |
;   Lines      | |                                           | | |                                           | |
;              | +-------------------------------------------+ | +-------------------------------------------+ |
;              |                                               |                                               |
;   8 lines    | See comment above Previous U Plane            | See comment above Previous V Plane            |
;              |                                               |                                               |
;              |                                               |                                               |
;              |                                               |                                               |
;              +-----------------------------------------------+---------------------------------------------+-+
;            Enough dummy space to assure that MOD ((Spatial_Frame - Previous_Frame), 4096) == 2032
;            +---+---------------------------------------------------------------------------------------+---+
;            | D |  Spatially Filtered Y Plane (present only for H261)                                   | D |
;            | u |                                                                                       | u |
;   Frame    | m |                                                                                       | m |
;   Height   | m |                                                                                       | m |
;   Lines    | y |                                                                                       | y |
;            |   |                                                                                       |   |
;            +---+---------------------------------------------------------------------------------------+---+
;            |                                                                                               |
;            |                                                                                               |
;            |                                                                                               |
;   24 lines |      Dummy Space (24 lines plus 8 bytes.  Can be reduced to 8 bytes if unrestricted motion    |
;            |      vectors is NOT selected, which is certainly the case for H261.)                          |
;            |                                                                                               |
;            |  8  176                                        16   176                                       |8
;            | +-+-------------------------------------------------------------------------------------------+-+
;            +-+D|  Spatially Filtered U plane (H261 only)   | D |  Spatially Filtered V plane (H261 only)   |D|
;   Frame      |u|                                           | u |                                           |u|
;   Height     |m|                                           | m |                                           |m|
;   Div By 2   |m|                                           | m |                                           |m|
;   Lines      |y|                                           | y |                                           |y|
;              +-+-------------------------------------------+---+-------------------------------------------+-+
;
; Cache layout of the target block and the full range for the reference area (as restricted to +/- 7 in vertical,
; and +/- 7 (expandable to +/- 15) in horizontal, is as shown here.  Each box represents a cache line (32 bytes),
; increasing incrementally from left to right, and then to the next row (like reading a book).  The 128 boxes taken
; as a whole represent 4Kbytes.  The boxes are populated as follows:
;
;   R -- Data from the reference area.  Each box contains 23 of the pels belonging to a line of the reference area.
;        The remaining 7 pels of the line is either in the box to the left (for reference areas used to provide
;        predictions for target macroblocks that begin at an address 0-mod-32), or to the right (for target MBs that
;        begin at an address 16-mod-32).  There are 30 R's corresponding to the 30-line limit on the vertical distance
;        we might search.
; 
;   T -- Data from the target macroblock.  Each box contains a full line (16 pels) for each of two adjacent
;        macroblocks.  There are 16 T's corresponding to the 16 lines of the macroblocks.
;
;   S -- Space for the spatially filtered macroblock (H261 only).
;
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+---+---+---+---+
;      | T |   | R |   | S |   | R |   |
;      +---+---+---+---+---+---+---+---+
;
; Thus, in a logical sense, the above data fits into one of the 4K data cache pages, leaving the other for all other
; data.  Care has been taken to assure that the tables and the stack space needed by this function fit nicely into
; the other data cache page.    Only the MBlockActionStream remains to conflict with the above data structures.  That
; is both unavoidable, and of minimal consequence.
; An algorithm has been selected that calculates fewer SWDs (Sum of Weighted Differences) than the typical log search.
; In the typical log search, a three level search is done, in which the SWDs are compared for the center point and a
; point at each 45 degrees, initially 4 pels away, then 2, then 1.  This requires a total of 25 SWDs for each
; macroblock (except those near edges or corners).
;
; In this algorithm, six levels are performed, with each odd level being a horizontal search, and each even level being
; a vertical search.  Each search compares the SWD for the center point with that of a point in each direction on the
; applicable axis.  This requires 13 SWDs, and a lot simpler control structure.  Here is an example picture of a
; search, in which "0" represents the initial center point (the 0,0 motion vector), "A", and "a" represent the first
; search points, etc.  In this example, the "winner" of each level of the search proceeds as follows:  a, B, C, C, E, F,
; arriving at a motion vector of -1 horizontal, 5 vertical.
;
;                ...............
;                ...............
;                ...............
;                ...b...........
;                ...............
;                ...............
;                ...............
;                ...a...0...A...
;                ...............
;                .....d.........
;                ......f........
;                .c.BeCE........
;                ......F........
;                .....D.........
;                ...............
;
;
; A word about data cache performance.  Conceptually, the tables and local variables used by this function are placed
; in memory such that they will fit in one 4K page of the on-chip data cache.  For the Pentium (tm) microprocessor,
; this leaves the other 4K page for other purposes.  The other data structures consist of:
;
;   The current frame, from which we need to access the lines of the 16*16 macroblock.  Since cache lines are 32 bytes
;   wide, the cache fill operations that fetch one target macroblock will serve to fetch the macroblock to the right,
;   so an average of 8 cache lines are fetched for each macroblock.
;
;   The previous frame, from which we need to access a reference area of 30*30 pels.  For each macroblock for which we
;   need to search for a motion vector, we will typically need to access no more than about 25 of these, but in general
;   these lines span the 30 lines of the search area.  Since cache lines are 32 bytes wide, the cache fill operations
;   that fetch reference data for one macroblock, will tend to fetch data that is useful as reference data for the
;   macroblock to the right, so an average of about 15 (rounded up to be safe) cache lines are fetched for each
;   macroblock.
;
;   The MBlockActionStream, which controls the searching (since we don't need to motion estimate blocks that are
;   legislated to be intra) will disrupt cache behaviour of the other data structures, but not to a significant degree.
;
; By setting the pitch to a constant of 384, and by allocating the frames as described above, the one available 4K page
; of data cache will be able to contain the 30 lines of the reference area, the 16 lines of the target area, and the
; 16 lines of the spatially filtered area (H261 only) without any collisions.
;
;
; Here is a flowchart of the major sections of this function:
;
; +-- Execute once for Y part of each macroblock that is NOT Intra By Decree --+
; |                                                                            |
; |   +---------------------------------------------------------------+        |
; |   |  1) Compute average value for target match points.            |        |
; |   |  2) Prepare match points in target MB for easier matching.    |        |
; |   |  3) Compute the SWD for (0,0) motion vector.                  |        |
; |   +---------------------------------------------------------------+        |
; |                 |                                                          |
; |                 v                                                          |
; |           /---------------------------------\  Yes                         |
; |          < 4) Is 0-motion SWD good enough?   >-------------------------+   |
; |           \---------------------------------/                          |   |
; |                                          |                             |   |
; |                                          |No                           |   |
; |                                          v                             |   |
; |     +--- 5) While state engine has more motion vectors to check ---+   |   |
; |     |                                                              |   |   |
; |     |                                                              |   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |   | 5) Compute SWDs for 2 ref MBs and pick best of 3. |----->|   |   |
; |     |   +---------------------------------------------------+      |   |   |
; |     |                                                              |   |   |
; |     +--------------------------------------------------------------+   |   |
; |                             |                                          |   |
; |                             v                                          |   |
; |                /-----------------------------------------\             |   |
; |               <  6) Is best motion vector the 0-vector?   >            |   |
; |                \-----------------------------------------/             |   |
; |                   |              |                                     |   |
; |                   |No            |Yes                                  |   |
; |                   v              v                                     |   |
; |     +-----------------+ +-------------------------------------------+  |   |
; |     | Mark all blocks | |  6) Identify as empty block any in which: |<-+   |
; |  +--| non-empty.      | |     -->  0-motion SWD < EmptyThresh, and  |      |
; |  |  +-----------------+ +-------------------------------------------+      |
; |  |                          |                                              |
; |  |                          v                                              |
; |  |   /--------------------------------\ Yes +--------------------------+   |
; |  |  <  6) Are all blocks marked empty? >--->|  6) Classify FORCEDEMPTY |-->|
; |  |   \--------------------------------/     +--------------------------+   |
; |  |                |                                                        |
; |  |                |No                                                      |
; |  |                v                                                        |
; |  |        /--------------------------------------------\                   |
; |  |       <  7) Are any non-phantom blocks marked empty? >                  |
; |  |        \--------------------------------------------/                   |
; |  |                |            |                                           |
; |  |                |No          |Yes                                        |
; |  v                v            v                                           |
; | +---------------------+   +--------------------------------+               |
; | | 8) Compute IntraSWD |   | Set IntraSWD artificially high |               |
; | +---------------------+   +--------------------------------+               |
; |              |                 |                                           |
; |              v                 v                                           |
; |         +-------------------------------+                                  |
; |         | 10) Classify block as one of: |                                  |
; |         |       INTRA                   |--------------------------------->|
; |         |       INTER                   |                                  |
; |         +-------------------------------+                                  |
; |                                                                            |
; +----------------------------------------------------------------------------+
;
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list
.DATA

;  Storage for tables and temps used by Motion Estimation function.  Fit into
;  4Kbytes contiguous memory so that it uses one cache page, leaving other
;  for reference area of previous frame and target macroblock of current frame.

PickPoint     DB  0,4,?,4,0,?,2,2 ; Map CF accum to new central pt selector.
PickPoint_BLS DB  6,4,?,4,6,?,2,2 ; Same, for when doing block level search.

OffsetToRef LABEL DWORD    ; Linearized adjustments to affect horz/vert motion.
   DD  ?        ; This index used when zero-valued motion vector is good enough.
   DD  0        ; Best fit of 3 SWDs is previous center.
   DD  1        ; Best fit of 3 SWDs is the ref block 1 pel to the right.
   DD -1        ; Best fit of 3 SWDs is the ref block 1 pel to the left.
   DD  1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel above.
   DD -1*PITCH  ; Best fit of 3 SWDs is the ref block 1 pel below.
   DD  2        ; Best fit of 3 SWDs is the ref block 2 pels to the right.
   DD -2        ; Best fit of 3 SWDs is the ref block 2 pels to the left.
   DD  2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel above.
   DD -2*PITCH  ; Best fit of 3 SWDs is the ref block 2 pel below.
   DD  4        ; Best fit of 3 SWDs is the ref block 4 pels to the right.
   DD -4        ; Best fit of 3 SWDs is the ref block 4 pels to the left.
   DD  4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel above.
   DD -4*PITCH  ; Best fit of 3 SWDs is the ref block 4 pel below.
   DD  7        ; Best fit of 3 SWDs is the ref block 7 pels to the right.
   DD -7        ; Best fit of 3 SWDs is the ref block 7 pels to the left.
   DD  7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel above.
   DD -7*PITCH  ; Best fit of 3 SWDs is the ref block 7 pel below.

M0   =  4  ; Define symbolic indices into OffsetToRef lookup table.
MHP1 =  8
MHN1 = 12
MVP1 = 16
MVN1 = 20
MHP2 = 24
MHN2 = 28
MVP2 = 32
MVN2 = 36
MHP4 = 40
MHN4 = 44
MVP4 = 48
MVN4 = 52
MHP7 = 56
MHN7 = 60
MVP7 = 64
MVN7 = 68

                ; Map linearized motion vector to vertical part.
                ; (Mask bottom byte of linearized MV to zero, then use result
                ; as index into this array to get vertical MV.)
IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
   DB -32, -32
   DB -30
   DB -28, -28
   DB -26
   DB -24, -24
   DB -22
   DB -20, -20
   DB -18
   DB -16, -16
   DB -14
   DB -12, -12
   DB -10
   DB  -8,  -8
   DB  -6
   DB  -4,  -4
   DB  -2
   DB   0
UnlinearizedVertMV  DB 0
   DB   2
   DB   4,   4
   DB   6
   DB   8,   8
   DB  10
   DB  12,  12
   DB  14
   DB  16,  16
   DB  18
   DB  20,  20
   DB  22
   DB  24,  24
   DB  26
   DB  28,  28
   DB  30

; Map initial states to initializers for half pel search.  Where search would
; illegally take us off edge of picture, set initializer artificially high.

InitHalfPelSearchHorz LABEL DWORD
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H
  DD 040000000H, 000000000H, 000004000H

InitHalfPelSearchVert LABEL DWORD
  DD 040000000H, 040000000H, 040000000H
  DD 000000000H, 000000000H, 000000000H
  DD 000004000H, 000004000H, 000004000H
  DD 040004000H, 040004000H, 040004000H


SWDState LABEL BYTE ; Rules that govern state engine of motion estimator.

   DB   8 DUP (?)       ; 0:  not used.

                        ; 1:  Upper Left Corner.  Explore 4 right and 4 down.
   DB  21, M0           ; (0,0)
   DB  22, MHP4         ; (0,4)
   DB  23, MVP4, ?, ?   ; (4,0)

                        ; 2:  Upper Edge.  Explore 4 left and 4 right.
   DB  22, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  22, MHP4, ?, ?   ; (0, 4)

                        ; 3:  Upper Right Corner.  Explore 4 right and 4 down.
   DB  31, M0           ; (0, 0)
   DB  22, MHN4         ; (0,-4)
   DB  32, MVP4, ?, ?   ; (4, 0)

                        ; 4:  Left Edge.  Explore 4 up and 4 down.
   DB  23, M0           ; ( 0,0)
   DB  23, MVN4         ; (-4,0)
   DB  23, MVP4, ?, ?   ; ( 4,0)

                        ; 5:  Interior Macroblock.  Explore 4 up and 4 down.
   DB  37, M0           ; ( 0,0)
   DB  37, MVN4         ; (-4,0)
   DB  37, MVP4, ?, ?   ; ( 4,0)

                        ; 6:  Right Edge.  Explore 4 up and 4 down.
   DB  32, M0           ; ( 0,0)
   DB  32, MVN4         ; (-4,0)
   DB  32, MVP4, ?, ?   ; ( 4,0)

                        ; 7:  Lower Left Corner.  Explore 4 up and 4 right.
   DB  38, M0           ; ( 0,0)
   DB  39, MHP4         ; ( 0,4)
   DB  23, MVN4, ?, ?   ; (-4,0)

                        ; 8:  Lower Edge.  Explore 4 left and 4 right.
   DB  39, M0           ; (0, 0)
   DB  39, MHN4         ; (0,-4)
   DB  39, MHP4, ?, ?   ; (0, 4)

                        ; 9:  Lower Right Corner.  Explore 4 up and 4 left.
   DB  44, M0           ; ( 0, 0)
   DB  39, MHN4         ; ( 0,-4)
   DB  32, MVN4, ?, ?   ; (-4, 0)

                        ; 10: Left Edge, No Vertical Motion Allowed.
   DB  46, M0           ; (0,0)
   DB  48, MHP2         ; (0,2)
   DB  47, MHP4, ?, ?   ; (0,4)

                        ; 11: Interior Macroblock, No Vertical Motion Allowed.
   DB  47, M0           ; (0, 0)
   DB  47, MHN4         ; (0,-4)
   DB  47, MHP4, ?, ?   ; (0, 4)

                        ; 12: Right Edge, No Vertical Motion Allowed.
   DB  49, M0           ; (0, 0)
   DB  48, MHN2         ; (0,-2)
   DB  47, MHN4, ?, ?   ; (0,-4)

                        ; 13: Horz by 2, Vert by 2, Horz by 1, Vert by 1.
   DB  14, M0 
   DB  14, MHP2 
   DB  14, MHN2, ?, ? 

                        ; 14: Vert by 2, Horz by 1, Vert by 1.
   DB  15, M0 
   DB  15, MVP2 
   DB  15, MVN2, ?, ? 

                        ; 15: Horz by 1, Vert by 1.
   DB  16, M0 
   DB  16, MHP1 
   DB  16, MHN1, ?, ? 

                        ; 16: Vert by 1.
   DB   0, M0
   DB   0, MVP1
   DB   0, MVN1, ?, ?

                        ; 17: Vert by 2, Horz by 2, Vert by 1, Horz by 1.
   DB  18, M0
   DB  18, MVP2
   DB  18, MVN2, ?, ?

                        ; 18: Horz by 2, Vert by 1, Horz by 1.
   DB  19, M0
   DB  19, MHP2
   DB  19, MHN2, ?, ?

                        ; 19: Vert by 1, Horz by 1.
   DB  20, M0
   DB  20, MVP1
   DB  20, MVN1, ?, ?

                        ; 20: Horz by 1.
   DB   0, M0
   DB   0, MHP1
   DB   0, MHN1, ?, ?

                        ; 21: From 1A.  Upper Left.  Try 2 right and 2 down.
   DB  24, M0           ; (0, 0)
   DB  25, MHP2         ; (0, 2)
   DB  26, MVP2, ?, ?   ; (2, 0)

                        ; 22: From  1B.
                        ;     From  2  center point would be (0,-4/0/4).
                        ;     From  3B center point would be (0,-4).
   DB  27, M0           ; (0, 4)
   DB  18, MVP2         ; (2, 4) Next: Horz 2, Vert 1, Horz 1.         (1:3,1:7)
   DB  13, MVP4, ?, ?   ; (4, 4) Next: Horz 2, Vert 2, Horz 1, Vert 1. (1:7,1:7)

                        ; 23: From  1C.
                        ;     From  4  center point would be (-4/0/4,0).
                        ;     From  7C center point would be (-4,0).
   DB  29, M0           ; (4, 0)
   DB  14, MHP2         ; (4, 2) Next: Vert 2, Horz 1, Vert 1.         (1:7,1:3)
   DB  17, MHP4, ?, ?   ; (4, 4) Next: Vert 2, Horz 2, Vert 1, Horz 1. (1:7,1:7)

                        ; 24: From 21A.  Upper Left.  Try 1 right and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHP1         ; (1, 0)
   DB   0, MVP1, ?, ?   ; (0, 1)

                        ; 25: From 21B.
                        ;     From 31B center point would be (0,-2).
   DB  20, M0           ; (0, 2) Next: Horz 1                            (0,1:3)
   DB  20, MVP1         ; (1, 2) Next: Horz 1                            (1,1:3)
   DB  15, MVP2, ?, ?   ; (2, 2) Next: Horz 1, Vert 1                  (1:3,1:3)

                        ; 26: From 21C.
                        ;     From 38C center point would be (-2,0).
   DB  16, M0           ; (2, 0) Next: Vert 1                            (1:3,0)
   DB  16, MHP1         ; (2, 1) Next: Vert 1                            (1:3,1)
   DB  19, MHP2, ?, ?   ; (2, 2) Next: Vert 1, Horz 1                  (1:3,1:3)

                        ; 27: From 22A.
   DB  28, M0           ; (0, 4)
   DB  28, MHN2         ; (0, 2)
   DB  28, MHP2, ?, ?   ; (0, 6)

                        ; 28: From 27.
   DB  20, M0           ; (0, 2/4/6) Next: Horz 1.                       (0,1:7)
   DB  20, MVP1         ; (1, 2/4/6) Next: Horz 1.                       (1,1:7)
   DB  20, MVP2, ?, ?   ; (2, 2/4/6) Next: Horz 1.                       (2,1:7)

                        ; 29: From 23A.
   DB  30, M0           ; (4, 0)
   DB  30, MVN2         ; (2, 0)
   DB  30, MVP2, ?, ?   ; (6, 0)

                        ; 30: From 29.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                       (1:7,0)
   DB  16, MHP1         ; (2/4/6, 1) Next: Vert 1.                       (1:7,1)
   DB  16, MHP2, ?, ?   ; (2/4/6, 2) Next: Vert 1.                       (1:7,2)

                        ; 31: From  3A.  Upper Right.  Try 2 left and 2 down.
   DB  33, M0           ; (0, 0)
   DB  25, MHN2         ; (0,-2)
   DB  34, MVP2, ?, ?   ; (2, 0)

                        ; 32: From  3C.
                        ;     From  6  center point would be (-4/0/4, 0)
                        ;     From  9C center point would be (-4, 0)
   DB  35, M0           ; (4, 0)
   DB  14, MHN2         ; (4,-2) Next: Vert2,Horz1,Vert1.            (1:7,-1:-3)
   DB  17, MHN4, ?, ?   ; (4,-4) Next: Vert2,Horz2,Vert1,Horz1.      (1:7,-1:-7)

                        ; 33: From 31A.  Upper Right.  Try 1 left and 1 down.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MVP1, ?, ?   ; (1, 0)

                        ; 34: From 31C.
                        ;     From 44C center point would be (-2, 0)
   DB  16, M0           ; (2, 0) Next: Vert 1                           (1:3, 0)
   DB  16, MHN1         ; (2,-1) Next: Vert 1                           (1:3,-1)
   DB  19, MHN2, ?, ?   ; (2,-2) Next: Vert 1, Horz 1                (1:3,-1:-3)

                        ; 35: From 32A.
   DB  36, M0           ; (4, 0)
   DB  36, MVN2         ; (2, 0)
   DB  36, MVP2, ?, ?   ; (6, 0)

                        ; 36: From 35.
   DB  16, M0           ; (2/4/6, 0) Next: Vert 1.                      (1:7, 0)
   DB  16, MHN1         ; (2/4/6,-1) Next: Vert 1.                      (1:7,-1)
   DB  16, MHN2, ?, ?   ; (2/4/6,-2) Next: Vert 1.                      (1:7,-2)

                        ; 37: From  5.
   DB  17, M0           ; (-4/0/4, 0) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-3: 3)
   DB  17, MHP4         ; (-4/0/4,-4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7, 1: 7)
   DB  17, MHN4, ?, ?   ; (-4/0/4, 4) Next: Vert2,Horz2,Vert1,Horz1 (-7:7,-7:-1)

                        ; 38: From 7A.  Lower Left.  Try 2 right and 2 up.
   DB  42, M0           ; ( 0,0)
   DB  43, MHP2         ; ( 0,2)
   DB  26, MVN2, ?, ?   ; (-2,0)

                        ; 39: From 13B.
                        ;     From 14  center point would be (0,-4/0/4)
                        ;     From 16B center point would be (0,-4)
   DB  40, M0           ; ( 0,4)
   DB  18, MVN2         ; (-2,4) Next: Horz2,Vert1,Horz1.            (-3:-1,1:7)
   DB  13, MVN4, ?, ?   ; (-4,4) Next: Horz2,Vert2,Horz1,Vert1.      (-7:-1,1:7)

                        ; 40: From 39A.
   DB  41, M0           ; (0, 4)
   DB  41, MHN2         ; (0, 2)
   DB  41, MHP2, ?, ?   ; (0, 6)

                        ; 41: From 40.
   DB  20, M0           ; ( 0,2/4/6) Next: Horz 1.                      ( 0,1:7)
   DB  20, MVN1         ; (-1,2/4/6) Next: Horz 1.                      (-1,1:7)
   DB  20, MVN2, ?, ?   ; (-2,2/4/6) Next: Horz 1.                      (-2,1:7)

                        ; 42: From 38A.  Lower Left.  Try 1 right and 1 up.
   DB   0, M0           ; ( 0,0)
   DB   0, MHP1         ; ( 0,1)
   DB   0, MVN1, ?, ?   ; (-1,0)

                        ; 43: From 38B.
                        ;     From 44B center point would be (0,-2)
   DB  20, M0           ; ( 0,2) Next: Horz 1                           ( 0,1:3)
   DB  20, MVN1         ; (-1,2) Next: Horz 1                           (-1,1:3)
   DB  15, MVN2, ?, ?   ; (-2,2) Next: Horz 1, Vert 1                (-1:-3,1:3)

                        ; 44: From 9A.  Lower Right.  Try 2 left and 2 up.
   DB  45, M0           ; ( 0, 0)
   DB  43, MHN2         ; ( 0,-2)
   DB  34, MVN2, ?, ?   ; (-2, 0)

                        ; 45: From 44A.  Lower Right.  Try 1 left and 1 up.
   DB   0, M0           ; ( 0, 0)
   DB   0, MHN1         ; ( 0,-1)
   DB   0, MVN1, ?, ?   ; (-1, 0)

                        ; 46: From 17A.
   DB   0, M0           ; (0,0)
   DB   0, MHP1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,1)

                        ; 47: From 10C.
                        ;     From 11 center point would be (0,4/0/-4)
                        ;     From 12C center point would be (0,-4)
   DB  48, M0           ; (0,4)
   DB  48, MHN2         ; (0,2)
   DB  48, MHP2, ?, ?   ; (0,6)

                        ; 48 From 10B.
                        ;    From 47  center point would be (0,2/4/6)
                        ;    From 12B center point would be (0,-2)
   DB   0, M0           ; (0,2)
   DB   0, MHN1         ; (0,1)
   DB   0, MHP1, ?, ?   ; (0,3)

                        ; 49 From 12A.
   DB   0, M0           ; (0, 0)
   DB   0, MHN1         ; (0,-1)
   DB   0, MHN1, ?, ?   ; (0,-1)

                        ; 50:  Interior Macroblock.  Explore 7 up and 7 down.
   DB  51, M0           ; ( 0,0)
   DB  51, MVN7         ; (-7,0)
   DB  51, MVP7, ?, ?   ; ( 7,0)

                        ; 51:  Explore 7 left and 7 right.
   DB   5, M0           ; (-7|0|7, 0)
   DB   5, MHN7         ; (-7|0|7,-7)
   DB   5, MHP7, ?, ?   ; (-7|0|7, 7)

MulByNeg8 LABEL DWORD

CNT = 0
REPEAT 128
  DD WeightedDiff+CNT
  CNT = CNT - 8
ENDM


  ; The following treachery puts the numbers into byte 2 of each aligned DWORD.
  DB   0,  0
  DD 193 DUP (255)
  DD 250,243,237,231,225,219,213,207,201,195,189,184,178,172,167,162,156
  DD 151,146,141,135,130,126,121,116,111,107,102, 97, 93, 89, 84, 80, 76
  DD  72, 68, 64, 61, 57, 53, 50, 46, 43, 40, 37, 34, 31, 28, 25, 22, 20
  DD  18, 15, 13, 11,  9,  7,  6,  4,  3,  2,  1
  DB   0,  0
WeightedDiff LABEL DWORD
  DB   0,  0
  DD   0,  0,  1,  2,  3,  4,  6,  7,  9, 11, 13, 15, 18
  DD  20, 22, 25, 28, 31, 34, 37, 40, 43, 46, 50, 53, 57, 61, 64, 68, 72
  DD  76, 80, 84, 89, 93, 97,102,107,111,116,121,126,130,135,141,146,151
  DD 156,162,167,172,178,184,189,195,201,207,213,219,225,231,237,243,250
  DD 191 DUP (255)
  DB 255,  0


MotionOffsets DD 1*PITCH,0,?,?

RemnantOfCacheLine DB 8 DUP (?)


LocalStorage LABEL DWORD  ; Local storage goes on the stack at addresses
                          ; whose lower 12 bits match this address.

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

MOTIONESTIMATION proc C AMBAS: DWORD,
ATargFrmBase: DWORD,
APrevFrmBase: DWORD,
AFiltFrmBase: DWORD,
ADo15Search: DWORD,
ADoHalfPelEst: DWORD,
ADoBlkLvlVec: DWORD,
ADoSpatialFilt: DWORD,
AZeroVectorThresh: DWORD,
ANonZeroMVDiff: DWORD,
ABlockMVDiff: DWORD,
AEmptyThresh: DWORD,
AInterCodThresh: DWORD,
AIntraCodDiff: DWORD,
ASpatialFiltThresh: DWORD,
ASpatialFiltDiff: DWORD,
AIntraSWDTot: DWORD,
AIntraSWDBlks: DWORD,
AInterSWDTot: DWORD,
AInterSWDBlks: DWORD

LocalFrameSize = 128 + 168*4 + 32   ; 128 for locals;  168*4 for blocks;  32 for dummy block.
RegStoSize = 16

; Arguments:

MBlockActionStream_arg       = RegStoSize +  4
TargetFrameBaseAddress_arg   = RegStoSize +  8
PreviousFrameBaseAddress_arg = RegStoSize + 12
FilteredFrameBaseAddress_arg = RegStoSize + 16
DoRadius15Search_arg         = RegStoSize + 20
DoHalfPelEstimation_arg      = RegStoSize + 24
DoBlockLevelVectors_arg      = RegStoSize + 28
DoSpatialFiltering_arg       = RegStoSize + 32
ZeroVectorThreshold_arg      = RegStoSize + 36
NonZeroMVDifferential_arg    = RegStoSize + 40
BlockMVDifferential_arg      = RegStoSize + 44
EmptyThreshold_arg           = RegStoSize + 48
InterCodingThreshold_arg     = RegStoSize + 52
IntraCodingDifferential_arg  = RegStoSize + 56
SpatialFiltThreshold_arg     = RegStoSize + 60
SpatialFiltDifferential_arg  = RegStoSize + 64
IntraSWDTotal_arg            = RegStoSize + 68
IntraSWDBlocks_arg           = RegStoSize + 72
InterSWDTotal_arg            = RegStoSize + 76
InterSWDBlocks_arg           = RegStoSize + 80
EndOfArgList                 = RegStoSize + 84

; Locals (on local stack frame)

MBlockActionStream       EQU [esp+   0]
CurrSWDState             EQU [esp+   4]
MotionOffsetsCursor      EQU CurrSWDState
HalfPelHorzSavings       EQU CurrSWDState
VertFilterDoneAddr       EQU CurrSWDState
IntraSWDTotal            EQU [esp+   8]
IntraSWDBlocks           EQU [esp+  12]
InterSWDTotal            EQU [esp+  16]
InterSWDBlocks           EQU [esp+  20]

MBCentralInterSWD        EQU [esp+  24]
MBRef1InterSWD           EQU [esp+  28]
MBRef2InterSWD           EQU [esp+  32]
MBCentralInterSWD_BLS    EQU [esp+  36]
MB0MVInterSWD            EQU [esp+  40]
MBAddrCentralPoint       EQU [esp+  44]
MBMotionVectors          EQU [esp+  48]

DoHalfPelEstimation      EQU [esp+  52]
DoBlockLevelVectors      EQU [esp+  56]
DoSpatialFiltering       EQU [esp+  60]
ZeroVectorThreshold      EQU [esp+  64]
NonZeroMVDifferential    EQU [esp+  68]
BlockMVDifferential      EQU [esp+  72]
EmptyThreshold           EQU [esp+  76]
InterCodingThreshold     EQU [esp+  80]
IntraCodingDifferential  EQU [esp+  84]
SpatialFiltThreshold     EQU [esp+  88]
SpatialFiltDifferential  EQU [esp+  92]
TargetMBAddr             EQU [esp+  96]
TargetFrameBaseAddress   EQU [esp+ 100]
PreviousFrameBaseAddress EQU [esp+ 104]
TargToRef                EQU [esp+ 108]
TargToSLF                EQU [esp+ 112]
DoRadius15Search         EQU [esp+ 116]

StashESP                 EQU [esp+ 120]

BlockLen                 EQU 168
Block1                   EQU [esp+  128+40]      ; "128" is for locals.  "40" is so offsets range from -40 to 124.
Block2                   EQU Block1  + BlockLen
Block3                   EQU Block2  + BlockLen
Block4                   EQU Block3  + BlockLen
BlockN                   EQU Block4  + BlockLen
BlockNM1                 EQU Block4
BlockNM2                 EQU Block3
BlockNP1                 EQU Block4  + BlockLen + BlockLen
DummyBlock               EQU Block4  + BlockLen


Ref1Addr                 EQU  -40
Ref2Addr                 EQU  -36
AddrCentralPoint         EQU  -32
CentralInterSWD          EQU  -28
Ref1InterSWD             EQU  -24
Ref2InterSWD             EQU  -20
CentralInterSWD_BLS      EQU  -16  ; CentralInterSWD, when doing blk level search.
CentralInterSWD_SLF      EQU  -16  ; CentralInterSWD, when doing spatial filter.
HalfPelSavings           EQU  Ref2Addr
ZeroMVInterSWD           EQU  -12
BlkHMV                   EQU   -8
BlkVMV                   EQU   -7
BlkMVs                   EQU   -8
AccumTargetPels          EQU   -4

; Offsets for Negated Quadrupled Target Pels:
N8T00                    EQU    0
N8T04                    EQU    4
N8T02                    EQU    8
N8T06                    EQU   12
N8T20                    EQU   16
N8T24                    EQU   20
N8T22                    EQU   24
N8T26                    EQU   28
N8T40                    EQU   32
N8T44                    EQU   36
N8T42                    EQU   40
N8T46                    EQU   44
N8T60                    EQU   48
N8T64                    EQU   52
N8T62                    EQU   56
N8T66                    EQU   60
N8T11                    EQU   64
N8T15                    EQU   68
N8T13                    EQU   72
N8T17                    EQU   76
N8T31                    EQU   80
N8T35                    EQU   84
N8T33                    EQU   88
N8T37                    EQU   92
N8T51                    EQU   96
N8T55                    EQU  100
N8T53                    EQU  104
N8T57                    EQU  108
N8T71                    EQU  112
N8T75                    EQU  116
N8T73                    EQU  120
N8T77                    EQU  124

  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov   esi,esp
   sub  esp,000001000H
  mov   eax,[esp]                   ; Cause system to commit page.
   sub  esp,000001000H
  and   esp,0FFFFF000H
   mov  ebx,OFFSET LocalStorage+31
  and   ebx,000000FE0H
   mov  edx,PD [esi+MBlockActionStream_arg]
  or    esp,ebx
   mov  eax,PD [esi+TargetFrameBaseAddress_arg]
  mov   TargetFrameBaseAddress,eax
   mov  ebx,PD [esi+PreviousFrameBaseAddress_arg]
  mov   PreviousFrameBaseAddress,ebx
   sub  ebx,eax
  mov   ecx,PD [esi+FilteredFrameBaseAddress_arg]
  sub   ecx,eax
   mov  TargToRef,ebx
  mov   TargToSLF,ecx
   mov  eax,PD [esi+EmptyThreshold_arg]
  mov   EmptyThreshold,eax
   mov  eax,PD [esi+DoHalfPelEstimation_arg]
  mov   DoHalfPelEstimation,eax
   mov  eax,PD [esi+DoBlockLevelVectors_arg]
  mov   DoBlockLevelVectors,eax
   mov  eax,PD [esi+DoRadius15Search_arg]
  mov   DoRadius15Search,eax
   mov  eax,PD [esi+DoSpatialFiltering_arg]
  mov   DoSpatialFiltering,eax
   mov  eax,PD [esi+ZeroVectorThreshold_arg]
  mov   ZeroVectorThreshold,eax
   mov  eax,PD [esi+NonZeroMVDifferential_arg]
  mov   NonZeroMVDifferential,eax
   mov  eax,PD [esi+BlockMVDifferential_arg]
  mov   BlockMVDifferential,eax
   mov  eax,PD [esi+InterCodingThreshold_arg]
  mov   InterCodingThreshold,eax
   mov  eax,PD [esi+IntraCodingDifferential_arg]
  mov   IntraCodingDifferential,eax
   mov  eax,PD [esi+SpatialFiltThreshold_arg]
  mov   SpatialFiltThreshold,eax
   mov  eax,PD [esi+SpatialFiltDifferential_arg]
  mov   SpatialFiltDifferential,eax
   xor  ebx,ebx
  mov   IntraSWDBlocks,ebx
   mov  InterSWDBlocks,ebx
  mov   IntraSWDTotal,ebx
   mov  InterSWDTotal,ebx
  mov   Block1.BlkMVs,ebx
   mov  Block2.BlkMVs,ebx
  mov   Block3.BlkMVs,ebx
   mov  Block4.BlkMVs,ebx
  mov   DummyBlock.Ref1Addr,esp
   mov  DummyBlock.Ref2Addr,esp
  mov   StashESP,esi
   jmp  FirstMacroBlock

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     1)  To calculate an average value for the target match points of each
;         block, we sum the 32 match points.  The totals for each of the 4
;         blocks is output seperately.
;
;     2)  Define each prepared match point in the target macroblock as the
;         real match point times negative 8, with the base address of the
;         WeightedDiff lookup table added.  I.e.
;
;           for (i = 0; i < 16; i += 2)
;             for (j = 0; j < 16; j += 2)
;               N8T[i][j] = ( -8 * Target[i][j]) + ((U32) WeightedDiff);
;
;         Both the multiply and the add of the WeightedDiff array base are
;         effected by a table lookup into the array MulByNeg8.
;
;         Then the SWD of a reference macroblock can be calculated as follows:
;
;           SWD = 0;
;           for each match point (i,j)
;               SWD += *((U32 *) (N8T[i][j] + 8 * Ref[i][j]));
;
;         In assembly, the fetch of WeightedDiff array element amounts to this:
;
;           mov edi,DWORD PTR N8T[i][j]   ; Fetch N8T[i][j]
;           mov dl,BYTE PTR Ref[i][j]     ; Fetch Ref[i][j]
;           mov edi,DWORD PTR[edi+edx*8]  ; Fetch WeithtedDiff of target & ref.
;
;     3)  We calculate the 0-motion SWD, as described just above.  We use 32
;         match points per block, and write the result seperately for each
;         block.  The result is accumulated into the high half of ebp.
;
;     4)  If the SWD for the 0-motion vector is below a threshold, we don't
;         bother searching for other possibly better motion vectors.  Presently,
;         this threshold is set such that an average difference of less than
;         three per match point causes the 0-motion vector to be accepted.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edx -- MBlockActionStream
;
;   Predominate usage for body of this section:
;
;     esi -- Target block address.
;     edi -- 0-motion reference block address.
;     ebp[ 0:12] -- Accumulator for target pels.
;     ebp[13:15] -- Loop control
;     ebp[16:31] -- Accumulator for weighted diff between target and 0-MV ref. 
;     edx -- Address at which to store -8 times pels.
;     ecx -- A reference pel.
;     ebx -- A target pel.
;     eax -- A target pel times -8;  and a weighted difference.
;
; Expected Pentium (tm) microprocessor performance for section:
;
;   Executed once per macroblock.
;
;   520 clocks for instruction execution
;     8 clocks for bank conflicts (64 dual mem ops with 1/8 chance of conflict)
;    80 clocks generously estimated for an average of 8 cache line fills for
;       the target macroblock and 8 cache line fills for the reference area.
;  ----
;   608 clocks total time for this section.
;

NextMacroBlock:

  mov   bl,[edx].CodedBlocks
   add  edx,SIZEOF T_MacroBlockActionDescr
  and   ebx,000000040H                ; Check for end-of-stream
   jne  Done

FirstMacroBlock:

  mov   cl,[edx].CodedBlocks          ; Init CBP for macroblock.
   mov  ebp,TargetFrameBaseAddress
  mov   bl,[edx].FirstMEState         ; First State
   mov  eax,DoRadius15Search          ; Searching 15 full pels out, or just 7?
  neg   al                            ; doing blk lvl => al=0, not => al=-1
  or    cl,03FH                       ; Indicate all 6 blocks are coded.
   and  al,bl
  mov   esi,[edx].BlkY1.BlkOffset     ; Get address of next macroblock to do.
   cmp  al,5
  jne   @f
  mov   bl,50                         ; Cause us to search +/- 15 if central
  ;                                   ; block and willing to go that far.
@@:
   mov  edi,TargToRef
  add   esi,ebp
   mov  CurrSWDState,ebx              ; Stash First State Number as current.
  add   edi,esi
   xor  ebp,ebp
  mov   TargetMBAddr,esi              ; Stash address of target macroblock.
   mov  MBlockActionStream,edx        ; Stash list ptr.
  mov   [edx].CodedBlocks,cl
   mov  ecx,INTER1MV                  ; Speculate INTER-coding, 1 motion vector.
  mov   [edx].BlockType,cl
   lea  edx,Block1

PrepMatchPointsNextBlock:

  mov   bl,PB [esi+6]                 ; 06A -- Target Pel 00.
  add   ebp,ebx                       ; 06B -- Accumulate target pels.
   mov  cl,PB [edi+6]                 ; 06C -- Reference Pel 00.
  mov   eax,MulByNeg8[ebx*4]          ; 06D -- Target Pel 00 * -8.
   mov  bl,PB [esi+4]                 ; 04A
  mov   [edx].N8T06,eax               ; 06E -- Store negated quadrupled Pel 00.
   add  ebp,ebx                       ; 04B
  mov   eax,PD [eax+ecx*8]            ; 06F -- Weighted difference for Pel 00.
   mov  cl,PB [edi+4]                 ; 04C
  add   ebp,eax                       ; 06G -- Accumulate weighted difference.
   mov  eax,MulByNeg8[ebx*4]          ; 04D
  mov   bl,PB [esi+2]                 ; 02A
   mov  [edx].N8T04,eax               ; 04E
  add   ebp,ebx                       ; 02B
   mov  eax,PD [eax+ecx*8]            ; 04F
  mov   cl,PB [edi+2]                 ; 02C
   add  ebp,eax                       ; 04G
  mov   eax,MulByNeg8[ebx*4]          ; 02D
   mov  bl,PB [esi]                   ; 00A
  mov   [edx].N8T02,eax               ; 02E
   add  ebp,ebx                       ; 00B
  mov   eax,PD [eax+ecx*8]            ; 02F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 00C
   add  edi,PITCH+1
  lea   ebp,[ebp+eax+000004000H]      ; 02G  (plus loop control)
   mov  eax,MulByNeg8[ebx*4]          ; 00D
  mov   bl,PB [esi+6]                 ; 17A
   mov  [edx].N8T00,eax               ; 00E
  add   ebp,ebx                       ; 17B
   mov  eax,PD [eax+ecx*8]            ; 00F
  mov   cl,PB [edi+6]                 ; 17C
   add  ebp,eax                       ; 00G
  mov   eax,MulByNeg8[ebx*4]          ; 17D
   mov  bl,PB [esi+4]                 ; 15A
  mov   [edx].N8T17,eax               ; 17E
   add  ebp,ebx                       ; 15B
  mov   eax,PD [eax+ecx*8]            ; 17F
   mov  cl,PB [edi+4]                 ; 15C
  add   ebp,eax                       ; 17G
   mov  eax,MulByNeg8[ebx*4]          ; 15D
  mov   bl,PB [esi+2]                 ; 13A
   mov  [edx].N8T15,eax               ; 15E
  add   ebp,ebx                       ; 13B
   mov  eax,PD [eax+ecx*8]            ; 15F
  mov   cl,PB [edi+2]                 ; 13C
   add  ebp,eax                       ; 15G
  mov   eax,MulByNeg8[ebx*4]          ; 13D
   mov  bl,PB [esi]                   ; 11A
  mov   [edx].N8T13,eax               ; 13E
   add  ebp,ebx                       ; 11B
  mov   eax,PD [eax+ecx*8]            ; 13F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 11C
   add  edi,PITCH-1
  add   ebp,eax                       ; 13G
   mov  eax,MulByNeg8[ebx*4]          ; 11D
  mov   bl,PB [esi+6]                 ; 26A
   mov  [edx].N8T11,eax               ; 11E
  add   ebp,ebx                       ; 26B
   mov  eax,PD [eax+ecx*8]            ; 11F
  mov   cl,PB [edi+6]                 ; 26C
   add  ebp,eax                       ; 11G
  mov   eax,MulByNeg8[ebx*4]          ; 26D
   mov  bl,PB [esi+4]                 ; 24A
  mov   [edx].N8T26,eax               ; 26E
   add  ebp,ebx                       ; 24B
  mov   eax,PD [eax+ecx*8]            ; 26F
   mov  cl,PB [edi+4]                 ; 24C
  add   ebp,eax                       ; 26G
   mov  eax,MulByNeg8[ebx*4]          ; 24D
  mov   bl,PB [esi+2]                 ; 22A
   mov  [edx].N8T24,eax               ; 24E
  add   ebp,ebx                       ; 22B
   mov  eax,PD [eax+ecx*8]            ; 24F
  mov   cl,PB [edi+2]                 ; 22C
   add  ebp,eax                       ; 24G
  mov   eax,MulByNeg8[ebx*4]          ; 22D
   mov  bl,PB [esi]                   ; 20A
  mov   [edx].N8T22,eax               ; 22E
   add  ebp,ebx                       ; 20B
  mov   eax,PD [eax+ecx*8]            ; 22F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 20C
   add  edi,PITCH+1
  add   ebp,eax                       ; 22G
   mov  eax,MulByNeg8[ebx*4]          ; 20D
  mov   bl,PB [esi+6]                 ; 37A
   mov  [edx].N8T20,eax               ; 20E
  add   ebp,ebx                       ; 37B
   mov  eax,PD [eax+ecx*8]            ; 20F
  mov   cl,PB [edi+6]                 ; 37C
   add  ebp,eax                       ; 20G
  mov   eax,MulByNeg8[ebx*4]          ; 37D
   mov  bl,PB [esi+4]                 ; 35A
  mov   [edx].N8T37,eax               ; 37E
   add  ebp,ebx                       ; 35B
  mov   eax,PD [eax+ecx*8]            ; 37F
   mov  cl,PB [edi+4]                 ; 35C
  add   ebp,eax                       ; 37G
   mov  eax,MulByNeg8[ebx*4]          ; 35D
  mov   bl,PB [esi+2]                 ; 33A
   mov  [edx].N8T35,eax               ; 35E
  add   ebp,ebx                       ; 33B
   mov  eax,PD [eax+ecx*8]            ; 35F
  mov   cl,PB [edi+2]                 ; 33C
   add  ebp,eax                       ; 35G
  mov   eax,MulByNeg8[ebx*4]          ; 33D
   mov  bl,PB [esi]                   ; 31A
  mov   [edx].N8T33,eax               ; 33E
   add  ebp,ebx                       ; 31B
  mov   eax,PD [eax+ecx*8]            ; 33F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 31C
   add  edi,PITCH-1
  add   ebp,eax                       ; 33G
   mov  eax,MulByNeg8[ebx*4]          ; 31D
  mov   bl,PB [esi+6]                 ; 46A
   mov  [edx].N8T31,eax               ; 31E
  add   ebp,ebx                       ; 46B
   mov  eax,PD [eax+ecx*8]            ; 31F
  mov   cl,PB [edi+6]                 ; 46C
   add  ebp,eax                       ; 31G
  mov   eax,MulByNeg8[ebx*4]          ; 46D
   mov  bl,PB [esi+4]                 ; 44A
  mov   [edx].N8T46,eax               ; 46E
   add  ebp,ebx                       ; 44B
  mov   eax,PD [eax+ecx*8]            ; 46F
   mov  cl,PB [edi+4]                 ; 44C
  add   ebp,eax                       ; 46G
   mov  eax,MulByNeg8[ebx*4]          ; 44D
  mov   bl,PB [esi+2]                 ; 42A
   mov  [edx].N8T44,eax               ; 44E
  add   ebp,ebx                       ; 42B
   mov  eax,PD [eax+ecx*8]            ; 44F
  mov   cl,PB [edi+2]                 ; 42C
   add  ebp,eax                       ; 44G
  mov   eax,MulByNeg8[ebx*4]          ; 42D
   mov  bl,PB [esi]                   ; 40A
  mov   [edx].N8T42,eax               ; 42E
   add  ebp,ebx                       ; 40B
  mov   eax,PD [eax+ecx*8]            ; 42F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 40C
   add  edi,PITCH+1
  add   ebp,eax                       ; 42G
   mov  eax,MulByNeg8[ebx*4]          ; 40D
  mov   bl,PB [esi+6]                 ; 57A
   mov  [edx].N8T40,eax               ; 40E
  add   ebp,ebx                       ; 57B
   mov  eax,PD [eax+ecx*8]            ; 40F
  mov   cl,PB [edi+6]                 ; 57C
   add  ebp,eax                       ; 40G
  mov   eax,MulByNeg8[ebx*4]          ; 57D
   mov  bl,PB [esi+4]                 ; 55A
  mov   [edx].N8T57,eax               ; 57E
   add  ebp,ebx                       ; 55B
  mov   eax,PD [eax+ecx*8]            ; 57F
   mov  cl,PB [edi+4]                 ; 55C
  add   ebp,eax                       ; 57G
   mov  eax,MulByNeg8[ebx*4]          ; 55D
  mov   bl,PB [esi+2]                 ; 53A
   mov  [edx].N8T55,eax               ; 55E
  add   ebp,ebx                       ; 53B
   mov  eax,PD [eax+ecx*8]            ; 55F
  mov   cl,PB [edi+2]                 ; 53C
   add  ebp,eax                       ; 55G
  mov   eax,MulByNeg8[ebx*4]          ; 53D
   mov  bl,PB [esi]                   ; 51A
  mov   [edx].N8T53,eax               ; 53E
   add  ebp,ebx                       ; 51B
  mov   eax,PD [eax+ecx*8]            ; 53F
   add  esi,PITCH-1
  mov   cl,PB [edi]                   ; 51C
   add  edi,PITCH-1
  add   ebp,eax                       ; 53G
   mov  eax,MulByNeg8[ebx*4]          ; 51D
  mov   bl,PB [esi+6]                 ; 66A
   mov  [edx].N8T51,eax               ; 51E
  add   ebp,ebx                       ; 66B
   mov  eax,PD [eax+ecx*8]            ; 51F
  mov   cl,PB [edi+6]                 ; 66C
   add  ebp,eax                       ; 51G
  mov   eax,MulByNeg8[ebx*4]          ; 66D
   mov  bl,PB [esi+4]                 ; 64A
  mov   [edx].N8T66,eax               ; 66E
   add  ebp,ebx                       ; 64B
  mov   eax,PD [eax+ecx*8]            ; 66F
   mov  cl,PB [edi+4]                 ; 64C
  add   ebp,eax                       ; 66G
   mov  eax,MulByNeg8[ebx*4]          ; 64D
  mov   bl,PB [esi+2]                 ; 62A
   mov  [edx].N8T64,eax               ; 64E
  add   ebp,ebx                       ; 62B
   mov  eax,PD [eax+ecx*8]            ; 64F
  mov   cl,PB [edi+2]                 ; 62C
   add  ebp,eax                       ; 64G
  mov   eax,MulByNeg8[ebx*4]          ; 62D
   mov  bl,PB [esi]                   ; 60A
  mov   [edx].N8T62,eax               ; 62E
   add  ebp,ebx                       ; 60B
  mov   eax,PD [eax+ecx*8]            ; 62F
   add  esi,PITCH+1
  mov   cl,PB [edi]                   ; 60C
   add  edi,PITCH+1
  add   ebp,eax                       ; 62G
   mov  eax,MulByNeg8[ebx*4]          ; 60D
  mov   bl,PB [esi+6]                 ; 77A
   mov  [edx].N8T60,eax               ; 60E
  add   ebp,ebx                       ; 77B
   mov  eax,PD [eax+ecx*8]            ; 60F
  mov   cl,PB [edi+6]                 ; 77C
   add  ebp,eax                       ; 60G
  mov   eax,MulByNeg8[ebx*4]          ; 77D
   mov  bl,PB [esi+4]                 ; 75A
  mov   [edx].N8T77,eax               ; 77E
   add  ebp,ebx                       ; 75B
  mov   eax,PD [eax+ecx*8]            ; 77F
   mov  cl,PB [edi+4]                 ; 75C
  add   ebp,eax                       ; 77G
   mov  eax,MulByNeg8[ebx*4]          ; 75D
  mov   bl,PB [esi+2]                 ; 73A
   mov  [edx].N8T75,eax               ; 75E
  add   ebp,ebx                       ; 73B
   mov  eax,PD [eax+ecx*8]            ; 75F
  mov   cl,PB [edi+2]                 ; 73C
   add  ebp,eax                       ; 75G
  mov   eax,MulByNeg8[ebx*4]          ; 73D
   mov  bl,PB [esi]                   ; 71A
  mov   [edx].N8T73,eax               ; 73E
   add  ebp,ebx                       ; 71B
  mov   eax,PD [eax+ecx*8]            ; 73F
   mov  cl,PB [edi]                   ; 71C
  add   esi,PITCH-1-PITCH*8+8
   add  edi,PITCH-1-PITCH*8+8
  add   ebp,eax                       ; 73G
   mov  eax,MulByNeg8[ebx*4]          ; 71D
  mov   ebx,ebp
   mov  [edx].N8T71,eax               ; 71E
  and   ebx,000001FFFH                ; Extract sum of target pels.
   add  edx,BlockLen                  ; Move to next output block
  mov   eax,PD [eax+ecx*8]            ; 71F
   mov  [edx-BlockLen].AccumTargetPels,ebx ; Store acc of target pels for block.
  add   eax,ebp                       ; 71G
   and  ebp,000006000H                ; Extract loop control
  shr   eax,16                        ; Extract SWD;  CF == 1 every second iter.
   mov  ebx,ecx
  mov   [edx-BlockLen].CentralInterSWD,eax ; Store SWD for 0-motion vector.
   jnc  PrepMatchPointsNextBlock

  add   esi,PITCH*8-16                ; Advance to block 3, or off end.
   add  edi,PITCH*8-16                ; Advance to block 3, or off end.
  xor   ebp,000002000H
   jne  PrepMatchPointsNextBlock      ; Jump if advancing to block 3.

  mov   ebx,CurrSWDState              ; Fetch First State Number for engine.
   mov  edi,Block1.CentralInterSWD
  test  bl,bl                         ; Test for INTRA-BY-DECREE.
   je   IntraByDecree

  add   eax,Block2.CentralInterSWD
   add  edi,Block3.CentralInterSWD
  add   eax,edi
   mov  edx,ZeroVectorThreshold
  cmp   eax,edx                       ; Compare 0-MV against ZeroVectorThresh
   jle  BelowZeroThresh               ; Jump if 0-MV is good enough.

  mov   cl,PB SWDState[ebx*8+3]       ; cl == Index of inc to apply to central
  ;                                   ; point to get to ref1.
   mov  bl,PB SWDState[ebx*8+5]       ; bl == Same as cl, but for ref2.
  mov   edx,TargToRef
   mov  MB0MVInterSWD,eax             ; Stash SWD for zero motion vector.
  mov   edi,PD OffsetToRef[ebx]       ; Get inc to apply to ctr to get to ref2.
   mov  ebp,PD OffsetToRef[ecx]       ; Get inc to apply to ctr to get to ref1.
  lea   esi,[esi+edx-PITCH*16]        ; Calculate address of 0-MV ref block.
   ;
  mov   MBAddrCentralPoint,esi        ; Set central point to 0-MV.
   mov  MBCentralInterSWD,eax
  mov   eax,Block1.CentralInterSWD    ; Stash Zero MV SWD, in case we decide
   mov  edx,Block2.CentralInterSWD    ; the best non-zero MV isn't enough
  mov   Block1.ZeroMVInterSWD,eax     ; better than the zero MV.
   mov  Block2.ZeroMVInterSWD,edx
  mov   eax,Block3.CentralInterSWD
   mov  edx,Block4.CentralInterSWD
  mov   Block3.ZeroMVInterSWD,eax
   mov  Block4.ZeroMVInterSWD,edx

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     5)  The SWD for two different reference macroblocks is calculated; ref1
;         into the high order 16 bits of ebp, and ref2 into the low 16 bits.
;         This is performed for each iteration of the state engine.  A normal,
;         internal macroblock will perform 6 iterations, searching +/- 4
;         horizontally, then +/- 4 vertically, then +/- 2 horizontally, then
;         +/- 2 vertically, then +/- 1 horizontally, then +/- 1 vertically.
;
; Register usage for this section:
;
;   Input:
;
;     esi -- Addr of 0-motion macroblock in ref frame.
;     ebp -- Increment to apply to get to first ref1 macroblock.
;     edi -- Increment to apply to get to first ref2 macroblock.
;     ebx, ecx -- High order 24 bits are zero.
;     
;   Output:
;
;     ebp -- SWD for the best-fit reference macroblock.
;     ebx -- Index of increment to apply to get to best-fit reference MB.
;     MBAddrCentralPoint -- the best-fit of the previous iteration;  it is the
;                         value to which OffsetToRef[ebx] must be added.
;
;
; Expected performance for SWDLoop code:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

MBFullPelMotionSearchLoop:

  lea   edi,[esi+edi+PITCH*8+8]
   lea  esi,[esi+ebp+PITCH*8+8]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   esi,MBCentralInterSWD     ; Get SWD for central point of these 3 refs
   xor  eax,eax
  add   ebp,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ebp,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ebp,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD

  cmp   ebp,edx                   ; Carry flag == 1 iff ref1 SWD < ref2 SWD.
   mov  edi,CurrSWDState          ; Restore current state number.
  adc   eax,eax                   ; eax == 1 iff ref1 SWD < ref2 SWD.
   cmp  ebp,esi                   ; Carry flag == 1 iff ref1 SWD < central SWD.
  adc   eax,eax                   ;
   cmp  edx,esi                   ; Carry flag == 1 iff ref2 SWD < central SWD.
  adc   eax,eax                   ; 0 --> Pick central point.
  ;                               ; 1 --> Pick ref2.
  ;                               ; 2 --> Not possible.
  ;                               ; 3 --> Pick ref2.
  ;                               ; 4 --> Pick central point.
  ;                               ; 5 --> Not possible.
  ;                               ; 6 --> Pick ref1.
  ;                               ; 7 --> Pick ref1.
   mov  MBRef2InterSWD,edx
  mov   MBRef1InterSWD,ebp
   xor  edx,edx
  mov   dl,PB PickPoint[eax]        ; dl == 0: central pt;  2: ref1;  4: ref2
   mov  esi,MBAddrCentralPoint      ; Reload address of central ref block.
  ;
   ;
  mov   ebp,Block1.CentralInterSWD[edx*2] ; Get SWD for each block, picked pt.
   mov  al,PB SWDState[edx+edi*8+1] ; al == Index of inc to apply to old central
   ;                                ;       point to get new central point.
  mov   Block1.CentralInterSWD,ebp  ; Stash SWD for new central point.
   mov  ebp,Block2.CentralInterSWD[edx*2]
  mov   Block2.CentralInterSWD,ebp
   mov  ebp,Block3.CentralInterSWD[edx*2]
  mov   Block3.CentralInterSWD,ebp
   mov  ebp,Block4.CentralInterSWD[edx*2]
  mov   Block4.CentralInterSWD,ebp
   mov  ebp,MBCentralInterSWD[edx*2]; Get the SWD for the point we picked.
  mov   dl,PB SWDState[edx+edi*8]   ; dl == New state number.
   mov  MBCentralInterSWD,ebp       ; Stash SWD for new central point.
  mov   edi,PD OffsetToRef[eax]     ; Get inc to apply to get to new central pt.
   mov  CurrSWDState,edx            ; Stash current state number.
  mov   bl,PB SWDState[edx*8+3]     ; bl == Index of inc to apply to central
  ;                                 ;       point to get to next ref1.
   mov  cl,PB SWDState[edx*8+5]     ; cl == Same as bl, but for ref2.
  add   esi,edi                     ; Move to new central point.
   test dl,dl
  mov   ebp,PD OffsetToRef[ebx]     ; Get inc to apply to ctr to get to ref1.
   mov  edi,PD OffsetToRef[ecx]     ; Get inc to apply to ctr to get to ref2.
  mov   MBAddrCentralPoint,esi      ; Stash address of new central ref block.
   jne  MBFullPelMotionSearchLoop   ; Jump if not done searching.

;Done searching for integer motion vector for full macroblock

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF
  mov   ecx,TargToRef            ; To Linearize MV for winning ref blk.
   mov  eax,esi                  ; Copy of ref macroblock addr.
  sub   eax,ecx                  ; To Linearize MV for winning ref blk.
   mov  ecx,TargetMBAddr
  sub   eax,ecx
   mov  edx,MBlockActionStream   ; Fetch list ptr.
  mov   ebx,eax
   mov  ebp,DoHalfPelEstimation  ; Are we doing half pel motion estimation?
  shl   eax,25                   ; Extract horz motion component.
   mov  [edx].BlkY1.PastRef,esi  ; Save address of reference MB selected.
  sar   ebx,8                    ; Hi 24 bits of linearized MV lookup vert MV.
   mov  ecx,MBCentralInterSWD
  sar   eax,24                   ; Finish extract horz motion component.
   test ebp,ebp
  mov   bl,PB UnlinearizedVertMV[ebx] ; Look up proper vert motion vector.
   mov  [edx].BlkY1.PHMV,al      ; Save winning horz motion vector.
  mov   [edx].BlkY1.PVMV,bl      ; Save winning vert motion vector.

IFDEF H261
ELSE
   je   SkipHalfPelSearch_1MV

;Search for half pel motion vector for full macroblock.

  mov   Block1.AddrCentralPoint,esi
   lea  ebp,[esi+8]
  mov   Block2.AddrCentralPoint,ebp
   add  ebp,PITCH*8-8
  mov   Block3.AddrCentralPoint,ebp
   xor  ecx,ecx
  mov   cl,[edx].FirstMEState
   add  ebp,8
  mov   edi,esi
   mov  Block4.AddrCentralPoint,ebp
  mov   ebp,InitHalfPelSearchHorz[ecx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  mov   esi,MBlockActionStream
   xor  eax,eax                   ; Keep pairing happy
  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  mov   bl,[esi].FirstMEState
   mov  edi,Block1.AddrCentralPoint
  cmp   ecx,edx
   jl   MBHorz_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the right is best.
   mov  ecx,Block1.Ref2InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref2InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref2InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref2InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   inc  al
  mov   [esi].BlkY1.PHMV,al
   jmp  MBHorz_Done

MBHorz_CenterBest:

  mov   ecx,Block1.CentralInterSWD
   xor  ebp,ebp
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.CentralInterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   jmp  MBHorz_Done

MBHorz_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBHorz_CenterBest

  mov   al,[esi].BlkY1.PHMV        ; Half pel to the left is best.
   mov  edx,[esi].BlkY1.PastRef
  dec   al
   mov  ecx,Block1.Ref1InterSWD
  mov   Block1.CentralInterSWD_BLS,ecx
   mov  ecx,Block3.Ref1InterSWD
  mov   Block3.CentralInterSWD_BLS,ecx
   mov  ecx,Block2.Ref1InterSWD
  mov   Block2.CentralInterSWD_BLS,ecx
   mov  ecx,Block4.Ref1InterSWD
  mov   Block4.CentralInterSWD_BLS,ecx
   dec  edx
  mov   [esi].BlkY1.PHMV,al
   mov  [esi].BlkY1.PastRef,edx

MBHorz_Done:

  mov   HalfPelHorzSavings,ebp
   mov  ebp,InitHalfPelSearchVert[ebx*4-4]

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

  add   ecx,Block1.Ref1InterSWD
   add  edx,Block1.Ref2InterSWD
  add   ecx,Block2.Ref1InterSWD
   add  edx,Block2.Ref2InterSWD
  add   ecx,Block3.Ref1InterSWD
   add  edx,Block3.Ref2InterSWD
  cmp   ecx,edx
   jl   MBVert_Ref1LTRef2

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,edx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel below is best.
  mov   Block1.CentralInterSWD,edx
   inc  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref2InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  [esi].BlkY1.PVMV,al
  mov   Block4.CentralInterSWD,edx
   jmp  MBVert_Done

MBVert_CenterBest:

  mov   ecx,Block1.CentralInterSWD_BLS
   xor  ebp,ebp
  mov   Block1.CentralInterSWD,ecx
   mov  ecx,Block2.CentralInterSWD_BLS
  mov   Block2.CentralInterSWD,ecx
   mov  ecx,Block3.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,ecx
   mov  ecx,Block4.CentralInterSWD_BLS
  mov   Block4.CentralInterSWD,ecx
   jmp  MBVert_Done

MBVert_Ref1LTRef2:

  mov   ebp,MBCentralInterSWD
   mov  esi,MBlockActionStream
  sub   ebp,ecx
   jle  MBVert_CenterBest

  mov   ecx,Block1.CentralInterSWD
   mov  edx,Block1.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block1.CentralInterSWD_BLS
  sub   edx,ecx
   mov  al,[esi].BlkY1.PVMV        ; Half pel above is best.
  mov   Block1.CentralInterSWD,edx
   dec  al
  mov   ecx,Block3.CentralInterSWD
   mov  edx,Block3.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block3.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block2.CentralInterSWD
  mov   Block3.CentralInterSWD,edx
   mov  edx,Block2.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block2.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,Block4.CentralInterSWD
  mov   Block2.CentralInterSWD,edx
   mov  edx,Block4.Ref1InterSWD
  sub   ecx,edx
   mov  edx,Block4.CentralInterSWD_BLS
  sub   edx,ecx
   mov  ecx,[esi].BlkY1.PastRef
  mov   Block4.CentralInterSWD,edx
   sub  ecx,PITCH
  mov   [esi].BlkY1.PVMV,al
   mov  [esi].BlkY1.PastRef,ecx

MBVert_Done:

  mov   ecx,HalfPelHorzSavings
   mov  edx,esi
  add   ebp,ecx                    ; Savings for horz and vert half pel motion.
   mov  ecx,MBCentralInterSWD      ; Reload SWD for new central point.
  sub   ecx,ebp                    ; Approx SWD for prescribed half pel motion.
   mov  esi,[edx].BlkY1.PastRef    ; Reload address of reference MB selected.
  mov   MBCentralInterSWD,ecx

SkipHalfPelSearch_1MV:

ENDIF ; H263

  mov   ebp,[edx].BlkY1.MVs    ; Load Motion Vectors
   add  esi,8
  mov   [edx].BlkY2.PastRef,esi
   mov  [edx].BlkY2.MVs,ebp
  lea   edi,[esi+PITCH*8]
   add  esi,PITCH*8-8
  mov   [edx].BlkY3.PastRef,esi
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,edi
   mov  [edx].BlkY4.MVs,ebp
IFDEF H261
ELSE ; H263
  mov   MBMotionVectors,ebp        ; Stash macroblock level motion vectors.
   mov  ebp,640 ; ??? BlockMVDifferential
  cmp   ecx,ebp
   jl   NoBlockMotionVectors

  mov   ecx,DoBlockLevelVectors
  test  ecx,ecx                    ; Are we doing block level motion vectors?
   je   NoBlockMotionVectors

;  Activity Details for this section of code  (refer to flow diagram above):
;
;  The following search is done similarly to the searches done above, except
;  these are block searches, instead of macroblock searches.
;
; Expected performance:
;
;   Execution frequency:  Six times per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
; Pentium (tm) microprocessor times per six iterations:
;   180 clocks for instruction execution setup to DoSWDLoop
;  2520 clocks for DoSWDLoop procedure, instruction execution.
;   192 clocks for bank conflicts in DoSWDLoop
;    30 clocks generously estimated for an average of 6 cache line fills for
;       the reference area.
;  ----
;  2922 clocks total time for this section.

;
;    Set up for the "BlkFullPelSWDLoop_4blks" loop to follow.
;    -  Store the SWD values for blocks 4, 3, 2, 1.
;    -  Compute and store the address of the central reference
;       point for blocks 1, 2, 3, 4.
;	 -  Compute and store the first address for ref 1 (minus 4 
;       pels horizontally) and ref 2 (plus 4 pels horizontally)
;       for blocks 4, 3, 2, 1 (in that order).
;    -  Initialize MotionOffsetsCursor
;    -  On exit:
;       esi = ref 1 address for block 1
;       edi = ref 2 address for block 1
;
  mov   esi,Block4.CentralInterSWD
   mov  edi,Block3.CentralInterSWD
  mov   Block4.CentralInterSWD_BLS,esi
   mov  Block3.CentralInterSWD_BLS,edi
  mov   esi,Block2.CentralInterSWD
   mov  edi,Block1.CentralInterSWD
  mov   Block2.CentralInterSWD_BLS,esi
   mov  eax,MBAddrCentralPoint   ; Reload addr of central, integer pel ref MB.
  mov   Block1.CentralInterSWD_BLS,edi
   mov  Block1.AddrCentralPoint,eax
  lea   edi,[eax+PITCH*8+8+1]
   lea  esi,[eax+PITCH*8+8-1]
  mov   Block4.Ref1Addr,esi
   mov  Block4.Ref2Addr,edi
  sub   esi,8
   add  eax,8
  mov   Block2.AddrCentralPoint,eax
   add  eax,PITCH*8-8
  mov   Block3.AddrCentralPoint,eax
   add  eax,8
  mov   Block4.AddrCentralPoint,eax
   sub  edi,8
  mov   Block3.Ref1Addr,esi
   mov  Block3.Ref2Addr,edi
  sub   esi,PITCH*8-8
   sub  edi,PITCH*8-8
  mov   Block2.Ref1Addr,esi
   mov  Block2.Ref2Addr,edi
  sub   esi,8
   mov  eax,OFFSET MotionOffsets
  mov   MotionOffsetsCursor,eax
   sub  edi,8
  mov   Block1.Ref1Addr,esi
   mov  Block1.Ref2Addr,edi

;
;  This loop will execute 6 times:
;    +- 4 pels horizontally
;    +- 4 pels vertically
;    +- 2 pels horizontally
;    +- 2 pels vertically
;    +- 1 pel horizontally
;    +- 1 pel vertically
;  It terminates when ref1 = ref2.  This simple termination
;  condition is what forces unrestricted motion vectors (UMV)
;  to be ON when advanced prediction (4MV) is ON.  Otherwise
;  we would need a state engine as above to distinguish edge
;  pels.
;
BlkFullPelSWDLoop_4blks:

;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  call  DoSWDLoop

;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   eax,MotionOffsetsCursor

BlkFullPelSWDLoop_1blk:

  xor   esi,esi
   cmp  ebp,edx                         ; CF == 1 iff ref1 SWD < ref2 SWD.
  mov   edi,BlockNM1.CentralInterSWD_BLS; Get SWD for central pt of these 3 refs
   adc  esi,esi                         ; esi == 1 iff ref1 SWD < ref2 SWD.
  cmp   ebp,edi                         ; CF == 1 iff ref1 SWD < central SWD.
   mov  ebp,BlockNM2.Ref1InterSWD       ; Fetch next block's Ref1 SWD.
  adc   esi,esi
   cmp  edx,edi                         ; CF == 1 iff ref2 SWD < central SWD.
  adc   esi,esi                         ; 0 --> Pick central point.
  ;                                     ; 1 --> Pick ref2.
  ;                                     ; 2 --> Not possible.
  ;                                     ; 3 --> Pick ref2.
  ;                                     ; 4 --> Pick central point.
  ;                                     ; 5 --> Not possible.
  ;                                     ; 6 --> Pick ref1.
  ;                                     ; 7 --> Pick ref1.
   mov  edx,BlockNM2.Ref2InterSWD       ; Fetch next block's Ref2 SWD.
  sub   esp,BlockLen                    ; Move ahead to next block.
   mov  edi,[eax]                       ; Next ref2 motion vector offset.
  mov   cl,PickPoint_BLS[esi]           ; cl == 6: central pt; 2: ref1; 4: ref2
   mov  ebx,esp                         ; For testing completion.
  ;
   ;
  mov   esi,BlockN.AddrCentralPoint[ecx*2-12] ; Get the addr for pt we picked.
   mov  ecx,BlockN.CentralInterSWD[ecx*2]    ; Get the SWD for point we picked.
  mov   BlockN.AddrCentralPoint,esi          ; Stash addr for new central point.
   sub  esi,edi                              ; Compute next ref1 addr.
  mov   BlockN.Ref1Addr,esi                  ; Stash next ref1 addr.
   mov  BlockN.CentralInterSWD_BLS,ecx       ; Stash the SWD for central point.
  lea   edi,[esi+edi*2]                      ; Compute next ref2 addr.
   xor  ecx,ecx
  mov   BlockN.Ref2Addr,edi                  ; Stash next ref2 addr.
   and  ebx,00000001FH                       ; Done when esp at 32-byte bound.
  jne   BlkFullPelSWDLoop_1blk

  add   esp,BlockLen*4
   add  eax,4                       ; Advance MotionOffsets pointer.
  mov   MotionOffsetsCursor,eax
   cmp  esi,edi
  jne   BlkFullPelSWDLoop_4blks

IF PITCH-384
  *** Error:  The magic leaks out of the following code if PITCH isn't 384.
ENDIF

;
;  The following code has been modified to correctly decode the motion vectors
;  The previous code was simply subtracting the target frame base address
;  from the chosen (central) reference block address.
;  What is now done is the begining reference macroblock address computed
;  in ebp, then subtracted from the chosen (central) reference block address.
;  Then, for blocks 2, 3, and 4, the distance from block 1 to that block
;  is subtracted.  Care was taken to preserve the original pairing.
; 
  mov   esi,Block1.AddrCentralPoint ; B1a  Reload address of central ref block.
   mov  ebp,TargetMBAddr			; ****  CHANGE  ****  addr. of target MB

  mov   edi,Block2.AddrCentralPoint ; B2a
   add  ebp,TargToRef				; ****  CHANGE	****  add Reference - Target

; mov   ebp,PreviousFrameBaseAddress  ****  CHANGE  ****  DELETED

  mov   Block1.Ref1Addr,esi         ; B1b  Stash addr central ref block.
   sub  esi,ebp                     ; B1c  Addr of ref blk, but in target frame.

  mov   Block2.Ref1Addr,edi         ; B2b
   sub  edi,ebp                     ; B2c

  sub   edi,8                       ; ****  CHANGE  ****  Correct for block 2
   mov  eax,esi                     ; B1e Copy linearized MV.

  sar   esi,8                       ; B1f High 24 bits of lin MV lookup vert MV.
   mov  ebx,edi                     ; B2e

  sar   edi,8                       ; B2f
   add  eax,eax                     ; B1g Sign extend HMV;  *2 (# of half pels).

  mov   Block1.BlkHMV,al            ; B1h Save winning horz motion vector.
   add  ebx,ebx                     ; B2g

  mov   Block2.BlkHMV,bl            ; B2h
   mov  al,UnlinearizedVertMV[esi]  ; B1i Look up proper vert motion vector.

  mov   Block1.BlkVMV,al            ; B1j Save winning vert motion vector.
   mov  al,UnlinearizedVertMV[edi]  ; B2i

  mov   esi,Block3.AddrCentralPoint ; B3a
   mov  edi,Block4.AddrCentralPoint ; B4a

  mov   Block3.Ref1Addr,esi         ; B3b
   mov  Block4.Ref1Addr,edi         ; B4b

  mov   Block2.BlkVMV,al            ; B2j
   sub  esi,ebp                     ; B3c

  sub   esi,8*PITCH                 ; ****  CHANGE  ****  Correct for block 3
   sub  edi,ebp                     ; B4c

  sub   edi,8*PITCH+8               ; ****  CHANGE  ****  Correct for block 4
   mov  eax,esi                     ; B3e

  sar   esi,8                       ; B3f
   mov  ebx,edi                     ; B4e

  sar   edi,8                       ; B4f
   add  eax,eax                     ; B3g

  mov   Block3.BlkHMV,al            ; B3h
   add  ebx,ebx                     ; B4g

  mov   Block4.BlkHMV,bl            ; B4h
   mov  al,UnlinearizedVertMV[esi]  ; B3i

  mov   Block3.BlkVMV,al            ; B3j
   mov  al,UnlinearizedVertMV[edi]  ; B4i

  mov   ebp,Block1.CentralInterSWD_BLS
   mov  ebx,Block2.CentralInterSWD_BLS

  add   ebp,Block3.CentralInterSWD_BLS
   add  ebx,Block4.CentralInterSWD_BLS

  add   ebx,ebp
   mov  Block4.BlkVMV,al            ; B4j

  mov   ecx,DoHalfPelEstimation
   mov  MBCentralInterSWD_BLS,ebx

  test  ecx,ecx
   je   NoHalfPelBlockLevelMVs

HalfPelBlockLevelMotionSearch:

  mov   edi,Block1.AddrCentralPoint
   xor  ebp,ebp

;    ebp -- Initialized to 0, implying can search both left and right.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  call  DoSWDHalfPelHorzLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkHorz:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   BlockNM1.HalfPelSavings,ebp
   jl   BlkHorz_Ref1LTRef2

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,edx
   jle  BlkHorz_CenterBest

  inc   al
   mov  BlockN.HalfPelSavings,ebx
  mov   BlockN.BlkHMV,al
   jmp  BlkHorz_Done

BlkHorz_Ref1LTRef2:

  mov   al,BlockNM1.BlkHMV
   sub  esp,BlockLen
  sub   ebx,ecx
   jle  BlkHorz_CenterBest

  mov   ecx,BlockN.Ref1Addr
   dec  al
  mov   BlockN.HalfPelSavings,ebx
   dec  ecx
  mov   BlockN.BlkHMV,al
   mov  BlockN.Ref1Addr,ecx

BlkHorz_CenterBest:
BlkHorz_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  jne   NextBlkHorz

  mov   edi,BlockN.AddrCentralPoint
   add  esp,BlockLen*4

;    ebp -- Initialized to 0, implying search both up and down is okay.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel above.  Ref2 is .5 below.

  call  DoSWDHalfPelVertLoop

;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4

NextBlkVert:

  mov   ebx,BlockNM1.CentralInterSWD_BLS
   cmp  ecx,edx
  mov   edi,BlockNM1.HalfPelSavings 
   jl   BlkVert_Ref1LTRef2

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   edx,ebx
   jge  BlkVert_CenterBest

  inc   al
   sub  edi,edx
  mov   BlockN.BlkVMV,al
   jmp  BlkVert_Done

BlkVert_Ref1LTRef2:

  mov   al,BlockNM1.BlkVMV
   sub  esp,BlockLen
  sub   ecx,ebx
   jge  BlkVert_CenterBest

  sub   edi,ecx
   mov  ecx,BlockN.Ref1Addr
  dec   al
   sub  ecx,PITCH
  mov   BlockN.BlkVMV,al
   mov  BlockN.Ref1Addr,ecx

BlkVert_CenterBest:
BlkVert_Done:

  mov   ecx,BlockNM1.Ref1InterSWD
   sub  ebx,edi
  mov   BlockN.CentralInterSWD_BLS,ebx
   mov  edx,BlockNM1.Ref2InterSWD
  test  esp,000000018H
  lea   ebp,[ebp+edi]
   jne  NextBlkVert

  mov   ebx,MBCentralInterSWD_BLS+BlockLen*4
   add  esp,BlockLen*4
  sub   ebx,ebp
   xor  eax,eax  ; ??? Keep pairing happy

NoHalfPelBlockLevelMVs:

  mov   eax,MBCentralInterSWD
   mov  ecx,BlockMVDifferential
  sub   eax,ebx
   mov  edi,MB0MVInterSWD
  cmp   eax,ecx
   jle  BlockMVNotBigEnoughGain

  sub   edi,ebx
   mov  ecx,NonZeroMVDifferential
  cmp   edi,ecx
   jle  NonZeroMVNotBigEnoughGain

; Block motion vectors are best.

  mov   MBCentralInterSWD,ebx           ; Set MBlock's SWD to sum of 4 blocks.
   mov  edx,MBlockActionStream
  mov   eax,Block1.CentralInterSWD_BLS  ; Set each block's SWD.
   mov  ebx,Block2.CentralInterSWD_BLS
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,ebx
  mov   eax,Block3.CentralInterSWD_BLS
   mov  ebx,Block4.CentralInterSWD_BLS
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,ebx
  mov   eax,Block1.BlkMVs               ; Set each block's motion vector.
   mov  ebx,Block2.BlkMVs
  mov   [edx].BlkY1.MVs,eax
   mov  [edx].BlkY2.MVs,ebx
  mov   eax,Block3.BlkMVs
   mov  ebx,Block4.BlkMVs
  mov   [edx].BlkY3.MVs,eax
   mov  [edx].BlkY4.MVs,ebx
  mov   eax,Block1.Ref1Addr             ; Set each block's reference blk addr.
   mov  ebx,Block2.Ref1Addr
  mov   [edx].BlkY1.PastRef,eax
   mov  [edx].BlkY2.PastRef,ebx
  mov   eax,Block3.Ref1Addr
   mov  ebx,Block4.Ref1Addr
  mov   [edx].BlkY3.PastRef,eax
   mov  eax,INTER4MV                    ; Set type for MB to INTER-coded, 4 MVs.
  mov   [edx].BlkY4.PastRef,ebx
   mov  [edx].BlockType,al
  jmp   MotionVectorSettled

NoBlockMotionVectors:

ENDIF ; H263

  mov   edi,MB0MVInterSWD

BlockMVNotBigEnoughGain:                ; Try MB-level motion vector.

  mov   eax,MBCentralInterSWD
   mov  ecx,NonZeroMVDifferential
  sub   edi,eax
   mov  edx,MBlockActionStream
  cmp   edi,ecx
   jg   MotionVectorSettled

NonZeroMVNotBigEnoughGain:              ; Settle on zero MV.

  mov   eax,Block1.ZeroMVInterSWD       ; Restore Zero MV SWD.
   mov  edx,Block2.ZeroMVInterSWD
  mov   Block1.CentralInterSWD,eax
   mov  Block2.CentralInterSWD,edx
  mov   eax,Block3.ZeroMVInterSWD
   mov  edx,Block4.ZeroMVInterSWD
  mov   Block3.CentralInterSWD,eax
   mov  Block4.CentralInterSWD,edx
  mov   eax,MB0MVInterSWD               ; Restore SWD for zero motion vector.

BelowZeroThresh:

  mov   edx,MBlockActionStream
   mov  ebx,TargetMBAddr              ; Get address of this target macroblock.
  mov   MBCentralInterSWD,eax         ; Save SWD.
   xor  ebp,ebp
  add   ebx,TargToRef
   mov  [edx].BlkY1.MVs,ebp           ; Set horz and vert MVs to 0 in all blks.
  mov   [edx].BlkY1.PastRef,ebx       ; Save address of ref block, all blks.
   add  ebx,8
  mov   [edx].BlkY2.PastRef,ebx
   mov  [edx].BlkY2.MVs,ebp
  lea   ecx,[ebx+PITCH*8]
   add  ebx,PITCH*8-8
  mov   [edx].BlkY3.PastRef,ebx
   mov  [edx].BlkY3.MVs,ebp
  mov   [edx].BlkY4.PastRef,ecx
   mov  [edx].BlkY4.MVs,ebp

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     6)  We've settled on the motion vector that will be used if we do indeed
;         code the macroblock with inter-coding.  We need to determine if some
;         or all of the blocks can be forced as empty (copy).
;         blocks.  If all the blocks can be forced empty, we force the whole
;         macroblock to be empty.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per macroblock.
;
;    23 clocks.
;

MotionVectorSettled:

IFDEF H261
   mov  edi,MBCentralInterSWD
  mov   eax,DoSpatialFiltering   ; Are we doing spatial filtering?
   mov  edi,TargetMBAddr
  test  eax,eax
   je   SkipSpatialFiltering

  mov   ebx,MBCentralInterSWD
   mov  esi,SpatialFiltThreshold
  cmp   ebx,esi
   jle  SkipSpatialFiltering

  add   edi,TargToSLF            ; Compute addr at which to put SLF prediction.
   xor  ebx,ebx
  mov   esi,[edx].BlkY1.PastRef
   xor  edx,edx
  mov   ebp,16
   xor  ecx,ecx

SpatialFilterHorzLoop:

  mov   dl,[edi]        ; Pre-load cache line for output.
   mov  bl,[esi+6]      ; p6
  mov   al,[esi+7]      ; p7
   inc  bl              ; p6+1
  mov   cl,[esi+5]      ; p5
   mov  [edi+7],al      ; p7' = p7
  add   al,bl           ; p7 + p6 + 1
   add  bl,cl           ; p6 + p5 + 1
  mov   dl,[esi+4]      ; p4
   add  eax,ebx         ; p7 + 2p6 + p5 + 2
  shr   eax,2           ; p6' = (p7 + 2p6 + p5 + 2) / 4
   inc  dl              ; p4 + 1
  add   cl,dl           ; p5 + p4 + 1
   mov  [edi+6],al      ; p6'
  mov   al,[esi+3]      ; p3
   add  ebx,ecx         ; p6 + 2p5 + p4 + 2
  shr   ebx,2           ; p5' = (p6 + 2p5 + p4 + 2) / 4
   add  dl,al           ; p4 + p3 + 1
  mov   [edi+5],bl      ; p5'
   mov  bl,[esi+2]      ; p2
  add   ecx,edx         ; p5 + 2p4 + p3 + 2
   inc  bl              ; p2 + 1
  shr   ecx,2           ; p4' = (p5 + 2p4 + p3 + 2) / 4
   add  al,bl           ; p3 + p2 + 1
  mov   [edi+4],cl      ; p4'
   add  edx,eax         ; p4 + 2p3 + p2 + 2
  shr   edx,2           ; p3' = (p4 + 2p3 + p2 + 2) / 4
   mov  cl,[esi+1]      ; p1
  add   bl,cl           ; p2 + p1 + 1
   mov  [edi+3],dl      ; p3'
  add   eax,ebx         ; p3 + 2p2 + p1 + 2
   mov  dl,[esi]        ; p0
  shr   eax,2           ; p2' = (p3 + 2p2 + p1 + 2) / 4
   inc  ebx             ; p2 + p1 + 2
  mov   [edi+2],al      ; p2'
   add  ebx,ecx         ; p2 + 2p1 + 2
  mov   [edi],dl        ; p0' = p0
   add  ebx,edx         ; p2 + 2p1 + p0 + 2
  shr   ebx,2           ; p1' = (p2 + 2p1 + p0 + 2) / 4
   mov  al,[esi+7+8]
  mov   [edi+1],bl      ; p1'
   mov  bl,[esi+6+8]
  inc   bl
   mov  cl,[esi+5+8]
  mov   [edi+7+8],al
   add  al,bl
  add   bl,cl
   mov  dl,[esi+4+8]
  add   eax,ebx
   ;
  shr   eax,2
   inc  dl
  add   cl,dl
   mov  [edi+6+8],al
  mov   al,[esi+3+8]
   add  ebx,ecx
  shr   ebx,2
   add  dl,al
  mov   [edi+5+8],bl
   mov  bl,[esi+2+8]
  add   ecx,edx
   inc  bl
  shr   ecx,2
   add  al,bl
  mov   [edi+4+8],cl
   add  edx,eax
  shr   edx,2
   mov  cl,[esi+1+8]
  add   bl,cl
   mov  [edi+3+8],dl
  add   eax,ebx
   mov  dl,[esi+8]
  shr   eax,2
   inc  ebx
  mov   [edi+2+8],al
   add  ebx,ecx
  mov   [edi+8],dl
   add  ebx,edx
  shr   ebx,2
   add  esi,PITCH
  mov   [edi+1+8],bl
   add  edi,PITCH
  dec   ebp             ; Done?
   jne  SpatialFilterHorzLoop

  mov   VertFilterDoneAddr,edi
   sub  edi,PITCH*16

SpatialFilterVertLoop:

  mov   eax,[edi]                ;  p0
   ;                             ;  Bank conflict for sure.
  ;
   mov  ebx,[edi+PITCH]          ;  p1
  add   eax,ebx                  ;  p0+p1
   mov  ecx,[edi+PITCH*2]        ;  p2
  add   ebx,ecx                  ;  p1+p2
   mov  edx,[edi+PITCH*3]        ;  p3
  shr   eax,1                    ; (p0+p1)/2                       dirty
   mov  esi,[edi+PITCH*4]        ;  p4
  add   ecx,edx                  ;  p2+p3
   mov  ebp,[edi+PITCH*5]        ;  p5
  shr   ebx,1                    ; (p1+p2)/2                       dirty
   add  edx,esi                  ;  p3+p4
  and   eax,07F7F7F7FH           ; (p0+p1)/2                       clean
   and  ebx,07F7F7F7FH           ; (p1+p2)/2                       clean
  and   ecx,0FEFEFEFEH           ;  p2+p3                          pre-cleaned
   and  edx,0FEFEFEFEH           ;  p3+p4                          pre-cleaned
  shr   ecx,1                    ; (p2+p3)/2                       clean
   add  esi,ebp                  ;  p4+p5
  shr   edx,1                    ; (p3+p4)/2                       clean
   lea  eax,[eax+ebx+001010101H] ; (p0+p1)/2+(p1+p2)/2+1
  shr   esi,1                    ; (p4+p5)/2                       dirty
   ;
  and   esi,07F7F7F7FH           ; (p4+p5)/2                       clean
   lea  ebx,[ebx+ecx+001010101H] ; (p1+p2)/2+(p2+p3)/2+1
  shr   eax,1                    ; p1' = ((p0+p1)/2+(p1+p2)/2+1)/2 dirty
   lea  ecx,[ecx+edx+001010101H] ; (p2+p3)/2+(p3+p4)/2+1
  shr   ebx,1                    ; p2' = ((p1+p2)/2+(p2+p3)/2+1)/2 dirty
   lea  edx,[edx+esi+001010101H] ; (p3+p4)/2+(p4+p5)/2+1
  and   eax,07F7F7F7FH           ; p1'                             clean
   and  ebx,07F7F7F7FH           ; p2'                             clean
  shr   ecx,1                    ; p3' = ((p2+p3)/2+(p3+p4)/2+1)/2 dirty
   mov  [edi+PITCH],eax          ; p1'
  shr   edx,1                    ; p4' = ((p3+p4)/2+(p4+p5)/2+1)/2 dirty
   mov  eax,[edi+PITCH*6]        ;  p6
  and   ecx,07F7F7F7FH           ; p3'                             clean
   and  edx,07F7F7F7FH           ; p4'                             clean
  mov   [edi+PITCH*2],ebx        ; p2'
   add  ebp,eax                  ;  p5+p6
  shr   ebp,1                    ; (p5+p6)/2                       dirty
   mov  ebx,[edi+PITCH*7]        ;  p7
  add   eax,ebx                  ;  p6+p7
   and  ebp,07F7F7F7FH           ; (p5+p6)/2                       clean
  mov   [edi+PITCH*3],ecx        ; p3'
   and  eax,0FEFEFEFEH           ; (p6+p7)/2                       pre-cleaned
  shr   eax,1                    ; (p6+p7)/2                       clean
   lea  esi,[esi+ebp+001010101H] ; (p4+p5)/2+(p5+p6)/2+1
  shr   esi,1                    ; p5' = ((p4+p5)/2+(p5+p6)/2+1)/2 dirty
   mov  [edi+PITCH*4],edx        ; p4'
  lea   ebp,[ebp+eax+001010101H] ; (p5+p6)/2+(p6+p7)/2+1
   and  esi,07F7F7F7FH           ; p5'                             clean
  shr   ebp,1                    ; p6' = ((p5+p6)/2+(p6+p7)/2+1)/2 dirty
   mov  [edi+PITCH*5],esi        ; p5'
  and   ebp,07F7F7F7FH           ; p6'                             clean
   add  edi,4
  test  edi,00000000FH
  mov   [edi+PITCH*6-4],ebp      ; p6'
   jne  SpatialFilterVertLoop

  add   edi,PITCH*8-16
   mov  eax,VertFilterDoneAddr
  cmp   eax,edi
   jne  SpatialFilterVertLoop
  

;  Activity Details for this section of code  (refer to flow diagram above):
;
;     9)  The SAD for the spatially filtered reference macroblock is calculated
;         with half the pel differences accumulating into the low order half
;         of ebp, and the other half into the high order half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;
;   Predominate usage for body of this section:
;
;     edi -- Address of pel 0,0 of spatially filtered reference macroblock.
;     esi, eax -- -8 times pel values from target macroblock.
;     ebp[ 0:15] -- SAD Accumulator for half of the match points.
;     ebp[16:31] -- SAD Accumulator for other half of the match points.
;     edx[ 0: 7] -- Weighted difference for one pel.
;     edx[ 8:15] -- Zero.
;     edx[16:23] -- Weighted difference for another pel.
;     edx[24:31] -- Zero.
;     bl, cl -- Pel values from the spatially filtered reference macroblock.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Execution frequency:  Once per block for which motion analysis is done
;                         beyond the 0-motion vector.
;
;   146 clocks instruction execution (typically).
;     6 clocks for bank conflicts (1/8 chance with 48 dual mem ops).
;     0 clocks for new cache line fills.
;  ----
;   152 clocks total time for this section.
;

SpatialFilterDone:

  sub   edi,PITCH*8-8             ; Get to block 4.
   xor  ebp,ebp
  xor   ebx,ebx
   xor  ecx,ecx

SLFSWDLoop:

  mov   eax,BlockNM1.N8T00        ; Get -8 times target Pel00.
   mov  bl,[edi]                  ; Get Pel00 in spatially filtered reference.
  mov   esi,BlockNM1.N8T04
   mov  cl,[edi+4]
  mov   edx,[eax+ebx*8]           ; Get abs diff for spatial filtered ref pel00.
   mov  eax,BlockNM1.N8T02
  mov   dl,[esi+ecx*8+2]          ; Get abs diff for spatial filtered ref pel04.
   mov  bl,[edi+2]
  mov   esi,BlockNM1.N8T06
   mov  cl,[edi+6]
  mov   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T11
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*1+1]
   mov  cl,[edi+PITCH*1+5]
  mov   esi,BlockNM1.N8T15
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T13
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*1+3]
  mov   cl,[edi+PITCH*1+7]
   mov  esi,BlockNM1.N8T17
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T20
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*2+0]
   mov  cl,[edi+PITCH*2+4]
  mov   esi,BlockNM1.N8T24
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T22
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*2+2]
  mov   cl,[edi+PITCH*2+6]
   mov  esi,BlockNM1.N8T26
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T31
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*3+1]
   mov  cl,[edi+PITCH*3+5]
  mov   esi,BlockNM1.N8T35
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T33
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*3+3]
  mov   cl,[edi+PITCH*3+7]
   mov  esi,BlockNM1.N8T37
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T40
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*4+0]
   mov  cl,[edi+PITCH*4+4]
  mov   esi,BlockNM1.N8T44
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T42
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*4+2]
  mov   cl,[edi+PITCH*4+6]
   mov  esi,BlockNM1.N8T46
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T51
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*5+1]
   mov  cl,[edi+PITCH*5+5]
  mov   esi,BlockNM1.N8T55
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T53
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*5+3]
  mov   cl,[edi+PITCH*5+7]
   mov  esi,BlockNM1.N8T57
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T60
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*6+0]
   mov  cl,[edi+PITCH*6+4]
  mov   esi,BlockNM1.N8T64
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T62
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*6+2]
  mov   cl,[edi+PITCH*6+6]
   mov  esi,BlockNM1.N8T66
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  mov   eax,BlockNM1.N8T71
   mov  dl,[esi+ecx*8+2]
  mov   bl,[edi+PITCH*7+1]
   mov  cl,[edi+PITCH*7+5]
  mov   esi,BlockNM1.N8T75
   add  ebp,edx
  mov   edx,[eax+ebx*8]
   mov  eax,BlockNM1.N8T73
  mov   dl,[esi+ecx*8+2]
   mov  bl,[edi+PITCH*7+3]
  mov   cl,[edi+PITCH*7+7]
   mov  esi,BlockNM1.N8T77
  add   ebp,edx
   mov  edx,[eax+ebx*8]
  add   edx,ebp   
   mov  cl,[esi+ecx*8+2]
  shr   edx,16 
   add  ebp,ecx
  and   ebp,0FFFFH
   sub  esp,BlockLen
  add   ebp,edx
   sub  edi,8
  test  esp,000000008H
  mov   BlockN.CentralInterSWD_SLF,ebp
   jne  SLFSWDLoop

  test  esp,000000010H
  lea   edi,[edi-PITCH*8+16]
   jne  SLFSWDLoop

  mov   eax,Block2.CentralInterSWD_SLF+BlockLen*4
   mov  ebx,Block3.CentralInterSWD_SLF+BlockLen*4
  mov   ecx,Block4.CentralInterSWD_SLF+BlockLen*4
   add  esp,BlockLen*4
  add   ebp,ecx
   lea  edx,[eax+ebx]
  add   ebp,edx
   mov  edx,SpatialFiltDifferential
  lea   esi,[edi+PITCH*8-8]
   mov  edi,MBCentralInterSWD
  sub   edi,edx
   mov  edx,MBlockActionStream
  cmp   ebp,edi
   jge  SpatialFilterNotAsGood

  mov   MBCentralInterSWD,ebp            ; Spatial filter was better.  Stash
   mov  ebp,Block1.CentralInterSWD_SLF   ; pertinent calculations.
  mov   Block2.CentralInterSWD,eax
   mov  Block3.CentralInterSWD,ebx
  mov   Block4.CentralInterSWD,ecx
   mov  Block1.CentralInterSWD,ebp
  mov   [edx].BlkY1.PastRef,esi
   mov  al,INTERSLF
  mov   [edx].BlockType,al

SkipSpatialFiltering:
SpatialFilterNotAsGood:
ENDIF ; H261

  mov   al,[edx].CodedBlocks       ; Fetch coded block pattern.
   mov  edi,EmptyThreshold         ; Get threshold for forcing block empty?
  mov   ebp,MBCentralInterSWD
   mov  esi,InterSWDBlocks
  mov   ebx,Block4.CentralInterSWD ; Is SWD > threshold?
  cmp   ebx,edi
   jg   @f

  and   al,0F7H                    ; If not, indicate block 4 is NOT coded.
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block3.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FBH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block2.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FDH
   dec  esi
  sub   ebp,ebx

@@:

  mov   ebx,Block1.CentralInterSWD
  cmp   ebx,edi
   jg   @f

  and   al,0FEH
   dec  esi
  sub   ebp,ebx

@@:

  mov   [edx].CodedBlocks,al     ; Store coded block pattern.
   add  esi,4
  mov   InterSWDBlocks,esi
   xor  ebx,ebx
  and   eax,00FH
   mov  MBCentralInterSWD,ebp
  cmp   al,00FH                  ; Are any blocks marked empty?
   jne  InterBest                ; If some blocks are empty, can't code as Intra

  cmp   ebp,InterCodingThreshold ; Is InterSWD below inter-coding threshhold.
   lea  esi,Block1+128
  mov   ebp,0
   jae  CalculateIntraSWD

InterBest:

  mov   ecx,InterSWDTotal
   mov  ebp,MBCentralInterSWD
  add   ecx,ebp                    ; Add to total for this macroblock class.
   mov  PD [edx].SWD,ebp
  mov   InterSWDTotal,ecx
   jmp  NextMacroBlock


;  Activity Details for this section of code  (refer to flow diagram above):
;
;    11)  The IntraSWD is calculated as two partial sums, one in the low order
;         16 bits of ebp and one in the high order 16 bits.  An average pel
;         value for each block will be calculated to the nearest half.
;
; Register usage for this section:
;
;   Input of this section:
;
;     None
;
;   Predominate usage for body of this section:
;
;     esi -- Address of target block 1 (3), plus 128.
;     ebp[ 0:15] -- IntraSWD Accumulator for block 1 (3).
;     ebp[16:31] -- IntraSWD Accumulator for block 2 (4).
;     edi -- Block 2 (4) target pel, times -8, and with WeightedDiff added.
;     edx -- Block 1 (3) target pel, times -8, and with WeightedDiff added.
;     ecx[ 0: 7] -- Weighted difference for one pel in block 2 (4).
;     ecx[ 8:15] -- Zero.
;     ecx[16:23] -- Weighted difference for one pel in block 1 (3).
;     ecx[24:31] -- Zero.
;     ebx -- Average block 2 (4) target pel to nearest .5.
;     eax -- Average block 1 (3) target pel to nearest .5.
;
;   Output of this section:
;
;     edi -- Scratch.
;     ebp[ 0:15] -- IntraSWD.  (Also written to MBlockActionStream.)
;     ebp[16:31] -- garbage.
;     ebx -- Zero.
;     eax -- MBlockActionStream.
;
; Expected Pentium (tm) microprocessor performance for this section:
;
;   Executed once per macroblock, (except for those for which one of more blocks
;   are marked empty, or where the InterSWD is less than a threshold).
;
;   183 clocks for instruction execution
;    12 clocks for bank conflicts  (94 dual mem ops with 1/8 chance of conflict)
;  ----
;   195 clocks total time for this section.

IntraByDecree:

  mov   eax,InterSWDBlocks            ; Inc by 4, because we will undo it below.
   xor  ebp,ebp
  mov   MBMotionVectors,ebp           ; Stash zero for MB level motion vectors.
   mov  ebp,040000000H                ; Set Inter SWD artificially high.
  lea   esi,Block1+128
   add  eax,4
  mov   MBCentralInterSWD,ebp
   mov  InterSWDBlocks,eax

CalculateIntraSWD:
CalculateIntraSWDLoop:

  mov   eax,[esi-128].AccumTargetPels  ; Fetch acc of target pels for 1st block.
   mov  edx,[esi-128].N8T00
  add   eax,8
   mov  ebx,[esi-128+BlockLen].AccumTargetPels
  shr   eax,4                ; Average block 1 target pel rounded to nearest .5.
   add  ebx,8
  shr   ebx,4
   mov  edi,[esi-128+BlockLen].N8T00
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T02
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T02
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T04
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T04
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T06
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T06
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T11
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T11
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T13
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T13
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T15
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T15
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T17
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T17
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T20
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T20
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T22
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T22
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T24
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T24
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T26
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T26
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T31
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T31
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T33
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T33
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T35
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T35
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T37
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T37
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T40
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T40
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T42
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T42
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T44
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T44
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T46
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T46
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T51
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T51
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T53
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T53
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T55
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T55
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T57
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T57
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T60
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T60
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T62
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T62
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T64
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T64
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T66
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T66
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T71
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T71
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T73
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T73
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   edx,[esi-128].N8T75
   mov  cl,PB [edi+ebx*4+2]
  mov   edi,[esi-128+BlockLen].N8T75
   add  ebp,ecx
  mov   ecx,PD [edx+eax*4]
   mov  edx,[esi-128].N8T77
  mov   cl,PB [edi+ebx*4+2]
   mov  edi,[esi-128+BlockLen].N8T77
  add   ebp,ecx
   mov  ecx,PD [edx+eax*4]
  mov   cl,PB [edi+ebx*4+2]
   mov  eax,000007FFFH
  add   ebp,ecx
   add  esi,BlockLen*2
  and   eax,ebp
   mov  ecx,MBCentralInterSWD
  shr   ebp,16
   sub  ecx,IntraCodingDifferential
  add   ebp,eax
   mov  edx,MBlockActionStream    ; Reload list ptr.
  cmp   ecx,ebp                    ; Is IntraSWD > InterSWD - differential?
   jl   InterBest

  lea   ecx,Block1+128+BlockLen*2
  cmp   ecx,esi
   je   CalculateIntraSWDLoop


;  ebp  -- IntraSWD
;  edx  -- MBlockActionStream

DoneCalcIntraSWD:

IntraBest:

  mov   ecx,IntraSWDTotal
   mov  edi,IntraSWDBlocks
  add   ecx,ebp                    ; Add to total for this macroblock class.
   add  edi,4                      ; Accumulate # of blocks for this type.
  mov   IntraSWDBlocks,edi
   mov  edi,InterSWDBlocks
  sub   edi,4
   mov  IntraSWDTotal,ecx
  mov   InterSWDBlocks,edi
   mov  bl,INTRA
  mov   PB [edx].BlockType,bl      ; Indicate macroblock handling decision.
IFDEF H261
   xor  ebx,ebx
ELSE ; H263
   mov  ebx,MBMotionVectors        ; Set MVs to best MB level motion vectors.
ENDIF
  mov   PD [edx].BlkY1.MVs,ebx
   mov  PD [edx].BlkY2.MVs,ebx
  mov   PD [edx].BlkY3.MVs,ebx
   mov  PD [edx].BlkY4.MVs,ebx
  xor   ebx,ebx
  mov   PD [edx].SWD,ebp
   jmp  NextMacroBlock

;==============================================================================
; Internal functions
;==============================================================================

DoSWDLoop:

;  Upon entry:
;    esi -- Points to ref1
;    edi -- Points to ref2
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  mov   bl,PB [esi]               ; 00A -- Get Pel 00 in reference ref1.
   mov  eax,Block1.N8T00+4        ; 00B -- Get -8 times target pel 00.
  mov   cl,PB [edi]               ; 00C -- Get Pel 00 in reference ref2.
   sub  esp,BlockLen*4+28

SWDLoop:

  mov   edx,PD [eax+ebx*8]        ; 00D -- Get weighted diff for ref1 pel 00.
   mov  bl,PB [esi+2]             ; 02A
  mov   dl,PB [eax+ecx*8+2]       ; 00E -- Get weighted diff for ref2 pel 00.
   mov  eax,BlockN.N8T02+32       ; 02B
  mov   ebp,edx                   ; 00F -- Accum weighted diffs for pel 00.
   mov  cl,PB [edi+2]             ; 02C
  mov   edx,PD [eax+ebx*8]        ; 02D
   mov  bl,PB [esi+4]             ; 04A
  mov   dl,PB [eax+ecx*8+2]       ; 02E
   mov  eax,BlockN.N8T04+32       ; 04B
  mov   cl,PB [edi+4]             ; 04C
   add  ebp,edx                   ; 02F
  mov   edx,PD [eax+ebx*8]        ; 04D
   mov  bl,PB [esi+6]
  mov   dl,PB [eax+ecx*8+2]       ; 04E
   mov  eax,BlockN.N8T06+32
  mov   cl,PB [edi+6]
   add  ebp,edx                   ; 04F
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T11+32
  mov   cl,PB [edi+PITCH*1+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T13+32
  mov   cl,PB [edi+PITCH*1+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T15+32
  mov   cl,PB [edi+PITCH*1+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*1+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T17+32
  mov   cl,PB [edi+PITCH*1+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T20+32
  mov   cl,PB [edi+PITCH*2+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T22+32
  mov   cl,PB [edi+PITCH*2+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T24+32
  mov   cl,PB [edi+PITCH*2+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*2+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T26+32
  mov   cl,PB [edi+PITCH*2+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T31+32
  mov   cl,PB [edi+PITCH*3+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T33+32
  mov   cl,PB [edi+PITCH*3+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T35+32
  mov   cl,PB [edi+PITCH*3+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*3+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T37+32
  mov   cl,PB [edi+PITCH*3+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T40+32
  mov   cl,PB [edi+PITCH*4+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T42+32
  mov   cl,PB [edi+PITCH*4+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T44+32
  mov   cl,PB [edi+PITCH*4+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*4+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T46+32
  mov   cl,PB [edi+PITCH*4+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T51+32
  mov   cl,PB [edi+PITCH*5+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T53+32
  mov   cl,PB [edi+PITCH*5+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T55+32
  mov   cl,PB [edi+PITCH*5+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*5+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T57+32
  mov   cl,PB [edi+PITCH*5+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+0]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T60+32
  mov   cl,PB [edi+PITCH*6+0]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+2]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T62+32
  mov   cl,PB [edi+PITCH*6+2]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+4]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T64+32
  mov   cl,PB [edi+PITCH*6+4]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*6+6]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T66+32
  mov   cl,PB [edi+PITCH*6+6]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+1]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T71+32
  mov   cl,PB [edi+PITCH*7+1]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+3]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T73+32
  mov   cl,PB [edi+PITCH*7+3]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+5]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T75+32
  mov   cl,PB [edi+PITCH*7+5]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   mov  bl,PB [esi+PITCH*7+7]
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,BlockN.N8T77+32
  mov   cl,PB [edi+PITCH*7+7]
   add  ebp,edx
  mov   edx,PD [eax+ebx*8]
   add  esp,BlockLen
  mov   dl,PB [eax+ecx*8+2]
   mov  eax,ebp
  add   ebp,edx
   add  edx,eax
  shr   ebp,16                       ; Extract SWD for ref1.
   and  edx,00000FFFFH               ; Extract SWD for ref2.
  mov   esi,BlockN.Ref1Addr+32       ; Get address of next ref1 block.
   mov  edi,BlockN.Ref2Addr+32       ; Get address of next ref2 block.
  mov   BlockNM1.Ref1InterSWD+32,ebp ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,edx ; Store SWD for ref2.
  mov   bl,PB [esi]                  ; 00A -- Get Pel 02 in reference ref1.
   mov  eax,BlockN.N8T00+32          ; 00B -- Get -8 times target pel 00.
  test  esp,000000018H               ; Done when esp is 32-byte aligned.
  mov   cl,PB [edi]                  ; 00C -- Get Pel 02 in reference ref2.
   jne  SWDLoop

; Output:
;    ebp -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
;    ecx -- Upper 24 bits zero
;    ebx -- Upper 24 bits zero

  add   esp,28
  ret

IFDEF H261
ELSE ; H263

DoSWDHalfPelHorzLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel to left.  Ref2 is .5 to right.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelHorzLoop:

  mov   al,[edi]           ; 00A -- Fetch center ref pel 00.
   mov  esi,BlockN.N8T00+32; 00B -- Target pel 00 (times -8).
  mov   bl,[edi+2]         ; 02A -- Fetch center ref pel 02.
   mov  edx,BlockN.N8T02+32; 02B -- Target pel 02 (times -8).
  lea   esi,[esi+eax*4]    ; 00C -- Combine target pel 00 and center ref pel 00.
   mov  al,[edi-1]         ; 00D -- Get pel to left for match against pel 00.
  lea   edx,[edx+ebx*4]    ; 02C -- Combine target pel 02 and center ref pel 02.
   mov  bl,[edi+1]         ; 00E -- Get pel to right for match against pel 00,
   ;                       ; 02D -- and pel to left for match against pel 02.
  mov   ecx,[esi+eax*4]    ; 00F -- [16:23]  weighted diff for left ref pel 00.
   mov  al,[edi+3]         ; 02E -- Get pel to right for match against pel 02.
  add   ebp,ecx            ; 00G -- Accumulate left ref pel 00.
   mov  ecx,[edx+ebx*4]    ; 02F -- [16:23]  weighted diff for left ref pel 02.
  mov   cl,[edx+eax*4+2]   ; 02H -- [0:7] is weighted diff for right ref pel 02.
   mov  al,[edi+4]         ; 04A
  add   ebp,ecx            ; 02I -- Accumulate right ref pel 02,
  ;                        ; 02G -- Accumulate left ref pel 02.
   mov  bl,[esi+ebx*4+2]   ; 00H -- [0:7] is weighted diff for right ref pel 00.
  add   ebp,ebx            ; 00I -- Accumulate right ref pel 00.
   mov  esi,BlockN.N8T04+32; 04B
  mov   bl,[edi+6]         ; 06A
   mov  edx,BlockN.N8T06+32; 06B
  lea   esi,[esi+eax*4]    ; 04C
   mov  al,[edi+3]         ; 04D
  lea   edx,[edx+ebx*4]    ; 06C
   mov  bl,[edi+5]         ; 04E & 06D
  mov   ecx,[esi+eax*4]    ; 04F
   mov  al,[edi+7]         ; 06E
  add   ebp,ecx            ; 04G
   mov  ecx,[edx+ebx*4]    ; 06F
  mov   cl,[edx+eax*4+2]   ; 06H
   mov  al,[edi+PITCH*1+1] ; 11A
  add   ebp,ecx            ; 04I & 06G
   mov  bl,[esi+ebx*4+2]   ; 04H
  add   ebp,ebx            ; 04I
   mov  esi,BlockN.N8T11+32; 11B
  mov   bl,[edi+PITCH*1+3] ; 13A
   mov  edx,BlockN.N8T13+32; 13B
  lea   esi,[esi+eax*4]    ; 11C
   mov  al,[edi+PITCH*1+0] ; 11D
  lea   edx,[edx+ebx*4]    ; 13C
   mov  bl,[edi+PITCH*1+2] ; 11E & 13D
  mov   ecx,[esi+eax*4]    ; 11F
   mov  al,[edi+PITCH*1+4] ; 13E
  add   ebp,ecx            ; 11G
   mov  ecx,[edx+ebx*4]    ; 13F
  mov   cl,[edx+eax*4+2]   ; 13H
   mov  al,[edi+PITCH*1+5] ; 15A
  add   ebp,ecx            ; 11I & 13G
   mov  bl,[esi+ebx*4+2]   ; 11H
  add   ebp,ebx            ; 11I
   mov  esi,BlockN.N8T15+32; 15B
  mov   bl,[edi+PITCH*1+7] ; 17A
   mov  edx,BlockN.N8T17+32; 17B
  lea   esi,[esi+eax*4]    ; 15C
   mov  al,[edi+PITCH*1+4] ; 15D
  lea   edx,[edx+ebx*4]    ; 17C
   mov  bl,[edi+PITCH*1+6] ; 15E & 17D
  mov   ecx,[esi+eax*4]    ; 15F
   mov  al,[edi+PITCH*1+8] ; 17E
  add   ebp,ecx            ; 15G
   mov  ecx,[edx+ebx*4]    ; 17F
  mov   cl,[edx+eax*4+2]   ; 17H
   mov  al,[edi+PITCH*2+0] ; 20A
  add   ebp,ecx            ; 15I & 17G
   mov  bl,[esi+ebx*4+2]   ; 15H
  add   ebp,ebx            ; 15I
   mov  esi,BlockN.N8T20+32; 20B
  mov   bl,[edi+PITCH*2+2] ; 22A
   mov  edx,BlockN.N8T22+32; 22B
  lea   esi,[esi+eax*4]    ; 20C
   mov  al,[edi+PITCH*2-1] ; 20D
  lea   edx,[edx+ebx*4]    ; 22C
   mov  bl,[edi+PITCH*2+1] ; 20E & 22D
  mov   ecx,[esi+eax*4]    ; 20F
   mov  al,[edi+PITCH*2+3] ; 22E
  add   ebp,ecx            ; 20G
   mov  ecx,[edx+ebx*4]    ; 22F
  mov   cl,[edx+eax*4+2]   ; 22H
   mov  al,[edi+PITCH*2+4] ; 24A
  add   ebp,ecx            ; 20I & 22G
   mov  bl,[esi+ebx*4+2]   ; 20H
  add   ebp,ebx            ; 20I
   mov  esi,BlockN.N8T24+32; 24B
  mov   bl,[edi+PITCH*2+6] ; 26A
   mov  edx,BlockN.N8T26+32; 26B
  lea   esi,[esi+eax*4]    ; 24C
   mov  al,[edi+PITCH*2+3] ; 24D
  lea   edx,[edx+ebx*4]    ; 26C
   mov  bl,[edi+PITCH*2+5] ; 24E & 26D
  mov   ecx,[esi+eax*4]    ; 24F
   mov  al,[edi+PITCH*2+7] ; 26E
  add   ebp,ecx            ; 24G
   mov  ecx,[edx+ebx*4]    ; 26F
  mov   cl,[edx+eax*4+2]   ; 26H
   mov  al,[edi+PITCH*3+1] ; 31A
  add   ebp,ecx            ; 24I & 26G
   mov  bl,[esi+ebx*4+2]   ; 24H
  add   ebp,ebx            ; 24I
   mov  esi,BlockN.N8T31+32; 31B
  mov   bl,[edi+PITCH*3+3] ; 33A
   mov  edx,BlockN.N8T33+32; 33B
  lea   esi,[esi+eax*4]    ; 31C
   mov  al,[edi+PITCH*3+0] ; 31D
  lea   edx,[edx+ebx*4]    ; 33C
   mov  bl,[edi+PITCH*3+2] ; 31E & 33D
  mov   ecx,[esi+eax*4]    ; 31F
   mov  al,[edi+PITCH*3+4] ; 33E
  add   ebp,ecx            ; 31G
   mov  ecx,[edx+ebx*4]    ; 33F
  mov   cl,[edx+eax*4+2]   ; 33H
   mov  al,[edi+PITCH*3+5] ; 35A
  add   ebp,ecx            ; 31I & 33G
   mov  bl,[esi+ebx*4+2]   ; 31H
  add   ebp,ebx            ; 31I
   mov  esi,BlockN.N8T35+32; 35B
  mov   bl,[edi+PITCH*3+7] ; 37A
   mov  edx,BlockN.N8T37+32; 37B
  lea   esi,[esi+eax*4]    ; 35C
   mov  al,[edi+PITCH*3+4] ; 35D
  lea   edx,[edx+ebx*4]    ; 37C
   mov  bl,[edi+PITCH*3+6] ; 35E & 37D
  mov   ecx,[esi+eax*4]    ; 35F
   mov  al,[edi+PITCH*3+8] ; 37E
  add   ebp,ecx            ; 35G
   mov  ecx,[edx+ebx*4]    ; 37F
  mov   cl,[edx+eax*4+2]   ; 37H
   mov  al,[edi+PITCH*4+0] ; 40A
  add   ebp,ecx            ; 35I & 37G
   mov  bl,[esi+ebx*4+2]   ; 35H
  add   ebp,ebx            ; 35I
   mov  esi,BlockN.N8T40+32; 40B
  mov   bl,[edi+PITCH*4+2] ; 42A
   mov  edx,BlockN.N8T42+32; 42B
  lea   esi,[esi+eax*4]    ; 40C
   mov  al,[edi+PITCH*4-1] ; 40D
  lea   edx,[edx+ebx*4]    ; 42C
   mov  bl,[edi+PITCH*4+1] ; 40E & 42D
  mov   ecx,[esi+eax*4]    ; 40F
   mov  al,[edi+PITCH*4+3] ; 42E
  add   ebp,ecx            ; 40G
   mov  ecx,[edx+ebx*4]    ; 42F
  mov   cl,[edx+eax*4+2]   ; 42H
   mov  al,[edi+PITCH*4+4] ; 44A
  add   ebp,ecx            ; 40I & 42G
   mov  bl,[esi+ebx*4+2]   ; 40H
  add   ebp,ebx            ; 40I
   mov  esi,BlockN.N8T44+32; 44B
  mov   bl,[edi+PITCH*4+6] ; 46A
   mov  edx,BlockN.N8T46+32; 46B
  lea   esi,[esi+eax*4]    ; 44C
   mov  al,[edi+PITCH*4+3] ; 44D
  lea   edx,[edx+ebx*4]    ; 46C
   mov  bl,[edi+PITCH*4+5] ; 44E & 46D
  mov   ecx,[esi+eax*4]    ; 44F
   mov  al,[edi+PITCH*4+7] ; 46E
  add   ebp,ecx            ; 44G
   mov  ecx,[edx+ebx*4]    ; 46F
  mov   cl,[edx+eax*4+2]   ; 46H
   mov  al,[edi+PITCH*5+1] ; 51A
  add   ebp,ecx            ; 44I & 46G
   mov  bl,[esi+ebx*4+2]   ; 44H
  add   ebp,ebx            ; 44I
   mov  esi,BlockN.N8T51+32; 51B
  mov   bl,[edi+PITCH*5+3] ; 53A
   mov  edx,BlockN.N8T53+32; 53B
  lea   esi,[esi+eax*4]    ; 51C
   mov  al,[edi+PITCH*5+0] ; 51D
  lea   edx,[edx+ebx*4]    ; 53C
   mov  bl,[edi+PITCH*5+2] ; 51E & 53D
  mov   ecx,[esi+eax*4]    ; 51F
   mov  al,[edi+PITCH*5+4] ; 53E
  add   ebp,ecx            ; 51G
   mov  ecx,[edx+ebx*4]    ; 53F
  mov   cl,[edx+eax*4+2]   ; 53H
   mov  al,[edi+PITCH*5+5] ; 55A
  add   ebp,ecx            ; 51I & 53G
   mov  bl,[esi+ebx*4+2]   ; 51H
  add   ebp,ebx            ; 51I
   mov  esi,BlockN.N8T55+32; 55B
  mov   bl,[edi+PITCH*5+7] ; 57A
   mov  edx,BlockN.N8T57+32; 57B
  lea   esi,[esi+eax*4]    ; 55C
   mov  al,[edi+PITCH*5+4] ; 55D
  lea   edx,[edx+ebx*4]    ; 57C
   mov  bl,[edi+PITCH*5+6] ; 55E & 57D
  mov   ecx,[esi+eax*4]    ; 55F
   mov  al,[edi+PITCH*5+8] ; 57E
  add   ebp,ecx            ; 55G
   mov  ecx,[edx+ebx*4]    ; 57F
  mov   cl,[edx+eax*4+2]   ; 57H
   mov  al,[edi+PITCH*6+0] ; 60A
  add   ebp,ecx            ; 55I & 57G
   mov  bl,[esi+ebx*4+2]   ; 55H
  add   ebp,ebx            ; 55I
   mov  esi,BlockN.N8T60+32; 60B
  mov   bl,[edi+PITCH*6+2] ; 62A
   mov  edx,BlockN.N8T62+32; 62B
  lea   esi,[esi+eax*4]    ; 60C
   mov  al,[edi+PITCH*6-1] ; 60D
  lea   edx,[edx+ebx*4]    ; 62C
   mov  bl,[edi+PITCH*6+1] ; 60E & 62D
  mov   ecx,[esi+eax*4]    ; 60F
   mov  al,[edi+PITCH*6+3] ; 62E
  add   ebp,ecx            ; 60G
   mov  ecx,[edx+ebx*4]    ; 62F
  mov   cl,[edx+eax*4+2]   ; 62H
   mov  al,[edi+PITCH*6+4] ; 64A
  add   ebp,ecx            ; 60I & 62G
   mov  bl,[esi+ebx*4+2]   ; 60H
  add   ebp,ebx            ; 60I
   mov  esi,BlockN.N8T64+32; 64B
  mov   bl,[edi+PITCH*6+6] ; 66A
   mov  edx,BlockN.N8T66+32; 66B
  lea   esi,[esi+eax*4]    ; 64C
   mov  al,[edi+PITCH*6+3] ; 64D
  lea   edx,[edx+ebx*4]    ; 66C
   mov  bl,[edi+PITCH*6+5] ; 64E & 66D
  mov   ecx,[esi+eax*4]    ; 64F
   mov  al,[edi+PITCH*6+7] ; 66E
  add   ebp,ecx            ; 64G
   mov  ecx,[edx+ebx*4]    ; 66F
  mov   cl,[edx+eax*4+2]   ; 66H
   mov  al,[edi+PITCH*7+1] ; 71A
  add   ebp,ecx            ; 64I & 66G
   mov  bl,[esi+ebx*4+2]   ; 64H
  add   ebp,ebx            ; 64I
   mov  esi,BlockN.N8T71+32; 71B
  mov   bl,[edi+PITCH*7+3] ; 73A
   mov  edx,BlockN.N8T73+32; 73B
  lea   esi,[esi+eax*4]    ; 71C
   mov  al,[edi+PITCH*7+0] ; 71D
  lea   edx,[edx+ebx*4]    ; 73C
   mov  bl,[edi+PITCH*7+2] ; 71E & 73D
  mov   ecx,[esi+eax*4]    ; 71F
   mov  al,[edi+PITCH*7+4] ; 73E
  add   ebp,ecx            ; 71G
   mov  ecx,[edx+ebx*4]    ; 73F
  mov   cl,[edx+eax*4+2]   ; 73H
   mov  al,[edi+PITCH*7+5] ; 75A
  add   ebp,ecx            ; 71I & 73G
   mov  bl,[esi+ebx*4+2]   ; 71H
  add   ebp,ebx            ; 71I
   mov  esi,BlockN.N8T75+32; 75B
  mov   bl,[edi+PITCH*7+7] ; 77A
   mov  edx,BlockN.N8T77+32; 77B
  lea   esi,[esi+eax*4]    ; 75C
   mov  al,[edi+PITCH*7+4] ; 75D
  lea   edx,[edx+ebx*4]    ; 77C
   mov  bl,[edi+PITCH*7+6] ; 75E & 77D
  mov   ecx,[esi+eax*4]    ; 75F
   mov  al,[edi+PITCH*7+8] ; 77E
  add   ebp,ecx            ; 75G
   mov  ecx,[edx+ebx*4]    ; 77F
  mov   cl,[edx+eax*4+2]   ; 77H
   add  esp,BlockLen
  add   ecx,ebp            ; 75I & 77G
   mov  bl,[esi+ebx*4+2]   ; 75H
  add   ebx,ecx            ; 75I
   mov  edi,BlockN.AddrCentralPoint+32 ; Get address of next ref1 block.
  shr   ecx,16                         ; Extract SWD for ref1.
   and  ebx,00000FFFFH                 ; Extract SWD for ref2.
  mov   BlockNM1.Ref1InterSWD+32,ecx   ; Store SWD for ref1.
   mov  BlockNM1.Ref2InterSWD+32,ebx   ; Store SWD for ref2.
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelHorzLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret


DoSWDHalfPelVertLoop:

;    ebp -- Initialized to 0, except when can't search off left or right edge.
;    edi -- Ref addr for block 1.  Ref1 is .5 pel up.  Ref2 is .5 down.

  xor   ecx,ecx
   sub  esp,BlockLen*4+28
  xor   eax,eax
   xor  ebx,ebx

SWDHalfPelVertLoop:

  mov   al,[edi]
   mov  esi,BlockN.N8T00+32
  mov   bl,[edi+2*PITCH]
   mov  edx,BlockN.N8T20+32
  lea   esi,[esi+eax*4]
   mov  al,[edi-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T40+32
  mov   bl,[edi+6*PITCH]
   mov  edx,BlockN.N8T60+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T11+32
  mov   bl,[edi+1+3*PITCH]
   mov  edx,BlockN.N8T31+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+1+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T51+32
  mov   bl,[edi+1+7*PITCH]
   mov  edx,BlockN.N8T71+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+1+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+1+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+1+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T02+32
  mov   bl,[edi+2+2*PITCH]
   mov  edx,BlockN.N8T22+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+2+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T42+32
  mov   bl,[edi+2+6*PITCH]
   mov  edx,BlockN.N8T62+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+2+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+2+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+2+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T13+32
  mov   bl,[edi+3+3*PITCH]
   mov  edx,BlockN.N8T33+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+3+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T53+32
  mov   bl,[edi+3+7*PITCH]
   mov  edx,BlockN.N8T73+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+3+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+3+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+3+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T04+32
  mov   bl,[edi+4+2*PITCH]
   mov  edx,BlockN.N8T24+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+4+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T44+32
  mov   bl,[edi+4+6*PITCH]
   mov  edx,BlockN.N8T64+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+4+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+4+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+4+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T15+32
  mov   bl,[edi+5+3*PITCH]
   mov  edx,BlockN.N8T35+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+5+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T55+32
  mov   bl,[edi+5+7*PITCH]
   mov  edx,BlockN.N8T75+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+5+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+5+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+5+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+0*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T06+32
  mov   bl,[edi+6+2*PITCH]
   mov  edx,BlockN.N8T26+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6-1*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+1*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+6+4*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T46+32
  mov   bl,[edi+6+6*PITCH]
   mov  edx,BlockN.N8T66+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+6+3*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+6+5*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+6+7*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+1*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T17+32
  mov   bl,[edi+7+3*PITCH]
   mov  edx,BlockN.N8T37+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+0*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+2*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   mov  al,[edi+7+5*PITCH]
  add   ebp,ecx
   mov  bl,[esi+ebx*4+2]
  add   ebp,ebx
   mov  esi,BlockN.N8T57+32
  mov   bl,[edi+7+7*PITCH]
   mov  edx,BlockN.N8T77+32
  lea   esi,[esi+eax*4]
   mov  al,[edi+7+4*PITCH]
  lea   edx,[edx+ebx*4]
   mov  bl,[edi+7+6*PITCH]
  mov   ecx,[esi+eax*4]
   mov  al,[edi+7+8*PITCH]
  add   ebp,ecx
   mov  ecx,[edx+ebx*4]
  mov   cl,[edx+eax*4+2]
   add  esp,BlockLen
  add   ecx,ebp
   mov  bl,[esi+ebx*4+2]
  add   ebx,ecx
   mov  edi,BlockN.AddrCentralPoint+32
  shr   ecx,16
   and  ebx,00000FFFFH
  mov   BlockNM1.Ref1InterSWD+32,ecx
   mov  BlockNM1.Ref2InterSWD+32,ebx
  xor   ebp,ebp
   mov  edx,ebx
  test  esp,000000018H
  mov   ebx,ebp
   jne  SWDHalfPelVertLoop

; Output:
;    ebp, ebx -- Zero
;    ecx -- Ref1 SWD for block 4
;    edx -- Ref2 SWD for block 4
   
  add  esp,28
  ret

ENDIF ; H263


; Performance for common macroblocks:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;  1412 clocks:  6-level search for best SWD.
;    16 clocks:  record best fit.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  2913 clocks total
;
; Performance for macroblocks in which 0-motion vector is "good enough":
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    16 clocks:  record best fit.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;   945 clocks:  calculate spatial loop filtered prediction.
;   152 clocks:  calculate SWD for spatially filtered prediction and classify.
;  ----
;  1559 clocks total
;
; Performance for macroblocks marked as intrablock by decree of caller:
;   298 clocks:  prepare target pels, compute avg target pel, compute 0-MV SWD.
;    90 clocks:  compute IntraSWD.
;    58 clocks:  extra cache fill burden on adjacent MB if SWD-search not done.
;    20 clocks:  classify (just weight the SWD for # of match points).
;  ----
;   476 clocks total
;
; 160*120 performance, generously estimated (assuming lots of motion):
;
;  2913 * 80 = 233000 clocks for luma.
;  2913 * 12 =  35000 clocks for chroma.
;              268000 clocks per frame * 15 = 4,020,000 clocks/sec.
;
; 160*120 performance, assuming typical motion:
;
;  2913 * 40 + 1559 * 40 = 179000 clocks for luma.
;  2913 *  8 + 1559 *  4 =  30000 clocks for chroma.
;                          209000 clocks per frame * 15 = 3,135,000 clocks/sec.
;
; Add 10-20% to allow for initial cache-filling, and unfortunate cases where
; cache-filling policy preempts areas of the tables that are not locally "hot",
; instead of preempting macroblocks upon which the processing was just finished.


Done:

  mov   eax,IntraSWDTotal
  mov   ebx,IntraSWDBlocks
  mov   ecx,InterSWDTotal
  mov   edx,InterSWDBlocks
  mov   esp,StashESP
  mov   edi,[esp+IntraSWDTotal_arg]
  mov   [edi],eax
  mov   edi,[esp+IntraSWDBlocks_arg]
  mov   [edi],ebx
  mov   edi,[esp+InterSWDTotal_arg]
  mov   [edi],ecx
  mov   edi,[esp+InterSWDBlocks_arg]
  mov   [edi],edx
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn


MOTIONESTIMATION endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exmfdct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   R:\h26x\h26x\src\enc\exmfdct.asv   1.3   22 Jul 1996 15:23:20   BNICKERS  $
;// $Log:   R:\h26x\h26x\src\enc\exmfdct.asv  $
;// 
;//    Rev 1.3   22 Jul 1996 15:23:20   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.2   02 May 1996 12:00:54   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.1   15 Mar 1996 15:52:44   BECHOLS
;// 
;// Completed monolithic - Brian
;// 
;//    Rev 1.0   22 Feb 1996 20:04:46   BECHOLS
;// Initial revision.
;// 
;//
;////////////////////////////////////////////////////////////////////////////
;
; exmfdct -- This function performs a Forward Discrete Cosine Transform for
; H263, on a stream of macroblocks comprised of 8*8 blocks of pels or pel
; differences.  It is tightly coupled with its caller, the frame differencing
; code, and its callee, the Quantization/Run-length-encoding code.
;

.xlist
include memmodel.inc
include e3inst.inc   ; Encoder instance data
include e3mbad.inc   ; MacroBlock Action Descriptor struct layout
include exEDTQ.inc   ; Data structures for motion -E-stimation, frame -D-iff,
                     ; Forward DCT -T-ransform, and -Q-uant/RLE.
include iammx.inc    ; MMx instructions
.list

.CODE EDTQ

EXTERN MMxQuantRLE:NEAR

;ASSUME cs : FLAT
;ASSUME ds : FLAT
;ASSUME es : FLAT
;ASSUME fs : FLAT
;ASSUME gs : FLAT
;ASSUME ss : FLAT

PUBLIC MMxDoForwardDCT
PUBLIC MMxDoForwardDCTx
PUBLIC MMxDoForwardDCTy

MMxDoForwardDCTx:
  movq       PelDiffsLine7,mm1
MMxDoForwardDCTy:
  mov        ebp,16
  lea        esi,PelDiffs
MMxDoForwardDCT:

StackOffset TEXTEQU <8>

; ++ ========================================================================
; The Butterfly macro performs a 4x8 symetrical butterfly on half of an
; 8x8 block of memory.  Given rows r0 to r7 the Butterfly gives the following
; results.      q0 = r0+r7,  q7 = r0-r7
;               q1 = r1+r6,  q6 = r1-r6
;               q2 = r2+r5,  q5 = r2-r5
;               q3 = r3+r4,  q4 = r3-r4
; This code has been optimized, but still gives up three half clocks.  The
; butterflies are numbered 10 -> 16, 20 -> 26, 30 -> 36, and 40 -> 46.
; -- ========================================================================
Butterfly1     MACRO
   punpcklbw   mm7,[esi]           ;10  -- Fetch line 0 of input.
   punpcklbw   mm0,[esi+ecx*1]     ;11  -- Fetch line 7 of input.
    pmulhw     mm7,mm4             ;12  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm6,[esi+ebp*1]     ;  20
    pmulhw     mm0,mm4             ;13  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm1,[esi+eax*2]     ;  21
    pmulhw     mm6,mm4             ;  22
   punpcklbw   mm5,[esi+ebp*2]     ;    30
    pmulhw     mm1,mm4             ;  23
   punpcklbw   mm2,[esi+ebx*1]     ;    31
    psubw      mm7,mm0             ;14  -- Line0 - Line7
   punpcklbw   mm4,[esi+eax*1]     ;       40
    paddw      mm0,mm0             ;15  -- 2 * Line7
   punpcklbw   mm3,[esi+ebp*4]     ;       41
    paddw      mm0,mm7             ;16  -- Line0 + Line7
   psraw       mm5,8               ;    32
    psubw      mm6,mm1             ;  24
   psraw       mm2,8               ;    33
    paddw      mm1,mm1             ;  25
   psraw       mm4,8               ;      42
    paddw      mm1,mm6             ;  26
   psraw       mm3,8               ;      43
    psubw      mm5,mm2             ;    34
   movq        [edi+7*8*2],mm7     ;17  -- Save Line0 - Line7
    psubw      mm4,mm3             ;      44
   movq        [edi+0*8*2],mm0     ;18  -- Save Line0 + Line7
    paddw      mm2,mm2             ;    35
   movq        [edi+6*8*2],mm6     ;  27
    paddw      mm3,mm3             ;      45
   movq        [edi+1*8*2],mm1     ;  28
    paddw      mm2,mm5             ;    36
   movq        [edi+5*8*2],mm5     ;    37
    paddw      mm3,mm4             ;      46
   movq        [edi+2*8*2],mm2     ;    38
   movq        [edi+4*8*2],mm4     ;      47
   movq        [edi+3*8*2],mm3     ;      48
ENDM

Butterfly2     MACRO
   movq        mm0,[edi+0*8*2]        ;10
   movq        mm1,[edi+7*8*2]        ;11
     movq      mm2,mm0                 ;12
   movq        mm3,[edi+1*8*2]        ;  20
     paddw     mm0,mm1                 ;13
   movq        mm4,[edi+6*8*2]        ;  21
     psubw     mm2,mm1                 ;14
   movq        [edi+0*8*2],mm0        ;15
   movq        [edi+7*8*2],mm2        ;16
     movq      mm5,mm3                 ;  22
   movq        mm6,[edi+2*8*2]        ;    30
     paddw     mm3,mm4                 ;  23
   movq        mm7,[edi+5*8*2]        ;    31
     psubw     mm5,mm4                 ;  24
   movq        [edi+1*8*2],mm3        ;  25
     movq      mm0,mm6                 ;    32
   movq        [edi+6*8*2],mm5        ;  26
     paddw     mm6,mm7                 ;    33
   movq        mm1,[edi+3*8*2]        ;      40
     psubw     mm0,mm7                 ;    34
   movq        mm2,[edi+4*8*2]        ;      41
     movq      mm3,mm1                 ;      42
   movq        [edi+2*8*2],mm6        ;    35
     paddw     mm1,mm2                 ;      43
   movq        [edi+5*8*2],mm0        ;    36
     psubw     mm3,mm2                 ;      44
   movq        [edi+3*8*2],mm1        ;      45
   movq        [edi+4*8*2],mm3        ;      46
ENDM

; ++ ========================================================================
; The StageOne macro performs a 4x4 Butterfly on rows q0 to q4 such that:
;               p0 = q0+q3,  p3 = q0-q3
;               p1 = q1+q2,  p2 = q1-q2
; A scaled butterflyon rows q5 and q6 yield the following equations.
;               p5 = C4*(q6-q5), p6 = C4*(q6+q5)
; This has been optimized, but gives up four half clocks.  The two simple
; butterflies are numbered 10 -> 16 and 30 -> 36.
; The scaled butterfly is numbered 20 -> 2c.
; -- ========================================================================
StageOne       MACRO
   movq        mm4,[edi+0*8*2]        ;10
   movq        mm5,[edi+3*8*2]        ;11
     movq      mm6,mm4                 ;12
   movq        mm0,[edi+6*8*2]        ;  20
     paddw     mm4,mm5                 ;13
   movq        mm1,[edi+5*8*2]        ;  21
     psubw     mm6,mm5                 ;14
   movq        [edi+0*8*2],mm4        ;15
     movq      mm2,mm0                 ;  22
   movq        [edi+3*8*2],mm6        ;16
     paddw     mm2,mm1                 ;  23
   psubw       mm0,mm1                 ;  24
   movq        mm3,[edi+1*8*2]        ;    30
     psllw     mm0,2                   ;  25
   movq        mm4,[edi+2*8*2]        ;    31
     psllw     mm2,2                   ;  26
   pmulhw      mm0,PD C4               ;  27
     movq      mm5,mm3                 ;    32
   pmulhw      mm2,PD C4               ;  28
     paddw     mm3,mm4                 ;    33
   psubw       mm5,mm4                 ;    34
   movq        [edi+1*8*2],mm3        ;    35
     psraw     mm0,1                   ;  29
   movq        [edi+2*8*2],mm5        ;    36
     psraw     mm2,1                   ;  2a
   movq        [edi+5*8*2],mm0        ;  2b
   movq        [edi+6*8*2],mm2        ;  2c
ENDM

; ++ ========================================================================
; The StageTwo macro performs two simple butterflies on rows p4,p5 and
; p6,p7 such that:
;               n4 = p4+p5,  n5 = p4-p5
;               n6 = p7-p6,  n7 = p7+p6
; They are numbered 20 -> 26 and 40 -> 46.
;
; It also performs a scaled butterflies on rows p0,p1 such that:
;               n0 = C4*(p0+p1), n1 = C4*(p0-p1)
; This are numbered 10 -> 1c.
;
; Finally, it performs a butterfly on the scaled rows p2,p3 such that:
;               n2 = C2*p3+C6*p2, n3 = C6*p6-C2*p2
; This is numbered 30 -> 3f.
;
; This macro has been optimized, but gives up four half clocks.
; -- ========================================================================
StageTwo       MACRO
   movq        mm1,[edi+3*8*2]        ;    30
   movq        mm2,[edi+2*8*2]        ;    31
     psllw     mm1,2                   ;    32
   movq        mm5,[edi+4*8*2]        ;  20
     psllw     mm2,2                   ;    33
   movq        mm6,[edi+5*8*2]        ;  21
     movq      mm3,mm1                 ;    34
   pmulhw      mm1,PD C2               ;    36
     movq      mm4,mm2                 ;    35
   pmulhw      mm2,PD C6               ;    37
     movq      mm7,mm5                 ;  22
   pmulhw      mm3,PD C6               ;    38
     paddw     mm5,mm6                 ;  23
   pmulhw      mm4,PD C2               ;    39
     psubw     mm7,mm6                 ;  24
   movq        [edi+4*8*2],mm5        ;  25
     paddw     mm1,mm2                 ;    3a
   movq        [edi+5*8*2],mm7        ;  26
     psraw     mm1,1                   ;    3c
   movq        mm6,[edi+0*8*2]        ;10
     psubw     mm3,mm4                 ;    3b
   movq        mm0,[edi+1*8*2]        ;11
     psraw     mm3,1                   ;    3d
   movq        [edi+2*8*2],mm1        ;    3e
     movq      mm7,mm6                 ;12
   movq        [edi+3*8*2],mm3        ;    3f
     paddw     mm6,mm0                 ;13
   movq        mm3,[edi+7*8*2]        ;      40
     psubw     mm7,mm0                 ;14
   movq        mm5,[edi+6*8*2]        ;      41
     psllw     mm6,2                   ;15
   psllw       mm7,2                   ;16
   pmulhw      mm6,PD C4               ;17
     movq      mm4,mm3                 ;      42
   pmulhw      mm7,PD C4               ;18
     paddw     mm3,mm5                 ;      43
   psubw       mm4,mm5                 ;      44
   movq        [edi+7*8*2],mm3        ;      45
     psraw     mm6,1                   ;19
   movq        [edi+6*8*2],mm4        ;      46
     psraw     mm7,1                   ;1a
   movq        [edi+0*8*2],mm6        ;1b
   movq        [edi+1*8*2],mm7        ;1c
ENDM

; ++ ========================================================================
; The StageThree macro performs a butterfly on the scaled rows n4,n7 and
; n5,n6 such that:
;               m4 = C7*n4+C1*n7,  m7 = C1*n7-C7*n4
;               m5 = C5*n6+C3*n5,  m6 = C3*n6-C5*n5
; Steps 10 -> 1f determine m4,m7 and 20 -> 2f determine m5,m6.
; The outputs m0-m7 are put into reverse binary order as follows:
;               0 = 000  ->  000 = 0
;               1 = 001  ->  100 = 4
;               2 = 010  ->  010 = 2
;               3 = 011  ->  110 = 6
;               4 = 100  ->  001 = 1
;               5 = 101  ->  101 = 5
;               6 = 110  ->  011 = 3
;               7 = 111  ->  111 = 7
;
; This macro has been optimized, but I had to give up 10 half clocks.
; -- ========================================================================
StageThree     MACRO
   movq        mm0,[edi+7*8*2]        ;10
   movq        mm4,[edi+6*8*2]        ;  20
   movq        mm1,[edi+4*8*2]        ;11
     psllw     mm0,2                  ;12
   movq        mm5,[edi+5*8*2]        ;  21
     psllw     mm4,2                  ;  22
   movq        mm3,[edi+1*8*2]        ;
     psllw     mm1,2                  ;13
   movq        mm7,[edi+3*8*2]        ;
     psllw     mm5,2                  ;  23
   movq        [edi+4*8*2],mm3        ;
     movq      mm2,mm0                ;14
   movq        [edi+6*8*2],mm7        ;
     movq      mm6,mm4                ;  24
   pmulhw      mm0,PD C1              ;16
     movq      mm3,mm1                ;15
   pmulhw      mm1,PD C7              ;17
   pmulhw      mm2,PD C7              ;18
   pmulhw      mm3,PD C1              ;19
     movq      mm7,mm5                ;  25
   pmulhw      mm4,PD C5              ;  26
     paddw     mm0,mm1                ;1a
   pmulhw      mm5,PD C3              ;  27
     psubw     mm2,mm3                ;1b
   pmulhw      mm6,PD C3              ;  28
   pmulhw      mm7,PD C5              ;  29
     psraw     mm0,1                  ;1c
   psraw       mm2,1                  ;1d
     paddw     mm4,mm5                ;  2a
   movq        [edi+1*8*2],mm0        ;1e
     psubw     mm6,mm7                ;  2b
   movq        [edi+7*8*2],mm2        ;1f
     psraw     mm4,1                  ;  2c
   psraw       mm6,1                  ;  2d
   movq        [edi+5*8*2],mm4        ;  2e
   movq        [edi+3*8*2],mm6        ;  2f
ENDM

OPTION NOM510

;============================================================================
; This section does the Forward Discrete Cosine Transform.  It performs a
;  DCT on an 8*8 block of pels or pel differences.
;
; Upon input:
;
; esi -- Address of block of pels or pel differences on which to perform FDCT.
; ebp -- Pitch of block (8, 16, or 384).
; edx -- Reserved.
;
; After setup:
;
; esi -- Address of block of pels or pel differences on which to perform FDCT.
; ebp -- Pitch of block (8, 16, or 384).  After Quant RLE, this gets set to 384.
; edx -- Reserved.
; edi -- Address at which to place intermediate and final coefficients.
; eax -- Pitch times 3
; ebx -- Pitch times 5
; ecx -- Pitch times 7
; mm5 -- 4 words of 256.
; mm0:mm7 -- Scratch.

   lea         edi,Coeffs
    lea        eax,[ebp+ebp*2]
   movq        mm4,PD C0100010001000100
   lea         ebx,[ebp+ebp*4]
    lea        ecx,[eax+ebp*4]

RepeatFirstTransform:

; ++ ========================================================================
; The Butterfly performs a 4x8 symetrical butterfly on half of an
; 8x8 block of memory.  Given rows r0 to r7 the Butterfly gives the following
; results.      q0 = r0+r7,  q7 = r0-r7
;               q1 = r1+r6,  q6 = r1-r6
;               q2 = r2+r5,  q5 = r2-r5
;               q3 = r3+r4,  q4 = r3-r4
; This code has been optimized, but still gives up three half clocks.  The
; butterflies are numbered 10 -> 16, 20 -> 26, 30 -> 36, and 40 -> 46.
; -- ========================================================================

   punpcklbw   mm7,[esi]           ;10  -- Fetch line 0 of input.
   punpcklbw   mm0,[esi+ecx*1]     ;11  -- Fetch line 7 of input.
    pmulhw     mm7,mm4             ;12  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm6,[esi+ebp*1]     ;  20
    pmulhw     mm0,mm4             ;13  -- Sign extend the 4 pels or pel diffs.
   punpcklbw   mm1,[esi+eax*2]     ;  21
    pmulhw     mm6,mm4             ;  22
   punpcklbw   mm5,[esi+ebp*2]     ;    30
    pmulhw     mm1,mm4             ;  23
   punpcklbw   mm2,[esi+ebx*1]     ;    31
    psubw      mm7,mm0             ;14  -- Line0 - Line7
   punpcklbw   mm4,[esi+eax*1]     ;       40
    paddw      mm0,mm0             ;15  -- 2 * Line7
   punpcklbw   mm3,[esi+ebp*4]     ;       41
    paddw      mm0,mm7             ;16  -- Line0 + Line7
   psraw       mm5,8               ;    32
    psubw      mm6,mm1             ;  24
   psraw       mm2,8               ;    33
    paddw      mm1,mm1             ;  25
   psraw       mm4,8               ;      42
    paddw      mm1,mm6             ;  26
   psraw       mm3,8               ;      43
    psubw      mm5,mm2             ;    34
   psubw       mm4,mm3             ;      44
    paddw      mm2,mm2             ;    35
   paddw       mm3,mm3             ;      45
    paddw      mm2,mm5             ;    36
   paddw       mm3,mm4             ;      46

; ++ ========================================================================
; The StageOne performs a 4x4 Butterfly on rows q0 to q4 such that:
;               p0 = q0+q3,  p3 = q0-q3
;               p1 = q1+q2,  p2 = q1-q2
; A scaled butterflyon rows q5 and q6 yield the following equations.
;               p5 = C4*(q6-q5), p6 = C4*(q6+q5)
; This has been optimized, but gives up four half clocks.  The two simple
; butterflies are numbered 10 -> 16 and 30 -> 36.
; The scaled butterfly is numbered 20 -> 2c.
; -- ========================================================================

    psubw      mm1,mm2              ;     30  -- p2 = q1 - q2
   psubw       mm6,mm5              ;   20    -- q6 - q5
    paddw      mm5,mm5              ;   21    -- 2q5
   paddw       mm5,mm6              ;   22    -- q6 + q5
    psllw      mm6,2                ;   23    -- scale
   pmulhw      mm6,PD C4            ;   24    -- C4*(q6-q5) scaled
    psllw      mm5,2                ;   23    -- scale
   pmulhw      mm5,PD C4            ;   24    -- C4*(q6+q5) scaled
    psubw      mm0,mm3              ; 10      -- p3 = q0 - q3
   paddw       mm3,mm3              ; 11      -- 2q3
    paddw      mm2,mm2              ;     31  -- 2q2
   paddw       mm3,mm0              ; 12      -- p0 = q0 + q3
    psraw      mm6,1                ;   25    -- p5 = C4*(q6-q5)
   paddw       mm2,mm1              ;     32  -- p1 = q1 + q2
    psraw      mm5,1                ;   26    -- p6 = C4*(q6+q5)

; ++ ========================================================================
; The StageTwo performs two simple butterflies on rows p4,p5 and
; p6,p7 such that:
;               n4 = p4+p5,  n5 = p4-p5
;               n6 = p7-p6,  n7 = p7+p6
; They are numbered 20 -> 26 and 40 -> 46.
;
; It also performs a scaled butterflies on rows p0,p1 such that:
;               n0 = C4*(p0+p1), n1 = C4*(p0-p1)
; This are numbered 10 -> 1c.
;
; Finally, it performs a butterfly on the scaled rows p2,p3 such that:
;               n2 = C2*p3+C6*p2, n3 = C6*p6-C2*p2
; This is numbered 30 -> 3f.
; -- ========================================================================

   psubw       mm3,mm2              ; 10        -- p0 - p1
    paddw      mm2,mm2              ; 11        -- 2p1
   paddw       mm2,mm3              ; 12        -- p0 + p1
    psllw      mm3,2                ; 13        -- scale
   pmulhw      mm3,PD C4            ; 14        -- C4*(p0-p1)
    psllw      mm2,2                ; 15        -- scale
   pmulhw      mm2,PD C4            ; 16        -- C4*(p0+p1)
    psllw      mm0,2                ;     30    -- scale p3
   psubw       mm4,mm6              ;   20      -- n5 = p4 - p5
    psllw      mm1,2                ;     31    -- scale p2
   psubw       mm7,mm5              ;       40  -- n6 = p7 - p6
    psraw      mm3,1                ; 17        -- n1 = C4*(p0-p1)
   paddw       mm6,mm6              ;   21      -- 2p5
    psraw      mm2,1                ; 18        -- n0 = C4*(p0+p1)
   movq        [edi+4*8*2],mm3      ; 19        -- Save n1             (stage 3)
    movq       mm3,mm0              ;     32    -- Copy scaled p3
   movq        [edi+0*8*2],mm2      ; 1a        -- Save n0             (stage 3)
    movq       mm2,mm1              ;     33    -- Copy scaled p2
   pmulhw      mm0,PD C2            ;     34    -- C2*p3 scaled
    paddw      mm5,mm5              ;       41  -- 2p6
   pmulhw      mm1,PD C6            ;     35    -- C6*p2 scaled
    paddw      mm6,mm4              ;   22      -- n4 = p4 + p5
   pmulhw      mm3,PD C6            ;     36    -- C6*p3 scaled
    paddw      mm5,mm7              ;       42  -- n7 = p7 + p6
   pmulhw      mm2,PD C2            ;     37    -- C2*p2 scaled
    psllw      mm5,2                ; 10        -- scale n7            (stage 3)
   paddw       mm0,mm1              ;     38    -- C2*p3 + C6*p2 scaled
    psllw      mm7,2                ;   20      -- scale n6            (stage 3)
   movq        mm1,mm5              ; 11        -- copy scaled n7      (stage 3)
    psraw      mm0,1                ;     39    -- n2 = C2*p3 + C6*p2
   pmulhw      mm5,PD C1            ; 12        -- C1*n7 scaled        (stage 3)
    psllw      mm6,2                ; 13        -- scale n4            (stage 3)
   movq        [edi+2*8*2],mm0      ;     3c    -- Save n2             (stage 3)
    psubw      mm3,mm2              ;     3a    -- C6*p3 - C2*p2 scaled

; ++ ========================================================================
; The StageThree macro performs a butterfly on the scaled rows n4,n7 and
; n5,n6 such that:
;               m4 = C7*n4+C1*n7,  m7 = C7*n7-C1*n4
;               m5 = C5*n6+C3*n5,  m6 = C3*n6-C5*n5
; Steps 10 -> 1f determine m4,m7 and 20 -> 2f determine m5,m6.
; The outputs m0-m7 are put into reverse binary order as follows:
;               0 = 000  ->  000 = 0
;               1 = 001  ->  100 = 4
;               2 = 010  ->  010 = 2
;               3 = 011  ->  110 = 6
;               4 = 100  ->  001 = 1
;               5 = 101  ->  101 = 5
;               6 = 110  ->  011 = 3
;               7 = 111  ->  111 = 7
; -- ========================================================================

   pmulhw      mm1,PD C7            ; 14        -- C7*n7 scaled
    movq       mm0,mm6              ; 15        -- copy scaled n4
   pmulhw      mm6,PD C7            ; 16        -- C7*n4 scaled
    psraw      mm3,1                ;     3b    -- n3 = C6*p6 - C2*p2
   pmulhw      mm0,PD C1            ; 17        -- C1*n4 scaled
    movq       mm2,mm7              ;   21      -- copy scaled n6
   movq        [edi+6*8*2],mm3      ;     3d    -- Save n3
    psllw      mm4,2                ;   22      -- scale n5
   pmulhw      mm7,PD C5            ;   23      -- C5*n6 scaled
    movq       mm3,mm4              ;   24      -- copy scaled n5
   pmulhw      mm4,PD C3            ;   25      -- C3*n5 scaled
    paddw      mm5,mm6              ; 18        -- C7*n4+C1*n7 scaled
   pmulhw      mm2,PD C3            ;   26      -- C3*n6 scaled
    psubw      mm1,mm0              ; 19        -- C7*n7-C1*n4 scaled
   pmulhw      mm3,PD C5            ;   27      -- C5*n5 scaled
    psraw      mm5,1                ; 1a        -- m4 = C7*n4+C1*n7
   paddw       mm7,mm4              ;   28      -- C5*n6+C3*n5 scaled
    psraw      mm1,1                ; 1b        -- m7 = C7*n7-C1*n4
   movq        [edi+1*8*2],mm5      ; 1c        -- Save m4
    psraw      mm7,1                ;   29      -- m5 = C5*n6+C3*n5
   movq        [edi+7*8*2],mm1      ; 1d        -- Save m7
    psubw      mm2,mm3              ;   2a      -- C3*n6-C5*n5 scaled
   movq        [edi+5*8*2],mm7      ;   2b      -- Save m5
    psraw      mm2,1                ;   2c      -- m6 = C3*n6-C5*n5
   movq        mm4,PD C0100010001000100  ; Prepare for next iteration.
    ;
   movq        [edi+3*8*2],mm2      ;   2d      -- Save m6
    ;
   add         edi,8
    add        esi,4
   test        esi,4
    ;
   jne         RepeatFirstTransform

   sub         edi,16
    mov        esi,2

; ++ ========================================================================
; The Transpose performs four 4x4 transpositions as described in the
; MMx User's Guide.  This of course rotates the 8x8 matrix on its diagonal.
;
; This routine is more expensive than I had hoped.  I need to revisit this.
; -- ========================================================================

   movq        mm0,[edi+0*8*2]        ;10  <C03 C02 C01 C00>
    ;
   movq        mm1,[edi+1*8*2]        ;11  <C13 C12 C11 C01>
    movq       mm4,mm0                ;12  <C03 C02 C01 C00>
   movq        mm2,[edi+2*8*2]        ;13  <C23 C22 C21 C20>
    punpckhwd  mm0,mm1                ;14  <C13 C03 C12 C02>
   movq        mm3,[edi+3*8*2]        ;15  <C33 C32 C31 C30>
    punpcklwd  mm4,mm1                ;16  <C11 C01 C10 C00>
   movq        mm6,mm2                ;17  <C23 C22 C21 C20>
    punpckhwd  mm2,mm3                ;18  <C33 C23 C32 C22>
   movq        mm1,mm0                ;19  <C13 C03 C12 C02>
    punpckldq  mm0,mm2                ;1a  <C32 C22 C12 C02>
   movq        mm7,[edi+4*8*2]        ;  20
    punpcklwd  mm6,mm3                ;1b  <C31 C21 C30 C20>
   movq        [edi+2*8*2],mm0        ;1c  <C32 C22 C12 C02> saved
    punpckhdq  mm1,mm2                ;1d  <C33 C23 C13 C03>
   movq        mm5,mm4                ;1e  <C11 C01 C10 C00>
    punpckldq  mm4,mm6                ;1f  <C30 C20 C10 C00>
   movq        [edi+3*8*2],mm1        ;1g  <C33 C23 C13 C03> saved
    punpckhdq  mm5,mm6                ;1h  <C31 C21 C11 C01>
   movq        mm3,[edi+5*8*2]        ;  21
    movq       mm0,mm7                ;  22
   movq        mm2,[edi+6*8*2]        ;  23
    punpckhwd  mm7,mm3                ;  24
   movq        mm1,[edi+7*8*2]        ;  25
    punpcklwd  mm0,mm3                ;  26
   movq        [edi+0*8*2],mm4        ;1i  <C30 C20 C10 C00> saved
    movq       mm6,mm2                ;  27
   movq        [edi+1*8*2],mm5        ;1j  <C31 C21 C11 C01> saved
    punpckhwd  mm2,mm1                ;  28
   movq        mm3,mm7                ;  29
    punpckldq  mm7,mm2                ;  2a
   movq        mm4,[edi+0*8*2+8]      ;    30
    punpcklwd  mm6,mm1                ;  2b
   movq        mm1,[edi+2*8*2+8]      ;    33
    punpckhdq  mm3,mm2                ;  2d
   movq        [edi+2*8*2+8],mm7      ;  2c
    movq       mm5,mm0                ;  2e
   movq        mm7,[edi+1*8*2+8]      ;    31
    punpckldq  mm0,mm6                ;  2f
   movq        mm2,[edi+3*8*2+8]      ;    35
    punpckhdq  mm5,mm6                ;  2h
   movq        [edi+3*8*2+8],mm3      ;  2g
    movq       mm6,mm4                ;    32
   movq        [edi+0*8*2+8],mm0      ;  2i
    punpckhwd  mm4,mm7                ;    34
   movq        [edi+1*8*2+8],mm5      ;  2j
    punpcklwd  mm6,mm7                ;    36
   movq        mm3,mm1                ;    37
    punpckhwd  mm1,mm2                ;    38
   movq        mm7,mm4                ;    39
    punpckldq  mm4,mm1                ;    3a
   movq        mm0,[edi+4*8*2+8]      ;      40
    punpcklwd  mm3,mm2                ;    3b
   movq        [edi+6*8*2],mm4        ;    3c
    punpckhdq  mm7,mm1                ;    3d
   movq        mm5,mm6                ;    3e
    punpckldq  mm6,mm3                ;    3f
   movq        [edi+7*8*2],mm7        ;    3g
    punpckhdq  mm5,mm3                ;    3h
   movq        mm2,[edi+5*8*2+8]      ;      41
    movq       mm4,mm0                ;      42
   movq        mm1,[edi+6*8*2+8]      ;      43
    punpckhwd  mm0,mm2                ;      44
   movq        mm7,[edi+7*8*2+8]      ;      45
    punpcklwd  mm4,mm2                ;      46
   movq        [edi+4*8*2],mm6        ;    3i
    movq       mm3,mm1                ;      47
   movq        [edi+5*8*2],mm5        ;    3j
    punpckhwd  mm1,mm7                ;      48
   movq        mm2,mm0                ;      49
    punpckldq  mm0,mm1                ;      4a
   punpcklwd   mm3,mm7                ;      4b
    ;
   movq        [edi+6*8*2+8],mm0      ;      4c
    punpckhdq  mm2,mm1                ;      4d
   movq        mm6,mm4                ;      4e
    punpckldq  mm4,mm3                ;      4f
   movq        [edi+7*8*2+8],mm2      ;      4g
    punpckhdq  mm6,mm3                ;      4h
   movq        [edi+4*8*2+8],mm4      ;      4i
    ;
   movq        [edi+5*8*2+8],mm6      ;      4j
    ;

RepeatSecondTransform:

; ++ ========================================================================
; The Butterfly performs a 4x8 symetrical butterfly on half of an
; 8x8 block of memory.  Given rows r0 to r7 the Butterfly gives the following
; results.      q0 = r0+r7,  q7 = r0-r7
;               q1 = r1+r6,  q6 = r1-r6
;               q2 = r2+r5,  q5 = r2-r5
;               q3 = r3+r4,  q4 = r3-r4
; This code has been optimized, but still gives up three half clocks.  The
; butterflies are numbered 10 -> 16, 20 -> 26, 30 -> 36, and 40 -> 46.
; -- ========================================================================

   movq        mm7,[edi]           ;10  -- Fetch line 0 of input.
   movq        mm0,[edi+7*8*2]     ;11  -- Fetch line 7 of input.
   movq        mm6,[edi+1*8*2]     ;  20
    psubw      mm7,mm0             ;14  -- Line0 - Line7
   movq        mm1,[edi+6*8*2]     ;  21
    paddw      mm0,mm0             ;15  -- 2 * Line7
   movq        mm5,[edi+2*8*2]     ;    30
    paddw      mm0,mm7             ;16  -- Line0 + Line7
   movq        mm2,[edi+5*8*2]     ;    31
    psubw      mm6,mm1             ;  24
   paddw       mm1,[edi+1*8*2]     ;  26
    psubw      mm5,mm2             ;    34
   movq        mm4,[edi+3*8*2]     ;       40
   movq        mm3,[edi+4*8*2]     ;       41
    psubw      mm6,mm5             ;   20    -- q6 - q5                (Stage 1)
   paddw       mm2,[edi+2*8*2]     ;    36
    psubw      mm4,mm3             ;      44
   paddw       mm3,[edi+3*8*2]     ;      46
    psubw      mm1,mm2             ;     30  -- p2 = q1 - q2           (Stage 1)

; ++ ========================================================================
; The StageOne performs a 4x4 Butterfly on rows q0 to q4 such that:
;               p0 = q0+q3,  p3 = q0-q3
;               p1 = q1+q2,  p2 = q1-q2
; A scaled butterflyon rows q5 and q6 yield the following equations.
;               p5 = C4*(q6-q5), p6 = C4*(q6+q5)
; This has been optimized, but gives up four half clocks.  The two simple
; butterflies are numbered 10 -> 16 and 30 -> 36.
; The scaled butterfly is numbered 20 -> 2c.
; -- ========================================================================

    paddw      mm5,mm5              ;   21    -- 2q5
   paddw       mm5,mm6              ;   22    -- q6 + q5
    psllw      mm6,2                ;   23    -- scale
   pmulhw      mm6,PD C4            ;   24    -- C4*(q6-q5) scaled
    psllw      mm5,2                ;   23    -- scale
   pmulhw      mm5,PD C4            ;   24    -- C4*(q6+q5) scaled
    psubw      mm0,mm3              ; 10      -- p3 = q0 - q3
   paddw       mm3,mm3              ; 11      -- 2q3
    paddw      mm2,mm2              ;     31  -- 2q2
   paddw       mm3,mm0              ; 12      -- p0 = q0 + q3
    psraw      mm6,1                ;   25    -- p5 = C4*(q6-q5)
   paddw       mm2,mm1              ;     32  -- p1 = q1 + q2
    psraw      mm5,1                ;   26    -- p6 = C4*(q6+q5)

; ++ ========================================================================
; The StageTwo performs two simple butterflies on rows p4,p5 and
; p6,p7 such that:
;               n4 = p4+p5,  n5 = p4-p5
;               n6 = p7-p6,  n7 = p7+p6
; They are numbered 20 -> 26 and 40 -> 46.
;
; It also performs a scaled butterflies on rows p0,p1 such that:
;               n0 = C4*(p0+p1), n1 = C4*(p0-p1)
; This are numbered 10 -> 1c.
;
; Finally, it performs a butterfly on the scaled rows p2,p3 such that:
;               n2 = C2*p3+C6*p2, n3 = C6*p6-C2*p2
; This is numbered 30 -> 3f.
; -- ========================================================================

   psubw       mm3,mm2              ; 10        -- p0 - p1
    paddw      mm2,mm2              ; 11        -- 2p1
   paddw       mm2,mm3              ; 12        -- p0 + p1
    psllw      mm3,2                ; 13        -- scale
   pmulhw      mm3,PD C4            ; 14        -- C4*(p0-p1)
    psllw      mm2,2                ; 15        -- scale
   pmulhw      mm2,PD C4            ; 16        -- C4*(p0+p1)
    psllw      mm0,2                ;     30    -- scale p3
   psubw       mm4,mm6              ;   20      -- n5 = p4 - p5
    psllw      mm1,2                ;     31    -- scale p2
   psubw       mm7,mm5              ;       40  -- n6 = p7 - p6
    psraw      mm3,1                ; 17        -- n1 = C4*(p0-p1)
   paddw       mm6,mm6              ;   21      -- 2p5
    psraw      mm2,1                ; 18        -- n0 = C4*(p0+p1)
   movq        [edi+4*8*2],mm3      ; 19        -- Save n1             (stage 3)
    movq       mm3,mm0              ;     32    -- Copy scaled p3
   movq        [edi+0*8*2],mm2      ; 1a        -- Save n0             (stage 3)
    movq       mm2,mm1              ;     33    -- Copy scaled p2
   pmulhw      mm0,PD C2            ;     34    -- C2*p3 scaled
    paddw      mm5,mm5              ;       41  -- 2p6
   pmulhw      mm1,PD C6            ;     35    -- C6*p2 scaled
    paddw      mm6,mm4              ;   22      -- n4 = p4 + p5
   pmulhw      mm3,PD C6            ;     36    -- C6*p3 scaled
    paddw      mm5,mm7              ;       42  -- n7 = p7 + p6
   pmulhw      mm2,PD C2            ;     37    -- C2*p2 scaled
    psllw      mm5,2                ; 10        -- scale n7            (stage 3)
   paddw       mm0,mm1              ;     38    -- C2*p3 + C6*p2 scaled
    psllw      mm7,2                ;   20      -- scale n6            (stage 3)
   movq        mm1,mm5              ; 11        -- copy scaled n7      (stage 3)
    psraw      mm0,1                ;     39    -- n2 = C2*p3 + C6*p2
   pmulhw      mm5,PD C1            ; 12        -- C1*n7 scaled        (stage 3)
    psllw      mm6,2                ; 13        -- scale n4            (stage 3)
   movq        [edi+2*8*2],mm0      ;     3c    -- Save n2             (stage 3)
    psubw      mm3,mm2              ;     3a    -- C6*p3 - C2*p2 scaled

; ++ ========================================================================
; The StageThree macro performs a butterfly on the scaled rows n4,n7 and
; n5,n6 such that:
;               m4 = C7*n4+C1*n7,  m7 = C7*n7-C1*n4
;               m5 = C5*n6+C3*n5,  m6 = C3*n6-C5*n5
; Steps 10 -> 1f determine m4,m7 and 20 -> 2f determine m5,m6.
; The outputs m0-m7 are put into reverse binary order as follows:
;               0 = 000  ->  000 = 0
;               1 = 001  ->  100 = 4
;               2 = 010  ->  010 = 2
;               3 = 011  ->  110 = 6
;               4 = 100  ->  001 = 1
;               5 = 101  ->  101 = 5
;               6 = 110  ->  011 = 3
;               7 = 111  ->  111 = 7
; -- ========================================================================

   pmulhw      mm1,PD C7            ; 14        -- C7*n7 scaled
    movq       mm0,mm6              ; 15        -- copy scaled n4
   pmulhw      mm6,PD C7            ; 16        -- C7*n4 scaled
    psraw      mm3,1                ;     3b    -- n3 = C6*p6 - C2*p2
   pmulhw      mm0,PD C1            ; 17        -- C1*n4 scaled
    movq       mm2,mm7              ;   21      -- copy scaled n6
   movq        [edi+6*8*2],mm3      ;     3d    -- Save n3
    psllw      mm4,2                ;   22      -- scale n5
   pmulhw      mm7,PD C5            ;   23      -- C5*n6 scaled
    movq       mm3,mm4              ;   24      -- copy scaled n5
   pmulhw      mm4,PD C3            ;   25      -- C3*n5 scaled
    paddw      mm5,mm6              ; 18        -- C7*n4+C1*n7 scaled
   pmulhw      mm2,PD C3            ;   26      -- C3*n6 scaled
    psubw      mm1,mm0              ; 19        -- C7*n7-C1*n4 scaled
   pmulhw      mm3,PD C5            ;   27      -- C5*n5 scaled
    psraw      mm5,1                ; 1a        -- m4 = C7*n4+C1*n7
   paddw       mm7,mm4              ;   28      -- C5*n6+C3*n5 scaled
    psraw      mm1,1                ; 1b        -- m7 = C7*n7-C1*n4
   movq        [edi+1*8*2],mm5      ; 1c        -- Save m4
    psraw      mm7,1                ;   29      -- m5 = C5*n6+C3*n5
   movq        [edi+7*8*2],mm1      ; 1d        -- Save m7
    psubw      mm2,mm3              ;   2a      -- C3*n6-C5*n5 scaled
   movq        [edi+5*8*2],mm7      ;   2b      -- Save m5
    psraw      mm2,1                ;   2c      -- m6 = C3*n6-C5*n5
    dec        esi
   movq        [edi+3*8*2],mm2      ;   2d      -- Save m6
    ;
   lea         edi,[edi+8]
    jne        RepeatSecondTransform

   mov         ebp,PITCH
    jmp        MMxQuantRLE

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exedtq.inc ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\exedtq.inv   1.15   06 Nov 1996 16:18:34   BNICKERS  $
;//
;// $Log:   S:\h26x\src\enc\exedtq.inv  $
;// 
;//    Rev 1.15   06 Nov 1996 16:18:34   BNICKERS
;// Improve performance.
;// 
;//    Rev 1.14   18 Oct 1996 16:57:14   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.13   10 Oct 1996 16:42:54   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.12   04 Oct 1996 08:48:00   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.11   12 Sep 1996 10:56:18   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.10   22 Jul 1996 15:23:32   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.9   25 Jun 1996 14:24:54   BNICKERS
;// Implement heuristic motion estimation for MMX, AP mode.
;// 
;//    Rev 1.8   14 May 1996 12:18:54   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.7   03 May 1996 14:03:46   BNICKERS
;// 
;// Minor bug fixes and integration refinements.
;// 
;//    Rev 1.6   02 May 1996 12:00:58   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.5   16 Apr 1996 16:41:02   BNICKERS
;// Start adding storage for B frame ME.
;// 
;//    Rev 1.4   10 Apr 1996 13:14:12   BNICKERS
;// Recoding of Motion Estimation, Advanced Prediction.
;// 
;//    Rev 1.3   05 Apr 1996 12:27:54   BNICKERS
;// Improvements to baseline half pel ME.
;// 
;//    Rev 1.2   26 Mar 1996 12:00:20   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.1   20 Mar 1996 15:26:56   KLILLEVO
;// changed quantization to match IA quantization
;// 
;//    Rev 1.0   15 Mar 1996 15:54:14   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.0   16 Feb 1996 17:12:12   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; exEDTQ.inc -- Include file for MMx versions of Motion Estimation and Frame
;               Differencing, Forward DC Transform, and Quant/RLE.
;
; Storage on local stack frame for variables that survive only for the duration
; of one of the four phases (Motion Est, Frame Diff, FDCT, Quant RLE).  This
; storage is prime in that it is accessed by the 3-byte addressing form,
; esp+8_bit_Disp.  This is particularly important for MMx instructions, which
; would be 8 bytes long if a 32-bit Displacement was used.  There's a penalty
; for such a long instruction.
; (128 bytes; 32:159)


;                            ********************************************
;   Motion Estimation Locals * THAT DO NOT SURVIVE DURING OTHER PASSES. *
;                            ********************************************

HalfPelMBMESWDAccum      TEXTEQU <[esp+   0+StackOffset]>; 4 QWORDs + bit bucket
BestOfFourStartingPoints TEXTEQU HalfPelMBMESWDAccum+4
BitBucket1               TEXTEQU <[esp+  32+StackOffset]>; 8 bytes (QWORD)
StashMM6                 TEXTEQU <[esp+  32+StackOffset]>; QWORD
PartSWDForLLBlk          TEXTEQU <[esp+  32+StackOffset]>; QWORD
SWDULandLR               TEXTEQU <[esp+  40+StackOffset]>; QWORD

BitBucket2               TEXTEQU <[esp+  48+StackOffset]>; QWORD
PartSWDForLRBlk          TEXTEQU <[esp+  48+StackOffset]>; QWORD
Addr0MVRefBlk            TEXTEQU <[esp+  48+StackOffset]>; DWORD
LimitForSWDForBlkMV      TEXTEQU <[esp+  52+StackOffset]>; DWORD
SWDURandLL               TEXTEQU <[esp+  56+StackOffset]>; QWORD

PartSWDForURBlk          TEXTEQU <[esp+  64+StackOffset]>; QWORD
SWD0MVURandLL            TEXTEQU <[esp+  72+StackOffset]>; QWORD
SWD0MVULandLR            TEXTEQU <[esp+  80+StackOffset]>; QWORD
SWDForNon0MVToBeat       TEXTEQU <[esp+  88+StackOffset]>; DWORD
BestMBFullPelSWD         TEXTEQU <[esp+  92+StackOffset]>; DWORD
BestMBHalfPelSWD         TEXTEQU <[esp+  96+StackOffset]>; DWORD
BestMBHalfPelRefAddr     TEXTEQU <[esp+ 100+StackOffset]>; DWORD
BestHalfPelHorzSWD       TEXTEQU <[esp+ 104+StackOffset]>; DWORD
BestHalfPelVertSWD       TEXTEQU <[esp+ 108+StackOffset]>; DWORD
Addr0MVRef               TEXTEQU <[esp+ 112+StackOffset]>; DWORD
BestBlockRefAddrVP1      TEXTEQU <[esp+ 116+StackOffset]>; DWORD
BestBlkFullPelSWD        TEXTEQU <[esp+ 120+StackOffset]>; DWORD
SWDForBlock2Or4          TEXTEQU <[esp+ 124+StackOffset]>; DWORD

;   Frame Differencing Locals, passed to FDCT.
;
;   The output of frame differencing is the input to the forward DCT.
;   The intermediate coefficients are also stored here.  This keeps the
;   addressing forms as small as possible.  This is particularly important
;   for MMx instructions, to keep them 7 bytes or shorter.
;   (32:167)

PelDiffs      TEXTEQU <[esp+StackOffset]>  ; Must stay here!
PelDiffsLine0 TEXTEQU <PelDiffs>
PelDiffsLine1 TEXTEQU <PelDiffs+16>
PelDiffsLine2 TEXTEQU <PelDiffs+32>
PelDiffsLine3 TEXTEQU <PelDiffs+48>
PelDiffsLine4 TEXTEQU <PelDiffs+64>
PelDiffsLine5 TEXTEQU <PelDiffs+80>
PelDiffsLine6 TEXTEQU <PelDiffs+96>
PelDiffsLine7 TEXTEQU <PelDiffs+112>
Coeffs        TEXTEQU <[esp+StackOffset+8]>   ; 16 QWORDs

;                   *****************************************
;   Local variables * THAT SURVIVE FROM ONE PASS TO ANOTHER *
;                   *****************************************
;
; QWORD aligned:
; (184:191)

BlockAbove                     TEXTEQU <[esp+StackOffset+152]> ; 2 DWORDs

;                             ************************************************
;   Frame Differencing Locals * THAT NEED NOT SURVIVE OTHER PASSES (but do). *
;                             ************************************************
;   These three blocks of 8*8 storage are needed for the left, right, and
;   central remote prediction contributions.
; (192:383)

LeftPred                       TEXTEQU <[esp+StackOffset+160]>
RightPred                      TEXTEQU <[esp+StackOffset+224]>
CentralPred                    TEXTEQU <[esp+CONST_384*1+StackOffset-96]>

;   Temp space used by Heuristic ME.

TargetSigContribForRowPairs    TEXTEQU CentralPred

;                   *****************************************
;   Local variables * THAT SURVIVE FROM ONE PASS TO ANOTHER *
;                   *****************************************
; (384:511)
DoHalfPelME                    TEXTEQU <[esp+CONST_384*1+StackOffset- 32]>
DoBlockLevelVectors            TEXTEQU <[esp+CONST_384*1+StackOffset- 28]>
DoAdvancedPrediction           TEXTEQU <[esp+CONST_384*1+StackOffset- 27]>
DoSpatialFiltering             TEXTEQU <[esp+CONST_384*1+StackOffset- 26]>
IsPlainPFrame                  TEXTEQU <[esp+CONST_384*1+StackOffset- 25]>
TargetFrameBaseAddress         TEXTEQU <[esp+CONST_384*1+StackOffset- 24]>
PreviousFrameBaseAddress       TEXTEQU <[esp+CONST_384*1+StackOffset- 20]>
TargToRef                      TEXTEQU <[esp+CONST_384*1+StackOffset- 16]>
BFrameBaseAddress              TEXTEQU <[esp+CONST_384*1+StackOffset- 12]>
SpatiallyFilteredMB            TEXTEQU <BFrameBaseAddress>
BFrameToFuture                 TEXTEQU <[esp+CONST_384*1+StackOffset-  8]>
SpatialFiltThreshold           TEXTEQU <BFrameToFuture>
PendingOBMC                    TEXTEQU <[esp+CONST_384*1+StackOffset-  4]>
SpatialFiltDifferential        TEXTEQU <PendingOBMC>
DistToBADforBlockAbove         TEXTEQU <[esp+CONST_384*1+StackOffset+  0]>
DistToBADforBlockBelow         TEXTEQU <[esp+CONST_384*1+StackOffset+  4]>
AddrOfLeftPred                 TEXTEQU <[esp+CONST_384*1+StackOffset+  8]>
AddrOfRightPred                TEXTEQU <[esp+CONST_384*1+StackOffset+ 12]>
Recip2QPToUse                  TEXTEQU <[esp+CONST_384*1+StackOffset+ 16]>
QPDiv2                         TEXTEQU <[esp+CONST_384*1+StackOffset+ 20]>
BRecip2QPToUse                 TEXTEQU <[esp+CONST_384*1+StackOffset+ 24]>
BQPDiv2                        TEXTEQU <[esp+CONST_384*1+StackOffset+ 28]>
CodeStreamCursor               TEXTEQU <[esp+CONST_384*1+StackOffset+ 32]>
BCodeStreamCursor              TEXTEQU <[esp+CONST_384*1+StackOffset+ 36]>
C00Copy                        TEXTEQU <[esp+CONST_384*1+StackOffset+ 40]>
StashBlockType                 TEXTEQU <[esp+CONST_384*1+StackOffset+ 44]>
TargetMacroBlockBaseAddr       TEXTEQU <[esp+CONST_384*1+StackOffset+ 48]>
BestMV                         TEXTEQU <[esp+CONST_384*1+StackOffset+ 52]>
BestMBHalfPelMV                TEXTEQU <[esp+CONST_384*1+StackOffset+ 56]>
CandidateMV                    TEXTEQU <BestMBHalfPelMV>
SWDTotal                       TEXTEQU <[esp+CONST_384*1+StackOffset+ 60]>
BSWDTotal                      TEXTEQU <[esp+CONST_384*1+StackOffset+ 64]>
BlockActionDescrCursor         TEXTEQU <[esp+CONST_384*1+StackOffset+ 68]>
MBlockActionStream             TEXTEQU BlockActionDescrCursor
BFrmCBP                        TEXTEQU <[esp+CONST_384*1+StackOffset+ 72]>
PastRefPitchDiv4               TEXTEQU <[esp+CONST_384*1+StackOffset+ 76]>
CurrSWDState                   TEXTEQU <[esp+CONST_384*1+StackOffset+ 80]>
StashPartialRefBlkAddr         TEXTEQU <[esp+CONST_384*1+StackOffset+ 84]>

StashESP                       TEXTEQU <[esp+CONST_384*1+StackOffset+ 92]>

; These two arrays use esp+384+96:esp+384+223, and esp+384*2-96:esp+384*2+31.
; (512:639, 704:831)

WeightForwardMotion            TEXTEQU <[esp+384+StackOffset+96]>
WeightBackwardMotion           TEXTEQU <[esp+384+StackOffset+160]>

; 32 more bytes of local variables here:
; (832:863)

DoHeuristicME                  TEXTEQU <[esp+CONST_384*2+StackOffset+ 32]>
TargetToSig_Debiased           TEXTEQU <[esp+CONST_384*2+StackOffset+ 36]>
SigToTarget                    TEXTEQU <[esp+CONST_384*2+StackOffset+ 40]>
BFrmZeroVectorThreshold        TEXTEQU <[esp+CONST_384*2+StackOffset+ 44]>
EMVLimitsForThisMB             TEXTEQU <[esp+CONST_384*2+StackOffset+ 48]> ; 8
DoExtendedMotionVectors        TEXTEQU <[esp+CONST_384*2+StackOffset+ 56]>
StackSpaceAvailable            TEXTEQU <[esp+CONST_384*2+StackOffset+ 60]>

EXTERNDEF C0100010001000100:DWORD
EXTERNDEF C1:DWORD
EXTERNDEF C2:DWORD
EXTERNDEF C3:DWORD
EXTERNDEF C4:DWORD
EXTERNDEF C5:DWORD
EXTERNDEF C6:DWORD
EXTERNDEF C7:DWORD
EXTERNDEF Diff_IdxRefWts:BYTE
EXTERNDEF FutureWt_FF_or_00:DWORD
EXTERNDEF BFrmSWDState:BYTE
EXTERNDEF Pel_Rnd:DWORD
EXTERNDEF LeftRightBlkPosition:DWORD
EXTERNDEF UpDownBlkPosition:DWORD
EXTERNDEF BlkEmptyFlag:BYTE
EXTERNDEF NextZigZagCoeff:BYTE

C00      = 0
C04      = 8
C10      = 16
C14      = 24
C20      = 32
C24      = 40
C30      = 48
C34      = 56
C40      = 64
C44      = 72
C50      = 80
C54      = 88
C60      = 96
C64      = 104
C70      = 112
C74      = 120
Q00      = C00      ;  C00
Q01      = C10      ;  C00+1
Q02      = C20      ;  C00+2
Q03      = C30      ;  C00+3
Q04      = C40      ;  C00+4
Q05      = C50      ;  C00+5
Q06      = C60      ;  C00+6
Q07      = C70      ;  C00+7
Q10      = C00+1    ;  C10
Q11      = C10+1    ;  C10+1
Q12      = C20+1    ;  C10+2
Q13      = C30+1    ;  C10+3
Q14      = C40+1    ;  C10+4
Q15      = C50+1    ;  C10+5
Q16      = C60+1    ;  C10+6
Q17      = C70+1    ;  C10+7
Q20      = C00+2    ;  C20
Q21      = C10+2    ;  C20+1
Q22      = C20+2    ;  C20+2
Q23      = C30+2    ;  C20+3
Q24      = C40+2    ;  C20+4
Q25      = C50+2    ;  C20+5
Q26      = C60+2    ;  C20+6
Q27      = C70+2    ;  C20+7
Q30      = C00+3    ;  C30
Q31      = C10+3    ;  C30+1
Q32      = C20+3    ;  C30+2
Q33      = C30+3    ;  C30+3
Q34      = C40+3    ;  C30+4
Q35      = C50+3    ;  C30+5
Q36      = C60+3    ;  C30+6
Q37      = C70+3    ;  C30+7
Q40      = C00+4    ;  C40
Q41      = C10+4    ;  C40+1
Q42      = C20+4    ;  C40+2
Q43      = C30+4    ;  C40+3
Q44      = C40+4    ;  C40+4
Q45      = C50+4    ;  C40+5
Q46      = C60+4    ;  C40+6
Q47      = C70+4    ;  C40+7
Q50      = C00+5    ;  C50
Q51      = C10+5    ;  C50+1
Q52      = C20+5    ;  C50+2
Q53      = C30+5    ;  C50+3
Q54      = C40+5    ;  C50+4
Q55      = C50+5    ;  C50+5
Q56      = C60+5    ;  C50+6
Q57      = C70+5    ;  C50+7
Q60      = C00+6    ;  C60
Q61      = C10+6    ;  C60+1
Q62      = C20+6    ;  C60+2
Q63      = C30+6    ;  C60+3
Q64      = C40+6    ;  C60+4
Q65      = C50+6    ;  C60+5
Q66      = C60+6    ;  C60+6
Q67      = C70+6    ;  C60+7
Q70      = C00+7    ;  C70
Q71      = C10+7    ;  C70+1
Q72      = C20+7    ;  C70+2
Q73      = C30+7    ;  C70+3
Q74      = C40+7    ;  C70+4
Q75      = C50+7    ;  C70+5
Q76      = C60+7    ;  C70+6
Q77      = C70+7    ;  C70+7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exmqrle.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;**  $Header:   R:\h26x\h26x\src\enc\exmqrle.asv   1.11   18 Oct 1996 16:57:20   BNICKERS  $
;**
;**  $Log:   R:\h26x\h26x\src\enc\exmqrle.asv  $
;// 
;//    Rev 1.11   18 Oct 1996 16:57:20   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.10   10 Oct 1996 16:42:32   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.9   22 Jul 1996 15:23:28   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.8   02 May 1996 12:00:50   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.7   10 Apr 1996 13:14:16   BNICKERS
;// No change.
;// 
;//    Rev 1.6   26 Mar 1996 12:00:26   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.5   20 Mar 1996 15:26:58   KLILLEVO
;// changed quantization to match IA quantization
;// 
;//    Rev 1.4   15 Mar 1996 15:52:06   BECHOLS
;// 
;// Completed Monolithic - Brian
;// 
;//    Rev 1.3   27 Feb 1996 08:28:04   KLILLEVO
;// now saves ebx in order not to crash in release build
;// 
;//    Rev 1.2   22 Feb 1996 18:38:38   BECHOLS
;// 
;// Rescaled the quantization constants, Intra DC scaling, and accounted
;// for the inter bias that frame differencing performs.
;// 
;//    Rev 1.1   25 Jan 1996 08:20:32   BECHOLS
;// Changed the zigzag path to match the output of the MMx Forward DCT.
;// 
;//    Rev 1.0   17 Oct 1995 13:35:10   AGUPTA2
;// Initial revision.
;** *************************************************************************
;*/

;/* MMXQuantRLE This function performs quantization on a block of coefficients
;**          and produces (run,level,sign) triples. (These triples are VLC by 
;**          another routine.)  'run' is unsigned byte integer, 'level' is 
;**          unsigned byte integer, and 'sign' is a signed byte integer with 
;**          a value of either 0  or -1.  Since 'level' is an unsigned byte 
;**          integer, it needs to be clamped, to the right range for AC coeff,
;**          outside this routine.
;** Arguments:
;**   CoeffStr: Starting Address of coefficient stream; each coeff is a
;**             signed 16-bit value and stored in an 8X8 matrix
;**   CodeStr:  Starting address of code stream; i.e. starting address for code 
;**             stream triples
;**   QP:       Quantizer value 1..31
;**   IntraFlag:Odd for INTRA and even for INTER
;** Returns:
;**   Ending code stream address
;** Dependencies:
;**   Clamping of 'level' must be done by the caller.   
;*/

.xlist
include e3inst.inc
include memmodel.inc
include iammx.inc
include exEDTQ.inc
include e3mbad.inc
.list

.CODE EDTQ
PUBLIC MMxQuantRLE

StackOffset TEXTEQU <8>
CONST_384   TEXTEQU <ebp>

MMxQuantRLE:

  lea         esi, Coeffs+128
   mov        edi, CodeStreamCursor
  mov         bl, StashBlockType
   mov        eax, -128
  cmp         bl, INTRA        
   mov        ebx, Coeffs+C00
  pxor        mm6, mm6                        ; clear mm6
   je         @f

  movdt       mm6,QPDiv2                      ; load mm6 with 4 copies of QP/2

@@:

; Register usage:
;  esi -- base addr of coefficients; the order expected is the same as produced 
;         by Fast DCT
;  edi -- RLE stream cursor
;  edx -- Reserved.  MacroBlockActionStream cursor, perturbed by block offsets.
;  eax -- Loop induction variable.
;  ebx -- DC
;  ebp -- Reserved.  PITCH
;  mm7 -- Reciprocal of quantization level.

  movdt       mm7, Recip2QPToUse
   punpckldq  mm6, mm6    
  movq        mm0, C00[esi+eax]           ;00A  Load 4 coeffs
   punpckldq  mm7, mm7                    ; 4 words of Recip2QP
  movq        mm2, C04[esi+eax]           ;04A
   movq       mm1, mm0                    ;00B  Copy
  psraw       mm0, 15                     ;00C  Extract sign
   movq       mm3, mm2                    ;04B

QuantCoeffs:

  psraw       mm3, 15                     ;04C
   pxor       mm1, mm0                    ;00D  1's complement
  pxor        mm2, mm3                    ;04D
   psubsw     mm1, mm0                    ;00E  Absolute value
  psubsw      mm2, mm3                    ;04E
   psubusw    mm1, mm6                    ;00S  Subtract QP/2 in case of inter
  pmulhw      mm1, mm7                    ;00F  Quantize
   psubusw    mm2, mm6                    ;04S
  movq        mm4, C10[esi+eax]           ;10A
   pmulhw     mm2, mm7                    ;04F
  movq        mm5, mm4                    ;10B
   packsswb   mm0, mm3                    ;0*A  Sign for 8 coeffs
  movq        mm3, C14[esi+eax]           ;14A
   psraw      mm4, 15                     ;10C
  packsswb    mm1, mm2                    ;0*C  Quantized 8 coeffs
   movq       mm2, mm3                    ;14B
  psraw       mm2, 15                     ;14C
   pxor       mm5, mm4                    ;10D
  pxor        mm3, mm2                    ;14D
   psubsw     mm5, mm4                    ;10E
  psubsw      mm3, mm2                    ;14E
   psubusw    mm5, mm6                    ;10S
  pmulhw      mm5, mm7                    ;10F
   psubusw    mm3, mm6                    ;14S
  movq        C04[esi+eax], mm0           ;0*B  Save sign
   pmulhw     mm3, mm7                    ;14F
  movq        mm0, C20[esi+eax]           ;20A
   packsswb   mm4, mm2                    ;1*A
  movq        C00[esi+eax], mm1           ;0*D  Save quantized 8 coeffs
   movq       mm1, mm0                    ;20B
  movq        C14[esi+eax], mm4           ;1*B
   packsswb   mm5, mm3                    ;1*C
  movq        mm2, C24[esi+eax]           ;24A
   psraw      mm0, 15                     ;20C
  movq        C10[esi+eax], mm5           ;1*D
   movq       mm3, mm2                    ;24B
  add         eax,32
   jne        QuantCoeffs

  pcmpeqb   mm7,mm7
   mov      cl,  StashBlockType
  cmp       cl,  INTRA                  ;
   mov      cl, [edi]                   ; Get output line into cache.
  mov       cl, [edi+32]                ; Get output line into cache.
   jne      RunValSignINTER00

RunValSignINTRAC00:

  mov       ecx, ebx
   sub      esi, 128
  shl       ecx, 16
   mov      PB [edi], 0H                ; Run-length
  shr       ecx, 20                     ; 8-bit unsigned INTRA-DC value
   jnz      @f
  mov       cl, 1
@@:
  mov       [edi+1], cl                 ; DC
   xor      ecx, ecx
  mov       [edi+2], al                 ; sign of DC 
   xor      ebx, ebx
  mov       bl, [esi+Q01]
   mov      cl, Q01                     ; Index to Zigzag table.
  add       edi, 3
   jmp      QuantizeFirstACCoeff

RunValSignINTER00:
  
  xor       ecx, ecx                    ; Index to Zigzag table.
   xor      ebx, ebx
  mov       bl, [esi+Q00-128]
   sub      esi, 128

QuantizeFirstACCoeff:

  xor       al, al                      ; Zero run counter

QuantizeNextCoeff:

  mov       [edi+1], bl            ; Store quantized value.
   add      bl,255                 ; CF == 1 iff did not quantize to zero.
  sbb       bl,bl                  ; bl == 0xFF iff did not quant to zero.
   mov      ah, [esi+ecx+8]        ; Fetch sign.
  mov       [edi],al               ; Store zero run counter.
   or       al,bl                  ; Zero cnt == -1 iff did not quant to zero.
  inc       al                     ; Increment zero count.
   mov      cl,NextZigZagCoeff[ecx]
  and       bl,3                   ; bl == 3 iff did not quant to 0, else 0.
   mov      [edi+2],ah             ; Store sign.
  add       edi,ebx                ; Inc output ptr iff did not quant to zero.
   mov      bl,[esi+ecx]           ; Fetch next quantized coeff.
  test      cl,cl                  ; More coeffs to do?
   jne      QuantizeNextCoeff

QuantDone:

  mov       ebx,CodeStreamCursor
   mov      al,StashBlockType
  sub       ebx,edi
   je       ReturnBlockEmptyFlag

  mov       ah,[edi-3]
  cmp       ah,16
   jl       @f

  mov       ah,[edi-2]
  cmp       ah,1
   jne      @f

  sub       edi,3
   jmp      QuantDone

@@:

  add       ebx,3
   xor      al,INTRA
  or        al,bl
   je       ReturnBlockEmptyFlag

  mov       ebx,-1       ; Set to -1
  mov       [edi],bl
   add      edi,3

ReturnBlockEmptyFlag:

  mov       CodeStreamCursor, edi
   pcmpeqb  mm6,mm6
  inc       ebx                    ; 0 if block not empty;  1 if block empty.
   paddb    mm6,mm6
  ret

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ex5qrle.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\ex5qrle.asv   1.2   06 Feb 1996 09:12:10   KLILLEVO  $
;// $Log:   S:\h26x\src\enc\ex5qrle.asv  $
;// 
;//    Rev 1.2   06 Feb 1996 09:12:10   KLILLEVO
;// now quantizes INTER blocks as TMN5 specifies and simulator does
;// 
;//    Rev 1.1   27 Dec 1995 15:32:48   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

; QuantRLE -- This function performs quantization on a block of coefficients
;             and produces (run,level,sign) triples. (These triples are VLC by 
;             another routine.)  'run' is unsigned byte integer, 'level' is 
;             unsigned byte integer, and 'sign' is a signed byte integer with 
;             a value of either 0  or -1.
; Arguments:
;   CoeffStr: Starting Address of coefficient stream
;   CodeStr:  Starting address of code stream; i.e. starting address for code 
;             stream triples
; Returns:
; Dependencies:
;   The order of coefficient storage comes from e3dctc.inc file.  These coeff
;   appear as CxxCxx in this file.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510

.xlist
include locals.inc
include memmodel.inc
include e3dctc.inc
.list

; READ-ONLY TABLE
.CONST

; QP can range from 1 to 31; but we build the following table for QP from 0 to
; 31 so that we can use indexing without subtracting 1 from QP or subtracting
; 8 from the displacement term.  In each pair, the first value is "2^32/2*QP"
; or "2^31/QP".  For some QP values, e.g. QP = 3, "2^31/QP" is an infinite
; bit string.  We check the most significant bit of the bit string that we are
; throwing away, if it is 1 then we increment the value.  For eaxmple,
; 2^31/3 is 2AAAAAAA.AAAAAA... but we use 2AAAAAAB as the table value.

ALIGN 8                       ; so that each pair is in a cache line

RecipINTER2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTERSubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP - QP/2, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FBH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07F0H                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F6H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F4H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F1H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07EFH                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07ECH                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EAH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07E7H                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07E5H                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E2H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E0H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07DDH                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07DBH                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07D8H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07D6H                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07D3H                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07D1H                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07CEH                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07CCH                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07C9H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07C7H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07C4H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07C2H                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07BFH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07BDH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07BAH                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07B8H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07B5H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07B3H                 ; QP = 31
QuantINTERSubTerm = RecipINTER2QP + 4

RecipINTRA2QP LABEL DWORD
  DWORD 0H                    ; Recip2QP for QP = 0
  DWORD 0H                    ; QuantINTRASubTerm for QP = 0
  DWORD 080000000H            ; Recip2QP for QP = 1
  DWORD 07FEH                 ; 0800 - 2*QP, QP = 1
  DWORD 040000000H            ; QP = 2
  DWORD 07FCH                 ; QP = 2
  DWORD 02AAAAAABH            ; QP = 3
  DWORD 07FAH                 ; QP = 3
  DWORD 020000000H            ; QP = 4
  DWORD 07F8H                 ; QP = 4
  DWORD 01999999AH            ; QP = 5
  DWORD 07F6H                 ; QP = 5
  DWORD 015555556H            ; QP = 6 *****
  DWORD 07F4H                 ; QP = 6
  DWORD 012492493H            ; QP = 7 *****
  DWORD 07F2H                 ; QP = 7
  DWORD 010000000H            ; QP = 8
  DWORD 07F0H                 ; QP = 8
  DWORD 00E38E38FH            ; QP = 9 *****
  DWORD 07EEH                 ; QP = 9
  DWORD 00CCCCCCDH            ; QP = 10
  DWORD 07ECH                 ; QP = 10
  DWORD 00BA2E8BBH            ; QP = 11 *****
  DWORD 07EAH                 ; QP = 11
  DWORD 00AAAAAABH            ; QP = 12
  DWORD 07E8H                 ; QP = 12
  DWORD 009D89D8AH            ; QP = 13
  DWORD 07E6H                 ; QP = 13
  DWORD 00924924AH            ; QP = 14 *****
  DWORD 07E4H                 ; QP = 14
  DWORD 008888889H            ; QP = 15
  DWORD 07E2H                 ; QP = 15
  DWORD 008000000H            ; QP = 16
  DWORD 07E0H                 ; QP = 16
  DWORD 007878788H            ; QP = 17
  DWORD 07DEH                 ; QP = 17
  DWORD 0071C71C8H            ; QP = 18 *****
  DWORD 07DCH                 ; QP = 18
  DWORD 006BCA1B0H            ; QP = 19 *****
  DWORD 07DAH                 ; QP = 19
  DWORD 006666667H            ; QP = 20 *****
  DWORD 07D8H                 ; QP = 20
  DWORD 006186187H            ; QP = 21 *****
  DWORD 07D6H                 ; QP = 21
  DWORD 005D1745EH            ; QP = 22 *****
  DWORD 07D4H                 ; QP = 22
  DWORD 00590B217H            ; QP = 23 *****
  DWORD 07D2H                 ; QP = 23
  DWORD 005555556H            ; QP = 24 *****
  DWORD 07D0H                 ; QP = 24
  DWORD 0051EB852H            ; QP = 25
  DWORD 07CEH                 ; QP = 25
  DWORD 004EC4EC5H            ; QP = 26
  DWORD 07CCH                 ; QP = 26
  DWORD 004BDA130H            ; QP = 27 *****
  DWORD 07CAH                 ; QP = 27
  DWORD 004924925H            ; QP = 28
  DWORD 07C8H                 ; QP = 28
  DWORD 00469EE59H            ; QP = 29 *****
  DWORD 07C6H                 ; QP = 29
  DWORD 004444445H            ; QP = 30 *****
  DWORD 07C4H                 ; QP = 30
  DWORD 004210843H            ; QP = 31 *****
  DWORD 07C2H                 ; QP = 31
QuantINTRASubTerm = RecipINTRA2QP + 4

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

QUANTRLE  proc C ACoeffStr: DWORD, ACodeStr:DWORD, AQP:DWORD, AIntraFlag:DWORD

LocalFrameSize = 8
RegisterStorageSize = 16
SIGNHIGH = 1
SIGNLOW  = 17
IsINTRA  = 1
;;;;; Arguments:
ACoeffStr_arg = LocalFrameSize + RegisterStorageSize +  4
ACodeStr_arg  = LocalFrameSize + RegisterStorageSize +  8
AQP_arg       = LocalFrameSize + RegisterStorageSize + 12
AIntraFlag_arg= LocalFrameSize + RegisterStorageSize + 16
;;;;; Locals (on local stack frame)
QST	EQU 0
R2P	EQU 4

  push  esi
   push edi
  push  ebp
   push ebx
  sub   esp, LocalFrameSize

   mov cl,  63                       ; Initialize run-length (64 - 1)

  mov  ebx, PD [esp+AQP_arg]         ; copy parameters
   mov  esi, PD [esp+ACoeffStr_arg]  
  mov edx, RecipINTRA2QP[ebx*8]      ; RecipINTRA2QP = RecipINTER2QP
   mov edi, PD [esp+ACodeStr_arg]
  mov [esp + R2P], edx		     ; store Recip2QP[QP] as local variable
   mov al,  PB [esp+AIntraFlag_arg]
  mov  edx, PD [esi+C00C02]          ; First coeff
   test al,  IsINTRA
  je  QuantINTERC00

  
;
; OPTIMIZATIONS:
;   The usual code to compute absolute value has been enhanced to subtract the 
;   bias without using extra instructions or cycles.  Division is achieved by
;   multiplying with the reciprocal value.  High AC coefficients that will 
;   almost always be 0 are moved out-of-line towards the end of the routine.
;   This reduces the execution time if the conditional branch is not in the BTB;
;   it also reduces L1 footprint.
;   There is one more optimization I want to implement: pair instructions such
;   that the conditional branch instruction is executed in the U pipe.  The 
;   mispredicted branch penalty for U pipe is 3 and for V pipe is 4.  Since the 
;   low AC branches will frequently be mispredicted, this is a worthwhile 
;   optimization.
;
; esi -- base addr of coefficients; the order expected is the same as produced 
;        by Fast DCT
; edi -- RLE stream cursor
; ebx -- QP
; ecx -- run value indicator
; edx -- normally used to load coefficients
; eax,ebp -- scratch registers
;
QuantINTRAC00:
  mov edx, QuantINTRASubTerm[ebx*8] ; Fetch QuantSubTerm for INTRA
   mov  eax, PD [esi+C00C02]
  mov [esp + QST], edx		    ; Store QuantSubTerm as local variable
   mov PB [edi], 0H                 ; Run-length
  sar  eax, 23                      ; 8-bit signed INTRA-DC value
   mov edx, PD [esi+C01C03]         ; Pre-load next coefficient
  mov  PB [edi+2], ah               ; sign of DC 
   jnz @f
  mov  al, 1
@@:
  mov  PB [edi+1], al               ; DC
   add edi, 3
  mov  cl, 62                       ; 64 - Index (2 for C01)
   jmp QuantC01
QuantINTERC00:
  mov   eax, QuantINTERSubTerm[ebx*8]	; Fetch QuantSubTerm for INTER
   sal  edx, SIGNHIGH                   ; C == sign of the coefficient
  sbb  ebp, ebp                         ; -1 if coeff is negative else 0
   mov   [esp + QST], eax							; store QuantSubTerm as local variable
                                    
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C01C03]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC01
  lea   eax, [eax+2*ebx]
   mov  cl, 62                      ; Initialize run length counter
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], 0H                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C01C03]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   add  edi, 3                      ; Increment output pointer
QuantC01:
  sal   edx, SIGNHIGH               ; C == sign of the coefficient
   mov  eax, [esp + QST]    ; 0 for INTRA, QP for INTER
  sbb   ebp, ebp                    ; -1 if coeff is negative else 0
   ;                                ; 
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     ; magnitude
   mov  edx, PD [esi+C10C12]        ; Pre-load next coeff
  sub   eax, ebp
   jl   QuantC10
  lea   eax, [eax+2*ebx]
   sub  cl, 62                      ; compute run-length
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]        ; Refetch orig. constant to check for sign
   mov  PB [edi+1], dl              ; Write quantized coefficient
  shr   eax, 31
   mov  PB [edi], cl                ; Write run length
  sub   eax, 1                      ; -1 if negative coefficient
   mov  edx, PD [esi+C10C12]        ; Next coefficient
  mov   PB [edi+2], al              ; Write sign
   mov  cl, 61                      ; Initialize run length counter
  add   edi, 3                      ; Increment output pointer
   mov  eax, eax                    ; To keep pairing happy
QuantC10:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC20
  lea   eax, [eax+2*ebx]
   sub  cl, 61                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 60                     
  add   edi, 3
   mov  eax, eax
QuantC20:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC11
  lea   eax, [eax+2*ebx]
   sub  cl, 60                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C11C13]       
  mov   PB [edi+2], al
   mov  cl, 59                      ;
  add   edi, 3
   mov  eax, eax
QuantC11:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C00C02]       
  sub   eax, ebp
   jl   QuantC02
  lea   eax, [eax+2*ebx]
   sub  cl, 59                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C00C02]       
  mov   PB [edi+2], al
   mov  cl, 58                     
  add   edi, 3
   mov  eax, eax
QuantC02:
  sal   edx, SIGNLOW
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C01C03]       
  sub   eax, ebp
   jl   QuantC03
  lea   eax, [eax+2*ebx]
   sub  cl, 58                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C00C02]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 57
  mov   edx, PD [esi+C01C03]
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC03:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C10C12]       
  sub   eax, ebp
   jl   QuantC12
  lea   eax, [eax+2*ebx]
   sub  cl, 57                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C01C03]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 56                    
  mov   edx, PD [esi+C10C12]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC12:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC21
  lea   eax, [eax+2*ebx]
   sub  cl, 56                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C10C12]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 55                    
  mov   edx, PD [esi+C21C23]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC21:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC30
  lea   eax, [eax+2*ebx]
   sub  cl, 55                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C30C32]       
  mov   PB [edi+2], al
   mov  cl, 54                    
  add   edi, 3
   mov  eax, eax
QuantC30:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC40
  lea   eax, [eax+2*ebx]
   sub  cl, 54                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 53                    
  add   edi, 3
   mov  eax, eax
QuantC40:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC31
  lea   eax, [eax+2*ebx]
   sub  cl, 53                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C31C33]       
  mov   PB [edi+2], al
   mov  cl, 52                    
  add   edi, 3
   mov  eax, eax
QuantC31:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C20C22]       
  sub   eax, ebp
   jl   QuantC22
  lea   eax, [eax+2*ebx]
   sub  cl, 52                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C20C22]       
  mov   PB [edi+2], al
   mov  cl, 51                    
  add   edi, 3
   mov  eax, eax
QuantC22:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C11C13]       
  sub   eax, ebp
   jl   QuantC13
  lea   eax, [eax+2*ebx]
   sub  cl, 51                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C20C22]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 50                    
  mov   edx, PD [esi+C11C13]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC13:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC04
  lea   eax, [eax+2*ebx]
   sub  cl, 50                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C11C13]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 49                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC04:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC05
  lea   eax, [eax+2*ebx]
   sub  cl, 49                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C07C05]       
  mov   PB [edi+2], al
   mov  cl, 48                    
  add   edi, 3
   mov  eax, eax
QuantC05:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC14
  lea   eax, [eax+2*ebx]
   sub  cl, 48                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 47                    
  mov   edx, PD [esi+C14C16]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC14:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C21C23]       
  sub   eax, ebp
   jl   QuantC23
  lea   eax, [eax+2*ebx]
   sub  cl, 47                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C21C23]       
  mov   PB [edi+2], al
   mov  cl, 46                    
  add   edi, 3
   mov  eax, eax
QuantC23:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C30C32]       
  sub   eax, ebp
   jl   QuantC32
  lea   eax, [eax+2*ebx]
   sub  cl, 46                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C21C23]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 45                    
  mov   edx, PD [esi+C30C32]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC32:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC41
  lea   eax, [eax+2*ebx]
   sub  cl, 45                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C30C32]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 44                    
  mov   edx, PD [esi+C41C43]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC41:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC50
  lea   eax, [eax+2*ebx]
   sub  cl, 44                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C50C52]       
  mov   PB [edi+2], al
   mov  cl, 43                    
  add   edi, 3
   mov  eax, eax
QuantC50:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jl   QuantC60
  lea   eax, [eax+2*ebx]
   sub  cl, 43                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 42                    
  add   edi, 3 
   mov  eax, eax
QuantC60:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC51
  lea   eax, [eax+2*ebx]
   sub  cl, 42                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C51C53]       
  mov   PB [edi+2], al
   mov  cl, 41                    
  add   edi, 3 
   mov  eax, eax
QuantC51:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C40C42]       
  sub   eax, ebp
   jl   QuantC42
  lea   eax, [eax+2*ebx]
   sub  cl, 41                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C40C42]       
  mov   PB [edi+2], al
   mov  cl, 40                    
  add   edi, 3 
   mov  eax, eax
QuantC42:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C31C33]       
  sub   eax, ebp
   jl   QuantC33
  lea   eax, [eax+2*ebx]
   sub  cl, 40                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C40C42]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 39                    
  mov   edx, PD [esi+C31C33]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC33:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC24
  lea   eax, [eax+2*ebx]
   sub  cl, 39                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C31C33]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 38                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3
QuantC24:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC15
  lea   eax, [eax+2*ebx]
   sub  cl, 38                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C17C15]       
  mov   PB [edi+2], al
   mov  cl, 37                    
  add   edi, 3  
   mov  eax, eax
QuantC15:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C04C06]       
  sub   eax, ebp
   jl   QuantC06
  lea   eax, [eax+2*ebx]
   sub  cl, 37                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 36                    
  mov   edx, PD [esi+C04C06]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3  
QuantC06:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C07C05]       
  sub   eax, ebp
   jl   QuantC07
  lea   eax, [eax+2*ebx]
   sub  cl, 36                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C04C06]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 35                    
  mov   edx, PD [esi+C07C05]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3 
QuantC07:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C14C16]       
  sub   eax, ebp
   jl   QuantC16
  lea   eax, [eax+2*ebx]
   sub  cl, 35                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C07C05]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C14C16]       
  mov   PB [edi+2], al
   mov  cl, 34                    
  add   edi, 3             
   mov  eax, eax
QuantC16:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jl   QuantC25
  lea   eax, [eax+2*ebx]
   sub  cl, 34                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C14C16]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 33                    
  mov   edx, PD [esi+C27C25]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC25:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jl   QuantC34
  lea   eax, [eax+2*ebx]
   sub  cl, 33                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 32                    
  mov   edx, PD [esi+C34C36]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC34:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C41C43]       
  sub   eax, ebp
   jl   QuantC43
  lea   eax, [eax+2*ebx]
   sub  cl, 32                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C41C43]       
  mov   PB [edi+2], al
   mov  cl, 31                    
  add   edi, 3                    
   mov  eax, eax
QuantC43:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C50C52]       
  sub   eax, ebp
   jl   QuantC52
  lea   eax, [eax+2*ebx]
   sub  cl, 31                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C41C43]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 30                    
  mov   edx, PD [esi+C50C52]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC52:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jl   QuantC61
  lea   eax, [eax+2*ebx]
   sub  cl, 30                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C50C52]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov   cl, 29                    
  mov   edx, PD [esi+C61C63]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC61:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jge  QuantNZC61
QuantC70:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jge  QuantNZC70
QuantC71:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C60C62]       
  sub   eax, ebp
   jge  QuantNZC71
QuantC62:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C51C53]       
  sub   eax, ebp
   jl   QuantC53
  lea   eax, [eax+2*ebx]
   sub  cl, 26                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C60C62]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 25                    
  mov   edx, PD [esi+C51C53]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC53:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC44
  lea   eax, [eax+2*ebx]
   sub  cl, 25                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C51C53]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 24                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC44:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jge  QuantNZC44
QuantC35:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C24C26]       
  sub   eax, ebp
   jl   QuantC26
  lea   eax, [eax+2*ebx]
   sub  cl, 23                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 22                    
  mov   edx, PD [esi+C24C26]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC26:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C17C15]       
  sub   eax, ebp
   jl   QuantC17
  lea   eax, [eax+2*ebx]
   sub  cl, 22                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C24C26]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 21                    
  mov   edx, PD [esi+C17C15]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC17:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C27C25]       
  sub   eax, ebp
   jge  QuantNZC17
QuantC27:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C34C36]       
  sub   eax, ebp
   jge  QuantNZC27
QuantC36:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jl   QuantC45
  lea   eax, [eax+2*ebx]
   sub  cl, 19                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C34C36]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 18                    
  mov   edx, PD [esi+C47C45]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC45:
  sal   edx, SIGNLOW                      
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jl   QuantC54
  lea   eax, [eax+2*ebx]
   sub  cl, 18                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 17                    
  mov   edx, PD [esi+C54C56]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC54:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C61C63]       
  sub   eax, ebp
   jge  QuantNZC54
QuantC63:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C70C72]       
  sub   eax, ebp
   jl   QuantC72
  lea   eax, [eax+2*ebx]
   sub  cl, 16                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 15                    
  mov   edx, PD [esi+C70C72]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC72:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C71C73]       
  sub   eax, ebp
   jl   QuantC73
  lea   eax, [eax+2*ebx]
   sub  cl, 15                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 14                    
  mov   edx, PD [esi+C71C73]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC73:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC64
  lea   eax, [eax+2*ebx]
   sub  cl, 14                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 13                    
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC64:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jge  QuantNZC64
QuantC55:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C44C46]       
  sub   eax, ebp
   jl   QuantC46
  lea   eax, [eax+2*ebx]
   sub  cl, 12                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 11                    
  mov   edx, PD [esi+C44C46]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC46:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C37C35]       
  sub   eax, ebp
   jl   QuantC37
  lea   eax, [eax+2*ebx]
   sub  cl, 11                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 10                    
  mov   edx, PD [esi+C37C35]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC37:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C47C45]       
  sub   eax, ebp
   jge  QuantNZC37
QuantC47:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C54C56]       
  sub   eax, ebp
   jge  QuantNZC47
QuantC56:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jl   QuantC65
  lea   eax, [eax+2*ebx]
   sub  cl, 8                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 7                     
  mov   edx, PD [esi+C67C65]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC65:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jl   QuantC74
  lea   eax, [eax+2*ebx]
   sub  cl, 7                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 6                     
  mov   edx, PD [esi+C74C76]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC74:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jge  QuantNZC74
QuantC75:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C64C66]       
  sub   eax, ebp
   jl   QuantC66
  lea   eax, [eax+2*ebx]
   sub  cl, 5                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 4                     
  mov   edx, PD [esi+C64C66]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC66:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C57C55]       
  sub   eax, ebp
   jl   QuantC57
  lea   eax, [eax+2*ebx]
   sub  cl, 4                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 3                     
  mov   edx, PD [esi+C57C55]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC57:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C67C65]       
  sub   eax, ebp
   jge  QuantNZC57
QuantC67:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C74C76]       
  sub   eax, ebp
   jge  QuantNZC67
QuantC76:
  sal   edx, SIGNLOW                     
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, PD [esi+C77C75]       
  sub   eax, ebp
   jl   QuantC77
  lea   eax, [eax+2*ebx]
   sub  cl, 1                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shl   eax, 16
   mov  PB [edi], cl               
  shr   eax, 31
   mov  cl, 0                     
  mov   edx, PD [esi+C77C75]       
   sub  eax, 1
  mov   PB [edi+2], al
   add  edi, 3                    
QuantC77:
  sal   edx, SIGNHIGH               
   mov  eax, [esp + QST]    
  sbb   ebp, ebp                    
   ;
  add   eax, ebp
   xor  ebp, edx
  shr   ebp, 21                     
   mov  edx, edx                  
  sub   eax, ebp
   jge  QuantNZC77

; Quantization and RLE is done
QuantDone:
  mov   eax, edi                   ; Return value

  add   esp,LocalFrameSize
  pop   ebx
   pop  ebp
  pop   edi
   pop  esi
  rturn

QuantNZC61:
  lea   eax, [eax+2*ebx]
   sub  cl, 29                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C61C63]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C70C72]       
  mov   PB [edi+2], al
   mov  cl, 28                    
  add   edi, 3                    
   jmp  QuantC70
QuantNZC70:
  lea   eax, [eax+2*ebx]
   sub  cl, 28                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C70C72]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C71C73]       
  mov   PB [edi+2], al
   mov  cl, 27                    
  add   edi, 3                    
   jmp  QuantC71
QuantNZC71:
  lea   eax, [eax+2*ebx]
   sub  cl, 27                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C71C73]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C60C62]       
  mov   PB [edi+2], al
   mov  cl, 26                    
  add   edi, 3                    
   jmp  QuantC62
QuantNZC44:
  lea   eax, [eax+2*ebx]
   sub  cl, 24                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C44C46]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C37C35]       
  mov   PB [edi+2], al
   mov  cl, 23                    
  add   edi, 3                    
   jmp  QuantC35
QuantNZC17:
  lea   eax, [eax+2*ebx]
   sub  cl, 21                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C17C15]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C27C25]       
  mov   PB [edi+2], al
   mov  cl, 20                    
  add   edi, 3                    
   jmp  QuantC27
QuantNZC27:
  lea   eax, [eax+2*ebx]
   sub  cl, 20                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C27C25]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C34C36]       
  mov   PB [edi+2], al
   mov  cl, 19                    
  add   edi, 3                    
   jmp  QuantC36
QuantNZC54:
  lea   eax, [eax+2*ebx]
   sub  cl, 17                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C54C56]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C61C63]       
  mov   PB [edi+2], al
   mov  cl, 16                    
  add   edi, 3                    
   jmp  QuantC63
QuantNZC64:
  lea   eax, [eax+2*ebx]
   sub  cl, 13                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C64C66]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C57C55]       
  mov   PB [edi+2], al
   mov  cl, 12                    
  add   edi, 3                    
   jmp  QuantC55
QuantNZC37:
  lea   eax, [eax+2*ebx]
   sub  cl, 10                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C37C35]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C47C45]       
  mov   PB [edi+2], al
   mov  cl, 9                     
  add   edi, 3                    
   jmp  QuantC47
QuantNZC47:
  lea   eax, [eax+2*ebx]
   sub  cl, 9                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C47C45]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C54C56]       
  mov   PB [edi+2], al
   mov  cl, 8                     
  add   edi, 3                    
   jmp  QuantC56
QuantNZC74:
  lea   eax, [eax+2*ebx]
   sub  cl, 6                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C74C76]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C77C75]       
  mov   PB [edi+2], al
   mov  cl, 5                     
  add   edi, 3                    
   jmp  QuantC75
QuantNZC57:
  lea   eax, [eax+2*ebx]
   sub  cl, 3                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C57C55]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C67C65]       
  mov   PB [edi+2], al
   mov  cl, 2                     
  add   edi, 3                    
   jmp  QuantC67
QuantNZC67:
  lea   eax, [eax+2*ebx]
   sub  cl, 2                      
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C67C65]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, PD [esi+C74C76]       
  mov   PB [edi+2], al
   mov  cl, 1                     
  add   edi, 3                    
   jmp  QuantC76
QuantNZC77:
  lea   eax, [eax+2*ebx]
   sub  cl, 0                     
  mul   PD [esp + R2P]
   ;
  mov   eax, PD [esi+C77C75]       
   mov  PB [edi+1], dl             
  shr   eax, 31
   mov  PB [edi], cl               
  sub   eax, 1
   mov  edx, edx                  
  mov   PB [edi+2], al  
  add   edi, 3                    
   jmp  QuantDone

QUANTRLE endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\locals.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\locals.inv   1.1   27 Dec 1995 14:36:24   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\locals.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:24   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

include memmodel.inc
IFDEF WIN32
LDal    macro   address
        mov     al,BYTE PTR address[esp]
        endm

LDbl    macro   address
        mov     bl,BYTE PTR address[esp]
        endm

LDcl    macro   address
        mov     cl,BYTE PTR address[esp]
        endm

LDdl    macro   address
        mov     dl,BYTE PTR address[esp]
        endm

LDah    macro   address
        mov     ah,BYTE PTR address[esp]
        endm

LDbh    macro   address
        mov     bh,BYTE PTR address[esp]
        endm

LDch    macro   address
        mov     ch,BYTE PTR address[esp]
        endm

LDdh    macro   address
        mov     dh,BYTE PTR address[esp]
        endm

Leax    macro   address
        mov     eax,DWORD PTR address[esp]
        endm

Lebx    macro   address
        mov     ebx,DWORD PTR address[esp]
        endm

Lecx    macro   address
        mov     ecx,DWORD PTR address[esp]
        endm

Ledx    macro   address
        mov     edx,DWORD PTR address[esp]
        endm

Lesi    macro   address
        mov     esi,DWORD PTR address[esp]
        endm

Ledi    macro   address
        mov     edi,DWORD PTR address[esp]
        endm

Lebp    macro   address
        mov     ebp,DWORD PTR address[esp]
        endm

LZeax   macro   address
        movzx   eax,BYTE PTR address[esp]
        endm

LZebx   macro   address
        movzx   ebx,BYTE PTR address[esp]
        endm

LZecx   macro   address
        movzx   ecx,BYTE PTR address[esp]
        endm

LZedx   macro   address
        movzx   edx,BYTE PTR address[esp]
        endm

LZesi   macro   address
        movzx   esi,BYTE PTR address[esp]
        endm

LZedi   macro   address
        movzx   edi,BYTE PTR address[esp]
        endm

LZebp   macro   address
        movzx   ebp,BYTE PTR address[esp]
        endm

STal    macro   address
        mov     BYTE PTR address[esp],al
        endm

STbl    macro   address
        mov     BYTE PTR address[esp],bl
        endm

STcl    macro   address
        mov     BYTE PTR address[esp],cl
        endm

STdl    macro   address
        mov     BYTE PTR address[esp],dl
        endm

STah    macro   address
        mov     BYTE PTR address[esp],ah
        endm

STbh    macro   address
        mov     BYTE PTR address[esp],bh
        endm

STch    macro   address
        mov     BYTE PTR address[esp],ch
        endm

STdh    macro   address
        mov     BYTE PTR address[esp],dh
        endm

Seax    macro   address
        mov     DWORD PTR address[esp],eax
        endm

Sebx    macro   address
        mov     DWORD PTR address[esp],ebx
        endm

Secx    macro   address
        mov     DWORD PTR address[esp],ecx
        endm

Sedx    macro   address
        mov     DWORD PTR address[esp],edx
        endm

Sesi    macro   address
        mov     DWORD PTR address[esp],esi
        endm

Sedi    macro   address
        mov     DWORD PTR address[esp],edi
        endm

Sebp    macro   address
        mov     DWORD PTR address[esp],ebp
        endm

ADDeax  macro   address
        add     eax,DWORD PTR address[esp]
        endm

ADDebx  macro   address
        add     ebx,DWORD PTR address[esp]
        endm

ADDecx  macro   address
        add     ecx,DWORD PTR address[esp]
        endm

ADDedx  macro   address
        add     edx,DWORD PTR address[esp]
        endm

ADDesi  macro   address
        add     esi,DWORD PTR address[esp]
        endm

ADDedi  macro   address
        add     edi,DWORD PTR address[esp]
        endm

ADDebp  macro   address
        add     ebp,DWORD PTR address[esp]
        endm

SUBeax  macro   address
        sub     eax,DWORD PTR address[esp]
        endm

SUBebx  macro   address
        sub     ebx,DWORD PTR address[esp]
        endm

SUBecx  macro   address
        sub     ecx,DWORD PTR address[esp]
        endm

SUBedx  macro   address
        sub     edx,DWORD PTR address[esp]
        endm

SUBesi  macro   address
        sub     esi,DWORD PTR address[esp]
        endm

SUBedi  macro   address
        sub     edi,DWORD PTR address[esp]
        endm

SUBebp  macro   address
        sub     ebp,DWORD PTR address[esp]
        endm

CMPeax  macro   address
        cmp     eax,DWORD PTR address[esp]
        endm

CMPebx  macro   address
        cmp     ebx,DWORD PTR address[esp]
        endm

CMPecx  macro   address
        cmp     ecx,DWORD PTR address[esp]
        endm

CMPedx  macro   address
        cmp     edx,DWORD PTR address[esp]
        endm

CMPesi  macro   address
        cmp     esi,DWORD PTR address[esp]
        endm

CMPedi  macro   address
        cmp     edi,DWORD PTR address[esp]
        endm

CMPebp  macro   address
        cmp     ebp,DWORD PTR address[esp]
        endm

ADDC2M  macro   address,constant
        add     DWORD PTR address[esp],constant
        endm

ELSE
LDal    macro   address
        DB      0A0H            ; opcode: move memory to accumulator (al)
        DD      address         ; source
        endm

LDbl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      01DH            ; destination: bl
        DD      address         ; source
        endm

LDcl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      00DH            ; destination: cl
        DD      address         ; source
        endm

LDdl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      015H            ; destination: dl
        DD      address         ; source
        endm

LDah    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      025H            ; destination: ah
        DD      address         ; source
        endm

LDbh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      03DH            ; destination: bh
        DD      address         ; source
        endm

LDch    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      02DH            ; destination: ch
        DD      address         ; source
        endm

LDdh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      035H            ; destination: dh
        DD      address         ; source
        endm

Leax    macro   address
        DB      0A1H            ; opcode: move memory to accumulator (eax)
        DD      address         ; source
        endm

Lebx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

Lecx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

Ledx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

Lesi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

Ledi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

Lebp    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

LZeax   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

LZebx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

LZecx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

LZedx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

LZesi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

LZedi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

LZebp   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

STal    macro   address
        DB      0A2H            ; opcode: move accumulator (al) to memory
        DD      address         ; destination
        endm

STbl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      01DH            ; source: bl
        DD      address         ; destination
        endm

STcl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      00DH            ; source: cl
        DD      address         ; destination
        endm

STdl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      015H            ; source: dl
        DD      address         ; destination
        endm

STah    macro   address
        DB      088H            ; opcode: move register to memory
        DB      025H            ; source: ah
        DD      address         ; destination
        endm

STbh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      03DH            ; source: bh
        DD      address         ; destination
        endm

STch    macro   address
        DB      088H            ; opcode: move register to memory
        DB      02DH            ; source: ch
        DD      address         ; destination
        endm

STdh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      035H            ; source: dh
        DD      address         ; destination
        endm

Seax    macro   address
        DB      0A3H            ; opcode: move accumulator (eax) to memory
        DD      address         ; destination
        endm

Sebx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      01DH            ; source: ebx
        DD      address         ; destination
        endm

Secx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      00DH            ; source: ecx
        DD      address         ; destination
        endm

Sedx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      015H            ; source: edx
        DD      address         ; destination
        endm

Sesi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      035H            ; source: esi
        DD      address         ; destination
        endm

Sedi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      03DH            ; source: edi
        DD      address         ; destination
        endm

Sebp    macro   address
        DB      089H            ; opcode: move register to memory
        DB      02DH            ; source: ebp
        DD      address         ; destination
        endm

ADDeax  macro   address
        DB      003H            ; opcode: add memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

ADDebx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

ADDecx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

ADDedx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

ADDesi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

ADDedi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

ADDebp  macro   address
        DB      003H            ; opcode: add memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

SUBeax  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      005H            ; source: eax
        DD      address         ; destination
        endm

SUBebx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

SUBecx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

SUBedx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

SUBesi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

SUBedi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

SUBebp  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

CMPeax  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      005H            ; source: eax
        DD      address         ; source
        endm

CMPebx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      01DH            ; source: ebx
        DD      address         ; source
        endm

CMPecx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      00DH            ; source: ecx
        DD      address         ; source
        endm

CMPedx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      015H            ; source: edx
        DD      address         ; source
        endm

CMPesi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      035H            ; source: esi
        DD      address         ; source
        endm

CMPedi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      03DH            ; source: edi
        DD      address         ; source
        endm

CMPebp  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      02DH            ; source: ebp
        DD      address         ; source
        endm

ADDC2M  macro   address,constant
        add     ds:DWORD PTR address,constant
        endm

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\intel\h263\i386\exmme.asm ===
;////////////////////////////////////////////////////////////////////////////
;//
;//              INTEL CORPORATION PROPRIETARY INFORMATION
;//
;//      This software is supplied under the terms of a license
;//      agreement or nondisclosure agreement with Intel Corporation
;//      and may not be copied or disclosed except in accordance
;//      with the terms of that agreement.
;//
;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\enc\exmme.asv   1.37   13 Dec 1996 17:19:38   MBODART  $
;//
;// $Log:   S:\h26x\src\enc\exmme.asv  $
;// 
;//    Rev 1.37   13 Dec 1996 17:19:38   MBODART
;// Tuned the ME parameters for H.261.
;// 
;//    Rev 1.36   06 Nov 1996 16:18:24   BNICKERS
;// Improve performance.
;// 
;//    Rev 1.35   30 Oct 1996 17:30:36   BNICKERS
;// Fix UMV table for right edge macroblocks.
;// 
;//    Rev 1.34   30 Oct 1996 14:49:20   KLILLEVO
;// zero motion vectors for intra blocks in PB-frame mode.
;// This is necesseary in the Extended Motion Vector mode
;// 
;//    Rev 1.33   18 Oct 1996 16:57:16   BNICKERS
;// Fixes for EMV
;// 
;//    Rev 1.32   15 Oct 1996 17:53:04   BNICKERS
;// 
;// Fix major bug w.r.t. EMV ME.
;// 
;//    Rev 1.31   14 Oct 1996 13:10:14   BNICKERS
;// 
;// Correct several problems wrt H261 ME.
;// 
;//    Rev 1.30   11 Oct 1996 16:53:12   KLILLEVO
;// 
;// Fix threshold
;// 
;//    Rev 1.29   11 Oct 1996 16:52:18   KLILLEVO
;// Another EMV fix.
;// 
;//    Rev 1.28   11 Oct 1996 15:43:16   KLILLEVO
;// Really fix the handling of the top row of MBs for EMV ME.
;// 
;//    Rev 1.27   11 Oct 1996 15:24:38   BNICKERS
;// Special handling of top row of MBs for EMV ME.
;// 
;//    Rev 1.26   11 Oct 1996 14:47:42   KLILLEVO
;// Kill full pel MV for Intra blocks so that EMV of adjacent blocks will work.
;// 
;//    Rev 1.25   10 Oct 1996 16:42:56   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.24   04 Oct 1996 08:48:02   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.23   24 Sep 1996 10:42:24   BNICKERS
;// For H261, zero out motion vectors when classifying MB as intra.
;// 
;//    Rev 1.22   12 Sep 1996 10:56:24   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.21   22 Jul 1996 15:23:24   BNICKERS
;// Reduce code size.  Implement H261 spatial filter.
;// 
;//    Rev 1.20   18 Jul 1996 16:54:26   KLILLEVO
;// changed emptythreshold to 40 instead of 128 to remove some blockiness
;// from the still frame mode on MMX
;// 
;//    Rev 1.19   26 Jun 1996 12:49:02   KLILLEVO
;// Fix minor booboo left in by Brian.
;// 
;//    Rev 1.18   26 Jun 1996 12:21:50   BNICKERS
;// Make heuristic ME work without unrestricted motion vectors.
;// 
;//    Rev 1.17   25 Jun 1996 14:24:58   BNICKERS
;// Implement heuristic motion estimation for MMX, AP mode.
;// 
;//    Rev 1.16   15 May 1996 16:57:14   BNICKERS
;// Fix SWD tabulation (again)! @#$%!%
;// 
;//    Rev 1.15   15 May 1996 16:53:24   BNICKERS
;// 
;// Fix SWD tabulation.
;// 
;//    Rev 1.14   15 May 1996 11:33:28   BNICKERS
;// Bug fix for calc of total SWD.
;// 
;//    Rev 1.13   14 May 1996 12:18:58   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.12   03 May 1996 14:03:50   BNICKERS
;// 
;// Minor bug fixes and integration refinements.
;// 
;//    Rev 1.11   02 May 1996 12:00:32   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.10   16 Apr 1996 16:40:14   BNICKERS
;// Fix some important but simple bugs.  Start adding table inits for B frm ME.
;// 
;//    Rev 1.9   10 Apr 1996 13:13:44   BNICKERS
;// Recoding of Motion Estimation, Advanced Prediction.
;// 
;//    Rev 1.8   05 Apr 1996 12:28:10   BNICKERS
;// Improvements to baseline half pel ME.
;// 
;//    Rev 1.7   26 Mar 1996 12:00:22   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.6   20 Mar 1996 17:01:44   KLILLEVO
;// fixed bug in new quant code
;// 
;//    Rev 1.5   20 Mar 1996 15:26:40   KLILLEVO
;// changed quantization to match IA quantization
;// 
;//    Rev 1.3   15 Mar 1996 15:51:16   BECHOLS
;// Completed monolithic - Brian
;// 
;//    Rev 1.0   16 Feb 1996 17:12:12   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; MMxMotionEstimation -- This function performs motion estimation for the
;                        macroblocks identified in the input list.  This is
;                        the MMx version.  Conditional assembly selects either
;                        the H263 or H261 version.
;
; Arguments:   See ex5me.asm.
;
; Other assumptions:  See ex5me.asm.  Most of the read-only tables needed in
;                     ex5me.asm are not needed here.
;

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro
OPTION M510
OPTION CASEMAP:NONE

IFDEF H261
ZEROVECTORTHRESHOLD          =  600
NONZEROMVDIFFERENTIAL        =  256
BLOCKMOTIONTHRESHOLD         = 1152
BLOCKMVDIFFERENTIAL          =  768
EMPTYTHRESHOLD               =   40
INTERCODINGTHRESHOLD         =  300
INTRACODINGDIFFERENTIAL      =  200
ELSE
ZEROVECTORTHRESHOLD          =  450
NONZEROMVDIFFERENTIAL        =  375
BLOCKMOTIONTHRESHOLD         = 1152
BLOCKMVDIFFERENTIAL          =  768
EMPTYTHRESHOLD               =   40
INTERCODINGTHRESHOLD         = 1152
INTRACODINGDIFFERENTIAL      = 1000
ENDIF

include iammx.inc
include e3inst.inc
include e3mbad.inc

.xlist
include memmodel.inc
.list

include exEDTQ.inc

MMXMEDATA SEGMENT PAGE
ALIGN 16

;  Storage for Target and Reference frames can interleave into 8K of the 16K
;  cache.  Pitch must be 384.
;
;     C# -- Stands for row number "#" of target macroblock in *C*urrent P frame.
;     B# -- Stands for row number "#" of target macroblock in current *B* frame.
;     R# -- Stands for row number "#" of 0MV *R*ef macroblock in past frame.
;     v  -- Stands for a row below 0MV, reference macroblock.
;           These same cache lines would hit reference lines >8 above the 0MV.
;     ^  -- Stands for a row below 0MV, reference macroblock.
;           These same cache lines would hit reference lines >8 below the 0MV.
;     +-+-+
;     |   | -- A cache line (32 bytes).  Position of letters,<, and > indicate
;     +-+-+    which 16 bytes may be used in the cache line.
;
;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
;     |C0 |   |  v|   |Cb |   |  ^|   |B6 |   | R6|   |
;     |C1 |   |  v|   |Cc |   |  ^|   |B7 |   | R7|   |
;     |C2 |   |  v|   |Cd |   |  ^|   |B8 |   | R8|   |
;     |C3 |   |  v|   |Ce |   |  ^|   |B9 |   | R9|   |
;     |C4 |   |  v|   |Cf |   |  ^|   |Ba |   | Ra|   |
;     |C5 |   |  v|   |B0 |   | R0|   |Bb |   | Rb|   |
;     |C6 |   |  v|   |B1 |   | R1|   |Bc |   | Rc|   |
;     |C7 |   |  v|   |B2 |   | R2|   |Bd |   | Rd|   |
;     |C8 |   |  ^|   |B3 |   | R3|   |Be |   | Re|   |
;     |C9 |   |  ^|   |B4 |   | R4|   |Bf |   | Rf|   |
;     |Ca |   |  ^|   |B5 |   | R5|   +-+-+-+-+-+-+-+-+
;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
;

; The static storage space used for read-only tables, and the stack usage
; are coordinated such that they mesh in the data cache, and use only one
; 4K way of the 4-way, 16K cache.
;
; The first 32 bytes of the static storage space are unallocated, because
; the top of stack ranges in this area.  As local procedure calls are made
; within this function, return addresses get pushed into these 32 bytes.
; (32 bytes;    0:  31)

  DB 32 DUP (?)   ; Static space place-holder.  Stack frame hits these addrs.

;
; The next 608 bytes of the static storage space are unallocated, because
; the local stack frame is made to hit cache at these addresses.  More of
; the local stack frame is allocated after a gap of 64 bytes.
; (608 bytes;   32: 639)

LocalStorage LABEL DWORD 

  DB 608 DUP (?)   ; Static space place-holder.  Stack frame hits these addrs.

; Motion Estimation State Engine adjustments to reference block address to get
; to next candidate reference block.
; (64 bytes; 640: 703)

FullPelMotionVectorAdjustment LABEL DWORD

        DD   -16*PITCH-8
VMG     EQU  000H+0+8
VMGHM8  EQU  000H-8+8

        DD   -8*PITCH-8-010H
VM8HM8  EQU  010H

        DD   -8*PITCH-020H
VM8     EQU  020H
VM8HP8  EQU  020H+8

        DD   -4*PITCH-8-030H
VM4HM8  EQU  030H-8+8
VM4HM4  EQU  030H-4+8
VM4     EQU  030H+0+8
VM4HP4  EQU  030H+4+8

        DD   -4*PITCH+8-040H
VM4HP8  EQU  040H+8-8
VM4HPG  EQU  040H+16-8

        DD   -2*PITCH-4-050H
VM2HM4  EQU  050H-4+4
VM2HM2  EQU  050H-2+4
VM2HM1  EQU  050H-1+4
VM2     EQU  050H+0+4
VM2HP1  EQU  050H+1+4
VM2HP2  EQU  050H+2+4
VM2HP4  EQU  050H+4+4
VM2HP8  EQU  050H+8+4

        DD   -1*PITCH-2-060H
VM1HM2  EQU  060H-2+2
VM1HM1  EQU  060H-1+2
VM1     EQU  060H+0+2
VM1HP1  EQU  060H+1+2
VM1HP2  EQU  060H+2+2
VM1HP4  EQU  060H+4+2

        DD   -16-070H
HMG     EQU  070H-16+16
HM8     EQU  070H-8+16
HM4     EQU  070H-4+16
HM3     EQU  070H-3+16
HM2     EQU  070H-2+16
HM1     EQU  070H-1+16

        DD   -080H
NOADJ   EQU  080H
HP1     EQU  080H+1
HP2     EQU  080H+2
HP4     EQU  080H+4
HP8     EQU  080H+8

        DD   1*PITCH-2-090H
VP1HM2  EQU  090H-2+2
VP1HM1  EQU  090H-1+2
VP1     EQU  090H+0+2
VP1HP1  EQU  090H+1+2
VP1HP2  EQU  090H+2+2
VP1HP4  EQU  090H+4+2

        DD   2*PITCH-4-0A0H
VP2HM4  EQU  0A0H-4+4
VP2HM2  EQU  0A0H-2+4
VP2HM1  EQU  0A0H-1+4
VP2     EQU  0A0H+0+4
VP2HP1  EQU  0A0H+1+4
VP2HP2  EQU  0A0H+2+4
VP2HP4  EQU  0A0H+4+4
VP2HP8  EQU  0A0H+8+4

        DD   4*PITCH-8-0B0H
VP4HM8  EQU  0B0H-8+8
VP4HM4  EQU  0B0H-4+8
VP4HM2  EQU  0B0H-2+8
VP4     EQU  0B0H+0+8
VP4HP2  EQU  0B0H+2+8
VP4HP4  EQU  0B0H+4+8

        DD   4*PITCH+8-0C0H
VP4HP8  EQU  0C0H+8-8
VP4HPG  EQU  0C0H+16-8

        DD   8*PITCH-8-0D0H
VP8HM8  EQU  0D0H-8+8
VP8HM4  EQU  0D0H-4+8

        DD   8*PITCH-0E0H
VP8     EQU  0E0H+0
VP8HP4  EQU  0E0H+4
VP8HP8  EQU  0E0H+8

        DD   16*PITCH-0F0H
VPG     EQU  0F0H+0
VPGHP8  EQU  0F0H+8

; Additional space reserved for stack variables.  If more space is needed,
; it should go here.
; (160 bytes; 704: 863)

  DB 160 DUP (?)   ; Static space place-holder.  Stack frame hits these addrs.

; QWORD Constants used by motion estimation, frame differencing, and FDCT.
; (144 bytes;   864:1007)

C0101010101010101 DD 001010101H, 001010101H
CFFFF0000FFFF0000 DD 0FFFF0000H, 0FFFF0000H
C0200010101010101 DD 001010101H, 002000101H
C0001000200020001 DD 000020001H, 000010002H
CFFFF00000000FFFF DD 00000FFFFH, 0FFFF0000H
C0000FFFFFFFF0000 DD 0FFFF0000H, 00000FFFFH
CFF000000000000FF DD 0000000FFH, 0FF000000H
C0101010101010002 DD 001010002H, 001010101H
C0100010001000100 DD 001000100H, 001000100H
C0001000100010001 DD 000010001H, 000010001H
C7F7F7F7F7F7F7F7F DD 07F7F7F7FH, 07F7F7F7FH
C1                DD 07D8A7D8AH, 07D8A7D8AH
C2                DD 076417641H, 076417641H
C3                DD 06A6D6A6DH, 06A6D6A6DH
C4                DD 05A825A82H, 05A825A82H
C5                DD 0471D471DH, 0471D471DH
C6                DD 030FC30FCH, 030FC30FCH
C7                DD 018F818F8H, 018F818F8H

; Distances to Block Action Descriptors for blocks that provide remote vectors
; for OBMC.  Which element accessed depends on edge condition.  Top edge is
; stack based variable, since different instances may have different distances
; to BAD of block above.  Bottom edge is always a constant, regardless of
; edge condition.  This is used in OBMC frame differencing.
; (16 bytes; 1008:1023)

BlockToLeft  DD 0, -SIZEOF T_MacroBlockActionDescr+SIZEOF T_Blk
BlockToRight DD 0,  SIZEOF T_MacroBlockActionDescr-SIZEOF T_Blk

; Table to map linearized motion vector to vertical part, used by motion
; estimation.  (Shift linearized motion vector right by 8 bits, and then
; use result as index into this array to get vertical MV.)
; (96 bytes; 1024:1119)

IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
   DB -64, -64
   DB -62
   DB -60, -60
   DB -58
   DB -56, -56
   DB -54
   DB -52, -52
   DB -50
   DB -48, -48
   DB -46
   DB -44, -44
   DB -42
   DB -40, -40
   DB -38
   DB -36, -36
   DB -34
   DB -32, -32
   DB -30
   DB -28, -28
   DB -26
   DB -24, -24
   DB -22
   DB -20, -20
   DB -18
   DB -16, -16
   DB -14
   DB -12, -12
   DB -10
   DB  -8,  -8
   DB  -6
   DB  -4,  -4
   DB  -2
   DB   0
UnlinearizedVertMV  DB 0
   DB   2
   DB   4,   4
   DB   6
   DB   8,   8
   DB  10
   DB  12,  12
   DB  14
   DB  16,  16
   DB  18
   DB  20,  20
   DB  22
   DB  24,  24
   DB  26
   DB  28,  28
   DB  30
   DB  32,  32
   DB  34
   DB  36,  36
   DB  38
   DB  40,  40
   DB  42
   DB  44,  44
   DB  46
   DB  48,  48
   DB  50
   DB  52,  52
   DB  54
   DB  56,  56
   DB  58
   DB  60,  60
   DB  62
; Table to provide index value in low byte, and rounding term of 1 in all bytes.
; Used in frame differencing, when half pel horizontal interpolation is needed.
; (1024 bytes; 1120:2143)

Pel_Rnd LABEL DWORD
CNT = 0
REPEAT 128
 DD CNT+001010101H, 001010101H
 CNT = CNT + 1
ENDM

; Motion Estimation State Engine Rules.
; (896 bytes;2144:3039)

StateEngineFirstRule LABEL BYTE ; Rules that govern state engine of estimator.
StateEngine EQU StateEngineFirstRule-20+2

   ; Starting States:

IF PITCH-384
*** error:  The magic of this table assumes a pitch of 384.
ENDIF
 DB       ?      ;  0:  not used.
 DB       3      ;  1: Upper left corner.
 DB       3      ;  2: Upper edge.
 DB       3      ;  3: Upper right corner.
 DB       3      ;  4: Left edge.
 DB       3      ;  5: Interior MB, not doing block search.
 DB       0      ;  6: Right edge.
 DB       0      ;  7: Lower left corner.
 DB       0      ;  8: Lower edge.
 DB       0      ;  9: Lower right corner.

 DB       ?      ;  0:  not used.
 DB      34      ;  1: Upper left corner.
 DB      66      ;  2: Upper edge.
 DB      42      ;  3: Upper right corner.
 DB      98      ;  4: Left edge.
 DB      16      ;  5: Interior MB, not doing block search.
 DB     114      ;  6: Right edge.
 DB      50      ;  7: Lower left corner.
 DB      82      ;  8: Lower edge.
 DB      58      ;  9: Lower right corner.

 DB     ?,?      ; Skip 2 bytes.

LASTINITIALMESTATE EQU 9

   ; Interior Telescoping States:

      ;  Try +/- 8,4,2,1, vertically first, then horizontally.

FIRSTBLOCKMESTATE EQU 10

 DB     VM2,    VM2,   12,   11  ;  10: V+1 better/worse than central.  Try V-1.
 DB  VP2HP1,    HP1,   13,   13  ;  11: Accept V+1/V-1 as best.         Try H+1.
 DB  VP1HP1,    HP1,   13,   13  ;  12: Accept central/V-1 as best.     Try H+1.
 DB     HM2,    HM2,   15,   14  ;  13: H+1 better/worse than central.  Try H-1.
 DB     HP2,  NOADJ, 0FFH, 0FFH  ;  14: Accept H+1/H-1 as best.         Done.
 DB     HP1,  NOADJ, 0FFH, 0FFH  ;  15: Accept central/H-1 as best.     Done.

 DB     VMG,    VMG,   18,   17  ;  16: V+8 better/worse than central.  Try V-8.
 DB  VPGHP8,    HP8,   19,   19  ;  17: Accept V+8/V-8 as best.         Try H+8.
 DB  VP8HP8,    HP8,   19,   19  ;  18: Accept central/V-8 as best.     Try H+8.
 DB     HMG,    HMG,   21,   20  ;  19: H+8 better/worse than central.  Try H-8.
 DB  VP4HPG,    VP4,   22,   22  ;  20: Accept H+8/H-8 as best.         Try V+4.
 DB  VP4HP8,    VP4,   22,   22  ;  21: Accept central/H-8 as best.     Try V+4.

 DB     VM8,    VM8,   24,   23  ;  22: V+4 better/worse than central.  Try V-4.
 DB  VP8HP4,    HP4,   25,   25  ;  23: Accept V+4/V-4 as best.         Try H+4.
 DB  VP4HP4,    HP4,   25,   25  ;  24: Accept central/V-4 as best.     Try H+4.
 DB     HM8,    HM8,   27,   26  ;  25: H+4 better/worse than central.  Try H-4.
 DB  VP2HP8,    VP2,   28,   28  ;  26: Accept H+4/H-4 as best.         Try V+2.
 DB  VP2HP4,    VP2,   28,   28  ;  27: Accept central/H-4 as best.     Try V+2.

 DB     VM4,    VM4,   30,   29  ;  28: V+2 better/worse than central.  Try V-2.
 DB  VP4HP2,    HP2,   31,   31  ;  29: Accept V+2/V-2 as best.         Try H+2.
 DB  VP2HP2,    HP2,   31,   31  ;  30: Accept central/V-2 as best.     Try H+2.
 DB     HM4,    HM4,   33,   32  ;  31: H+2 better/worse than central.  Try H-2.
 DB  VP1HP4,    VP1,   10,   10  ;  32: Accept H+2/H-2 as best.         Try V+1.
 DB  VP1HP2,    VP1,   10,   10  ;  33: Accept central/H-2 as best.     Try V+1.

   ; Boundary States:

     ; Upper left corner:

 DB  VM8HP8,    HP8,   35,  101  ;  34: Accept corner/V+8.              Try H+8.
 DB  VP4HM8,    VP4,   36,   70  ;  35: Accept corner/H+8.              Try V+4.
 DB  VM4HP4,    HP4,   37,  105  ;  36: Accept corner/V+4.              Try H+4.
 DB  VP2HM4,    VP2,   38,   74  ;  37: Accept corner/H+4.              Try V+2.
 DB  VM2HP2,    HP2,   39,  109  ;  38: Accept corner/V+2.              Try H+2.
 DB  VP1HM2,    VP1,   40,   78  ;  39: Accept corner/H+2.              Try V+1.
 DB  VM1HP1,    HP1,   41,  113  ;  40: Accept corner/V+1.              Try H+1.
 DB     HM1,  NOADJ, 0F5H, 0F7H  ;  41: Accept corner/H+1.              Done.

     ; Upper right corner:

 DB  VM8HM8,    HM8,   43,  117  ;  42: Accept corner/V+8.              Try H-8.
 DB  VP4HP8,    VP4,   44,   70  ;  43: Accept corner/H-8.              Try V+4.
 DB  VM4HM4,    HM4,   45,  121  ;  44: Accept corner/V+4.              Try H-4.
 DB  VP2HP4,    VP2,   46,   74  ;  45: Accept corner/H-4.              Try V+2.
 DB  VM2HM2,    HM2,   47,  125  ;  46: Accept corner/V+2.              Try H-2.
 DB  VP1HP2,    VP1,   48,   78  ;  47: Accept corner/H-2.              Try V+1.
 DB  VM1HM1,    HM1,   49,  129  ;  48: Accept corner/V+1.              Try H-1.
 DB     HP1,  NOADJ, 0F6H, 0F7H  ;  49: Accept corner/H-1.              Done

     ; Lower left corner:

 DB  VP8HP8,    HP8,   51,  101  ;  50: Accept corner/V-8.              Try H+8.
 DB  VM4HM8,    VM4,   52,   86  ;  51: Accept corner/H+8.              Try V-4.
 DB  VP4HP4,    HP4,   53,  105  ;  52: Accept corner/V-4.              Try H+4.
 DB  VM2HM4,    VM2,   54,   90  ;  53: Accept corner/H+4.              Try V-2.
 DB  VP2HP2,    HP2,   55,  109  ;  54: Accept corner/V-2.              Try H+2.
 DB  VM1HM2,    VM1,   56,   94  ;  55: Accept corner/H+2.              Try V-1.
 DB  VP1HP1,    HP1,   57,  113  ;  56: Accept corner/V-1.              Try H+1.
 DB     HM1,  NOADJ, 0F9H, 0FBH  ;  57: Accept corner/H+1.              Done.

     ; Lower right corner:

 DB  VP8HM8,    HM8,   59,  117  ;  58: Accept corner/V-8.              Try H-8.
 DB  VM4HP8,    VM4,   60,   86  ;  59: Accept corner/H-8.              Try V-4.
 DB  VP4HM4,    HM4,   61,  121  ;  60: Accept corner/V-4.              Try H-4.
 DB  VM2HP4,    VM2,   62,   90  ;  61: Accept corner/H-4.              Try V-2.
 DB  VP2HM2,    HM2,   63,  125  ;  62: Accept corner/V-2.              Try H-2.
 DB  VM1HP2,    VM1,   64,   94  ;  63: Accept corner/H-2.              Try V-1.
 DB  VP1HM1,    HM1,   65,  129  ;  64: Accept corner/V-1.              Try H-1.
 DB     HP1,  NOADJ, 0FAH, 0FBH  ;  65: Accept corner/H-1.              Done.

     ; Upper edge:

 DB  VM8HP8,    HP8,   67,   19  ;  66: Accept central/V+8 as best.     Try H+8.
 DB     HMG,    HMG,   69,   68  ;  67: H+8 worse/better than central.  Try H-8.
 DB  VP4HPG,    VP4,   70,   70  ;  68: Accept H+8/H-8 as best.         Try V+4.
 DB  VP4HP8,    VP4,   70,   70  ;  69: Accept central/H-8 as best.     Try V+4.
 DB  VM4HP4,    HP4,   71,   25  ;  70: Accept central/V+4 as best.     Try H+4.
 DB     HM8,    HM8,   73,   72  ;  71: H+4 worse/better than central.  Try H-4.
 DB  VP2HP8,    VP2,   74,   74  ;  72: Accept H+4/H-4 as best.         Try V+2.
 DB  VP2HP4,    VP2,   74,   74  ;  73: Accept central/H-4 as best.     Try V+2.
 DB  VM2HP2,    HP2,   75,   31  ;  74: Accept central/V+2 as best.     Try H+2.
 DB     HM4,    HM4,   77,   76  ;  75: H+2 worse/better than central.  Try H-2.
 DB  VP1HP4,    VP1,   78,   78  ;  76: Accept H+2/H-2 as best.         Try V+1.
 DB  VP1HP2,    VP1,   78,   78  ;  77: Accept central/H-2 as best.     Try V+1.
 DB  VM1HP1,    HP1,   79,   13  ;  78: Accept central/V+1 as best.     Try H+1.
 DB     HM2,    HM2,   81,   80  ;  79: H+1 worse/better than central.  Try H-1.
 DB     HP2,  NOADJ, 0F7H, 0F7H  ;  80: Accept H+1/H-1 as best.         Done.
 DB     HP1,  NOADJ, 0F7H, 0F7H  ;  81: Accept central/H-1 as best.     Done.

     ; Lower edge:

 DB  VP8HP8,    HP8,   83,   19  ;  82: Accept central/V-8 as best.     Try H+8.
 DB     HMG,    HMG,   85,   84  ;  83: H+8 worse/better than central.  Try H-8.
 DB  VM4HPG,    VM4,   86,   86  ;  84: Accept H+8/H-8 as best.         Try V-4.
 DB  VM4HP8,    VM4,   86,   86  ;  85: Accept central/H-8 as best.     Try V-4.
 DB  VP4HP4,    HP4,   87,   25  ;  86: Accept central/V-4 as best.     Try H+4.
 DB     HM8,    HM8,   89,   88  ;  87: H+4 worse/better than central.  Try H-4.
 DB  VM2HP8,    VM2,   90,   90  ;  88: Accept H+4/H-4 as best.         Try V-2.
 DB  VM2HP4,    VM2,   90,   90  ;  89: Accept central/H-4 as best.     Try V-2.
 DB  VP2HP2,    HP2,   91,   31  ;  90: Accept central/V-2 as best.     Try H+2.
 DB     HM4,    HM4,   93,   92  ;  91: H+2 worse/better than central.  Try H-2.
 DB  VM1HP4,    VM1,   94,   94  ;  92: Accept H+2/H-2 as best.         Try V-1.
 DB  VM1HP2,    VM1,   94,   94  ;  93: Accept central/H-2 as best.     Try V-1.
 DB  VP1HP1,    HP1,   95,   13  ;  94: Accept central/V-1 as best.     Try H+1.
 DB     HM2,    HM2,   97,   96  ;  95: H+1 worse/better than central.  Try H-1.
 DB     HP2,  NOADJ, 0FBH, 0FBH  ;  96: Accept H+1/H-1 as best.         Done.
 DB     HP1,  NOADJ, 0FBH, 0FBH  ;  97: Accept central/H-1 as best.     Done.

     ; Left edge:

 DB     VMG,    VMG,  100,   99  ;  98: V+8 worse/better than central.  Try V-8.
 DB  VPGHP8,    HP8,  101,  101  ;  99: Accept V+8/V-8 as best.         Try H+8.
 DB  VP8HP8,    HP8,  101,  101  ; 100: Accept central/V-8 as best.     Try H+8.
 DB  VP4HM8,    VP4,  102,   22  ; 101: Accept central/H+8 as best.     Try V+4.
 DB     VM8,    VM8,  104,  103  ; 102: V+4 worse/better than central.  Try V-4.
 DB  VP8HP4,    HP4,  105,  105  ; 103: Accept V+4/V-4 as best.         Try H+4.
 DB  VP4HP4,    HP4,  105,  105  ; 104: Accept central/V-4 as best.     Try H+4.
 DB  VP2HM4,    VP2,  106,   28  ; 105: Accept central/H+4 as best.     Try V+2.
 DB     VM4,    VM4,  108,  107  ; 106: V+2 worse/better than central.  Try V-2.
 DB  VP4HP2,    HP2,  109,  109  ; 107: Accept V+2/V-2 as best.         Try H+2.
 DB  VP2HP2,    HP2,  109,  109  ; 108: Accept central/V-2 as best.     Try H+2.
 DB  VP1HM2,    VP1,  110,   10  ; 109: Accept central/H+2 as best.     Try V+1.
 DB     VM2,    VM2,  112,  111  ; 110: V+1 worse/better than central.  Try V-1.
 DB  VP2HP1,    HP1,  113,  113  ; 111: Accept V+1/V-1 as best.         Try H+1.
 DB  VP1HP1,    HP1,  113,  113  ; 112: Accept central/V-1 as best.     Try H+1.
 DB     HM1,  NOADJ, 0FDH, 0FDH  ; 113: Accept central/H+1 as best.     Done.

     ; Right edge:

 DB     VPG,    VPG,  116,  115  ; 114: V-8 worse/better than central.  Try V+8.
 DB  VMGHM8,    HM8,  117,  117  ; 115: Accept V-8/V+8 as best.         Try H-8.
 DB  VM8HM8,    HM8,  117,  117  ; 116: Accept central/V+8 as best.     Try H-8.
 DB  VP4HP8,    VP4,  118,   22  ; 117: Accept central/H+8 as best.     Try V+4.
 DB     VM8,    VM8,  120,  119  ; 118: V+4 worse/better than central.  Try V-4.
 DB  VP8HM4,    HM4,  121,  121  ; 119: Accept V+4/V-4 as best.         Try H-4.
 DB  VP4HM4,    HM4,  121,  121  ; 120: Accept central/V-4 as best.     Try H-4.
 DB  VP2HP4,    VP2,  122,   28  ; 121: Accept central/H+4 as best.     Try V+2.
 DB     VM4,    VM4,  124,  123  ; 122: V+2 worse/better than central.  Try V-2.
 DB  VP4HM2,    HM2,  125,  125  ; 123: Accept V+2/V-2 as best.         Try H-2.
 DB  VP2HM2,    HM2,  125,  125  ; 124: Accept central/V-2 as best.     Try H-2.
 DB  VP1HP2,    VP1,  126,   10  ; 125: Accept central/H+2 as best.     Try V+1.
 DB     VM2,    VM2,  128,  127  ; 126: V+1 worse/better than central.  Try V-1.
 DB  VP2HM1,    HM1,  129,  129  ; 127: Accept V+1/V-1 as best.         Try H-1.
 DB  VP1HM1,    HM1,  129,  129  ; 128: Accept central/V-1 as best.     Try H-1.
 DB     HP1,  NOADJ, 0FEH, 0FEH  ; 129: Accept central/H+1 as best.     Done.

     ; Exhaustive search, radius 1 here, reaching out to radius 2 further below.
     ;     .   .   .   .   .
     ;     .   2   5   3   .   C = center.
     ;     .   7   C   8   .
     ;     .   4   6   1   .   # = order to try additional candidates.
     ;     .   .   .   .   .

FIRST_HEURISTIC_EXHAUSTIVE = 130

 DB  VM2HM2, VM2HM2,  131, 138 ; 130: #1 worse/better than  C. Try #2.
 DB     HP2,    HP2,  132, 145 ; 131: #2 worse/better than  C. Try #3.
 DB  VP2HM2, VP2HM2,  133, 151 ; 132: #3 worse/better than  C. Try #4.
 DB  VM2HP1, VM2HP1,  134, 156 ; 133: #4 worse/better than  C. Try #5.
 DB     VP2,    VP2,  135, 160 ; 134: #5 worse/better than  C. Try #6.
 DB  VM1HM1, VM1HM1,  136, 163 ; 135: #6 worse/better than  C. Try #7.
 DB     HP2,    HP2,  137, 165 ; 136: #7 worse/better than  C. Try #8.
 DB     HM1,    HP1, 0FFH, 166 ; 137: If C best, quit.  If 8 best, keep going.
 DB     HP2,    HP2,  139, 145 ; 138: #2 worse/better than #1. Try #3.
 DB  VP2HM2, VP2HM2,  140, 151 ; 139: #3 worse/better than #1. Try #4.
 DB  VM2HP1, VM2HP1,  141, 156 ; 140: #4 worse/better than #1. Try #5.
 DB     VP2,    VP2,  142, 160 ; 141: #5 worse/better than #1. Try #6.
 DB  VM1HM1, VM1HM1,  143, 163 ; 142: #6 worse/better than #1. Try #7.
 DB     HP2,    HP2,  144, 165 ; 143: #7 worse/better than #1. Try #8.
 DB     HP1,    HP1,  199, 166 ; 144: #8 worse/better than #1. Take best, go on.
 DB  VP2HM2, VP2HM2,  146, 151 ; 145: #3 worse/better than #2. Try #4.
 DB  VM2HP1, VM2HP1,  147, 156 ; 146: #4 worse/better than #2. Try #5.
 DB     VP2,    VP2,  148, 160 ; 147: #5 worse/better than #2. Try #6.
 DB  VM1HM1, VM1HM1,  149, 163 ; 148: #6 worse/better than #2. Try #7.
 DB     HP2,    HP2,  150, 165 ; 149: #7 worse/better than #2. Try #8.
 DB     HM3,    HP1,  208, 166 ; 150: #8 worse/better than #2. Take best, go on.
 DB  VM2HP1, VM2HP1,  152, 156 ; 151: #4 worse/better than #3. Try #5.
 DB     VP2,    VP2,  153, 160 ; 152: #5 worse/better than #3. Try #6.
 DB  VM1HM1, VM1HM1,  154, 163 ; 153: #6 worse/better than #3. Try #7.
 DB     HP2,    HP2,  155, 165 ; 154: #7 worse/better than #3. Try #8.
 DB     HP1,    HP1,  217, 166 ; 155: #8 worse/better than #3. Take best, go on.
 DB     VP2,    VP2,  157, 160 ; 156: #5 worse/better than #4. Try #6.
 DB  VM1HM1, VM1HM1,  158, 163 ; 157: #6 worse/better than #4. Try #7.
 DB     HP2,    HP2,  159, 165 ; 158: #7 worse/better than #4. Try #8.
 DB     HM3,    HP1,  190, 166 ; 159: #8 worse/better than #4. Take best, go on.
 DB  VM1HM1, VM1HM1,  161, 163 ; 160: #6 worse/better than #5. Try #7.
 DB     HP2,    HP2,  162, 165 ; 161: #7 worse/better than #5. Try #8.
 DB  VM2HM1,    HP1,  184, 166 ; 162: #8 worse/better than #5. Take best, go on.
 DB     HP2,    HP2,  164, 165 ; 163: #7 worse/better than #6. Try #8.
 DB  VP2HM1,    HP1,  176, 166 ; 164: #8 worse/better than #6. Take best, go on.
 DB     HM3,    HP1,  172, 166 ; 165: #8 worse/better than #7. Take best, go on.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   2   ~ = tried, but not as good.
     ;     .   ~   C   X   1   X = best so far.
     ;     .   ~   ~   ~   3   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  167, 169 ; 166: #1 better/worse than  X.  Try #2.
 DB     VP2,    VP2,  168, 171 ; 167: #2 better/worse than  X.  Try #3.
 DB  VM1HM1,  NOADJ, 0FFH,0FFH ; 168: #3 better/worse than  X.  Take best, quit.
 DB     VP2,    VP2,  170, 171 ; 169: #2 better/worse than #1.  Try #3.
 DB     VM1,  NOADJ, 0FFH,0FFH ; 170: #3 better/worse than #1.  Take best, quit.
 DB     VM2,  NOADJ, 0FFH,0FFH ; 171: #3 better/worse than #2.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     2   ~   ~   ~   .   ~ = tried, but not as good.
     ;     1   X   C   ~   .   X = best so far.
     ;     3   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  173, 175 ; 172: #1 better/worse than  X.  Try #2.
 DB     VP2,    VP2,  174, 177 ; 173: #2 better/worse than  X.  Try #3.
 DB  VM1HP1,  NOADJ, 0FFH,0FFH ; 174: #3 better/worse than  X.  Take best, quit.
 DB     VP2,    VP2,  176, 177 ; 175: #2 better/worse than #1.  Try #3.
 DB     VM1,  NOADJ, 0FFH,0FFH ; 176: #3 better/worse than #1.  Take best, quit.
 DB     VM2,  NOADJ, 0FFH,0FFH ; 177: #3 better/worse than #2.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   .   ~ = tried, but not as good.
     ;     .   ~   C   ~   .   X = best so far.
     ;     .   ~   X   ~   .   # = order to try additional candidates.
     ;     .   2   1   3   .

 DB     HM1,    HM1,  179, 181 ; 178: #1 better/worse than  X.  Try #2.
 DB     HP2,    HP2,  180, 183 ; 179: #2 better/worse than  X.  Try #3.
 DB  VM1HM1,  NOADJ, 0FFH,0FFH ; 180: #3 better/worse than  X.  Take best, quit.
 DB     HP2,    HP2,  182, 183 ; 181: #2 better/worse than #1.  Try #3.
 DB     HM1,  NOADJ, 0FFH,0FFH ; 182: #3 better/worse than #1.  Take best, quit.
 DB     HM2,  NOADJ, 0FFH,0FFH ; 183: #3 better/worse than #2.  Take best, quit.

     ;     .   2   1   3   .   C = center.
     ;     .   ~   X   ~   .   ~ = tried, but not as good.
     ;     .   ~   C   ~   .   X = best so far.
     ;     .   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     HM1,    HM1,  185, 187 ; 184: #1 better/worse than  X.  Try #2.
 DB     HP2,    HP2,  186, 189 ; 185: #2 better/worse than  X.  Try #3.
 DB  VP1HM1,  NOADJ, 0FFH,0FFH ; 186: #3 better/worse than  X.  Take best, quit.
 DB     HP2,    HP2,  188, 189 ; 187: #2 better/worse than #1.  Try #3.
 DB     HM1,  NOADJ, 0FFH,0FFH ; 188: #3 better/worse than #1.  Take best, quit.
 DB     HM2,  NOADJ, 0FFH,0FFH ; 189: #3 better/worse than #2.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   .   ~ = tried, but not as good.
     ;     1   ~   C   ~   .   X = best so far.
     ;     2   X   ~   ~   .   # = order to try additional candidates.
     ;     4   3   5   .   .

 DB     VP1,    VP1,  191, 195 ; 190: #1 better/worse than  X.  Try #2.
 DB  VP1HP1, VP1HP1,  178, 192 ; 191: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  193, 181 ; 192: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  194, 183 ; 193: #4 better/worse than #2.  Try #5.
 DB  VM1HM2,  NOADJ, 0FFH,0FFH ; 194: #5 better/worse than #2.  Take best, quit.
 DB  VP1HP1, VP1HP1,  196, 192 ; 195: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  197, 181 ; 196: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  198, 183 ; 197: #4 better/worse than #1.  Try #5.
 DB  VM2HM2,  NOADJ, 0FFH,0FFH ; 198: #5 better/worse than #1.  Take best, quit.

     ;     .   .   .   .   .   C = center.
     ;     .   ~   ~   ~   .   ~ = tried, but not as good.
     ;     .   ~   C   ~   1   X = best so far.
     ;     .   ~   ~   X   2   # = order to try additional candidates.
     ;     .   .   4   3   5

 DB     VP1,    VP1,  200, 204 ; 199: #1 better/worse than  X.  Try #2.
 DB  VP1HM1, VP1HM1,  178, 201 ; 200: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  202, 181 ; 201: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  203, 183 ; 202: #4 better/worse than #2.  Try #5.
 DB     VM1,  NOADJ, 0FFH,0FFH ; 203: #5 better/worse than #2.  Take best, quit.
 DB  VP1HM1, VP1HM1,  205, 201 ; 204: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  206, 181 ; 205: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  207, 183 ; 206: #4 better/worse than #1.  Try #5.
 DB     VM2,  NOADJ, 0FFH,0FFH ; 207: #5 better/worse than #1.  Take best, quit.

     ;     4   3   5   .   .   C = center.
     ;     2   X   ~   ~   .   ~ = tried, but not as good.
     ;     1   ~   C   ~   .   X = best so far.
     ;     .   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  209, 213 ; 208: #1 better/worse than  X.  Try #2.
 DB  VM1HP1, VM1HP1,  184, 210 ; 209: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  211, 187 ; 210: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  212, 189 ; 211: #4 better/worse than #2.  Try #5.
 DB  VP1HM2,  NOADJ, 0FFH,0FFH ; 212: #5 better/worse than #2.  Take best, quit.
 DB  VM1HP1, VM1HP1,  214, 210 ; 213: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  215, 187 ; 214: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  216, 189 ; 215: #4 better/worse than #1.  Try #5.
 DB  VP2HM2,  NOADJ, 0FFH,0FFH ; 216: #5 better/worse than #1.  Take best, quit.

     ;     .   .   4   3   5   C = center.
     ;     .   ~   ~   X   2   ~ = tried, but not as good.
     ;     .   ~   C   ~   1   X = best so far.
     ;     .   ~   ~   ~   .   # = order to try additional candidates.
     ;     .   .   .   .   .

 DB     VM1,    VM1,  218, 222 ; 217: #1 better/worse than  X.  Try #2.
 DB  VM1HM1, VM1HM1,  184, 219 ; 218: #2 better/worse than  X.  Try #3.
 DB     HM1,    HM1,  220, 187 ; 219: #3 better/worse than #2.  Try #4.
 DB     HP2,    HP2,  221, 189 ; 220: #4 better/worse than #2.  Try #5.
 DB     VP1,  NOADJ, 0FFH,0FFH ; 221: #5 better/worse than #2.  Take best, quit.
 DB  VM1HM1, VM1HM1,  223, 219 ; 222: #2 better/worse than #1.  Try #3.
 DB     HM1,    HM1,  224, 187 ; 223: #3 better/worse than #1.  Try #4.
 DB     HP2,    HP2,  225, 189 ; 224: #4 better/worse than #1.  Try #5.
 DB     VP2,  NOADJ, 0FFH,0FFH ; 225: #5 better/worse than #1.  Take best, quit.

FIRST_HEURISTIC_EXHAUSTIVE_NEW_CTR = 226

 DB  VP1HP1, VP1HP1,  130, 130 ; 226: Redoing ctr, away from limiting edge.

 DB  ?, ?, ?, ?, ?, ?

; Table of values to add to SWDs for half pel reference macroblocks, to cause
; those that are off the edge of the frame to produce artificially high SWDs.
; (64 bytes;3040:3103)

InvalidateBadHalfPelMVs LABEL DWORD

  DD    0FFFFFFFFH, 0FFFFFF00H, 0FFFF00FFH, 0FFFF0000H
  DD    0FF00FFFFH, 0FF00FF00H, 0FF0000FFH, 0FF000000H
  DD    000FFFFFFH, 000FFFF00H, 000FF00FFH, 000FF0000H
  DD    00000FFFFH, 00000FF00H, 0000000FFH, 000000000H

; Tables (interleaved) to select case from next table (below these) to drive
; the weighting of the future and past predictions in the construction of
; B-frame reference blocks.
; (448 bytes;3104:3551)

VertWtSel LABEL BYTE
  DB   0
HorzWtSel LABEL BYTE
  DB   240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   1,   0
  DB   1,   0
  DB   2,  16
  DB   2,  16
  DB   3,  32
  DB   3,  32
  DB   4,  48
  DB   4,  48
  DB   5,  64
  DB   5,  64
  DB   6,  80
  DB   6,  80
  DB   7,  96
  DB   7,  96
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   8, 112
  DB   9, 128
  DB   9, 128
  DB  10, 144
  DB  10, 144
  DB  11, 160
  DB  11, 160
  DB  12, 176
  DB  12, 176
  DB  13, 192
  DB  13, 192
  DB  14, 208
  DB  14, 208
  DB  15, 224
  DB  15, 224
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240  ; Chroma starts here
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240  ; Luma ends here
  DB   0, 240
  DB   0, 240
  DB   1,   0
  DB   1,   0
  DB   2,  16
  DB   2,  16
  DB   3,  32
  DB   3,  32
  DB   4,  48
  DB   4,  48
  DB   5,  64
  DB   5,  64
  DB   6,  80
  DB   6,  80
  DB   7,  96
  DB   7,  96
  DB   8, 112
  DB   9, 128
  DB   9, 128
  DB  10, 144
  DB  10, 144
  DB  11, 160
  DB  11, 160
  DB  12, 176
  DB  12, 176
  DB  13, 192
  DB  13, 192
  DB  14, 208
  DB  14, 208
  DB  15, 224
  DB  15, 224
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240
  DB   0, 240

; Table indexed by VertWtSel and HorzWtSel to get index of weight to apply to
; future and past predictions in the construction of B-frame reference blocks
; for frame differencing.
; (264 bytes;3552:3815)
;
; Indexed by VertWtSel[VMV]+HorzWtSel[HMV]+N  to get idx of weight for line N.

P8F0 =  0*8
F1P7 =  1*8
F2P6 =  2*8
F3P5 =  3*8
F4P4 =  4*8
F5P3 =  5*8
F6P2 =  6*8
F7P1 =  7*8
F8P0 =  8*8
P1F7 =  9*8
P2F6 = 10*8
P3F5 = 11*8
P4F4 = 12*8
P5F3 = 13*8
P6F2 = 14*8
P7F1 = 15*8

Diff_IdxRefWts LABEL BYTE

  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F1P7, F1P7, F1P7, F1P7, F1P7, F1P7, F1P7, F1P7
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F2P6, F2P6, F2P6, F2P6, F2P6, F2P6, F2P6, F2P6
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F3P5, F3P5, F3P5, F3P5, F3P5, F3P5, F3P5, F3P5
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F4P4, F4P4, F4P4, F4P4, F4P4, F4P4, F4P4, F4P4
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F5P3, F5P3, F5P3, F5P3, F5P3, F5P3, F5P3, F5P3
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F6P2, F6P2, F6P2, F6P2, F6P2, F6P2, F6P2, F6P2
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F7P1, F7P1, F7P1, F7P1, F7P1, F7P1, F7P1, F7P1
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  F8P0, F8P0, F8P0, F8P0, F8P0, F8P0, F8P0, F8P0
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P1F7, P1F7, P1F7, P1F7, P1F7, P1F7, P1F7, P1F7
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P2F6, P2F6, P2F6, P2F6, P2F6, P2F6, P2F6, P2F6
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P3F5, P3F5, P3F5, P3F5, P3F5, P3F5, P3F5, P3F5
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P4F4, P4F4, P4F4, P4F4, P4F4, P4F4, P4F4, P4F4
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P5F3, P5F3, P5F3, P5F3, P5F3, P5F3, P5F3, P5F3
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P6F2, P6F2, P6F2, P6F2, P6F2, P6F2, P6F2, P6F2
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P7F1, P7F1, P7F1, P7F1, P7F1, P7F1, P7F1, P7F1
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0
  DB  P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0, P8F0

BFrmSWDState LABEL BYTE  ; State engine rules for finding best motion vector.
; (48 bytes; 3816:3863)

; 1st number:  Horizontal Motion displacement to try, in half pel increments.
; 2nd number:  Vertical Motion displacement to try, in half pel increments.
; 3rd number:  Next state to enter if previous best is still best.
; 4th number:  Next state to enter if this motion is better than previous best.

   DB    -2,   0,  4,  8   ;  0 -- ( 0, 0) Try (-2, 0)
   DB     2,   0, 12, 12   ;  4 -- ( 0, 0) Try ( 2, 0)
   DB     4,   0, 12, 12   ;  8 -- (-2, 0) Try ( 2, 0)
   DB     0,  -2, 16, 20   ; 12 -- ( N, 0) Try ( N,-2)  (N = {-2,0,2})
   DB     0,   2, 24, 24   ; 16 -- ( N, 0) Try ( N, 2)
   DB     0,   4, 24, 24   ; 20 -- ( N,-2) Try ( N, 2)

   DB    -1,   0, 28, 32   ; 24
   DB     1,   0, 36, 36   ; 28
   DB     2,   0, 36, 36   ; 32
   DB     0,  -1, 40, 44   ; 36
   DB     0,   1,  0,  0   ; 40
   DB     0,   2,  0,  0   ; 44

; Table used by Quant RLE to navigate the zigzag order of quantized coeffs.
; Contents of this table are initialized by first entry to MMxEDTQ.  In
; unlikely event of race condition, it will just get initialized by more
; than one encoder instance.
; (128 bytes; 3864:3991)

NextZigZagCoeff LABEL BYTE

  DB 128 DUP (0FFH)

; Table used to initial above table.
; (64 bytes: 3992:4055)

InitZigZagCoeff LABEL BYTE

  DB Q01,Q10,Q20,Q11,Q02,Q03,Q12,Q21,Q30,Q40,Q31,Q22,Q13,Q04,Q05,Q14
  DB Q23,Q32,Q41,Q50,Q60,Q51,Q42,Q33,Q24,Q15,Q06,Q07,Q16,Q25,Q34,Q43
  DB Q52,Q61,Q70,Q71,Q62,Q53,Q44,Q35,Q26,Q17,Q27,Q36,Q45,Q54,Q63,Q72
  DB Q73,Q64,Q55,Q46,Q37,Q47,Q56,Q65,Q74,Q75,Q66,Q57,Q67,Q76,Q77,  0

; Constants needed by the Quant RLE phase.
; (128 bytes; 4056:4183)

Recip2QP LABEL DWORD
  WORD 0H, 0H           ; QP = 000h
  WORD 04000H, 04000H   ; QP = 001h
  WORD 02000H, 02000H   ; QP = 002h
  WORD 01555H, 01555H   ; QP = 003h
  WORD 01000H, 01000H   ; QP = 004h
  WORD 00CCCH, 00CCCH   ; QP = 005h
  WORD 00AAAH, 00AAAH   ; QP = 006h
  WORD 00924H, 00924H   ; QP = 007h
  WORD 00800H, 00800H   ; QP = 008h
  WORD 0071CH, 0071CH   ; QP = 009h
  WORD 00666H, 00666H   ; QP = 00Ah
  WORD 005D1H, 005D1H   ; QP = 00Bh
  WORD 00555H, 00555H   ; QP = 00Ch
  WORD 004ECH, 004ECH   ; QP = 00Dh
  WORD 00492H, 00492H   ; QP = 00Eh
  WORD 00444H, 00444H   ; QP = 00Fh
  WORD 00400H, 00400H   ; QP = 010h
  WORD 003C3H, 003C3H   ; QP = 011h
  WORD 0038EH, 0038EH   ; QP = 012h
  WORD 0035EH, 0035EH   ; QP = 013h
  WORD 00333H, 00333H   ; QP = 014h
  WORD 0030CH, 0030CH   ; QP = 015h
  WORD 002E8H, 002E8H   ; QP = 016h
  WORD 002C8H, 002C8H   ; QP = 017h
  WORD 002AAH, 002AAH   ; QP = 018h
  WORD 0028FH, 0028FH   ; QP = 019h
  WORD 00276H, 00276H   ; QP = 01Ah
  WORD 0025EH, 0025EH   ; QP = 01Bh
  WORD 00249H, 00249H   ; QP = 01Ch
  WORD 00234H, 00234H   ; QP = 01Dh
  WORD 00222H, 00222H   ; QP = 01Eh
  WORD 00210H, 00210H   ; QP = 01Fh

; Skip over space to get to where the following tables can go.  They will
; hit the cache at the same point as a portion of the StateEngine states
; that aren't used in the heuristic ME mode.
; (2056 bytes; 4184:6239)

  DB 2056 DUP (?)   ; Static space place-holder.

; Table to select base address in next table below to use for particular block
; of macroblock.  First column provides address of base element of HorzWtSel
; to use to map horizontal MV to list of weighting indices to use.  ; Second
; column is similar, but for Vertical MV.  Third and fourth columns not used.
; 6 rows; one for each block in a macroblock.
; (88 bytes; 6240:6327)

LeftRightBlkPosition LABEL DWORD
  DD HorzWtSel+0-64
UpDownBlkPosition LABEL DWORD
  DD                   VertWtSel+0-64,   0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+32-64,  VertWtSel+0-64,   0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+0-64,   VertWtSel+32-64,  0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+32-64,  VertWtSel+32-64,  0DEADBEEFH, 0DEADBEEFH
  DD HorzWtSel+128,    VertWtSel+128,    0DEADBEEFH
BlkEmptyFlag LABEL BYTE  ; sneak this in here
  DB       16, 0, 32, 0
  DD HorzWtSel+128,    VertWtSel+128


; The following table, indexed by MBEdgeType&7, returns a mask which is used to
; zero-out the motion vectors for predictors that are off the edge of the
; frame.  The index is a 3 bit value, each bit being set if the macroblock
; is NOT on the corresponding edge.  1 == left;  2 == right;  4 == top;
; The value gotten out is (where A==left; B==above; C==above right):
;    <mask(A) mask(A) mask(C) mask(C) mask(B) mask(B) mask(A) mask(A)>
; The mask is 0xFF if the corresponding remote block is NOT off the edge, and
; 0x00 if it is off the edge.
; (32 bytes: 6328: 6359)

ValidRemoteVectors LABEL DWORD
  DWORD 0DEADBEEFH   ;  0: Can't be on left and right edges at once.
  DWORD 0FF0000FFH   ;  1: Top right corner.
  DWORD 000000000H   ;  2: Top left corner.
  DWORD 0FF0000FFH   ;  3: Top edge.
  DWORD 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  DWORD 0FF00FFFFH   ;  5: Right edge.
  DWORD 000FFFF00H   ;  6: Left edge.
  DWORD 0FFFFFFFFH   ;  7: Central macroblock.

; The following table, indexed by MBEdgeType, returns a QWORD of unsigned bytes
; to be subtracted with saturation to the predicted motion vector for extended
; motion vector search.  Since saturation occurs at 0, the values here are
; such that the motion vectors are biased to the appropriate point for the
; clamping effect.  The index is a 4 bit value, each bit being set if the
; macroblock is NOT on the corresponding edge.  1 == left;  2 == right;
; 4 == top;  8 == bottom.  The 8 values being calculated are as follows:
;    ; [ 0: 7] -- HMV lower limit for signature search
;    ; [ 8:15] -- HMV lower limit
;    ; [16:23] -- HMV upper limit for signature search
;    ; [24:31] -- HMV upper limit
;    ; [32:39] -- VMV lower limit for signature search
;    ; [40:47] -- VMV lower limit
;    ; [48:55] -- VMV upper limit for signature search
;    ; [56:63] -- VMV upper limit
; (88 bytes: 6360:6447)

EMV_ClampLowerEnd LABEL DWORD
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  0: Can't be on all edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  1: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  2: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  3: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  BYTE   87,  94,  97, 100,      ;  5: Bottom right corner.
         87,  94,  97, 100
  BYTE  119, 126,  97, 100,      ;  6: Bottom left corner.
         87,  94,  97, 100
  BYTE   87,  94,  97, 100,      ;  7: Bottom edge.
         87,  94,  97, 100
  DWORD 0DEADBEEFH, 0DEADBEEFH   ;  8: Can't be on left and right edges at once.
  BYTE   87,  94,  97, 100,      ;  9: Top right corner.
        119, 126,  97, 100
  BYTE  119, 126,  97, 100,      ; 10: Top left corner.
        119, 126,  97, 100
  BYTE   87,  94,  97, 100,      ; 11: Top edge.
        119, 126,  97, 100
  DWORD 0DEADBEEFH, 0DEADBEEFH   ; 12: Can't be on left and right edges at once.
  BYTE   87,  94,  97, 100,      ; 13: Right edge.
         87,  94,  97, 100
  BYTE  119, 126,  97, 100,      ; 14: Left edge.
         87,  94,  97, 100
  BYTE   87,  94,  97, 100,      ; 15: Central macroblock.
         87,  94,  97, 100

; The following table, indexed by MBEdgeType, returns a QWORD of unsigned bytes
; to be added with saturation to the result of the application of the preceed-
; ing table, to clamp the upper limit on the motion vector search parameters.
; Since saturation occurs at 255, the values here are such that the motion
; vectors are biased to the appropriate point for the clamping effect.
; (88 bytes: 6448:6535)

EMV_ClampUpperEnd LABEL DWORD
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  0: Can't be on all edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  1: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  2: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  3: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  BYTE  184, 193, 216, 225,      ;  5: Bottom right corner.
        184, 193, 216, 225
  BYTE  216, 225, 184, 193,      ;  6: Bottom left corner.
        184, 193, 216, 225
  BYTE  184, 193, 184, 193,      ;  7: Bottom edge.
        184, 193, 216, 225
  DWORD 0DEADBEEFH, 0DEADBEEFH   ;  8: Can't be on left and right edges at once.
  BYTE  184, 193, 216, 225,      ;  9: Top right corner.
        216, 225, 184, 193
  BYTE  216, 225, 184, 193,      ; 10: Top left corner.
        216, 225, 184, 193
  BYTE  184, 193, 184, 193,      ; 11: Top edge.
        216, 225, 184, 193
  DWORD 0DEADBEEFH, 0DEADBEEFH   ; 12: Can't be on left and right edges at once.
  BYTE  184, 193, 216, 225,      ; 13: Right edge.
        184, 193, 184, 193
  BYTE  216, 225, 184, 193,      ; 14: Left edge.
        184, 193, 184, 193
  BYTE  184, 193, 184, 193,      ; 15: Central macroblock.
        184, 193, 184, 193

; The following table, indexed by MBEdgeType, returns a QWORD of unsigned bytes
; to be added without saturation to the result of the application of the
; preceeding table, to return the the motion vector search parameters to the
; proper range for subsequent use.
; (88 bytes: 6536:6623)

EMV_RestoreRange LABEL DWORD
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  0: Can't be on all edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  1: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  2: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  3: Can't be on top and bottom edges at once.
; DWORD 0DEADBEEFH, 0DEADBEEFH   ;  4: Can't be on left and right edges at once.
  BYTE  120, 255,  88, 225,      ;  5: Bottom right corner.
        120, 255,  88, 225
  BYTE  120, 255,  56, 193,      ;  6: Bottom left corner.
        120, 255,  88, 225
  BYTE  120, 255,  56, 193,      ;  7: Bottom edge.
        120, 255,  88, 225
  DWORD 0DEADBEEFH, 0DEADBEEFH   ;  8: Can't be on left and right edges at once.
  BYTE  120, 255,  88, 225,      ;  9: Top right corner.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 10: Top left corner.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 11: Top edge.
        120, 255,  56, 193
  DWORD 0DEADBEEFH, 0DEADBEEFH   ; 12: Can't be on left and right edges at once.
  BYTE  120, 255,  88, 225,      ; 13: Right edge.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 14: Left edge.
        120, 255,  56, 193
  BYTE  120, 255,  56, 193,      ; 15: Central macroblock.
        120, 255,  56, 193

; Tables indexed by indices fetched from Diff_IdxRefWts.  These tables return
; a multipler to apply to past or future predictions to construct the
; B-frame candidate reference blocks.
; (128 bytes;6624:6751)

FutureWt_FF_or_00 LABEL DWORD

  DD 000000000H, 000000000H
  DD 000000000H, 0FF000000H
  DD 000000000H, 0FFFF0000H
  DD 000000000H, 0FFFFFF00H
  DD 000000000H, 0FFFFFFFFH
  DD 0FF000000H, 0FFFFFFFFH
  DD 0FFFF0000H, 0FFFFFFFFH
  DD 0FFFFFF00H, 0FFFFFFFFH
  DD 0FFFFFFFFH, 0FFFFFFFFH
  DD 0FFFFFFFFH, 000FFFFFFH
  DD 0FFFFFFFFH, 00000FFFFH
  DD 0FFFFFFFFH, 0000000FFH
  DD 0FFFFFFFFH, 000000000H
  DD 000FFFFFFH, 000000000H
  DD 00000FFFFH, 000000000H
  DD 0000000FFH, 000000000H

MMXMEDATA ENDS

;=============================================================================

.CODE EDTQ

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

EXTERN MMxDoForwardDCT:NEAR
EXTERN MMxDoForwardDCTx:NEAR
EXTERN MMxDoForwardDCTy:NEAR
IFDEF H261
ELSE
EXTERN MMxDoBFrameLumaBlocks:NEAR
EXTERN MMxDoBFrameChromaBlocks:NEAR
ENDIF

MMxEDTQ  proc C AMBAS:   DWORD,
ATarg:   DWORD,
APrev:   DWORD,
ABTarg:  DWORD,
AWtFwd:  DWORD,
AWtBwd:  DWORD,
AFrmWd:  DWORD,
ADoHalf: DWORD,
ADoBlk:  DWORD,
ADoSF:   DWORD,
ADoAP:   DWORD,
ADoB:    DWORD,
ADoLuma: DWORD,
ADoExtMV:DWORD,
AQP:     DWORD,
ABQP:    DWORD,
AB0VecT: DWORD,
ASpaFilT:DWORD,
ASpaFilD:DWORD,
ASWDTot: DWORD,
ABSWDTot:DWORD,
ACodStr: DWORD,
ABCodStr:DWORD

LocalFrameSize = 1536   ; Space needed for locals

RegStoSize = 16

; Arguments:

MBlockActionStream_arg       = RegStoSize +   4
TargetFrameBaseAddress_arg   = RegStoSize +   8
PreviousFrameBaseAddress_arg = RegStoSize +  12
BTargetFrameBaseAddress_arg  = RegStoSize +  16
SignatureBaseAddress_arg     = RegStoSize +  20
WeightForwardMotion_arg      = RegStoSize +  24
WeightBackwardMotion_arg     = RegStoSize +  28
FrameWidth                   = RegStoSize +  32
DoHalfPelEstimation_arg      = RegStoSize +  36
DoBlockLevelVectors_arg      = RegStoSize +  40
DoSpatialFiltering_arg       = RegStoSize +  44
DoAdvancedPrediction_arg     = RegStoSize +  48
DoBFrame_arg                 = RegStoSize +  52
DoLumaBlocksInThisPass_arg   = RegStoSize +  56
DoExtendedMotionVectors_arg  = RegStoSize +  60
QuantizationLevel            = RegStoSize +  64
BQuantizationLevel           = RegStoSize +  68
BFrmZeroVectorThreshold_arg  = RegStoSize +  72
SpatialFiltThreshold_arg     = RegStoSize +  76
SpatialFiltDifferential_arg  = RegStoSize +  80
PSWDTotal                    = RegStoSize +  84
PBSWDTotal                   = RegStoSize +  88
CodeStreamCursor_arg         = RegStoSize +  92
BCodeStreamCursor_arg        = RegStoSize +  96
EndOfArgList                 = RegStoSize + 100

StackOffset TEXTEQU <0>
CONST_384   TEXTEQU <384>

  push  esi
  push  edi
  push  ebp
  push  ebx

; Adjust stack ptr so that local frame fits nicely in cache w.r.t. other data.

  mov        esi,esp
   and       esp,0FFFFF000H
  sub        esp,000000FE0H
IFDEF H261

   mov       ebp,PITCH
  
CONST_384   TEXTEQU <ebp>

  mov        eax,[esi+SpatialFiltThreshold_arg]
   mov       ebx,[esi+SpatialFiltDifferential_arg]
  mov        SpatialFiltThreshold,eax
   mov       SpatialFiltDifferential,ebx
  mov        ecx,[esi+TargetFrameBaseAddress_arg]
   mov       ebx,[esi+SignatureBaseAddress_arg]
  sub        ecx,ebx
   mov       eax,[esi+TargetFrameBaseAddress_arg]
  mov        SigToTarget,ecx
   add       ecx,PITCH*80+64
  neg        ecx
  mov        TargetToSig_Debiased,ecx
   mov       ebx,[esi+PreviousFrameBaseAddress_arg]
  mov        PreviousFrameBaseAddress,ebx
   mov       TargetFrameBaseAddress,eax
  sub        ebx,eax
   mov       ecx,[esi+QuantizationLevel]
  mov        TargToRef,ebx
   mov       eax,[esi+CodeStreamCursor_arg]
  mov        ebx,ecx
   mov       CodeStreamCursor,eax
  shl        ebx,16
   xor       edx,edx
  or         ebx,ecx
   mov       ecx,Recip2QP[ecx*4]
  mov        QPDiv2,ebx
   mov       Recip2QPToUse,ecx
  mov        eax,[esi+DoSpatialFiltering_arg]
   mov       DoExtendedMotionVectors,edx
  test       eax,eax
   je        @f
  mov        eax,3
@@:
  mov        DoSpatialFiltering,al
   mov       SWDTotal,edx
  mov        BestMBHalfPelMV,edx
   mov       ebx,PreviousFrameBaseAddress
  mov        BlockAbove[0],edx
   sub       ebx,16
  mov        edx,[esi+FrameWidth]
   mov       SpatiallyFilteredMB,ebx
  imul       edx,-SIZEOF T_MacroBlockActionDescr/16
  add        edx,2*SIZEOF T_Blk
   mov       eax,14           ; 14 if restricted MVs and doing heuristic ME.
  mov        BlockAbove[4],edx
   mov       DoHeuristicME,eax

ELSE
 
   mov       eax,[esi+DoExtendedMotionVectors_arg]
  test       eax,eax
   je        @f
  mov        eax,7
@@:
  mov        DoExtendedMotionVectors,eax
   mov       eax,[esi+BFrmZeroVectorThreshold_arg]
  mov        edi,[esi+WeightForwardMotion_arg]
   mov       BFrmZeroVectorThreshold,eax
  mov        ecx,60
   mov       ebx,060606060H
  lea        edx,WeightForwardMotion+128
@@:
   mov       eax,[edi+ecx]
  and        eax,03F3F3F3FH    ; ???
   mov       ebp,[edi+ecx+64]
  and        ebp,03F3F3F3FH    ; ???
   xor       eax,ebx
  xor        ebp,ebx
   mov       [edx+ecx+64],eax
  mov        [edx+ecx-128],ebp
   sub       ecx,4
  mov        ebp,PITCH
   jge       @b

  mov        edi,[esi+WeightBackwardMotion_arg]
   mov       eax,edx
  lea        edx,WeightBackwardMotion+128
   mov       ecx,60
  sub        eax,edx
   jne       @b
  
CONST_384   TEXTEQU <ebp>

  mov        ebx,[esi+PreviousFrameBaseAddress_arg]
   mov       eax,[esi+TargetFrameBaseAddress_arg]
  mov        PreviousFrameBaseAddress,ebx
   mov       TargetFrameBaseAddress,eax
  mov        ecx,[esi+BTargetFrameBaseAddress_arg]
   sub       ebx,eax
  mov        TargToRef,ebx
   sub       eax,ecx
  mov        BFrameBaseAddress,ecx
   mov       BFrameToFuture,eax
  mov        ecx,[esi+TargetFrameBaseAddress_arg]
   mov       ebx,[esi+SignatureBaseAddress_arg]
  sub        ecx,ebx
   mov       edx,[esi+FrameWidth]
  mov        SigToTarget,ecx
   add       ecx,PITCH*80+64
  neg        ecx
  imul       edx,-SIZEOF T_MacroBlockActionDescr/16
  mov        TargetToSig_Debiased,ecx
   mov       ecx,[esi+DoBFrame_arg]
  add        edx,2*SIZEOF T_Blk
   xor       cl,1
  mov        BlockAbove[4],edx
   mov       IsPlainPFrame,cl
  mov        ecx,[esi+QuantizationLevel]
   mov       eax,[esi+CodeStreamCursor_arg]
  mov        ebx,ecx
   mov       CodeStreamCursor,eax
  mov        eax,[esi+BCodeStreamCursor_arg]
   mov       BCodeStreamCursor,eax
  shl        ebx,16
   mov       eax,[esi+DoHalfPelEstimation_arg]
  or         ebx,ecx
   mov       ecx,Recip2QP[ecx*4]
  mov        QPDiv2,ebx
   mov       Recip2QPToUse,ecx
  mov        ecx,[esi+BQuantizationLevel]
   xor       edx,edx
  mov        ebx,ecx
  shl        ebx,16
   mov       BestMBHalfPelMV,edx
  or         ebx,ecx
   mov       ecx,Recip2QP[ecx*4]
  mov        BQPDiv2,ebx
   mov       BRecip2QPToUse,ecx
  test       eax,eax
   je        @f
  mov        eax,-4
@@:
  mov        DoHalfPelME,eax
   mov       eax,[esi+DoBlockLevelVectors_arg]
  mov        DoBlockLevelVectors,al
   mov       eax,[esi+DoAdvancedPrediction_arg]
  mov        DoAdvancedPrediction,al
   mov       SWDTotal,edx
  test       eax,eax
   lea       eax,[eax+14]     ; 14 if restricted MVs and doing heuristic ME.
  je         @f
  xor        eax,eax          ; 0 if unrestricted MVs and doing heuristic ME.
@@:
  mov        DoHeuristicME,eax
   mov       BSWDTotal,edx
  mov        PendingOBMC,edx
   mov       BlockAbove[0],edx
ENDIF
  mov        eax,01E98E268H
  mov        EMVLimitsForThisMB,eax 
  ;               ; [ 0: 7] -- HMV lower limit for sig search (biased 128)
  ;               ; [ 8:15] -- HMV lower limit (signed)
  ;               ; [16:23] -- HMV upper limit for sig search (biased 128)
  ;               ; [24:31] -- HMV upper limit (signed)
   mov       EMVLimitsForThisMB+4,eax ; Same as for HMV.
  mov        edx,[esi+MBlockActionStream_arg]
   mov       al,NextZigZagCoeff[Q77]
  test       al,al
   je        ZigZagCoeffInitialized

  xor        ecx,ecx
   lea       ebx,InitZigZagCoeff
  xor        eax,eax

@@:

  mov        al,[ebx]
   inc       ebx
  mov        NextZigZagCoeff[ecx],al
   mov       ecx,eax
  test       eax,eax
   jne       @b

ZigZagCoeffInitialized:

  mov        StashESP,esi
   mov       eax,[esi+DoLumaBlocksInThisPass_arg]
  test       eax,eax
   jne       FirstMacroBlock   ; Jump if doing luma plane

  jmp        FirstMacroBlock_ChromaProcessing

IntraCodedChromaProcessingDone:

IFDEF H261
ELSE
  mov        al,IsPlainPFrame
  test       al,al
   jne       NextMacroBlock_ChromaProcessing

  mov        eax,QPDiv2
   mov       ebx,BQPDiv2

  call       MMxDoBFrameChromaBlocks
ENDIF

NextMacroBlock_ChromaProcessing:

  mov        bl,[edx].CodedBlocks
   sub       edx,-SIZEOF T_MacroBlockActionDescr
  and        bl,040H               ; Check for end-of-stream
   jne       TrulyDone

FirstMacroBlock_ChromaProcessing:

  mov        al,[edx].BlockType         ; Chroma handling.  Intra?  Or Inter?
   mov       ecx,TargetFrameBaseAddress
  cmp        al,INTRA
   jne       ChromaIsInterCoded

  mov        esi,[edx].BlkU.BlkOffset
   mov       StashBlockType,al
  add        esi,ecx
   push      eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCT       ; Block is in target frame;  Pitch is PITCH

  shl        bl,4
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       esi,[edx].BlkV.BlkOffset
  mov        [edx].CodedBlocks,al
   mov       ecx,TargetFrameBaseAddress
  add        esi,ecx

  call       MMxDoForwardDCT       ; Block is in target frame;  Pitch is PITCH

  shl        bl,5
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       ecx                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        [edx].CodedBlocks,al
   jmp       IntraCodedChromaProcessingDone

ChromaIsInterCoded:

  mov        edi,[edx].BlkU.BlkOffset   ; Get address of next macroblock to do.
   mov       ebx,[edx].BlkU.MVs
  add        edi,ecx
   mov       esi,[edx].BlkU.PastRef
  mov        StashBlockType,al
IFDEF H261
   mov       ecx,2+256*1        ; cl==2 tells SpatialLoopFilter code to do one
   ;                            ; block.  ch==1 causes it to return to here.
  mov        TargetMacroBlockBaseAddr,edi  ; Store address of U block.
   cmp       al,INTERSLF
  je         DoSpatialFilterForChroma

ReturnFromSpatialFilterForU:

ENDIF

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4   ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,4
   mov       al,[edx].CodedBlocks
  sub        al,bl
   mov       ecx,TargetFrameBaseAddress
  mov        [edx].CodedBlocks,al
   pop       edi                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        edi,[edx].BlkV.BlkOffset   ; Get address of next macroblock to do.
   mov       ebx,[edx].BlkV.MVs
  add        edi,ecx
   mov       esi,[edx].BlkV.PastRef
IFDEF H261
   mov       ecx,2-256*1        ; cl==2 tells SpatialLoopFilter code to do one
   ;                            ; block.  ch==-1 causes it to return to here.
  mov        TargetMacroBlockBaseAddr,edi  ; Store address of U block.
   mov       al,[edx].BlockType
  cmp        al,INTERSLF
   je        DoSpatialFilterForChroma

ReturnFromSpatialFilterForV:

ENDIF

  call       DoNonOBMCDifferencing

                                 ; (Finish differencing the last four lines.)
  movq       mm4,[edi+ebp*4]     ; T4
   psrlq     mm1,1
  movq       mm5,[edi+PITCH*5]
   psubb     mm4,mm0             ; D4 = T4 - P4
  movq       mm0,[edi+PITCH*6]
   psubb     mm5,mm1
  movq       mm1,[edi+PITCH*7]
   pand      mm2,mm6
  pand       mm3,mm6
   psrlq     mm2,1
  movq       PelDiffsLine4,mm4     ; Store D4.
   psubb     mm0,mm2
  movq       PelDiffsLine5,mm5
   psrlq     mm3,1
  movq       PelDiffsLine6,mm0
   psubb     mm1,mm3
  push       eax                   ; Adjust stack pointer
StackOffset TEXTEQU <4>

  call       MMxDoForwardDCTx      ; Block is in PelDiffs block;  Pitch is 16

  shl        bl,5
   mov       al,[edx].CodedBlocks
  sub        al,bl
   pop       ecx                   ; Adjust stack pointer
StackOffset TEXTEQU <0>
  mov        [edx].CodedBlocks,al
   jmp       IntraCodedChromaProcessingDone

;============================================================================
;  Here we copy the target macroblock, and interpolate left, right, and both.
;  We also accumulate the target pels for each block.  Result is four partial
;  sums in four packed words.  After summing them all up, the final sum will
;  be the sum of the 64 pels of each block, divided by 2.

NextMacroBlock:

  mov        bl,[edx].CodedBlocks
   sub       edx,-SIZEOF T_MacroBlockActionDescr
  and        bl,040H               ; Check for end-of-stream
   jne       Done

FirstMacroBlock:

  mov        edi,TargetFrameBaseAddress
   mov       esi,[edx].BlkY1.BlkOffset   ; Get address of next macroblock to do.
  add        edi,esi
   mov       esi,TargToRef
  add        esi,edi
   mov       TargetMacroBlockBaseAddr,edi
  mov        Addr0MVRef,esi

;============================================================================
; We calculate the 0-motion SWD.  We use 32 match points per block, and
; write the result seperately for each block.  If the SWD for the 0-motion
; vector is below a threshold, we don't bother searching for other possibly
; better motion vectors.
;
;  ebp -- PITCH
;  esi -- Address of ref block.
;  edi -- Address of target block.
;  edx -- MBlockActionStream
;  ecx -- Not used.  Will be linearized MV in non-zero MV search.
;  ebx -- CurrSWDState, i.e. FirstMEState, times 8
;  eax -- Scratch
;  mm7 -- Best SWD for macroblock.
;  mm0-mm6 Scratch
;

   mov       cl,[edx].CodedBlocks        ; Init CBP for macroblock.
  or         cl,03FH                     ; Indicate all 6 blocks are coded.
   mov       eax,DoHeuristicME           ; 0  if unrestricted MVs and heur ME.
   ;                                     ; 14 if restricted MVs and heur ME.
   ;                                     ; 15 if suppressing heuristic ME.
  mov        [edx].