er to the locked list
    WaveOutList * waveOutList = WaveOutList::GetLocked();
    if (!waveOutList)
        return;

    // Quick exit if the list is empty.
    if (waveOutList->Size() == 0)
    {
        waveOutList->Unlock();
        return;
    }

    // We make a duplicate of the list because we cannot call back to the application while
    // the list is locked.  If it is locked, the first WINMM callback will block attempting
    // to add data to the locked list.
    VectorT<WaveOutInfo> waveOutCallbackCopy = *waveOutList;

    // Remove the callback data from the original list
    waveOutList->ClearCallbackData();

    // unlock the list
    waveOutList->Unlock();

    DPFN(
        eDbgLevelInfo, 
        "CallCallbackRoutines Start %d entries.", 
        waveOutCallbackCopy.Size());

    int nEntries = waveOutCallbackCopy.Size();
    for (int i = 0; i < nEntries; ++i)
    {
        WaveOutInfo & woi = waveOutCallbackCopy.Get(i);
        woi.CallCallbackRoutines();
    }
}

//---------------------------------------------------------------------------------------

/*+

  Our version of the WaveCallback routine, all this routine does is to store away
  the callback data, for later use..

--*/
void CALLBACK WaveOutCallback(
  HWAVEOUT hwo,
  UINT uMsg,
  DWORD dwInstance,
  DWORD dwParam1,
  DWORD dwParam2
)
{
    WaveOutList::AddCallbackData(hwo, WinMMCallbackData(uMsg, dwInstance, dwParam1, dwParam2));
}

/*+

  Call waveOutOpen, saving dwCallback if it is a function.

--*/
MMRESULT 
APIHOOK(waveOutOpen)(
    LPHWAVEOUT phwo,
    UINT uDeviceID,
    LPWAVEFORMATEX pwfx,
    DWORD dwCallback,
    DWORD dwCallbackInstance,
    DWORD fdwOpen
    )
{
    WAVE_OUT_CALLBACK * myCallback = &WaveOutCallback;

    MMRESULT returnValue = ORIGINAL_API(waveOutOpen)(
        phwo, 
        uDeviceID, 
        pwfx, 
        (DWORD)myCallback, 
        dwCallbackInstance, 
        fdwOpen);

    if (returnValue == MMSYSERR_NOERROR && (fdwOpen & CALLBACK_FUNCTION))
    {
        WaveOutInfo woi;
        woi.m_DeviceId = *phwo;
        woi.m_OrigCallback = (WAVE_OUT_CALLBACK *)dwCallback;

        WaveOutList::Add(woi);

        LOGN( eDbgLevelError, "waveOutOpen(%d,...) has callback. Added to list.", *phwo);
    }

    return returnValue;
}

/*+

  Call waveOutClose and forget the callback for the device.

--*/
MMRESULT 
APIHOOK(waveOutClose)(
    HWAVEOUT hwo
    )
{
    LOGN( eDbgLevelError, "waveOutClose(%d) called. Remove callback from list.", hwo);

    WaveOutList::RemoveWaveOut(hwo);

    MMRESULT returnValue = ORIGINAL_API(waveOutClose)(hwo);
    return returnValue;
}

//--------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
/*+

  Up to this point, this module is generic; that is going to change.
  The app necessating this fix uses the WM_TIMER message to pump the
  sound system, unfortunately the timer can occur while the game is
  inside the WINMM callback routine, causing a deadlock occurs when this timer
  callback calls a WINMM routine.

--*/
static TIMERPROC g_OrigTimerCallback = NULL;

VOID CALLBACK TimerCallback(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{
    if (g_OrigTimerCallback)
    {
        // Pass all the delayed WINMM timer callback data
        WaveOutList::CallCallbackRoutines();

        // Now call the original callback routine.
        (*g_OrigTimerCallback)(hwnd, uMsg, idEvent, dwTime);
    }
}

/*+

  Substitute our timer routine for theirs.

--*/
UINT_PTR 
APIHOOK(SetTimer)(
    HWND hWnd,              // handle to window
    UINT_PTR nIDEvent,      // timer identifier
    UINT uElapse,           // time-out value
    TIMERPROC lpTimerFunc   // timer procedure
    )
{
    g_OrigTimerCallback = lpTimerFunc;

    LOGN( eDbgLevelError, "SetTimer called. Substitute our timer routine for theirs.");

    UINT_PTR returnValue = ORIGINAL_API(SetTimer)(hWnd, nIDEvent, uElapse, TimerCallback);
    return returnValue;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // Initialize the WaveOutList, fail if we cannot.
        return WaveOutList::Create();
    }

    return TRUE;
}
/*+

  Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(WINMM.DLL, waveOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, waveOutClose)
    APIHOOK_ENTRY(USER32.DLL, SetTimer)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\delaydllinit.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DelayDllInit.cpp

 Abstract:

    This Shim delays the DllInit of given DLLs on the command line until at
    SHIM_STATIC_DLLS_INITIALIZED

    One problem was: Autodesk 3D Studio Mask does the bad thing of creating windows
    during their Splash!DllInit. This is not allowed but works on previous OSes. It
    also works fine on regular US install. But if you enable Far East language
    support, then the IME creates a window on top of the main window and we get in a
    situation where ADVAPI32 is called before it initialized. Solution is simple: 
    delay SPLASH.

    There is a better way to do this, but we would need a callback in NTDLL right after
    it loads KERNEL32.


 History:

    06/11/2001  pierreys    Created
*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DelayDllInit)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

APIHOOK_ENUM_END

#pragma pack(push)
#pragma pack(1)

typedef struct _ENTRYPATCH {
    BYTE    bJmp;
    DWORD   dwRelativeAddress;
} ENTRYPATCH, *PENTRYPATCH;

#pragma pack(pop)

typedef struct _DLLPATCH {
    struct _DLLPATCH    *Next;
    HMODULE             hModule;
    DWORD               dwOldProtection;
    ENTRYPATCH          epSave;
    PENTRYPATCH         pepFix;
} DLLPATCH, *PDLLPATCH;

PDLLPATCH   pDllPatchHead=NULL;

BOOL WINAPI
PatchedDllMain(
    HINSTANCE hinstDll,
    DWORD fdwReason,
    LPVOID lpvReserved
    )
{
    if (fdwReason != DLL_PROCESS_ATTACH)
        LOGN(eDbgLevelError, "PatchDllMain invalidely called");

    return(TRUE);
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{

    PIMAGE_NT_HEADERS   pImageNTHeaders;
    DWORD               dwUnused;
    PDLLPATCH           pDllPatch;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            CSTRING_TRY
            {
                int             i, iDllCount;
                CString         *csArguments;

                CString         csCl(COMMAND_LINE);
                CStringParser   csParser(csCl, L";");

                iDllCount      = csParser.GetCount();
                csArguments    = csParser.ReleaseArgv();

                for (i=0; i<iDllCount; i++)
                {
                    pDllPatch=(PDLLPATCH)LocalAlloc(LMEM_FIXED, sizeof(*pDllPatch));
                    if (pDllPatch)
                    {
                        pDllPatch->hModule=GetModuleHandle(csArguments[i].Get());
                        if (pDllPatch->hModule)
                        {
                            pImageNTHeaders=RtlImageNtHeader(pDllPatch->hModule);
                            if (pImageNTHeaders)
                            {
                                pDllPatch->pepFix=(PENTRYPATCH)((DWORD)(pImageNTHeaders->OptionalHeader.AddressOfEntryPoint)+(DWORD)(pDllPatch->hModule));
                                if (pDllPatch->pepFix)
                                {
                                    if (VirtualProtect(pDllPatch->pepFix, sizeof(*(pDllPatch->pepFix)), PAGE_READWRITE, &(pDllPatch->dwOldProtection)))
                                    {
                                        memcpy(&(pDllPatch->epSave), pDllPatch->pepFix, sizeof(pDllPatch->epSave));

                                        //
                                        // Warning: this is X86 only.
                                        //
                                        pDllPatch->pepFix->bJmp=0xE9;              // 32-bit near relative jump
                                        pDllPatch->pepFix->dwRelativeAddress=(DWORD)PatchedDllMain-(DWORD)(pDllPatch->pepFix)-sizeof(*(pDllPatch->pepFix));

                                        pDllPatch->Next=pDllPatchHead;
                                        pDllPatchHead=pDllPatch;
                                    }
                                    else 
                                    {
                                        LOGN(eDbgLevelError, "Failed to make the DllMain of %S writable", csArguments[i].Get());

                                        return FALSE;
                                    }
                                }
                                else 
                                {
                                    LOGN(eDbgLevelError, "Failed to get the DllMain of %S", csArguments[i].Get());

                                    return FALSE;
                                }
                            }
                            else
                            {
                                LOGN(eDbgLevelError, "Failed to get the header of %S", csArguments[i].Get());

                                return FALSE;
                            }
                        } 
                        else 
                        {
                            LOGN(eDbgLevelError, "Failed to get the %S Dll", csArguments[i].Get());

                            return FALSE;
                        }
                    }
                    else
                    {
                        LOGN(eDbgLevelError, "Failed to allocate memory for %S", csArguments[i].Get());

                        return FALSE;
                    }
                }
            }
            CSTRING_CATCH
            {
                return FALSE;
            }
            break;

        case SHIM_STATIC_DLLS_INITIALIZED:

            if (pDllPatchHead)
            {
                PDLLPATCH   pNextDllPatch;

                for (pDllPatch=pDllPatchHead; pDllPatch; pDllPatch=pNextDllPatch)
                {
                    memcpy(pDllPatch->pepFix, &(pDllPatch->epSave), sizeof(*(pDllPatch->pepFix)));

                    if (!VirtualProtect(pDllPatch->pepFix, sizeof(*(pDllPatch->pepFix)), pDllPatch->dwOldProtection, &dwUnused))
                    {
                        LOGN(eDbgLevelWarning, "Failed to reprotect Dll at %08X", pDllPatch->hModule);
                    }

                    if (!((PDLL_INIT_ROUTINE)(pDllPatch->pepFix))(pDllPatch->hModule, DLL_PROCESS_ATTACH, (PCONTEXT)1))
                    {
                        LOGN(eDbgLevelError, "Failed to initialize Dll at %08X", pDllPatch->hModule);

                        return(FALSE);
                    }

                    pNextDllPatch=pDllPatch->Next;

                    if (!LocalFree(pDllPatch))
                    {
                        LOGN(eDbgLevelWarning, "Failed to free memory Dll at %08X", pDllPatch->hModule);
                    }
                }
            }
            else
            {
                LOGN(eDbgLevelError, "Failed to get Dll list");

                return FALSE;
            }
            break;

    }

    return TRUE;
}



HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\disablefilterkeys.cpp ===
/*++

 Copyright (c) 2001-2002 Microsoft Corporation

 Module Name:

   DisableFilterKeys.cpp

 Abstract:

   This shim disables the Filter Keys Accessibility Option at DLL_PROCESS_ATTACH,
   and re-enables it on termination of the application.

 History:

   06/27/2001 linstev   Created
   02/06/2002 mnikkel   Added check for malloc and SystemParametersInfo failures. 

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableFilterKeys)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

FILTERKEYS g_OldFilterKeyValue;
BOOL g_bInitialize = FALSE;

/*++

 DisableFilterKeys saves the current value for LPFILTERKEYS and then disables the option.

--*/

VOID 
DisableFilterKeys()
{
    if (!g_bInitialize) 
    {
        FILTERKEYS NewFilterKeyValue;

        // Initialize the current and new Filterkey structures
        g_OldFilterKeyValue.cbSize = sizeof(FILTERKEYS);
        NewFilterKeyValue.cbSize = sizeof(FILTERKEYS);
        NewFilterKeyValue.dwFlags = 0;

        // retrieve the current stickykey structure
        if (SystemParametersInfo(SPI_GETFILTERKEYS, sizeof(FILTERKEYS), &g_OldFilterKeyValue, 0))
        {
            // if retrieval of current Filterkey structure was successful then broadcast the settings
            // with the new structure.  This does NOT modify the INI file.
            if (SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), &NewFilterKeyValue, SPIF_SENDCHANGE))
            {
                g_bInitialize = TRUE;
                LOGN( eDbgLevelInfo, "[DisableFilterKeys] Filterkeys disabled.");
            }
            else
            {
                LOGN( eDbgLevelError, "[DisableFilterKeys] Unable to change Filterkey settings!");
            }
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableFilterKeys] Unable to retrieve current Filterkey settings!");
        }
    }
}

/*++

 EnableFilterKeys uses the save value for FILTERKEYS and resets the option to the original setting.

--*/

VOID 
EnableFilterKeys()
{
    if (g_bInitialize)
    {
        g_bInitialize = FALSE;

        // Restore Filterkey original state
        if (SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), &g_OldFilterKeyValue, SPIF_SENDCHANGE))
        {   
            LOGN( eDbgLevelInfo, "[DisableStickyKeys] Filterkey state restored");
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to restore Filterkey settings!");
        }
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        // Turn OFF filter keys
        DisableFilterKeys();
    } else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        // Restore filter keys
        EnableFilterKeys();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\disableboostthread.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DisableBoostThread.cpp

 Abstract:

    DisableBoostThread disables the autoboost that threads get when they
    unblocked. The NT scheduler will normally temporarily boost a thread
    when the synchronization object gets release. 9X does not: it only check
    if there is a higher priority thread.

    This was first written for Hijaak: besied its many memory bugs, as a race 
    condition between its worker thread and its main thread. See b#379504 for details.

 History:

    06/28/2001  pierreys    Created
*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableBoostThread)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateThread)
APIHOOK_ENUM_END

HANDLE
APIHOOK(CreateThread)(
    LPSECURITY_ATTRIBUTES lpsa,
    DWORD cbStack,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpvThreadParm,
    DWORD fdwCreate,
    LPDWORD lpIDThread    
    )
{
    HANDLE  hThread;

    //
    // Call the original API
    //
    hThread=ORIGINAL_API(CreateThread)(
        lpsa,
        cbStack,
        lpStartAddress,
        lpvThreadParm,
        fdwCreate,
        lpIDThread
    );

    if (hThread!=NULL)
    {
        //
        // We are disabling (rather weird, but TRUE means disabling)
        // the autoboost a thread gets for unblocking.
        //
        SetThreadPriorityBoost(hThread, TRUE);
    }

    return(hThread);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason==DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            BOOL fBoostMainThread=FALSE;

            CString csCl(COMMAND_LINE);
            CStringParser csParser(csCl, L" ");
    
            int argc = csParser.GetCount();

            for (int i = 0; i < argc; ++i)
            {
                if (csParser[i] == L"+LowerMainThread")
                {
                    DPFN( eDbgLevelSpew, "LowerMainThread Selected");

                    //
                    // Unboost the main thread to make sure it runs first.
                    //
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);
                }
                else if (csParser[i] == L"+HigherMainThread")
                {
                    DPFN( eDbgLevelSpew, "HigherMainThread Selected");

                    //
                    // Boost the main thread to make sure it runs first.
                    //
                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
                }
                else if (csParser[i] == L"+BoostMainThread")
                {
                    DPFN( eDbgLevelSpew, "HigherMainThread Selected");

                    fBoostMainThread = TRUE;
                }
                else
                {
                    DPFN( eDbgLevelError, "Ignoring unknown command:%S", csParser[i].Get());
                }
    
            }

            if (!fBoostMainThread)
            {
                //
                // We are disabling (rather weird, but TRUE means disabling)
                // the autoboost a thread gets for unblocking.
                //
                SetThreadPriorityBoost(GetCurrentThread(), TRUE);
            }
        }
        CSTRING_CATCH
        {
            DPFN( eDbgLevelError, "String error, ignoring command line");
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateThread)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\derandomizeexename.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DerandomizeExeName.cpp

 Abstract:

    See markder

 History:

    10/13/1999  markder     created.   
    05/16/2000  robkenny    Check for memory alloc failure.
    03/12/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DeRandomizeExeName)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
APIHOOK_ENUM_END

CString * g_csFilePattern = NULL;
CString * g_csNewFileName = NULL;

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR                lpApplicationName,    // name of executable module
    LPSTR                 lpCommandLine,        // command line string
    LPSECURITY_ATTRIBUTES lpProcessAttributes, 
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL                  bInheritHandles,      // handle inheritance flag
    DWORD                 dwCreationFlags,      // creation flags
    LPVOID                lpEnvironment,        // new environment block
    LPCSTR                lpCurrentDirectory,   // current directory name
    LPSTARTUPINFOA        lpStartupInfo, 
    LPPROCESS_INFORMATION lpProcessInformation 
    )
{

    CSTRING_TRY
    {
        AppAndCommandLine appAndCommandLine(lpApplicationName, lpCommandLine);
    
        const CString & csOrigAppName = appAndCommandLine.GetApplicationName();
        CString fileName;
    
        //
        // Grab the filename portion of the string only.
        //
        csOrigAppName.GetLastPathComponent(fileName);
    
        BOOL bMatchesPattern = fileName.PatternMatch(*g_csFilePattern);
        if (bMatchesPattern)
        {
            //
            // Replace the randomized app name with the specified name
            //
            CString csNewAppName(csOrigAppName);
            csNewAppName.Replace(fileName, *g_csNewFileName);
    
            //
            // Copy the exe to the specified name.
            //
            if (CopyFileW(csOrigAppName.Get(), csNewAppName.Get(), FALSE))
            {
    
                LOGN(
                    eDbgLevelInfo,
                    "[CreateProcessA] Derandomized pathname from (%S) to (%S)",
                    csOrigAppName.Get(), csNewAppName.Get());
    
                //
                // Mark the file for deletion after we reboot,
                // otherwise the file will never get removed.
                //
                MoveFileExW(csNewAppName.Get(), NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    
                //
                // We have successfully copied the exe to a new file with the specified name
                // it is now safe to replace the lpApplicationName to our new file.
                //
    
                return ORIGINAL_API(CreateProcessA) (
                                    csNewAppName.GetAnsi(),
                                    lpCommandLine, 
                                    lpProcessAttributes,
                                    lpThreadAttributes,
                                    bInheritHandles,
                                    dwCreationFlags,
                                    lpEnvironment,
                                    lpCurrentDirectory,
                                    lpStartupInfo,
                                    lpProcessInformation);
            }
        }
    }
    CSTRING_CATCH
    {
        // Fall through
    }

    return ORIGINAL_API(CreateProcessA) (
                        lpApplicationName,
                        lpCommandLine, 
                        lpProcessAttributes,
                        lpThreadAttributes,
                        bInheritHandles,
                        dwCreationFlags,
                        lpEnvironment,
                        lpCurrentDirectory,
                        lpStartupInfo,
                        lpProcessInformation);
}

#if TEST_MATCH
void
TestMatch(
    const char* a,
    const char* b
    )
{
    BOOL bMatch = PatternMatchA(a, b);
    
    if (bMatch)
    {
        DPFN(
            eDbgLevelSpew,
            "[TestMatch] (%s) == (%s)\n", a, b);
    }
    else
    {
        DPFN(
            eDbgLevelSpew,
            "[TestMatch] (%s) != (%s)\n", a, b);
    }
}

void TestLots()
{
    TestMatch("", "");
    TestMatch("", "ABC");
    TestMatch("*", "");
    TestMatch("?", "");
    TestMatch("abc", "ABC");
    TestMatch("?", "ABC");
    TestMatch("?bc", "ABC");
    TestMatch("a?c", "ABC");
    TestMatch("ab?", "ABC");
    TestMatch("a??", "ABC");
    TestMatch("?b?", "ABC");
    TestMatch("??c", "ABC");
    TestMatch("???", "ABC");
    TestMatch("*", "ABC");
    TestMatch("*.", "ABC");
    TestMatch("*.", "ABC.");
    TestMatch("*.?", "ABC.");
    TestMatch("??*", "ABC");
    TestMatch("*??", "ABC");
    TestMatch("ABC", "ABC");
    TestMatch(".*", "ABC");
    TestMatch("?*", "ABC");
    TestMatch("???*", "ABC");
    TestMatch("*.txt", "ABC.txt");
    TestMatch("*.txt", ".txt");
    TestMatch("*.txt", ".abc");
    TestMatch("*.txt", "txt.abc");
    TestMatch("***", "");
    TestMatch("***", "a");
    TestMatch("***", "ab");
    TestMatch("***", "abc");
}
#endif


BOOL
ParseCommandLine(void)
{
    CSTRING_TRY
    {
        CStringToken csTok(COMMAND_LINE, ";");

        g_csFilePattern = new CString;
        g_csNewFileName = new CString;

        if (g_csFilePattern &&
            g_csNewFileName && 
            csTok.GetToken(*g_csFilePattern) &&
            csTok.GetToken(*g_csNewFileName))
        {
            return TRUE;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    LOGN(
        eDbgLevelError,
        "[ParseCommandLine] Illegal command line");

    return FALSE;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        #if TEST_MATCH
        TestLots();
        #endif

        return ParseCommandLine();
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
   
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\disablethemes.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    DisableThemes.cpp

 Abstract:

    This shim is for apps that don't support themes.

 Notes:

    This is a general purpose shim.

 History:

    01/15/2001 clupu      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableThemes)
#include "ShimHookMacro.h"

#include "uxtheme.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

void
TurnOffThemes(
    void
    )
{
    LOGN( eDbgLevelError, "[TurnOffThemes] Turning off themes");
    
    SetThemeAppProperties(0);
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        TurnOffThemes();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\disablestickykeys.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   DisableStickyKeys.cpp

 Abstract:

   This shim disables the Sticky Keys Accessibility Option at DLL_PROCESS_ATTACH,
   and re-enables it on termination of the application.

   Some applications, ie. A Bug's Life, have control keys mapped to the shift key.  When the
   key is pressed five consecutive times the option is enabled and they are dumped out to the
   desktop to verify that they want to enable the option.  In the case of A Bug's Life, the
   application errors and terminates when going to the desktop.

 History:

   05/11/2000 jdoherty  Created
   11/06/2000 linstev   Removed User32 dependency on InitializeHooks
   04/01/2001 linstev   Use SHIM_STATIC_DLLS_INITIALIZED callout
   02/06/2002 mnikkel   Added check for malloc and SystemParametersInfo failures. 

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableStickyKeys)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

STICKYKEYS g_OldStickyKeyValue;
BOOL g_bInitialize2 = FALSE;

/*++

 DisableStickyKeys saves the current value for LPSTICKYKEYS and then disables the option.

--*/

VOID 
DisableStickyKeys()
{
    if (!g_bInitialize2)
    {
        STICKYKEYS NewStickyKeyValue;

        // Initialize the current and new Stickykey structures
        g_OldStickyKeyValue.cbSize = sizeof(STICKYKEYS);
        NewStickyKeyValue.cbSize = sizeof(STICKYKEYS);
        NewStickyKeyValue.dwFlags = 0;

        // retrieve the current Stickykey structure
        if (SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(STICKYKEYS), &g_OldStickyKeyValue, 0))
        {
            // if retrieval of current Stickykey structure was successful then broadcast the settings
            // with the new structure.  This does NOT modify the INI file.
            if (SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), &NewStickyKeyValue, SPIF_SENDCHANGE))
            {
                g_bInitialize2 = TRUE;
                LOGN( eDbgLevelInfo, "[DisableStickyKeys] Stickykeys disabled.");
            }
            else
            {
                LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to change Stickykey settings!");
            }
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to retrieve current Stickykey settings!");
        }
    }
}

/*++

 EnableStickyKeys uses the save value for STICKYKEYS and resets the option to the original setting.

--*/

VOID 
EnableStickyKeys()
{
    if (g_bInitialize2) 
    {
        g_bInitialize2 = FALSE;

        // Restore Stickykey original state
        if (SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), &g_OldStickyKeyValue, SPIF_SENDCHANGE))
        {   
            LOGN( eDbgLevelInfo, "[DisableStickyKeys] Sticky key state restored");
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to restore Sticky key settings!");
        }
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        // Turn OFF sticky keys
        DisableStickyKeys();
    } else if (fdwReason == DLL_PROCESS_DETACH)
    {
        // Restore sticky keys
        EnableStickyKeys();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\disablew2kownerdrawbuttonstates.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DisableW2KOwnerDrawButtonStates.cpp

 Abstract:

    Hooks all application-defined window procedures and filters out new
    owner-draw buttons states (introduced in Win2000).

 Notes:

    This shim can be reused for other shims that require WindowProc hooking.
    Copy all APIHook_* functions and simply replace the code in WindowProcHook
    and DialogProcHook.

 History:

    11/01/1999 markder  Created
    02/15/1999 markder  Reworked WndProc hooking mechanism so that it generically
                        hooks all WndProcs for the process.
    11/29/2000 andyseti Converted into GeneralPurpose shim.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableW2KOwnerDrawButtonStates)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(RegisterClassW)
    APIHOOK_ENUM_ENTRY(RegisterClassExA)
    APIHOOK_ENUM_ENTRY(RegisterClassExW)
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamAorW)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(SetWindowLongW)
APIHOOK_ENUM_END


/*++

 Change WM_DRAWITEM behaviour

--*/

LRESULT CALLBACK 
WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    // Check for message we're interested in
    if (uMsg == WM_DRAWITEM)
    {
        if (((LPDRAWITEMSTRUCT) lParam)->itemState &
                ~(ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE)) 
        {
            LOGN(eDbgLevelError, "Removed Win2K-specific Owner-draw button flags.");

            // Remove all Win9x-incompatible owner draw button states.
            ((LPDRAWITEMSTRUCT) lParam)->itemState &=
               (ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE);
        }
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

INT_PTR CALLBACK 
DialogProcHook(
    DLGPROC   pfnOld,   // address of old DialogProc
    HWND      hwndDlg,  // handle to dialog box
    UINT      uMsg,     // message
    WPARAM    wParam,   // first message parameter
    LPARAM    lParam    // second message parameter
    )
{
    // Check for message we're interested in
    if (uMsg == WM_DRAWITEM)
    {
        if (((LPDRAWITEMSTRUCT) lParam)->itemState &
                ~(ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE)) 
        {
            LOGN(eDbgLevelError, "Removed Win2K-specific Owner-draw button flags.");
 
            // Remove all Win9x-incompatible owner draw button states.
            ((LPDRAWITEMSTRUCT) lParam)->itemState &=
               (ODS_SELECTED |
                ODS_GRAYED |
                ODS_DISABLED |
                ODS_CHECKED |
                ODS_FOCUS | 
                ODS_DEFAULT |
                ODS_COMBOBOXEDIT |
                ODS_HOTLIGHT |
                ODS_INACTIVE);
        }
    }

    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

/*++

 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
    )
{
    WNDCLASSA   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, WindowProcHook);
    if( NULL == wcNewWndClass.lpfnWndProc ) {
        DPFN(eDbgLevelInfo, "Failed to hook window proc via RegisterClassA.");
        return ORIGINAL_API(RegisterClassA)(lpWndClass);
    }

    DPFN(eDbgLevelInfo, "Hooked window proc via RegisterClassA.");

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  // class data
    )
{
    WNDCLASSW   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, WindowProcHook);
    if( NULL == wcNewWndClass.lpfnWndProc ) {
        DPFN(eDbgLevelInfo, "Failed to hook window proc via RegisterClassW.");
        return ORIGINAL_API(RegisterClassW)(lpWndClass);
    }

    DPFN( eDbgLevelInfo, "Hooked window proc via RegisterClassW.");

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
    )
{
    WNDCLASSEXA   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, WindowProcHook);
    if( NULL == wcNewWndClass.lpfnWndProc ) {
        DPFN(eDbgLevelInfo, "Failed to hook window proc via RegisterClassExA.");
        return ORIGINAL_API(RegisterClassExA)(lpwcx);
    }


    DPFN( eDbgLevelInfo, "Hooked window proc via RegisterClassExA.");

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  // class data
    )
{
    WNDCLASSEXW   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, WindowProcHook);
    if( NULL == wcNewWndClass.lpfnWndProc ) {
        DPFN(eDbgLevelInfo, "Failed to hook window proc via RegisterClassExW.");
        return ORIGINAL_API(RegisterClassExW)(lpwcx);
    }

    DPFN( eDbgLevelInfo, "Hooked window proc via RegisterClassExW.");

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

HWND
APIHOOK(CreateDialogParamA)(
    HINSTANCE hInstance,     // handle to module
    LPCSTR lpTemplateName,   // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
    )
{
    DLGPROC lpNewDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);
    if( NULL == lpNewDialogFunc ) {
        DPFN( eDbgLevelInfo, "Failed to hook window proc via CreateDialogParamA.");

        return ORIGINAL_API(CreateDialogParamA)(  
            hInstance,
            lpTemplateName,
            hWndParent,
            lpDialogFunc,
            dwInitParam     );
    }

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogParamA.");

    return ORIGINAL_API(CreateDialogParamA)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpNewDialogFunc,
        dwInitParam     );
}

HWND
APIHOOK(CreateDialogParamW)(
    HINSTANCE hInstance,     // handle to module
    LPCWSTR lpTemplateName,  // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
    )
{
    DLGPROC lpNewDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);
    if( NULL == lpNewDialogFunc ) {
        DPFN( eDbgLevelInfo, "Failed to hook window proc via CreateDialogParamW.");

        return ORIGINAL_API(CreateDialogParamW)(  
            hInstance,
            lpTemplateName,
            hWndParent,
            lpDialogFunc,
            dwInitParam     );
    }

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogParamW.");

    return ORIGINAL_API(CreateDialogParamW)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpNewDialogFunc,
        dwInitParam     );
}

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        // handle to module
    LPCDLGTEMPLATE lpTemplate,  // dialog box template
    HWND hWndParent,            // handle to owner window
    DLGPROC lpDialogFunc,       // dialog box procedure
    LPARAM lParamInit           // initialization value
    )
{
    DLGPROC lpNewDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);
    if( NULL == lpNewDialogFunc ) {
        DPFN( eDbgLevelInfo, "Failed to hook window proc via CreateDialogIndirectParamA.");

        return ORIGINAL_API(CreateDialogIndirectParamA)(  
            hInstance,
            lpTemplate,
            hWndParent,
            lpDialogFunc,
            lParamInit     );
    }

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogIndirectParamA.");

    return ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpNewDialogFunc,
        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamW)(
    HINSTANCE hInstance,        // handle to module
    LPCDLGTEMPLATE lpTemplate,  // dialog box template
    HWND hWndParent,            // handle to owner window
    DLGPROC lpDialogFunc,       // dialog box procedure
    LPARAM lParamInit           // initialization value
    )
{
    DLGPROC lpNewDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);
    if( NULL == lpNewDialogFunc ) {
        DPFN( eDbgLevelInfo, "Failed to hook window proc via CreateDialogIndirectParamW.");

        return ORIGINAL_API(CreateDialogIndirectParamW)(  
            hInstance,
            lpTemplate,
            hWndParent,
            lpDialogFunc,
            lParamInit     );
    }

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogIndirectParamW.");

    return ORIGINAL_API(CreateDialogIndirectParamW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpNewDialogFunc,
        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamAorW)(
    HINSTANCE hInstance,        // handle to module
    LPCDLGTEMPLATE lpTemplate,  // dialog box template
    HWND hWndParent,            // handle to owner window
    DLGPROC lpDialogFunc,       // dialog box procedure
    LPARAM lParamInit           // initialization value
    )
{
    DLGPROC lpNewDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook);
    if( NULL == lpNewDialogFunc ) {
        DPFN( eDbgLevelInfo, "Failed to hook window proc via CreateDialogIndirectParamAorW.");

        return ORIGINAL_API(CreateDialogIndirectParamAorW)(  
            hInstance,
            lpTemplate,
            hWndParent,
            lpDialogFunc,
            lParamInit     );
    }

    DPFN( eDbgLevelInfo, "Hooked window proc via CreateDialogIndirectParamAorW.");

    return ORIGINAL_API(CreateDialogIndirectParamAorW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpNewDialogFunc,
        lParamInit     );
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC) 
    {

        LOGN( eDbgLevelError, "Hooked window proc via SetWindowLongA. Pre-hook: 0x%X. ", dwNewLong);

        LONG tmp = (LONG) HookCallback((PVOID)dwNewLong, WindowProcHook);
        if( NULL != tmp) {
            dwNewLong = tmp;
        }

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);

    } 
    else if (nIndex == DWL_DLGPROC) 
    {

        LOGN( eDbgLevelError, "Hooked dialog proc via SetWindowLongA. Pre-hook: 0x%X. ", dwNewLong);

        LONG tmp = (LONG) HookCallback((PVOID)dwNewLong, DialogProcHook);
        if( NULL != tmp) {
            dwNewLong = tmp;
        }

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);
    }

    return ORIGINAL_API(SetWindowLongA)(  
        hWnd,
        nIndex,
        dwNewLong );
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC) 
    {
        LOGN( eDbgLevelError, "Hooked window proc via SetWindowLongW. Pre-hook: 0x%X. ", dwNewLong);

        LONG tmp = (LONG) HookCallback((PVOID)dwNewLong, WindowProcHook);
        if( NULL != tmp) {
            dwNewLong = tmp;
        }

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);
    } 
    else if (nIndex == DWL_DLGPROC) 
    {
        LOGN( eDbgLevelError, "Hooked dialog proc via SetWindowLongW. Pre-hook: 0x%X. ", dwNewLong);

        LONG tmp = (LONG) HookCallback((PVOID)dwNewLong, DialogProcHook);
        if( NULL != tmp) {
            dwNewLong = tmp;
        }

        DPFN( eDbgLevelInfo, "Post-hook: 0x%X.", dwNewLong);
    }

    return ORIGINAL_API(SetWindowLongW)(  
        hWnd,
        nIndex,
        dwNewLong );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW);
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamAorW);
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA);
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\emptyclipboardtoset.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmptyClipboardtoSet.cpp

 Abstract:
 
    Calendar of Ramadan V. 1 calls SetClipboardData with CF_TEXT without 
    emptying the clipboard first.
    
    This shim is app specific

 History:

 05/20/2001 mhamid  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmptyClipboardtoSet)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetClipboardData) 
APIHOOK_ENUM_END

HANDLE 
APIHOOK(SetClipboardData)(
  UINT uFormat,
  HANDLE hMem
			             )
{
	if (uFormat == CF_TEXT)
		EmptyClipboard();
	return ORIGINAL_API(SetClipboardData)(uFormat, hMem);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetClipboardData)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\disablescreensaver.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    DisableScreenSaver.cpp

 Abstract:

    This shim is for apps that do bad things when screen savers are active.

 Notes:

    This is a general purpose shim.

 History:

    02/07/2001 linstev      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DisableScreenSaver)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

// Store the state of the active flag
BOOL g_bActive = TRUE;

BOOL g_bSuccess = FALSE;

/*++

 Turn screen saver off and on again on detach.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        // 
        // Turn OFF screen saver: detect success/failure so we know if we can 
        // safely clean up
        //
        g_bSuccess = SystemParametersInfoA(SPI_GETSCREENSAVEACTIVE, 0, &g_bActive, 0) &&
                     SystemParametersInfoA(SPI_SETSCREENSAVEACTIVE, FALSE, NULL, 0);        

        if (!g_bSuccess) {
            LOGN( eDbgLevelError, "[INIT] Failed to disable screen saver");
        }

    } else if (fdwReason == DLL_PROCESS_DETACH) {
        // 
        // Restore original screen saver state
        //
        if (g_bSuccess) {
            SystemParametersInfoA(SPI_SETSCREENSAVEACTIVE, g_bActive, NULL, 0);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\emulategetstdhandle.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateGetStdHandle.cpp

 Abstract:
 
    Normally, when a process is created, members hStdInput, hStdOutput, and 
    hStdError of STARTUPINFO struct are set to NULL. Some apps like 
    Baby-Sitters Club Activity Center and Baby-Sitters Club 3-rd Grade Disk 2
    may check these handles and send Error messages.
    
    This shim can be used in this case to send appropriate handles and prevent 
    program terminate.

 History:

 06/14/2000 a-vales  created
 11/29/2000 andyseti Converted into AppSpecific shim.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetStdHandle)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetStdHandle) 
APIHOOK_ENUM_END

HANDLE 
APIHOOK(GetStdHandle)(
    DWORD nStdHandle)
{
    HANDLE hStd = ORIGINAL_API(GetStdHandle)(nStdHandle);

    if (hStd == 0)
    {
        switch (nStdHandle)
        {
            case STD_INPUT_HANDLE:
                LOGN( eDbgLevelError, "Correcting GetStdHandle(STD_INPUT_HANDLE). Returning handle = 1.");
                hStd = (HANDLE) 1;
                break;
            case STD_OUTPUT_HANDLE:
                LOGN( eDbgLevelError, "Correcting GetStdHandle(STD_OUTPUT_HANDLE). Returning handle = 2.");
                hStd = (HANDLE) 2;
                break;

            case STD_ERROR_HANDLE:
                LOGN( eDbgLevelError, "Correcting GetStdHandle(STD_ERROR_HANDLE). Returning handle = 3.");
                hStd = (HANDLE) 3;
                break;
        }
    }

    return hStd;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetStdHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\emulategetstringtype.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    EmulateGetStringType.cpp

 Abstract:
    
    This shim emulate Win 2K GetStringType[W,ExW,A,ExA] API behavior.
    There's more than 10k change in Win XP ctype from Win 2K for Unicode 3.0 
    change.

 Notes:

    This is a general shim.

 History:

    06/03/2002 hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetStringType)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetStringTypeW)
    APIHOOK_ENUM_ENTRY(GetStringTypeExW)
    APIHOOK_ENUM_ENTRY(GetStringTypeA)
    APIHOOK_ENUM_ENTRY(GetStringTypeExA)
APIHOOK_ENUM_END

/*++

 Table data imported, sorted and compressed from Win2K 
    \windows\winnls\data\other\ctype.txt.
 Format : WCHAR, CTYPE1, CTYPE2, CTYPE3, # of duplication series

--*/

#define MAXINDEX 1420    // 0 base max
WORD g_ctype[][5] = {
    0x0000, 0x0020, 0x0000, 0x0000, 0x0008,
    0x0009, 0x0068, 0x0009, 0x0008, 0x0000,
    0x000A, 0x0028, 0x0000, 0x0008, 0x0003,
    0x000E, 0x0020, 0x0000, 0x0000, 0x0011,
    0x0020, 0x0048, 0x000A, 0x0048, 0x0000,
    0x0021, 0x0010, 0x000B, 0x0048, 0x0000,
    0x0022, 0x0010, 0x000B, 0x0448, 0x0000,
    0x0023, 0x0010, 0x0005, 0x0048, 0x0000,
    0x0024, 0x0010, 0x0005, 0x0448, 0x0000,
    0x0025, 0x0010, 0x0005, 0x0048, 0x0000,
    0x0026, 0x0010, 0x0001, 0x0048, 0x0000,
    0x0027, 0x0010, 0x000B, 0x0440, 0x0000,
    0x0028, 0x0010, 0x000B, 0x0048, 0x0002,
    0x002B, 0x0010, 0x0005, 0x0048, 0x0000,
    0x002C, 0x0010, 0x0007, 0x0048, 0x0000,
    0x002D, 0x0010, 0x0005, 0x0440, 0x0000,
    0x002E, 0x0010, 0x0004, 0x0048, 0x0000,
    0x002F, 0x0010, 0x0004, 0x0448, 0x0000,
    0x0030, 0x0084, 0x0003, 0x0040, 0x0009,
    0x003A, 0x0010, 0x0007, 0x0048, 0x0000,
    0x003B, 0x0010, 0x000B, 0x0048, 0x0001,
    0x003D, 0x0010, 0x000B, 0x0448, 0x0000,
    0x003E, 0x0010, 0x000B, 0x0048, 0x0001,
    0x0040, 0x0010, 0x0001, 0x0448, 0x0000,
    0x0041, 0x0181, 0x0001, 0x8040, 0x0005,
    0x0047, 0x0101, 0x0001, 0x8040, 0x0013,
    0x005B, 0x0010, 0x000B, 0x0048, 0x0000,
    0x005C, 0x0010, 0x000B, 0x0448, 0x0000,
    0x005D, 0x0010, 0x000B, 0x0048, 0x0000,
    0x005E, 0x0010, 0x000B, 0x0448, 0x0002,
    0x0061, 0x0182, 0x0001, 0x8040, 0x0005,
    0x0067, 0x0102, 0x0001, 0x8040, 0x0013,
    0x007B, 0x0010, 0x000B, 0x0048, 0x0002,
    0x007E, 0x0010, 0x000B, 0x0448, 0x0000,
    0x007F, 0x0020, 0x0000, 0x0000, 0x0020,
    0x00A0, 0x0048, 0x000A, 0x0008, 0x0000,
    0x00A1, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00A2, 0x0010, 0x0005, 0x0048, 0x0001,
    0x00A4, 0x0010, 0x0005, 0x0008, 0x0000,
    0x00A5, 0x0010, 0x0005, 0x0048, 0x0000,
    0x00A6, 0x0010, 0x000B, 0x0048, 0x0000,
    0x00A7, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00A8, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00A9, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00AA, 0x0010, 0x000B, 0x0400, 0x0000,
    0x00AB, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00AC, 0x0010, 0x000B, 0x0048, 0x0000,
    0x00AD, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00AE, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00AF, 0x0010, 0x000B, 0x0448, 0x0000,
    0x00B0, 0x0010, 0x0005, 0x0008, 0x0001,
    0x00B2, 0x0014, 0x0003, 0x0000, 0x0001,
    0x00B4, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00B5, 0x0010, 0x000B, 0x0008, 0x0002,
    0x00B8, 0x0010, 0x000B, 0x0408, 0x0000,
    0x00B9, 0x0014, 0x0003, 0x0000, 0x0000,
    0x00BA, 0x0010, 0x000B, 0x0400, 0x0000,
    0x00BB, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00BC, 0x0010, 0x000B, 0x0000, 0x0002,
    0x00BF, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00C0, 0x0101, 0x0001, 0x8003, 0x0005,
    0x00C6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x00C7, 0x0101, 0x0001, 0x8003, 0x0008,
    0x00D0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x00D1, 0x0101, 0x0001, 0x8003, 0x0005,
    0x00D7, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00D8, 0x0101, 0x0001, 0x8003, 0x0005,
    0x00DE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x00DF, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00E0, 0x0102, 0x0001, 0x8003, 0x0005,
    0x00E6, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00E7, 0x0102, 0x0001, 0x8003, 0x0008,
    0x00F0, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00F1, 0x0102, 0x0001, 0x8003, 0x0005,
    0x00F7, 0x0010, 0x000B, 0x0008, 0x0000,
    0x00F8, 0x0102, 0x0001, 0x8003, 0x0005,
    0x00FE, 0x0102, 0x0001, 0x8000, 0x0000,
    0x00FF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0100, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0101, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0102, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0103, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0104, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0105, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0106, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0107, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0108, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0109, 0x0102, 0x0001, 0x8003, 0x0000,
    0x010A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x010B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x010C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x010D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x010E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x010F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0110, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0111, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0112, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0113, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0114, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0115, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0116, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0117, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0118, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0119, 0x0102, 0x0001, 0x8003, 0x0000,
    0x011A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x011B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x011C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x011D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x011E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x011F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0120, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0121, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0122, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0123, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0124, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0125, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0126, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0127, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0128, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0129, 0x0102, 0x0001, 0x8003, 0x0000,
    0x012A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x012B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x012C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x012D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x012E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x012F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0130, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0131, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0132, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0133, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0134, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0135, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0136, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0137, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0138, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0139, 0x0101, 0x0001, 0x8003, 0x0000,
    0x013A, 0x0102, 0x0001, 0x8003, 0x0000,
    0x013B, 0x0101, 0x0001, 0x8003, 0x0000,
    0x013C, 0x0102, 0x0001, 0x8003, 0x0000,
    0x013D, 0x0101, 0x0001, 0x8003, 0x0000,
    0x013E, 0x0102, 0x0001, 0x8003, 0x0000,
    0x013F, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0140, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0141, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0142, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0143, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0144, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0145, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0146, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0147, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0148, 0x0102, 0x0001, 0x8003, 0x0001,
    0x014A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x014B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x014C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x014D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x014E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x014F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0150, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0151, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0152, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0153, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0154, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0155, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0156, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0157, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0158, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0159, 0x0102, 0x0001, 0x8003, 0x0000,
    0x015A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x015B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x015C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x015D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x015E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x015F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0160, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0161, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0162, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0163, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0164, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0165, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0166, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0167, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0168, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0169, 0x0102, 0x0001, 0x8003, 0x0000,
    0x016A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x016B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x016C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x016D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x016E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x016F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0170, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0171, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0172, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0173, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0174, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0175, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0176, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0177, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0178, 0x0101, 0x0001, 0x8003, 0x0001,
    0x017A, 0x0102, 0x0001, 0x8003, 0x0000,
    0x017B, 0x0101, 0x0001, 0x8003, 0x0000,
    0x017C, 0x0102, 0x0001, 0x8003, 0x0000,
    0x017D, 0x0101, 0x0001, 0x8003, 0x0000,
    0x017E, 0x0102, 0x0001, 0x8003, 0x0000,
    0x017F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0180, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0181, 0x0101, 0x0001, 0x8000, 0x0001,
    0x0183, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0184, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0185, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0186, 0x0101, 0x0001, 0x8000, 0x0001,
    0x0188, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0189, 0x0101, 0x0001, 0x8000, 0x0002,
    0x018C, 0x0102, 0x0001, 0x8000, 0x0001,
    0x018E, 0x0101, 0x0001, 0x8000, 0x0003,
    0x0192, 0x0112, 0x0001, 0x8000, 0x0000,
    0x0193, 0x0101, 0x0001, 0x8000, 0x0001,
    0x0195, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0196, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0197, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0198, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0199, 0x0102, 0x0001, 0x8000, 0x0000,
    0x019A, 0x0102, 0x0001, 0x8003, 0x0001,
    0x019C, 0x0101, 0x0001, 0x8000, 0x0001,
    0x019E, 0x0102, 0x0001, 0x8000, 0x0000,
    0x019F, 0x0101, 0x0001, 0x8003, 0x0001,
    0x01A1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01A2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01A3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01A4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01A5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01A6, 0x0100, 0x0001, 0x8000, 0x0000,
    0x01A7, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01A8, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01A9, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01AA, 0x0100, 0x0001, 0x8000, 0x0000,
    0x01AB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01AC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01AD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01AE, 0x0101, 0x0001, 0x8003, 0x0001,
    0x01B0, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01B1, 0x0101, 0x0001, 0x8000, 0x0002,
    0x01B4, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01B5, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01B6, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01B7, 0x0101, 0x0001, 0x8000, 0x0001,
    0x01B9, 0x0102, 0x0001, 0x8000, 0x0001,
    0x01BB, 0x0100, 0x0001, 0x8000, 0x0000,
    0x01BC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01BD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01BE, 0x0100, 0x0001, 0x8000, 0x0001,
    0x01C0, 0x0100, 0x0001, 0x8008, 0x0003,
    0x01C4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01C5, 0x0103, 0x0001, 0x8003, 0x0000,
    0x01C6, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01C7, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01C8, 0x0103, 0x0001, 0x8000, 0x0000,
    0x01C9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01CA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01CB, 0x0103, 0x0001, 0x8000, 0x0000,
    0x01CC, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01CD, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01CE, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01CF, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D0, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D1, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D2, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D3, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D4, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D5, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D6, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D7, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01D8, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01D9, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01DA, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01DB, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01DC, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01DD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01DE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01DF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01E8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01E9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01EA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01EB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01EC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01ED, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01EE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01EF, 0x0102, 0x0001, 0x8003, 0x0001,
    0x01F1, 0x0101, 0x0001, 0x8000, 0x0000,
    0x01F2, 0x0103, 0x0001, 0x8000, 0x0000,
    0x01F3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x01F4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01F5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01FA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01FB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01FC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01FD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x01FE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x01FF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0200, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0201, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0202, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0203, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0204, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0205, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0206, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0207, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0208, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0209, 0x0102, 0x0001, 0x8003, 0x0000,
    0x020A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x020B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x020C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x020D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x020E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x020F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0210, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0211, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0212, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0213, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0214, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0215, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0216, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0217, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0250, 0x0102, 0x0001, 0x8000, 0x0011,
    0x0262, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0263, 0x0102, 0x0001, 0x8000, 0x0004,
    0x0268, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0269, 0x0102, 0x0001, 0x8000, 0x0000,
    0x026A, 0x0100, 0x0001, 0x8000, 0x0000,
    0x026B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x026C, 0x0102, 0x0001, 0x8000, 0x0007,
    0x0274, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0275, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0276, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0277, 0x0102, 0x0001, 0x8000, 0x0008,
    0x0280, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0282, 0x0102, 0x0001, 0x8000, 0x000C,
    0x028F, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0290, 0x0102, 0x0001, 0x8000, 0x0003,
    0x0294, 0x0100, 0x0001, 0x8000, 0x0005,
    0x029A, 0x0102, 0x0001, 0x8000, 0x0000,
    0x029B, 0x0100, 0x0001, 0x8000, 0x0001,
    0x029D, 0x0102, 0x0001, 0x8000, 0x0001,
    0x029F, 0x0100, 0x0001, 0x8000, 0x0000,
    0x02A0, 0x0102, 0x0001, 0x8000, 0x0000,
    0x02A1, 0x0100, 0x0001, 0x8000, 0x0001,
    0x02A3, 0x0102, 0x0001, 0x8000, 0x0005,
    0x02B0, 0x0010, 0x0001, 0x0400, 0x0008,
    0x02B9, 0x0010, 0x0001, 0x0001, 0x0002,
    0x02BC, 0x0010, 0x0001, 0x0401, 0x0000,
    0x02BD, 0x0010, 0x0001, 0x0001, 0x0009,
    0x02C7, 0x0010, 0x0001, 0x0401, 0x0000,
    0x02C8, 0x0010, 0x0001, 0x0001, 0x0001,
    0x02CA, 0x0010, 0x0001, 0x0401, 0x0001,
    0x02CC, 0x0010, 0x0001, 0x0001, 0x0002,
    0x02CF, 0x0010, 0x0001, 0x0401, 0x0000,
    0x02D0, 0x0010, 0x0001, 0x0001, 0x0007,
    0x02D8, 0x0010, 0x0001, 0x0408, 0x0005,
    0x02DE, 0x0010, 0x0001, 0x0001, 0x0000,
    0x02E0, 0x0010, 0x0001, 0x0400, 0x0003,
    0x02E4, 0x0010, 0x0001, 0x0001, 0x0005,
    0x0300, 0x0010, 0x0001, 0x0003, 0x0045,
    0x0360, 0x0010, 0x0001, 0x0003, 0x0001,
    0x0374, 0x0010, 0x0001, 0x0000, 0x0001,
    0x037A, 0x0010, 0x0001, 0x0408, 0x0000,
    0x037E, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0384, 0x0010, 0x0001, 0x0408, 0x0001,
    0x0386, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0387, 0x0010, 0x0001, 0x0408, 0x0000,
    0x0388, 0x0101, 0x0001, 0x8003, 0x0002,
    0x038C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x038E, 0x0101, 0x0001, 0x8003, 0x0001,
    0x0390, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0391, 0x0101, 0x0001, 0x8000, 0x0010,
    0x03A3, 0x0101, 0x0001, 0x8000, 0x0006,
    0x03AA, 0x0101, 0x0001, 0x8003, 0x0001,
    0x03AC, 0x0102, 0x0001, 0x8003, 0x0004,
    0x03B1, 0x0102, 0x0001, 0x8000, 0x0018,
    0x03CA, 0x0102, 0x0001, 0x8003, 0x0004,
    0x03D0, 0x0102, 0x0001, 0x8000, 0x0001,
    0x03D2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03D3, 0x0101, 0x0001, 0x8003, 0x0001,
    0x03D5, 0x0102, 0x0001, 0x8000, 0x0001,
    0x03DA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03DC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03DE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03E4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03E6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E7, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03E8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03E9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03EA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03EB, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03EC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03ED, 0x0102, 0x0001, 0x8000, 0x0000,
    0x03EE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x03EF, 0x0102, 0x0001, 0x8000, 0x0004,
    0x0401, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0402, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0403, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0404, 0x0101, 0x0001, 0x8000, 0x0002,
    0x0407, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0408, 0x0101, 0x0001, 0x8000, 0x0003,
    0x040C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x040E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x040F, 0x0101, 0x0001, 0x8000, 0x0009,
    0x0419, 0x0101, 0x0001, 0x8003, 0x0000,
    0x041A, 0x0101, 0x0001, 0x8000, 0x0015,
    0x0430, 0x0102, 0x0001, 0x8000, 0x0008,
    0x0439, 0x0102, 0x0001, 0x8003, 0x0000,
    0x043A, 0x0102, 0x0001, 0x8000, 0x0015,
    0x0451, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0452, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0453, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0454, 0x0102, 0x0001, 0x8000, 0x0002,
    0x0457, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0458, 0x0102, 0x0001, 0x8000, 0x0003,
    0x045C, 0x0102, 0x0001, 0x8003, 0x0000,
    0x045E, 0x0102, 0x0001, 0x8003, 0x0000,
    0x045F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0460, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0461, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0462, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0463, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0464, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0465, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0466, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0467, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0468, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0469, 0x0102, 0x0001, 0x8000, 0x0000,
    0x046A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x046B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x046C, 0x0101, 0x0001, 0x8000, 0x0000,
    0x046D, 0x0102, 0x0001, 0x8000, 0x0000,
    0x046E, 0x0101, 0x0001, 0x8000, 0x0000,
    0x046F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0470, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0471, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0472, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0473, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0474, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0475, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0476, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0477, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0478, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0479, 0x0102, 0x0001, 0x8000, 0x0000,
    0x047A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x047B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x047C, 0x0101, 0x0001, 0x8000, 0x0000,
    0x047D, 0x0102, 0x0001, 0x8000, 0x0000,
    0x047E, 0x0101, 0x0001, 0x8000, 0x0000,
    0x047F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0480, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0481, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0482, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0483, 0x0010, 0x0001, 0x0003, 0x0003,
    0x0490, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0491, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0492, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0493, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0494, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0495, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0496, 0x0101, 0x0001, 0x8000, 0x0000,
    0x0497, 0x0102, 0x0001, 0x8000, 0x0000,
    0x0498, 0x0101, 0x0001, 0x8003, 0x0000,
    0x0499, 0x0102, 0x0001, 0x8003, 0x0000,
    0x049A, 0x0101, 0x0001, 0x8000, 0x0000,
    0x049B, 0x0102, 0x0001, 0x8000, 0x0000,
    0x049C, 0x0101, 0x0001, 0x8000, 0x0000,
    0x049D, 0x0102, 0x0001, 0x8000, 0x0000,
    0x049E, 0x0101, 0x0001, 0x8000, 0x0000,
    0x049F, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A1, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A7, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04A8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04A9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04AA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04AB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04AC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04AD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04AE, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04AF, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04B1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04B2, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B3, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B6, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B7, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04B8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04B9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04BA, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04BB, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04BC, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04BD, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04BE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04BF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04C0, 0x0100, 0x0001, 0x8000, 0x0000,
    0x04C1, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04C2, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04C3, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04C4, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04C7, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04C8, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04CB, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04CC, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04D0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04D1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04D2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04D3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04D4, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04D5, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04D6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04D7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04D8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04D9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04DA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04DB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04DC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04DD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04DE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04DF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E0, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04E1, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04E2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04E3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04E5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04E7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04E8, 0x0101, 0x0001, 0x8000, 0x0000,
    0x04E9, 0x0102, 0x0001, 0x8000, 0x0000,
    0x04EA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04EB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04EE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04EF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x04F8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x04F9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x0531, 0x0101, 0x0001, 0x8000, 0x0025,
    0x0559, 0x0010, 0x0001, 0x0401, 0x0001,
    0x055B, 0x0010, 0x0001, 0x0008, 0x0004,
    0x0561, 0x0102, 0x0001, 0x8000, 0x0026,
    0x0589, 0x0010, 0x0001, 0x0008, 0x0000,
    0x0591, 0x0010, 0x0002, 0x0003, 0x0010,
    0x05A3, 0x0010, 0x0002, 0x0003, 0x001A,
    0x05BE, 0x0010, 0x0002, 0x0008, 0x0000,
    0x05BF, 0x0010, 0x0002, 0x0003, 0x0000,
    0x05C0, 0x0010, 0x0002, 0x0008, 0x0000,
    0x05C1, 0x0010, 0x0002, 0x0003, 0x0001,
    0x05C3, 0x0010, 0x0002, 0x0008, 0x0000,
    0x05C4, 0x0010, 0x0002, 0x0003, 0x0000,
    0x05D0, 0x0100, 0x0002, 0x8000, 0x001A,
    0x05F0, 0x0100, 0x0002, 0x8000, 0x0002,
    0x05F3, 0x0010, 0x0002, 0x0008, 0x0001,
    0x060C, 0x0010, 0x0002, 0x0008, 0x0000,
    0x061B, 0x0010, 0x0002, 0x0008, 0x0000,
    0x061F, 0x0010, 0x0002, 0x0008, 0x0000,
    0x0621, 0x0100, 0x0002, 0x8000, 0x0019,
    0x0640, 0x0010, 0x0002, 0x0601, 0x0000,
    0x0641, 0x0100, 0x0002, 0x8000, 0x0009,
    0x064B, 0x0010, 0x0002, 0x0003, 0x0007,
    0x0660, 0x0004, 0x0006, 0x0000, 0x0009,
    0x066A, 0x0010, 0x0005, 0x0008, 0x0000,
    0x066B, 0x0010, 0x0007, 0x0008, 0x0001,
    0x066D, 0x0010, 0x0002, 0x0008, 0x0000,
    0x0670, 0x0010, 0x0002, 0x0003, 0x0000,
    0x0671, 0x0100, 0x0002, 0x8000, 0x0046,
    0x06BA, 0x0100, 0x0002, 0x8000, 0x0004,
    0x06C0, 0x0100, 0x0002, 0x8000, 0x000E,
    0x06D0, 0x0100, 0x0002, 0x8000, 0x0003,
    0x06D4, 0x0010, 0x0002, 0x0008, 0x0000,
    0x06D5, 0x0100, 0x0002, 0x8000, 0x0000,
    0x06D6, 0x0010, 0x0002, 0x0001, 0x0012,
    0x06E9, 0x0010, 0x0002, 0x0008, 0x0000,
    0x06EA, 0x0010, 0x0002, 0x0001, 0x0003,
    0x06F0, 0x0004, 0x0003, 0x0000, 0x0009,
    0x0901, 0x0010, 0x0001, 0x0001, 0x0002,
    0x0905, 0x0100, 0x0001, 0x8000, 0x0034,
    0x093C, 0x0010, 0x0001, 0x0001, 0x0000,
    0x093D, 0x0010, 0x0001, 0x0000, 0x0000,
    0x093E, 0x0010, 0x0001, 0x0005, 0x000E,
    0x094D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0950, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0951, 0x0010, 0x0001, 0x0001, 0x0003,
    0x0958, 0x0100, 0x0001, 0x8000, 0x0009,
    0x0962, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0964, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0966, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0970, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0981, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0982, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0985, 0x0100, 0x0001, 0x8000, 0x0007,
    0x098F, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0993, 0x0100, 0x0001, 0x8000, 0x0015,
    0x09AA, 0x0100, 0x0001, 0x8000, 0x0006,
    0x09B2, 0x0100, 0x0001, 0x8000, 0x0000,
    0x09B6, 0x0100, 0x0001, 0x8000, 0x0003,
    0x09BC, 0x0010, 0x0001, 0x0001, 0x0000,
    0x09BE, 0x0010, 0x0001, 0x0004, 0x0002,
    0x09C1, 0x0010, 0x0001, 0x0005, 0x0003,
    0x09C7, 0x0010, 0x0001, 0x0004, 0x0001,
    0x09CB, 0x0010, 0x0001, 0x0004, 0x0001,
    0x09CD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x09D7, 0x0010, 0x0001, 0x0000, 0x0000,
    0x09DC, 0x0100, 0x0001, 0x8000, 0x0001,
    0x09DF, 0x0100, 0x0001, 0x8000, 0x0002,
    0x09E2, 0x0010, 0x0001, 0x0005, 0x0001,
    0x09E6, 0x0004, 0x0001, 0x0000, 0x0009,
    0x09F0, 0x0100, 0x0001, 0x8000, 0x0001,
    0x09F2, 0x0010, 0x0001, 0x0000, 0x0008,
    0x0A02, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0A05, 0x0100, 0x0001, 0x8000, 0x0005,
    0x0A0F, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A13, 0x0100, 0x0001, 0x8000, 0x0015,
    0x0A2A, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0A32, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A35, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A38, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0A3C, 0x0010, 0x0001, 0x0005, 0x0000,
    0x0A3E, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0A40, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0A41, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0A47, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0A4B, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0A4D, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0A59, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0A5E, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0A66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0A70, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0A72, 0x0010, 0x0001, 0x0000, 0x0002,
    0x0A81, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0A83, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0A85, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0A8D, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0A8F, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0A93, 0x0100, 0x0001, 0x8000, 0x0015,
    0x0AAA, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0AB2, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0AB5, 0x0100, 0x0001, 0x8000, 0x0004,
    0x0ABC, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0ABD, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0ABE, 0x0010, 0x0001, 0x0004, 0x0002,
    0x0AC1, 0x0010, 0x0001, 0x0005, 0x0004,
    0x0AC7, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0AC9, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0ACB, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0ACD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0AD0, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0AE0, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0AE6, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0B01, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0B02, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B05, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0B0F, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B13, 0x0100, 0x0001, 0x8000, 0x0015,
    0x0B2A, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0B32, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B36, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0B3C, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0B3D, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B3F, 0x0010, 0x0001, 0x0005, 0x0000,
    0x0B40, 0x0010, 0x0001, 0x0004, 0x0000,
    0x0B41, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0B47, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0B4B, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0B4D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0B56, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B5C, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B5F, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0B66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0B70, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0B82, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0B85, 0x0100, 0x0001, 0x8000, 0x0005,
    0x0B8E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0B92, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0B99, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0B9C, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0B9E, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0BA3, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0BA8, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0BAE, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0BB7, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0BBE, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0BC0, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0BC6, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0BCA, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0BCD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0BD7, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0BE7, 0x0004, 0x0001, 0x0000, 0x000B,
    0x0C01, 0x0010, 0x0001, 0x0000, 0x0002,
    0x0C05, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0C0E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0C12, 0x0100, 0x0001, 0x8000, 0x0016,
    0x0C2A, 0x0100, 0x0001, 0x8000, 0x0009,
    0x0C35, 0x0100, 0x0001, 0x8000, 0x0004,
    0x0C3E, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0C41, 0x0010, 0x0001, 0x0004, 0x0003,
    0x0C46, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0C4A, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0C4D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0C55, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0C60, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0C66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0C82, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0C85, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0C8E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0C92, 0x0100, 0x0001, 0x8000, 0x0016,
    0x0CAA, 0x0100, 0x0001, 0x8000, 0x0009,
    0x0CB5, 0x0100, 0x0001, 0x8000, 0x0004,
    0x0CBE, 0x0010, 0x0001, 0x0004, 0x0000,
    0x0CBF, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0CC1, 0x0010, 0x0001, 0x0004, 0x0003,
    0x0CC6, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0CCA, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0CCD, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0CD5, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0CDE, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0CE0, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0CE6, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0D02, 0x0010, 0x0001, 0x0000, 0x0001,
    0x0D05, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0D0E, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0D12, 0x0100, 0x0001, 0x8000, 0x0016,
    0x0D2A, 0x0100, 0x0001, 0x8000, 0x000F,
    0x0D3E, 0x0010, 0x0001, 0x0004, 0x0002,
    0x0D41, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0D46, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0D4A, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0D4D, 0x0010, 0x0001, 0x0001, 0x0000,
    0x0D57, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0D60, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0D66, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0E01, 0x0100, 0x0001, 0x8000, 0x0022,
    0x0E24, 0x0100, 0x0001, 0x8004, 0x0000,
    0x0E25, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E26, 0x0100, 0x0001, 0x8004, 0x0000,
    0x0E27, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0E2F, 0x0100, 0x0001, 0x0008, 0x0000,
    0x0E30, 0x0100, 0x0001, 0x8004, 0x0000,
    0x0E31, 0x0100, 0x0001, 0x0005, 0x0000,
    0x0E32, 0x0100, 0x0001, 0x8004, 0x0001,
    0x0E34, 0x0100, 0x0001, 0x0005, 0x0005,
    0x0E3A, 0x0100, 0x0001, 0x0003, 0x0000,
    0x0E3F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x0E40, 0x0100, 0x0001, 0x8004, 0x0005,
    0x0E46, 0x0100, 0x0001, 0x0008, 0x0000,
    0x0E47, 0x0100, 0x0001, 0x0003, 0x0000,
    0x0E48, 0x0100, 0x0001, 0x0001, 0x0003,
    0x0E4C, 0x0100, 0x0001, 0x0003, 0x0002,
    0x0E4F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x0E50, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0E5A, 0x0010, 0x0001, 0x0008, 0x0001,
    0x0E81, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0E84, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E87, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0E8A, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E8D, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0E94, 0x0100, 0x0001, 0x8000, 0x0003,
    0x0E99, 0x0100, 0x0001, 0x8000, 0x0006,
    0x0EA1, 0x0100, 0x0001, 0x8000, 0x0002,
    0x0EA5, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0EA7, 0x0100, 0x0001, 0x8000, 0x0000,
    0x0EAA, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0EAD, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0EAF, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0EB0, 0x0010, 0x0001, 0x0004, 0x0000,
    0x0EB1, 0x0010, 0x0001, 0x0005, 0x0000,
    0x0EB2, 0x0010, 0x0001, 0x0004, 0x0001,
    0x0EB4, 0x0010, 0x0001, 0x0005, 0x0005,
    0x0EBB, 0x0010, 0x0001, 0x0005, 0x0002,
    0x0EC0, 0x0010, 0x0001, 0x0005, 0x0004,
    0x0EC6, 0x0010, 0x0001, 0x0000, 0x0000,
    0x0EC8, 0x0010, 0x0001, 0x0001, 0x0005,
    0x0ED0, 0x0004, 0x0001, 0x0000, 0x0009,
    0x0EDC, 0x0100, 0x0001, 0x8000, 0x0001,
    0x0F00, 0x0010, 0x0001, 0x0000, 0x0017,
    0x0F18, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0F1A, 0x0010, 0x0001, 0x0000, 0x0005,
    0x0F20, 0x0004, 0x0001, 0x0000, 0x0013,
    0x0F34, 0x0010, 0x0001, 0x0000, 0x000B,
    0x0F40, 0x0100, 0x0001, 0x8000, 0x0007,
    0x0F49, 0x0100, 0x0001, 0x8000, 0x0020,
    0x0F71, 0x0010, 0x0001, 0x0005, 0x000C,
    0x0F7E, 0x0010, 0x0001, 0x0001, 0x0001,
    0x0F80, 0x0010, 0x0001, 0x0005, 0x0001,
    0x0F82, 0x0010, 0x0001, 0x0001, 0x0009,
    0x0F90, 0x0100, 0x0001, 0x0001, 0x0005,
    0x0F97, 0x0100, 0x0001, 0x0001, 0x0000,
    0x0F99, 0x0100, 0x0001, 0x0001, 0x0014,
    0x0FB1, 0x0100, 0x0001, 0x0001, 0x0006,
    0x0FB9, 0x0100, 0x0001, 0x0001, 0x0000,
    0x10A0, 0x0101, 0x0001, 0x8000, 0x0025,
    0x10D0, 0x0102, 0x0001, 0x8000, 0x0026,
    0x10FB, 0x0010, 0x0001, 0x0000, 0x0000,
    0x1100, 0x0100, 0x0001, 0x8000, 0x0059,
    0x115F, 0x0100, 0x0001, 0x8000, 0x0043,
    0x11A8, 0x0100, 0x0001, 0x8000, 0x0051,
    0x1E00, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E01, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E02, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E03, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E04, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E05, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E06, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E07, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E08, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E09, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E0A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E0B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E0C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E0D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E0E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E0F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E10, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E11, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E12, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E13, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E14, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E15, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E16, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E17, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E18, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E19, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E1A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E1B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E1C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E1D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E1E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E1F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E20, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E21, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E22, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E23, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E24, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E25, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E26, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E27, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E28, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E29, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E2A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E2B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E2C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E2D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E2E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E2F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E30, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E31, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E32, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E33, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E34, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E35, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E36, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E37, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E38, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E39, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E3A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E3B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E3C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E3D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E3E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E3F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E40, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E41, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E42, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E43, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E44, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E45, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E46, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E47, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E48, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E49, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E4A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E4B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E4C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E4D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E4E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E4F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E50, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E51, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E52, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E53, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E54, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E55, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E56, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E57, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E58, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E59, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E5A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E5B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E5C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E5D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E5E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E5F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E60, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E61, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E62, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E63, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E64, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E65, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E66, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E67, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E68, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E69, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E6A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E6B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E6C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E6D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E6E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E6F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E70, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E71, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E72, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E73, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E74, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E75, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E76, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E77, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E78, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E79, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E7A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E7B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E7C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E7D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E7E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E7F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E80, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E81, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E82, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E83, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E84, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E85, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E86, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E87, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E88, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E89, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E8A, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E8B, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E8C, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E8D, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E8E, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E8F, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E90, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E91, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E92, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E93, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1E94, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1E95, 0x0102, 0x0001, 0x8003, 0x0006,
    0x1EA0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EA8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EA9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EAA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EAB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EAC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EAD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EAE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EAF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EB8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EB9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EBA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EBB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EBC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EBD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EBE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EBF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EC8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EC9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ECA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ECB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ECC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ECD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ECE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ECF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1ED8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1ED9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EDA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EDB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EDC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EDD, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EDE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EDF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EE8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EE9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EEA, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EEB, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EEC, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EED, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EEE, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EEF, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF0, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF1, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF2, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF3, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF4, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF5, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF6, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF7, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1EF8, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1EF9, 0x0102, 0x0001, 0x8003, 0x0000,
    0x1F00, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F08, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F10, 0x0102, 0x0001, 0x8003, 0x0005,
    0x1F18, 0x0101, 0x0001, 0x8003, 0x0005,
    0x1F20, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F28, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F30, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F38, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F40, 0x0102, 0x0001, 0x8003, 0x0005,
    0x1F48, 0x0101, 0x0001, 0x8003, 0x0005,
    0x1F50, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F59, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F5B, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F5D, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F5F, 0x0101, 0x0001, 0x8003, 0x0000,
    0x1F60, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F68, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F70, 0x0102, 0x0001, 0x8003, 0x000D,
    0x1F80, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F88, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1F90, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1F98, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1FA0, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1FA8, 0x0101, 0x0001, 0x8003, 0x0007,
    0x1FB0, 0x0102, 0x0001, 0x8003, 0x0004,
    0x1FB6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FB8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FBD, 0x0010, 0x0001, 0x0408, 0x0004,
    0x1FC2, 0x0102, 0x0001, 0x8003, 0x0002,
    0x1FC6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FC8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FCD, 0x0010, 0x0001, 0x0408, 0x0002,
    0x1FD0, 0x0102, 0x0001, 0x8003, 0x0003,
    0x1FD6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FD8, 0x0101, 0x0001, 0x8003, 0x0003,
    0x1FDD, 0x0010, 0x0001, 0x0408, 0x0002,
    0x1FE0, 0x0102, 0x0001, 0x8003, 0x0007,
    0x1FE8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FED, 0x0010, 0x0001, 0x0408, 0x0002,
    0x1FF2, 0x0102, 0x0001, 0x8003, 0x0002,
    0x1FF6, 0x0102, 0x0001, 0x8003, 0x0001,
    0x1FF8, 0x0101, 0x0001, 0x8003, 0x0004,
    0x1FFD, 0x0010, 0x0001, 0x0408, 0x0001,
    0x2000, 0x0018, 0x000A, 0x0008, 0x0006,
    0x2007, 0x0018, 0x0004, 0x0008, 0x0000,
    0x2008, 0x0018, 0x000A, 0x0008, 0x0003,
    0x200C, 0x0030, 0x000B, 0x0008, 0x0000,
    0x200D, 0x0030, 0x000B, 0x0000, 0x0000,
    0x200E, 0x0030, 0x0001, 0x0000, 0x0000,
    0x200F, 0x0030, 0x0002, 0x0000, 0x0000,
    0x2010, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2011, 0x0010, 0x000B, 0x0400, 0x0004,
    0x2016, 0x0010, 0x000B, 0x0008, 0x0001,
    0x2018, 0x0010, 0x000B, 0x0088, 0x0001,
    0x201A, 0x0010, 0x000B, 0x0008, 0x0001,
    0x201C, 0x0010, 0x000B, 0x0088, 0x0001,
    0x201E, 0x0010, 0x000B, 0x0008, 0x0008,
    0x2027, 0x0010, 0x000B, 0x0000, 0x0000,
    0x2028, 0x0030, 0x0008, 0x0008, 0x0001,
    0x202A, 0x0030, 0x000B, 0x0000, 0x0004,
    0x2030, 0x0010, 0x0005, 0x0008, 0x0001,
    0x2032, 0x0010, 0x0005, 0x0408, 0x0001,
    0x2034, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2035, 0x0010, 0x000B, 0x0008, 0x0002,
    0x2038, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2039, 0x0010, 0x000B, 0x0008, 0x0009,
    0x2043, 0x0010, 0x000B, 0x0400, 0x0000,
    0x2044, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2045, 0x0010, 0x000B, 0x0008, 0x0001,
    0x206A, 0x0030, 0x000B, 0x0000, 0x0005,
    0x2070, 0x0004, 0x0003, 0x0000, 0x0000,
    0x2074, 0x0004, 0x0003, 0x0000, 0x0005,
    0x207A, 0x0010, 0x0005, 0x0008, 0x0000,
    0x207B, 0x0010, 0x0005, 0x0400, 0x0000,
    0x207C, 0x0010, 0x000B, 0x0408, 0x0000,
    0x207D, 0x0010, 0x000B, 0x0008, 0x0001,
    0x207F, 0x0010, 0x000B, 0x0400, 0x0000,
    0x2080, 0x0004, 0x0003, 0x0000, 0x0009,
    0x208A, 0x0010, 0x0005, 0x0008, 0x0000,
    0x208B, 0x0010, 0x0005, 0x0400, 0x0000,
    0x208C, 0x0010, 0x000B, 0x0408, 0x0000,
    0x208D, 0x0010, 0x000B, 0x0008, 0x0001,
    0x20A0, 0x0010, 0x0005, 0x0008, 0x0008,
    0x20A9, 0x0010, 0x0005, 0x0048, 0x0000,
    0x20AA, 0x0010, 0x0005, 0x0008, 0x0002,
    0x20D0, 0x0010, 0x0001, 0x0009, 0x0011,
    0x2100, 0x0010, 0x000B, 0x0000, 0x0016,
    0x2117, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2118, 0x0010, 0x000B, 0x0000, 0x0020,
    0x2153, 0x0010, 0x000B, 0x0000, 0x000C,
    0x2160, 0x0010, 0x0001, 0x0000, 0x0022,
    0x2190, 0x0010, 0x000B, 0x0008, 0x005A,
    0x2200, 0x0010, 0x000B, 0x0008, 0x0011,
    0x2212, 0x0010, 0x0005, 0x0408, 0x0000,
    0x2213, 0x0010, 0x0005, 0x0008, 0x0000,
    0x2214, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2215, 0x0010, 0x000B, 0x0408, 0x0001,
    0x2217, 0x0010, 0x000B, 0x0008, 0x0006,
    0x221E, 0x0010, 0x000B, 0x0000, 0x0000,
    0x221F, 0x0010, 0x000B, 0x0008, 0x00D2,
    0x2300, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2302, 0x0010, 0x000B, 0x0008, 0x0078,
    0x2400, 0x0010, 0x000B, 0x0008, 0x0024,
    0x2440, 0x0010, 0x000B, 0x0008, 0x000A,
    0x2460, 0x0010, 0x000B, 0x0000, 0x003B,
    0x249C, 0x0112, 0x000B, 0x8000, 0x0019,
    0x24B6, 0x0111, 0x000B, 0x8000, 0x0019,
    0x24D0, 0x0112, 0x000B, 0x8000, 0x0019,
    0x24EA, 0x0010, 0x000B, 0x0000, 0x0000,
    0x2500, 0x0010, 0x000B, 0x0408, 0x0000,
    0x2501, 0x0010, 0x000B, 0x0008, 0x0002,
    0x2504, 0x0010, 0x000B, 0x0408, 0x0001,
    0x2506, 0x0010, 0x000B, 0x0008, 0x0001,
    0x2508, 0x0010, 0x000B, 0x0408, 0x0001,
    0x250A, 0x0010, 0x000B, 0x0008, 0x0041,
    0x254C, 0x0010, 0x000B, 0x0408, 0x0001,
    0x254E, 0x0010, 0x000B, 0x0008, 0x0047,
    0x25A0, 0x0010, 0x000B, 0x0008, 0x004E,
    0x25EF, 0x0010, 0x000B, 0x0000, 0x0000,
    0x2600, 0x0010, 0x000B, 0x0008, 0x0013,
    0x261A, 0x0010, 0x000B, 0x0008, 0x0055,
    0x2701, 0x0010, 0x000B, 0x0008, 0x0003,
    0x2706, 0x0010, 0x000B, 0x0008, 0x0003,
    0x270C, 0x0010, 0x000B, 0x0008, 0x001B,
    0x2729, 0x0010, 0x000B, 0x0008, 0x0022,
    0x274D, 0x0010, 0x000B, 0x0008, 0x0000,
    0x274F, 0x0010, 0x000B, 0x0008, 0x0003,
    0x2756, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2758, 0x0010, 0x000B, 0x0008, 0x0006,
    0x2761, 0x0010, 0x000B, 0x0008, 0x0006,
    0x2776, 0x0010, 0x000B, 0x0000, 0x001D,
    0x2794, 0x0010, 0x000B, 0x0008, 0x0000,
    0x2798, 0x0010, 0x000B, 0x0008, 0x0017,
    0x27B1, 0x0010, 0x000B, 0x0008, 0x000D,
    0x3000, 0x0048, 0x000A, 0x0088, 0x0000,
    0x3001, 0x0010, 0x000B, 0x0088, 0x0001,
    0x3003, 0x0010, 0x000B, 0x0400, 0x0000,
    0x3004, 0x0010, 0x0001, 0x0000, 0x0000,
    0x3005, 0x0110, 0x000B, 0x8101, 0x0000,
    0x3006, 0x0010, 0x000B, 0x0008, 0x0000,
    0x3007, 0x0110, 0x000B, 0x0008, 0x0000,
    0x3008, 0x0010, 0x000B, 0x0008, 0x0003,
    0x300C, 0x0010, 0x000B, 0x0088, 0x0001,
    0x300E, 0x0010, 0x000B, 0x0008, 0x000D,
    0x301C, 0x0010, 0x000B, 0x0400, 0x0000,
    0x301D, 0x0010, 0x000B, 0x0008, 0x0003,
    0x3021, 0x0010, 0x000B, 0x0000, 0x0008,
    0x302A, 0x0010, 0x000B, 0x0001, 0x0005,
    0x3030, 0x0010, 0x000B, 0x0400, 0x0000,
    0x3031, 0x0010, 0x000B, 0x0430, 0x0000,
    0x3032, 0x0010, 0x000B, 0x0433, 0x0000,
    0x3033, 0x0010, 0x000B, 0x0430, 0x0000,
    0x3034, 0x0010, 0x000B, 0x0433, 0x0000,
    0x3035, 0x0010, 0x000B, 0x0430, 0x0000,
    0x3036, 0x0010, 0x000B, 0x0008, 0x0001,
    0x303F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x3041, 0x0100, 0x0001, 0x8020, 0x000A,
    0x304C, 0x0100, 0x0001, 0x8023, 0x0000,
    0x304D, 0x0100, 0x0001, 0x8020, 0x0000,
    0x304E, 0x0100, 0x0001, 0x8023, 0x0000,
    0x304F, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3050, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3051, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3052, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3053, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3054, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3055, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3056, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3057, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3058, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3059, 0x0100, 0x0001, 0x8020, 0x0000,
    0x305A, 0x0100, 0x0001, 0x8023, 0x0000,
    0x305B, 0x0100, 0x0001, 0x8020, 0x0000,
    0x305C, 0x0100, 0x0001, 0x8023, 0x0000,
    0x305D, 0x0100, 0x0001, 0x8020, 0x0000,
    0x305E, 0x0100, 0x0001, 0x8023, 0x0000,
    0x305F, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3060, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3061, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3062, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3063, 0x0100, 0x0001, 0x8020, 0x0001,
    0x3065, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3066, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3067, 0x0100, 0x0001, 0x8023, 0x0000,
    0x3068, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3069, 0x0100, 0x0001, 0x8023, 0x0000,
    0x306A, 0x0100, 0x0001, 0x8020, 0x0005,
    0x3070, 0x0100, 0x0001, 0x8023, 0x0001,
    0x3072, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3073, 0x0100, 0x0001, 0x8023, 0x0001,
    0x3075, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3076, 0x0100, 0x0001, 0x8023, 0x0001,
    0x3078, 0x0100, 0x0001, 0x8020, 0x0000,
    0x3079, 0x0100, 0x0001, 0x8023, 0x0001,
    0x307B, 0x0100, 0x0001, 0x8020, 0x0000,
    0x307C, 0x0100, 0x0001, 0x8023, 0x0001,
    0x307E, 0x0100, 0x0001, 0x8020, 0x0016,
    0x3099, 0x0010, 0x0001, 0x0033, 0x0001,
    0x309B, 0x0110, 0x0001, 0x84B3, 0x0001,
    0x309D, 0x0110, 0x0001, 0x8421, 0x0000,
    0x309E, 0x0110, 0x0001, 0x8423, 0x0000,
    0x30A1, 0x0100, 0x0001, 0x8090, 0x000A,
    0x30AC, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30AD, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30AE, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30AF, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B0, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B1, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B2, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B3, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B4, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B5, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B6, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B7, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30B8, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30B9, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30BA, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30BB, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30BC, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30BD, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30BE, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30BF, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C0, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C1, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C2, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C3, 0x0100, 0x0001, 0x8090, 0x0001,
    0x30C5, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C6, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C7, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30C8, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30C9, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30CA, 0x0100, 0x0001, 0x8090, 0x0005,
    0x30D0, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30D2, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30D3, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30D5, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30D6, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30D8, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30D9, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30DB, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30DC, 0x0100, 0x0001, 0x8013, 0x0001,
    0x30DE, 0x0100, 0x0001, 0x8090, 0x000F,
    0x30EE, 0x0100, 0x0001, 0x8010, 0x0000,
    0x30EF, 0x0100, 0x0001, 0x8090, 0x0000,
    0x30F0, 0x0100, 0x0001, 0x8010, 0x0001,
    0x30F2, 0x0100, 0x0001, 0x8090, 0x0001,
    0x30F4, 0x0100, 0x0001, 0x8013, 0x0000,
    0x30F5, 0x0100, 0x0001, 0x8010, 0x0001,
    0x30F7, 0x0100, 0x0001, 0x8013, 0x0003,
    0x30FB, 0x0010, 0x0001, 0x0098, 0x0000,
    0x30FC, 0x0110, 0x0001, 0x8031, 0x0000,
    0x30FD, 0x0110, 0x0001, 0x8411, 0x0000,
    0x30FE, 0x0110, 0x0001, 0x8413, 0x0000,
    0x3105, 0x0100, 0x0001, 0x8000, 0x0027,
    0x3131, 0x0100, 0x0001, 0x8080, 0x0033,
    0x3165, 0x0100, 0x0001, 0x8000, 0x0029,
    0x3190, 0x0010, 0x0001, 0x0000, 0x000F,
    0x3200, 0x0010, 0x0001, 0x0000, 0x001C,
    0x3220, 0x0010, 0x0001, 0x0000, 0x0023,
    0x3260, 0x0010, 0x0001, 0x0000, 0x001B,
    0x327F, 0x0010, 0x0001, 0x0008, 0x0000,
    0x3280, 0x0010, 0x0001, 0x0000, 0x0030,
    0x32C0, 0x0010, 0x0001, 0x0008, 0x000B,
    0x32D0, 0x0010, 0x0001, 0x0000, 0x002E,
    0x3300, 0x0010, 0x0001, 0x0000, 0x0057,
    0x3358, 0x0010, 0x0001, 0x0008, 0x0018,
    0x3371, 0x0010, 0x0001, 0x0000, 0x0005,
    0x337B, 0x0010, 0x0001, 0x0000, 0x0062,
    0x33E0, 0x0010, 0x0001, 0x0008, 0x001E,
    0x4E00, 0x0100, 0x0001, 0x8100, 0x51A5,
    0xAC00, 0x0100, 0x0001, 0x8000, 0x2BA3,
    0xF900, 0x0100, 0x0001, 0x8100, 0x012D,
    0xFB00, 0x0102, 0x0001, 0x8000, 0x0006,
    0xFB13, 0x0102, 0x0001, 0x8000, 0x0004,
    0xFB1E, 0x0010, 0x0002, 0x0001, 0x0000,
    0xFB1F, 0x0100, 0x0002, 0x8000, 0x0017,
    0xFB38, 0x0100, 0x0002, 0x8000, 0x0004,
    0xFB3E, 0x0100, 0x0002, 0x8000, 0x0000,
    0xFB40, 0x0100, 0x0002, 0x8000, 0x0001,
    0xFB43, 0x0100, 0x0002, 0x8000, 0x0001,
    0xFB46, 0x0100, 0x0002, 0x8000, 0x006B,
    0xFBD3, 0x0100, 0x0002, 0x8000, 0x016A,
    0xFD3E, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFD50, 0x0100, 0x0002, 0x8000, 0x003F,
    0xFD92, 0x0100, 0x0002, 0x8000, 0x0035,
    0xFDF0, 0x0100, 0x0002, 0x8000, 0x000B,
    0xFE20, 0x0010, 0x0001, 0x0003, 0x0003,
    0xFE30, 0x0010, 0x000B, 0x0008, 0x0000,
    0xFE31, 0x0010, 0x000B, 0x0400, 0x0001,
    0xFE33, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFE35, 0x0010, 0x0000, 0x0008, 0x0001,
    0xFE37, 0x0010, 0x000B, 0x0008, 0x000D,
    0xFE49, 0x0010, 0x000B, 0x0008, 0x0006,
    0xFE50, 0x0010, 0x0007, 0x0008, 0x0000,
    0xFE51, 0x0010, 0x000B, 0x0008, 0x0000,
    0xFE52, 0x0010, 0x0004, 0x0008, 0x0000,
    0xFE54, 0x0010, 0x000B, 0x0008, 0x0000,
    0xFE55, 0x0010, 0x0007, 0x0008, 0x0000,
    0xFE56, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFE58, 0x0010, 0x000B, 0x0400, 0x0000,
    0xFE59, 0x0010, 0x000B, 0x0008, 0x0008,
    0xFE62, 0x0010, 0x0005, 0x0008, 0x0000,
    0xFE63, 0x0010, 0x0005, 0x0400, 0x0000,
    0xFE64, 0x0010, 0x000B, 0x0008, 0x0001,
    0xFE66, 0x0010, 0x000B, 0x0408, 0x0000,
    0xFE68, 0x0010, 0x000B, 0x0408, 0x0000,
    0xFE69, 0x0010, 0x0005, 0x0408, 0x0000,
    0xFE6A, 0x0010, 0x0005, 0x0008, 0x0000,
    0xFE6B, 0x0010, 0x000B, 0x0408, 0x0000,
    0xFE70, 0x0010, 0x0002, 0x0000, 0x0002,
    0xFE74, 0x0010, 0x0002, 0x0000, 0x0000,
    0xFE76, 0x0010, 0x0002, 0x0000, 0x0009,
    0xFE80, 0x0110, 0x0002, 0x8000, 0x007C,
    0xFEFF, 0x0048, 0x0000, 0x0000, 0x0000,
    0xFF01, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFF04, 0x0010, 0x0005, 0x0488, 0x0000,
    0xFF05, 0x0010, 0x0005, 0x0088, 0x0000,
    0xFF06, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF07, 0x0010, 0x000B, 0x0480, 0x0000,
    0xFF08, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFF0B, 0x0010, 0x0005, 0x0088, 0x0000,
    0xFF0C, 0x0010, 0x0007, 0x0088, 0x0000,
    0xFF0D, 0x0010, 0x0005, 0x0480, 0x0000,
    0xFF0E, 0x0010, 0x0004, 0x0088, 0x0000,
    0xFF0F, 0x0010, 0x0004, 0x0488, 0x0000,
    0xFF10, 0x0084, 0x0003, 0x0080, 0x0009,
    0xFF1A, 0x0010, 0x0007, 0x0088, 0x0000,
    0xFF1B, 0x0010, 0x000B, 0x0088, 0x0001,
    0xFF1D, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF1E, 0x0010, 0x000B, 0x0088, 0x0001,
    0xFF20, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF21, 0x0181, 0x0001, 0x8080, 0x0005,
    0xFF27, 0x0101, 0x0001, 0x8080, 0x0013,
    0xFF3B, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF3C, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF3D, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF3E, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF3F, 0x0010, 0x000B, 0x0088, 0x0000,
    0xFF40, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF41, 0x0182, 0x0001, 0x8080, 0x0005,
    0xFF47, 0x0102, 0x0001, 0x8080, 0x0013,
    0xFF5B, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFF5E, 0x0010, 0x000B, 0x0488, 0x0000,
    0xFF61, 0x0010, 0x000B, 0x0048, 0x0003,
    0xFF65, 0x0010, 0x0001, 0x0048, 0x0000,
    0xFF66, 0x0100, 0x0001, 0x8050, 0x0009,
    0xFF70, 0x0110, 0x0001, 0x8073, 0x0000,
    0xFF71, 0x0100, 0x0001, 0x8050, 0x002C,
    0xFF9E, 0x0110, 0x0001, 0x8053, 0x0001,
    0xFFA0, 0x0010, 0x0001, 0x0040, 0x0000,
    0xFFA1, 0x0100, 0x0001, 0x8040, 0x001D,
    0xFFC2, 0x0100, 0x0001, 0x8040, 0x0005,
    0xFFCA, 0x0100, 0x0001, 0x8040, 0x0005,
    0xFFD2, 0x0100, 0x0001, 0x8040, 0x0005,
    0xFFDA, 0x0100, 0x0001, 0x8040, 0x0002,
    0xFFE0, 0x0010, 0x0005, 0x0088, 0x0001,
    0xFFE2, 0x0010, 0x000B, 0x0088, 0x0002,
    0xFFE5, 0x0010, 0x0005, 0x0088, 0x0001,
    0xFFE8, 0x0010, 0x000B, 0x0040, 0x0006,
    0xFFFD, 0x0100, 0x000B, 0x8000, 0x0000
};

/*++

 Function Description:
    
    Get CTYPE for the character.

 Arguments:

    IN wcSrcChar    - Source character
    IN wType        - CTYPE to get (must be 1,2,3)

 Return Value:

    CTYPE value

 History:

    06/03/2002 hioh     Created

--*/

WORD GetCtype(WCHAR wcSrcChar, WORD wType)
{
    WORD bgn = 0;
    WORD end = MAXINDEX;
    WORD med;
    WORD idx = 0xFFFF;

    // Look for index in the table
    while (wcSrcChar > g_ctype[bgn][0] && g_ctype[end][0] > wcSrcChar) {
        med = (bgn + end) / 2;
        if (bgn == med) {
            idx = bgn;
            break;
        }

        if (wcSrcChar < g_ctype[med][0]) {
            end = med;
        }
        else {
            bgn = med;
        }
    }

    // Check the border index
    if (idx == 0xFFFF) {
        if (wcSrcChar == g_ctype[bgn][0]) {
            idx = bgn;
        }
        else if (wcSrcChar == g_ctype[end][0]) {
            idx = end;
        }
    }

    // Return CTYPE if the character is really in the table
    if (idx != 0xFFFF && g_ctype[idx][0] <= wcSrcChar && wcSrcChar <= g_ctype[idx][0]+g_ctype[idx][4]) {
        return (g_ctype[idx][wType]);
    }

    // Not found in the table
    return (0);
}

/*++

 GetStringTypeW : Internal

--*/

BOOL
myGetStringTypeW(
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    int Ctr;                      // loop counter

    //
    //  Invalid Parameter Check:
    //    - lpSrcStr NULL
    //    - cchSrc is 0
    //    - lpCharType NULL
    //    - same buffer - src and destination
    //    - (flags will be checked in switch statement below)
    //
    if ((lpSrcStr == NULL) || (cchSrc == 0) || (lpCharType == NULL) || 
        (lpSrcStr == lpCharType)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1) {
        cchSrc = lstrlenW(lpSrcStr) + 1;
    }

    //
    //  Return the appropriate information in the lpCharType parameter
    //  based on the dwInfoType parameter.
    //
    switch (dwInfoType) {
        case CT_CTYPE1:
            //  Return the ctype 1 information for the string.
            for (Ctr = 0; Ctr < cchSrc; Ctr++) {
                lpCharType[Ctr] = GetCtype(lpSrcStr[Ctr], 1);
            }
            break;

        case CT_CTYPE2:
            //  Return the ctype 2 information.
            for (Ctr = 0; Ctr < cchSrc; Ctr++) {
                lpCharType[Ctr] = GetCtype(lpSrcStr[Ctr], 2);
            }
            break;

        case CT_CTYPE3:
            //  Return the ctype 3 information.
            for (Ctr = 0; Ctr < cchSrc; Ctr++) {
                lpCharType[Ctr] = GetCtype(lpSrcStr[Ctr], 3);
            }
            break;

        default :
            //  Invalid flag parameter, so return failure.
            SetLastError(ERROR_INVALID_FLAGS);
            return FALSE;
    }

    //  Return success.
    return TRUE;
}

/*++

 GetStringTypeW

--*/

BOOL
APIHOOK(GetStringTypeW)(
    DWORD   dwInfoType,
    LPCWSTR lpSrcStr,
    int     cchSrc,
    LPWORD  lpCharType)
{
    return myGetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 GetStringTypeExW

--*/

BOOL
APIHOOK(GetStringTypeExW)(
    LCID Locale,
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    //  Invalid Parameter Check: Validate LCID
    if (Locale != LOCALE_SYSTEM_DEFAULT && Locale != LOCALE_USER_DEFAULT &&
        Locale != LOCALE_NEUTRAL && Locale != LOCALE_INVARIANT) {

        if (SUBLANGID(LANGIDFROMLCID(Locale)) == SUBLANG_NEUTRAL) {
            //
            //  Re-form the locale id using the primary language and the
            //  default sublanguage.
            //
            Locale = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(Locale)),
                SUBLANG_DEFAULT), SORTIDFROMLCID(Locale));
        }

        if (!IsValidLocale(Locale, LCID_SUPPORTED)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //  Return the result of GetStringTypeW.
    return myGetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 GetStringTypeA : Internal

--*/

BOOL
myGetStringTypeA(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    WCHAR wcCpStr[7];       // 6 is max for LOCALE_IDEFAULTANSICODEPAGE
    long cp = 0;            // Ansi code page
    int UnicodeLength;      // length of Unicode string
    BOOL Result;            // result
    int Ctr;                // loop counter

    // Get code page for the locale
    if (GetLocaleInfoW(Locale, LOCALE_IDEFAULTANSICODEPAGE, wcCpStr, 
        sizeof(wcCpStr) / sizeof(wcCpStr[0]))) {
        cp = wcstol(wcCpStr, NULL, 10);
    }

    //
    //  Invalid Parameter Check:
    //    - Validate LCID
    //    - valid code page
    //    - same buffer - src and destination
    //
    if ((cp == 0) || (lpSrcStr == (LPSTR)lpCharType)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //  Get the source length if not specified
    if (cchSrc == -1) {
        cchSrc = lstrlenA(lpSrcStr);
        cchSrc++;
    }

    //  Allocate Unicode string
    WCHAR *pUnicode = new WCHAR[cchSrc];

    //
    //  Convert Ansi string to Unicode.
    //  Invalid character is handled as 0xFFFF in original API
    //
    UnicodeLength = 0;
    for (Ctr = 0; Ctr < cchSrc; Ctr++) {
        int lenWchar;

        // Check if DBCS lead byte
        if (IsDBCSLeadByteEx(cp, lpSrcStr[Ctr])) {
            // Check if 2 byte exist
            if ((Ctr+1) < cchSrc) {
                lenWchar = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, 
                    &lpSrcStr[Ctr], 2, &pUnicode[UnicodeLength], 
                    cchSrc - UnicodeLength);

                // Check if invalid
                if (0 == lenWchar) {
                    pUnicode[UnicodeLength] = 0xFFFF;
                }
                // DBCS counter increment
                Ctr++;
            } else {
                // 1 byte DBCS lead is invalid
                pUnicode[UnicodeLength] = 0xFFFF;
            }
        } else {
            // Single byte handling
            lenWchar = MultiByteToWideChar(cp, MB_ERR_INVALID_CHARS, 
                &lpSrcStr[Ctr], 1, &pUnicode[UnicodeLength], 
                cchSrc - UnicodeLength);

            // Check if invalid
            if (0 == lenWchar) {
                pUnicode[UnicodeLength] = 0xFFFF;
            }
        }
        UnicodeLength++;
    }

    //  Call the W version of the API.
    Result = myGetStringTypeW(dwInfoType, pUnicode, UnicodeLength, lpCharType);

    //  Free the allocated source buffer (if one was allocated).
    delete [] pUnicode;

    //  Return the result of the call to GetStringTypeW.
    return (Result);
}

/*++

 GetStringTypeA

--*/

BOOL
APIHOOK(GetStringTypeA)(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    return myGetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 GetStringTypeExA

--*/

BOOL
APIHOOK(GetStringTypeExA)(
    LCID Locale,
    DWORD dwInfoType,
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
    return myGetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStringTypeExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\enlargegetobject.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EnlargeGetObject.cpp

 Abstract:
 
    Holy Quran (El Hozayfy and Mohamed Ayoub) V 1 calls GetObjectA()
    with the second parameter hard coded to 10 while it suppose to 
    be the sizeof(BITMAP) i.e. 24
    
    This shim is app specific

 History:

 04/17/2001 mhamid  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EnlargeGetObjectBufferSize)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetObjectA) 
APIHOOK_ENUM_END

int 
APIHOOK(GetObjectA)(
  HGDIOBJ hgdiobj,  // handle to graphics object
  int cbBuffer,     // size of buffer for object information
  LPVOID lpvObject  // buffer for object information
					)
{
	if ((cbBuffer == 10) && (lpvObject != NULL))
		cbBuffer = sizeof(BITMAP);
	return ORIGINAL_API(GetObjectA)(hgdiobj, cbBuffer, lpvObject);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetObjectA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\emulategetuieffects.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    EmulateGetUIEffects.cpp

 Abstract:

    Force SPI_GETUIEFFECTS to FALSE if this is a remote (TS) session

 History:

    08/07/2002  linstev     Created
    08/22/2002  robkenny    Converted to a general shim

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetUIEffects)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SystemParametersInfoA) 
    APIHOOK_ENUM_ENTRY(SystemParametersInfoW) 
APIHOOK_ENUM_END

BOOL    bGetUIEffects   = FALSE;


/*++

  If the caller was after SPI_GETUIEFFECTS and this is a TS session
  force the value to the value specified on the command line.

--*/


VOID CorrectGetUIEffects(
    UINT uiAction,  // system parameter to retrieve or set
    UINT uiParam,   // depends on action to be taken
    PVOID pvParam,  // depends on action to be taken
    UINT fWinIni    // user profile update option
    )
{
    if (pvParam && (uiAction == SPI_GETUIEFFECTS))
    {
        if (GetSystemMetrics(SM_REMOTESESSION))
        {
            BOOL * bUiEffect = (BOOL *)pvParam;

            // Only spew the message if we are actually changing the value
            if (*bUiEffect != bGetUIEffects)
            {
                LOGN(eDbgLevelWarning, "SystemParametersInfoA: Forcing SPI_GETUIEFFECTS to %s", bGetUIEffects ? "TRUE" : "FALSE");

                *bUiEffect = bGetUIEffects;
            }
        }
    }
}

/*++

 Force SPI_GETUIEFFECTS to bGetUIEffects (defaults to FALSE) if this is a remote (TS) session

--*/

BOOL 
APIHOOK(SystemParametersInfoA)(
    UINT uiAction,  // system parameter to retrieve or set
    UINT uiParam,   // depends on action to be taken
    PVOID pvParam,  // depends on action to be taken
    UINT fWinIni    // user profile update option
    )
{
    BOOL bRet = ORIGINAL_API(SystemParametersInfoA)(uiAction, uiParam, pvParam, fWinIni);

    if (bRet)
    {
        CorrectGetUIEffects(uiAction, uiParam, pvParam, fWinIni);
    }
    
    return bRet;
}

BOOL 
APIHOOK(SystemParametersInfoW)(
    UINT uiAction,  // system parameter to retrieve or set
    UINT uiParam,   // depends on action to be taken
    PVOID pvParam,  // depends on action to be taken
    UINT fWinIni    // user profile update option
    )
{
    BOOL bRet = ORIGINAL_API(SystemParametersInfoW)(uiAction, uiParam, pvParam, fWinIni);

    if (bRet)
    {
        CorrectGetUIEffects(uiAction, uiParam, pvParam, fWinIni);
    }
    
    return bRet;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            {
                CSTRING_TRY
                {
                    CString csCl(COMMAND_LINE);
                    if (csCl.CompareNoCase(L"true") == 0)
                    {
                        DPFN(eDbgLevelSpew, "EmulateGetUIEffects command line forcing SPI_GETUIEFFECTS to TRUE");
                        bGetUIEffects = TRUE;
                    }
                    else if (csCl.CompareNoCase(L"false") == 0)
                    {
                        DPFN(eDbgLevelSpew, "EmulateGetUIEffects command line forcing SPI_GETUIEFFECTS to FALSE");
                        bGetUIEffects = FALSE;
                    }
                }
                CSTRING_CATCH
                {
                    return FALSE;
                }
            }
            break;

        default:
            break;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, SystemParametersInfoA)
    APIHOOK_ENTRY(USER32.DLL, SystemParametersInfoW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\failgetstdhandle.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    FailGetStdHandle.cpp

 Abstract:

    This shim returns INVALID_HANDLE_VALUE when GetStdHandle is called.

 Notes:

    This is an app specific shim.

 History:

    12/12/1999 cornel   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FailGetStdHandle)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetStdHandle) 
APIHOOK_ENUM_END

/*++

 Return INVALID_HANDLE_VALUE when GetStdHandle is called.

--*/

HANDLE 
APIHOOK(GetStdHandle)(DWORD nStdHandle)
{
    return INVALID_HANDLE_VALUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetStdHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\emulatelzhandles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateLZHandles.cpp

 Abstract:

    This shim hooks all of the LZ api calls and increments/decrements the 
    handles so that a valid handle from the app's perspective is always > 0 
    instead of >= 0.

    Fixes apps that treated a handle value of zero as an error; Win9x never 
    returned handles of zero.

 History:

    07/25/2000 t-adams  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateLZHandles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LZClose) 
    APIHOOK_ENUM_ENTRY(LZCopy) 
    APIHOOK_ENUM_ENTRY(LZInit) 
    APIHOOK_ENUM_ENTRY(LZOpenFile) 
    APIHOOK_ENUM_ENTRY(LZRead) 
    APIHOOK_ENUM_ENTRY(LZSeek) 
APIHOOK_ENUM_END

#define KEY_SIZE_STEP MAX_PATH

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

VOID
APIHOOK(LZClose)(INT hFile) 
{
    ORIGINAL_API(LZClose)(--hFile);
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

LONG
APIHOOK(LZCopy)(
           INT hSource, 
           INT hDest
           ) 
{
    return ORIGINAL_API(LZCopy)(--hSource, --hDest);
}

/*++

  Abstract:
    This function does not decrement the handle passed in to it
    because the handle passed in is supposed to be a regular HANDLE
    created by CreateFile.  It does decrement handles that are 
    passed back to the app because they represent LZ file handles.
    The differences between the handles are poorly documented in MSDN.

  History:

  07/25/2000    t-adams     Created

--*/

INT
APIHOOK(LZInit)(INT hfSource) 
{
    INT iRet = 0;

    // Don't decrement handle.  See above.
    iRet = ORIGINAL_API(LZInit)(hfSource);

    // If there was an error, don't increment the error.
    if(iRet < 0) {
        return iRet;
    }
    
    return ++iRet;
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

INT
APIHOOK(LZOpenFile)(
    LPSTR lpFileName, 
    LPOFSTRUCT lpReOpenBuf, 
    WORD wStyle
    )
{
    INT iRet = 0;
    iRet = ORIGINAL_API(LZOpenFile)(lpFileName, lpReOpenBuf, wStyle);

    // If there was an error, don't increment the error.
    if( iRet < 0 ) {
        return iRet;
    }

    return ++iRet;
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

INT
APIHOOK(LZRead)(
    INT hFile, 
    LPSTR lpBuffer, 
    INT cbRead
    ) 
{
    return ORIGINAL_API(LZRead)(--hFile, lpBuffer, cbRead);
}

/*++

  Abstract:
    This function decrements the handles on the way in and increments
    handles that are passed back to the app

  History:

  07/25/2000    t-adams     Created

--*/

LONG
APIHOOK(LZSeek)(
    INT hFile, 
    LONG lOffset, 
    INT iOrigin
    ) 
{
    return ORIGINAL_API(LZSeek)(--hFile, lOffset, iOrigin);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(LZ32.DLL, LZClose)
    APIHOOK_ENTRY(LZ32.DLL, LZCopy)
    APIHOOK_ENTRY(LZ32.DLL, LZInit)
    APIHOOK_ENTRY(LZ32.DLL, LZOpenFile)
    APIHOOK_ENTRY(LZ32.DLL, LZRead)
    APIHOOK_ENTRY(LZ32.DLL, LZSeek)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\failcloseprofileusermapping.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    FailCloseProfileUserMapping.cpp

 Abstract:

    Fifa 2000 makes a bad assumption that CloseProfileUserMapping always 
    returns 0

    Fix is of course trivial.
   
 Notes:

    This is an app specific shim.

 History:

    04/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FailCloseProfileUserMapping)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CloseProfileUserMapping) 
APIHOOK_ENUM_END

/*++

 Stub always returns 0.

--*/

BOOL
APIHOOK(CloseProfileUserMapping)(VOID)
{
    ORIGINAL_API(CloseProfileUserMapping)();
    return FALSE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CloseProfileUserMapping)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\extractassociatedicon.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ExtractAssociatedIcon.cpp

 Abstract:
 
    32bpp icons do not render into old style metafiles. When an application uses OleGetIconOfFile,
    The icons are not rendered.  We shim shell32's ExtractAssociatedIcon to return 24bpp icons,
    so we don't try to use functions that aren't available in old metafiles.
   
 Notes:

    This shim is a general purpose shim.

 History:

    07/19/2001 lamadio  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ExtractAssociatedIcon)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ExtractAssociatedIconW)
    APIHOOK_ENUM_ENTRY(ExtractAssociatedIconA)
    APIHOOK_ENUM_ENTRY(DrawIcon)
    APIHOOK_ENUM_ENTRY(DrawIconEx)
APIHOOK_ENUM_END


HBITMAP CreateDIB(HDC h, WORD depth, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = depth;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}


// Strip a 32bbp icon of it's alpha channel
HICON StripIcon(HICON hicon, BOOL fDestroyOriginal)
{
    // Get the original bitmaps. Don't forget to delete them
    ICONINFO ii;
    if (GetIconInfo(hicon, &ii))
    {
        // Make sure we have a good height and width.
        BITMAP bm;
        GetObject(ii.hbmColor, sizeof(bm), &bm);

        HDC hdcNew = CreateCompatibleDC(NULL);
        HDC hdcSrc = CreateCompatibleDC(NULL);
        if (hdcNew && hdcSrc)
        {
            // Create a 24bpp icon. This strips the alpha channel
            RGBQUAD* prgb;
            HBITMAP hbmpNew = CreateDIB(hdcNew, 24, bm.bmWidth, bm.bmHeight, &prgb);

            if (hbmpNew)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcNew, hbmpNew);
                HBITMAP hbmpOld2 = (HBITMAP)SelectObject(hdcSrc, ii.hbmColor);

                // Copy from 32bpp to 24bpp.
                BitBlt(hdcNew, 0, 0, bm.bmWidth, bm.bmHeight, hdcSrc, 0, 0, SRCCOPY);

                SelectObject(hdcSrc, hbmpOld2);
                SelectObject(hdcNew, hbmpOld);

                // Delete the original bitmap
                DeleteObject(ii.hbmColor);

                // and return the new one
                ii.hbmColor = hbmpNew;
            }
        }

        if (hdcNew)
            DeleteDC(hdcNew);

        if (hdcSrc)
            DeleteDC(hdcSrc);

        // Now, create the new icon from the 16bpp image and the mask.
        HICON hiconStripped = CreateIconIndirect(&ii);

        if (hiconStripped)
        {
            if (fDestroyOriginal)
                DestroyIcon(hicon);

            hicon = hiconStripped;
        }

        // Don't forget to clean up.
        DeleteObject(ii.hbmColor);
        DeleteObject(ii.hbmMask);
    }

    return hicon;
}

HICON APIHOOK(ExtractAssociatedIconA)(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon)
{
    HICON hicon = ORIGINAL_API(ExtractAssociatedIconA)(hInst, lpIconPath, lpiIcon);
    return StripIcon(hicon, TRUE);
}

HICON APIHOOK(ExtractAssociatedIconW)(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
    HICON hicon = ORIGINAL_API(ExtractAssociatedIconW)(hInst, lpIconPath, lpiIcon);
    return StripIcon(hicon, TRUE);
}


BOOL APIHOOK(DrawIcon)(HDC hDC, int X, int Y, HICON hIcon)
{
    HICON hIconNew = StripIcon(hIcon, FALSE);
        
    BOOL b = ORIGINAL_API(DrawIcon)(hDC, X, Y, hIconNew);

    DestroyIcon(hIconNew);

    return b;
}

BOOL APIHOOK(DrawIconEx)(HDC hDC, int X, int Y, HICON hIcon, int cxWidth, int cyHeight, UINT istepIfAniCur,
              HBRUSH hbrFlickerFreeDraw, UINT diFlags)
{
    HICON hIconNew = StripIcon(hIcon, FALSE);
        
    BOOL b = ORIGINAL_API(DrawIconEx)(hDC, X, Y, hIconNew, cxWidth, cyHeight, istepIfAniCur,
              hbrFlickerFreeDraw, diFlags);

    DestroyIcon(hIconNew);
    return b;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ExtractAssociatedIconA)
    APIHOOK_ENTRY(SHELL32.DLL, ExtractAssociatedIconW)
    APIHOOK_ENTRY(USER32.DLL, DrawIcon)
    APIHOOK_ENTRY(USER32.DLL, DrawIconEx)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\failobsoleteshellapis.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    FailObsoleteShellAPIs.cpp

 Abstract:

    Some applications call private shell32 APIs that have been removed since win2k.
    To make matters worse, these old ordinals are now used by other shell APIs. To
    prevent resulting crashes, we now hand out stubbed out functions that fail when
    you call GetProcAddress with these obsolete ordinals.

 Notes:

    This is a general purpose shim.

 History:

    05/31/2001 stevepro    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FailObsoleteShellAPIs)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcAddress)
APIHOOK_ENUM_END


HMODULE g_hShell32 = NULL;



/*++

    Stubbed out versions of the obsolete APIs.  They all return failure codes.

--*/


STDAPI_(BOOL)
FileMenu_HandleNotify(HMENU hmenu, LPCITEMIDLIST * ppidl, LONG lEvent)
{
    return FALSE;
}

STDAPI_(UINT)
FileMenu_DeleteAllItems(HMENU hmenu)
{
    return 0;
}

STDAPI_(LRESULT)
FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi)
{
    return FALSE;
}

STDAPI_(HMENU)
FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidlFS)
{
    return NULL;
}

STDAPI_(BOOL)
FileMenu_GetLastSelectedItemPidls(
    IN  HMENU          hmenu,
    OUT LPITEMIDLIST * ppidlFolder,         OPTIONAL
    OUT LPITEMIDLIST * ppidlItem)           OPTIONAL
{
    return FALSE;
}

STDAPI_(LRESULT)
FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch)
{
    return E_FAIL;
}

STDAPI_(BOOL)
FileMenu_InitMenuPopup(
    IN HMENU hmenu)
{
    return FALSE;
}

STDAPI
FileMenu_ComposeA(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN struct FMCOMPOSEA * pfmc)
{
    return E_FAIL;
}

STDAPI_(void)
FileMenu_Invalidate(HMENU hmenu)
{
}

STDAPI_(LRESULT)
FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *lpmi)
{
    return FALSE;
}

STDAPI
FileMenu_ComposeW(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN struct FMCOMPOSEW * pfmc)
{
    return E_FAIL;
}

STDAPI_(HMENU)
FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, DWORD fmf)
{
    return NULL;
}

STDAPI_(BOOL)
FileMenu_AppendItem(
    HMENU hmenu,
    LPTSTR psz,
    UINT id,
    int iImage,
    HMENU hmenuSub,
    UINT cyItem)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y,
    HWND hwndOwner, LPTPMPARAMS lpTpm)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id)
{
    return FALSE;
}

STDAPI_(void)
FileMenu_Destroy(HMENU hmenu)
{
}

STDAPI_(void)
FileMenu_AbortInitMenu(void)
{
}

STDAPI_(UINT)
FileMenu_AppendFilesForPidl(
    HMENU hmenu,
    LPITEMIDLIST pidl,
    BOOL bInsertSeparator)
{
    return 0;
}

STDAPI_(BOOL)
FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem)
{
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_DeleteSeparator(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable)
{
    return FALSE;
}

STDAPI_(DWORD)
FileMenu_GetItemExtent(HMENU hmenu, UINT iItem)
{
    return 0;
}

STDAPI_(BOOL)
FileMenu_ProcessCommand(
    IN HWND   hwnd,
    IN HMENU  hmenuBar,
    IN UINT   idMenu,
    IN HMENU  hmenu,
    IN UINT   idCmd)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_IsFileMenu(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_InsertItem(
    IN HMENU  hmenu,
    IN LPTSTR psz,
    IN UINT   id,
    IN int    iImage,
    IN HMENU  hmenuSub,
    IN UINT   cyItem,
    IN UINT   iPos)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_InsertSeparator(HMENU hmenu, UINT iPos)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_GetPidl(HMENU hmenu, UINT iPos, LPITEMIDLIST *ppidl)
{
    return FALSE;
}

STDAPI_(void)
FileMenu_EditMode(BOOL bEdit)
{
}

STDAPI_(BOOL)
FileMenu_HandleMenuSelect(
    IN HMENU  hmenu,
    IN WPARAM wparam,
    IN LPARAM lparam)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_IsUnexpanded(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(void)
FileMenu_DelayedInvalidate(HMENU hmenu)
{
}

STDAPI_(BOOL)
FileMenu_IsDelayedInvalid(HMENU hmenu)
{
    return FALSE;
}

STDAPI_(BOOL)
FileMenu_CreateFromMenu(
    IN HMENU    hmenu,
    IN COLORREF clr,
    IN int      cxBmpGap,
    IN HBITMAP  hbmp,
    IN int      cySel,
    IN DWORD    fmf)
{
    return FALSE;
}



/*++

    Table associating the obsolete APIs and thier ordinals

--*/

struct ShellStubs
{
    PVOID   pfnStub;
    UINT    uiOrd;
};

const ShellStubs g_rgShellStubs[] =
{
    { FileMenu_HandleNotify,              101 },
    { FileMenu_DeleteAllItems,            104 },
    { FileMenu_DrawItem,                  105 },
    { FileMenu_FindSubMenuByPidl,         106 },
    { FileMenu_GetLastSelectedItemPidls,  107 },
    { FileMenu_HandleMenuChar,            108 },
    { FileMenu_InitMenuPopup,             109 },
    { FileMenu_ComposeA,                  110 },
    { FileMenu_Invalidate,                111 },
    { FileMenu_MeasureItem,               112 },
    { FileMenu_ComposeW,                  113 },
    { FileMenu_Create,                    114 },
    { FileMenu_AppendItem,                115 },
    { FileMenu_TrackPopupMenuEx,          116 },
    { FileMenu_DeleteItemByCmd,           117 },
    { FileMenu_Destroy,                   118 },
    { FileMenu_AbortInitMenu,             120 },
    { FileMenu_AppendFilesForPidl,        124 },
    { FileMenu_DeleteItemByIndex,         140 },
    { FileMenu_DeleteMenuItemByFirstID,   141 },
    { FileMenu_DeleteSeparator,           142 },
    { FileMenu_EnableItemByCmd,           143 },
    { FileMenu_GetItemExtent,             144 },
    { FileMenu_ProcessCommand,            217 },
    { FileMenu_IsFileMenu,                216 },
    { FileMenu_InsertItem,                218 },
    { FileMenu_InsertSeparator,           219 },
    { FileMenu_GetPidl,                   220 },
    { FileMenu_EditMode,                  221 },
    { FileMenu_HandleMenuSelect,          222 },
    { FileMenu_IsUnexpanded,              223 },
    { FileMenu_DelayedInvalidate,         224 },
    { FileMenu_IsDelayedInvalid,          225 },
    { FileMenu_CreateFromMenu,            227 },

/*
    May need to add these too.  Not needed yet.

    { ExtAppListOpenW                     228 },
    { ExtAppListOpenA                     229 },
    { ExtAppListClose                     230 },
    { ExtAppListAddItemsW                 231 },
    { ExtAppListAddItemsA                 232 },
    { ExtAppListRemoveItemsW              233 },
    { ExtAppListRemoveItemsA              234 },
    { ExtAppListItemsFreeStringsW         235 },
    { ExtAppListItemsFreeStringsA         236 },
    { ExtAppListEnumItemsW                237 },
    { ExtAppListEnumItemsA                238 },

    { Link_AddExtraDataSection            206 },
    { Link_ReadExtraDataSection           207 },
    { Link_RemoveExtraDataSection         208 },

    { ReceiveAddToRecentDocs              647 },
*/

};



/*++

    We only want to intercept calls to GetProcAddress and not mess with the
    DLL inport tables.  This is because the ordinals have been reused
    by valid shell APIs and we want LdrGetProcAddress to work normally for these
    ordinals.  So instead of hooking each of the old APIs using the shim library,
    we need to do the work ourselves.

--*/

FARPROC
APIHOOK(GetProcAddress)(
    HMODULE hModule,
    LPCSTR pszProcName
    )
{
    // Only intercept shell32 API's referenced by ordinal
    if (IS_INTRESOURCE(pszProcName))
    {
        if (g_hShell32 == NULL)
        {
            g_hShell32 = GetModuleHandle(L"shell32.dll");
        }

        if (g_hShell32 && hModule == g_hShell32)
        {
            UINT uiOrd = (UINT)pszProcName;

            // Look for ordinal of obsolete APIs
            for (int i=0; i < ARRAYSIZE(g_rgShellStubs); ++i)
            {
                if (g_rgShellStubs[i].uiOrd == uiOrd)
                {
                    // Found one!
                    return (FARPROC)g_rgShellStubs[i].pfnStub;
                }
            }
        }
    }

    // Default to the original API
    return ORIGINAL_API(GetProcAddress)(
        hModule,
        pszProcName);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(kernel32.DLL, GetProcAddress)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\failopenfile.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FailOpenFile.cpp

 Abstract:

   Force OpenFile to fail for the specified files.

 History:

    01/31/2001  robkenny    created
    03/13/2001  robkenny    Converted to CString
    02/07/2002  astritz     Converted to StrSafe

--*/

#include "precomp.h"
#include "charvector.h"

IMPLEMENT_SHIM_BEGIN(FailOpenFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenFile) 
APIHOOK_ENUM_END

CharVector  * g_FailList = NULL;

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        // file name
    LPOFSTRUCT lpReOpenBuff,  // file information
    UINT uStyle               // action and attributes
    )
{
    int i;
    for (i = 0; i < g_FailList->Size(); ++i)
    {
        // Compare each fail name against the end of lpFileName
        const char * failName = g_FailList->Get(i);
        size_t failNameLen = strlen(failName);
        size_t fileNameLen = strlen(lpFileName);

        if (fileNameLen >= failNameLen)
        {
            if (_strnicmp(failName, lpFileName+fileNameLen-failNameLen, failNameLen) == 0)
            {
                // Force OpenFile to fail for this filename
                DPFN( eDbgLevelError, "Forcing OpenFile(%s) to fail", lpFileName); 
                return FALSE;
            }
        }
    }

    HFILE returnValue = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
    return returnValue;
}

/*++

 Parse the command line, push each filename onto the end of the g_FailList.

--*/

BOOL ParseCommandLine(const char * cl)
{
    g_FailList = new CharVector;
    if (!g_FailList)
    {
        return FALSE;
    }

    if (cl != NULL && *cl)
    {
        int     argc = 0;
        LPSTR * argv = _CommandLineToArgvA(cl, & argc);
        if (argv)
        {
            for (int i = 0; i < argc; ++i)
            {
                if (!g_FailList->Append(argv[i]))
                {
                    // Memory failure
                    delete g_FailList;
                    g_FailList = NULL;
                    break;
                }
                DPFN( eDbgLevelSpew, "Adding %s to fail list", argv[i]); 
            }
            LocalFree(argv);
        }
    }
    return g_FailList != NULL;
}

/*++

 Handle attach and detach

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        return ParseCommandLine(COMMAND_LINE);
    }
    return TRUE;
}


/*++

  Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forceadminaccess.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAdminAccess.cpp

 Abstract:

    Pretend the token is a member. Typically used to see if we have 
    administrator access... 

 Notes:

    This is a general purpose shim.

 History:

    12/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAdminAccess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CheckTokenMembership) 
APIHOOK_ENUM_END

/*++

 Pretend the token is a member.

--*/

BOOL 
APIHOOK(CheckTokenMembership)(
    HANDLE TokenHandle,  // handle to an access token
    PSID SidToCheck,     // SID to check for 
    PBOOL IsMember       // receives results of the check 
    )
{
    BOOL bRet = ORIGINAL_API(CheckTokenMembership)(
        TokenHandle, SidToCheck, IsMember);

    if (bRet && IsMember)
    {
        *IsMember = TRUE;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CheckTokenMembership)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\force640x480x8.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force640x480x8.cpp

 Abstract:

    This shim is for games that assume the start resolution is 640x480x8.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force640x480x8)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_WIDTH   640
#define CDS_HEIGHT  480
#define CDS_BITS    8

VOID
ChangeMode()
{
    DEVMODEA dm;

    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);
        if ((dm.dmPelsWidth != CDS_WIDTH) ||
            (dm.dmPelsHeight != CDS_HEIGHT) ||
            (dm.dmBitsPerPel != CDS_BITS)) {
            //
            // The mode is different, so change
            //
            dm.dmPelsWidth = CDS_WIDTH;
            dm.dmPelsHeight = CDS_HEIGHT;
            dm.dmBitsPerPel = CDS_BITS;
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(1) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        ChangeMode();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\filternetworkresources.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    FilterNetworkResources.cpp

 Abstract:

    This shim intercepts WNetEnumResourceW from MPR.DLL and removes:

             "Microsoft Terminal Services"   and/or 
             "Web Client Network"

    network providers from the list of default network providers. It obtains the actual 
    names for these two providers from the registry. 

 Notes:

   This is a general purpose shim.

 History:
 
   08/21/2001 bduke & linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FilterNetworkResources)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WNetEnumResourceA) 
    APIHOOK_ENUM_ENTRY(WNetEnumResourceW) 
APIHOOK_ENUM_END

// ANSI and Unicode versions of the resource provider names
CHAR g_szTerminalServerName[MAX_PATH] = "";
CHAR g_szWebClientName[MAX_PATH] = "";
WCHAR g_wzTerminalServerName[MAX_PATH] = L"";
WCHAR g_wzWebClientName[MAX_PATH] = L"";

void
InitPaths()
{
    //
    // Registry path for the names of all providers, so we can find the name for 
    // each provider in different language SKUs
    //
    #define TS_NETWORK_PROVIDER  L"SYSTEM\\CurrentControlSet\\Services\\RDPNP\\NetworkProvider"
    #define WC_NETWORK_PROVIDER  L"SYSTEM\\CurrentControlSet\\Services\\WebClient\\NetworkProvider"
    #define PROVIDER_VALUEA      "Name"
    #define PROVIDER_VALUEW      L"Name"

    //
    // Get names from the registry
    //
    HKEY hKey;
    if (ERROR_SUCCESS == RegOpenKeyW(HKEY_LOCAL_MACHINE, TS_NETWORK_PROVIDER, &hKey)) {
        //
        // Get the TS provider name
        //
        DWORD dwSize;

        dwSize = sizeof(g_szTerminalServerName);
        if( ERROR_SUCCESS != RegQueryValueExA(hKey, PROVIDER_VALUEA, 0, 0, (PBYTE)g_szTerminalServerName, &dwSize) ) {
            g_szTerminalServerName[0] = '\0';
        }

        dwSize = sizeof(g_wzTerminalServerName);
        if( ERROR_SUCCESS != RegQueryValueExW(hKey, PROVIDER_VALUEW, 0, 0, (PBYTE)g_wzTerminalServerName, &dwSize) ) {
            g_wzTerminalServerName[0] = L'\0';
        }

        RegCloseKey(hKey);
    } else {
        DPFN(eDbgLevelWarning, "Failed to open TS_NETWORK_PROVIDER");
    }

    if (ERROR_SUCCESS == RegOpenKeyW(HKEY_LOCAL_MACHINE, WC_NETWORK_PROVIDER, &hKey)) {
        //
        // Get the web client name
        //
        DWORD dwSize;
        
        dwSize = sizeof(g_szWebClientName);
        if( ERROR_SUCCESS != RegQueryValueExA(hKey, PROVIDER_VALUEA, 0, 0, (PBYTE)g_szWebClientName, &dwSize) ) {
            g_szWebClientName[0] = '\0';
        }

        dwSize = sizeof(g_wzWebClientName);
        if( ERROR_SUCCESS != RegQueryValueExW(hKey, PROVIDER_VALUEW, 0, 0, (PBYTE)g_wzWebClientName, &dwSize) ) {
            g_wzWebClientName[0] = L'\0';
        }

        RegCloseKey(hKey);
    } else {
        DPFN(eDbgLevelWarning, "Failed to open WC_NETWORK_PROVIDER");
    }
}

/*++
  
 Hook WNetEnumResourceA function

--*/

DWORD 
APIHOOK(WNetEnumResourceA)(
    HANDLE  hEnum,         // handle to enumeration
    LPDWORD lpcCount,      // entries to list
    LPVOID  lpBuffer,      // buffer
    LPDWORD lpBufferSize   // buffer size
    )
{   
retry:

    DWORD dwRet = ORIGINAL_API(WNetEnumResourceA)(hEnum, lpcCount, lpBuffer, lpBufferSize);

    if (dwRet == NO_ERROR) {
        //
        // Remove entries we want to hide
        //

        DWORD dwCount = *lpcCount;
        LPNETRESOURCEA lpResourceFirst = (LPNETRESOURCEA) lpBuffer;
        LPNETRESOURCEA lpResourceLast = (LPNETRESOURCEA) lpBuffer  + dwCount - 1;

        while ((dwCount > 0) && (lpResourceFirst <= lpResourceLast)) {
            
            if ((lpResourceFirst->dwUsage & RESOURCEUSAGE_CONTAINER) && 
                ((strcmp(lpResourceFirst->lpProvider, g_szTerminalServerName) == 0) ||
                (strcmp(lpResourceFirst->lpProvider, g_szWebClientName) == 0))) {

                MoveMemory(lpResourceFirst, lpResourceLast, sizeof(NETRESOURCEA));
                ZeroMemory(lpResourceLast, sizeof(NETRESOURCEA));

                lpResourceLast--;
                dwCount--; 
            } else {
                lpResourceFirst++;
            }
        }

        if (dwCount != *lpcCount) {
            if (dwCount == 0) {
                //
                // We filtered everything out, so try again with a larger count
                //
                *lpcCount = *lpcCount + 1;
                goto retry;
            }
            LOGN(eDbgLevelWarning, "Network providers removed from list");
        }

        //
        // Fixup out variables
        //

        *lpcCount = dwCount;

        if (dwCount == 0) {
            dwRet = ERROR_NO_MORE_ITEMS;
        }
    }

    return dwRet;
}

/*++
  
 Hook WNetEnumResourceW function

--*/

DWORD 
APIHOOK(WNetEnumResourceW)(
    HANDLE  hEnum,         // handle to enumeration
    LPDWORD lpcCount,      // entries to list
    LPVOID  lpBuffer,      // buffer
    LPDWORD lpBufferSize   // buffer size
    )
{   
retry:

    DWORD dwRet = ORIGINAL_API(WNetEnumResourceW)(hEnum, lpcCount, lpBuffer, lpBufferSize);

    if (dwRet == NO_ERROR) {
        //
        // Remove entries we want to hide
        //

        DWORD dwCount = *lpcCount;
        LPNETRESOURCEW lpResourceFirst = (LPNETRESOURCEW) lpBuffer;
        LPNETRESOURCEW lpResourceLast = (LPNETRESOURCEW) lpBuffer  + dwCount - 1;

        while ((dwCount > 0) && (lpResourceFirst <= lpResourceLast)) {
            
            if ((lpResourceFirst->dwUsage & RESOURCEUSAGE_CONTAINER) && 
                ((wcscmp(lpResourceFirst->lpProvider, g_wzTerminalServerName) == 0) ||
                (wcscmp(lpResourceFirst->lpProvider, g_wzWebClientName) == 0))) {

                MoveMemory(lpResourceFirst, lpResourceLast, sizeof(NETRESOURCEW));
                ZeroMemory(lpResourceLast, sizeof(NETRESOURCEW));

                lpResourceLast--;
                dwCount--; 
            } else {
                lpResourceFirst++;
            }
        }

        if (dwCount != *lpcCount) {
            if (dwCount == 0) {
                //
                // We filtered everything out, so try again with a larger count
                //
                *lpcCount = *lpcCount + 1;
                goto retry;
            }
            LOGN(eDbgLevelWarning, "Network providers removed from list");
        }

        //
        // Fixup out variables
        //

        *lpcCount = dwCount;

        if (dwCount == 0) {
            dwRet = ERROR_NO_MORE_ITEMS;
        }
    }

    return dwRet;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        InitPaths();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(MPR.DLL, WNetEnumResourceA)
    APIHOOK_ENTRY(MPR.DLL, WNetEnumResourceW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fakethememetrics.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FakeThemeMetrics.cpp

 Abstract:

  This Shim will allow the Skemers group to shim applications that do not behave 
  well with "Themed" system metrics

 History:

  11/30/2000 a-brienw Converted to shim frame work version 2.

--*/

#include "precomp.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    sizeof(x)/sizeof((x)[0])
#endif

IMPLEMENT_SHIM_BEGIN(FakeThemeMetrics)
#include "ShimHookMacro.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSysColor) 
APIHOOK_ENUM_END

#define F_TYPE_RGB      0
#define F_TYPE_MAP      1
#define F_TYPE_PERCENT  2
#define F_TYPE_MAX      3
#define F_TYPE_NOTEQUAL 4
typedef struct
{
    int nIndex;
    DWORD fType;
    COLORREF rgb;
    int nMap;  // If mapping we need to use the post processed color. Call HookedGetSysColor. See note
    int iPercent;
} GETSYSCOLOR_MAP;

const static GETSYSCOLOR_MAP s_ColorMap[] = 
{
    {COLOR_MENU, F_TYPE_MAP, RGB(212, 208, 200), COLOR_BTNFACE, 10},
    {COLOR_BTNFACE, F_TYPE_MAX, RGB(227, 227, 227), 0, 0},
    {COLOR_3DDKSHADOW, F_TYPE_NOTEQUAL, RGB(0,0,0), COLOR_BTNFACE, 20}
};

COLORREF AdjustPercent(COLORREF crOld, int iPercent)
{
    return RGB(GetRValue(crOld) - (GetRValue(crOld) * iPercent) / 100,
               GetGValue(crOld) - (GetGValue(crOld) * iPercent) / 100,
               GetBValue(crOld) - (GetBValue(crOld) * iPercent) / 100);
}

// NOTE: If you are mapping a color (i.e. a direct map), then you need to call HookedGetSysColor. For example
// MSDEV calls GetSysColor(COLOR_BTNFACE). It then calls GetSysColor(COLOR_MENU) and compares the two. 
// If they are different then it pukes. However we hook both COLOR_MENU and COLOR_BTNFACE. So we need to get the mapped color.


DWORD HookedGetSysColor(int nIndex)
{
    for (int i = 0; i < ARRAYSIZE(s_ColorMap); i++)
    {
        if (nIndex == s_ColorMap[i].nIndex)
        {
            switch (s_ColorMap[i].fType)
            {
            case F_TYPE_RGB:
                return (DWORD)s_ColorMap[i].rgb;
                break;

            case F_TYPE_MAP:
                return HookedGetSysColor(s_ColorMap[i].nMap);
                break;

            case F_TYPE_PERCENT:
            {
                COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);

                return (DWORD)AdjustPercent(crOld, s_ColorMap[i].iPercent);
            }

            case F_TYPE_MAX:
            {
                COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);
                BYTE r = GetRValue(crOld);
                BYTE g = GetGValue(crOld);
                BYTE b = GetBValue(crOld);

                if (r > GetRValue(s_ColorMap[i].rgb))
                    r = GetRValue(s_ColorMap[i].rgb);
                if (g > GetGValue(s_ColorMap[i].rgb))
                    g = GetGValue(s_ColorMap[i].rgb);
                if (b > GetBValue(s_ColorMap[i].rgb))
                    b = GetBValue(s_ColorMap[i].rgb);

                return RGB(r,g,b);
            }
            case F_TYPE_NOTEQUAL:
            {
                COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);
                COLORREF crNotEqual = (COLORREF)HookedGetSysColor(s_ColorMap[i].nMap);
                if (crOld == crNotEqual)
                {
                    crOld = AdjustPercent(crOld, s_ColorMap[i].iPercent);
                }

                return crOld;
            }
            }

            break;
        }
    }

    return ORIGINAL_API(GetSysColor)( nIndex );
}

DWORD
APIHOOK(GetSysColor)(int nIndex)
{
    return HookedGetSysColor(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetSysColor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\force640x480x16.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force640x480x8.cpp

 Abstract:

    This shim is for games that assume the start resolution is 640x480x16.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force640x480x16)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_WIDTH   640
#define CDS_HEIGHT  480
#define CDS_BITS    16

VOID
ChangeMode()
{
    DEVMODEA dm;

    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);

        if ((dm.dmPelsWidth != CDS_WIDTH) ||
            (dm.dmPelsHeight != CDS_HEIGHT) ||
            (dm.dmBitsPerPel != CDS_BITS)) {
            //
            // The mode is different, so change
            //
            dm.dmPelsWidth = CDS_WIDTH;
            dm.dmPelsHeight = CDS_HEIGHT;
            dm.dmBitsPerPel = CDS_BITS;
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(1) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        ChangeMode();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fixservicestartupcirculardependency.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    FixServiceStartupCircularDependency.cpp

 Abstract:

    Hooks the call to CreateServiceA and changes the start parameter for
    only the service passed in COMMAND_LINE from SERVICE_AUTO_START to
    SERVICE_SYSTEM_START.  This eliminates a circular dependency during
    boot up which results in XP taking 15 to 20 minutes to boot.

 Notes:

    This is a general purpose shim.  Pass the service name in the command
    line.  It tests if the startup type for that service is SERVICE_AUTO_START
    and if so changes it to SERVICE_SYSTEM_START.

 History:

    02/19/2001 a-brienw Created
    02/20/2001 a-brienw Changed it to a general purpose shim using the command
                        line to pass in the service name.
    02/14/2002 astritz  Security Review

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FixServiceStartupCircularDependency)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateServiceA)
APIHOOK_ENUM_END

/*++

 Hook CreateServiceA to change the start parameter for the required service.

--*/

SC_HANDLE
APIHook_CreateServiceA(
  SC_HANDLE hSCManager,       // handle to SCM database 
  LPCSTR lpServiceName,       // name of service to start
  LPCSTR lpDisplayName,       // display name
  DWORD dwDesiredAccess,      // type of access to service
  DWORD dwServiceType,        // type of service
  DWORD dwStartType,          // when to start service
  DWORD dwErrorControl,       // severity of service failure
  LPCSTR lpBinaryPathName,    // name of binary file
  LPCSTR lpLoadOrderGroup,    // name of load ordering group
  LPDWORD lpdwTagId,          // tag identifier
  LPCSTR lpDependencies,      // array of dependency names
  LPCSTR lpServiceStartName,  // account name 
  LPCSTR lpPassword           // account password
)
{
    /*
       Only change it if it is currently SERVICE_AUTO_START.  Do not change
       the IF statement to read != as there are other startup types which do
       not result in a circular dependency.
    */
    if (dwStartType == SERVICE_AUTO_START &&
        !_stricmp(lpServiceName,COMMAND_LINE))
    {
        LOGN( eDbgLevelInfo,
            "[CreateServiceA] Fixed startup type: %s.", lpServiceName);
        dwStartType = SERVICE_SYSTEM_START;
    }
    
    return ORIGINAL_API(CreateServiceA)(hSCManager, lpServiceName,
        lpDisplayName, dwDesiredAccess, dwServiceType, dwStartType,
        dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId,
        lpDependencies, lpServiceStartName, lpPassword);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, CreateServiceA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forceansiwindowproc.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAnsiWindowProc.cpp

 Abstract:

    Apps call GetWindowLongA() to get a window procedure and subsequently 
    does not call CallWindowProc() with the value returned from 
    GetWindowLongA(). This SHIM calls GetWindowLongW( ), which returns the 
    window procedure.
        If the app wants a Dialog procedure, we pass back our function
    and subsequently call CallWindowProc() in our function. SetWindowLongA()
    is hooked to prevent the app from setting our function as a Dialog Proc. 
   
 Notes:

    This is a general purpose SHIM 
 History:

    03/16/2000 prashkud Created
    01/30/2001 prashkud Converted to a general SHIM

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAnsiWindowProc)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(GetWindowLongA) 
APIHOOK_ENUM_END

#define HANDLE_MASK 0xffff0000
LONG g_lGetWindowLongRet = 0;

LRESULT
MyProcAddress(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    return CallWindowProcA(
            (WNDPROC) g_lGetWindowLongRet,
            hWnd,
            uMsg,
            wParam,
            lParam
            );
}

LONG
APIHOOK(SetWindowLongA)(
    HWND hwnd,
    int  nIndex,
    LONG dwNewLong
     )
{
    LONG lRet = 0;

    // If the address that is being set is my address, don't!
    if (dwNewLong == (LONG)MyProcAddress)
    {
        lRet = 0;
    }
    else
    {
        lRet = ORIGINAL_API(SetWindowLongA)(hwnd,nIndex,dwNewLong);
    }

    return lRet;
}

/*++

 This function intercepts GetWindowLong( ), checks the nIndex for GWL_WNDPROC 
 and if it is,calls GetWindowLongW( ). Otherwise, it calls GetWindowLongA( )

--*/

LONG
APIHOOK(GetWindowLongA)(
    HWND hwnd,
    int  nIndex )
{
    LONG lRet = 0;

    // Apply the modification only if the App wants a WindowProc.
    if ((nIndex == GWL_WNDPROC) ||
        (nIndex == DWL_DLGPROC))
    {
        if ((nIndex == GWL_WNDPROC)) 
        {
            lRet = GetWindowLongW(hwnd, nIndex);
        }
        else
        {
            g_lGetWindowLongRet = ORIGINAL_API(GetWindowLongA)(
                                                hwnd,
                                                nIndex
                                                );
            if ((g_lGetWindowLongRet & HANDLE_MASK) == HANDLE_MASK)
            {
                lRet = (LONG) MyProcAddress;
            }
            else
            {
                lRet = g_lGetWindowLongRet;
            }
            
        }
    }
    else
    {
        lRet = ORIGINAL_API(GetWindowLongA)(hwnd, nIndex);
    }

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, GetWindowLongA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forceappendmenusuccess.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAppendMenuSuccess.cpp

 Abstract:

    Apps call AppendMenu passing the handle of the system menu.
    This is prohibited in Windows 2000 and the API will fail. The present
    shim will return success to all AppenMenu calls since there is no
    easy way to tell if an HMENU is the handle of the real system menu.

 Notes:

    This is a general shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAppendMenuSuccess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(AppendMenuA)
APIHOOK_ENUM_END

/*++

    Return TRUE to AppendMenuA no matter what.

--*/

BOOL
APIHOOK(AppendMenuA)(
    HMENU    hMenu,
    UINT     uFlags,
    UINT_PTR uIDNewItem,
    LPSTR    lpNewItem
    )
{
    BOOL bReturn = ORIGINAL_API(AppendMenuA)(
                                    hMenu,
                                    uFlags,
                                    uIDNewItem,
                                    lpNewItem);
    
    if (!bReturn) {
        LOGN(
            eDbgLevelInfo,
            "ForceAppendMenuSuccess.dll, AppendMenuA returns TRUE instead of FALSE.");
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, AppendMenuA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forcedefaultsystempaletteentries.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceDefaultSystemPaletteEntries.cpp

 Abstract:

    This shim hard-codes DefaultPalette with correct palette information.

 Notes:

    This is a general purpose shim.

 History:

    11/22/1999 linstev     Created
    11/29/2000 a-larrsh    Ported to Multi-Shim Format
--*/

#include "precomp.h"
IMPLEMENT_SHIM_BEGIN(ForceDefaultSystemPaletteEntries)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSystemPaletteEntries)
APIHOOK_ENUM_END

// Initialize global palette
DWORD DefaultPalette[256] = 
{
    0x00000000, 0x00000080, 0x00008000, 0x00008080,
    0x00800000, 0x00800080, 0x00808000, 0x00C0C0C0,
    0x00C0DCC0, 0x00F0CAA6, 0x04081824, 0x04142830,
    0x0418303C, 0x04304D61, 0x0451514D, 0x044D7161,
    0x04826D61, 0x040C1414, 0x04597582, 0x04759E08,
    0x04303438, 0x04AA6938, 0x04203428, 0x04496161,
    0x0449869E, 0x047D9A6D, 0x040869CB, 0x048E8682,
    0x0475615D, 0x040061EB, 0x04000871, 0x042C3830,
    0x040471EF, 0x048E92AA, 0x04306DF7, 0x0404C3C3,
    0x0492AAB2, 0x04101814, 0x04040C08, 0x040C7110,
    0x04CFA282, 0x040008AA, 0x0428412C, 0x04498EB2,
    0x04204D61, 0x04555955, 0x0404D3D3, 0x041C3C4D,
    0x0420A6F7, 0x0410A210, 0x0418241C, 0x045DAEF3,
    0x04719EAA, 0x04B2E720, 0x04102871, 0x0486C3D3,
    0x04288A2C, 0x040C51BA, 0x0459716D, 0x04494D4D,
    0x04AAB6C3, 0x04005100, 0x0420CBF7, 0x044D8A51,
    0x04BEC7B2, 0x04043CBA, 0x04101C18, 0x040851DF,
    0x04A6E7A6, 0x049ECF24, 0x04797592, 0x04AE7559,
    0x049E8269, 0x04CFE3DF, 0x040C2030, 0x0428692C,
    0x049EA2A2, 0x04F7C782, 0x0434617D, 0x04B6BEBE,
    0x04969E86, 0x04DBFBD3, 0x04655149, 0x0465EF65,
    0x04AED3D3, 0x04E7924D, 0x04B2BEB2, 0x04D7DBDB,
    0x04797571, 0x04344D59, 0x0486B2CF, 0x04512C14,
    0x04A6FBFB, 0x04385965, 0x04828E92, 0x041C4161,
    0x04595961, 0x04002000, 0x043C6D7D, 0x045DB2D7,
    0x0438EF3C, 0x0451CB55, 0x041C2424, 0x0461C3F3,
    0x0408A2A2, 0x0438413C, 0x04204951, 0x04108A14,
    0x04103010, 0x047DE7F7, 0x04143449, 0x04B2652C,
    0x04F7EBAA, 0x043C7192, 0x0404FBFB, 0x04696151,
    0x04EFC796, 0x040441D7, 0x04000404, 0x04388AF7,
    0x048AD3F3, 0x04006500, 0x040004E3, 0x04DBFFFF,
    0x04F7AE69, 0x04CF864D, 0x0455A2D3, 0x04EBEFE3,
    0x04EB8A41, 0x04CF9261, 0x04C3F710, 0x048E8E82,
    0x04FBFFFF, 0x04104110, 0x04040851, 0x0482FBFB,
    0x043CC734, 0x04088A8A, 0x04384545, 0x04514134,
    0x043C7996, 0x041C6161, 0x04EBB282, 0x04004100,
    0x04715951, 0x04A2AAA6, 0x04B2B6B2, 0x04C3FBFB,
    0x04000834, 0x0428413C, 0x04C7C7CF, 0x04CFD3D3,
    0x04824520, 0x0408CB0C, 0x041C1C1C, 0x04A6B29A,
    0x0471A6BE, 0x04CF9E6D, 0x046D7161, 0x04008A04,
    0x045171BE, 0x04C7D3C3, 0x04969E96, 0x04798696,
    0x042C1C10, 0x04385149, 0x04BE7538, 0x0408141C,
    0x04C3C7C7, 0x04202C28, 0x04D3E3CF, 0x0471826D,
    0x04653C1C, 0x0404EF08, 0x04345575, 0x046D92A6,
    0x04797979, 0x0486F38A, 0x04925528, 0x04E3E7E7,
    0x04456151, 0x041C499A, 0x04656961, 0x048E9EA2,
    0x047986D3, 0x04204151, 0x048AC7E3, 0x04007100,
    0x04519EBE, 0x0410510C, 0x04A6AAAA, 0x042C3030,
    0x04D37934, 0x04183030, 0x0449828E, 0x04CBFBC3,
    0x046D7171, 0x040428A6, 0x044D4545, 0x04040C14,
    0x04087575, 0x0471CB79, 0x044D6D0C, 0x04FBFBD3,
    0x04AAB2AE, 0x04929292, 0x04F39E55, 0x04005D00,
    0x04E3D7B2, 0x04F7FBC3, 0x043C5951, 0x0404B2B2,
    0x0434658E, 0x040486EF, 0x04F7FBE3, 0x04616161,
    0x04DFE3DF, 0x041C100C, 0x0408100C, 0x0408180C,
    0x04598600, 0x0424FBFB, 0x04346171, 0x04042CC7,
    0x04AEC79A, 0x0445AE4D, 0x0428A62C, 0x04EFA265,
    0x047D8282, 0x04F7D79A, 0x0465D3F7, 0x04E3E7BA,
    0x04003000, 0x04245571, 0x04DF823C, 0x048AAEC3,
    0x04A2C3D3, 0x04A6FBA2, 0x04F3FFF3, 0x04AAD7E7,
    0x04EFEFC3, 0x0455F7FB, 0x04EFF3F3, 0x04BED3B2,
    0x0404EBEB, 0x04A6E3F7, 0x00F0FBFF, 0x00A4A0A0,
    0x00808080, 0x000000FF, 0x0000FF00, 0x0000FFFF,
    0x00FF0000, 0x00FF00FF, 0x00FFFF00, 0x00FFFFFF
};

/*++

 Copy the values stored in DefaultPalette into lppe.

--*/

UINT 
APIHOOK(GetSystemPaletteEntries)(
    HDC hdc,             
    UINT iStartIndex,     
    UINT nEntries,        
    LPPALETTEENTRY lppe
    )
{
    if (lppe)
    {
        if (iStartIndex < 256)
        {
            // From original NT code, prevent overruning the user-provided buffer.
            int cToCopy = min(256-iStartIndex, nEntries);
            memcpy(
                lppe, 
                &DefaultPalette[iStartIndex], 
                cToCopy * sizeof(PALETTEENTRY));
        }
    }
    else
    {
        nEntries = 256;
    }
        
    return nEntries;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetSystemPaletteEntries)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forcedirectdrawemulation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ForceDirectDrawEmulation.cpp

 Abstract:

    Some applications don't handle aspects of hardware acceleration correctly.
    For example, Dragon Lore 2 creates a surface and assumes that the pitch is 
    double the width for 16bpp. However, this is not always the case. 
    DirectDraw exposes this through the lPitch parameter when a surface is 
    locked. 

    The fix is to force DirectDraw into emulation, in which case all surfaces 
    will be in system memory and so the pitch really will be related to the 
    width.

 Notes:

    This is a general purpose shim.

 History:

    03/11/2000 linstev     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceDirectDrawEmulation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
APIHOOK_ENUM_END

/*++

 Force DirectDraw into emulation.

--*/

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY hKey,           
    LPSTR lpValueName,  
    LPDWORD lpReserved,  
    LPDWORD lpType,      
    LPBYTE lpData,       
    LPDWORD lpcbData     
    )
{
    if (lpValueName && _stricmp("EmulationOnly", lpValueName) == 0)
    {
        LONG lRet = ERROR_SUCCESS;
        if (lpType)
        {
            *lpType = REG_DWORD;
        }

        if (lpData && !lpcbData)
        {
           return ERROR_INVALID_PARAMETER;
        }

        if (lpData)
        {
           if (*lpcbData >= 4)
           {
              *((DWORD *)lpData) = 1;
           }
           else
           {
              lRet = ERROR_MORE_DATA;
           }           
        }

        if (lpcbData)
        {
            *lpcbData = 4;
        }

        return lRet;
    }

    return ORIGINAL_API(RegQueryValueExA)(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA) 

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forcedirectdrawwait.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ForceDirectDrawWait.cpp

 Abstract:

    Some applications don't specify the DD_WAIT flag to 
    IDirectDrawSurface::Lock, which means that if it fails because the device
    is busy, the app can fail. This could also happen on Win9x of course, but 
    was more difficult to repro.

    Note that we don't need to do this on the IDirectDraw7 interface since the
    default is DDLOCK_WAIT, unless DDLOCK_DONOTWAIT is specified.

 Notes:

    This is a general purpose shim.

 History:

    03/04/2000 linstev     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceDirectDrawWait)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface2, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw4, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw4_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw4, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface4, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Make sure we add DDBLT_WAIT.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    dwFlags &= ~DDBLT_DONOTWAIT;
    dwFlags |= DDBLT_WAIT;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(
        IDirectDrawSurface, 
        Blt, 
        lpDDDestSurface);

    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

HRESULT 
COMHOOK(IDirectDrawSurface2, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    dwFlags &= ~DDBLT_DONOTWAIT;
    dwFlags |= DDBLT_WAIT;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(
        IDirectDrawSurface2, 
        Blt, 
        lpDDDestSurface);

    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

HRESULT 
COMHOOK(IDirectDrawSurface4, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    dwFlags &= ~DDBLT_DONOTWAIT;
    dwFlags |= DDBLT_WAIT;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(
        IDirectDrawSurface4, 
        Blt, 
        lpDDDestSurface);

    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

/*++

 Make sure we add DDLOCK_WAIT.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Lock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    dwFlags &= ~DDLOCK_DONOTWAIT;
    dwFlags |= DDLOCK_WAIT;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(
        IDirectDrawSurface, 
        Lock, 
        lpDDSurface);

    // Call the old API
    return (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent);
}

HRESULT 
COMHOOK(IDirectDrawSurface2, Lock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    dwFlags &= ~DDLOCK_DONOTWAIT;
    dwFlags |= DDLOCK_WAIT;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(
        IDirectDrawSurface2, 
        Lock, 
        lpDDSurface);

    // Call the old API
    return (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent);
}

HRESULT 
COMHOOK(IDirectDrawSurface4, Lock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    dwFlags &= ~DDLOCK_DONOTWAIT;
    dwFlags |= DDLOCK_WAIT;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(
        IDirectDrawSurface4, 
        Lock, 
        lpDDSurface);

    // Call the old API
    return (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, CreateSurface, 6)

    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Blt, 5)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface2, Blt, 5)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface4, Blt, 5)

    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Lock, 25)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface2, Lock, 25)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface4, Lock, 25)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forceapplicationfocus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceApplicationFocus.cpp

 Abstract:

    This shim calls SetForegroundWindow after CreateWindowEx and ShowWindow 
    calls to fix focus problems that applications tend to have when they 
    create/destroy windows on startup and manage to lose the foreground focus.

 Notes:

    This is a general purpose shim.

 History:

    12/02/1999 markder     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceApplicationFocus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShowWindow)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
    APIHOOK_ENUM_ENTRY(CreateWindowExW)
APIHOOK_ENUM_END

/*++

 Calls SetForegroundWindow directly after a ShowWindow call with SW_SHOW as
 the operation. The mouse_event call allows the SetForegroundWindow call to 
 succeed. This is a hack borrowed from the DirectX sources.

--*/

BOOL 
APIHOOK(ShowWindow)(
    HWND hWnd, 
    INT nCmdShow
    )
{
    BOOL bReturn;

    bReturn = ORIGINAL_API(ShowWindow)(hWnd, nCmdShow);

    if (nCmdShow == SW_SHOW)
    {
        if (hWnd != GetForegroundWindow()) {
            LOGN( eDbgLevelWarning, 
               "ShowWindow called for non-foreground window. Forcing to foreground.");
        }
        mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
        SetForegroundWindow(hWnd);
    }

    return bReturn;
}

/*++

 Calls SetForegroundWindow directly after a CreateWindowEx call with 
 WS_VISIBLE as a style. The mouse_event call allows the
 SetForegroundWindow call to succeed. This is a hack borrowed from
 the DirectX sources.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  
    LPCSTR lpWindowName, 
    DWORD dwStyle,       
    int x,               
    int y,               
    int nWidth,          
    int nHeight,         
    HWND hWndParent,     
    HMENU hMenu,         
    HINSTANCE hInstance, 
    LPVOID lpParam       
    )
{
    HWND hReturn;

    hReturn = ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,      
        lpWindowName,     
        dwStyle,          
        x,                
        y,                
        nWidth,           
        nHeight,          
        hWndParent,       
        hMenu,            
        hInstance,        
        lpParam);

    if (hReturn && (dwStyle & WS_VISIBLE))
    {
        if (hReturn != GetForegroundWindow()) {
            LOGN( eDbgLevelWarning, 
               "CreateWindowExA: New window not foreground. Forcing to foreground.");
        }
        mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
        SetForegroundWindow(hReturn);
    }

    return hReturn;
}

/*++

 Calls SetForegroundWindow directly after a CreateWindowEx call with
 WS_VISIBLE as a style. The mouse_event call allows the
 SetForegroundWindow call to succeed. This is a hack borrowed from
 the DirectX sources.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,      
    LPCWSTR lpClassName,  
    LPCWSTR lpWindowName, 
    DWORD dwStyle,        
    int x,                
    int y,                
    int nWidth,           
    int nHeight,          
    HWND hWndParent,      
    HMENU hMenu,          
    HINSTANCE hInstance,  
    LPVOID lpParam        
    )
{
    HWND hReturn;

    hReturn = ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,     
        x,           
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,     
        hInstance, 
        lpParam);

    if (hReturn && (dwStyle & WS_VISIBLE))
    {
        if (hReturn != GetForegroundWindow()) {
            LOGN( eDbgLevelWarning, "CreateWindowExW: New window not foreground. Forcing to foreground.");
        }
        mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
        SetForegroundWindow(hReturn);
    }

    return hReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ShowWindow)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forcedisplaymode.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ForceDisplayMode.cpp

 Abstract:

    This shim is for games that require a specific resolution to run at.

    It takes a command line to specify the resolution: width in pixels, height 
    in pixels,bits per pixel if you don't specify one or more of those, we'll 
    use the current setting.    
    
        eg: 1024,768 will change resolution to 1024x768.
        eg: ,,16 will change the color depth to 16 bit.

 Notes:

    This is a general purpose shim.

 History:

    11/08/2000  maonis      Created (adopted from Force640x480x8 and Force640x480x16 shims)
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceDisplayMode)
#include "ShimHookMacro.h"

// This module has been given an official blessing to use the str routines.
#include "strsafe.h"

#define MAX_LENGTH 1024

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

DWORD g_dmPelsWidth = 0;
DWORD g_dmPelsHeight = 0;
DWORD g_dmBitsPerPel = 0;

VOID 
ParseCommandLine(
    LPCSTR lpCommandLine
    )
{

    size_t slen = 0;
    if (FAILED(StringCchLengthA((char *)lpCommandLine, MAX_LENGTH, &slen)))
    {
        DPFN( eDbgLevelError, 
           "[ParseCommandLine] Error in StringCchLength \n");
        return;
    }

    LPSTR szCommandLine = (LPSTR) malloc(slen + 1);
    if (!szCommandLine) {
        DPFN( eDbgLevelError, 
           "[ParseCommandLine] not enough memory\n");
        return;
    }
         
    if (FAILED(StringCchCopyA(szCommandLine, (slen + 1), lpCommandLine)))
    {
        DPFN( eDbgLevelError, 
           "[ParseCommandLine] Error in StringCchCopyA \n");
        return;
    }

    char *token, *szCurr = szCommandLine;
    
    if (token = strchr(szCurr, ',')) {
        *token = '\0';
        g_dmPelsWidth = atol(szCurr);
        szCurr = token + 1;

        if (token = strchr(szCurr, ',')) {
            *token = '\0';
            g_dmBitsPerPel = atol(token + 1);
        }

        g_dmPelsHeight = atol(szCurr);
    } else {
        g_dmPelsWidth = atol(szCurr);
    }

    DPFN( eDbgLevelError, 
       "[ParseCommandLine] width = %d pixels; height = %d pixels; color depth = %d\n", g_dmPelsWidth, g_dmPelsHeight, g_dmBitsPerPel);

    free(szCommandLine);
}

VOID
ChangeMode()
{
    DEVMODEA dm;
    BOOL fNeedChange = FALSE;
    
    __try { 
        EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm);

        if (g_dmPelsWidth && g_dmPelsWidth != dm.dmPelsWidth) {
            dm.dmPelsWidth = g_dmPelsWidth;
            fNeedChange = TRUE;
        }

        if (g_dmPelsHeight && g_dmPelsHeight != dm.dmPelsHeight) {
            dm.dmPelsHeight = g_dmPelsHeight;
            fNeedChange = TRUE;
        }

        if (g_dmBitsPerPel && g_dmBitsPerPel != dm.dmBitsPerPel) {
            dm.dmBitsPerPel = g_dmBitsPerPel;
            fNeedChange = TRUE;
        }

        if (fNeedChange) {
            ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);
        }
    }
    __except(1) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        ParseCommandLine(COMMAND_LINE);
        ChangeMode();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forceseparatevdm.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ForceSeparateVDM.cpp   

 Abstract:

    Force child processes to use a separate VDM. 
    
    This can be useful if the parent process wants to wait on a handle returned
    by CreateProcess. This only works because of a hack in the VDM that returns 
    and actual thread handle that will go away along with the process if a VDM 
    doesn't already exist.

 Notes:

    This is a general purpose shim.

 History:

   06/14/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceSeparateVDM)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
    APIHOOK_ENUM_ENTRY(CreateProcessW) 
APIHOOK_ENUM_END

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (!(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
        LOGN(eDbgLevelWarning, "Added CREATE_SEPARATE_WOW_VDM to CreateProcessA"); 
    }
    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine, 
        lpProcessAttributes, lpThreadAttributes, bInheritHandles,
        dwCreationFlags | CREATE_SEPARATE_WOW_VDM,
        lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (!(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
        LOGN(eDbgLevelWarning, "Added CREATE_SEPARATE_WOW_VDM to CreateProcessW"); 
    }
    return ORIGINAL_API(CreateProcessW)(lpApplicationName, lpCommandLine, 
        lpProcessAttributes, lpThreadAttributes, bInheritHandles,
        dwCreationFlags | CREATE_SEPARATE_WOW_VDM,
        lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forceaviwindow.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAVIWindow.cpp

 Abstract:

    Some apps that use MCI to play their AVIs send messages in an order that
    causes mciavi32 to continually re-open the window it's supposed to be 
    playing to.

    The code in mciavi is different on win9x, so the exact reason for this shim 
    is hidden in layers of user/avi code. Here we just filter the message that 
    causes the avi stuff to not use the existing window it's been given.

 Notes:

    This is an app specific shim.

 History:

    02/22/2000 linstev     Created
    09/27/2000 mnikkel     Modified to destroy the MCI window on a command line input

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAVIWindow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PostMessageW)
APIHOOK_ENUM_END

BOOL g_bDestroyWindow= FALSE;

/*++

 Filter AVIM_SHOWSTAGE
 
--*/

BOOL 
APIHOOK(PostMessageW)(
    HWND hWnd,      
    UINT Msg,       
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    #define AVIM_SHOWSTAGE  (WM_USER+104)

    BOOL bRet;

    // Eat the AVIM_SHOWSTAGE message
    if (Msg != AVIM_SHOWSTAGE)
    {        
        bRet = ORIGINAL_API(PostMessageW)(
            hWnd,
            Msg,
            wParam,
            lParam);
    }
    else    
    {
        LOGN( eDbgLevelError, 
           "[APIHook_PostMessageW] AVIM_SHOWSTAGE message discarded");

        // if command line specified to destroy the MCI window do so now.
        if (g_bDestroyWindow)
        {
            MCIWndDestroy(hWnd);
        }

        bRet = TRUE;
    }

    return bRet;
}
 
/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
            g_bDestroyWindow = csCl.CompareNoCase(L"DestroyMCIWindow") == 0;
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, PostMessageW)
    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forceworkingdirectorytoexepath.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ForceWorkingDirectoryToEXEPath.cpp

 Abstract:

   This shim forces the working directory to match the executables path in a 
   short cut link. This shim is used in the case of the working directory
   in the link being incorrect and causing the application to work 
   incorrectly.  When this shim is applied the call to SetWorkingDirectory will
   be ignored and will be executed when SetPath is called.

 Notes:

   This is a general purpose shim.

 History:

   09/27/2000 a-brienw Created
   11/15/2000 a-brienw added some error checking as precautionary measure.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceWorkingDirectoryToEXEPath)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)


HRESULT MySetWorkingDirectoryW( PVOID pThis, const CString & pszDir, const CString & pszFile );
HRESULT MySetWorkingDirectoryA( PVOID pThis, const CString & csDir, const CString & csFile );


/*++

  Hook IShellLinkA::SetWorkingDirectory and call local
  SetWorkingDirectoryA to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetWorkingDirectory)(
    PVOID pThis,
    LPCSTR pszDir
    )
{
    CSTRING_TRY
    {
        CString csDummyPath;
        return MySetWorkingDirectoryA( pThis, pszDir, csDummyPath);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError,"Exception encountered");
    }

    _pfn_IShellLinkA_SetWorkingDirectory pfnSetWorkingDir =
        ORIGINAL_COM(IShellLinkA, SetWorkingDirectory, pThis);
     return((*pfnSetWorkingDir)(pThis, pszDir));
}

/*++

  Hook IShellLinkW::SetWorkingDirectory and call local
  SetWorkingDirectoryW to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkW, SetWorkingDirectory)(
    PVOID pThis,
    LPCWSTR pszDir
    )
{
    return MySetWorkingDirectoryW( pThis, pszDir, NULL );
}

/*++

  Hook IShellLinkA::SetPath and call local
  SetWorkingDirectoryA to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetPath)(
    PVOID pThis,
    LPCSTR pszFile
    )
{
    CSTRING_TRY
    {
        CString csDummyPath;
        return MySetWorkingDirectoryA( pThis, csDummyPath, pszFile);
    }
    CSTRING_CATCH
    {
         DPFN( eDbgLevelError,"Exception encountered");    
    }

    _pfn_IShellLinkA_SetPath pfnSetPath = ORIGINAL_COM(IShellLinkA, SetPath, pThis);
    return (*pfnSetPath)(pThis, pszFile);
}

/*++

  Hook IShellLinkW::SetPath and call local
  SetWorkingDirectoryW to handle the input.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkW, SetPath)(
    PVOID pThis,
    LPCWSTR pszFile
    )
{
    if (pszFile == NULL)
    {
        return S_OK;    // We will fault later otherwise.
    }
    return MySetWorkingDirectoryW( pThis, NULL, pszFile );
}

/*++

  This routine handles the input of SetPath and
  SetWorkingDirectory and determines what path
  to really place in the short cut link's working
  directory.

--*/

HRESULT
MySetWorkingDirectoryA(
    PVOID pThis,
    const CString & csDir,
    const CString & csFile
    )
{
    
    HRESULT hReturn = NOERROR;

    CSTRING_TRY
    {
        char szDir[_MAX_PATH+1];
        CString csStoredDir;
        bool doit = false;        
        
        if( csFile.IsEmpty())
        {
            // handle passed in working directory
            IShellLinkA *MyShellLink = (IShellLinkA *)pThis;

            // now call IShellLink::GetWorkingDirectory
            hReturn = MyShellLink->GetWorkingDirectory(
                szDir,
                _MAX_PATH+1);
            
            // if the stored working directory has not
            // been stored use the one passed in.
            csStoredDir = szDir;
            if (csStoredDir.GetLength() < 1 )
            {
                csStoredDir = csDir;
            }             

            doit = true;
            hReturn = NOERROR;
        }
        else
        {
            _pfn_IShellLinkA_SetPath    pfnSetPath;

            // Look up IShellLink::SetPath
            pfnSetPath = (_pfn_IShellLinkA_SetPath)
                ORIGINAL_COM( IShellLinkA, SetPath, pThis);

            // build working directory from exe path & name
            int len;
            csStoredDir = csFile;

            // now search backwards from the end of the string
            // for the first \ and terminate the string there
            // making that the new path.
            len = csStoredDir.ReverseFind(L'\\');
            if (len > 0)
            {            
                doit = true;
                csStoredDir.Truncate(len);
                if(csStoredDir[0] == L'"')
                {
                    csStoredDir += L'"';
                }
            }

            // now call the IShellLink::SetPath
            hReturn = (*pfnSetPath)( pThis, csFile.GetAnsi());
        }

        // if there was no error
        if (hReturn == NOERROR)
        {
            // and we have a working directory to set
            if( doit == true )
            {
                _pfn_IShellLinkA_SetWorkingDirectory    pfnSetWorkingDirectory;

                // Look up IShellLink::SetWorkingDirectory
                pfnSetWorkingDirectory = (_pfn_IShellLinkA_SetWorkingDirectory)
                    ORIGINAL_COM( IShellLinkA, SetWorkingDirectory, pThis);

                // now call the IShellLink::SetWorkingDirectory
                if( pfnSetWorkingDirectory != NULL )
                {
                    hReturn = (*pfnSetWorkingDirectory)(
                        pThis,
                        csStoredDir.GetAnsi());
                }
                else
                {
                    hReturn = E_OUTOFMEMORY;
                }
            }
        }
    }
    CSTRING_CATCH
    {
    }

    // return the error status
    return( hReturn );
}

/*++

  This routine handles the input of SetPath and
  SetWorkingDirectory and determines what path
  to really place in the short cut link's working
  directory.

--*/

HRESULT
MySetWorkingDirectoryW(
    PVOID pThis,
    const CString & csDir,
    const CString & csFile
    )
{
    HRESULT hReturn = NOERROR;
    CSTRING_TRY
    {
        wchar_t szDir[_MAX_PATH+1];    
        bool doit = false;        
        CString csStoredDir;

        if( csFile.IsEmpty())
        {
            // handle passed in working directory
            IShellLinkW *MyShellLink = (IShellLinkW *)pThis;

            // now call IShellLink::GetWorkingDirectory
            hReturn = MyShellLink->GetWorkingDirectory(
                szDir,
                _MAX_PATH);
            
            // if the stored working directory has not
            // been stored use the one passed in.
            csStoredDir = szDir;
            if( csStoredDir.GetLength() < 1 )
            {
                csStoredDir = csDir;
            }

            doit = true;
            hReturn = NOERROR;
        }
        else
        {
            _pfn_IShellLinkW_SetPath    pfnSetPath;

            // Look up IShellLink::SetPath
            pfnSetPath = (_pfn_IShellLinkW_SetPath)
                ORIGINAL_COM( IShellLinkW, SetPath, pThis);

            // build working directory from exe path & name
            int len;

            csStoredDir = csFile;
            len = csStoredDir.ReverseFind(L'\\');            

            // now search backwards from the end of the string
            // for the first \ and terminate the string there
            // making that the new path.

            if (len > 0)
            {            
                doit = true;
                csStoredDir.Truncate(len);
                if(csStoredDir[0] == L'"')
                {
                    csStoredDir += L'"';
                }
            }            

            // now call the IShellLink::SetPath
            hReturn = (*pfnSetPath)( pThis, csFile.Get());
        }

        // if there was no error
        if (hReturn == NOERROR)
        {
            // and we have a working directory to set
            if( doit == true )
            {
                _pfn_IShellLinkW_SetWorkingDirectory    pfnSetWorkingDirectory;

                // Look up IShellLink::SetWorkingDirectory
                pfnSetWorkingDirectory = (_pfn_IShellLinkW_SetWorkingDirectory)
                    ORIGINAL_COM( IShellLinkW, SetWorkingDirectory, pThis);

                // now call the IShellLink::SetWorkingDirectory
                if( pfnSetWorkingDirectory != NULL )
                {
                    hReturn = (*pfnSetWorkingDirectory)(
                        pThis,
                        csStoredDir.Get());
                }
                else
                {
                    hReturn = E_OUTOFMEMORY;
                }
            }
        }
    }
    CSTRING_CATCH
    {
    }

    // return the error status
    return( hReturn );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_COMSERVER(SHELL32)

    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetWorkingDirectory, 9)
    COMHOOK_ENTRY(ShellLink, IShellLinkW, SetWorkingDirectory, 9)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
    COMHOOK_ENTRY(ShellLink, IShellLinkW, SetPath, 20)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forcesimplewindow.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceSimpleWindow.cpp

 Abstract:

    Make the simplest possible full-screen window.

 Notes:

    This is a general purpose shim, but should not be used in a layer.

 History:

    06/01/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceSimpleWindow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
    APIHOOK_ENUM_ENTRY(CreateWindowExW)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(SetWindowLongW)
APIHOOK_ENUM_END

BOOL g_bFullScreen = TRUE;

/*++

 Simplify window if it's not a child.
 
--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    if (!(dwStyle & WS_CHILD))
    {
        DPFN( eDbgLevelWarning, "Window \"%s\" style simplified: WS_STYLE=%08lx, WS_EXSTYLE=%08lx", lpWindowName, dwStyle, dwExStyle);

        dwStyle &= WS_VISIBLE;
        dwStyle |= WS_OVERLAPPED|WS_POPUP;

        dwExStyle = 0;

        if (g_bFullScreen)
        {
            DPFN( eDbgLevelWarning, "Window \"%s\" maximized", lpWindowName);
            x = y = 0;
            nWidth = GetSystemMetrics(SM_CXSCREEN);
            nHeight = GetSystemMetrics(SM_CYSCREEN);
            dwExStyle = WS_EX_TOPMOST;
        }
    }

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Simplify window if it's not a child.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    if (!(dwStyle & WS_CHILD))
    {
        DPFN( eDbgLevelWarning, "Window \"%S\" style simplified: WS_STYLE=%08lx, WS_EXSTYLE=%08lx", lpWindowName, dwStyle, dwExStyle);

        dwStyle &= WS_VISIBLE;
        dwStyle |= WS_OVERLAPPED|WS_POPUP;

        dwExStyle = 0;

        if (g_bFullScreen)
        {
            DPFN( eDbgLevelWarning, "Window \"%S\" maximized", lpWindowName);
            x = y = 0;
            nWidth = GetSystemMetrics(SM_CXSCREEN);
            nHeight = GetSystemMetrics(SM_CYSCREEN);
            dwExStyle = WS_EX_TOPMOST;
        }
    }

    return ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if ((nIndex == GWL_STYLE) || (nIndex == GWL_EXSTYLE))
    {
        CHAR szName[MAX_PATH];
        GetWindowTextA(hWnd, szName, MAX_PATH);
        DPFN( eDbgLevelWarning, "Window \"%s\": ignoring style change", szName);
        return GetWindowLongA(hWnd, nIndex);
    }
    else
    {
        return ORIGINAL_API(SetWindowLongA)(  
            hWnd,
            nIndex,
            dwNewLong);
    }
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if ((nIndex == GWL_STYLE) || (nIndex == GWL_EXSTYLE))
    {
        CHAR szName[MAX_PATH];
        GetWindowTextA(hWnd, szName, MAX_PATH);
        DPFN( eDbgLevelWarning, "Window \"%s\": ignoring style change", szName);
        return GetWindowLongW(hWnd, nIndex);
    }
    else
    {
        return ORIGINAL_API(SetWindowLongW)(  
            hWnd,
            nIndex,
            dwNewLong);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CString csCl(COMMAND_LINE);
        g_bFullScreen = csCl.CompareNoCase(L"FULLSCREEN") == 0;
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fusapi.h ===
//  --------------------------------------------------------------------------
//  Module Name: FUSAPI.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage communication with the BAM server for shims.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _FUSAPI_
#define     _FUSAPI_

//  --------------------------------------------------------------------------
//  CFUSAPI
//
//  Purpose:    Class that knows how to communicate with the BAM server.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

class   CFUSAPI
{
    private:
                CFUSAPI (void);
    public:
                CFUSAPI (const WCHAR *pszImageName);
                ~CFUSAPI (void);

        bool    IsRunning (void);
        bool    TerminatedFirstInstance (void);
        void    RegisterBadApplication (BAM_TYPE bamType);
    private:
        void    DWORDToString (DWORD dwNumber, WCHAR *pszString);
    private:
        HANDLE  _hPort;
        WCHAR*  _pszImageName;
};

#endif  /*  _FUSAPI_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\forcetemporarymodechange.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceTemporaryModeChange.cpp

 Abstract:

    A hack for several apps that permanently change the display mode and fail
    to restore it correctly. Some of these apps do restore the resolution, but 
    not the refresh rate. 1024x768 @ 60Hz looks really bad.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceTemporaryModeChange)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsW)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExW)
APIHOOK_ENUM_END

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD      dwFlags
    )
{
    if (dwFlags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsA] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsA)(
        lpDevMode,
        CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsW)(
    LPDEVMODEW lpDevMode,
    DWORD      dwFlags
    )
{
    if (dwFlags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsW] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsW)(
        lpDevMode,
        CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR     lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (dwflags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsExA] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsExA)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        CDS_FULLSCREEN, 
        lParam);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExW)(
    LPCWSTR    lpszDeviceName,
    LPDEVMODEW lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (dwflags != CDS_FULLSCREEN) {
        LOGN(
            eDbgLevelError,
            "[ChangeDisplaySettingsExW] Changing flags to CDS_FULLSCREEN.");
    }

    return ORIGINAL_API(ChangeDisplaySettingsExW)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        CDS_FULLSCREEN, 
        lParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsW)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fusbadapplicationtype1.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType1.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 1.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"

IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType1)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 1 applications if the image is already running then
//              try to terminate the first instance if possible. Prompt the
//              user to give some input. If the termination succeeds treat
//              this like it's not running. In that case register this process
//              as the instance that's bad.
//
//              Otherwise exit this process. Don't give it a chance to run.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
   switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            if (!fusAPI.IsRunning() || fusAPI.TerminatedFirstInstance())
            {
                fusAPI.RegisterBadApplication(BAM_TYPE_SECOND_INSTANCE_START);
            }
            else
            {
                ExitProcess(0);
            }
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fusapi.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSAPI.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to manage communication with the BAM server for shims.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "strsafe.h"
#include "FUSAPI.h"

#ifndef ARRAYSIZE
   #define ARRAYSIZE(x)    (sizeof(x) / sizeof((x)[0]))
#endif
#define TBOOL(x)        (BOOL)(x)
#define TSTATUS(x)      (NTSTATUS)(x)

//  --------------------------------------------------------------------------
//  CFUSAPI::CFUSAPI
//
//  Arguments:  pszImageName    =   Image name of the desired process.
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CFUSAPI. Establishes a connection with the
//              BAM server. Saves off the image name given or the image name
//              of the current process if not specified.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

CFUSAPI::CFUSAPI (const WCHAR *pszImageName) :
    _hPort(NULL),
    _pszImageName(NULL)

{
    ULONG                           ulConnectionInfoLength;
    UNICODE_STRING                  portName, *pImageName;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    WCHAR                           szConnectionInfo[32];

    RtlInitUnicodeString(&portName, FUS_PORT_NAME);
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = TRUE;
    StringCbCopyW(szConnectionInfo, sizeof(szConnectionInfo),FUS_CONNECTION_REQUEST);
    ulConnectionInfoLength = sizeof(szConnectionInfo);
    TSTATUS(NtConnectPort(&_hPort,
                          &portName,
                          &sqos,
                          NULL,
                          NULL,
                          NULL,
                          szConnectionInfo,
                          &ulConnectionInfoLength));
    if (pszImageName != NULL)
    {
        _pszImageName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, (lstrlen(pszImageName) + sizeof('\0')) * sizeof(WCHAR)));
        if (_pszImageName != NULL)
        {
            (TCHAR*)StringCbCopyW(_pszImageName, (lstrlen(pszImageName) + sizeof('\0')), pszImageName);
        }
    }
    else
    {
        pImageName = &NtCurrentPeb()->ProcessParameters->ImagePathName;
        _pszImageName = static_cast<WCHAR*>(LocalAlloc(LMEM_FIXED, pImageName->Length + sizeof(WCHAR)));
        if (_pszImageName != NULL)
        {
            CopyMemory(_pszImageName, pImageName->Buffer, pImageName->Length);
            _pszImageName[pImageName->Length / sizeof(WCHAR)] = L'\0';
        }
    }
}

//  --------------------------------------------------------------------------
//  CFUSAPI::~CFUSAPI
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CFUSAPI. Releases resources used by the class.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

CFUSAPI::~CFUSAPI (void)

{
    if (_pszImageName != NULL)
    {
        (HLOCAL)LocalFree(_pszImageName);
        _pszImageName = NULL;
    }
    if (_hPort != NULL)
    {
        TBOOL(CloseHandle(_hPort));
        _hPort = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CFUSAPI::IsRunning
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Asks the BAM server is the image name running?
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CFUSAPI::IsRunning (void)

{
    bool    fResult;

    fResult = false;
    if ((_hPort != NULL) && (_pszImageName != NULL))
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_QUERYRUNNING;
        portMessageIn.apiBAM.apiSpecific.apiQueryRunning.in.pszImageName = _pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiQueryRunning.in.cchImageName = lstrlenW(_pszImageName) + sizeof('\0');
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        if (NT_SUCCESS(NtRequestWaitReplyPort(_hPort, &portMessageIn.portMessage, &portMessageOut.portMessage)) &&
            NT_SUCCESS(portMessageOut.apiBAM.apiGeneric.status))
        {
            fResult = portMessageOut.apiBAM.apiSpecific.apiQueryRunning.out.fResult;
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CFUSAPI::TerminatedFirstInstance
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Starts a child process to bring up UI for the current process.
//              The current process is shim'd typically as a BAM type 1
//              process. The child process makes the decision and presents
//              appropriate UI and returns the result to this process in the
//              exit code. This process then makes a decision on what to do.
//              The process is halted waiting for the child process (with the
//              loader lock held).
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

bool    CFUSAPI::TerminatedFirstInstance (void)

{
    bool                    fResult;
    HANDLE                  hProcess;
    STARTUPINFO             startupInfo;
    PROCESS_INFORMATION     processInformation;
    WCHAR                   szCommandLine[MAX_PATH];

    fResult = false;
    (DWORD)ExpandEnvironmentStringsW(L"%systemroot%\\system32\\rundll32.exe %systemroot%\\system32\\shsvcs.dll,FUSCompatibilityEntry prompt", szCommandLine, ARRAYSIZE(szCommandLine));
    if (DuplicateHandle(GetCurrentProcess(),
                        GetCurrentProcess(),
                        GetCurrentProcess(),
                        &hProcess,
                        PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
                        TRUE,
                        0) != FALSE)
    {
        WCHAR   szProcessHandle[16];

        DWORDToString(HandleToULong(hProcess), szProcessHandle);
        (WCHAR*)StringCbCatW(szCommandLine, sizeof(szCommandLine), L" ");
        (WCHAR*)StringCbCatW(szCommandLine, sizeof(szCommandLine), szProcessHandle);
    }
    else
    {
        hProcess = NULL;
    }
    ZeroMemory(&startupInfo, sizeof(startupInfo));
    ZeroMemory(&processInformation, sizeof(processInformation));
    startupInfo.cb = sizeof(startupInfo);
    if (CreateProcessW(NULL,
                       szCommandLine,
                       NULL,
                       NULL,
                       TRUE,
                       0,
                       NULL,
                       NULL,
                       &startupInfo,
                       &processInformation) != FALSE)
    {
        DWORD   dwExitCode;

        TBOOL(CloseHandle(processInformation.hThread));
        (DWORD)WaitForSingleObject(processInformation.hProcess, INFINITE);
        dwExitCode = 0;
        TBOOL(GetExitCodeProcess(processInformation.hProcess, &dwExitCode));
        fResult = (dwExitCode != 0);
        TBOOL(CloseHandle(processInformation.hProcess));
    }
    if (hProcess != NULL)
    {
        TBOOL(CloseHandle(hProcess));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CFUSAPI::RegisterBadApplication
//
//  Arguments:  bamType     =   BAM type of the current process.
//
//  Returns:    <none>
//
//  Purpose:    Registers with the BAM server this process (image name) as a
//              bad application of type whatever is passed in. The different
//              BAM shims pass in different parameters.
//
//  History:    2000-11-03  vtan        created
//  --------------------------------------------------------------------------

void    CFUSAPI::RegisterBadApplication (BAM_TYPE bamType)

{
    if ((_hPort != NULL) && (_pszImageName != NULL))
    {
        FUSAPI_PORT_MESSAGE     portMessageIn, portMessageOut;

        ZeroMemory(&portMessageIn, sizeof(portMessageIn));
        ZeroMemory(&portMessageOut, sizeof(portMessageOut));
        portMessageIn.apiBAM.apiGeneric.ulAPINumber = API_BAM_REGISTERRUNNING;
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.pszImageName = _pszImageName;
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.cchImageName = lstrlen(_pszImageName) + sizeof('\0');
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.dwProcessID = GetCurrentProcessId();
        portMessageIn.apiBAM.apiSpecific.apiRegisterRunning.in.bamType = bamType;
        portMessageIn.portMessage.u1.s1.DataLength = sizeof(API_BAM);
        portMessageIn.portMessage.u1.s1.TotalLength = static_cast<CSHORT>(sizeof(FUSAPI_PORT_MESSAGE));
        TSTATUS(NtRequestWaitReplyPort(_hPort, &portMessageIn.portMessage, &portMessageOut.portMessage));
    }
}

//  --------------------------------------------------------------------------
//  CFUSAPI::DWORDToString
//
//  Arguments:  dwNumber    =   DWORD to convert to a string.
//              pszString   =   Buffer that gets the result.
//
//  Returns:    <none>
//
//  Purpose:    Implements wsprintf(pszString, TEXT("%ld"), dwNumber) because
//              this code CANNOT use user32 imports.
//
//  History:    2000-11-08  vtan        created
//  --------------------------------------------------------------------------

void    CFUSAPI::DWORDToString (DWORD dwNumber, WCHAR *pszString)

{
    int     i;
    WCHAR   szTemp[16];

    i = 0;
    do
    {
        szTemp[i++] = L'0' + static_cast<WCHAR>(dwNumber % 10);
        dwNumber /= 10;
    } while (dwNumber != 0);
    do
    {
        --i;
        *pszString++ = szTemp[i];
    } while (i != 0);
    *pszString = L'\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fusbadapplicationtype3.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType3.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 3.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"


IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 1 applications register the process as bad.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            fusAPI.RegisterBadApplication(BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE);
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fusbadapplicationtype2.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType2.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 2.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"

IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 1 applications register the process as bad.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
   switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            fusAPI.RegisterBadApplication(BAM_TYPE_SWITCH_USER);
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\globalmemorystatustrim.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    GlobalMemoryStatusTrim.cpp

 Abstract:

    Limits the amount of swap space and physical memory returned from the
    GlobalMemoryStatus API.  This is necessary for some apps run on 64 bit 
    machines which have over 2 gig of memory.

 Notes:

    This is a general purpose shim.

 History:

	04/19/2002 mnikkel  Created

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(GlobalMemoryStatusTrim)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GlobalMemoryStatus)
APIHOOK_ENUM_END

/*++

 Limit the swap space and physical memory size

--*/

VOID
APIHOOK(GlobalMemoryStatus)( 
    LPMEMORYSTATUS lpBuffer
    )
{
    ORIGINAL_API(GlobalMemoryStatus)(lpBuffer);

    // change page file to always be 2 gig or less
    if (lpBuffer->dwTotalPageFile > 0x7FFFFFFF)	{
        lpBuffer->dwTotalPageFile = 0x7FFFFFFF;
    }

    if (lpBuffer->dwAvailPageFile > 0x7FFFFFFF) {
        lpBuffer->dwAvailPageFile = 0x7FFFFFFF;
    }

	// change physical memory to always be 1 gig or less
	if (lpBuffer->dwTotalPhys > 0x3FFFFFFF) {
		lpBuffer->dwTotalPhys = 0x3FFFFFFF;
	}

	if (lpBuffer->dwAvailPhys > 0x3FFFFFFF) {
		lpBuffer->dwAvailPhys  = 0x3FFFFFFF;
	}

	return;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalMemoryStatus)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\getvolumeinformationlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    GetVolumeInformationLie.cpp

 Abstract:

    This DLL Hooks GetVolumeInformationA/W and strips out specified FILE_SUPPORTS_XXX flags

 Notes:
    
    This is a general purpose shim.

 History:

    05/28/2002 yoda - the force wisely have I used, hmmmmm, yes!

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(GetVolumeInformationLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVolumeInformationA) 
    APIHOOK_ENUM_ENTRY(GetVolumeInformationW) 
APIHOOK_ENUM_END


DWORD GetRestricedFSFlags()
{
    static DWORD s_dwRet = (DWORD)-1;

    if (s_dwRet == (DWORD)-1)
    {
        char* pszCmdLine = COMMAND_LINE;

        if (pszCmdLine && *pszCmdLine)
        {
            while (*pszCmdLine == ' ')
            {
                pszCmdLine++;
            }

            s_dwRet = (DWORD)atol(pszCmdLine);
        }
        else
        {
            s_dwRet = 0;
        }
    }

    return s_dwRet;
}

BOOL APIHOOK(GetVolumeInformationA)(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber,
                                    LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
{
    BOOL bRet;
    
    bRet = ORIGINAL_API(GetVolumeInformationA)(lpRootPathName,
                                               lpVolumeNameBuffer,
                                               nVolumeNameSize,
                                               lpVolumeSerialNumber,
                                               lpMaximumComponentLength,
                                               lpFileSystemFlags,
                                               lpFileSystemNameBuffer,
                                               nFileSystemNameSize);

    if (lpFileSystemFlags)
    {
        // mask off whatever flags we don't want the app to see
        *lpFileSystemFlags = (*lpFileSystemFlags & (~GetRestricedFSFlags()));
    }

    return bRet;
}

BOOL APIHOOK(GetVolumeInformationW)
  (LPCWSTR lpRootPathName,              // root directory
   LPWSTR lpVolumeNameBuffer,           // volume name buffer
   DWORD nVolumeNameSize,               // length of name buffer
   LPDWORD lpVolumeSerialNumber,        // volume serial number
   LPDWORD lpMaximumComponentLength,    // maximum file name length
   LPDWORD lpFileSystemFlags,           // file system options
   LPWSTR lpFileSystemNameBuffer,       // file system name buffer
   DWORD nFileSystemNameSize            // length of file system name buffer
  )
{
    BOOL bRet;
    
    bRet = ORIGINAL_API(GetVolumeInformationW)(lpRootPathName,
                                               lpVolumeNameBuffer,
                                               nVolumeNameSize,
                                               lpVolumeSerialNumber,
                                               lpMaximumComponentLength,
                                               lpFileSystemFlags,
                                               lpFileSystemNameBuffer,
                                               nFileSystemNameSize);

    if (lpFileSystemFlags)
    {
        // mask off whatever flags we don't want the app to see
        *lpFileSystemFlags = (*lpFileSystemFlags & (~GetRestricedFSFlags()));
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVolumeInformationA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVolumeInformationW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\handleemptyaccesscheck.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    HandleEmptyAccessCheck.cpp   

 Abstract:

    AccessCheck used to accept a 0 value for DesiredAccess and return access_allowed,
    this changed in .NET server to return access_denied.

 Notes:

    This is a general purpose shim.

 History:

   05/29/2002   robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HandleEmptyAccessCheck)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(AccessCheck) 
APIHOOK_ENUM_END

typedef BOOL        (WINAPI *_pfn_AccessCheck)(
    PSECURITY_DESCRIPTOR pSecurityDescriptor, // SD
    HANDLE ClientToken,                       // handle to client access token
    DWORD DesiredAccess,                      // requested access rights 
    PGENERIC_MAPPING GenericMapping,          // mapping
    PPRIVILEGE_SET PrivilegeSet,              // privileges
    LPDWORD PrivilegeSetLength,               // size of privileges buffer
    LPDWORD GrantedAccess,                    // granted access rights
    LPBOOL AccessStatus                       // result of access check
);

BOOL 
APIHOOK(AccessCheck)(
    PSECURITY_DESCRIPTOR pSecurityDescriptor, // SD
    HANDLE ClientToken,                       // handle to client access token
    DWORD DesiredAccess,                      // requested access rights 
    PGENERIC_MAPPING GenericMapping,          // mapping
    PPRIVILEGE_SET PrivilegeSet,              // privileges
    LPDWORD PrivilegeSetLength,               // size of privileges buffer
    LPDWORD GrantedAccess,                    // granted access rights
    LPBOOL AccessStatus                       // result of access check
    )
{
    if (DesiredAccess == 0)
    {
        DesiredAccess = MAXIMUM_ALLOWED;
    }

    return ORIGINAL_API(AccessCheck)(
        pSecurityDescriptor, // SD
        ClientToken,                       // handle to client access token
        DesiredAccess,                      // requested access rights 
        GenericMapping,          // mapping
        PrivilegeSet,              // privileges
        PrivilegeSetLength,               // size of privileges buffer
        GrantedAccess,                    // granted access rights
        AccessStatus                       // result of access check
        );
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, AccessCheck)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\fusbadapplicationtype4.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: FUSBadApplicationType4.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Shim code to register a process as a BAM type 4.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

#include "precomp.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lpcfus.h>

#include "FUSAPI.h"


IMPLEMENT_SHIM_BEGIN(FUSBadApplicationType4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//  --------------------------------------------------------------------------
//  InitializeHooks
//
//  Arguments:  fdwReason   =   DLL attach reason.
//
//  Returns:    <none>
//
//  Purpose:    Hooks whatever it necessary during process startup of a known
//              bad application.
//
//              For type 4 applications register the process as bad.
//
//  History:    11/03/2000  vtan        created
//              11/29/2000  a-larrsh    Ported to Multi-Shim Format
//  --------------------------------------------------------------------------

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            CFUSAPI     fusAPI(NULL);

            fusAPI.RegisterBadApplication(BAM_TYPE_SWITCH_TO_NEW_USER);
            break;
        }
        default:
            break;
    }

   return TRUE;
}


HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\globalmemorystatuslie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    GlobalMemoryStatusLie.cpp

 Abstract:

    Lies about the amount of swap space returned from the
    GlobalMemoryStatus API so app will think it has a huge
    swap space like it did on win98.

 Notes:

    This is a general purpose shim.

 History:

    05/08/2001 mnikkel  Created

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(GlobalMemoryStatusLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GlobalMemoryStatus)
APIHOOK_ENUM_END



/*++

   Increase the Available page file size to 400 mb.

--*/

VOID
APIHOOK(GlobalMemoryStatus)( 
        LPMEMORYSTATUS lpBuffer
)
{
    ORIGINAL_API(GlobalMemoryStatus)(lpBuffer);

    // change page file size to 400 mb.
    lpBuffer->dwAvailPageFile = 0x17D78400;

    return;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GlobalMemoryStatus)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\handledbcsusername2.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   HandleDBCSUserName2.cpp

 Abstract:

   Disable DBCS handling for CharNextA if the string is DBCS user profile
   for non-DBCS enabled application support.

 More info:

   Return next byte address instead of next character address.

 History:

    05/01/2001  geoffguo        Created

--*/

#include "precomp.h"
#include "userenv.h"

IMPLEMENT_SHIM_BEGIN(HandleDBCSUserName2)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CharNextA) 
APIHOOK_ENUM_END

//
// Reverse compare strings
//
BOOL ReverseStrCmp(
    LPCSTR lpCurrentChar,
    LPCSTR lpStrBuf)
{
    BOOL     bRet = FALSE;
    DWORD    i, dwLen;
    LPCSTR   lpStr1, lpStr2;

    if (!lpStrBuf || !lpCurrentChar || *lpStrBuf == '\0')
        goto Exit;

    dwLen = lstrlenA(lpStrBuf);
    do
    {
        bRet = TRUE;
        lpStr1 = lpCurrentChar;
        lpStr2 = &lpStrBuf[dwLen-1];
        for (i = 0; i < dwLen; i++)
        {
            if (IsBadStringPtrA(lpStr1, 1) || *lpStr1 == '\0' ||
                toupper(*lpStr1) != toupper(*lpStr2))
            {
                bRet = FALSE;
                break;
            }
            lpStr1--;
            lpStr2--;
        }

        if (bRet)
            break;

        dwLen--;
    } while (dwLen > 0 && lpStrBuf[dwLen-1] != '\\');

Exit:
    return bRet;
}

//
// Checking if the string is user profile path
//
BOOL IsUserProfilePath(
    LPCSTR lpCurrentChar)
{
    HANDLE hToken;
    DWORD  dwLen;
    BOOL   bRet = FALSE;
    char   szProfile[MAX_PATH];
    char   szShortProfile[MAX_PATH];

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        goto Exit;

    dwLen = MAX_PATH;
    if (!GetUserProfileDirectoryA(hToken, szProfile, &dwLen))
        goto Exit;

    bRet = ReverseStrCmp(lpCurrentChar, szProfile);
    if (bRet)
        goto Exit;

    dwLen = GetShortPathNameA(szProfile, szShortProfile, MAX_PATH);
    if (dwLen >= MAX_PATH || dwLen == 0)
        goto Exit;

    bRet = ReverseStrCmp(lpCurrentChar, szShortProfile);

Exit:
    return bRet;
}

//
// Disable DBCS handling for CharNextA
//
LPSTR
APIHOOK(CharNextA)(
    LPCSTR lpCurrentChar)
{
    if (lpCurrentChar != NULL && *lpCurrentChar != (char)NULL) {
        // Disable DBCS support for DBCS username in user profile path
        if (IsDBCSLeadByte(*lpCurrentChar) && !IsUserProfilePath(lpCurrentChar))
            lpCurrentChar++;

        lpCurrentChar++;
    }

    return (LPSTR)lpCurrentChar;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CharNextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\handledbcsusername.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   HandleDBCSUserName.cpp

 Abstract:

   ShFolder.Exe is failing installation when its app path has Hi Ascii characters (typically DBCS).
   When app path is double quoted, the bug code is not processed and install will succeed.
   This shim wrap the command line app path name with double quote at GetCommandLineA.

   Example:
   C:\DOCUME~1\DBCS\LOCALS~1\Temp\_ISTMP1.DIR\_ISTMP0.DIR\shfolder.exe /Q:a
   "C:\DOCUME~1\DBCS\LOCALS~1\Temp\_ISTMP1.DIR\_ISTMP0.DIR\shfolder.exe" /Q:a

 More info:

   Self extractor ShFolder.Exe checks its app path name with space char 0x20 on signed char basis.
   Hi Ascii character included in path treated below 0x20 and path is chopped at there.
   When path has double quote at the top, the problem check is not proceeded.

 History:

    04/09/2001  hioh        Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HandleDBCSUserName)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
APIHOOK_ENUM_END

char * g_lpszCommandLine = NULL;

CRITICAL_SECTION g_csCmdLine;

class CAutoLock
{
public:
   CAutoLock()
   {
      EnterCriticalSection(&g_csCmdLine);
   }
   ~CAutoLock()
   {
      LeaveCriticalSection(&g_csCmdLine);
   }
};

/*++

 Wrap the application path name with double quote.
 
--*/

LPSTR
APIHOOK(GetCommandLineA)(
    void
    )
{
    CAutoLock lock;
    if (g_lpszCommandLine)
    {
        // Been here, done that
        return g_lpszCommandLine;
    }

    g_lpszCommandLine = ORIGINAL_API(GetCommandLineA)();
    CSTRING_TRY
    {
        AppAndCommandLine  appCmdLine(NULL, g_lpszCommandLine);

        // The command line is often only the arguments: no application name
        // If the "application name" doesn't exist, don't bother to put quotes
        // around it.
        DWORD dwAttr = GetFileAttributesW(appCmdLine.GetApplicationName());
        if (dwAttr != INVALID_FILE_ATTRIBUTES)
        {
            CString csDQ = L'"';
            CString csCL = csDQ;
            CString csNA = appCmdLine.GetCommandlineNoAppName();

            csCL += appCmdLine.GetApplicationName();
            csCL += csDQ;

            if (!csNA.IsEmpty())
            {   // Add the rest
                csCL += L" ";
                csCL += csNA;
            }

            g_lpszCommandLine = csCL.ReleaseAnsi();
        }
    }
    CSTRING_CATCH
    {
        // Do nothing, g_lpszCommandLine is initialized with good value
    }

    return g_lpszCommandLine;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
       return InitializeCriticalSectionAndSpinCount(&g_csCmdLine, 0x80000000);
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\grabmatchinginformation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    GrabMatchingInformation.cpp

 Abstract:

    Upon ProcessAttach the shim gathers matching information from the current 
    directory.

 Notes:

    This is a general purpose shim.

 History:

    20-Oct-2000   jdoherty    Created

--*/
#include "precomp.h"
#include <stdio.h>

// This module is *not* DBCS safe, but should only be used by our testers
// We should, eventually, correct this file.
// This module has been given an official blessing to use the str routines.
#include "LegalStr.h"

IMPLEMENT_SHIM_BEGIN(GrabMatchingInformation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

BOOL gbCalledHook;
LPSTR glpOriginalRootDir;
VOID GrabMatchingInformationMain();
BOOL GrabMatchingInfo(LPSTR lpRootDirectory, HANDLE hStorageFile, int nLevel);
BOOL GetRelativePath(LPSTR lpPathFromRoot, LPCSTR lpSubDir, LPCSTR lpFileName);
VOID AddMatchingFile( LPSTR lpData, LPCSTR pszFullPath, LPCSTR pszRelativePath );

LPSTR 
APIHOOK(GetCommandLineA)()
{
    if (!gbCalledHook)
    {
        int     nLength = 0;
        LPSTR   lpCursorEnd;
        
        glpOriginalRootDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
        
        GetModuleFileNameA( NULL, glpOriginalRootDir, MAX_PATH );
        nLength = strlen( glpOriginalRootDir );
        lpCursorEnd = &glpOriginalRootDir[nLength-1];
        
        while( --nLength )
        {
            if ( *(lpCursorEnd) == '\\' )
            {
                *(lpCursorEnd) = '\0';
                break;
            }
            lpCursorEnd--;
            if (nLength==0)
            {
                GetCurrentDirectoryA( MAX_PATH, glpOriginalRootDir );
            }
        }
        GrabMatchingInformationMain();
        ShimFree(glpOriginalRootDir);
        gbCalledHook = TRUE;
    }
    
    return ORIGINAL_API(GetCommandLineA)();
}

LPWSTR 
APIHOOK(GetCommandLineW)()
{
    if (!gbCalledHook)
    {
        int     nLength = 0;
        LPSTR   lpCursorEnd;
        
        glpOriginalRootDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
        
        GetModuleFileNameA( NULL, glpOriginalRootDir, MAX_PATH );
        nLength = strlen( glpOriginalRootDir );
        lpCursorEnd = &glpOriginalRootDir[nLength-1];
        
        while( --nLength )
        {
            if ( *(lpCursorEnd) == '\\' )
            {
                *(lpCursorEnd) = '\0';
                break;
            }
            lpCursorEnd--;
            if (nLength==0)
            {
                GetCurrentDirectoryA( MAX_PATH, glpOriginalRootDir );
            }
        }
        GrabMatchingInformationMain();
        ShimFree(glpOriginalRootDir);
        gbCalledHook = TRUE;
    }

    return ORIGINAL_API(GetCommandLineW)();
}


VOID GrabMatchingInformationMain()
{
    HANDLE hMutexHandle;
    LPSTR lpStorageFilePath;
    LPSTR lpDirInfo;
    LPSTR lpRootDir;
    HANDLE hStorageFile;
    DWORD  dwBytesWritten = 0;

    lpStorageFilePath = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpDirInfo = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpRootDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));


    // Setup a mutex so only one process at a time can write to the matchinginfo.txt file.
    hMutexHandle = CreateMutexA( NULL, FALSE, "MyGrabMIFileMutex" );
    WaitForSingleObject( hMutexHandle, INFINITE );

    // Build path to where the matching information will be stored.
    SHGetSpecialFolderPathA(NULL, lpStorageFilePath, CSIDL_DESKTOPDIRECTORY, TRUE );
    strcat( lpStorageFilePath, "\\matchinginfo.txt" );

/*
    if ( (strcmp(glpOriginalRootDir ,".") == 0) || (strcmp(glpOriginalRootDir ,"") == 0) )
    {
        GetCurrentDirectoryA( MAX_PATH, glpOriginalRootDir );
    }
*/
    // Open matchinginfo.txt on the desktop for write if it exists and set the file pointer to the end
    // of the file, create a new file otherwise.
    hStorageFile = CreateFileA( lpStorageFilePath, 
                                GENERIC_WRITE, 
                                0, 
                                NULL, 
                                OPEN_ALWAYS, 
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

    SetFilePointer( hStorageFile, NULL, NULL, FILE_END );

    if (hStorageFile == INVALID_HANDLE_VALUE)
    {
        return;
    }
    sprintf(lpDirInfo, "<!-- Generating matching information for files in: [ %s ]For Process: [ %s ]-->\r\n", 
            glpOriginalRootDir,
            GetCommandLineA()
            );
    WriteFile( hStorageFile, lpDirInfo, strlen(lpDirInfo), &dwBytesWritten, NULL );
    strcpy(lpRootDir, glpOriginalRootDir);

    if (!GrabMatchingInfo(lpRootDir, hStorageFile, 0))
    {
        CloseHandle(hStorageFile);
        return;
    }

    CloseHandle(hStorageFile);

    ShimFree(lpStorageFilePath);
    ShimFree(lpDirInfo);
    ShimFree(lpRootDir);

    ReleaseMutex( hMutexHandle );

    return;
}

/*++

 This function traverses lpRootDirectory and it's subdirectories while storing the 
 size and checksum for the files in those directories. 

--*/
BOOL GrabMatchingInfo(LPSTR lpRootDirectory, HANDLE hStorageFile, int nLevel)
{

    WIN32_FIND_DATAA FindFileData;
    HANDLE hSearch;                         // Search handle returned by FindFirstFile
    LPSTR lpSubDir;
    LPSTR lpFilePath;
    LPSTR lpData;
    LPSTR lpPathFromRoot;
    DWORD  dwBytesWritten = 0;

    int cbFileCounter = 0;
    lpSubDir = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpFilePath = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
    lpData = (LPSTR) ShimMalloc((MAX_PATH*2)*sizeof(LPSTR));
    lpPathFromRoot = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));

    // Just repeat displaying a dot so the user knows something is happening.
    // USED IN GRABMI
    // printf(".");

    strcpy (lpSubDir, lpRootDirectory);

    strcat(lpRootDirectory, "\\*");

    if ( (hSearch=FindFirstFileA( lpRootDirectory, &FindFileData )) == INVALID_HANDLE_VALUE )
    {
        return FALSE;
    }

    BOOL bRepeat = FALSE;

    while ( (strcmp( FindFileData.cFileName, "." ) == 0) || (strcmp( FindFileData.cFileName, ".." ) == 0) && !bRepeat )
    {
        FindNextFileA(hSearch, &FindFileData);
        if ( strcmp( FindFileData.cFileName, ".." ) == 0 )
            bRepeat = TRUE;
    }

    if (!FindNextFileA(hSearch, &FindFileData))
    {
        return TRUE;
    }

    do 
    {
        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // Build path for matching file
            strcpy(lpFilePath, lpSubDir);
            strcat(lpFilePath, "\\");
            strcat(lpFilePath, FindFileData.cFileName);

            ZeroMemory( lpData, (MAX_PATH*2)*sizeof(LPSTR) );

            //  Determine the relative path for the file from the original root directory.
            if (!GetRelativePath(lpPathFromRoot, lpSubDir, FindFileData.cFileName))
                strcpy(lpPathFromRoot, FindFileData.cFileName);

            // Check to see if there is version information for the specified file and whether it is 
            // an .exe, .icd, ._MP, or .dll.  If so add the information to the file.
            if ( stristr(lpFilePath, ".exe") || 
                 stristr(lpFilePath, ".icd") ||
                 stristr(lpFilePath, "._MP") ||
                 stristr(lpFilePath, ".dll") )
            {
                AddMatchingFile( lpData, lpFilePath, lpPathFromRoot );
            } else
            {
                // Limit the amount of info gathered to 10 files per directory excluding the above file types.
                if (cbFileCounter < 10)
                {
                    cbFileCounter++;
                    AddMatchingFile( lpData, lpFilePath, lpPathFromRoot );
                }
            }

            // Write the information stored in lpData to the file
            WriteFile( hStorageFile, lpData, strlen(lpData), &dwBytesWritten, NULL );
        }
    } while ( FindNextFileA( hSearch, &FindFileData ) );

    /////////////////////////////////////////////////////////////////////////////////
    //
    // Now go through the directory again and go into the subdirectories
    //
    /////////////////////////////////////////////////////////////////////////////////
    if (strlen(lpRootDirectory) < 4)
    {
        if ( (hSearch=FindFirstFileA(lpRootDirectory, &FindFileData)) == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
    } else
    {
        if ( (hSearch=FindFirstFileA(lpRootDirectory, &FindFileData)) == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
        FindNextFileA(hSearch, &FindFileData);
        if (!FindNextFileA(hSearch, &FindFileData))
        {
            FindClose( hSearch );
            return TRUE;
        }
    }

    do
    {
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && nLevel < 3)
        {
            strcat(lpSubDir, "\\");
            strcat(lpSubDir, FindFileData.cFileName);

            GrabMatchingInfo (lpSubDir, hStorageFile, nLevel+1);
            lpSubDir[strlen(lpSubDir)-2]='\0';

            strcpy(lpSubDir, lpRootDirectory);
            lpSubDir[strlen(lpSubDir)-2]='\0';
        }
    }while ( FindNextFileA( hSearch, &FindFileData ) ); 

    FindClose(hSearch);

    ShimFree(lpSubDir);
    ShimFree(lpFilePath);
    ShimFree(lpData);
    ShimFree(lpPathFromRoot);

    return TRUE;
}

BOOL GetRelativePath(LPSTR lpPathFromRoot, LPCSTR lpSubDir, LPCSTR lpFileName)
{

    int difference=(strlen(lpSubDir)-strlen(glpOriginalRootDir));
    if (difference)
    {
        for (int i=0; i < difference; i++)
        {
            lpPathFromRoot[i] = lpSubDir[strlen(glpOriginalRootDir)+i+1];
        }
        strcat(lpPathFromRoot, "\\");
        strcat(lpPathFromRoot, lpFileName);
        difference=0;
        return TRUE;
    }
    return FALSE;
}

/*++
    AddMatchingFile

    Description:    Adds a matching file and it's attributes to the tree.

--*/
VOID AddMatchingFile(
                    OUT LPSTR lpData, 
                    IN LPCSTR pszFullPath, 
                    IN LPCSTR pszRelativePath )
{
    PATTRINFO   pAttrInfo;
    DWORD       dwAttrCount;

    LPWSTR      pwszFullPath;
    pwszFullPath = (LPWSTR) ShimMalloc(MAX_PATH*sizeof(LPWSTR));
    mbstowcs( pwszFullPath, pszFullPath, MAX_PATH );

    //
    // Call the attribute manager to get all the attributes for this file.
    //
    if (SdbGetFileAttributes(pwszFullPath, &pAttrInfo, &dwAttrCount))
    {
        LPSTR       lpBuffer;
        LPWSTR      lpwBuffer;

        lpBuffer = (LPSTR) ShimMalloc(MAX_PATH*sizeof(LPSTR));
        lpwBuffer = (LPWSTR) ShimMalloc(MAX_PATH*sizeof(LPWSTR));

        //
        // Loop through all the attributes and show the ones that are available.
        //
//        ZeroMemory( lpData, (MAX_PATH*2)*sizeof(LPSTR) );

        sprintf(lpData, "<MATCHING_FILE NAME=\"%s\" ", pszRelativePath);
        for (DWORD i = 0; i < dwAttrCount; ++i)
        {
            if ( SdbFormatAttribute(&pAttrInfo[i], lpwBuffer, MAX_PATH) )//CHARCOUNT(lpwBuffer))) 
            {
                ZeroMemory( lpBuffer, MAX_PATH*sizeof(LPSTR) );
                wcstombs( lpBuffer, lpwBuffer, wcslen (lpwBuffer) );
                //
                // wszBuffer has XML for this attribute
                //
                strcat( lpData, lpBuffer );
                strcat( lpData, " " );
            }
        }
        strcat( lpData, "/>\r\n" );
        ShimFree( lpBuffer );
        ShimFree( lpwBuffer );
        SdbFreeFileAttributes(pAttrInfo);
    }
    ShimFree( pwszFullPath );
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL, KERNEL32 and MSVCRT APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        gbCalledHook = FALSE;

        DPFN( eDbgLevelInfo, "Beginng to Grab Information.");
    } 

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\heapclearallocation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapClearAllocation.cpp

 ModAbstract:
     
    This shim fills all heap allocations with 0
     
 Notes:

    This is a general purpose shim.

 History:
           
    05/16/2000 dmunsil      Created (based on HeapPadAllocation, by linstev)
    10/10/2000 rparsons     Added additional hooks for GlobalAlloc & LocalAlloc
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapClearAllocation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
    APIHOOK_ENUM_ENTRY(LocalAlloc) 
    APIHOOK_ENUM_ENTRY(GlobalAlloc) 
APIHOOK_ENUM_END

/*++

 Clear the allocation with the requested DWORD.

--*/

PVOID 
APIHOOK(RtlAllocateHeap)(
    PVOID HeapHandle,
    ULONG Flags,
    SIZE_T Size
    )
{
    return ORIGINAL_API(RtlAllocateHeap)(HeapHandle, Flags | HEAP_ZERO_MEMORY, Size);
}

/*++

 Clear the allocation with the requested DWORD.

--*/

HLOCAL
APIHOOK(LocalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    return ORIGINAL_API(LocalAlloc)(uFlags | LMEM_ZEROINIT, uBytes);
}

/*++

 Clear the allocation with the requested DWORD.

--*/

HGLOBAL
APIHOOK(GlobalAlloc)(
    UINT uFlags,
    DWORD dwBytes
    )
{
    return ORIGINAL_API(GlobalAlloc)(uFlags | GMEM_ZEROINIT, dwBytes);    
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalAlloc)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\heapforcegrowable.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapForceGrowable.cpp

 Abstract:
     
    Remove upper limit on heap calls by setting the maximum size to zero, which
    means that the heap will grow to accomodate new allocations.
     
 Notes:

    This is a general purpose shim.

 History:
                            
    04/25/2000 linstev  Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapForceGrowable)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(HeapCreate) 
APIHOOK_ENUM_END

/*++

 Fix the heap so it can grow.

--*/

HANDLE
APIHOOK(HeapCreate)(
    DWORD flOptions,      
    DWORD dwInitialSize,  
    DWORD dwMaximumSize   
    )
{
    if (dwMaximumSize)
    {
        LOGN( eDbgLevelError,
            "[APIHook_HeapCreate] Setting heap maximum to 0.");
        dwMaximumSize = 0;
    }

    return ORIGINAL_API(HeapCreate)(flOptions, dwInitialSize, dwMaximumSize);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, HeapCreate)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\heapignoremoveable.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapIgnoreMoveable.cpp

 Abstract:

    After 64k calls to GlobalAlloc, we are no longer able to use the 
    GMEM_MOVEABLE flag. This shim just filters it in the case of 
    GlobalAlloc failing.

    This is a known issue with the heap manager on NT and is a won't fix. 
    
    According to adrmarin:

        The table with handles cannot grow dynamic. The initial size is 
        hardcoded to 64k handles. Increasing this number will affect the 
        reserved address for each process. 

    See Whistler bug #147032.

 Notes:

    This is a general purpose shim - superceded by EmulateHeap.

 History:

    02/19/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapIgnoreMoveable)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GlobalAlloc)
APIHOOK_ENUM_END

/*++

 Remove the GMEM_MOVEABLE flag in the case of failure.

--*/

HGLOBAL 
APIHOOK(GlobalAlloc)(
    UINT uFlags,    
    DWORD dwBytes   
    )
{
    HGLOBAL hRet = ORIGINAL_API(GlobalAlloc)(uFlags, dwBytes);

    if (hRet == NULL)
    {
        hRet = ORIGINAL_API(GlobalAlloc)(
            uFlags & ~GMEM_MOVEABLE, dwBytes);
    }

    return hRet;
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalAlloc)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\heapdelaylocalfree.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   HeapDelayLocalFree.cpp

 Abstract:

   Delay calls to LocalFree.

 History:

   09/19/2000   robkenny
   02/12/2002   robkenny    Convert InitializeCriticalSection to InitializeCriticalSectionAndSpinCount
                            and checking return status to verify that critical section was
                            actually created.

                            Shim was deallocating memory in SHIM_PROCESS_DETACH, which can
                            cause the shim to crash when the process is exiting, since there
                            is not guarantee that the shim will not be called from other
                            libraries afterwards.


--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(HeapDelayLocalFree)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LocalFree)
APIHOOK_ENUM_END

CRITICAL_SECTION            g_CritSec;
static VectorT<HLOCAL>     *g_DelayLocal            = NULL;
static DWORD                g_DelayBufferSize       = 20;

HLOCAL 
APIHOOK(LocalFree)(
    HLOCAL hMem   // handle to local memory object
)
{
    if (hMem == NULL)
        return NULL;

    if (g_DelayLocal)
    {
        EnterCriticalSection(&g_CritSec);

        // If the list is full
        if (g_DelayLocal->Size() > 0 &&
            g_DelayLocal->Size() >= g_DelayLocal->MaxSize())
        {
            HLOCAL & hDelayed = g_DelayLocal->Get(0);
#if DBG
            DPFN(eDbgLevelInfo, "LocalFree(0x%08x).", hDelayed);
#endif
            ORIGINAL_API(LocalFree)(hDelayed);

            g_DelayLocal->Remove(0);
        }

        g_DelayLocal->Append(hMem);
#if DBG
        DPFN(eDbgLevelInfo, "Delaying LocalFree(0x%08x).", hMem);
#endif
       
        LeaveCriticalSection(&g_CritSec);
        
        return NULL;
    }

    HLOCAL returnValue = ORIGINAL_API(LocalFree)(hMem);
    return returnValue;
}

BOOL ParseCommandLine(const char * /*commandLine*/)
{
    // Preallocate the event, prevents EnterCriticalSection
    // from throwing an exception in low-memory situations.
    if (!InitializeCriticalSectionAndSpinCount(&g_CritSec, 0x8000000))
    {
        return FALSE;
    }

    g_DelayLocal = new VectorT<HLOCAL>;

    if (g_DelayLocal)
    {
        // If we cannot resize the array, stop now
        if (!g_DelayLocal->Resize(g_DelayBufferSize))
        {
            delete g_DelayLocal;
            g_DelayLocal = NULL;

            // Turn off all hooks:
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, LocalFree)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\heaplookasidefree.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapLookasideFree.cpp

 Abstract:
     
    Check for the following heap management problems:

        1. Delay heap free calls by command line
        2. Validate free calls to make sure they are in the correct heap.
        3. Allocate new blocks out of the delay free pool if the size is 
           identical
    
    The delay of calls is implemented by means of circular array. As soon 
    as it's full, the oldest free call is validated and executed. 
     
 Notes:

    This is a general purpose shim.

 History:
           
    04/03/2000 linstev  Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapLookasideFree)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
    APIHOOK_ENUM_ENTRY(RtlFreeHeap) 
    APIHOOK_ENUM_ENTRY(HeapDestroy) 
APIHOOK_ENUM_END

#define DEFAULT_BUFFER_SIZE 16

DWORD g_dwBufferSize;
DWORD g_bHead, g_bTail;
CRITICAL_SECTION g_csHeap;

struct ENTRY
{
    HANDLE hHeap;
    PVOID lpMem;
    ULONG Flags;
    ULONG Size;
};
ENTRY *g_pEntry;

/*++

 Try and find an entry in the list.

--*/

PVOID 
APIHOOK(RtlAllocateHeap)(
    HANDLE hHeap,
    ULONG Flags,
    SIZE_T Size
    )
{
    PVOID pRet = NULL;
    
    // Make sure we are the only ones touching our heap list
    EnterCriticalSection(&g_csHeap);

    // Check if we are active - we may have shut down already.
    if (g_pEntry && Size)
    {
        DWORD bTail = (g_bTail + g_dwBufferSize - 1) % g_dwBufferSize;
        DWORD bHead = (g_bHead + g_dwBufferSize - 1) % g_dwBufferSize;
        while (bTail != bHead)
        {
            ENTRY *pEntry = g_pEntry + bTail;
            if ((pEntry->Size == Size) &&
                (pEntry->hHeap == hHeap) &&
                (pEntry->Flags == Flags))
            {
                pRet = pEntry->lpMem;
                pEntry->hHeap = 0;
                break;
            }
            bTail = (bTail + 1) % g_dwBufferSize;
        }
    }

    if (!pRet)
    {
        pRet = ORIGINAL_API(RtlAllocateHeap)(hHeap, Flags, Size);
    }

    // Done using the list
    LeaveCriticalSection(&g_csHeap);

    if (!pRet)
    {
        DPFN( eDbgLevelWarning,
            "Allocation of size %d failed", Size);
    }
        
    return pRet;
}

/*++

 Buffer the call and free the oldest entry if it's valid.

--*/

BOOL
APIHOOK(RtlFreeHeap)(
    PVOID hHeap,
    ULONG Flags,
    PVOID lpMem
    )
{
    BOOL bRet = TRUE;

    // Check if we are active - we may have shut down already.
    if (g_pEntry && lpMem)
    {
        // Make sure we are the only ones touching our heap list
        EnterCriticalSection(&g_csHeap);

        // Go ahead and free the oldest allocation
        ENTRY *pEntry = g_pEntry + g_bHead;
        if (pEntry->hHeap)
        {
            if (HeapValidate(
                    pEntry->hHeap, 
                    pEntry->Flags, 
                    pEntry->lpMem))
            {
                ORIGINAL_API(RtlFreeHeap)(
                    pEntry->hHeap, 
                    pEntry->Flags, 
                    pEntry->lpMem);
                
                pEntry->hHeap = 0;
            }
        }
        
        // Add a new entry to the table
        __try
        {
            pEntry = g_pEntry + g_bTail;
            pEntry->Size = HeapSize(hHeap, Flags, lpMem);
            pEntry->hHeap = hHeap;
            pEntry->Flags = Flags;
            pEntry->lpMem = lpMem;
            g_bHead = (g_bHead + 1) % g_dwBufferSize;
            g_bTail = (g_bTail + 1) % g_dwBufferSize;
        }
        __except(1)
        {
        }
        // Done using the list
        LeaveCriticalSection(&g_csHeap);
    }
    else
    {
        // We're no longer active, so just work normally
        bRet = ORIGINAL_API(RtlFreeHeap)(
                hHeap, 
                Flags, 
                lpMem);
    }

    return bRet;
}

/*++

 Clear all entries of this heap from our table.

--*/

BOOL
APIHOOK(HeapDestroy)(
    HANDLE hHeap
    )
{
    // Make sure we are the only ones touching our heap list
    EnterCriticalSection(&g_csHeap);

    if (g_pEntry)
    {
        // Remove entries in this heap from our list
        for (ULONG i=0; i<g_dwBufferSize; i++)
        {
            ENTRY *pEntry = g_pEntry + i;
            if (pEntry->hHeap == hHeap)
            {
                pEntry->hHeap = 0;
            }
        }
    }
    
    // We're done with the list
    LeaveCriticalSection(&g_csHeap);

    return ORIGINAL_API(HeapDestroy)(hHeap);
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL and KERNEL32 APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
        
            if (! csCl.IsEmpty())
            {
                WCHAR * unused = NULL;
                g_dwBufferSize= wcstol(csCl, &unused, 10);
            }
            if (g_dwBufferSize == 0)
            {
                g_dwBufferSize = DEFAULT_BUFFER_SIZE;
            }

            if (!InitializeCriticalSectionAndSpinCount(&g_csHeap, 0x80000000))
            {
                DPFN( eDbgLevelError, "InitializeCriticalSectionAndSpinCount failed!");
                return FALSE;
            }

            g_bHead = 0;
            g_bTail = g_dwBufferSize - 1;
            g_pEntry = (ENTRY *)VirtualAlloc(0, 
                                             sizeof(ENTRY) * g_dwBufferSize, 
                                             MEM_COMMIT, 
                                             PAGE_READWRITE);
            if (!g_pEntry)
            {
                DPFN( eDbgLevelError, "Allocation of global buffer failed!");
                return FALSE;
            }
        }
        CSTRING_CATCH
        {
            return FALSE;
        }

        return TRUE;
    }
    if (fdwReason == DLL_PROCESS_DETACH) 
    {
        EnterCriticalSection(&g_csHeap);
        VirtualFree(g_pEntry, 0, MEM_RELEASE);
        g_pEntry = (ENTRY *)NULL;
        LeaveCriticalSection(&g_csHeap);
        
        // Don't delete this critical section in case we get called after detach
        // DeleteCriticalSection(&g_csHeap);
        return TRUE;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlFreeHeap)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapDestroy)

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\heappadallocation.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapPadAllocation.cpp

 ModAbstract:
     
    This shim pads heap allocations by n bytes - where n is 256 by default but 
    can be specified by command line.
     
 Notes:

    This is a general purpose shim.

 History:
           
    09/28/1999 linstev  Created
    04/25/2000 linstev  Added command line 
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapPadAllocation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
APIHOOK_ENUM_END

#define DEFAULT_PAD_SIZE 256

DWORD g_dwPadSize = DEFAULT_PAD_SIZE;

/*++

 Increase the heap allocation size.

--*/

PVOID 
APIHOOK(RtlAllocateHeap)(
    PVOID HeapHandle,
    ULONG Flags,
    SIZE_T Size
    )
{
    return ORIGINAL_API(RtlAllocateHeap)(HeapHandle, Flags, Size + g_dwPadSize);
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL and KERNEL32 APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
        
            if (! csCl.IsEmpty())
            {
                WCHAR * unused = NULL;
                g_dwPadSize = wcstol(csCl, &unused, 10);
            }
            if (g_dwPadSize == 0)
            {
                g_dwPadSize = DEFAULT_PAD_SIZE;
            }

            DPFN( eDbgLevelInfo, "Padding all heap allocations by %d bytes\n", g_dwPadSize);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    } 

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\heapvalidatefrees.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeapValidateFrees.cpp

 ModAbstract:
     
    Verifies the pointer passed to RtlFreeHeap and RtlReAllocateHeap to make 
    sure they belong to the heap specified
     
 Notes:

    This is a general purpose shim.

 History:
           
    04/25/2000 linstev  Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeapValidateFrees)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RtlFreeHeap) 
    APIHOOK_ENUM_ENTRY(RtlReAllocateHeap) 
    APIHOOK_ENUM_ENTRY(RtlSizeHeap) 
APIHOOK_ENUM_END

/*++

 Verify that the pointer being freed belongs to the heap.

--*/

BOOL
APIHOOK(RtlFreeHeap)(
    PVOID HeapHandle,
    ULONG Flags,
    PVOID BaseAddress
    )
{
    BOOL bRet = FALSE; 

    if (HeapValidate(HeapHandle, 0, BaseAddress)) 
    {
        bRet = ORIGINAL_API(RtlFreeHeap)(HeapHandle, Flags, BaseAddress);
    }
    else 
    {
        LOGN( eDbgLevelError,
            "[APIHook_RtlFreeHeap] Invalid Pointer 0x%x for Heap 0x%x.",
            BaseAddress, HeapHandle);
    }
    
    return bRet;
}

/*++

 Verify that the pointer being freed belongs to the heap.

--*/

LPVOID
APIHOOK(RtlReAllocateHeap)(
    HANDLE hHeap,  
    DWORD dwFlags, 
    LPVOID lpMem,  
    DWORD dwBytes  
    )
{
    LPVOID pRet = NULL;

    if (HeapValidate(hHeap, 0, lpMem)) 
    {
        pRet = ORIGINAL_API(RtlReAllocateHeap)(hHeap, dwFlags, lpMem, dwBytes);
    }
    else
    {
        LOGN( eDbgLevelError,
            "[APIHook_RtlReAllocateHeap] Invalid Pointer 0x%x for Heap 0x%x.",
            lpMem, hHeap);
    }

    return pRet;
}

/*++

 Verify that the pointer being sized belongs to the heap

--*/

DWORD
APIHOOK(RtlSizeHeap)(
    HANDLE hHeap,  
    DWORD dwFlags, 
    LPCVOID lpMem  
    )
{
    DWORD dwRet = (DWORD)-1;

    if (HeapValidate(hHeap, 0, lpMem)) 
    {
        dwRet = ORIGINAL_API(RtlSizeHeap)(hHeap, dwFlags, lpMem);
    }
    else
    {
        LOGN( eDbgLevelError,
            "[APIHook_RtlSizeHeap] Invalid Pointer 0x%x for Heap 0x%x.",
            lpMem, hHeap);
    }

    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NTDLL.DLL, RtlFreeHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlReAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlSizeHeap)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\hidecursor.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    HideCursor.cpp

 Abstract:

    ShowCursor will display the cursor if the count is >= 0, this shim will 
    force ShowCursor to act as a toggle rather than a count.
   
    In other words it forces the count to be 0 or -1.

 History:

    05/25/2001  robkenny   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HideCursor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShowCursor)
APIHOOK_ENUM_END

int
APIHOOK(ShowCursor)(
    BOOL bShow   // cursor visibility
    )
{
    int nShowCount = ShowCursor(bShow);

    while (nShowCount > 0)
    {
        // Hide the cursor until the count reaches 0
        nShowCount = ShowCursor(FALSE);
    }

    while (nShowCount < -1)
    {
        // Show the cursor until the count reaches -1
        nShowCount = ShowCursor(TRUE);
    }

    return nShowCount;
}

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ShowCursor)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorealttab.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IgnoreAltTab.cpp

 Abstract:

   This DLL installs a low level keyboard hook to eat Alt-Tab, Left Win,
   Right Win and Apps combinations.
   
   This is accomplished by creating a seperate thread, installing a WH_KEYBOARD_LL hook
   and starting a message loop in that thread.
   

   This shim needs to force DInput to use windows hooks instead of WM_INPUT,
   since WM_INPUT messages force all WH_KEYBOARD_LL to be ignored.

 Notes:

   We intentionally try to stay at the *end* of the hook chain
   by hooking as early as we can.  If we are at the end of the
   hook chain, we allow all previous hookers (DInput especially)
   their chance at the key event before we toss it out.

 History:

    05/25/2001  robkenny   Created
    11/27/2001  mnikkel    Added sticky and filter keys to shim.

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(IgnoreAltTab)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterRawInputDevices)
APIHOOK_ENUM_END


// Forward declarations

LRESULT CALLBACK KeyboardProcLL(int nCode, WPARAM wParam, LPARAM lParam);
class CThreadKeyboardHook;


// Global variables

CThreadKeyboardHook *g_cKeyboardHook = NULL;

BOOL g_bFilterKeyInit = FALSE;
BOOL g_bStickyKeyInit = FALSE;
BOOL g_bCatchKeys     = TRUE;

STICKYKEYS g_OldStickyKeyValue;
FILTERKEYS g_OldFilterKeyValue;

class CThreadKeyboardHook
{
protected:
    HHOOK               hKeyboardHook;
    HANDLE              hMessageThread;
    DWORD               dwMessageThreadId;

public:
    CThreadKeyboardHook();

    void    AddHook();
    void    RemoveHook();

    LRESULT HandleKeyLL(int code, WPARAM wParam, LPARAM lParam);

    static DWORD WINAPI MessageLoopThread(LPVOID lpParameter);
};

/*++

  This routine runs in a seperate thread.
 
  MSDN says: "This hook is called in the context of the thread that installed it.
              The call is made by sending a message to the thread that installed
              the hook. Therefore, the thread that installed the hook must have a message loop." 

--*/

DWORD WINAPI CThreadKeyboardHook::MessageLoopThread(LPVOID lpParameter)
{
    CThreadKeyboardHook * pThreadHookList = (CThreadKeyboardHook *)lpParameter;


    pThreadHookList->AddHook();

    DPFN(eDbgLevelSpew, "Starting message loop");

    BOOL bRet;
    MSG msg;

    while ((bRet = GetMessage(&msg, NULL, 0, 0)) != 0)
    { 
        DPFN(eDbgLevelSpew, "MessageLoopThread: Msg(0x%08x) wParam(0x%08x) lParam(0x%08x)",
             msg.message, msg.wParam, msg.lParam);

        if (bRet == -1)
        {
            // handle the error and possibly exit
        }
        else
        {
            TranslateMessage(&msg); 
            DispatchMessage(&msg); 
        }
    }
    
    // We are exiting the thread
    pThreadHookList->hMessageThread = 0;
    pThreadHookList->dwMessageThreadId = 0;

    return 0;
}

CThreadKeyboardHook::CThreadKeyboardHook()
{
    hMessageThread = CreateThread(NULL, 0, MessageLoopThread, this, 0, &dwMessageThreadId);
}

void CThreadKeyboardHook::AddHook()
{
    // Do not add duplicates to the list
    if (!hKeyboardHook)
    {
        hKeyboardHook = SetWindowsHookExA(WH_KEYBOARD_LL, KeyboardProcLL, g_hinstDll, 0);
        if (hKeyboardHook)
        {
            DPFN(eDbgLevelSpew, "Adding WH_KEYBOARD_LL hook(0x%08x)", hKeyboardHook);
        }
    }
}

void CThreadKeyboardHook::RemoveHook()
{
    if (hKeyboardHook)
    {
        UnhookWindowsHookEx(hKeyboardHook);

        DPFN(eDbgLevelSpew, "Removing hook(0x%08x)", hKeyboardHook);

        hKeyboardHook   = NULL;
    }
}

LRESULT CThreadKeyboardHook::HandleKeyLL(int code, WPARAM wParam, LPARAM lParam)
{
    DWORD dwKey             = 0;
    BOOL bAltDown           = 0;
    BOOL bCtlDown           = GetKeyState(VK_CONTROL) < 0;

    if (lParam)
    {
        KBDLLHOOKSTRUCT * pllhs = (KBDLLHOOKSTRUCT*)lParam;
        dwKey                   = pllhs->vkCode;
        bAltDown                = (pllhs->flags & LLKHF_ALTDOWN) != 0;
    }

    //if (code >= 0)    // Despite what MSDN says, we need to muck with the values even if nCode == 0
    {
        if (bAltDown && dwKey == VK_TAB)        // Alt-Tab
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Alt-Tab");
            return TRUE; 
        }
        else if (bAltDown && dwKey == VK_ESCAPE)     // Alt-Escape
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Alt-Escape");
            return TRUE; 
        }
        else if (bCtlDown && dwKey == VK_ESCAPE)     // Ctrl-Escape
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Ctrl-Escape");
            return TRUE; 
        }
        else if (dwKey == VK_RWIN || dwKey == VK_LWIN) // Windows key
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Windows Key");
            return TRUE; 
        }
        else if (dwKey == VK_APPS)       // Menu key
        {
            // Do not process this event
            LOGN(eDbgLevelInfo, "Eating Key: Apps key");
            return TRUE; 
        }
    }

    DPFN(eDbgLevelSpew, "LL Key event:  code(0x%08x) dwKey(0x%08x) bits(0x%08x) Alt(%d) Ctrl(%d)",
          code, dwKey, lParam, bAltDown, bCtlDown);

    return CallNextHookEx(hKeyboardHook, code, wParam, lParam);
}



/*++

 This function intercepts special codes and eats them so that
 the app is not switched out of.

--*/

LRESULT CALLBACK
KeyboardProcLL(
    int    nCode,
    WPARAM wParam,
    LPARAM lParam
   )
{
    if (g_cKeyboardHook)
    {
        return g_cKeyboardHook->HandleKeyLL(nCode, wParam, lParam);
    }

    return 1; // this is an error...
}

/*++

 Determine if there are any accelerated pixel formats available. This is done
 by enumerating the pixel formats and testing for acceleration.

--*/

BOOL
IsGLAccelerated()
{
    HMODULE hMod = NULL;
    HDC hdc = NULL;
    int i;
    PIXELFORMATDESCRIPTOR pfd;
    _pfn_wglDescribePixelFormat pfnDescribePixelFormat;

    int iFormat = -1;

    //
    // Load original opengl
    //

    hMod = LoadLibraryA("opengl32");
    if (!hMod)
    {
        LOGN(eDbgLevelError, "Failed to load OpenGL32");
        goto Exit;
    }

    //
    // Get wglDescribePixelFormat so we can enumerate pixel formats
    //
    
    pfnDescribePixelFormat = (_pfn_wglDescribePixelFormat) GetProcAddress(
        hMod, "wglDescribePixelFormat");
    if (!pfnDescribePixelFormat)
    {
        LOGN(eDbgLevelError, "API wglDescribePixelFormat not found in OpenGL32");
        goto Exit;
    }

    //
    // Get a Display DC for enumeration
    //
    
    hdc = GetDC(NULL);
    if (!hdc)
    {
        LOGN(eDbgLevelError, "GetDC(NULL) Failed");
        goto Exit;
    }

    //
    // Run the list of pixel formats looking for any that are non-generic,
    //   i.e. accelerated by an ICD
    //
    
    i = 1;
    iFormat = 0;
    while ((*pfnDescribePixelFormat)(hdc, i, sizeof(PIXELFORMATDESCRIPTOR), &pfd))
    {
        if ((pfd.dwFlags & PFD_DRAW_TO_WINDOW) &&
            (pfd.dwFlags & PFD_SUPPORT_OPENGL) &&
            (!(pfd.dwFlags & PFD_GENERIC_FORMAT)))
        {
            iFormat = i;
            break;
        }

        i++;
    }

Exit:
    if (hdc)
    {
        ReleaseDC(NULL, hdc);
    }

    if (hMod)
    {
        FreeLibrary(hMod);
    }

    return (iFormat > 0);
}


/*++

 WM_INPUT messages force WH_KEYBOARD_LL hooks to be ignored, therefore
 we need to fail this call.
 
--*/
BOOL
APIHOOK(RegisterRawInputDevices)(
  PCRAWINPUTDEVICE  /*pRawInputDevices*/, 
  UINT        /*uiNumDevices*/,
  UINT        /*cbSize*/
)
{
    LOGN(eDbgLevelError, "RegisterRawInputDevices: failing API with bogus ERROR_INVALID_PARAMETER");

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}
/*++

 DisableStickyKeys saves the current value for LPSTICKYKEYS and then disables the option.

--*/

VOID 
DisableStickyKeys()
{
    if (!g_bStickyKeyInit )
    {
        STICKYKEYS NewStickyKeyValue;

        // Initialize the current and new Stickykey structures
        g_OldStickyKeyValue.cbSize = sizeof(STICKYKEYS);
        NewStickyKeyValue.cbSize = sizeof(STICKYKEYS);
        NewStickyKeyValue.dwFlags = 0;

        // retrieve the current Stickykey structure
        if (SystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(STICKYKEYS), &g_OldStickyKeyValue, 0))
        {
            // if retrieval of current Stickykey structure was successful then change the settings
            // with the new structure.
            if (SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), &NewStickyKeyValue, SPIF_SENDCHANGE))
            {
                g_bStickyKeyInit  = TRUE;
                LOGN( eDbgLevelInfo, "[DisableStickyKeys] Stickykeys disabled.");
            }
            else
            {
                LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to change Stickykey settings!");
            }
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to retrieve current Stickykey settings!");
        }
    }
}

/*++

 EnableStickyKeys uses the save value for STICKYKEYS and resets the option to the original setting.

--*/

VOID 
EnableStickyKeys()
{
    if (g_bStickyKeyInit ) 
    {
        g_bStickyKeyInit  = FALSE;

        // Restore Stickykey original state
        if (SystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(STICKYKEYS), &g_OldStickyKeyValue, SPIF_SENDCHANGE))
        {   
            LOGN( eDbgLevelInfo, "[DisableStickyKeys] Sticky key state restored");
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to restore Sticky key settings!");
        }
    }
}


/*++

 DisableFilterKeys saves the current value for LPFILTERKEYS and then disables the option.

--*/

VOID 
DisableFilterKeys()
{
    if (!g_bFilterKeyInit) 
    {
        FILTERKEYS NewFilterKeyValue;

        // Initialize the current and new Filterkey structures
        g_OldFilterKeyValue.cbSize = sizeof(FILTERKEYS);
        NewFilterKeyValue.cbSize = sizeof(FILTERKEYS);
        NewFilterKeyValue.dwFlags = 0;

        // retrieve the current stickykey structure
        if (SystemParametersInfo(SPI_GETFILTERKEYS, sizeof(FILTERKEYS), &g_OldFilterKeyValue, 0))
        {
            // if retrieval of current Filterkey structure was successful then change the settings
            // with the new structure.
            if (SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), &NewFilterKeyValue, SPIF_SENDCHANGE))
            {
                g_bFilterKeyInit = TRUE;
                LOGN( eDbgLevelInfo, "[DisableFilterKeys] Filterkeys disabled.");
            }
            else
            {
                LOGN( eDbgLevelError, "[DisableFilterKeys] Unable to change Filterkey settings!");
            }
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableFilterKeys] Unable to retrieve current Filterkey settings!");
        }
    }
}

/*++

 EnableFilterKeys uses the save value for FILTERKEYS and resets the option to the original setting.

--*/

VOID 
EnableFilterKeys()
{
    if (g_bFilterKeyInit)
    {
        g_bFilterKeyInit = FALSE;

        // Restore Filterkey original state
        if (SystemParametersInfo(SPI_SETFILTERKEYS, sizeof(FILTERKEYS), &g_OldFilterKeyValue, SPIF_SENDCHANGE))
        {   
            LOGN( eDbgLevelInfo, "[DisableStickyKeys] Filterkey state restored");
        }
        else
        {
            LOGN( eDbgLevelError, "[DisableStickyKeys] Unable to restore Filterkey settings!");
        }
    }
}


/*++

 Handle Shim notifications.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
   )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
            if (csCl.CompareNoCase(L"NOKEYS") == 0)
            {
                g_bCatchKeys = FALSE;
            }
        }
        CSTRING_CATCH
        {
            // no action
        }
    }
    else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        if (g_bCatchKeys)
        {
            DisableStickyKeys();
            DisableFilterKeys();
        }

        #if DBG
        static bool bTest = FALSE;
        if (bTest)
        {
            delete g_cKeyboardHook;
            g_cKeyboardHook = NULL;
            return TRUE;
        }
        #endif

        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);
            if (csCl.CompareNoCase(L"OPENGL") == 0)
            {
                // This must be called *after* the dll's have been initialized
                if (IsGLAccelerated())
                {
                    return TRUE;
                }
            }

            g_cKeyboardHook = new CThreadKeyboardHook;
            if (!g_cKeyboardHook)
            {
                return FALSE;
            }

        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    } 
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        if (g_bCatchKeys)
        {
            EnableFilterKeys();
            EnableStickyKeys();
        }
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL,   RegisterRawInputDevices)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorecocreateinstance.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    IgnoreCoCreateInstance.cpp

 Abstract:

    Ignore specified CoCreateInstance calls.

 Notes:

    This is a general purpose shim.

 History:

    01/07/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreCoCreateInstance)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CoCreateInstance)
APIHOOK_ENUM_END

int g_nCount = 0;
CString *g_rGUIDs = NULL;

/*++

 Ignore specified CoCreateInstance calls
 
--*/

STDAPI 
APIHOOK(CoCreateInstance)(
    REFCLSID  rclsid,     
    LPUNKNOWN pUnkOuter, 
    DWORD     dwClsContext,  
    REFIID    riid,         
    LPVOID*   ppv
    )
{
    CSTRING_TRY
    {
        //
        // Convert the CLSID to a string so we can compare it to our guids
        //

        LPOLESTR wszCLSID;
        if (StringFromCLSID(rclsid, &wszCLSID) == S_OK) {
            // Run the list and jump out if we match
            CString csClass(wszCLSID);
            for (int i = 0; i < g_nCount; i++) {
                if (csClass.CompareNoCase(g_rGUIDs[i]) == 0) {
                    LOGN(eDbgLevelWarning, "[CoCreateInstance] Failed %S", wszCLSID);

                    // Free the memory
                    CoTaskMemFree(wszCLSID);
                    return REGDB_E_CLASSNOTREG;
                }
            }
            
            // Free the memory
            CoTaskMemFree(wszCLSID);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return ORIGINAL_API(CoCreateInstance)(rclsid, pUnkOuter, dwClsContext, riid, 
        ppv);
}
 
/*++

 Register hooked functions

--*/

BOOL ParseCommandLine()
{
    CSTRING_TRY
    {
        CString csCl(COMMAND_LINE);
        CStringParser csParser(csCl, L";");

        g_nCount = csParser.GetCount();
        g_rGUIDs = csParser.ReleaseArgv();
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    for (int i = 0; i < g_nCount; ++i) {
        DPFN(eDbgLevelInfo, "ClassID = %S", g_rGUIDs[i].Get());
    }

    return TRUE;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return ParseCommandLine();
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(OLE32.DLL, CoCreateInstance)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\hidetaskbar.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HideTaskBar.cpp

 Abstract:

    The WS_EX_CLIENTEDGE flag means that the taskbar gets shown on NT. This 
    isn't always what's desirable.

 Notes:

    This is a general purpose shim.

 History:

    04/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HideTaskBar)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExW) 
APIHOOK_ENUM_END

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    // Remove the client edge style.
    dwExStyle &= ~WS_EX_CLIENTEDGE;

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    dwExStyle &= ~WS_EX_CLIENTEDGE;
    
    // Call the original API
    return ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorecrtexit.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    IgnoreCRTExit.cpp

 Abstract:

    Prevent CRT shutdown routines from running. At some point MSVCRT didn't 
    actually call these, so some apps fault when they really do get called.
    
 Notes:
    
    This is a general purpose shim.
   
 History:

    05/09/2002  linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreCRTExit)
#include "ShimHookMacro.h"

typedef LPVOID (__cdecl *_pfn_atexit)(LPVOID);
typedef LPVOID (__cdecl *_pfn__onexit)(LPVOID);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(atexit) 
    APIHOOK_ENUM_ENTRY(_onexit) 
APIHOOK_ENUM_END

VOID
__cdecl
APIHOOK(atexit)(LPVOID lpFunc)
{
    return;
}

LPVOID
__cdecl
APIHOOK(_onexit)(LPVOID lpFunc)
{
    return lpFunc;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSVCRT.DLL, atexit)
    APIHOOK_ENTRY(MSVCRT.DLL, _onexit)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ieunharden.cpp ===
/*++

 Copyright (c) 2002-2003 Microsoft Corporation

 Module Name:

    IEUnHarden.cpp

 Abstract:

    IESoftening modifications

 History:

    01/15/2003  prashkud    Created    

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IEUnHarden)

#include <windows.h>
#include <urlmon.h>
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

APIHOOK_ENUM_END

#define SUCCESS(val) ((val == ERROR_SUCCESS) ? TRUE : FALSE)

IInternetSecurityManager *g_pISM = NULL;

BOOL
IEHardeningEnabled()
{
    BOOL bRet = FALSE;
    HKEY hUserKey = 0;
    HKEY hAdminKey = 0;

    const WCHAR wszIEUserHardeningPath[] 
                    = L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{A509B1A7-37EF-4b3f-8CFC-4F3A74704073}";

    const WCHAR wszIEAdminHardeningPath[] 
                    = L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{A509B1A8-37EF-4b3f-8CFC-4F3A74704073}";


    DWORD dwVal = 0;    
    DWORD dwcbBuf = sizeof(dwVal);

    if (SUCCESS(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszIEUserHardeningPath, 0, KEY_READ |  KEY_WOW64_64KEY, &hUserKey)))
    {
        if (SUCCESS(RegQueryValueExW(hUserKey, L"IsInstalled", NULL, NULL, (LPBYTE)&dwVal, &dwcbBuf)))
        {
            if (dwVal == 1)
            {
                bRet = TRUE;
            }
        }
    }

    dwVal = 0;    
    dwcbBuf = sizeof(dwVal);

    if (!bRet )
    {
        if (SUCCESS(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszIEAdminHardeningPath, 0, KEY_READ | KEY_WOW64_64KEY, &hAdminKey)))
        {
            if (SUCCESS(RegQueryValueExW(hAdminKey, L"IsInstalled", NULL, NULL, (LPBYTE)&dwVal, &dwcbBuf)))
            {
                if (dwVal == 1)
                {
                    bRet = TRUE;
                }
            }        
        }
    }

    if (hUserKey)
    {
        RegCloseKey(hUserKey);
        hUserKey = 0;
    }

    if (hAdminKey)
    {
        RegCloseKey(hAdminKey);
        hAdminKey = 0;
    }
    return bRet;
}


VOID
AddUrlToTrustDomain(CString& csUrl, BOOL bIntranet)
{
    if (g_pISM)            
    {
        DWORD dwZone = bIntranet ? URLZONE_INTRANET : URLZONE_TRUSTED;
        HRESULT hres = g_pISM->SetZoneMapping(dwZone, csUrl.Get(), SZM_CREATE);

        if (hres == E_ACCESSDENIED)
        {
            DPFN(eDbgLevelError, "[IEUnHarden] Attempted to enter a non-SSL site \
                                into a zone that requires server verification \n");
        }
        else if (hres == E_FAIL)
        {
            DPFN(eDbgLevelError, "[IEUnHarden] The mapping already exists \n");
        }        
        else if (hres == E_INVALIDARG)
        {
            DPFN(eDbgLevelError, "[IEUnHarden] Invalid wildcard \n");
        }
        else if (hres == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
        {
            DPFN(eDbgLevelError, "[IEUnHarden] The mapping already exists in another zone \n");
        }
        else
        {
            DPFN(eDbgLevelError, "[IEUnHarden] SetZoneMapping() failed ! \n");
        }
    }    
}

BOOL
ParseCommandLineA(LPCSTR szParam)
{
    if (!IEHardeningEnabled())
    {
        return FALSE;
    }        
    
    CSTRING_TRY
    {
        CStringToken csParam(szParam, "|");
        CString csTok;            

        while (csParam.GetToken(csTok))
        {    
            csTok.TrimLeft();
            csTok.TrimRight();
            if (csTok.ComparePartNoCase(L"TrustedSites", 0, wcslen(L"TrustedSites")) == 0)    // TrustedSites is the first word
            {
                int nLeftBracket, nRightBracket;
                CString csUrl;

                nLeftBracket = csTok.Find(L'{');
                nRightBracket = csTok.Find(L'}');
                if (nLeftBracket != -1 &&
                    nRightBracket != -1 &&
                    (nLeftBracket + 1) < (nRightBracket - 1))
                {
                    csUrl = csTok.Mid(nLeftBracket+1, nRightBracket-nLeftBracket-1);
                    AddUrlToTrustDomain(csUrl, FALSE);

                }
                else
                {
                    DPFN(eDbgLevelError, "Invalid command line. Should be enclosed in {}/n");
                }
            }            
            else if (csTok.ComparePartNoCase(L"TrustedIntranetSites", 0,
                                            wcslen(L"TrustedIntranetSites")) == 0)    // TrustedIntranetSites is the first word
            {
                int nLeftBracket, nRightBracket;
                CString csUrl;

                nLeftBracket = csTok.Find(L'{');
                nRightBracket = csTok.Find(L'}');
                if (nLeftBracket != -1 &&
                    nRightBracket != -1 && 
                    (nLeftBracket + 1) < (nRightBracket - 1))
                {
                    csUrl = csTok.Mid(nLeftBracket+1, nRightBracket-nLeftBracket-1);
                    AddUrlToTrustDomain(csUrl, TRUE);

                }
                else
                {
                    DPFN(eDbgLevelError, "Invalid command line. Should be enclosed in {}/n");
                }
            }
            else
            {
                DPFN(eDbgLevelError, "[IESOFT] Invalid option %s \n", csTok.GetAnsi());
                return FALSE;
            }
        }
    }
    CSTRING_CATCH
    {
        DPFN(eDbgLevelError, "Out of Memory \n");       
        return FALSE;
    }    

    return TRUE;
}

BOOL
InitCOM()
{
    BOOL bRet = FALSE;
    HRESULT hres = CoInitialize(NULL);
    if (SUCCEEDED(hres)||
        (hres == S_FALSE))    // COM library is already initialized on this thread
    {
        
        hres = CoCreateInstance(CLSID_InternetSecurityManager,
                                NULL,
                                CLSCTX_INPROC_SERVER, 
                                IID_IInternetSecurityManager,
                                (void **)&g_pISM);

        if (SUCCEEDED(hres))            
        {
            bRet = TRUE;
        }
        else
        {
            DPFN(eDbgLevelError, "Failed to create IInternetSecurityManager object \n");
        }
    }
    else
    {
        DPFN(eDbgLevelError, "Failed to initialize COM Library \n");
    }

    return bRet;
}

void
UnInitCOM()
{
    if (g_pISM)
    {
        g_pISM->Release();
    }
    CoUninitialize();
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        if (!InitCOM())
        {
            return FALSE;
        }
        if (ParseCommandLineA(COMMAND_LINE) == FALSE)
        {            
            return FALSE;
        }

        UnInitCOM();
    }
    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignoredebugoutput.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreDebugOutput.cpp

 Abstract:

    If an app tries to output debug strings, throws them on the floor to improve 
    perf.

 Notes:

    This shim is general purpose and emulates Win9x behavior (at least it 
    emulates the behavior when there's no debugger attached).

 History:

    05/10/2000   dmunsil     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreDebugOutput)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OutputDebugStringA)
    APIHOOK_ENUM_ENTRY(OutputDebugStringW)
APIHOOK_ENUM_END

/*++

 This stub function throws away all debug strings

--*/

VOID 
APIHOOK(OutputDebugStringA)(
    LPCSTR lpOutputString
    )
{
    return;
}

/*++

 This stub function throws away all debug strings

--*/

VOID 
APIHOOK(OutputDebugStringW)(
    LPCWSTR lpOutputString
    )
{
    return;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, OutputDebugStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, OutputDebugStringW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorefreelibrary.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreFreeLibrary.cpp

 Abstract:

    Some applications free DLLs before they're actually ready to. When this occurs,
    if the offending application attempts to make a call to an exported function,
    the call fails. This results in an access violation.
    
    This shim takes a command line of ; delimited DLL names. For each DLL on the command
    line, a call to FreeLibrary for the specified DLL will be ignored.
                                                             
    Example:

    xanim.dll
    
    video_3dfx.dll;glide.dll

 Notes:
    
    This is a general purpose shim.

 History:

    10/31/2000 rparsons  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreFreeLibrary)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FreeLibrary) 
APIHOOK_ENUM_END

#define MAX_FILES 64

int                 g_nLibraryCountFreeLibrary          = 0;
CString *           g_rgLibrariesToIgnoreFreeLibrary    = NULL;



/*++

 Hook the call to FreeLibrary. Determine if the file name that corresponds to this
 module should be ignored.

--*/

BOOL
APIHOOK(FreeLibrary)( 
    HMODULE hModule
    )
{
    CSTRING_TRY
    {
        CString csModule;
        csModule.GetModuleFileNameW(hModule);

        CString csFileName;
        csModule.GetLastPathComponent(csFileName);

        for (int i = 0; i < g_nLibraryCountFreeLibrary; ++i)
        {
            if (csFileName.CompareNoCase(g_rgLibrariesToIgnoreFreeLibrary[i]) == 0)
            {
                DPFN( eDbgLevelInfo, "Caught attempt freeing %S\n", csModule.Get());
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
    
    return ORIGINAL_API(FreeLibrary)(hModule);
}

/*++

 This function parses the COMMAND_LINE for the libraries that should
 have their FreeLibrary call ignored.

--*/

BOOL ParseCommandLine()
{
    CSTRING_TRY
    {
        CString         csCl(COMMAND_LINE);
        CStringParser   csParser(csCl, L";");

        g_nLibraryCountFreeLibrary          = csParser.GetCount();
        g_rgLibrariesToIgnoreFreeLibrary    = csParser.ReleaseArgv();
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    for (int i = 0; i < g_nLibraryCountFreeLibrary; ++i) {
        DPFN( eDbgLevelInfo, "Library %d: name: --%S--\n", i, g_rgLibrariesToIgnoreFreeLibrary[i].Get());
    }

    return TRUE;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return ParseCommandLine();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignoremcistop.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreMCIStop.cpp

 Abstract:

    The shim hooks mciSendCommand and ignores MCI_STOP which takes 2-3 seconds
    on my P2-400. 

    Sent to the audio team for fixing, but I'm not optimistic - bug number 
    246407.

 Notes:

    This cannot be put in the layer, but can apply to more than one app.

 History:

    08/04/2000 a-brienw  Created
    11/30/2000 linstev   Generalized 

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(IgnoreMCIStop)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Hook mciSendCommand and perform the shims duties.

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    if (uMsg == MCI_STOP)
    {
        DPFN( eDbgLevelWarning, "Ignoring MCI_STOP");
        return 0;
    }

    if (uMsg == MCI_CLOSE)
    {
        DPFN( eDbgLevelWarning, "MCI_CLOSE called: issuing MCI_STOP");
        mciSendCommandA(IDDevice, MCI_STOP, 0, 0);
    }

    MCIERROR mErr = ORIGINAL_API(mciSendCommandA)(
        IDDevice,
        uMsg,
        fdwCommand,
        dwParam);

    return mErr;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorehungapppaint.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreHungAppPaint.cpp

 Abstract:

    Setup the hollow brush to prevent user from trashing peoples windows.

 Notes:

    This is a general purpose shim.

 History:
    
    12/04/2000 linstev  Created

--*/

#include "precomp.h"
#include <new.h>

IMPLEMENT_SHIM_BEGIN(IgnoreHungAppPaint)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(RegisterClassW)
    APIHOOK_ENUM_ENTRY(RegisterClassExA)
    APIHOOK_ENUM_ENTRY(RegisterClassExW)
APIHOOK_ENUM_END

struct HUNGCLASS
{
    CString csClass;    
    HUNGCLASS *next;
};
HUNGCLASS *g_lHungList = NULL;

BOOL g_bAll = FALSE;

/*++

 Check if a class needs a hollow brush.

--*/

BOOL
IsHungClassW(LPCWSTR wszClass)
{
    BOOL bRet = FALSE;

    if (wszClass)
    {
        HUNGCLASS *h = g_lHungList;
        while (h)
        {
            if (h->csClass.CompareNoCase(wszClass) == 0)
            {
                LOGN(eDbgLevelWarning, "Matched hung class: forcing HOLLOW_BRUSH");

                bRet = TRUE;
                break;
            }
            h = h->next;
        }
    }

    return bRet;
}

/*++

 Check if a class needs a hollow brush.

--*/

BOOL
IsHungClassA(LPCSTR szClass)
{
   CSTRING_TRY
   {   
      CString csClass(szClass);
      return IsHungClassW(csClass);
   }
   CSTRING_CATCH
   {
      // Do nothing
   }
   
   return FALSE;
}

/*++

 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)

--*/

ATOM
APIHOOK(RegisterClassA)(
    WNDCLASSA *lpWndClass  
    )
{
    if (lpWndClass && (g_bAll || IsHungClassA(lpWndClass->lpszClassName)))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassA)(lpWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    WNDCLASSW *lpWndClass  
    )
{
    if (lpWndClass && IsHungClassW(lpWndClass->lpszClassName))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassW)(lpWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    WNDCLASSEXA *lpWndClass  
    )
{
    if (lpWndClass && IsHungClassA(lpWndClass->lpszClassName))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassExA)(lpWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    WNDCLASSEXW *lpWndClass  
    )
{
    if (lpWndClass && IsHungClassW(lpWndClass->lpszClassName))
    {
        lpWndClass->hbrBackground = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
    }

    return ORIGINAL_API(RegisterClassExW)(lpWndClass);
}

/*++

 Parse the command line for fixes:

    CLASS1; CLASS2; CLASS3 ...

--*/

VOID
ParseCommandLineA(
    LPCSTR lpCommandLine
    )
{
    // Add all the defaults if no command line is specified
    if (!lpCommandLine || (lpCommandLine[0] == '\0'))
    {
        g_bAll = TRUE;
        DPFN(eDbgLevelInfo, "All classes will use HOLLOW_BRUSH");
        return;
    }

    char seps[] = " ,\t;";
    char *token = NULL;

    // Since strtok modifies the string, we need to copy it 
    int cchCmdLine = strlen(lpCommandLine) + 1;
    LPSTR szCommandLine = (LPSTR) malloc(cchCmdLine);
    if (!szCommandLine) goto Exit;

    HRESULT hr;
    hr = StringCchCopyA(szCommandLine, cchCmdLine, lpCommandLine);
    if (FAILED(hr))
    {
       goto Exit;
    }

    //
    // Run the string, looking for fix names
    //
    
    token = _strtok(szCommandLine, seps);
    while (token)
    {
        HUNGCLASS *h;

        h = (HUNGCLASS *) malloc(sizeof(HUNGCLASS));
        if (h)
        {
            CSTRING_TRY
            {
               // Force a default construct of the CString (malloc doesn't)
               new(&h->csClass) CString();
               
               h->csClass = token;              
               
               h->next = g_lHungList;
               g_lHungList = h;
               DPFN(eDbgLevelInfo, "Adding %s", token);
            }
            CSTRING_CATCH
            {
               // Do nothing, loop around and try again with next one.
               DPFN(eDbgLevelError, "[IgnoreHungAppPaint] CString exception caught, out of memory");
            }            
        }
        else
        {
            DPFN(eDbgLevelError, "Out of memory");
        }
    
        // Get the next token
        token = _strtok(NULL, seps);
    }

Exit:
    if (szCommandLine)
    {
        free(szCommandLine);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        ParseCommandLineA(COMMAND_LINE);
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA);
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignoremessagebox.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   IgnoreMessageBox.cpp

 Abstract:

   This APIHooks MessageBox and based on the passed in command line prevents the
   message box from being displayed. Many applications display a message box with
   some debugging or other extraneous comment. This is normally the result of
   differences between Windows 98 and Whistler. 

   command line syntax:

   text,caption;text1,caption1

   The passed in command line is composed of a pair of one or more strings separated
   by semicolons. These string pairs form the text and caption that must match in order
   to block the display of the message box. If either the caption or text are not needed
   then they can be left blank. For example, "block this text,;" would prevent the message
   box from being displayed if the text passed to the message box was: block this text" the
   caption parameter would not be used. The following are some examples:

    "error message 1000,Error"      - would not display the message box if the
                                      lpCaption parameter contained Error and
                                      the lpText parameter contained error
                                      message 1000

    "error message 1000,"           - would not display the message box if the
                                      lpText parameter contained error message 1000

    ",Error"                        - would not display any message boxes if the
                                      lpCaption parameter contained Error
                                 
    "message1,Error;message2,Error2 - would not display the message box if the
                                      lpText parameter contained message1 and
                                      the lpCaption parameter contained Error or
                                      the lpText parameter contained message2 and
                                      the lpCaption paramter contained Error2.

    The match is performed on the command line string to the current message box
    parameter string. The command line string can contain wildcard specification
    characters. This allows complex out of order matching to take place see below:

        ?   match one character in this position
        *   match zero or more characters in this position

    If the source string contains any ? * , ; \ characters, precede them with a backslash.
    For example, the following command line would match the indicated text and caption:

        Text:           "Compatibility; A *very* important thing."
        Caption:        "D:\WORD\COMPAT.DOC"

        Command line:   "Compatibility\; A \*very\* important thing.,D:\\WORD\\COMPAT.DOC"

 Notes:

 History:

   04/06/2000 philipdu Created
   04/06/2000 markder  Added wide-character conversion, plus Ex versions.
   05/23/2001 mnikkel  Added W routines so we can pick up system messagebox calls

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(IgnoreMessageBox)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA) 
    APIHOOK_ENUM_ENTRY(MessageBoxExA) 
    APIHOOK_ENUM_ENTRY(MessageBoxW) 
    APIHOOK_ENUM_ENTRY(MessageBoxExW) 
APIHOOK_ENUM_END


class MBPair
{
public:
    CString     csText;
    CString     csCaption;
};

VectorT<MBPair>     * g_IgnoreList = NULL;


BOOL IsBlockMessage(LPCSTR szOrigText, LPCSTR szOrigCaption)
{
    CSTRING_TRY
    {
        CString csText(szOrigText);
        CString csCaption(szOrigCaption);
    
        for (int i = 0; i < g_IgnoreList->Size(); ++i)
        {
            const MBPair & mbPair = g_IgnoreList->Get(i);
        
            BOOL bTextMatch  = mbPair.csText.IsEmpty()    || csText.PatternMatch(mbPair.csText);
            BOOL bTitleMatch = mbPair.csCaption.IsEmpty() || csCaption.PatternMatch(mbPair.csCaption);

            if (bTextMatch && bTitleMatch)
            {
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return FALSE;
}

BOOL IsBlockMessageW(LPWSTR szOrigText, LPWSTR szOrigCaption)
{
    CSTRING_TRY
    {
        CString csText(szOrigText);
        CString csCaption(szOrigCaption);
    
        for (int i = 0; i < g_IgnoreList->Size(); ++i)
        {
            const MBPair & mbPair = g_IgnoreList->Get(i);
        
            BOOL bTextMatch  = mbPair.csText.IsEmpty()    || csText.PatternMatch(mbPair.csText);
            BOOL bTitleMatch = mbPair.csCaption.IsEmpty() || csCaption.PatternMatch(mbPair.csCaption);

            if (bTextMatch && bTitleMatch)
            {
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return FALSE;
}


int
APIHOOK(MessageBoxA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessage(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxA swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%s\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%s\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxA)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}


int
APIHOOK(MessageBoxExA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessage(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxExA swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%s\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%s\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxExA)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    return iReturnValue;
}

int
APIHOOK(MessageBoxW)(
    HWND hWnd,          // handle to owner window
    LPWSTR lpText,      // text in message box
    LPWSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessageW(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxW swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%S\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%S\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxW)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}

int
APIHOOK(MessageBoxExW)(
    HWND hWnd,          // handle to owner window
    LPWSTR lpText,      // text in message box
    LPWSTR lpCaption,   // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;

    //if this is the passed in string that we want do not
    //want to display then simply return to caller.

    if (IsBlockMessageW(lpText, lpCaption))
    {
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] MessageBoxExW swallowed:\n");
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Caption = \"%S\"\n", lpCaption);
        DPFN( eDbgLevelInfo, "[IgnoreMessageBox] Text    = \"%S\"\n", lpText);
        return MB_OK;
    }

    iReturnValue = ORIGINAL_API(MessageBoxExW)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    return iReturnValue;
}


BOOL
ParseCommandLine(const char * cl)
{
    CSTRING_TRY
    {
        CStringToken csCommandLine(COMMAND_LINE, ";");
        CString csTok;
    
        g_IgnoreList = new VectorT<MBPair>;
        if (!g_IgnoreList)
        {
            return FALSE;
        }
    
        while (csCommandLine.GetToken(csTok))
        {
            MBPair mbPair;
            
            CStringToken csMB(csTok, ",");
            csMB.GetToken(mbPair.csText);
            csMB.GetToken(mbPair.csCaption);
    
            if (!g_IgnoreList->AppendConstruct(mbPair))
            {
                return FALSE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Fall through
        LOGN(eDbgLevelError, "[ParseCommandLine] Illegal command line");
    }    

    return g_IgnoreList && g_IgnoreList->Size() > 0;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW) 
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorenomodechange.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreNoModeChange.cpp

 Abstract:

    Ignore mode changes that are not really different from the current mode.

    The problem is that even if there is no real mode change, the uniqueness 
    value for the mode is still updated. DirectDraw checks this value every 
    time it enters any API and if the mode uniqueness value has changed, it
    resets all it's objects.

    Applications will hit this if they call ChangeDisplaySettings* and don't 
    realize that even if the mode is identical, they'll still have to reset 
    all their objects.

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreNoModeChange)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsW)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExW)
APIHOOK_ENUM_END


BOOL 
IsModeEqual(
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBitsPerPel,
    DWORD dwRefresh
    )
{
    BOOL     bRet = FALSE;
    DEVMODEA dm;
    
    dm.dmSize = sizeof(DEVMODEA);

    //
    // Get the existing settings.
    //
    if (EnumDisplaySettingsA(0, ENUM_CURRENT_SETTINGS, &dm)) {
        
        //
        // Assume that 0 or 1 means default refresh.
        //
        if (dwRefresh <= 1) {
            dwRefresh = dm.dmDisplayFrequency;
        }
        
        bRet = (dwWidth == dm.dmPelsWidth) &&
               (dwHeight == dm.dmPelsHeight) &&
               (dwBitsPerPel == dm.dmBitsPerPel) &&
               (dwRefresh == dm.dmDisplayFrequency);
    }

    if (bRet) {
        LOGN(
            eDbgLevelInfo,
            "[IsModeEqual] Ignoring irrelevant mode change.");
    } else {
        LOGN(
            eDbgLevelInfo,
            "Mode change is required.");
    }

    return bRet;
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD      dwFlags
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsA)(
                            lpDevMode,
                            CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsW)(
    LPDEVMODEW lpDevMode,
    DWORD      dwFlags
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsW)(
                            lpDevMode,
                            CDS_FULLSCREEN);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR     lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsExA)(
                            lpszDeviceName, 
                            lpDevMode, 
                            hwnd, 
                            CDS_FULLSCREEN, 
                            lParam);
}

/*++

 Force temporary change.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExW)(
    LPCWSTR    lpszDeviceName,
    LPDEVMODEW lpDevMode,
    HWND       hwnd,
    DWORD      dwflags,
    LPVOID     lParam
    )
{
    if (lpDevMode &&
        IsModeEqual(
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel,
            lpDevMode->dmDisplayFrequency)) {
        
        return DISP_CHANGE_SUCCESSFUL;
    }

    return ORIGINAL_API(ChangeDisplaySettingsExW)(
                            lpszDeviceName, 
                            lpDevMode, 
                            hwnd, 
                            CDS_FULLSCREEN, 
                            lParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsW)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignoreoemtochar.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    IgnoreOemToChar.cpp

 Abstract:

    Written originally to fix an Install Shield bug.  
    
    It may be specific to _ins5576._mp versions.

    The executable _ins5576._mp calls OemToChar on the string 
    "%userprofile%\local settings\temp\_istmp11.dir\_ins5576._mp".
    
    The call is unessasary and causes problems with path names that
    contain non-ansi characters.
    

 Notes:
    
    This is a general purpose shim.

 History:

    04/03/2001 a-larrsh  Created
    03/13/2002 mnikkel   Modified to use strsafe.h

--*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(IgnoreOemToChar)
#include "ShimHookMacro.h"

typedef BOOL (WINAPI *_pfn_OemToCharA)(LPCSTR lpszSrc, LPSTR lpszDst);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OemToCharA) 
APIHOOK_ENUM_END

/*++

 Hook the call to OemToCharA. Determine if the string should be ignored.

--*/

BOOL APIHOOK(OemToCharA)(
   LPCSTR lpszSrc,  // string to translate
   LPSTR lpszDst   // translated string
)
{
   BOOL bReturn = FALSE;

   CSTRING_TRY
   {
        CString sTemp(lpszSrc);

        sTemp.MakeUpper();

        if( sTemp.Find(L"TEMP") )
        {
            DPFN( eDbgLevelInfo, "Ignoring attempt to convert string %s\n", lpszSrc);

            if (lpszDst)
            {
                StringCchCopyA(lpszDst, strlen(lpszSrc)+1, lpszSrc);
                bReturn = TRUE;
            }
        }
   }
   CSTRING_CATCH
   {
       // do nothing
   }

   if (!bReturn)
   {
      bReturn = ORIGINAL_API(OemToCharA)(lpszSrc, lpszDst);
   }

   return bReturn;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, OemToCharA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignoresyscolchanges.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreSysColChanges.cpp

 Abstract:

    Do not change system colors. Of course this changes the behaviour between
    9x and NT, but we're trying to make the experience better.

 Notes:

    This is a general purpose shim.

 History:

    07/17/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreSysColChanges)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetSysColors) 
APIHOOK_ENUM_END

/*++

 Ignore changes to system colors

--*/

BOOL 
APIHOOK(SetSysColors)(
    int cElements,                 
    CONST INT *lpaElements,        
    CONST COLORREF *lpaRgbValues   
    )
{
    LOGN(
            eDbgLevelInfo,
            "Ignoring changes to system colors");

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SetSysColors)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorevboverflow.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IgnoreVBOverflow.cpp

 Abstract:

    Some VB applications don't expect full 32-bit handles from some APIs. VB
    type checking typically throws a "Runtime Error 6" message when 
    applications try and store a 32-bit value in a 16-bit variable.
    
    This fix works with VB5 and VB6 apps.

 Notes:

    This is a general purpose shim.

 History:

    05/21/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreVBOverflow)
#include "ShimHookMacro.h"

typedef DWORD (WINAPI *_pfn_VB5_vbaI2I4)();
typedef DWORD (WINAPI *_pfn_VB6_vbaI2I4)();

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VB5_vbaI2I4)
    APIHOOK_ENUM_ENTRY(VB6_vbaI2I4)
APIHOOK_ENUM_END

/*++

  Zero the return if ecx > 0xFFFF

--*/

__declspec(naked)
VOID
APIHOOK(VB5_vbaI2I4)()
{
    __asm {
        test  ecx, 0xFFFF0000
        jz    Loc1
        xor   ecx, ecx
    Loc1:
        mov   eax, ecx
        ret
    }
}

/*++

  Zero the return if ecx > 0xFFFF

--*/

__declspec(naked)
VOID
APIHOOK(VB6_vbaI2I4)()
{
    __asm {
        test  ecx, 0xFFFF0000
        jz    Loc1
        xor   ecx, ecx
    Loc1:
        mov   eax, ecx
        ret
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_NAME(MSVBVM50.DLL, VB5_vbaI2I4, __vbaI2I4)
    APIHOOK_ENTRY_NAME(MSVBVM60.DLL, VB6_vbaI2I4, __vbaI2I4)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignorezeromovewindow.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   IgnoreZeroMoveWindow.cpp

 Abstract:

   This shim changes MoveWindow calls with zero-sized width &
   height parameters to a value of one. NBA Live 99 was failing
   due to an internal check. This implies that WIN9x does not allow
   zero size windows.


 Notes:
    
    This is an app specific for NBA Live 99

 History:

    03/02/2000 a-chcoff   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreZeroMoveWindow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MoveWindow) 
APIHOOK_ENUM_END

/*++

 This function sanitizes 0 size windows by making them have a min height/width of 1.

--*/

BOOL 
APIHOOK(MoveWindow)(
    HWND hWnd,      // handle to window
    int X,          // horizontal position
    int Y,          // vertical position
    int nWidth,     // width
    int nHeight,    // height
    BOOL bRepaint   // repaint option
    )
{   
    if (0 == nWidth) nWidth=1;
    if (0 == nHeight) nHeight=1;

    return ORIGINAL_API(MoveWindow)(
        hWnd, X, Y, nWidth, nHeight, bRepaint);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, MoveWindow)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\injectdll.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    InjectDll.cpp

 Abstract:

    This Shim inject given DLLs on the command line at
    SHIM_STATIC_DLLS_INITIALIZED so that if people try to load
    dynamic library in their own DllInit, no dependencies occur
    because the dynamic libraries are in place.

    One problem was: Visio 2000 call LoadLibrary(VBE6.DLL) which
    (shame on us) loads MSI.DLL in its DllInit.


 History:

    06/11/2001  pierreys    Created
*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(InjectDll)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

APIHOOK_ENUM_END

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    switch (fdwReason)
    {
        case SHIM_STATIC_DLLS_INITIALIZED:

            CSTRING_TRY
            {
                int             i, iDllCount;
                CString         *csArguments;

                CString         csCl(COMMAND_LINE);
                CStringParser   csParser(csCl, L";");

                iDllCount      = csParser.GetCount();
                csArguments    = csParser.ReleaseArgv();

                for (i=0; i<iDllCount; i++)
                {
                    if (LoadLibrary(csArguments[i].Get())==NULL)
                    {
                        LOGN(eDbgLevelError, "Failed to load %S DLL", csArguments[i].Get());

                        return(FALSE);
                    }
                }
            }
            CSTRING_CATCH
            {
                return FALSE;
            }
            break;
    }

    return TRUE;
}



HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\ignoretapidisconnect.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IgnoreTAPIDisconnect.cpp

 Abstract:

    NT4 does not send a disconnect message to the line callback. It's not clear 
    why this is the case. 

    The current behaviour seems to be correct, so this shim simply removes the 
    disconnect message from the queue.

 Notes:

    This is a general purpose shim.

 History:

    05/09/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreTAPIDisconnect)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lineInitialize) 
APIHOOK_ENUM_END

/*++

 Ignore disconnect state.

--*/

VOID FAR PASCAL LineCallback(
    LINECALLBACK pfnOld,
    DWORD hDevice,             
    DWORD dwMsg,               
    DWORD dwCallbackInstance,  
    DWORD dwParam1,            
    DWORD dwParam2,            
    DWORD dwParam3             
    )
{
    if ((dwMsg == LINEAGENTSTATUS_STATE) && (dwParam1 & LINECALLSTATE_DISCONNECTED)) {
        //
        // Ignore disconnect message
        //
        return;
    }

    return (*pfnOld)(hDevice, dwMsg, dwCallbackInstance, dwParam1, dwParam2, dwParam3);    
}

/*++

 Hook the callback.

--*/

LONG 
APIHOOK(lineInitialize)(
    LPHLINEAPP lphLineApp,  
    HINSTANCE hInstance,    
    LINECALLBACK lpfnCallback,  
    LPCSTR lpszAppName,     
    LPDWORD lpdwNumDevs     
    )
{
    return ORIGINAL_API(lineInitialize)(lphLineApp, hInstance, 
        (LINECALLBACK) HookCallback(lpfnCallback, LineCallback),  lpszAppName,
        lpdwNumDevs);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(TAPI32.DLL, lineInitialize)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\keepwindowonmonitor.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    KeepWindowOnMonitor.cpp

 Abstract:

   Do not allow a window to be placed off the Monitor.

 History:

    04/24/2001  robkenny    Created
    09/10/2001  robkenny    Made shim more generic.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(KeepWindowOnMonitor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowPos) 
    APIHOOK_ENUM_ENTRY(MoveWindow) 
    APIHOOK_ENUM_ENTRY(CreateWindowA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
APIHOOK_ENUM_END


/*++

   Are these two RECTs equal
   
--*/

BOOL operator == (const RECT & rc1, const RECT & rc2)
{
    return rc1.left   == rc2.left   &&
           rc1.right  == rc2.right  &&
           rc1.top    == rc2.top    &&
           rc1.bottom == rc2.bottom;
}

/*++

   Are these two RECTs different
   
--*/

BOOL operator != (const RECT & rc1, const RECT & rc2)
{
    return ! (rc1 == rc2);
}

/*++

   Is rcWindow entirely visible on rcMonitor
   
--*/

BOOL EntirelyVisible(const RECT & rcWindow, const RECT & rcMonitor)
{
    return rcWindow.left   >= rcMonitor.left   &&
           rcWindow.right  <= rcMonitor.right  &&
           rcWindow.top    >= rcMonitor.top    &&
           rcWindow.bottom <= rcMonitor.bottom;
}


#define MONITOR_CENTER   0x0001        // center rect to monitor
#define MONITOR_CLIP     0x0000        // clip rect to monitor
#define MONITOR_WORKAREA 0x0002        // use monitor work area
#define MONITOR_AREA     0x0000        // use monitor entire area

//
//  ClipOrCenterRectToMonitor
//
//  The most common problem apps have when running on a
//  multimonitor system is that they "clip" or "pin" windows
//  based on the SM_CXSCREEN and SM_CYSCREEN system metrics.
//  Because of app compatibility reasons these system metrics
//  return the size of the primary monitor.
//
//  This shows how you use the new Win32 multimonitor APIs
//  to do the same thing.
//
BOOL ClipOrCenterRectToMonitor(
    LPRECT prcWindowPos,
    UINT flags)
{
    HMONITOR hMonitor;
    MONITORINFO mi;
    RECT        rcMonitorRect;
    int         w = prcWindowPos->right  - prcWindowPos->left;
    int         h = prcWindowPos->bottom - prcWindowPos->top;

    //
    // get the nearest monitor to the passed rect.
    //
    hMonitor = MonitorFromRect(prcWindowPos, MONITOR_DEFAULTTONEAREST);

    //
    // get the work area or entire monitor rect.
    //
    mi.cbSize = sizeof(mi);
    if ( !GetMonitorInfo(hMonitor, &mi) )
    {
        return FALSE;
    }

    if (flags & MONITOR_WORKAREA)
        rcMonitorRect = mi.rcWork;
    else
        rcMonitorRect = mi.rcMonitor;

    // We only want to move the window if it is not entirely visible.
    if (EntirelyVisible(*prcWindowPos, rcMonitorRect))
    {
        return FALSE;
    }
    //
    // center or clip the passed rect to the monitor rect
    //
    if (flags & MONITOR_CENTER)
    {
        prcWindowPos->left   = rcMonitorRect.left + (rcMonitorRect.right  - rcMonitorRect.left - w) / 2;
        prcWindowPos->top    = rcMonitorRect.top  + (rcMonitorRect.bottom - rcMonitorRect.top  - h) / 2;
        prcWindowPos->right  = prcWindowPos->left + w;
        prcWindowPos->bottom = prcWindowPos->top  + h;
    }
    else
    {
        prcWindowPos->left   = max(rcMonitorRect.left, min(rcMonitorRect.right-w,  prcWindowPos->left));
        prcWindowPos->top    = max(rcMonitorRect.top,  min(rcMonitorRect.bottom-h, prcWindowPos->top));
        prcWindowPos->right  = prcWindowPos->left + w;
        prcWindowPos->bottom = prcWindowPos->top  + h;
    }

    return TRUE;
}

/*++

   If hwnd is not entirely visible on a single monitor,
   move/resize the window as necessary.

--*/

void ClipOrCenterWindowToMonitor(
    HWND hwnd,
    HWND hWndParent,
    UINT flags,
    const char * API)
{
    // We only want to forcibly move top-level windows
    if (hWndParent == NULL || hWndParent == GetDesktopWindow())
    {
        // Grab the current position of the window
        RECT rcWindowPos;
        if ( GetWindowRect(hwnd, &rcWindowPos) )
        {
            RECT rcOrigWindowPos = rcWindowPos;

            // Calculate the new position of the window, based on flags
            if ( ClipOrCenterRectToMonitor(&rcWindowPos, flags) )
            {
                if (rcWindowPos != rcOrigWindowPos)
                {
                    DPFN( eDbgLevelInfo, "[%s] HWnd(0x08x) OrigWindowRect (%d, %d) x (%d, %d) moved to (%d, %d) x (%d, %d)\n",
                          API, hwnd,
                          rcOrigWindowPos.left, rcOrigWindowPos.top, rcOrigWindowPos.right, rcOrigWindowPos.bottom,
                          rcWindowPos.left, rcWindowPos.top, rcWindowPos.right, rcWindowPos.bottom);

                    SetWindowPos(hwnd, NULL, rcWindowPos.left, rcWindowPos.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
                }
            }
        }
    }
}


/*++

   Call SetWindowPos,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

BOOL
APIHOOK(SetWindowPos)(
  HWND hWnd,             // handle to window
  HWND hWndInsertAfter,  // placement-order handle
  int X,                 // horizontal position
  int Y,                 // vertical position
  int cx,                // width
  int cy,                // height
  UINT uFlags            // window-positioning options
)
{
    BOOL bReturn = ORIGINAL_API(SetWindowPos)(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);

    ClipOrCenterWindowToMonitor(hWnd, GetParent(hWnd), MONITOR_CENTER | MONITOR_WORKAREA, "SetWindowPos");

    return bReturn;
}

/*++

   Call MoveWindow,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

BOOL
APIHOOK(MoveWindow)(
  HWND hWnd,      // handle to window
  int X,          // horizontal position
  int Y,          // vertical position
  int nWidth,     // width
  int nHeight,    // height
  BOOL bRepaint   // repaint option
)
{
    BOOL bReturn = ORIGINAL_API(MoveWindow)(hWnd, X, Y, nWidth, nHeight, bRepaint);

    ClipOrCenterWindowToMonitor(hWnd, GetParent(hWnd), MONITOR_CENTER | MONITOR_WORKAREA, "MoveWindow");

    return bReturn;
}

/*++

   Call CreateWindowA,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

HWND
APIHOOK(CreateWindowA)(
  LPCSTR lpClassName,  // registered class name
  LPCSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
)
{
    HWND hWnd = ORIGINAL_API(CreateWindowA)(lpClassName,
                                            lpWindowName,
                                            dwStyle,
                                            x,
                                            y,
                                            nWidth,
                                            nHeight,
                                            hWndParent,
                                            hMenu,
                                            hInstance,
                                            lpParam);

    if (hWnd)
    {
        ClipOrCenterWindowToMonitor(hWnd, hWndParent, MONITOR_CENTER | MONITOR_WORKAREA, "CreateWindowA");
    }

    return hWnd;
}

/*++

   Call CreateWindowExA,
   but if the window is not entirely visible,
   the window will be centered on the nearest monitor.

--*/

HWND
APIHOOK(CreateWindowExA)(
  DWORD dwExStyle,      // extended window style
  LPCSTR lpClassName,  // registered class name
  LPCSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
)
{
    HWND hWnd = ORIGINAL_API(CreateWindowExA)(dwExStyle,
                                              lpClassName,
                                              lpWindowName,
                                              dwStyle,
                                              x,
                                              y,
                                              nWidth,
                                              nHeight,
                                              hWndParent,
                                              hMenu,
                                              hInstance,
                                              lpParam);

    if (hWnd)
    {
        ClipOrCenterWindowToMonitor(hWnd, hWndParent, MONITOR_CENTER | MONITOR_WORKAREA, "CreateWindowExA");
    }

    return hWnd;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowPos)
    APIHOOK_ENTRY(USER32.DLL, MoveWindow)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\lazyreleasedc.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    LazyReleaseDC.cpp

 Abstract:

    Delay releasing a DC by one call.  A DC is not released until the next call to ReleaseDC

 Notes:

    This is a general purpose shim.

 History:
    
    10/10/1999 linstev  Created
    02/05/2002 mnikkel  Changed InitializeCriticalSection to InitializeCriticalSectionAndSpinCount

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LazyReleaseDC)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ReleaseDC) 
APIHOOK_ENUM_END

HWND                g_hWndPrev;
HDC                 g_hDcPrev;
CRITICAL_SECTION    g_MakeThreadSafe;

/*++

 Save this hWnd and hdc for releasing later. If there is already a DC to be 
 released, release it now.

--*/

int 
APIHOOK(ReleaseDC)(
    HWND hWnd, 
    HDC hdc
    )
{
    UINT uRet = 1; // All's well

    EnterCriticalSection(&g_MakeThreadSafe);

    // If there is a previous DC, release it now
    if (g_hDcPrev) {
        uRet = ORIGINAL_API(ReleaseDC)(g_hWndPrev, g_hDcPrev);
    }

    g_hWndPrev = hWnd;
    g_hDcPrev = hdc;

    LeaveCriticalSection(&g_MakeThreadSafe);

    return uRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hWndPrev = 0;
        g_hDcPrev = 0;

        return InitializeCriticalSectionAndSpinCount(&g_MakeThreadSafe,0x80000000);
    }

    // Ignore Detach code
    /*
    else if (fdwReason == DLL_PROCESS_DETACH) {
        DeleteCriticalSection(&g_MakeThreadSafe);
    }
    */

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, ReleaseDC)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\loadcomctl32version5.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    e.cpp

 Abstract:

    This DLL Hooks CreateWindow, DialogBox, and CreateDialog routines in order to
    ensure that Comctl32 version 5 is loaded.

 Notes:
    
    This is a general purpose shim.

 History:

    05/25/2000 lamadio  Added initial shims to ensure that comctl32 version 6 
                        is loaded.

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(LoadComctl32Version5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExW) 
    APIHOOK_ENUM_ENTRY(DialogBoxParamA) 
    APIHOOK_ENUM_ENTRY(DialogBoxParamW) 
    APIHOOK_ENUM_ENTRY(DialogBoxIndirectParamA) 
    APIHOOK_ENUM_ENTRY(DialogBoxIndirectParamW) 
    APIHOOK_ENUM_ENTRY(CreateDialogParamA) 
    APIHOOK_ENUM_ENTRY(CreateDialogParamW) 
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW) 
APIHOOK_ENUM_END

BOOL g_fComctl32V5Loaded = FALSE;

typedef BOOL  (__stdcall *PFNInitCommonControlsEx)(LPINITCOMMONCONTROLSEX);
void EnsureComctl32Version5IsLoaded()
{

    if (g_fComctl32V5Loaded == FALSE) {
        HMODULE hMod = GetModuleHandle(TEXT("Comctl32.dll"));
        if (hMod == NULL) {
            hMod = LoadLibrary(TEXT("Comctl32.dll"));
            if (hMod) {
                PFNInitCommonControlsEx pfn = (PFNInitCommonControlsEx)GetProcAddress(hMod, "InitCommonControlsEx");
                if (pfn) {
                    INITCOMMONCONTROLSEX icc;
                    icc.dwSize = sizeof(icc);
                    icc.dwICC = 0x00003FFF;     // Initialize all classes.

                    pfn(&icc);
                }
            }
        }

        g_fComctl32V5Loaded = TRUE;      // Well, we tried. If we failed, we shouldn't try more than once.
    }
}



HWND APIHOOK(CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle,  int X, int Y, 
                             int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateWindowExA)(dwExStyle, lpClassName, lpWindowName, dwStyle,  X, Y, 
                             nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}
HWND APIHOOK(CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle,  int X, int Y, 
                             int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateWindowExW)(dwExStyle, lpClassName, lpWindowName, dwStyle,  X, Y, 
                             nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

INT_PTR APIHOOK(DialogBoxParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxParamA)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

INT_PTR APIHOOK(DialogBoxParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxParamW)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

INT_PTR APIHOOK(DialogBoxIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxIndirectParamA)(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

INT_PTR APIHOOK(DialogBoxIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(DialogBoxIndirectParamW)(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogParamA)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogParamW)(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogIndirectParamA)(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

HWND APIHOOK(CreateDialogIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    EnsureComctl32Version5IsLoaded();
    return ORIGINAL_API(CreateDialogIndirectParamW)(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxParamA)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxParamW)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxIndirectParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:


 Notes:

 History:

    15/11/2000 clupu Created
    11/30/2000 a-brienw modified for beginning of misc shim

--*/

#include "precomp.h"
#include "ShimHookMacro.h"

DECLARE_SHIM(AddProcessParametersFlags)
DECLARE_SHIM(AliasDXDC)
DECLARE_SHIM(CorrectACMArgs)
DECLARE_SHIM(CorrectACMStreamOpen)
DECLARE_SHIM(CorrectActiveMoviePath)
DECLARE_SHIM(CorrectCreateIcon)
DECLARE_SHIM(CorrectCreateSurface)
DECLARE_SHIM(CorrectFarEastFont)
DECLARE_SHIM(CorrectFilePathInSetDlgItemText)
DECLARE_SHIM(CorrectFilePathsUninstall)
DECLARE_SHIM(CorrectOpenFileExclusive)
DECLARE_SHIM(CorrectVerInstallFile)
DECLARE_SHIM(CUASAppFix)
DECLARE_SHIM(CUASDisableCicero)
DECLARE_SHIM(DelayDllInit)
DECLARE_SHIM(DelayShowGroup)
DECLARE_SHIM(DelayWin95VersionLie)
DECLARE_SHIM(DelayWinMMCallback)
DECLARE_SHIM(DeleteSpecifiedFiles)
DECLARE_SHIM(DeRandomizeExeName)
DECLARE_SHIM(DisableBoostThread)
DECLARE_SHIM(DisableFilterKeys)
DECLARE_SHIM(DisableScreenSaver)
DECLARE_SHIM(DisableStickyKeys)

#ifndef SHIM_WIN2K
DECLARE_SHIM(DisableThemes)
#endif // SHIM_WIN2K

DECLARE_SHIM(DisableW2KOwnerDrawButtonStates)
DECLARE_SHIM(EmptyClipboardtoSet)
DECLARE_SHIM(EmulateGetStdHandle)
DECLARE_SHIM(EmulateGetStringType)
DECLARE_SHIM(EmulateGetUIEffects)
DECLARE_SHIM(EmulateLZHandles)
DECLARE_SHIM(EnlargeGetObjectBufferSize)
DECLARE_SHIM(ExtractAssociatedIcon)
DECLARE_SHIM(FailCloseProfileUserMapping)
DECLARE_SHIM(FailGetStdHandle)
DECLARE_SHIM(FailObsoleteShellAPIs)
DECLARE_SHIM(FailOpenFile)
DECLARE_SHIM(FakeThemeMetrics)
DECLARE_SHIM(FilterNetworkResources)
DECLARE_SHIM(FixServiceStartupCircularDependency)
DECLARE_SHIM(Force640x480x8)
DECLARE_SHIM(Force640x480x16)
DECLARE_SHIM(ForceAdminAccess)
DECLARE_SHIM(ForceAnsiWindowProc)
DECLARE_SHIM(ForceAppendMenuSuccess)
DECLARE_SHIM(ForceApplicationFocus)
DECLARE_SHIM(ForceAVIWindow)
DECLARE_SHIM(ForceDefaultSystemPaletteEntries)
DECLARE_SHIM(ForceDirectDrawEmulation)
DECLARE_SHIM(ForceDirectDrawWait)
DECLARE_SHIM(ForceDisplayMode)
DECLARE_SHIM(ForceSeparateVDM)
DECLARE_SHIM(ForceSimpleWindow)
DECLARE_SHIM(ForceTemporaryModeChange)
DECLARE_SHIM(ForceWorkingDirectoryToEXEPath)
DECLARE_SHIM(FUSBadApplicationType1)
DECLARE_SHIM(FUSBadApplicationType2)
DECLARE_SHIM(FUSBadApplicationType3)
DECLARE_SHIM(FUSBadApplicationType4)
DECLARE_SHIM(GetVolumeInformationLie)
DECLARE_SHIM(GlobalMemoryStatusLie)
DECLARE_SHIM(GlobalMemoryStatusTrim)
DECLARE_SHIM(HandleDBCSUserName)
DECLARE_SHIM(HandleDBCSUserName2)
DECLARE_SHIM(HandleEmptyAccessCheck)
DECLARE_SHIM(HeapClearAllocation)
DECLARE_SHIM(HeapDelayLocalFree)
DECLARE_SHIM(HeapForceGrowable)
DECLARE_SHIM(HeapIgnoreMoveable)
DECLARE_SHIM(HeapLookasideFree)
DECLARE_SHIM(HeapPadAllocation)
DECLARE_SHIM(HeapValidateFrees)
DECLARE_SHIM(HideCursor)
DECLARE_SHIM(HideTaskBar)
DECLARE_SHIM(IEUnHarden)
DECLARE_SHIM(IgnoreAltTab)
DECLARE_SHIM(IgnoreCoCreateInstance)
DECLARE_SHIM(IgnoreCRTExit)
DECLARE_SHIM(IgnoreDebugOutput)
DECLARE_SHIM(IgnoreFreeLibrary)
DECLARE_SHIM(IgnoreHungAppPaint)
DECLARE_SHIM(IgnoreMCIStop)
DECLARE_SHIM(IgnoreMessageBox)
DECLARE_SHIM(IgnoreNoModeChange)
DECLARE_SHIM(IgnoreOemToChar)
DECLARE_SHIM(IgnoreSysColChanges)
DECLARE_SHIM(IgnoreTAPIDisconnect)
DECLARE_SHIM(IgnoreVBOverflow)
DECLARE_SHIM(IgnoreZeroMoveWindow)
DECLARE_SHIM(InjectDll)
DECLARE_SHIM(KeepWindowOnMonitor)
DECLARE_SHIM(LazyReleaseDC)
DECLARE_SHIM(LimitFindFile)
DECLARE_SHIM(LoadComctl32Version5)
DECLARE_SHIM(LoadLibraryCWD)
DECLARE_SHIM(LowerThreadPriority)
DECLARE_SHIM(MoveIniToRegistry)
DECLARE_SHIM(MoveWinInitRenameToReg)
DECLARE_SHIM(NullHwndInMessageBox)
DECLARE_SHIM(PaletteRestore)
DECLARE_SHIM(PopulateDefaultHKCUSettings)
DECLARE_SHIM(PropagateProcessHistory)
DECLARE_SHIM(RecopyExeFromCD)
DECLARE_SHIM(RedirectDBCSTempPath)
DECLARE_SHIM(RedirectEXE)
DECLARE_SHIM(RedirectWindowsDirToSystem32)
DECLARE_SHIM(RemoveBroadcastPostMessage)
DECLARE_SHIM(RemoveDDEFlagFromShellExecuteEx)
DECLARE_SHIM(RemoveInvalidW2KWindowStyles)
DECLARE_SHIM(RemoveIpFromMsInfoCommandLine)
DECLARE_SHIM(RemoveNoBufferingFlagFromCreateFile)
DECLARE_SHIM(RemoveOverlappedFlagFromCreateFile)
DECLARE_SHIM(RemoveReadOnlyAttribute)
DECLARE_SHIM(RestoreSystemCursors)
DECLARE_SHIM(SearchPathInAppPaths)
DECLARE_SHIM(SetEnvironmentVariable)
DECLARE_SHIM(StackSwap)
DECLARE_SHIM(TerminateExe)
DECLARE_SHIM(TrimVersionInfo)
DECLARE_SHIM(UnMirrorImageList)
DECLARE_SHIM(WaveOutUsePreferredDevice)
DECLARE_SHIM(WinG32SysToSys32)


VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcGenral", eDbgLevelSpew, "General Purpose Shims initialized.");
            break;

        case DLL_PROCESS_DETACH:
            DPF("AcGenral", eDbgLevelSpew, "General Purpose Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()

    MULTISHIM_ENTRY(AddProcessParametersFlags)
    MULTISHIM_ENTRY(AliasDXDC)
    MULTISHIM_ENTRY(CorrectACMArgs)
    MULTISHIM_ENTRY(CorrectACMStreamOpen)
    MULTISHIM_ENTRY(CorrectActiveMoviePath)
    MULTISHIM_ENTRY(CorrectCreateIcon)
    MULTISHIM_ENTRY(CorrectCreateSurface)
    MULTISHIM_ENTRY(CorrectFarEastFont)
    MULTISHIM_ENTRY(CorrectFilePathInSetDlgItemText)
    MULTISHIM_ENTRY(CorrectFilePathsUninstall)
    MULTISHIM_ENTRY(CorrectOpenFileExclusive)
    MULTISHIM_ENTRY(CorrectVerInstallFile)
    MULTISHIM_ENTRY(CUASAppFix)
    MULTISHIM_ENTRY(CUASDisableCicero)
    MULTISHIM_ENTRY(DelayDllInit)
    MULTISHIM_ENTRY(DelayShowGroup)
    MULTISHIM_ENTRY(DelayWin95VersionLie)
    MULTISHIM_ENTRY(DelayWinMMCallback)
    MULTISHIM_ENTRY(DeleteSpecifiedFiles)
    MULTISHIM_ENTRY(DeRandomizeExeName)
    MULTISHIM_ENTRY(DisableBoostThread)
    MULTISHIM_ENTRY(DisableFilterKeys)
    MULTISHIM_ENTRY(DisableScreenSaver)
    MULTISHIM_ENTRY(DisableStickyKeys)

#ifndef SHIM_WIN2K
    MULTISHIM_ENTRY(DisableThemes)
#endif // SHIM_WIN2K

    MULTISHIM_ENTRY(DisableW2KOwnerDrawButtonStates)
    MULTISHIM_ENTRY(EmptyClipboardtoSet)
    MULTISHIM_ENTRY(EmulateGetStdHandle)
    MULTISHIM_ENTRY(EmulateGetStringType)
    MULTISHIM_ENTRY(EmulateGetUIEffects)
    MULTISHIM_ENTRY(EmulateLZHandles)
    MULTISHIM_ENTRY(EnlargeGetObjectBufferSize)
    MULTISHIM_ENTRY(ExtractAssociatedIcon)
    MULTISHIM_ENTRY(FailCloseProfileUserMapping)
    MULTISHIM_ENTRY(FailGetStdHandle)
    MULTISHIM_ENTRY(FailObsoleteShellAPIs)
    MULTISHIM_ENTRY(FailOpenFile)
    MULTISHIM_ENTRY(FakeThemeMetrics)
    MULTISHIM_ENTRY(FilterNetworkResources)
    MULTISHIM_ENTRY(FixServiceStartupCircularDependency)
    MULTISHIM_ENTRY(Force640x480x8)
    MULTISHIM_ENTRY(Force640x480x16)
    MULTISHIM_ENTRY(ForceAdminAccess)
    MULTISHIM_ENTRY(ForceAnsiWindowProc)
    MULTISHIM_ENTRY(ForceAppendMenuSuccess)
    MULTISHIM_ENTRY(ForceApplicationFocus)
    MULTISHIM_ENTRY(ForceAVIWindow)
    MULTISHIM_ENTRY(ForceDefaultSystemPaletteEntries)
    MULTISHIM_ENTRY(ForceDirectDrawEmulation)
    MULTISHIM_ENTRY(ForceDirectDrawWait)
    MULTISHIM_ENTRY(ForceDisplayMode)
    MULTISHIM_ENTRY(ForceSeparateVDM)
    MULTISHIM_ENTRY(ForceSimpleWindow)
    MULTISHIM_ENTRY(ForceTemporaryModeChange)
    MULTISHIM_ENTRY(ForceWorkingDirectoryToEXEPath)
    MULTISHIM_ENTRY(FUSBadApplicationType1)
    MULTISHIM_ENTRY(FUSBadApplicationType2)
    MULTISHIM_ENTRY(FUSBadApplicationType3)
    MULTISHIM_ENTRY(FUSBadApplicationType4)
    MULTISHIM_ENTRY(GetVolumeInformationLie)
    MULTISHIM_ENTRY(GlobalMemoryStatusLie)
    MULTISHIM_ENTRY(GlobalMemoryStatusTrim)
    MULTISHIM_ENTRY(HandleDBCSUserName)
    MULTISHIM_ENTRY(HandleDBCSUserName2)
    MULTISHIM_ENTRY(HandleEmptyAccessCheck)
    MULTISHIM_ENTRY(HeapClearAllocation)
    MULTISHIM_ENTRY(HeapDelayLocalFree)
    MULTISHIM_ENTRY(HeapForceGrowable)
    MULTISHIM_ENTRY(HeapIgnoreMoveable)
    MULTISHIM_ENTRY(HeapLookasideFree)
    MULTISHIM_ENTRY(HeapPadAllocation)
    MULTISHIM_ENTRY(HeapValidateFrees)
    MULTISHIM_ENTRY(HideCursor)
    MULTISHIM_ENTRY(HideTaskBar)
    MULTISHIM_ENTRY(IEUnHarden)
    MULTISHIM_ENTRY(IgnoreAltTab)
    MULTISHIM_ENTRY(IgnoreCoCreateInstance)
    MULTISHIM_ENTRY(IgnoreCRTExit)
    MULTISHIM_ENTRY(IgnoreDebugOutput)
    MULTISHIM_ENTRY(IgnoreFreeLibrary)
    MULTISHIM_ENTRY(IgnoreHungAppPaint)
    MULTISHIM_ENTRY(IgnoreMCIStop)
    MULTISHIM_ENTRY(IgnoreMessageBox)
    MULTISHIM_ENTRY(IgnoreNoModeChange)
    MULTISHIM_ENTRY(IgnoreOemToChar)
    MULTISHIM_ENTRY(IgnoreSysColChanges)
    MULTISHIM_ENTRY(IgnoreTAPIDisconnect)
    MULTISHIM_ENTRY(IgnoreVBOverflow)
    MULTISHIM_ENTRY(IgnoreZeroMoveWindow)
    MULTISHIM_ENTRY(InjectDll)
    MULTISHIM_ENTRY(KeepWindowOnMonitor)
    MULTISHIM_ENTRY(LazyReleaseDC)
    MULTISHIM_ENTRY(LimitFindFile)
    MULTISHIM_ENTRY(LoadComctl32Version5)
    MULTISHIM_ENTRY(LoadLibraryCWD)
    MULTISHIM_ENTRY(LowerThreadPriority)
    MULTISHIM_ENTRY(MoveIniToRegistry)
    MULTISHIM_ENTRY(MoveWinInitRenameToReg)
    MULTISHIM_ENTRY(NullHwndInMessageBox)
    MULTISHIM_ENTRY(PaletteRestore)
    MULTISHIM_ENTRY(PopulateDefaultHKCUSettings)
    MULTISHIM_ENTRY(PropagateProcessHistory)
    MULTISHIM_ENTRY(RecopyExeFromCD)
    MULTISHIM_ENTRY(RedirectDBCSTempPath)
    MULTISHIM_ENTRY(RedirectEXE)
    MULTISHIM_ENTRY(RedirectWindowsDirToSystem32)
    MULTISHIM_ENTRY(RemoveBroadcastPostMessage)
    MULTISHIM_ENTRY(RemoveDDEFlagFromShellExecuteEx)
    MULTISHIM_ENTRY(RemoveInvalidW2KWindowStyles)
    MULTISHIM_ENTRY(RemoveIpFromMsInfoCommandLine)
    MULTISHIM_ENTRY(RemoveNoBufferingFlagFromCreateFile)
    MULTISHIM_ENTRY(RemoveOverlappedFlagFromCreateFile)
    MULTISHIM_ENTRY(RemoveReadOnlyAttribute)
    MULTISHIM_ENTRY(RestoreSystemCursors)
    MULTISHIM_ENTRY(SearchPathInAppPaths)
    MULTISHIM_ENTRY(SetEnvironmentVariable)
    MULTISHIM_ENTRY(StackSwap)
    MULTISHIM_ENTRY(TerminateExe)
    MULTISHIM_ENTRY(TrimVersionInfo)
    MULTISHIM_ENTRY(UnMirrorImageList)
    MULTISHIM_ENTRY(WaveOutUsePreferredDevice)
    MULTISHIM_ENTRY(WinG32SysToSys32)

    CALL_MULTISHIM_NOTIFY_FUNCTION()

MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\limitfindfile.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    LimitFindFile.cpp

 Abstract:

    This shim was originally intended for QuickTime's qt32inst.exe which
    did a breadth-first search of the directory tree and would overflow 
    the buffer in which it was keeping a list of subdirs yet to visit.

    With this shim you can limit the number of files that a single FindFile
    search will return, you can limit the number of subdirectories (aka the
    branching factor) returned, you can limit the "depth" to which any
    FindFile search will locate files, and you can specify whether these 
    limits should be applied to all FindFiles or only fully-qualified FindFiles.
    You can also request that FindFile return only short filenames.

    The shim's arguments are:
    DEPTH=#
    BRANCH=#
    FILES=#
    SHORTFILENAMES or LONGFILENAMES
    LIMITRELATIVE or ALLOWRELATIVE

    The default behavior is:
    SHORTFILENAMES
    DEPTH = 4
    ALLOWRELATIVE
    ... but if any command line is specified, the behavior is only that which
        is specified on the command line (no default behavior).

    An example command line:
    COMMAND_LINE="FILES=100 LIMITRELATIVE"
    Which would limit every FindFile search to returning 100 or fewer files (but
    still returning any and all subdirectories).

    Note: Depth is a bit tricky.  The method used is to count backslashes, so
    limiting depth to zero will allow no files to be found ("C:\autorun.bat" has
    1 backslash).

 History:

    08/24/2000 t-adams    Created
    03/14/2002 mnikkel    Changed InitializeCriticalSection to InitializeCriticalSectionAndSpinCount
                          changed to use strsafe.h
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LimitFindFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA) 
    APIHOOK_ENUM_ENTRY(FindNextFileA) 
    APIHOOK_ENUM_ENTRY(FindClose) 
APIHOOK_ENUM_END

// Linked list of FindFileHandles
struct FFNode
{
    FFNode  *next;
    HANDLE  hFF;
    DWORD   dwBranches;
    DWORD   dwFiles;
};
FFNode *g_FFList = NULL;

// Default behaviors - overridden by Commandline
BOOL  g_bUseShortNames = TRUE;
BOOL  g_bLimitDepth    = TRUE;
DWORD g_dwDepthLimit   = 4;
BOOL  g_bLimitRelative = FALSE;
BOOL  g_bLimitBranch   = FALSE;
DWORD g_dwBranchLimit  = 0;
BOOL  g_bLimitFiles    = FALSE;
DWORD g_dwFileLimit    = 0;

CRITICAL_SECTION    g_MakeThreadSafe;


/*++

  Abstract:
    ApplyLimits applys the recently found file from lpFindFileData to the
    current node, checks that none of the limits have been violated, and
    shortens the filename if requested.

    It returns TRUE if within limits, FALSE if limits have been exceeded.
  History:

  08/24/2000    t-adams     Created

--*/
BOOL ApplyLimits(FFNode *pFFNode, LPWIN32_FIND_DATAA lpFindFileData)
{
    BOOL bRet = TRUE;

    // If it's a directory
    if ( lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    {
        pFFNode->dwBranches++;
        if ( g_bLimitBranch && pFFNode->dwBranches > g_dwBranchLimit )
        {
            bRet = FALSE;
            goto exit;
        }
    }
    else
    { // else it's a file
        pFFNode->dwFiles++;
        if ( g_bLimitFiles && pFFNode->dwFiles > g_dwFileLimit )
        {
            bRet = FALSE;
            goto exit;
        }
    }

    // Change to short name if requested
    if ( g_bUseShortNames && NULL != lpFindFileData->cAlternateFileName[0])
    {
        if (S_OK != StringCchCopyA(lpFindFileData->cFileName,
                                   ARRAYSIZE(lpFindFileData->cFileName),
                                   lpFindFileData->cAlternateFileName))
            bRet = FALSE;
    }

exit:
    return bRet;
}


/*++

  Abstract:
    CheckDepthLimit checks to see if the depth of the requested search
    is greater than is allowed.  If we are limiting relative paths, then
    the current directory is prepended to the requested search string.

    It returns TRUE if within limits, FALSE if limits have been exceeded.
  History:

  08/24/2000    t-adams     Created

--*/
BOOL
CheckDepthLimit(const CString & csFileName)
{
    BOOL   bRet = TRUE;

    CSTRING_TRY
    {
        // Check the depth of the requested file
        if ( g_bLimitDepth )
        {
            DWORD dwDepth = 0;
            int   nIndex = 0;

            for(; nIndex >= 0; dwDepth++)
            {
                nIndex = csFileName.Find(L'\\', nIndex);
            }
   
            if ( dwDepth > g_dwDepthLimit )
            {
                bRet = FALSE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return bRet;
}


/*++

  Abstract:
    This function checks the depth of the requested search (see comments above).
    If the depth check passes it performs the search, request limit application,
    and finally returns a successful handle only if within all limits.

  History:

  08/24/2000    t-adams     Created

--*/
HANDLE 
APIHOOK(FindFirstFileA)(
            LPCSTR lpFileName,
            LPWIN32_FIND_DATAA lpFindFileData)
{
    HANDLE hRet       = INVALID_HANDLE_VALUE;
    FFNode *pFFNode   = NULL;
    BOOL   bRelPath   = FALSE;

    CString csFileName(lpFileName);
    
    // Determine if the path is relative to the CWD:
    CString csDrive;
    csFileName.GetDrivePortion(csDrive);
    bRelPath = csDrive.IsEmpty();

    // If it is a relative path & we're not limiting such, then just do
    // the FindFile and get out.
    if ( bRelPath)
    {
        if (!g_bLimitRelative)
        {
            return ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
        }

        // We need to expand the directory portion of lpFileName to its full path
        CString csPath;
        CString csFile;

        csFileName.GetNotLastPathComponent(csPath);
        csFileName.GetLastPathComponent(csFile);

        csPath.GetFullPathNameW();
        csPath.AppendPath(csFile);

        csFileName = csPath;

        // Check the depth limit
        if ( !CheckDepthLimit(csFileName) )
        {
            return INVALID_HANDLE_VALUE;
        }
    }

    hRet = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
    if ( INVALID_HANDLE_VALUE == hRet )
    {
        return hRet;
    }

    EnterCriticalSection(&g_MakeThreadSafe);

    // Make a new node for this handle
    pFFNode = (FFNode *) malloc(sizeof FFNode);
    if ( !pFFNode )
    {
        // Don't close the find, maybe it could still work for the app.
        goto exit;
    }
    pFFNode->hFF = hRet;
    pFFNode->dwBranches = 0;
    pFFNode->dwFiles = 0;

    // Apply our limits until we get a passable find
    while( !ApplyLimits(pFFNode, lpFindFileData) )
    {
        // If there are no more files to find, clean up & exit
        //   else loop back & ApplyLimits again
        if ( !FindNextFileA(hRet, lpFindFileData) )
        {
            free(pFFNode);
            FindClose(hRet);
            hRet = INVALID_HANDLE_VALUE;
            goto exit;
        }
    }

    // We are clear to add this node to the global list
    pFFNode->next = g_FFList;
    g_FFList = pFFNode;

    LeaveCriticalSection(&g_MakeThreadSafe);

exit:
    return hRet;
}


/*++

  Abstract:
    This function continues a limited search given the search's handle.
    
  History:

  08/24/2000    t-adams     Created

--*/

BOOL
FindNextFileAInternal(
            HANDLE hFindFile, 
            LPWIN32_FIND_DATAA lpFindFileData)
{
    FFNode *pFFNode = NULL;
    BOOL bRet = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

    if ( !bRet )
    {
        goto exit;
    }

    // Find our node in the global list
    pFFNode = g_FFList;
    while( pFFNode )
    {
        if ( pFFNode->hFF == hFindFile )
        {
            break;
        }
        pFFNode = pFFNode->next;
    }

    // We don't keep track of relative-path searches if we're not
    // limiting such.
    if ( pFFNode == NULL )
    {
        goto exit;
    }

    // Apply our limits until we get a passable find
    while( !ApplyLimits(pFFNode, lpFindFileData) )
    {
        // If there are no more files to find return FALSE
        //   else loop back & ApplyLimits again
        if ( !FindNextFileAInternal(hFindFile, lpFindFileData) )
        {
            bRet = FALSE;
            goto exit;
        }
    }

exit:
    return bRet;
}

BOOL 
APIHOOK(FindNextFileA)(
            HANDLE hFindFile, 
            LPWIN32_FIND_DATAA lpFindFileData)
{
    // FindNextFileAInternal is called seperately since it may recurse
    EnterCriticalSection(&g_MakeThreadSafe);

    BOOL bRet = FindNextFileAInternal(hFindFile, lpFindFileData);

    LeaveCriticalSection(&g_MakeThreadSafe);

    return bRet;
}


/*++

  Abstract:
    This function closes a search, cleaning up the structures used
    in keeping track of the limits.

  History:

  08/24/2000    t-adams     Created

--*/
BOOL 
APIHOOK(FindClose)(
            HANDLE hFindFile)
{

    FFNode *pFFNode, *prev;

    BOOL bRet = ORIGINAL_API(FindClose)(hFindFile);

    EnterCriticalSection(&g_MakeThreadSafe);

    // Find the node that matches the handle
    pFFNode = g_FFList;
    prev = NULL;
    while( pFFNode )
    {
        if ( pFFNode->hFF == hFindFile )
        {
            // Remove this node from this list
            if ( prev )
            {
                prev->next = pFFNode->next;
            }
            else
            {
                g_FFList = pFFNode->next;
            }

            free(pFFNode);
            pFFNode = NULL;
            break;
        }
        prev = pFFNode;
        pFFNode = pFFNode->next;
    }

    LeaveCriticalSection(&g_MakeThreadSafe);

    return bRet;
}


/*++

  Abstract:
    This function parses the command line.
    See the top of the file for valid arguments.

  History:

  08/24/2000    t-adams     Created

--*/

VOID 
ParseCommandLine( LPCSTR lpCommandLine )
{
    // If there is a command line, reset the default behavior
    if (*lpCommandLine != 0)
    {
        g_bLimitDepth = FALSE;
        g_bLimitBranch = FALSE;
        g_bLimitFiles = FALSE;
        g_bUseShortNames = FALSE;
    }

    CSTRING_TRY
    {
        CStringToken csCommandLine(COMMAND_LINE, L" ,\t;:=");
        CString csOperator;

        // Parse the command line
        DWORD *pdwValue = NULL;

        while (csCommandLine.GetToken(csOperator))
        {
            if (csOperator.IsEmpty())
            {
                goto Exit;
            }

            // If we're looking for a value
            if ( pdwValue )
            {
                *pdwValue = atol(csOperator.GetAnsi());
                pdwValue = NULL;
            }
            else
            { // We're expecting a keyword
                if ( csOperator.CompareNoCase(L"DEPTH") == 0 )
                {
                    g_bLimitDepth = TRUE;
                    pdwValue = &g_dwDepthLimit;
                }
                else if ( csOperator.CompareNoCase(L"BRANCH") == 0 )
                {
                    g_bLimitBranch = TRUE;
                    pdwValue = &g_dwBranchLimit;
                }
                else if ( csOperator.CompareNoCase(L"FILES") == 0 )
                {
                    g_bLimitFiles = TRUE;
                    pdwValue = &g_dwFileLimit;
                }
                else if ( csOperator.CompareNoCase(L"SHORTFILENAMES") == 0)
                {
                    g_bUseShortNames = TRUE;
                    // Don't need a value here
                }
                else if ( csOperator.CompareNoCase(L"LONGFILENAMES") == 0)
                {
                    g_bUseShortNames = FALSE;
                    // Don't need a value here
                }
                else if ( csOperator.CompareNoCase(L"LIMITRELATIVE") == 0)
                {
                    g_bLimitRelative = TRUE;
                    // Don't need a value here
                }
                else if ( csOperator.CompareNoCase(L"ALLOWRELATIVE") == 0)
                {
                    g_bLimitRelative = FALSE;
                    // Don't need a value here
                }
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

Exit:
    //
    // Dump results of command line parse
    //

    DPFN( eDbgLevelInfo, "===================================\n");
    DPFN( eDbgLevelInfo, "          Limit FindFile           \n");
    DPFN( eDbgLevelInfo, "===================================\n");
    if ( g_bLimitDepth )
    {
        DPFN( eDbgLevelInfo, " Depth  = %d\n", g_dwDepthLimit);
    }
    if ( g_bLimitBranch )
    {
        DPFN( eDbgLevelInfo, " Branch = %d\n", g_dwBranchLimit);
    }
    if ( g_bLimitFiles )
    {
        DPFN( eDbgLevelInfo, " Files  = %d\n", g_dwFileLimit);
    }
    if ( g_bLimitRelative )
    {
        DPFN( eDbgLevelInfo, " Limiting Relative Paths.\n");
    }
    else
    {
        DPFN( eDbgLevelInfo, " Not Limiting Relative Paths.\n");
    }
    if ( g_bUseShortNames )
    {
        DPFN( eDbgLevelInfo, " Using short file names.\n");
    }

    DPFN( eDbgLevelInfo, "-----------------------------------\n");
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ParseCommandLine(COMMAND_LINE);

        return InitializeCriticalSectionAndSpinCount(&g_MakeThreadSafe,0x80000000);
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindClose)
    CALL_NOTIFY_FUNCTION

HOOK_END



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\lowerthreadpriority.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LowerThreadPriority.cpp

 Abstract:

    Includes the following hooks:
    
    SetThreadPriority: if the thread priority is THREAD_PRIORITY_TIME_CRITICAL, 
                       change it to THREAD_PRIORITY_HIGHEST.
    
    SetPriorityClass: if the process priority is HIGH_PRIORITY_CLASS or 
                      REALTIME_PRIORITY_CLASS, change it to 
                      NORMAL_PRIORITY_CLASS. 
    
 Notes:
    
    This is a general purpose shim.
   
 History:

    05/23/2001  qzheng      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LowerThreadPriority)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetThreadPriority) 
    APIHOOK_ENUM_ENTRY(SetPriorityClass) 
APIHOOK_ENUM_END

BOOL
APIHOOK(SetThreadPriority)(
    HANDLE hThread,
    int nPriority
    )
{
    BOOL bReturnValue;
    int  nNewPriority;

    LOGN( eDbgLevelInfo,
        "Original SetThreadPriority(hThread: 0x%08lx, nPriority: %d).", hThread, nPriority );
    
	nNewPriority = (nPriority == THREAD_PRIORITY_TIME_CRITICAL) ? THREAD_PRIORITY_HIGHEST : nPriority;
    bReturnValue = ORIGINAL_API(SetThreadPriority)(hThread, nNewPriority);

	if( bReturnValue && (nNewPriority != nPriority) ) {
        LOGN( eDbgLevelInfo,
            "New SetThreadPriority(hThread: 0x%08lx, nPriority: %d).", hThread, nNewPriority );
    }

    return bReturnValue;
}

BOOL
APIHOOK(SetPriorityClass)(
    HANDLE hProcess,
    DWORD  dwPriorityClass
    )
{
    BOOL  bReturnValue;
    DWORD dwNewPriorityClass;

    LOGN( eDbgLevelInfo,
        "Original SetPriorityClass(hProcess: 0x%08lx, dwPriorityClass: %d).", hProcess, dwPriorityClass );
    
	dwNewPriorityClass = ( (dwPriorityClass == HIGH_PRIORITY_CLASS) || (dwPriorityClass == REALTIME_PRIORITY_CLASS) ) ? 
	                     NORMAL_PRIORITY_CLASS : dwPriorityClass;
    bReturnValue = ORIGINAL_API(SetPriorityClass)(hProcess, dwNewPriorityClass);

	if( bReturnValue && (dwNewPriorityClass != dwPriorityClass) ) {
	    LOGN( eDbgLevelInfo,
             "New SetPriorityClass (hProcess: 0x%08lx, dwPriorityClass: %d).", hProcess, dwNewPriorityClass );
    }

    return bReturnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, SetThreadPriority)
    APIHOOK_ENTRY(KERNEL32.DLL, SetPriorityClass)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\loadlibrarycwd.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    LoadLibraryCWD.cpp

 Abstract:

    Some applications rely on the fact that LoadLibrary will search the current
    working directory (CWD) in-order to find dlls that are there.  This is a
    security hole, so we apply shims to only the apps that really need it.
    
 Notes:
    
    This is a general purpose shim.

 History:

    05/01/2002 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LoadLibraryCWD)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

typedef BOOL (WINAPI *_pfn_SetDllDirectoryW)(LPCWSTR lpPathName);

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        HMODULE hMod = GetModuleHandleW(L"KERNEL32.DLL");

        if (hMod) {

            // Get the API
            _pfn_SetDllDirectoryW pfn = (_pfn_SetDllDirectoryW)
                GetProcAddress(hMod, "SetDllDirectoryW");

            if (pfn) {
                // Success, the API exists
                LOGN(eDbgLevelError, "DLL search order now starts with current directory");
                pfn(L".");
                return TRUE;
            }
        }

        LOGN(eDbgLevelError, "ERROR: DLL search order API does not exist");
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\precomp.h ===
#ifndef _GPSHIMS_PRECOMP_H_
#define _GPSHIMS_PRECOMP_H_

#include "ShimHook.h"
#include "StrSafe.h"

using namespace ShimLib;


#endif // _GPSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\nullhwndinmessagebox.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NullHwndInMessageBox.cpp

 Abstract:

    This shim replaces "non window" handles in msgbox with NULL to tell it 
    that desktop is owner.

 Notes:

    This is a general purpose shim.

 History:

    12/08/1999 a-jamd   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NullHwndInMessageBox)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA)
    APIHOOK_ENUM_ENTRY(MessageBoxW)
APIHOOK_ENUM_END

/*++

 This stub function sets hWnd to NULL if it is not a valid window.

--*/
int 
APIHOOK(MessageBoxA)(
    HWND    hWnd,
    LPCSTR  lpText,
    LPCSTR  lpCaption,
    UINT    uType
    )
{
    if (IsWindow(hWnd) == 0) {
        hWnd = NULL;
    }

    return ORIGINAL_API(MessageBoxA)(hWnd, lpText, lpCaption, uType);
}

/*++

 This stub function sets hWnd to NULL if it is not a valid window.

--*/

int 
APIHOOK(MessageBoxW)(
    HWND    hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT    uType
    )
{
    if (IsWindow(hWnd) == 0) {
        hWnd = NULL;
    }

    return ORIGINAL_API(MessageBoxW)(hWnd, lpText, lpCaption, uType);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\movewininitrenametoreg.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    MoveWinInitRenameToReg.cpp

 Abstract:
    This shim hooks ExitWindowsEx as well as waits for DLL_PROCESS_DETACH 
    and then moves the contents of the [Rename] section of wininit.ini 
    into the registry via MoveFileEx().  

 History:

 07/24/2000 t-adams    Created
 02/12/2002 mnikkel    Modified calls to GetPrivateProfileStringW so default was a
                       null string, not NULL. Also put in loop for retrieving key values
                       that increased buffer till value fit instead of using MAX_PATH.

--*/
#include "precomp.h"

#define SIZE_STEP MAX_PATH

IMPLEMENT_SHIM_BEGIN(MoveWinInitRenameToReg)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ExitWindowsEx) 
APIHOOK_ENUM_END



/*++

  Abstract:
    Moves the entries in the Rename section of WinInit.ini into
    the registry via MoveFileEx().

--*/
void MoveWinInitRenameToReg(void)
{
    LPWSTR szKeys               = NULL;
    LPWSTR szFrom               = NULL;
    DWORD  dwKeysSize           = 0;
    LPWSTR pszTo                = NULL;

    CString csWinInit;
    CString csWinInitBak;

    // Construct the paths to wininit.ini and wininit.bak
    csWinInit.GetWindowsDirectoryW();
    csWinInitBak.GetWindowsDirectoryW();

    csWinInit.AppendPath(L"\\wininit.ini");
    csWinInitBak.AppendPath(L"\\wininit.bak");

    // Make sure wininit.ini exists.
    if( GetFileAttributesW(csWinInit) != INVALID_FILE_ATTRIBUTES)
    {
        // Copy wininit.ini to wininit.bak because we will be destroying
        // wininit.ini as we read through its keys and can't simply rename
        // it to wininit.bak later.  If the backup fails we can still continue.
        CopyFileW(csWinInit, csWinInitBak, FALSE);
    
        // Read the "key" names.
        // Since we can't know how big the list of keys is going to be,
        // continue to try to get the list until GetPrivateProfile string
        // returns something other than dwKeysSize-2 (indicating too small
        // of a buffer).      
        do
        {
            if( NULL != szKeys )
            {
                free(szKeys);
            }
            dwKeysSize += SIZE_STEP;
            szKeys = (LPWSTR) malloc(dwKeysSize * sizeof(WCHAR));
            if( NULL == szKeys )
            {
                goto Exit;
            }
        }
        while(GetPrivateProfileStringW(L"Rename", NULL, L"", szKeys, dwKeysSize, csWinInit)
               == dwKeysSize - 2);
          
        // Traverse through the keys. If there are no keys, szKeys will be a null terminator.
        // Delete each key after we read it so that if there are multiple "NUL" keys,
        // our calls to GetPrivateProfileStringA won't continue to return only the
        // first NUL key's associated value.
        pszTo = szKeys;
        while(*pszTo != NULL)
        {
            DWORD  dwFromSize = 0;

            do
            {
                if( NULL != szFrom )
                {
                    free(szFrom);
                }
                dwFromSize += SIZE_STEP;
                szFrom = (LPWSTR) malloc(dwFromSize * sizeof(WCHAR));
                if( NULL == szFrom )
                {
                    goto Exit;
                }
            }
            while(GetPrivateProfileStringW(L"Rename", pszTo, L"", szFrom, MAX_PATH, csWinInit) 
                    == dwKeysSize - 1);

            WritePrivateProfileStringW(L"Rename", pszTo, NULL, csWinInit);

            // If pszTo is "NUL", then the intention is to delete the szFrom file, so pass
            // NULL to MoveFileExA().  If the move fails we still wish to continue.
            if( wcscmp(pszTo, L"NUL") == 0 )
            {
                MoveFileExW(szFrom, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
            }
            else
            {
                MoveFileExW(szFrom, pszTo, MOVEFILE_DELAY_UNTIL_REBOOT);
            }
    
            // Move to the next file (key)
            pszTo += wcslen(pszTo) + 1;
        }
    
        // delete WinInit.ini
        DeleteFileW(csWinInit);
    }

Exit:
    if( NULL != szKeys )
    {
        free(szKeys);
    }
    if( NULL != szFrom )
    {
        free(szFrom);
    }
}


/*++

  Abstract:
    Hook ExitWindowsEx in case the program resets the machine, keeping
    us from receiving the DLL_PROCESS_DETACH message.  (Shim originally
    written for an uninstall program that caused a reset.)

--*/
BOOL 
APIHOOK(ExitWindowsEx)( 
            UINT uFlags, 
            DWORD dwReserved) 
{
    MoveWinInitRenameToReg();
    return ORIGINAL_API(ExitWindowsEx)(uFlags, dwReserved);    
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        MoveWinInitRenameToReg();
    }
    
    return TRUE;
}

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ExitWindowsEx )

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\moveinitoregistry.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   MoveIniToRegistry.cpp

 Abstract:

   This shim will move entries written directly into an INI file into the registry.

   Usage:
   IniFile  [IniSection]   IniKeyName  RegBaseKey RegKeyPath RegValue RegValueType

   IniFile          Full path to INI file (env variables like used for CorrectFilePaths may be used)
   [IniSection]     INI section name, must include the brackets
   IniKeyName       INI key name (the thing on the left of the =)
   RegBaseKey       One of: HKEY_CLASSES_ROOT, HKEY_CURRENT_CONFIG, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE or HKEY_USERS
   RegKeyPath       path of the registry key
   RegValue         registry value name (it may be different from IniKeyName
   RegValueType     One of: REG_SZ, REG_EXPAND_SZ, REG_DWORD


   Example:
   win.ini [Boot] SCRNSAVE.EXE HKEY_CURRENT_USER "Default\Control Panel\Desktop" SCRNSAVE.EXE REG_SZ
   Win.ini
   [Desktop]
   SCRNSAVE.EXE=goofy screen saver
   will be placed:
   RegSetValueEX("HKEY_USERS\Default\Control Panel\Desktop", "SCRNSAVE.EXE", 0, REG_SZ, "goofy screen saver", strlen("goofy screen saver"));
   

  Note:
    A section name of * implies that the data is not associated with any specific section,
    this allows this shim to work with (stupid) apps that put the data into random sections.
    If there are multiple entries, the first matching 

 Created:

   08/17/2000 robkenny

 Modified:



--*/

#include "precomp.h"
#include <ClassCFP.h>       // for EnvironmentValues

IMPLEMENT_SHIM_BEGIN(MoveIniToRegistry)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA) 
    APIHOOK_ENUM_ENTRY(OpenFile) 
    APIHOOK_ENUM_ENTRY(WriteFile) 
    APIHOOK_ENUM_ENTRY(CloseHandle) 
APIHOOK_ENUM_END


// Convert a string into a root HKEY
HKEY ToHKEY(const CString & csKey)
{
    if (csKey.CompareNoCase(L"HKEY_CLASSES_ROOT") == 0) 
    {
        return HKEY_CLASSES_ROOT;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_CURRENT_CONFIG") == 0)
    {
        return HKEY_CURRENT_CONFIG;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_CURRENT_USER") == 0)  
    {
        return HKEY_CURRENT_USER;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_LOCAL_MACHINE") == 0) 
    {
        return HKEY_LOCAL_MACHINE;
    } 
    else  if (csKey.CompareNoCase(L"HKEY_USERS") == 0)   
    {
        return HKEY_USERS;
    } 
    else
    {
        return NULL;
    }
}

DWORD ToRegType(const CString & csRegType)
{
    if (csRegType.CompareNoCase(L"REG_SZ") == 0)  
    {
        return REG_SZ;
    }   
    else if (csRegType.CompareNoCase(L"REG_EXPAND_SZ") == 0)  
    {
        return REG_EXPAND_SZ;
    }   
    else if (csRegType.CompareNoCase(L"REG_DWORD") == 0)      
    {
        return REG_DWORD;
    }   
    else if (csRegType.CompareNoCase(L"REG_DWORD_LITTLE_ENDIAN") == 0)  
    {
        // Same as REG_DWORD
        return REG_DWORD;
    }   
    else
    {
        return REG_NONE;
    }
}

class IniEntry
{
protected:

public:
    CString         lpIniFileName;
    HANDLE          hIniFileHandle;
    CString         lpSectionName;
    CString         lpKeyName;
    CString         lpKeyPath;
    DWORD           dwRegDataType;
    HKEY            hkRootKey;

    BOOL            bFileNameConverted;
    BOOL            bDirty;         // Has this file been modified

    BOOL    Set(const char * iniFileName,
                const char * iniSectionName,
                const char * iniKeyName,
                const char * rootKeyName,
                const char * keyPath,
                const char * valueName,
                const char * valueType);
    void    Clear();

    void    Convert();
    VOID    ReadINIEntry(CString & csEntry);
    void    MoveToRegistry();

    inline void SetDirty(BOOL dirty)
    {
        bDirty = dirty;
    }
    inline void OpenFile(HANDLE hFile)
    {
        hIniFileHandle  = hFile;
        bDirty          = FALSE;
    }
    inline void CloseFile()
    {
        hIniFileHandle  = INVALID_HANDLE_VALUE;
        bDirty          = FALSE;
    }
};


void IniEntry::Clear()
{
    if (hIniFileHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hIniFileHandle);
}

BOOL IniEntry::Set(
    const char * iniFileName,
    const char * iniSectionName,
    const char * iniKeyName,
    const char * rootKeyName,
    const char * keyPath,
    const char * valueName,
    const char * valueType)
{
    hIniFileHandle      = INVALID_HANDLE_VALUE;
    dwRegDataType       = REG_NONE;
    hkRootKey           = NULL;
    bFileNameConverted  = FALSE;
    bDirty              = FALSE;

    CString csValue(valueType);
    CString csRootKey(rootKeyName);

    dwRegDataType = ToRegType(csValue);
    if (dwRegDataType == REG_NONE)
        return false;

    // Attempt to open the registry keys, if these fail, we need go no further
    hkRootKey = ToHKEY(csRootKey);
    if (hkRootKey == NULL)
        return false;

    // We cannot open the RegKey here; ADVAPI32.dll hasn't been initialzed, yet.

    lpKeyPath       = keyPath;
    lpIniFileName   = iniFileName;
    lpSectionName   = iniSectionName;
    lpKeyName       = iniKeyName;

    return TRUE;
}


// Read a single line of data from the file,
// return TRUE if hit EOF
BOOL GetLine(HANDLE hFile, char * line, DWORD lineSize, DWORD * charsRead)
{
    BOOL retval = FALSE;

    *charsRead = 0;
    while (*charsRead < lineSize - 1)
    {
        DWORD bytesRead;
        char *nextChar = line + *charsRead;

        BOOL readOK = ReadFile(hFile, nextChar, 1, &bytesRead, NULL);
        if (!readOK || bytesRead != 1)
        {
            // Some sort of error
            retval = TRUE;
            break;
        }
        // Eat CR-LF
        if (!IsDBCSLeadByte(*nextChar) && *nextChar == '\n')
            break;
        if (!IsDBCSLeadByte(*nextChar) && *nextChar != '\r')
            *charsRead += 1;
    }

    line[*charsRead] = 0;

    return retval;
}

VOID FindLine(HANDLE hFile, const CString & findMe, CString & csLine, const WCHAR * stopLooking)
{
    csLine.Empty();

    const size_t findMeLen      = findMe.GetLength();

    // Search for findMe
    while (true)
    {
        char line[300];

        DWORD dataRead;
        BOOL eof = GetLine(hFile, line, sizeof(line), &dataRead);
        if (eof)
            break;

        CString csTemp(line);
        if (dataRead >= findMeLen) 
        {
            csTemp.TrimLeft();
            if (csTemp.ComparePartNoCase(findMe, 0, findMeLen) == 0) 
            {
                // Found the section
                csLine = csTemp;
                break;
            }

            // Check for termination
            if (stopLooking && csTemp.CompareNoCase(stopLooking) == 0) 
            {
                csLine = csTemp;
                break;
            }
        }
    }
}

// Convert all %envVars% in the string to text.
void IniEntry::Convert()
{
    if (!bFileNameConverted)
    {
        EnvironmentValues   env;
        WCHAR * fullIniFileName = env.ExpandEnvironmentValueW(lpIniFileName);
        if (fullIniFileName) 
        {
            lpIniFileName = fullIniFileName;
            delete fullIniFileName;
        }

        bFileNameConverted = TRUE;
    }
}

// Read the data from the INI file
// We *cannot* use GetPrivateProfileStringA since it might be re-routed to the registry
// Return the number of chars read.
VOID IniEntry::ReadINIEntry(CString & csEntry)
{
    csEntry.Empty();

    CString csLine;
    
    HANDLE hFile = CreateFileW(lpIniFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {

        // If the section name is *, we don't need to search
        if (lpSectionName.GetAt(0) != L'*') 
        {
            FindLine(hFile, lpSectionName, csLine, NULL);
        }

        // Our early termination string.
        // If the section name is *, we look forever, otherwise
        // we stop looking if we find a line starting with a [
        const WCHAR * stopLooking = lpSectionName.GetAt(0) == L'*' ? NULL : L"[";

        // Search for lpKeyName
        FindLine(hFile, lpKeyName, csLine, stopLooking);
        if (!csLine.IsEmpty())
        {
            int nEqual = csLine.Find(L'=');
            if (nEqual >= 0)
            {
                csLine.Mid(nEqual + 1, csEntry);
            }
        }

        CloseHandle(hFile);
    }
}

// Move the INI file entry into the registry
void IniEntry::MoveToRegistry()
{
    // Don't bother with the work, if they never wrote any data into the file.
    if (!bDirty)
        return;

    HKEY regKey;
    LONG success = RegOpenKeyExW(
        hkRootKey,
        lpKeyPath,
        0,
        KEY_ALL_ACCESS,
        &regKey);
    if (success != ERROR_SUCCESS)
        return;

    CString csIniEntry;

    ReadINIEntry(csIniEntry);
    if (!csIniEntry.IsEmpty())  
    {
        switch (dwRegDataType)
        {
        case REG_SZ:
        case REG_EXPAND_SZ:
            {
                const WCHAR * lpIniEntry = csIniEntry.Get();
                DWORD dwValueSize = (csIniEntry.GetLength() + 1) * sizeof(WCHAR);
                success = RegSetValueExW(regKey, lpKeyName, 0, dwRegDataType, (CONST BYTE *)lpIniEntry, dwValueSize);
                if (success == ERROR_SUCCESS)
                {
                    LOGN( eDbgLevelError, "IniEntry::MoveToRegistry, KeyPath(%S) Value(%S) set to (%S)\n",
                        lpKeyPath, lpKeyName, lpIniEntry);
                }
            }
            break;

        case REG_DWORD:
            {
                WCHAR * unused;
                long iniValue = wcstol(csIniEntry, &unused, 10);

                RegSetValueExW(regKey, lpKeyName, 0, dwRegDataType, (CONST BYTE *)&iniValue, sizeof(iniValue));
                if (success == ERROR_SUCCESS)
                {
                    LOGN( eDbgLevelError, "IniEntry::MoveToRegistry, KeyPath(%S) Value(%S) set to (%d)\n", lpKeyPath, lpKeyName, iniValue);
                }
            }
            break;
        }
    }

    RegCloseKey(regKey);
}

class IniEntryList : public VectorT<IniEntry>
{
public:
    void    OpenFile(const char *fileName, HANDLE hFile);
    void    CloseFile(HANDLE hFile);
    void    WriteFile(HANDLE hFile);    

    void    Add(const char * iniFileName,
                const char * iniSectionName,
                const char * iniKeyName,
                const char * rootKeyName,
                const char * keyPath,
                const char * valueName,
                const char * valueType);
};

// A file is being opened.
// If it is one that we are interested in, remember the handle
void IniEntryList::OpenFile(const char *fileName, HANDLE handle)
{
    CString csFileName(fileName);
    csFileName.GetFullPathNameW();

    const int nElem = Size();
    for (int i = 0; i < nElem; ++i)
    {
        IniEntry & elem = Get(i);

        elem.Convert();

        // Convert fileName to a full pathname for the compare.
        char fullPathName[MAX_PATH];
        char * filePart;
        
        if (csFileName.CompareNoCase(elem.lpIniFileName) == 0)  
        {
            elem.OpenFile(handle);

            DPFN( eDbgLevelSpew, "IniEntryList::OpenFile(%S) Handle(%d) has been opened for write\n", elem.lpIniFileName.Get(), elem.hIniFileHandle);
        }
    }
}

// A file has been closed,
// Check to see if this is a handle to a file that we are interested in.
// If it is a match, then move the INI entries into the registry.
void IniEntryList::CloseFile(HANDLE handle)
{
    const int nElem = Size();
    for (int i = 0; i < nElem; ++i)
    {
        IniEntry & elem = Get(i);

        if (elem.hIniFileHandle == handle)  
        {
            DPFN( eDbgLevelSpew, "IniEntryList::CloseFile(%S) Handle(%d) has been closed\n", elem.lpIniFileName.Get(), elem.hIniFileHandle);

            // Move the ini entry into the registry
            elem.MoveToRegistry();

            elem.CloseFile();
        }
    }
}

// A file has been closed,
// Check to see if this is a handle to a file that we are interested in.
// If it is a match, then move the INI entries into the registry.
void IniEntryList::WriteFile(HANDLE handle)
{
    const int nElem = Size();
    for (int i = 0; i < nElem; ++i)
    {
        IniEntry & elem = Get(i);

        if (elem.hIniFileHandle == handle && !elem.bDirty)  
        {
            DPFN( eDbgLevelSpew, "IniEntryList::CloseFile(%S) Handle(%d) has been closed\n", elem.lpIniFileName.Get(), elem.hIniFileHandle);
            
            elem.SetDirty(TRUE);
        }
    }
}

// Attempt to add these values to the list.
// Only if all values are valid, will a new entry be created.
void IniEntryList::Add(const char * iniFileName,
                       const char * iniSectionName,
                       const char * iniKeyName,
                       const char * rootKeyName,
                       const char * keyPath,
                       const char * valueName,
                       const char * valueType)
{
    // Make room for this 
    int lastElem = Size();
    if (Resize(lastElem + 1))   
    {
        IniEntry & iniEntry = Get(lastElem);

        // The VectorT does not call the constructors for new elements
        // Inplace new
        new (&iniEntry) IniEntry;

        if (iniEntry.Set(iniFileName, iniSectionName, iniKeyName, rootKeyName, keyPath, valueName, valueType)) 
        {
            // Keep the value
            nVectorList += 1;
        }
    }
}

IniEntryList * g_IniEntryList = NULL;

/*++

    Create the appropriate g_PathCorrector

--*/
BOOL ParseCommandLine(const char * commandLine)
{
    g_IniEntryList = new IniEntryList;
    if (!g_IniEntryList)
        return FALSE;

    int argc;
    char **argv = _CommandLineToArgvA(commandLine, &argc);

    // If there are no command line arguments, stop now
    if (argc == 0 || argv == NULL)
        return TRUE;

#if DBG
    {
        for (int i = 0; i < argc; ++i)
        {
            const char * arg = argv[i];
            DPFN( eDbgLevelSpew, "Argv[%d] = (%s)\n", i, arg);
        }
    }
#endif

    // Search the beginning of the command line for the switches
    for (int i = 0; i+6 < argc; i += 7)
    {
        g_IniEntryList->Add(
            argv[i + 0],
            argv[i + 1],
            argv[i + 2],
            argv[i + 3],
            argv[i + 4],
            argv[i + 5],
            argv[i + 6]);
    }

    return TRUE;
}


HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,                         // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile                        // handle to template file
    )
{
    HANDLE returnValue = ORIGINAL_API(CreateFileA)(
                lpFileName,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);

    if ( (dwDesiredAccess & GENERIC_WRITE) && (returnValue != INVALID_HANDLE_VALUE))
        g_IniEntryList->OpenFile(lpFileName, returnValue);

    return returnValue;
}


HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        // file name
    LPOFSTRUCT lpReOpenBuff,  // file information
    UINT uStyle               // action and attributes
    )
{
    HFILE returnValue = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
 
    if ((uStyle & OF_WRITE) && (returnValue != HFILE_ERROR))
        g_IniEntryList->OpenFile(lpReOpenBuff->szPathName, (HANDLE)returnValue);

    return returnValue;
}

BOOL 
APIHOOK(CloseHandle)(
    HANDLE hObject   // handle to object
    )
{
    BOOL returnValue = ORIGINAL_API(CloseHandle)(hObject);

    if (hObject != INVALID_HANDLE_VALUE)
        g_IniEntryList->CloseFile(hObject);

    return returnValue;
}

BOOL
APIHOOK(WriteFile)(
    HANDLE hFile,                    // handle to file
    LPCVOID lpBuffer,                // data buffer
    DWORD nNumberOfBytesToWrite,     // number of bytes to write
    LPDWORD lpNumberOfBytesWritten,  // number of bytes written
    LPOVERLAPPED lpOverlapped        // overlapped buffer
    )
{
    BOOL returnValue = ORIGINAL_API(WriteFile)(
        hFile,
        lpBuffer,
        nNumberOfBytesToWrite,
        lpNumberOfBytesWritten,
        lpOverlapped
        );

    g_IniEntryList->WriteFile(hFile);

    return returnValue;
}

/*++

  Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }
    
    return TRUE;
}

HOOK_BEGIN

    APIHOOK_ENTRY(Kernel32.DLL, CreateFileA )
    APIHOOK_ENTRY(Kernel32.DLL, OpenFile )
    APIHOOK_ENTRY(Kernel32.DLL, WriteFile )
    APIHOOK_ENTRY(Kernel32.DLL, CloseHandle )

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\populatedefaulthkcusettings.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    PopulateDefaultHKCUSettings.cpp
    
 Abstract:

    Populate HKCU with default values if they do not exist. Some apps installs HKCU values
    for only the user that ran setup on that app. In this case, if another users tries to use the
    application they will be unable to due to missing HKCU regkeys.
    
    To shim around this, we check for the existance of a regkey and if it does not exist, we then read
    a pre-defined .reg file our of our resource section and exec regedit on it to add the necessary
    registry keys. For example:

    COMMAND_LINE("Software\Lotus\SmartCenter\97.0!SmartCenter97")

    would mean that if the regkey 'HKCU\Software\Lotus\SmartCenter\97.0' does NOT exist, then we should
    read the named resource 'SmartCenter97' out of our dll and write it to a temp .reg file and then
    execute 'regedit.exe /s tempfile.reg' to properly populate the registry with the defaul HKCU values.

 Notes:

    This is an general shim. (Actually, its a Admiral shim, since its in the navy, hehe).

 History:

    01/31/2001 reiner Created
    03/30/2001 amarp  Added %__AppSystemDir_% and %__AppLocalOrCDDir<Param1><Param2><Param3>_%
                      (documented below)
    03/14/2002 mnikkel changed to use strsafe.h

--*/

#include "precomp.h"
#include "stdio.h"


IMPLEMENT_SHIM_BEGIN(PopulateDefaultHKCUSettings)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
APIHOOK_ENUM_END

const DWORD g_MAX = MAX_PATH * 2;

BOOL ParseCommandLine(
            const char* pszCmdLine, 
            char* pszRegKeyName, 
            DWORD cchRegKeyName, 
            char* pszResourceName, 
            DWORD cchResourceName)
{
    BOOL bRet = FALSE;

    CSTRING_TRY
    {
        CString csCmdLine(pszCmdLine);
        int cchKey = csCmdLine.Find(L"!");

        if (cchKey >= 0)
        {
            // Resource length = Command line length - Key length - exclamation
            DWORD cchResource = csCmdLine.GetLength() - cchKey - 1;
            
            if ((cchRegKeyName >= (DWORD)(cchKey + 1)) && 
                (cchResourceName >= (cchResource + 1)))
            {
                CString csKey = csCmdLine.Left(cchKey);
                CString csResource = csCmdLine.Right(cchResource);

                // we have enough space in the output buffers to fit the strings
                if (S_OK == StringCchCopyA(pszRegKeyName, cchRegKeyName, csKey.GetAnsi()) &&
                    S_OK == StringCchCopyA(pszResourceName, cchResourceName, csResource.GetAnsi()))
                {
                    bRet = TRUE;
                }
            }
        }
    }
    CSTRING_CATCH
    {
        // do nothing
    }

    return bRet;
}


//
// This actually creates the tempfile (0 bytes) and returns
// the filename.
//
BOOL CreateTempName(char* szFileName)
{
    char szTempPath[MAX_PATH];
    BOOL bRet = FALSE;

    DWORD dwLen = GetTempPathA(MAX_PATH, szTempPath);

    if (dwLen > 0 && dwLen < MAX_PATH)
    {
        if (GetTempFileNameA(szTempPath,
                             "AcGenral",
                             0,
                             szFileName))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}


//
// Exec's "regedit /s" with the given file
//
BOOL SpawnRegedit(char* szFile)
{
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    char szApp[g_MAX];
    BOOL bRet = FALSE;

    if (S_OK == StringCchCopyA(szApp, g_MAX, "regedit.exe /s ") &&
        S_OK == StringCchCatA(szApp, g_MAX, szFile))
    {
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_HIDE;
        
        bRet = CreateProcessA(NULL,
                            szApp,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &si,
                            &pi);

        if (bRet)
        {
            WaitForSingleObject(pi.hProcess, INFINITE);

            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }

    return bRet;
}


//
// this function is used to change a path from:
//
//  "C:\Lotus\Smartsuite"  ->  "C:\\Lotus\\Smartsuite"
//
// (.reg files use escaped backslashes)
//
BOOL DoubleUpBackslashes(WCHAR* pwszPath, DWORD cchPath)
{
    BOOL bRet = FALSE;

    CSTRING_TRY
    {
        CString csTemp(pwszPath);

        csTemp.Replace(L"\\",L"\\\\");

        if (cchPath >= (DWORD)(csTemp.GetLength()+1) &&
            S_OK == StringCchCopyW(pwszPath, cchPath, csTemp))
        {
            bRet = TRUE;
        }
    }
    CSTRING_CATCH
    {
        // do nothing
    }

    return bRet;
}


//
// This fuction calculates the application dir (pszAppDir) and the application
// parent dir (pszAppParentDir) based on the return from GetModuleFileName
//
BOOL InitAppDir(WCHAR* pwszSystemDir, DWORD cchSystemDir,
                WCHAR* pwszAppDir, DWORD cchAppDir, 
                WCHAR* pwszAppParentDir, DWORD cchAppParentDir
                )
{
    DWORD dwLen = 0;
    WCHAR wszExePath[MAX_PATH];

    dwLen = GetSystemDirectoryW(pwszSystemDir,cchSystemDir);
    if(dwLen <= 0 || dwLen >= MAX_PATH)
        return FALSE;

    BOOL bRet = DoubleUpBackslashes(pwszSystemDir,cchSystemDir);
    if( !bRet )
        return FALSE;

    if (GetModuleFileNameW(NULL, wszExePath, sizeof(wszExePath)/sizeof(wszExePath[0])))
    {
        CSTRING_TRY
        {
            CString csPath;
            CString csPath2;
            CString csTemp(wszExePath);

            csTemp.GetNotLastPathComponent(csPath);
            csPath.GetNotLastPathComponent(csPath2);

            if (!csPath.IsEmpty())
            {
                if (cchAppDir >= (DWORD)(csPath.GetLength()+1) &&           
                    S_OK == StringCchCopyW(pwszAppDir, cchAppDir, csPath))
                {
                    bRet = DoubleUpBackslashes(pwszAppDir, cchAppDir);
                    
                    if (bRet)
                    {
                        if (!csPath2.IsEmpty())
                        {
                            if(cchAppParentDir >= (DWORD)(csPath2.GetLength()+1) &&
                            S_OK == StringCchCopyW(pwszAppParentDir, cchAppParentDir, csPath2))
                            {
                                bRet = DoubleUpBackslashes(pwszAppParentDir, cchAppParentDir);
                            }
                        }
                        else
                        {
                            // if there is not another '\' then just use the same path as pwszAppDir
                            if (S_OK == StringCchCopyW(pwszAppParentDir, cchAppParentDir, pwszAppDir))
                                bRet = TRUE;
                        }
                    }
                }
            }
        }
        CSTRING_CATCH
        {
            // do nothing
        }
    }

    return bRet;
}


//
// This function is called to actually write stuff out to the file
//
BOOL WriteToFile(HANDLE hFile, void* pv, DWORD cb)
{
    DWORD dwBytesWritten;
    BOOL bWriteSucceeded = FALSE;

    if (WriteFile(hFile, pv, cb, &dwBytesWritten, NULL) &&
        (dwBytesWritten == cb))
    {
        bWriteSucceeded = TRUE;
    }

    return bWriteSucceeded;
}

BOOL PathIsNonEmptyDirectory(WCHAR* pwszPath)
{
    WCHAR wszSearchFilter[MAX_PATH+1];
    DWORD dwAttr = GetFileAttributesW(pwszPath);
    BOOL bRet = FALSE;
    if( (-1 != dwAttr) && (FILE_ATTRIBUTE_DIRECTORY & dwAttr ) )
    {
        if (S_OK != StringCchPrintfW(wszSearchFilter, MAX_PATH, L"%s\\*.*", pwszPath))
        {
            return bRet;
        }
        

        WIN32_FIND_DATAW FindData;
        HANDLE hSearch = FindFirstFileW(wszSearchFilter,&FindData);
        if( INVALID_HANDLE_VALUE == hSearch )
            return bRet;
        do
        {
            if(L'.' != FindData.cFileName[0])
            {
                bRet = TRUE;
                break;
            }
        }
        while( FindNextFileW(hSearch,&FindData) );
        FindClose(hSearch);
    }
    return bRet;
}

BOOL FindCDDriveContainingDirectory(WCHAR* pwchCDDriveLetter, WCHAR* pwszCheckPath)
{
    // Find out cd drive (looks for app cd in drive, else just chooses first cd drive found)
    // NOTE: This function only actually does anything the first time its called (to avoid
    //       thrashing CD drive, or bringing up excessive dialogs if no CD in drive).
    //       The assumption is that once a good CD drive is found, any other times you need
    //       a CD drive in this shim, it will be the same one, so this function will just return
    //       that drive.

    static BOOL  s_bFoundDrive = FALSE;
    static BOOL  s_bTriedOnce  = FALSE;
    static WCHAR s_wchCDDriveLetter = L'\0';

    if( s_bTriedOnce )
    {
        *pwchCDDriveLetter = s_wchCDDriveLetter;
        return s_bFoundDrive;
    }
    s_bTriedOnce = TRUE;
    
    DWORD dwLogicalDrives = GetLogicalDrives();
    WCHAR wchCurrDrive = L'a';
    WCHAR wszPath[MAX_PATH];

    while( dwLogicalDrives )
    {
        if( dwLogicalDrives & 1 )
        {
            wszPath[0] = wchCurrDrive;
            wszPath[1] = L':';
            wszPath[2] = L'\0';

            if( DRIVE_CDROM == GetDriveTypeW( wszPath ) )
            {
                if( L'\0' == s_wchCDDriveLetter )
                {
                    s_bFoundDrive = TRUE;
                    s_wchCDDriveLetter = wchCurrDrive;
                }

                if (wcslen(pwszCheckPath) > MAX_PATH-3)
                {
                    return FALSE;
                }
                if (S_OK != StringCchCatW(wszPath, MAX_PATH, pwszCheckPath))
                {
                    return FALSE;
                }
                
                DWORD dwAttr = GetFileAttributesW(wszPath);
                if( (-1 != dwAttr) && (FILE_ATTRIBUTE_DIRECTORY & dwAttr ) )
                {
                    // this drive seems to have the app cd in it based on 
                    // a very primitive heuristic... so lets use this as our cd drive.
                    s_wchCDDriveLetter = wchCurrDrive;
                    *pwchCDDriveLetter = s_wchCDDriveLetter;
                    return TRUE;
                }
            }
        }
        dwLogicalDrives >>= 1;
        wchCurrDrive++;
    }
    *pwchCDDriveLetter = s_wchCDDriveLetter; //may be L'\0' if we didn't find anything.
    return s_bFoundDrive;
}

BOOL GrabNParameters( UINT uiNumParameters,
                      WCHAR* pwszStart, WCHAR** ppwszEnd,
                      WCHAR  pwszParam[][MAX_PATH] )
{
    WCHAR* pwszEnd;
    UINT uiLength;
    *ppwszEnd = NULL;

    for( UINT i = 0; i < uiNumParameters; i++ )
    {
        if( L'<' != *(pwszStart++) )
            return FALSE;

        pwszEnd = pwszStart;

        while( (L'\0' != *pwszEnd) )
        {
            if( L'>' != *pwszEnd )
            {
                pwszEnd++;
                continue;
            }
            uiLength = (pwszEnd - pwszStart);
            if( uiLength >= MAX_PATH )
                return FALSE;
            if( S_OK != StringCchCopyW(pwszParam[i], MAX_PATH, pwszStart))
                return FALSE;
            break;
        }

        if( L'>' != *pwszEnd )
            return FALSE;

        pwszStart = pwszEnd + 1; 
    }
    *ppwszEnd = pwszStart;
    return TRUE;
}

//
// As we write out the resource to a temp file, we need to scan through looking
// for the env variables:
//
//      %__AppDir_%
//      %__AppParentDir_%
//
// and replace them with the proper path (the dir of the current .exe or its parent,
// respectively). 
//
// Additional vars (added by amarp):
//
//     %__AppSystemDir_% 
//          - Maps to GetSystemDir()  (i.e. c:\windows\system32)
// 
//     %__AppLocalOrCDDir<Param1><Param2><Param3>_%
// 
//          - The three parameters are just paths (should start with a \\).  
//            Any/all may be empty.  They are defined as follows:
//            Param1 = a relative path under the apps install directory (i.e. under AppDir)
//            Param2 = a relative path under the apps CD drive (where CD Drive = "drive:")
//            Param3 = a relative path/filename under Param1 or Param2 (in most cases this will be empty)
// 
//            When this var is encountered, it is replaced as follows:
//             a)   if AppDirParam1Param3 is a *nonempty* directory, output AppDirParam1Param3
//             b)   else, if there is a CDDrive for which directory CDDrive:Param2 exists, output CDDrive:Param2Param3
//             c)   else, output CDDrive:Param2Param3 for the first enumerated CD drive.
//
//            Example: %__AppLocalOrCDDir<\\content\\clipart><\\clipart><\\index.dat>_% maps does the following:
//                (lets assume AppDir is c:\app, and there are cd drives d: and e:, neither of which have the app's CD inserted)
//             a)   Is c:\app\content a directory? Yes! -> Is it nonempty (at least one file or directory that doesn't start with '.')?
//                                                 yes! -> output c:\app\content\index.dat
//             <end>
//
//            Or, this example could pan out to the following scenario:
//             a) Is c:\app\content a directory? Yes! -> Is it nonempty? No!
//             b) Is d:\clipart a directory? No! Is e:\clipart a directory? No!
//             c) The first cd drive we found was d: -> output d:\clipart\index.dat
//             <end>
//
//            Anoter example: %__AppLocalOrCDDir<__UNUSED__><\\clipart><>_% maps does the following:
//                (lets assume AppDir is c:\app and app CD is in drive d:)
//             a)   Is c:\app__UNUSED__ a directory?  PROBABLY NOT! (thus we can essentially ignore this parameter by doing this)
//             b)   Is d:\clipart a directory? Yes! -->  output d:\clipart
//             <end>
//
//
//
// NOTE: cbResourceSize holds the size of the original resource (which is the 2 WCHAR's
//       smaller than pvData). We use this to set eof after we are done writing everything
//       out.
//
BOOL WriteResourceFile(HANDLE hFile, void* pvData, DWORD /*cbResourceSize*/)
{
    WCHAR* pwszEndOfLastWrite = (WCHAR*)pvData;
    WCHAR wszAppDir[MAX_PATH];
    WCHAR wszAppParentDir[MAX_PATH];
    WCHAR wszSystemDir[MAX_PATH];
    BOOL bRet = FALSE;
    bRet = InitAppDir(wszSystemDir, sizeof(wszSystemDir)/sizeof(wszSystemDir[0]),
                      wszAppDir, sizeof(wszAppDir)/sizeof(wszAppDir[0]), 
                      wszAppParentDir, sizeof(wszAppParentDir)/sizeof(wszAppParentDir[0]));
    if (!bRet)
        return bRet;

    do
    {
        WCHAR* pwsz = wcsstr(pwszEndOfLastWrite, L"%__App");
        if (pwsz)
        {
            // first, write out anything before the tag we found
            bRet = WriteToFile(hFile, pwszEndOfLastWrite, (DWORD)((BYTE*)pwsz - (BYTE*)pwszEndOfLastWrite));

            if(!bRet)
                break;

            pwszEndOfLastWrite = pwsz;

            // found a tag that we need to replace. See which one it is
            if (wcsncmp(pwsz, L"%__AppDir_%", lstrlenW(L"%__AppDir_%")) == 0)
            {
                bRet = WriteToFile(hFile, wszAppDir, lstrlenW(wszAppDir) * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__AppDir_%");
            }
            else if (wcsncmp(pwsz, L"%__AppParentDir_%", lstrlenW(L"%__AppParentDir_%")) == 0)
            {
                bRet = WriteToFile(hFile, wszAppParentDir, lstrlenW(wszAppParentDir) * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__AppParentDir_%");
            }
            else if (wcsncmp(pwsz, L"%__AppSystemDir_%", lstrlenW(L"%__AppSystemDir_%")) == 0)
            {
                bRet = WriteToFile(hFile, wszSystemDir, lstrlenW(wszSystemDir) * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__AppSystemDir_%");
            }
            else if (wcsncmp(pwsz, L"%__AppLocalOrCDDir", lstrlenW(L"%__AppLocalOrCDDir")) == 0)
            {
                WCHAR   wszParams[3][MAX_PATH];
                WCHAR*  pwszStart = pwsz + lstrlenW(L"%__AppLocalOrCDDir");
                WCHAR*  pwszEnd;
                WCHAR   wszDesiredPath[MAX_PATH];

                if (!GrabNParameters(3,pwszStart,&pwszEnd,wszParams))
                {
                    pwszEndOfLastWrite += lstrlenW(L"%__AppLocalOrCDDir");
                    continue;
                }

                if (0 != wcsncmp(pwszEnd, L"_%", lstrlenW(L"_%")))
                {
                    pwszEndOfLastWrite = pwszEnd;
                    continue;
                }

                if (S_OK == StringCchPrintfW(wszDesiredPath,MAX_PATH, L"%s%s", wszAppDir, wszParams[0]))
                {
                    if( PathIsNonEmptyDirectory(wszDesiredPath) )
                    {
                        if (S_OK == StringCchPrintfW(wszDesiredPath,MAX_PATH,L"%s%s%s",wszAppDir, wszParams[0], wszParams[2]))
                            bRet = WriteToFile(hFile, wszDesiredPath, lstrlenW(wszDesiredPath) * sizeof(WCHAR));
                    }
                    else
                    {
                        WCHAR wchDrive;
                        UINT uiOffset;
                        if( L'\\' == wszParams[1][0] && L'\\' == wszParams[1][1] )
                            uiOffset = sizeof(WCHAR);
                        else
                            uiOffset = 0;
                        if( FindCDDriveContainingDirectory(&wchDrive,wszParams[1]+uiOffset))
                        {
                            if (S_OK == StringCchPrintfW(wszDesiredPath,MAX_PATH,L"%c:%s%s",wchDrive,wszParams[1],wszParams[2]))
                                bRet = WriteToFile(hFile, wszDesiredPath, lstrlenW(wszDesiredPath) * sizeof(WCHAR));
                        }
                    }
                }
                                                                
                pwszEndOfLastWrite= pwszEnd + lstrlenW(L"_%");
            }
            else
            {
                // Strange... we found a string that started w/ "%__App" that wasen't one we are
                // intersted in. Just skip over it and keep going.
                bRet = WriteToFile(hFile, pwsz, lstrlenW(L"%__App") * sizeof(WCHAR));
                pwszEndOfLastWrite += lstrlenW(L"%__App");
            }
        }
        else
        {
            // didn't find anymore strings to replace

            // using lstrlenW should give us the size of the string w/out the null, which is what we
            // want since we added on the space for the null when we created the buffer
            bRet = WriteToFile(hFile, pwszEndOfLastWrite, lstrlenW(pwszEndOfLastWrite) * sizeof(WCHAR));

            // break out of the loop, as we are finished
            break;
        }

    } while (bRet);
    
    return bRet;
}


//
// The job of this function is to read the specified string resource our
// of our own DLL and write it to a temp file, and then to spawn regedit on
// the file 
//
BOOL ExecuteRegFileFromResource(char* pszResourceName)
{
    // lame, but we aren't passed our hinst in our pseudo dllmain,
    // so we have to hardcode the dllname
    HMODULE hmod = GetModuleHandleA("AcGenral");
    BOOL bRet = FALSE;

    if (hmod)
    {
        HRSRC hrsrc = FindResourceA(hmod, pszResourceName, MAKEINTRESOURCEA(10)/* RT_RCDATA */);

        if (hrsrc)
        {
            DWORD dwSize;
            void* pvData;

            dwSize = SizeofResource(hmod, hrsrc);

            if (dwSize > 0)
            {
                // allocate enough room for the entire resource including puting a null terminator on
                // the end since we will be treating it like huge LPWSTR.
                pvData = LocalAlloc(LPTR, dwSize + sizeof(WCHAR));

                if (pvData)
                {
                    HGLOBAL hGlobal = LoadResource(hmod, hrsrc);

                    if (hGlobal)
                    {
                        void* pv = LockResource(hGlobal);

                        if (pv)
                        {
                            char szTempFile[MAX_PATH];

                            // copy the resource into our buffer
                            memcpy(pvData, pv, dwSize);

                            if (CreateTempName(szTempFile))
                            {
                                // we use OPEN_EXISTING since the tempfile should always exist as it
                                // was created in the call to CreateTempName()
                                HANDLE hFile = CreateFileA(szTempFile,
                                                        GENERIC_WRITE,
                                                        FILE_SHARE_READ,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        FILE_ATTRIBUTE_TEMPORARY,
                                                        NULL);

                                if (hFile != INVALID_HANDLE_VALUE)
                                {
                                    BOOL bWriteSucceeded = WriteResourceFile(hFile, pvData, dwSize);

                                    CloseHandle(hFile);

                                    if (bWriteSucceeded)
                                    {
                                        bRet = SpawnRegedit(szTempFile);
                                    }
                                }

                                DeleteFileA(szTempFile);
                            }
                        }
                    }
                    LocalFree(pvData);
                }
            }
        }
    }

    return bRet;
}


BOOL PopulateHKCUValues()
{
    static BOOL s_fAlreadyPopulated = FALSE;

    if (!s_fAlreadyPopulated)
    {
        char szRegKeyName[MAX_PATH];
        char szResourceName[64];

        UINT uiOldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS); // stop dialogs from coming up when we enumerate CD drives that are empty.

        // set this to true so we only do this check once 
        s_fAlreadyPopulated = TRUE;

        if (ParseCommandLine(COMMAND_LINE,
                             szRegKeyName,
                             ARRAYSIZE(szRegKeyName),
                             szResourceName,
                             ARRAYSIZE(szResourceName)))
        {
            DWORD dwError;
            HKEY hkCU;

            // check to see if the HKCU registry key is already present
            dwError = RegOpenKeyExA(HKEY_CURRENT_USER,
                                    szRegKeyName,
                                    0,
                                    KEY_QUERY_VALUE,
                                    &hkCU);

            if (dwError == ERROR_SUCCESS)
            {
                // yep, its already there. Nothing to do.
                RegCloseKey(hkCU);
            }
            else if (dwError == ERROR_FILE_NOT_FOUND)
            {
                // the regkey is missing, we will assume that this is the first time
                // the user has run the app and populate HKCU with the proper stuff
                ExecuteRegFileFromResource(szResourceName);
            }
        }

        SetErrorMode(uiOldErrorMode);
    }


    return s_fAlreadyPopulated;
}


//
// Its lame that we have to hook RegOpenKey/Ex but since we need to call
// the advapi32 registry apis we can't do this as a straight NOTIFY_FUNCTION
// because we need to wait for advapi to have its DLL_PROCESS_ATTACH called.
//
LONG
APIHOOK(RegOpenKeyA)(HKEY hkey, LPCSTR pszSubKey, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyA)(hkey, pszSubKey, phkResult);
}


LONG
APIHOOK(RegOpenKeyW)(HKEY hkey, LPCWSTR pszSubKey, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyW)(hkey, pszSubKey, phkResult);
}

LONG
APIHOOK(RegOpenKeyExA)(HKEY hkey, LPCSTR pszSubKey, DWORD ulOptions, REGSAM samDesired, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyExA)(hkey, pszSubKey, ulOptions, samDesired, phkResult);
}

LONG
APIHOOK(RegOpenKeyExW)(HKEY hkey, LPCWSTR pszSubKey, DWORD ulOptions, REGSAM samDesired, HKEY* phkResult)
{
    PopulateHKCUValues();
    return ORIGINAL_API(RegOpenKeyExW)(hkey, pszSubKey, ulOptions, samDesired, phkResult);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\recopyexefromcd.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RecopyExeFromCD.cpp

 Abstract:

    This shim waits for CloseHandle to be called on the appropriate .exe file.
    Once this call has been made, CopyFile is called to recopy the executable 
    due to truncation of the file during install.

 History:

    12/08/1999 a-jamd   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RecopyExeFromCD)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA) 
    APIHOOK_ENUM_ENTRY(CloseHandle) 
APIHOOK_ENUM_END

// The following variables are used to keep track of the file handle,
// the source path and the destination path.
HANDLE          g_hInterestingHandle    = NULL; 
CString *       g_wszSourcePath         = NULL;
CString *       g_wszDestinationPath    = NULL;
BOOL            g_bInCopyFile           = FALSE;

// The following array specifies what the valid names of executables to 
// be recopied are. Add to these lists when new apps requiring this shim are 
// found.
WCHAR *g_rgszExes[] = {
    L"eaw.exe",
    L"GK3.EXE",
};

#define N_RECOPY_EXE    (sizeof(g_rgszExes) / sizeof(g_rgszExes[0]))

/*++

 This stub function breaks into CreateFileA and checks to see if the file in 
 use is a known .exe file.  If it is, APIHook_CreateFileA determines if  
 lpFileName is the source path or the destination and saves it.  When the 
 file is the destination, the handle returned by CreateFile is also saved 
 for my check in CloseHandle.

--*/

HANDLE 
APIHOOK(CreateFileA)(    
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  
    DWORD dwCreationDisposition,                          
    DWORD dwFlagsAndAttributes, 
    HANDLE hTemplateFile 
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileA)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,  
        dwCreationDisposition,                          
        dwFlagsAndAttributes, 
        hTemplateFile);

    if (hRet != INVALID_HANDLE_VALUE)
    {
        CString csFilePartOnly;
        CString csFileName(lpFileName);
        csFileName.GetFullPathNameW();
        csFileName.GetLastPathComponent(csFilePartOnly);
    
        // Should be d:\ or somesuch
        CString csDir;
        csFileName.Mid(0, 3, csDir);
        UINT uiDriveType = GetDriveTypeW(csDir);

        for (int i = 0; i < N_RECOPY_EXE; ++i)
        {
            const WCHAR * lpszRecopy = g_rgszExes[i];
    
            // Find out if one of the known .exe files is the file in use
            
            if (csFilePartOnly.CompareNoCase(lpszRecopy) == 0)
            {
                if (uiDriveType != DRIVE_CDROM)
                {
                    // Known .exe file was found in the filename, and it wasn't on the CDRom.
                    // There is also a valid handle.
                    g_hInterestingHandle = hRet;
                    g_wszDestinationPath = new CString(csFileName);
                    
                    break;
                }
                else
                {
                    // Known .exe was found in the filename, and the drive is a CDRom.
                    // This is the path to the source and must be stored for later.
                    g_wszSourcePath = new CString(csFileName);

                    break;
                }
            }
        }
    }
    
    return hRet;
}


/*++

 This stub function breaks into CloseHandle and checks to see if the handle in 
 use is the handle to a known .exe.  If it is, APIHook_CloseHandle calls 
 CopyFile and copies the known .exe from the CDRom to the destination.

--*/

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    BOOL    bRet;

    bRet = ORIGINAL_API(CloseHandle)(hObject);
    
    // Find out if g_hInterestingHandle is being closed
    if ((hObject == g_hInterestingHandle) &&
        g_wszSourcePath &&
        g_wszDestinationPath &&
        (g_bInCopyFile == FALSE) )
    {
        // CopyFileA calls CloseHandle, so we must maintain the recursive state 
        // to fix a recursion problem
        g_bInCopyFile = TRUE;

        // Correct Handle
        // Call CopyFile and recopy the known .exe file from the CDRom to the 
        // destination
        CopyFileW( g_wszSourcePath->Get(), g_wszDestinationPath->Get(), FALSE );

        LOGN( eDbgLevelWarning, "[CloseHandle] Copied %S from CD to %S", g_wszSourcePath->Get(), g_wszDestinationPath->Get());

        // Since copying from the CDRom, and attributes are carried over, the 
        // file attributes must be set
        SetFileAttributesW( g_wszDestinationPath->Get(), FILE_ATTRIBUTE_NORMAL );

        g_bInCopyFile = FALSE;
        g_hInterestingHandle = NULL;

        return bRet;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\propagateprocesshistory.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   PropagateProcessHistory.cpp

 Abstract:

   This DLL adds the current process to the __PROCESS_HISTORY environment
   variable. This is needed for 32-bit applications that launch other
   32-bit executables that have been put in a temporary directory and have
   no appropriate side-step files. It allows the matching mechanism to
   locate files in the parent's directory, which are unique to the application.

 History:

   03/21/2000 markder  Created
   03/13/2002 mnikkel  Modified to use strsafe and correctly handle error returns from
                       GetEnvironmentVariableW and GetModuleFileNameW.  Removed
                       HEAP_GENERATE_EXCEPTIONS from HeapAllocs.
   03/26/2002 mnikkel  Removed incorrect checks for error on GetEnvironmentVariableW.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PropagateProcessHistory)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    BOOL bRet = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        DWORD dwProcessHistoryBufSize, dwExeFileNameBufSize, dwFullProcessSize;
        LPWSTR wszExeFileName = NULL, wszProcessHistory = NULL;

        // Get size of buffers, note that if PROCESS_HISTORY is not defined that
		// dwProcessHistoryBufSize can be zero.  This is expected.
        dwProcessHistoryBufSize = GetEnvironmentVariableW( L"__PROCESS_HISTORY", NULL, 0 );
        dwExeFileNameBufSize = MAX_PATH*2; // GetModuleFileNameW doesn't return buffer size needed??;
        dwFullProcessSize = dwProcessHistoryBufSize + dwExeFileNameBufSize + 2;

        wszProcessHistory = (LPWSTR) HeapAlloc(
                                        GetProcessHeap(),
                                        0,
                                        dwFullProcessSize * sizeof(WCHAR) );


        wszExeFileName = (LPWSTR) HeapAlloc(
                                        GetProcessHeap(),
                                        0,
                                        (dwExeFileNameBufSize + 1) * sizeof(WCHAR) );

        if( wszExeFileName && wszProcessHistory )
        {
            wszProcessHistory[0] = L'\0';
			if (dwProcessHistoryBufSize > 0)
			{
				dwProcessHistoryBufSize = GetEnvironmentVariableW( 
					                            L"__PROCESS_HISTORY",
						                        wszProcessHistory,
							                    dwProcessHistoryBufSize );
			}

            dwExeFileNameBufSize = GetModuleFileNameW( NULL, wszExeFileName, dwExeFileNameBufSize );
            if (dwExeFileNameBufSize <= 0)
            {
                DPFN( eDbgLevelError, "GetModuleFileNameW failed.");
                bRet = FALSE;
                goto exitnotify;
            }

            if( *wszProcessHistory && wszProcessHistory[wcslen(wszProcessHistory) - 1] != L';' )
                StringCchCatW(wszProcessHistory, dwFullProcessSize, L";");

            StringCchCatW(wszProcessHistory, dwFullProcessSize, wszExeFileName);

            if( ! SetEnvironmentVariableW( L"__PROCESS_HISTORY", wszProcessHistory ) )
            {
                DPFN( eDbgLevelError, "SetEnvironmentVariable failed!");
            }
            else
            {
                DPFN( eDbgLevelInfo, "Current EXE added to process history");
                DPFN( eDbgLevelInfo, "__PROCESS_HISTORY=%S", wszProcessHistory);
            }
        }
        else
        {
            DPFN( eDbgLevelError, "Could not allocate memory for strings");
            bRet = FALSE;
        }

exitnotify:
        if( wszProcessHistory )
            HeapFree( GetProcessHeap(), 0, wszProcessHistory );

        if( wszExeFileName )
            HeapFree( GetProcessHeap(), 0, wszExeFileName );
    }

    return bRet;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\paletterestore.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    PaletteRestore.cpp

 Abstract:

    On win9x, all palette state was maintained through a mode change. On NT, 
    this can cause numerous problems, most often when task switching between 
    the application and the desktop.

    Unfortunately, GetSystemPaletteEntries does NOT return the peFlags part
    of the PALETTEENTRY struct, which means that we have to intercept the 
    other palette setting functions just to find out what the real palette 
    is.

    The strategy is as follows:
        
        1. Catch all known ways of setting up the palette
        2. After a mode change, restore the palette 

    In order to do this, we also have to keep a list of the DCs so we know 
    which palette was animated/realized and the active window to which it 
    belongs.

    Not yet implemented:

        1. Track whether a palette change came from within DirectDraw, since on 
           win9x, DirectDraw doesn't use GDI to set the palette, so calls to 
           GetSystemPaletteEntries will return different results. 

 Notes:

    This is a general purpose shim.

 History:

    05/20/2000 linstev  Created
    03/06/2002 mnikkel  Changed InitializeCriticalSection to InitializeCriticalSectionAndSpinCount

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(PaletteRestore)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsW)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExW)
    APIHOOK_ENUM_ENTRY(SetSystemPaletteUse)
    APIHOOK_ENUM_ENTRY(CreatePalette)
    APIHOOK_ENUM_ENTRY(SetPaletteEntries)
    APIHOOK_ENUM_ENTRY(AnimatePalette)
    APIHOOK_ENUM_ENTRY(CreateDCA)
    APIHOOK_ENUM_ENTRY(CreateDCW)
    APIHOOK_ENUM_ENTRY(CreateCompatibleDC)
    APIHOOK_ENUM_ENTRY(DeleteDC)
    APIHOOK_ENUM_ENTRY(GetDC)
    APIHOOK_ENUM_ENTRY(GetWindowDC)
    APIHOOK_ENUM_ENTRY(ReleaseDC)
    APIHOOK_ENUM_ENTRY(SelectPalette)
    APIHOOK_ENUM_ENTRY(GetSystemPaletteEntries)
    APIHOOK_ENUM_ENTRY(RealizePalette)
    APIHOOK_ENUM_ENTRY(DeleteObject)
APIHOOK_ENUM_END

//
// Keep track of the last realized palette
//

PALETTEENTRY g_lastPal[256];

//
// Keeps the last value of the call to SetSystemPaletteUse
//

UINT g_uLastUse = SYSPAL_NOSTATIC256;

//
// Default system palette: needed because NT only keeps 20 colors
//
 
DWORD g_palDefault[256] = 
{
    0x00000000, 0x00000080, 0x00008000, 0x00008080,
    0x00800000, 0x00800080, 0x00808000, 0x00C0C0C0,
    0x00C0DCC0, 0x00F0CAA6, 0x04081824, 0x04142830,
    0x0418303C, 0x04304D61, 0x0451514D, 0x044D7161,
    0x04826D61, 0x040C1414, 0x04597582, 0x04759E08,
    0x04303438, 0x04AA6938, 0x04203428, 0x04496161,
    0x0449869E, 0x047D9A6D, 0x040869CB, 0x048E8682,
    0x0475615D, 0x040061EB, 0x04000871, 0x042C3830,
    0x040471EF, 0x048E92AA, 0x04306DF7, 0x0404C3C3,
    0x0492AAB2, 0x04101814, 0x04040C08, 0x040C7110,
    0x04CFA282, 0x040008AA, 0x0428412C, 0x04498EB2,
    0x04204D61, 0x04555955, 0x0404D3D3, 0x041C3C4D,
    0x0420A6F7, 0x0410A210, 0x0418241C, 0x045DAEF3,
    0x04719EAA, 0x04B2E720, 0x04102871, 0x0486C3D3,
    0x04288A2C, 0x040C51BA, 0x0459716D, 0x04494D4D,
    0x04AAB6C3, 0x04005100, 0x0420CBF7, 0x044D8A51,
    0x04BEC7B2, 0x04043CBA, 0x04101C18, 0x040851DF,
    0x04A6E7A6, 0x049ECF24, 0x04797592, 0x04AE7559,
    0x049E8269, 0x04CFE3DF, 0x040C2030, 0x0428692C,
    0x049EA2A2, 0x04F7C782, 0x0434617D, 0x04B6BEBE,
    0x04969E86, 0x04DBFBD3, 0x04655149, 0x0465EF65,
    0x04AED3D3, 0x04E7924D, 0x04B2BEB2, 0x04D7DBDB,
    0x04797571, 0x04344D59, 0x0486B2CF, 0x04512C14,
    0x04A6FBFB, 0x04385965, 0x04828E92, 0x041C4161,
    0x04595961, 0x04002000, 0x043C6D7D, 0x045DB2D7,
    0x0438EF3C, 0x0451CB55, 0x041C2424, 0x0461C3F3,
    0x0408A2A2, 0x0438413C, 0x04204951, 0x04108A14,
    0x04103010, 0x047DE7F7, 0x04143449, 0x04B2652C,
    0x04F7EBAA, 0x043C7192, 0x0404FBFB, 0x04696151,
    0x04EFC796, 0x040441D7, 0x04000404, 0x04388AF7,
    0x048AD3F3, 0x04006500, 0x040004E3, 0x04DBFFFF,
    0x04F7AE69, 0x04CF864D, 0x0455A2D3, 0x04EBEFE3,
    0x04EB8A41, 0x04CF9261, 0x04C3F710, 0x048E8E82,
    0x04FBFFFF, 0x04104110, 0x04040851, 0x0482FBFB,
    0x043CC734, 0x04088A8A, 0x04384545, 0x04514134,
    0x043C7996, 0x041C6161, 0x04EBB282, 0x04004100,
    0x04715951, 0x04A2AAA6, 0x04B2B6B2, 0x04C3FBFB,
    0x04000834, 0x0428413C, 0x04C7C7CF, 0x04CFD3D3,
    0x04824520, 0x0408CB0C, 0x041C1C1C, 0x04A6B29A,
    0x0471A6BE, 0x04CF9E6D, 0x046D7161, 0x04008A04,
    0x045171BE, 0x04C7D3C3, 0x04969E96, 0x04798696,
    0x042C1C10, 0x04385149, 0x04BE7538, 0x0408141C,
    0x04C3C7C7, 0x04202C28, 0x04D3E3CF, 0x0471826D,
    0x04653C1C, 0x0404EF08, 0x04345575, 0x046D92A6,
    0x04797979, 0x0486F38A, 0x04925528, 0x04E3E7E7,
    0x04456151, 0x041C499A, 0x04656961, 0x048E9EA2,
    0x047986D3, 0x04204151, 0x048AC7E3, 0x04007100,
    0x04519EBE, 0x0410510C, 0x04A6AAAA, 0x042C3030,
    0x04D37934, 0x04183030, 0x0449828E, 0x04CBFBC3,
    0x046D7171, 0x040428A6, 0x044D4545, 0x04040C14,
    0x04087575, 0x0471CB79, 0x044D6D0C, 0x04FBFBD3,
    0x04AAB2AE, 0x04929292, 0x04F39E55, 0x04005D00,
    0x04E3D7B2, 0x04F7FBC3, 0x043C5951, 0x0404B2B2,
    0x0434658E, 0x040486EF, 0x04F7FBE3, 0x04616161,
    0x04DFE3DF, 0x041C100C, 0x0408100C, 0x0408180C,
    0x04598600, 0x0424FBFB, 0x04346171, 0x04042CC7,
    0x04AEC79A, 0x0445AE4D, 0x0428A62C, 0x04EFA265,
    0x047D8282, 0x04F7D79A, 0x0465D3F7, 0x04E3E7BA,
    0x04003000, 0x04245571, 0x04DF823C, 0x048AAEC3,
    0x04A2C3D3, 0x04A6FBA2, 0x04F3FFF3, 0x04AAD7E7,
    0x04EFEFC3, 0x0455F7FB, 0x04EFF3F3, 0x04BED3B2,
    0x0404EBEB, 0x04A6E3F7, 0x00F0FBFF, 0x00A4A0A0,
    0x00808080, 0x000000FF, 0x0000FF00, 0x0000FFFF,
    0x00FF0000, 0x00FF00FF, 0x00FFFF00, 0x00FFFFFF
};

// 
// Critical section used when accessing our lists
//

CRITICAL_SECTION g_csLists;

//
// A single item in the list of palettes
//

struct PALITEM
{
    HPALETTE hPal;
    PALETTEENTRY palPalEntry[256];
};

//
// Vector class that stores all the known palettes
//

class CPalVector : public VectorT<PALITEM>
{
public:
    // Find an hPal
    PALITEM *Find(HPALETTE hPal)
    {
        for (int i=0; i<Size(); ++i)
        {
            PALITEM &pitem = Get(i);
            if (pitem.hPal == hPal)
            {
                return &pitem;
            }
        }
        
        DPFN( eDbgLevelWarning, "Find: Could not find HPALETTE %08lx", hPal);

        return NULL;
    }
    
    // Remove an hPal
    BOOL Remove(HPALETTE hPal)
    {
        if (hPal)
        {
            EnterCriticalSection(&g_csLists);

            for (int i=0; i<Size(); ++i)
            {
                PALITEM &pitem = Get(i);
                if (pitem.hPal == hPal)
                {
                    pitem = Get(Size() - 1);
                    nVectorList -= 1;
                    LeaveCriticalSection(&g_csLists);
                    return TRUE;
                }
            }
            
            LeaveCriticalSection(&g_csLists);
        }

        return FALSE;
    }

};
CPalVector *g_palList;

//
// A single item in the list of DCs
//

struct DCITEM
{
    HDC hDc;
    HWND hWnd;
    HPALETTE hPal;
};

//
// Vector class that stores all the known DCs acquired by GetDC
//

class CDcVector : public VectorT<DCITEM>
{
public:
    // Find an hWnd/hDC
    DCITEM *Find(HWND hWnd, HDC hDc)
    {
        for (int i=0; i<Size(); ++i)
        {
            DCITEM &ditem = Get(i);
            if ((ditem.hDc == hDc) &&
                (ditem.hWnd == hWnd))
            {
                return &ditem;
            }
        }

        DPFN( eDbgLevelWarning, "Find: Could not find HDC %08lx", hDc);
        
        return NULL;
    }

    // Add an hWnd/hDC
    void Add(HWND hWnd, HDC hDc)
    {
        EnterCriticalSection(&g_csLists);

        DCITEM ditem;
        ditem.hPal = 0;
        ditem.hWnd = hWnd;
        ditem.hDc = hDc;
        Append(ditem);

        LeaveCriticalSection(&g_csLists);
    }
        
    
    // Remove an hWnd/hDC
    BOOL Remove(HWND hWnd, HDC hDc)
    {
        if (hDc)
        {
            EnterCriticalSection(&g_csLists);

            for (int i=0; i<Size(); ++i)
            {
                DCITEM &ditem = Get(i);
                if ((ditem.hDc == hDc) && (ditem.hWnd == hWnd))
                {
                    ditem = Get(Size() - 1);
                    nVectorList -= 1;
                    LeaveCriticalSection(&g_csLists);
                    return TRUE;
                }
            }

            LeaveCriticalSection(&g_csLists);
        }

        DPFN( eDbgLevelWarning, "Remove: Could not find hWnd=%08lx, hDC=%08lx", hWnd, hDc);

        return FALSE;
    }
};
CDcVector *g_dcList;

/*++

 Restore the last palette that was realized if we're in a palettized mode.
 
--*/

VOID 
FixPalette()
{
    LPLOGPALETTE plogpal;
    HWND hwnd;
    HDC hdc;
    HPALETTE hpal, hpalold;
    int icaps;
    
    hwnd = GetActiveWindow();
    hdc = ORIGINAL_API(GetDC)(hwnd);
    icaps = GetDeviceCaps(hdc, RASTERCAPS);

    // Check for palettized mode
    if (icaps & RC_PALETTE)
    {
        DPFN( eDbgLevelInfo, "Restoring palette");

        // We've set into a palettized mode, so fix the palette use
        ORIGINAL_API(SetSystemPaletteUse)(hdc, g_uLastUse);

        // Create a palette we can realize
        plogpal = (LPLOGPALETTE) malloc(sizeof(LOGPALETTE) + sizeof(g_lastPal));
        plogpal->palVersion = 0x0300;
        plogpal->palNumEntries = 256;
        MoveMemory(&plogpal->palPalEntry[0], &g_lastPal[0], sizeof(g_lastPal));
    
        // Realize the palette
        hpal = ORIGINAL_API(CreatePalette)(plogpal);
        hpalold = ORIGINAL_API(SelectPalette)(hdc, hpal, FALSE);
        ORIGINAL_API(RealizePalette)(hdc);
        ORIGINAL_API(SelectPalette)(hdc, hpalold, FALSE);
        ORIGINAL_API(DeleteObject)(hpal);
    }
    else
    {
        // Release the DC we used
        ORIGINAL_API(ReleaseDC)(hwnd, hdc);
    }
}

/*++

 Restore palette after change
 
--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD dwFlags
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsA)(
        lpDevMode,
        dwFlags);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Restore palette after change

--*/

LONG 
APIHOOK(ChangeDisplaySettingsW)(
    LPDEVMODEW lpDevMode,
    DWORD dwFlags
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsW)(
        lpDevMode,
        dwFlags);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Restore palette after change

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND hwnd,
    DWORD dwFlags,
    LPVOID lParam
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsExA)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        dwFlags, 
        lParam);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Restore palette after change
 
--*/

LONG 
APIHOOK(ChangeDisplaySettingsExW)(
    LPCWSTR lpszDeviceName,
    LPDEVMODEW lpDevMode,
    HWND hwnd,
    DWORD dwFlags,
    LPVOID lParam
    )
{
    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsExW)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        dwFlags, 
        lParam);

    if (lpDevMode)
    {
        DPFN( eDbgLevelInfo, 
            "%08lx=ChangeDisplaySettings(%d x %d x %d)", 
            lRet,
            lpDevMode->dmPelsWidth, 
            lpDevMode->dmPelsHeight, 
            lpDevMode->dmBitsPerPel);
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "%08lx=ChangeDisplaySettings Restore",lRet);
    }

    if (lpDevMode) FixPalette();

    return lRet;
}

/*++

 Track the system palette use

--*/

UINT 
APIHOOK(SetSystemPaletteUse)(
    HDC hdc,      
    UINT uUsage   
    )
{
    g_uLastUse = uUsage;

    DPFN( eDbgLevelInfo, "SetSystemPaletteUse=%08lx", uUsage);
        
    return ORIGINAL_API(SetSystemPaletteUse)(hdc, uUsage);
}

/*++

 Track created palette

--*/

HPALETTE 
APIHOOK(CreatePalette)(
    CONST LOGPALETTE *lplgpl   
    )
{
    HPALETTE hRet;

    hRet = ORIGINAL_API(CreatePalette)(lplgpl);

    if (hRet)
    {
        PALITEM pitem;
        
        pitem.hPal = hRet;

        MoveMemory(
            &pitem.palPalEntry[0], 
            &lplgpl->palPalEntry[0], 
            lplgpl->palNumEntries * sizeof(PALETTEENTRY));

        EnterCriticalSection(&g_csLists);
        g_palList->Append(pitem);
        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, "%08lx=CreatePalette", hRet);

    return hRet;
}

/*++

 Update our private palette with the new entries.

--*/

UINT 
APIHOOK(SetPaletteEntries)(
    HPALETTE hpal,             
    UINT iStart,               
    UINT cEntries,             
    CONST PALETTEENTRY *lppe   
    )
{
    UINT uRet;

    uRet = ORIGINAL_API(SetPaletteEntries)(
        hpal,
        iStart,
        cEntries,
        lppe);

    if (uRet)
    {
        EnterCriticalSection(&g_csLists);

        PALITEM *pitem = g_palList->Find(hpal);

        if (pitem)
        {
            MoveMemory(
                &pitem->palPalEntry[iStart], 
                lppe, 
                cEntries * sizeof(PALETTEENTRY));
        }

        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=SetPaletteEntries(%08lx,%d,%d)", 
        uRet, 
        hpal, 
        iStart, 
        cEntries);

    return uRet;
}

/*++

 Update our private palette with the new entries.

--*/

BOOL 
APIHOOK(AnimatePalette)(
    HPALETTE hpal,            
    UINT iStartIndex,         
    UINT cEntries,            
    CONST PALETTEENTRY *ppe   
    )
{
    BOOL bRet;
    UINT ui;
    int i;

    bRet = ORIGINAL_API(AnimatePalette)(
        hpal,
        iStartIndex,
        cEntries,
        ppe);

    if (bRet)
    {
        EnterCriticalSection(&g_csLists);

        PALITEM *pitem = g_palList->Find(hpal);

        if (pitem)
        {
            //
            // Animate palette only replaces entries with the PC_RESERVED flag 
            //

            PALETTEENTRY *pe = &pitem->palPalEntry[iStartIndex];
            for (ui=0; ui<cEntries; ui++)
            {
                if (pe->peFlags & PC_RESERVED)
                {
                    pe->peRed = ppe->peRed;
                    pe->peGreen = ppe->peGreen;
                    pe->peBlue = ppe->peBlue;
                }

                pe++;
                ppe++;
            }

            //
            // Check if this palette will be realized. 
            // Note: check all DCs since the palette it may have been 
            // selected into more than 1.
            //

            for (i=0; i<g_dcList->Size(); i++)
            {
                DCITEM &ditem = g_dcList->Get(i);

                if ((hpal == ditem.hPal) &&
                    (GetActiveWindow() == ditem.hWnd))
                {
                    MoveMemory(
                        &g_lastPal[0], 
                        &pitem->palPalEntry[0], 
                        sizeof(g_lastPal));
                    
                    break;
                }
            }
        }
        
        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=AnimatePalette(%08lx,%d,%d)", 
        bRet,
        hpal,
        iStartIndex,
        cEntries);

    return bRet;
}

/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette. 

--*/

HDC 
APIHOOK(CreateCompatibleDC)(
    HDC hdc   
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(CreateCompatibleDC)(hdc);

    if (hRet)
    {
        g_dcList->Add(0, hRet);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=CreateCompatibleDC(%08lx)", 
        hRet,
        hdc);

    return hRet;
}
 
/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette. We only care about CreateDC 
 if it's passed 'display'

--*/

HDC 
APIHOOK(CreateDCA)(
    LPCSTR lpszDriver,  
    LPCSTR lpszDevice,  
    LPCSTR lpszOutput,  
    CONST DEVMODEA *lpInitData 
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(CreateDCA)(
        lpszDriver, 
        lpszDevice, 
        lpszOutput, 
        lpInitData);

    if (hRet && (!lpszDriver || (_stricmp(lpszDriver, "DISPLAY") == 0)))
    {
        g_dcList->Add(0, hRet);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=CreateDCA(%s,%s)", 
        hRet,
        lpszDriver,
        lpszDevice);

    return hRet;
}
 
/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette. We only care about CreateDC 
 if it's passed 'display'

--*/

HDC 
APIHOOK(CreateDCW)(
    LPCWSTR lpszDriver,  
    LPCWSTR lpszDevice,  
    LPCWSTR lpszOutput,  
    CONST DEVMODEW *lpInitData 
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(CreateDCW)(
        lpszDriver, 
        lpszDevice, 
        lpszOutput, 
        lpInitData);

    if (hRet && (!lpszDriver || (_wcsicmp(lpszDriver, L"DISPLAY") == 0)))
    {
        g_dcList->Add(0, hRet);
    }

    DPFN( eDbgLevelInfo, 
        "%08lx=CreateDCW(%S,%S)", 
        hRet,
        lpszDriver,
        lpszDevice);

    return hRet;
}

/*++

 Remove a DC created with CreateDC

--*/

BOOL
APIHOOK(DeleteDC)(
    HDC hdc
    )
{
    int bRet;

    bRet = ORIGINAL_API(DeleteDC)(hdc);

    if (bRet)
    {
        g_dcList->Remove(0, hdc);
    }

    DPFN( eDbgLevelInfo, "%08lx=DeleteDC(%08lx)", bRet, hdc);

    return bRet;
}

/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette.

--*/

HDC 
APIHOOK(GetDC)(
    HWND hWnd   
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(GetDC)(hWnd);

    if (hRet)
    {
        g_dcList->Add(hWnd, hRet);
    }

    DPFN( eDbgLevelInfo, "%08lx=GetDC(%08lx)", hRet, hWnd);

    return hRet;
}

/*++

 Keep a list of DCs and their associated windows so we can look them up when 
 we need to find out which DC has which palette.

--*/

HDC 
APIHOOK(GetWindowDC)(
    HWND hWnd   
    )
{
    HDC hRet;

    hRet = ORIGINAL_API(GetWindowDC)(hWnd);

    if (hRet)
    {
        g_dcList->Add(hWnd, hRet);
    }

    DPFN( eDbgLevelInfo, "%08lx=GetWindowDC(%08lx)", hRet, hWnd);

    return hRet;
}

/*++

 Release the DC and remove it from our list

--*/

int 
APIHOOK(ReleaseDC)(
    HWND hWnd,  
    HDC hDC     
    )
{
    int iRet;

    iRet = ORIGINAL_API(ReleaseDC)(hWnd, hDC);

    if (iRet)
    {
        g_dcList->Remove(hWnd, hDC);
    }

    DPFN( eDbgLevelInfo, "%08lx=ReleaseDC(%08lx, %08lx)", iRet, hWnd, hDC);

    return iRet;
}
  
/*++

 Keep track of which DC the palette lives in.

--*/

HPALETTE 
APIHOOK(SelectPalette)(
    HDC hdc,                
    HPALETTE hpal,          
    BOOL bForceBackground   
    )
{
    HPALETTE hRet;

    hRet = ORIGINAL_API(SelectPalette)(
        hdc,
        hpal,
        bForceBackground);

    EnterCriticalSection(&g_csLists);

    //
    // Select this palette into all copies of this DC
    //

    for (int i=0; i<g_dcList->Size(); i++)
    {
        DCITEM & ditem = g_dcList->Get(i);

        if (hdc == ditem.hDc)
        {
            ditem.hPal = hpal;
        }
    }

    LeaveCriticalSection(&g_csLists);

    DPFN( eDbgLevelInfo, "%08lx=SelectPalette(%08lx, %08lx)", hRet, hdc, hpal);

    return hRet;
}

/*++

 Stub this for now because of known problems listed at top.

--*/

UINT 
APIHOOK(GetSystemPaletteEntries)(
    HDC hdc,              
    UINT iStartIndex,     
    UINT nEntries,        
    LPPALETTEENTRY lppe   
    )
{
    UINT uRet;

    uRet = ORIGINAL_API(GetSystemPaletteEntries)(
        hdc,
        iStartIndex,
        nEntries,
        lppe);

    DPFN( eDbgLevelInfo, "%08lx=GetSystemPaletteEntries(%08lx, %08lx, %08lx)", uRet, hdc, iStartIndex, nEntries);

    return uRet;
}

/*++

 Fill in the last known palette if anything was realized

--*/

UINT 
APIHOOK(RealizePalette)(
    HDC hdc   
    )
{
    UINT uRet;

    uRet = ORIGINAL_API(RealizePalette)(hdc);

    if (uRet)
    {
        EnterCriticalSection(&g_csLists);

        //
        // Check for all windows of all DCs
        //

        HWND hwnd = GetActiveWindow();

        for (int i=0; i<g_dcList->Size(); i++)
        {
            DCITEM &ditem = g_dcList->Get(i);

            if (hwnd == ditem.hWnd)
            {
                PALITEM *pitem = g_palList->Find(ditem.hPal);

                if (pitem)
                {
                    MoveMemory(
                        &g_lastPal[0],
                        &pitem->palPalEntry[0],
                        sizeof(g_lastPal));

                    break;
                }
            }
        }

        LeaveCriticalSection(&g_csLists);
    }

    DPFN( eDbgLevelInfo, "%08lx=RealizePalette(%08lx)", uRet, hdc);

    return uRet;
}

/*++

 Delete palette objects from the list.

--*/

UINT 
APIHOOK(DeleteObject)(
    HGDIOBJ hObject
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(DeleteObject)(hObject);

    if (bRet)
    {
        g_palList->Remove((HPALETTE)hObject);
    }

    return bRet;
}
 
/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        g_palList = new CPalVector;
        g_dcList = new CDcVector;
        MoveMemory(&g_lastPal, &g_palDefault, sizeof(g_lastPal));

        return InitializeCriticalSectionAndSpinCount(&g_csLists,0x80000000);
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        // Can't free since we might still be called
        
        // delete g_palList;
        // delete g_dcList;
        // DeleteCriticalSection(&g_csLists);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA);
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsW);
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA);
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExW);
    APIHOOK_ENTRY(USER32.DLL, GetDC);
    APIHOOK_ENTRY(USER32.DLL, GetWindowDC);
    APIHOOK_ENTRY(USER32.DLL, ReleaseDC);

    APIHOOK_ENTRY(GDI32.DLL, CreateCompatibleDC);
    APIHOOK_ENTRY(GDI32.DLL, CreateDCA);
    APIHOOK_ENTRY(GDI32.DLL, CreateDCW);
    APIHOOK_ENTRY(GDI32.DLL, DeleteDC);
    APIHOOK_ENTRY(GDI32.DLL, SetSystemPaletteUse);
    APIHOOK_ENTRY(GDI32.DLL, CreatePalette);
    APIHOOK_ENTRY(GDI32.DLL, SetPaletteEntries);
    APIHOOK_ENTRY(GDI32.DLL, AnimatePalette);
    APIHOOK_ENTRY(GDI32.DLL, SelectPalette);
    APIHOOK_ENTRY(GDI32.DLL, GetSystemPaletteEntries);
    APIHOOK_ENTRY(GDI32.DLL, RealizePalette);
    APIHOOK_ENTRY(GDI32.DLL, DeleteObject);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\removebroadcastpostmessage.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveBroadcastPostMessage.cpp

 Abstract:

    Fix apps that don't handle broadcast messages.

 Notes:

    This is a general purpose shim.

 History:

    04/28/2000 a-batjar  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveBroadcastPostMessage)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PostMessageA) 
APIHOOK_ENUM_END

/*++

 Filter HWND_BROADCAST messages

--*/

BOOL 
APIHOOK(PostMessageA)(
        HWND hwnd,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam
        )
{
    if (hwnd == HWND_BROADCAST)
    {
        hwnd = NULL;
    }

    return ORIGINAL_API(PostMessageA)(
        hwnd,
        Msg,
        wParam,
        lParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, PostMessageA)

HOOK_END

    

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\redirectwindowsdirtosystem32.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RedirectWindowsDirToSystem32.cpp

 Abstract:

    Redirects GetWindowsDirectory calls to GetSystemDirectory.

 Notes:


 History:

    04/05/2000 a-batjar  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RedirectWindowsDirToSystem32)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryA) 
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryW) 
APIHOOK_ENUM_END

DWORD 
APIHOOK(GetWindowsDirectoryA)(
    LPSTR lpBuffer,
    DWORD Size 
    )
{
   return GetSystemDirectoryA( lpBuffer, Size );
}

DWORD 
APIHOOK(GetWindowsDirectoryW)(
    LPWSTR lpBuffer,
    DWORD Size 
    )
{
   return GetSystemDirectoryW( lpBuffer, Size );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetWindowsDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetWindowsDirectoryW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\redirectexe.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    RedirectEXE.cpp

 Abstract:

    Launch a new EXE and terminate the existing one.

 Notes:

    This is a general purpose shim.

 History:

    04/10/2001 linstev  Created
    03/13/2002 mnikkel  Added return value check on GetEnvironmentVariableW and
                        allocated buffer based on return value.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RedirectEXE)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Launch the new process.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        // 
        // Redirect the EXE
        //
        CSTRING_TRY 
        {
            AppAndCommandLine acl(NULL, GetCommandLineA());
        
            CString csAppName(COMMAND_LINE);

            csAppName.ExpandEnvironmentStrings();

            if (csAppName.GetAt(0) == L'+')
            {
                CString csDrive, csPathAdd, csName, csExt, csCracker;
                DWORD   dwLen;
                WCHAR * pszBuffer;

                csAppName.Delete(0, 1);
                csCracker=acl.GetApplicationName();
                csCracker.SplitPath(&csDrive, &csPathAdd, &csName, &csExt);

                csPathAdd.TrimRight('\\');
                if (csPathAdd.IsEmpty())
                {
                    csPathAdd = L"\\";
                }

                dwLen = GetEnvironmentVariableW(L"PATH", NULL, 0);
                if (dwLen <= 0)
                {
                    LOGN( eDbgLevelError, "Could not get path!");
                }
                else
                {
                   pszBuffer = (WCHAR *)malloc((dwLen+1)*sizeof(WCHAR));
                    if (pszBuffer == NULL)
                    {
                        LOGN( eDbgLevelError, "Could not allocate memory!");
                    }
                    else
                    {
                        dwLen = GetEnvironmentVariableW(L"PATH", pszBuffer, dwLen+1);
                        if (dwLen <= 0)
                        {
                            LOGN( eDbgLevelError, "Could not get path!");
                        }
                        else
                        {
                            CString csPathEnv = pszBuffer;

                            csPathEnv += L";";
                            csPathEnv += csDrive;
                            csPathEnv += csPathAdd;
                            if (!SetEnvironmentVariable(L"PATH", csPathEnv.Get()))
                            {
                                LOGN( eDbgLevelError, "Could not set path!");
                            }
                            else
                            {
                                LOGN( eDbgLevelInfo, "New Path: %S", csPathEnv);
                            }
                        }
                    }
                }               
            }

            csAppName += L" ";
            csAppName += acl.GetCommandlineNoAppName();

            LOGN( eDbgLevelInfo, "Redirecting to %S", csAppName);

            PROCESS_INFORMATION ProcessInfo;
            STARTUPINFOA StartupInfo;

            ZeroMemory(&StartupInfo, sizeof(StartupInfo));
            StartupInfo.cb = sizeof(StartupInfo);
            ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));

            BOOL bRet = CreateProcessA(NULL,
                                csAppName.GetAnsi(),
                                NULL,
                                NULL,
                                FALSE,
                                0,
                                NULL,
                                NULL,
                                &StartupInfo,
                                &ProcessInfo);

            if (bRet == 0)
            {
                LOGN( eDbgLevelError, "CreateProcess failed!");
                return FALSE;
            }
        }
        CSTRING_CATCH
        {
            LOGN( eDbgLevelError, "Exception while trying to redirect EXE");
        }

        ExitProcess(0);
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\removeddeflagfromshellexecuteex.cpp ===
/*++

 Copyright (c) 2001-2002 Microsoft Corporation

 Module Name:

    RemoveDDEFlagFromShellExecuteEx.cpp

 Abstract:

    Some applications call ShellExecute which in turn calls ShellExecuteEx.
    One of the flags in the SHELLEXECUTEINFO structure is 'SEE_MASK_FLAG_DDEWAIT'.
    This flag gets set by ShellExecuteEx as a default whenever ShellExecute is
    called.
    
    Here is the description for the flag:
    
    'Wait for the DDE conversation to terminate before returning
    (if the ShellExecuteEx function causes a DDE conversation to start).
    
    The SEE_MASK_FLAG_DDEWAIT flag must be specified if the thread calling
    ShellExecuteEx does not have a message loop or if the thread or process
    will terminate soon after ShellExecuteEx returns. Under such conditions,
    the calling thread will not be available to complete the DDE conversation,
    so it is important that ShellExecuteEx complete the conversation before
    returning control to the caller. Failure to complete the conversation can
    result in an unsuccessful launch of the document.
    
    If the calling thread has a message loop and will exist for some time
    after the call to ShellExecuteEx returns, the SEE_MASK_FLAG_DDEWAIT
    flag is optional. If the flag is omitted, the calling thread's message
    pump will be used to complete the DDE conversation. The calling application
    regains control sooner, since the DDE conversation can be completed in the background.'
    
    When the flag gets passed, it can sometimes cause synchronzation problems.
    An example is Photo Express Platinum 2000. It attempts to launch Internet Explorer,
    but IE wreaks havoc on the app that made the call.
    
    This shim simply removes this flag from the ShellExecuteEx call.

 Notes:
    
    This is a general purpose shim.

 History:

    04/16/2001  rparsons  Created
    03/07/2002  mnikkel   Added check for Null lpExecInfo

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveDDEFlagFromShellExecuteEx)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)
APIHOOK_ENUM_END

/*++

 Hook the call to ShellExecuteExW and remove the flag.

--*/

BOOL
APIHOOK(ShellExecuteExW)(
    LPSHELLEXECUTEINFO lpExecInfo
    )
{
    if (lpExecInfo)
        lpExecInfo->fMask = lpExecInfo->fMask & ~SEE_MASK_FLAG_DDEWAIT;

    LOGN( eDbgLevelInfo, "Removed SEE_MASK_FLAG_DDEWAIT from ShellExecuteExW");
    
    return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\redirectdbcstemppath.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   RedirectDBCSTempPath.cpp

 Abstract:

   This shim redirect DBCS temp path to SBCS temp path.
   With DBCS user name log on, temp path contains DBCS path.
   Some App cannot handle DBCS temp path and fails to launch.

   Originally created for Japanese App BenriKaikeiV2 to avoid setup failure.
   App setup fails when DBCS user logon. GetTempPathA returns DBCS include path.
   SETUP1.EXE convert path to Unicode and call MSVBVM60!rtcLeftCharBstr to set str length.
   This API calculate Unicode len = ANSI len + ANSI len and set wrong result.
   Length is wrong and MSVBVM60!_vbaStrCat could not add necessary file name to path.
   RedirectDBCSTempPath solves those bugs.

   Example:
   change C:\DOCUME~1\DBCS\LOCALS~1\Temp\ (DBCS User Temp)
   to C:\DOCUME~1\ALLUSE~1\APPLIC~1\ (All User App Data)

 History:

    05/04/2001  hioh        Created
    03/14/2002  mnikkel     Increased size of buffer to MAX_PATH*2
                            converted to use strsafe.h
    04/25/2002  hioh        To "\Documents and Settings\All Users\Application Data\" for LUA

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RedirectDBCSTempPath)
#include "ShimHookMacro.h"

//
// API to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetTempPathA) 
APIHOOK_ENUM_END

/*++

 Function Description:
    
    Check if DBCS character is included in the specified length of the string.

 Arguments:

    IN pStr  - Pointer to the string
    IN dwlen - Length to check

 Return Value:

    TRUE if DBCS exist or FALSE

 History:

    05/04/2001 hioh     Created

--*/

BOOL
IsDBCSHere(
    CHAR    *pStr,
    DWORD   dwlen
    )
{
    while (0 < dwlen--)
    {
        if (IsDBCSLeadByte(*pStr++))
        {
            return TRUE;
        }
    }
    return FALSE;
}

/*++

 Hack to redirect DBCS temp path to SBCS ALL User App Data path.
 
--*/

DWORD
APIHOOK(GetTempPathA)(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
    // Check if valid pointer
    if (!lpBuffer)
    {   // NULL pointer error
        LOG("RedirectDBCSTempPath", eDbgLevelError, "lpBuffer is NULL.");
        return (ORIGINAL_API(GetTempPathA)(nBufferLength, lpBuffer));
    }

    // Call original API with my stack data
    CHAR    szTempPath[MAX_PATH*2];
    DWORD   dwLen = ORIGINAL_API(GetTempPathA)(sizeof(szTempPath), szTempPath);

    // If API error occurs, return
    if (dwLen <= 0 || dwLen >= MAX_PATH)
    {
        return dwLen;
    }

    // Check DBCS, if so, try to redirect
    if (IsDBCSHere(szTempPath, dwLen))
    {
        CHAR    szAllUserPath[MAX_PATH*2] = "";

        // Get All User App Data path
        if (SHGetSpecialFolderPathA(0, szAllUserPath, CSIDL_COMMON_APPDATA, FALSE))
        {
            // Check if we have non DBCS path
            if (szAllUserPath[0] && !IsDBCSHere(szAllUserPath, strlen(szAllUserPath)))
            {
                CHAR    szNewTempPath[MAX_PATH*2] = "";
                DWORD   dwNewLen;

                dwNewLen = GetShortPathNameA(szAllUserPath, szNewTempPath, sizeof(szNewTempPath));
                // Add last back slash if not exist
                if (dwNewLen+1 < MAX_PATH*2 && szNewTempPath[dwNewLen-1] != 0x5c)
                {
                    szNewTempPath[dwNewLen] = 0x5c;
                    dwNewLen++;
                    szNewTempPath[dwNewLen] = 0;
                }
                if (dwNewLen < nBufferLength)
                {   // Enough space to return new path
                    if (S_OK == StringCchCopyA(lpBuffer, nBufferLength, szNewTempPath))
                    {
                        LOG("RedirectDBCSTempPath", eDbgLevelInfo, "GetTempPathA() is redirected to All User App Data.");
                        return (dwNewLen);
                    }
                }
                LOG("RedirectDBCSTempPath", eDbgLevelInfo, "nBufferLength is not sufficient.");
                return (dwNewLen + 1);
            }
        }
    }

    // Return original data
    LOG("RedirectDBCSTempPath", eDbgLevelInfo, "Returns original result.");
    if (dwLen < nBufferLength)
    {
        if (S_OK == StringCchCopyA(lpBuffer, nBufferLength, szTempPath))
        {
            return (dwLen);
        }
    }
    return (dwLen + 1);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetTempPathA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\removeipfrommsinfocommandline.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveIpFromMsInfoCommandLine.cpp   

 Abstract:

    Microsoft Streets & Trips 2000 specific hack. removing /p option when it 
    calls msinfo: Bug #30531

 Notes:

    This is a general purpose shim.

 History:

   02/23/2000 jarbats  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveIpFromMsInfoCommandLine)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessW) 
APIHOOK_ENUM_END

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    WCHAR *szTemp = NULL;

    if (lpCommandLine && wcsistr(lpCommandLine, L"msinfo32.exe"))
    {
        szTemp = wcsistr(lpCommandLine, L"/p");

        if (NULL != szTemp)
        {
            *szTemp ++ = L' ';
            *szTemp = L' ';
        }
    }
    
    return ORIGINAL_API(CreateProcessW)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\removeinvalidw2kwindowstyles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveInvalidW2KWindowStyles.cpp

 Abstract:

    Windows 2000 deems certain previously supported Windows style bits as 
    "invalid". This shim removes the newly invalidated style bits from the mask 
    which will allow the CreateWindowEx call to succeed.

 Notes:

    This is a general purpose shim.

 History:

    09/13/1999 markder  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveInvalidW2KWindowStyles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExW) 
APIHOOK_ENUM_END

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    // Defined in windows source as WS_INVALID50
    dwExStyle &= 0x85F77FF;         

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Remove invalid Windows 2000 style bits from dwExStyle mask before calling
 CreateWindowEx.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam 
    )
{
    dwExStyle &= 0x85F77FF;
    
    // Call the original API
    return ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\removenobufferingflagfromcreatefile.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RemoveNoBufferingFlagFromCreateFile.cpp

 Abstract:

    This modified version of kernel32!CreateFile* prevents an app from using
    the FILE_FLAG_NO_BUFFERING flag if the app doesn't handle it correctly.

 Notes:

    This is a general shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveNoBufferingFlagFromCreateFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
APIHOOK_ENUM_END


/*++

    Take out FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPSTR                 lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    //
    // Take out FILE_FLAG_NO_BUFFERING.
    //
    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING) {
        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] called with FILE_FLAG_NO_BUFFERING set.\n");
    }
    
    dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;

    return ORIGINAL_API(CreateFileA)(
                                lpFileName,
                                dwDesiredAccess,
                                dwShareMode,
                                lpSecurityAttributes,
                                dwCreationDisposition,
                                dwFlagsAndAttributes,
                                hTemplateFile);
}

/*++

    Take out FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileW)(
    LPWSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    //
    // Take out FILE_FLAG_NO_BUFFERING.
    //
    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING) {
        DPFN(
            eDbgLevelInfo,
            "[CreateFileW] called with FILE_FLAG_NO_BUFFERING set.\n");
    }
    
    dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;

    return ORIGINAL_API(CreateFileW)(
                                lpFileName,
                                dwDesiredAccess,
                                dwShareMode,
                                lpSecurityAttributes,
                                dwCreationDisposition,
                                dwFlagsAndAttributes,
                                hTemplateFile);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\removeoverlappedflagfromcreatefile.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RemoveOverlappedFlagFromCreateFile.cpp

 Abstract:

    This modified version of kernel32!CreateFile* prevents an app from using
    the FILE_FLAG_OVERLAPPED flag if the app doesn't handle it correctly.

 Notes:

    This is a general shim.

 History:

    06/22/2001 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveOverlappedFlagFromCreateFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
APIHOOK_ENUM_END

/*++

 Take out FILE_FLAG_OVERLAPPED if we are on a drive

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPSTR                 lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if ((dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED) &&
        (GetDriveTypeFromFileNameA(lpFileName) != DRIVE_UNKNOWN))
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_OVERLAPPED;
        LOGN(eDbgLevelInfo, "[CreateFileA] \"%s\": removed OVERLAPPED flag", lpFileName);
    }

    return ORIGINAL_API(CreateFileA)(lpFileName, dwDesiredAccess, dwShareMode,
        lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes,
        hTemplateFile);
}

/*++

 Take out FILE_FLAG_OVERLAPPED if we are on a drive

--*/

HANDLE
APIHOOK(CreateFileW)(
    LPWSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if ((dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED) &&
        (GetDriveTypeFromFileNameW(lpFileName) != DRIVE_UNKNOWN))
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_OVERLAPPED;
        LOGN(eDbgLevelInfo, "[CreateFileW] \"%S\": removed OVERLAPPED flag", lpFileName);
    }

    return ORIGINAL_API(CreateFileW)(lpFileName, dwDesiredAccess, dwShareMode,
        lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, 
        hTemplateFile);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\searchpathinapppaths.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   SearchPathInAppPaths.cpp

 Abstract:

   An application might use SearchPath to determine if a specific EXE is found
   in the current path.  Some applications have registered their path with the
   shell in "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\App Paths"
   If SearchPath fails, we'll check to see if the applications has registered a path.

 History:

   03/03/2000 robkenny  Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(SearchPathInAppPaths)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SearchPathA) 
APIHOOK_ENUM_END


  
DWORD 
APIHOOK(SearchPathA)(
    LPCSTR lpPath,       // search path
    LPCSTR lpFileName,   // file name
    LPCSTR lpExtension,  // file extension
    DWORD nBufferLength, // size of buffer
    LPSTR lpBuffer,      // found file name buffer
    LPSTR *lpFilePart    // file component
    )
{
    DWORD returnValue = ORIGINAL_API(SearchPathA)(
        lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);

    if (returnValue == 0 && lpFileName != NULL)
    {
        // Search failed, look in the registry.
        // First look for lpFileName.  If that fails, append lpExtension and look again.

        CSTRING_TRY
        {
            CString csReg(L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\");
            csReg += lpFileName;

            // Try looking for lpFileName exactly
            CString csValue;
            LONG success = RegQueryValueExW(csValue, HKEY_LOCAL_MACHINE, csReg, NULL);
            if (success == ERROR_SUCCESS)
            {
                // Found the value in the registry.
                // Verify that there is enough space in the output buffer
                if (nBufferLength < (DWORD)csValue.GetLength())
                {
                    // The return value is the size necessary to hold the path.
                    returnValue = csValue.GetLength() + 1;
                }
                else
                {                                                         
                    StringCchCopyA(lpBuffer, nBufferLength, csValue.GetAnsi());
                    returnValue = csValue.GetLength();
                }
            }

            if (returnValue == 0 && lpExtension)
            {
                // Append the extension onto the filename and try again

                csReg += lpExtension;

                LONG success = RegQueryValueExW(csValue, HKEY_LOCAL_MACHINE, csReg, NULL);
                if (success == ERROR_SUCCESS && csValue.GetLength() > 0)
                {
                    // Found the value in the registry.
                    // Verify that there is enough space in the output buffer
                    if (nBufferLength < (DWORD)csValue.GetLength())
                    {
                        // The return value is the size necessary to hold the path.
                        returnValue = csValue.GetLength() + 1;
                    }
                    else
                    {                                                         
                        StringCchCopyA(lpBuffer, nBufferLength, csValue.GetAnsi());
                        returnValue = csValue.GetLength();
                    }
                }
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, SearchPathA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\restoresystemcursors.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    RestoreSystemCursors.cpp

 Abstract:

    Due to a bug in NT, cursors are not correctly restored with the following
    code sequence:

        1. hNewCursor = LoadCursor(0, "cursor.cur");
        2. SetSystemCursor(hNewCursor, OCR_NORMAL)
        3. hOldCursor = LoadCursor(0,MAKEINTRESOURCE(OCR_NORMAL));
        4. SetSystemCursor(hOldCursor, OCR_NORMAL)

    The last call (4) does nothing on NT, but works correctly on Win9x. 
    
    To fix this we use the known USER workaround, namely CopyCursor. Note that 
    this will probably be fixed in Whistler by the time it ships.
    
 Notes:

    This is a general purpose shim.

 History:

    02/13/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RestoreSystemCursors)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

#define OCR_NORMAL          32512UL
#define OCR_IBEAM           32513UL
#define OCR_WAIT            32514UL
#define OCR_CROSS           32515UL
#define OCR_UP              32516UL
#define OCR_SIZE            32640UL   
#define OCR_ICON            32641UL   
#define OCR_SIZENWSE        32642UL
#define OCR_SIZENESW        32643UL
#define OCR_SIZEWE          32644UL
#define OCR_SIZENS          32645UL
#define OCR_SIZEALL         32646UL
#define OCR_ICOCUR          32647UL   
#define OCR_NO              32648UL
#define OCR_HAND            32649UL
#define OCR_APPSTARTING     32650UL

struct CURSOR 
{
    DWORD id;
    HCURSOR hCursor;
};

CURSOR g_arrCursors[] = 
{
    {OCR_NORMAL,        0},
    {OCR_IBEAM,         0},
    {OCR_WAIT,          0},
    {OCR_CROSS,         0},
    {OCR_UP,            0},
    {OCR_SIZE,          0},
    {OCR_ICON,          0},
    {OCR_SIZENWSE,      0},
    {OCR_SIZENESW,      0},
    {OCR_SIZEWE,        0},
    {OCR_SIZENS,        0},
    {OCR_SIZEALL,       0},
    {OCR_ICOCUR,        0},
    {OCR_NO,            0},
    {OCR_HAND,          0},
    {OCR_APPSTARTING,   0}
};

BOOL g_bInit = FALSE;

/*++

 Backup cursors.

--*/

VOID 
BackupCursors()
{
    if (!g_bInit) 
    {
        g_bInit = TRUE;

        // Backup all the cursors
        for (int i=0; i<sizeof(g_arrCursors)/sizeof(CURSOR);i++)
        {
            HCURSOR hCursorT = LoadCursor(0,MAKEINTRESOURCE(g_arrCursors[i].id));
            
            if (hCursorT)
            {
                g_arrCursors[i].hCursor = CopyCursor(hCursorT);
                DestroyCursor(hCursorT);
            }
            else
            {
                g_arrCursors[i].hCursor = 0;
            }
        }
    }
}

/*++

 Restore cursors.

--*/

VOID
RestoreCursors()
{
    if (g_bInit) 
    {
        // Restore all the cursors
        for (int i=0; i<sizeof(g_arrCursors)/sizeof(CURSOR);i++)
        {
            if (g_arrCursors[i].hCursor)
            {
                SetSystemCursor(g_arrCursors[i].hCursor, g_arrCursors[i].id);
                DestroyCursor(g_arrCursors[i].hCursor);
            }
        }
    }
}

/*++

 Backup cursors.

--*/

LPSTR 
APIHOOK(GetCommandLineA)()
{
    BackupCursors();
    return ORIGINAL_API(GetCommandLineA)();
}

/*++

 Backup cursors.

--*/

LPWSTR 
APIHOOK(GetCommandLineW)()
{
    BackupCursors();
    return ORIGINAL_API(GetCommandLineW)();
}
 
/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        RestoreCursors();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\removereadonlyattribute.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    RemoveReadOnlyAttribute.cpp

 Abstract:

    Removes read only attributes from directories: used to fix some apps that 
    aren't used to shell folders being read-only.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000  a-jamd      Created
    12/02/2000  linstev     Separated functionality into 2 shims: this one and EmulateCDFS
    03/12/2002  robkenny    Security review

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RemoveReadOnlyAttribute)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)        
    APIHOOK_ENUM_ENTRY(FindFirstFileW)         
    APIHOOK_ENUM_ENTRY(FindFirstFileA)             
    APIHOOK_ENUM_ENTRY(FindNextFileW)             
    APIHOOK_ENUM_ENTRY(FindNextFileA)              
    APIHOOK_ENUM_ENTRY(GetFileInformationByHandle)
APIHOOK_ENUM_END


/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesA)(LPCSTR lpFileName)
{    
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesA)(lpFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[GetFileAttributesA] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesW)(LPCWSTR wcsFileName)
{
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesW)(wcsFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[GetFileAttributesW] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName, 
    LPWIN32_FIND_DATAA lpFindFileData
    )
{    
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit
        LOGN( eDbgLevelWarning, "[FindFirstFileA] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR wcsFileName, 
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileW)(wcsFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // It's a directory: flip the read-only bit
        LOGN( eDbgLevelInfo, "[FindFirstFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileA)(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAA lpFindFileData 
    )
{    
    BOOL bRet = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[FindNextFileA] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileW)(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAW lpFindFileData 
    )
{
    BOOL bRet = ORIGINAL_API(FindNextFileW)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit
        LOGN( eDbgLevelWarning, "[FindNextFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(GetFileInformationByHandle)( 
    HANDLE hFile, 
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation 
    )
{
    BOOL bRet = ORIGINAL_API(GetFileInformationByHandle)(hFile, lpFileInformation);

    if (bRet &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Flip the read-only bit.
        LOGN( eDbgLevelWarning, "[GetFileInformationByHandle] Removing FILE_ATTRIBUTE_READONLY");
        lpFileInformation->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW);
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA);
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileInformationByHandle);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\setenvironmentvariable.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SetEnvironmentVariable.cpp

 Abstract:

    mapi dlls don't ship with w2k, and with outlook2000 it gets installed in a different
    location (%commonprogramfiles%)
    resumemaker and possibly others depend on mapi dlls being in system32 directory.
    Command line syntax is "envvariablename|envvariablevalue|envvariablename|envvariablevalue"

 Notes:

    This is an app specific shim.

 History:

    07/02/2000 jarbats  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SetEnvironmentVariable)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Set environment variables in the command line to get some dll path resolutions correct.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        char *CmdLine = COMMAND_LINE;
        char *lpstrEnvName;
        char *lpstrEnvVal;

        for (;;)
        {
            lpstrEnvName = lpstrEnvVal = CmdLine;        

            while (*CmdLine && (*CmdLine != '|')) CmdLine++;

            if (*CmdLine == '|')
            {
                *CmdLine = '\0';
                CmdLine++;
            }
        
            lpstrEnvVal = CmdLine;                       

            if (0 == *lpstrEnvVal) 
            {
                break;
            }
  
            CSTRING_TRY
            {
                CString csEnvValue(lpstrEnvVal);
                if (csEnvValue.ExpandEnvironmentStringsW() > 0)
                {
                    if (SetEnvironmentVariableA(lpstrEnvName, csEnvValue.GetAnsi()))
                    {           
                        DPFN( eDbgLevelInfo, "Set %s to %s\n", lpstrEnvName, csEnvValue.GetAnsi());
                    }
                    else
                    {
                        DPFN( eDbgLevelInfo, "No Success setting %s to %s\n", lpstrEnvName, lpstrEnvVal);
                    }
                }
            }
            CSTRING_CATCH
            {
                // Do nothing
            }

            while (*CmdLine && (*CmdLine == '|')) CmdLine++;
        }
    }

    return TRUE;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

TARGETNAME=AcGenral

TARGETTYPE=DYNLINK

INCLUDES=$(INCLUDES);                              \
         ..;                                       \
         $(SHELL_INC_PATH)

SOURCES=..\general.rc                              \
        ..\Main.cpp                                \
        ..\AddProcessParametersFlags.cpp           \
        ..\AliasDXDC.cpp                           \
        ..\CorrectACMArgs.cpp                      \
        ..\CorrectACMStreamOpen.cpp                \
        ..\CorrectActiveMoviePath.cpp              \
        ..\CorrectCreateIcon.cpp                   \
        ..\CorrectCreateSurface.cpp                \
        ..\CorrectFarEastFont.cpp                  \
        ..\CorrectFilePathInSetDlgItemText.cpp     \
        ..\CorrectFilePathsUninstall.cpp           \
        ..\CorrectOpenFileExclusive.cpp            \
        ..\CorrectVerInstallFile.cpp               \
        ..\CUASAppFix.cpp                          \
        ..\CUASDisableCicero.cpp                   \
        ..\DelayDllInit.cpp                        \
        ..\DelayShowGroup.cpp                      \
        ..\DelayWin95VersionLie.cpp                \
        ..\DelayWinMMCallback.cpp                  \
        ..\DeleteSpecifiedFiles.cpp                \
        ..\DeRandomizeExeName.cpp                  \
        ..\DisableBoostThread.cpp                  \
        ..\DisableFilterKeys.cpp                   \
        ..\DisableScreenSaver.cpp                  \
        ..\DisableStickyKeys.cpp                   \
        ..\DisableW2KOwnerDrawButtonStates.cpp     \
        ..\EmptyClipboardtoSet.cpp                 \
        ..\EmulateGetStdHandle.cpp                 \
        ..\EmulateGetStringType.cpp                \
        ..\EmulateGetUIEffects.cpp                 \
        ..\EmulateLZHandles.cpp                    \
        ..\EnlargeGetObject.cpp                    \
        ..\ExtractAssociatedIcon.cpp               \
        ..\FailCloseProfileUserMapping.cpp         \
        ..\FailGetStdHandle.cpp                    \
        ..\FailObsoleteShellAPIs.cpp               \
        ..\FailOpenFile.cpp                        \
        ..\FakeThemeMetrics.cpp                    \
        ..\FilterNetworkResources.cpp              \
        ..\FixServiceStartupCircularDependency.cpp \
        ..\Force640x480x8.cpp                      \
        ..\Force640x480x16.cpp                     \
        ..\ForceAdminAccess.cpp                    \
        ..\ForceAnsiWindowProc.cpp                 \
        ..\ForceAppendMenuSuccess.cpp              \
        ..\ForceApplicationFocus.cpp               \
        ..\ForceAVIWindow.cpp                      \
        ..\ForceDefaultSystemPaletteEntries.cpp    \
        ..\ForceDirectDrawEmulation.cpp            \
        ..\ForceDirectDrawWait.cpp                 \
        ..\ForceDisplayMode.cpp                    \
        ..\ForceSeparateVDM.cpp                    \
        ..\ForceSimpleWindow.cpp                   \
        ..\ForceTemporaryModeChange.cpp            \
        ..\ForceWorkingDirectoryToEXEPath.cpp      \
        ..\FUSAPI.cpp                              \
        ..\FUSBadApplicationType1.cpp              \
        ..\FUSBadApplicationType2.cpp              \
        ..\FUSBadApplicationType3.cpp              \
        ..\FUSBadApplicationType4.cpp              \
        ..\GetVolumeInformationLie.cpp             \
        ..\GlobalMemoryStatusLie.cpp               \
        ..\GlobalMemoryStatusTrim.cpp              \
        ..\HandleDBCSUserName.cpp                  \
        ..\HandleDBCSUserName2.cpp                 \
        ..\HandleEmptyAccessCheck.cpp              \
        ..\HeapClearAllocation.cpp                 \
        ..\HeapDelayLocalFree.cpp                  \
        ..\HeapForceGrowable.cpp                   \
        ..\HeapIgnoreMoveable.cpp                  \
        ..\HeapLookasideFree.cpp                   \
        ..\HeapPadAllocation.cpp                   \
        ..\HeapValidateFrees.cpp                   \
        ..\HideCursor.cpp                          \
        ..\HideTaskBar.cpp                         \
        ..\IEUnHarden.cpp                          \
        ..\IgnoreAltTab.cpp                        \
        ..\IgnoreCoCreateInstance.cpp              \
        ..\IgnoreCRTExit.cpp                       \
        ..\IgnoreDebugOutput.cpp                   \
        ..\IgnoreFreeLibrary.cpp                   \
        ..\IgnoreHungAppPaint.cpp                  \
        ..\IgnoreMCIStop.cpp                       \
        ..\IgnoreMessageBox.cpp                    \
        ..\IgnoreNoModeChange.cpp                  \
        ..\IgnoreOemToChar.cpp                     \
        ..\IgnoreSysColChanges.cpp                 \
        ..\IgnoreTAPIDisconnect.cpp                \
        ..\IgnoreVBOverflow.cpp                    \
        ..\IgnoreZeroMoveWindow.cpp                \
        ..\InjectDll.cpp                           \
        ..\KeepWindowOnMonitor.cpp                 \
        ..\LazyReleaseDC.cpp                       \
        ..\LimitFindFile.cpp                       \
        ..\LoadComctl32Version5.cpp                \
        ..\LoadLibraryCWD.cpp                      \
        ..\LowerThreadPriority.cpp                 \
        ..\MoveIniToRegistry.cpp                   \
        ..\MoveWinInitRenameToReg.cpp              \
        ..\NullHwndInMessageBox.cpp                \
        ..\PaletteRestore.cpp                      \
        ..\PopulateDefaultHKCUSettings.cpp         \
        ..\PropagateProcessHistory.cpp             \
        ..\RecopyEXEFromCD.cpp                     \
        ..\RedirectDBCSTempPath.cpp                \
        ..\RedirectEXE.cpp                         \
        ..\RedirectWindowsDirToSystem32.cpp        \
        ..\RemoveBroadcastPostMessage.cpp          \
        ..\RemoveDDEFlagFromShellExecuteEx.cpp     \
        ..\RemoveInvalidW2KWindowStyles.cpp        \
        ..\RemoveIpFromMsInfoCommandLine.cpp       \
        ..\RemoveNoBufferingFlagFromCreateFile.cpp \
        ..\RemoveOverlappedFlagFromCreateFile.cpp  \
        ..\RemoveReadOnlyAttribute.cpp             \
        ..\RestoreSystemCursors.cpp                \
        ..\SearchPathInAppPaths.cpp                \
        ..\SetEnvironmentVariable.cpp              \
        ..\StackSwap_Exports.cpp                   \
        ..\StackSwap.cpp                           \
        ..\TerminateExe.cpp                        \
        ..\TrimVersionInfo.cpp                     \
        ..\UnMirrorImageList.cpp                   \
        ..\WaveOutUsePreferredDevice.cpp           \
        ..\WinG32SysToSys32.cpp

C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\winmm.lib            \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\msacm32.lib          \
           $(SDK_LIB_PATH)\version.lib          \
           $(SDK_LIB_PATH)\shell32.lib          \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\userenv.lib          \
           $(SDBAPI_PATH)\lib\$(O)\sdbapil.lib


DLLBASE=0x22000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\stackswap_exports.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Exports.cpp

 Abstract:

    Helper functions for enumerating module exports.
    
 Notes:

    Although only used by the stack swapping shim, it may later be included in
    the library, since it's general.

    Most of these routines are copied out of the source for imagehlp.dll. We 
    are not including this dll since it doesn't work in the Win2K shim layer.

 History:

    05/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(StackSwap)
#include "StackSwap_Exports.h"

// User APIs
BOOL LoadModule(PCSTR lpName, PLOADED_IMAGE lpImage);
BOOL UnloadModule(PLOADED_IMAGE lpImage);
BOOL EnumFirstExport(PLOADED_IMAGE lpImage, PEXPORT_ENUM lpExports);
BOOL EnumNextExport(PEXPORT_ENUM lpExports);

// Internal APIs
BOOL CalculateImagePtrs(PLOADED_IMAGE lpImage);
PIMAGE_SECTION_HEADER ImageRvaToSection(PIMAGE_NT_HEADERS NtHeaders, PVOID Base, ULONG Rva);
PVOID ImageRvaToVa(PIMAGE_NT_HEADERS NtHeaders, PVOID Base, ULONG Rva, PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL);
PVOID ImageDirectoryEntryToData32(PVOID Base, BOOLEAN MappedAsImage, USHORT DirectoryEntry, PULONG Size, PIMAGE_SECTION_HEADER *FoundSection OPTIONAL, PIMAGE_FILE_HEADER FileHeader, PIMAGE_OPTIONAL_HEADER32 OptionalHeader);
PVOID ImageDirectoryEntryToData(PVOID Base, BOOLEAN MappedAsImage, USHORT DirectoryEntry, PULONG Size);

/*++

 Open a file handle to a module and map it's image.

--*/

BOOL
LoadModule(
    PCSTR lpName,
    PLOADED_IMAGE lpImage
    )
{
    HANDLE hFile;
    CHAR szSearchBuffer[MAX_PATH];
    DWORD dwLen;
    LPSTR lpFilePart;
    LPSTR lpOpenName;
    BOOL bRet = FALSE;
    
    ZeroMemory(lpImage, sizeof(LOADED_IMAGE));

    lpOpenName = (PSTR)lpName;
    dwLen = 0;

Retry:
    hFile = CreateFileA(
                lpOpenName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

    if (hFile == INVALID_HANDLE_VALUE) 
    {
        if (!dwLen) 
        {
            //
            // open failed try to find the file on the search path
            //

            dwLen = SearchPathA(
                NULL,
                lpName,
                ".DLL",
                MAX_PATH,
                szSearchBuffer,
                &lpFilePart
                );

            if (dwLen && dwLen < MAX_PATH) 
            {
                lpOpenName = szSearchBuffer;
                goto Retry;
            }
        }

        goto Exit;
    }

    lpImage->hFile = hFile;

    HANDLE hFileMap;

    hFileMap = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL);

    if (!hFileMap) 
    {
        goto Exit;
    }

    lpImage->MappedAddress = (PUCHAR) MapViewOfFile(
        hFileMap,
        FILE_MAP_READ,
        0,
        0,
        0
        );

    CloseHandle(hFileMap);

    lpImage->SizeOfImage = GetFileSize(hFile, NULL);

    if (!lpImage->MappedAddress ||
        !CalculateImagePtrs(lpImage)) 
    {
        goto Exit;
    }

    bRet = TRUE;

Exit:
    if (bRet == FALSE)
    {
        CloseHandle(hFile);
        UnmapViewOfFile(lpImage->MappedAddress);
    }

    return bRet;
}

/*++

 Helper function for LoadImage. Fill in all the pointers in a LOADED_IMAGE 
 structure.

--*/

BOOL
CalculateImagePtrs(
    PLOADED_IMAGE lpImage
    )
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_FILE_HEADER FileHeader;
    BOOL bRet;

    // Everything is mapped. Now check the image and find nt image headers

    bRet = TRUE;  // Assume the best

    __try 
    {
        DosHeader = (PIMAGE_DOS_HEADER)lpImage->MappedAddress;

        if ((DosHeader->e_magic != IMAGE_DOS_SIGNATURE) &&
            (DosHeader->e_magic != IMAGE_NT_SIGNATURE)) 
        {
            bRet = FALSE;
            goto tryout;
        }

        if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) 
        {
            if (DosHeader->e_lfanew == 0) 
            {
                lpImage->fDOSImage = TRUE;
                bRet = FALSE;
                goto tryout;
            }
            lpImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

            // If IMAGE_NT_HEADERS would extend past the end of file...
            if ((PBYTE)lpImage->FileHeader + sizeof(IMAGE_NT_HEADERS) >
                (PBYTE)lpImage->MappedAddress + lpImage->SizeOfImage ||

                 // ..or if it would begin in, or before the IMAGE_DOS_HEADER...
                (PBYTE)lpImage->FileHeader <
                (PBYTE)lpImage->MappedAddress + sizeof(IMAGE_DOS_HEADER))
            {
                // ...then e_lfanew is not as expected.
                // (Several Win95 files are in this category.)
                bRet = FALSE;
                goto tryout;
            }
        } 
        else 
        {
            // No DOS header indicates an image built w/o a dos stub
            lpImage->FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader);
        }

        NtHeaders = lpImage->FileHeader;

        if ( NtHeaders->Signature != IMAGE_NT_SIGNATURE ) 
        {
            if ((USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE ||
                (USHORT)NtHeaders->Signature == (USHORT)IMAGE_OS2_SIGNATURE_LE)
            {
                lpImage->fDOSImage = TRUE;
            }

            bRet = FALSE;
            goto tryout;

        } 
        else 
        {
            lpImage->fDOSImage = FALSE;
        }

        FileHeader = &NtHeaders->FileHeader;

        // No optional header indicates an object...

        if (FileHeader->SizeOfOptionalHeader == 0) 
        {
            bRet = FALSE;
            goto tryout;
        }

        if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) 
        {
            // 32-bit image.  Do some tests.
            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.ImageBase >= 0x80000000) 
            {
                lpImage->fSystemImage = TRUE;
            } 
            else 
            {
                lpImage->fSystemImage = FALSE;
            }

            if (((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MajorLinkerVersion < 3 &&
                ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.MinorLinkerVersion < 5)
            {
                bRet = FALSE;
                goto tryout;
            }

        } 
        else 
        {
            lpImage->fSystemImage = FALSE;
        }

        lpImage->Sections = IMAGE_FIRST_SECTION(NtHeaders);
        lpImage->Characteristics = FileHeader->Characteristics;
        lpImage->NumberOfSections = FileHeader->NumberOfSections;
        lpImage->LastRvaSection = lpImage->Sections;
tryout:
    ;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER ) 
    {
        bRet = FALSE;
    }

    return bRet;
}


/*++

 Unmap the loaded image.

--*/

BOOL
UnloadModule(
    PLOADED_IMAGE lpImage
    )
{
    UnmapViewOfFile(lpImage->MappedAddress);
    CloseHandle(lpImage->hFile);

    return TRUE;
}

/*++

 Description:

    Locates an RVA within the image header of a file that is mapped as a file and 
    returns a pointer to the section table entry for that virtual address.

 Arguments:

    NtHeaders - pointer to the image or data file
    Base      - base of the image or data file
    Rva       - relative virtual address (RVA) to locate

 Returns:

    NULL      - no data for the specified directory entry
    NON-NULL  - pointer of the section entry containing the data

--*/

PIMAGE_SECTION_HEADER
ImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID /*Base*/,
    IN ULONG Rva
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION(NtHeaders);

    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) 
    {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData) 
        {
            return NtSection;
        }

        ++NtSection;
    }

    return NULL;
}

/*++

 Description:

    This function locates an RVA within the image header of a file that is 
    mapped as a file and returns the virtual addrees of the corresponding 
    byte in the file.

 Arguments:

    NtHeaders - pointer to the image or data file.
    Base      - base of the image or data file.
    Rva       - relative virtual address (RVA) to locate.
    LastRvaSection - optional parameter that if specified, points to a variable
                that contains the last section value used for the specified 
                image to translate and RVA to a VA.

 Returns:

    NULL      - does not contain the specified RVA
    NON-NULL  - virtual address in the mapped file.

--*/

PVOID
ImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )
{
    PIMAGE_SECTION_HEADER NtSection;

    if (LastRvaSection == NULL ||
        (NtSection = *LastRvaSection) == NULL ||
        NtSection == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData) 
    {
        NtSection = NS_StackSwap::ImageRvaToSection(
            NtHeaders,
            Base,
            Rva);
    }

    if (NtSection != NULL) 
    {
        if (LastRvaSection != NULL) 
        {
            *LastRvaSection = NtSection;
        }

        return (PVOID)((ULONG_PTR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData);
    }
    else 
    {
        return NULL;
    }
}

/*++

 See ImageDirectoryEntryToData.

--*/

PVOID
ImageDirectoryEntryToData32(
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    OUT PIMAGE_SECTION_HEADER *FoundSection OPTIONAL,
    IN PIMAGE_FILE_HEADER FileHeader,
    IN PIMAGE_OPTIONAL_HEADER32 OptionalHeader
    )
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;
    ULONG DirectoryAddress;

    if (DirectoryEntry >= OptionalHeader->NumberOfRvaAndSizes) 
    {
        *Size = 0;
        return( NULL );
    }

    if (!(DirectoryAddress = OptionalHeader->DataDirectory[ DirectoryEntry ].VirtualAddress)) 
    {
        *Size = 0;
        return( NULL );
    }
    
    *Size = OptionalHeader->DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < OptionalHeader->SizeOfHeaders) 
    {
        if (FoundSection) 
        {
            *FoundSection = NULL;
        }
        return ((PVOID)((ULONG_PTR)Base + DirectoryAddress));
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                        FileHeader->SizeOfOptionalHeader);

    for (i=0; i<FileHeader->NumberOfSections; i++) 
    {
        if (DirectoryAddress >= NtSection->VirtualAddress &&
           DirectoryAddress < NtSection->VirtualAddress + NtSection->SizeOfRawData) 
        {
            if (FoundSection) 
            {
                *FoundSection = NtSection;
            }
            
            return( (PVOID)((ULONG_PTR)Base + (DirectoryAddress - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }

        ++NtSection;
    }

    return( NULL );
}

/*++

 Description:

    This function locates a directory entry within the image header and returns 
    either the virtual address or seek address of the data the Directory 
    describes.  It may optionally return the section header, if any, for the 
    found data.

 Arguments:

    Base           - base of the image or data file.
    MappedAsImage  - FALSE if the file is mapped as a data file.
                   - TRUE if the file is mapped as an image.
    DirectoryEntry - directory entry to locate.
    Size           - return the size of the directory.
    FoundSection   - Returns the section header, if any, for the data

 Returns:

    NULL           - The file does not contain data for the specified directory entry.
    NON-NULL       - Returns the address of the raw data the directory describes.

--*/

PVOID
ImageDirectoryEntryToData(
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;

    if ((ULONG_PTR)Base & 0x00000001) 
    {
        Base = (PVOID)((ULONG_PTR)Base & ~0x1);
        MappedAsImage = FALSE;
     }

    NtHeader = RtlpImageNtHeader(Base);

    if (NtHeader) 
    {
        FileHeader = &NtHeader->FileHeader;
        OptionalHeader = &NtHeader->OptionalHeader;
    } 
    else 
    {
        // Handle case where Image passed in doesn't have a dos stub (ROM images for instance);
        FileHeader = (PIMAGE_FILE_HEADER)Base;
        OptionalHeader = (PIMAGE_OPTIONAL_HEADER) ((ULONG_PTR)Base + IMAGE_SIZEOF_FILE_HEADER);
    }

    if (OptionalHeader->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) 
    {
        return (ImageDirectoryEntryToData32(
            Base,
            MappedAsImage,
            DirectoryEntry,
            Size,
            NULL,
            FileHeader,
            (PIMAGE_OPTIONAL_HEADER32)OptionalHeader));
    } 
    else
    {
        return NULL;
    }
}

/*++

 Enumerate the first exported function.

--*/

BOOL
EnumFirstExport(
    PLOADED_IMAGE lpImage,
    PEXPORT_ENUM lpExports
    )
{
    ULONG imageSize;

    ZeroMemory (lpExports, sizeof (EXPORT_ENUM));

    lpExports->Image = lpImage;

    lpExports->ImageDescriptor = (PIMAGE_EXPORT_DIRECTORY)
        ImageDirectoryEntryToData(
            lpImage->MappedAddress,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_EXPORT,
            &imageSize);

    if (!lpExports->ImageDescriptor) 
    {
        //DPF(eDbgLevelError, "Cannot load export directory for %s", lpImage->ModuleName);
        return FALSE;
    }

    if (lpExports->ImageDescriptor->NumberOfNames == 0) 
    {
        return FALSE;
    }

    lpExports->ExportNamesAddr = (PDWORD) NS_StackSwap::ImageRvaToVa(
        lpExports->Image->FileHeader,
        lpExports->Image->MappedAddress,
        lpExports->ImageDescriptor->AddressOfNames,
        NULL);

    lpExports->ExportOrdAddr = (PUSHORT) NS_StackSwap::ImageRvaToVa(
        lpExports->Image->FileHeader,
        lpExports->Image->MappedAddress,
        lpExports->ImageDescriptor->AddressOfNameOrdinals,
        NULL
        );

    lpExports->CurrExportNr = 0;

    return EnumNextExport(lpExports);
}

/*++

 Enumerate the next exported function.

--*/

BOOL
EnumNextExport(
    IN OUT  PEXPORT_ENUM lpExports
    )
{
    if (lpExports->CurrExportNr >= lpExports->ImageDescriptor->NumberOfNames) 
    {
        return FALSE;
    }

    if (*lpExports->ExportNamesAddr == 0) 
    {
        return FALSE;
    }

    lpExports->ExportFunction = (CHAR *)NS_StackSwap::ImageRvaToVa(
        lpExports->Image->FileHeader,
        lpExports->Image->MappedAddress,
        *lpExports->ExportNamesAddr,
        NULL);

    lpExports->ExportFunctionOrd = *lpExports->ExportOrdAddr + 
        lpExports->ImageDescriptor->Base;

    lpExports->ExportNamesAddr++;
    lpExports->ExportOrdAddr++;
    lpExports->CurrExportNr++;

    return (lpExports->ExportFunction != NULL);
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\stackswap.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    StackSwap.cpp

 Abstract:

    Some applications make the assumption that Win32 APIs don't use any stack 
    space. This stems from the architecture of win9x - whereby many APIs 
    thunked and therefore had there own stack.

    Of course on NT this isn't the case and many APIs are normal user mode 
    functions that don't even call down to kernel. To make matters worse, some
    applications depend on *no* stack usage in a number of other ways, for 
    example:

        1. Sierra Cart racing keeps a pointer in old stack
        2. Baldur's Gate *double* dereferences pointers in old stack
        3. NFL Blitz keeps it's linked lists on the stack and so simply calling 
           an API causes corruption 
        4. NFL Blitz 2000 runs out of stack space calling CreateFile
        5. Interplay EReg has uninitialized variables on the stack which are 
           normally zeroed on win9x

    This shim is parameterized and takes a list of APIs and the behavior of 
    each. Behavior is defined as the following:

          - No stack is used by this API
        0 - After API is called, old stack will be filled with zeroes
        1 - After API is called, old stack will be filled with valid pointers
        2 - After API is called, old stack will be filled with valid pointers 
            to pointers

    The default is that no stack space is used by the API.

 Notes:

    This is a general purpose shim.

 History:

    05/03/2000  linstev     Created
    03/12/2001  robkenny    Blessed for DBCS
    02/07/2002  astritz     Converted to strsafe

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(StackSwap)
#include "ShimHookMacro.h"
#include "ShimStack.h"
#include "StackSwap_Exports.h"
#include "StackSwap_Excludes.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateThread) 
    APIHOOK_ENUM_ENTRY(TerminateThread) 
    APIHOOK_ENUM_ENTRY(ExitThread) 
APIHOOK_ENUM_END


#define THREAD_VAR       Vdm        // The TEB variable to overwrite

#define STUB_SIZE        64         // size of stub code in bytes
#define STACK_SIZE       65536      // size of temporary stack
#define STACK_COPY_SIZE  16         // number of dwords to copy from old stack
#define STACK_FILL_SIZE  256        // default number of dwords to fill
#define STACK_GUARD_SIZE 4096       // gaurd page at the top of the stack - must be a multiple of 4096

#define STACK_FILL_NONE -1          // no old stack filling
#define STACK_FILL_ZERO  0          // fill old stack with zeroes
#define STACK_FILL_PTR1  1          // fill old stack with pointers
#define STACK_FILL_PTR2  2          // fill old stack with pointers to pointers

PVOID g_dwZero = 0;                 // used for pointer to zero
PVOID g_dwPtr = &g_dwPtr;           // used for pointer to pointer

PVOID g_arrFill[] = 
{
    0, 
    &g_dwZero,
    &g_dwPtr 
};

// Store for each hook returned by the parser

struct HOOK
{
    char szModule[MAX_PATH];        // Module name
    char szFnName[MAX_PATH];        // Function name
    PVOID pfnNew;                   // Pointer to stub
    int dwFill;                     // Stack fill type
    DWORD dwFillSize;               // Number of dwords to fill
    struct HOOK *next;              
};
HOOK *g_pHooks = NULL;

HOOK g_AllHooks[] =
{
    {"KERNEL32.DLL", "*", NULL, STACK_FILL_NONE},
    {"GDI32.DLL",    "*", NULL, STACK_FILL_NONE},
    {"USER32.DLL",   "*", NULL, STACK_FILL_NONE},
    {"WINMM.DLL",    "*", NULL, STACK_FILL_NONE}
};

DWORD dwStubCount = 0;

// Thread local data

typedef struct _THREAD_DATA
{
    PVOID pfnHook;                  // Address of actual call
    PVOID pNewStack;                // The new stack
    PVOID pOldStack;                // The old stack
    DWORD dwFill;                   // Fill method
    DWORD dwFillSize;               // Number of dwords to fill
    ULONG ulCount;                  // Number of times we've entered 
    DWORD dwRet;                    // Return value 
    DWORD dwEcx, dwEsi, dwEdi;      // Tempory storage, since we don't have a stack
} THREAD_DATA;

/*++

 This function is called from the stubs. It's purpose is to give the API a new 
 stack to use. It does this by doing the following:

    1. Copy the original stack to the new stack
    2. Call the original hook
    3. Copy the changed stack back to the original stack
    4. Return control to the original caller

 The only tricky things about this routine are that we don't want to use any 
 stack at all (no push/pop) and we need to calculate how much stack was used
 for the parameters - something we don't know because we don't have the proto-
 type. 
 
 If we really wanted to use push and pop, we could have set up a temporary 
 stack, but since we only need ecx, esi and edi, there didn't seem to be any 
 point.

--*/

__declspec(naked)
void 
SwapStack()
{
    __asm {
        inc  [eax + THREAD_DATA.ulCount]            // increment counter

        mov  [eax + THREAD_DATA.dwEcx], ecx         // backup ecx
        mov  [eax + THREAD_DATA.dwEsi], esi         // backup esi
        mov  [eax + THREAD_DATA.dwEdi], edi         // backup edi

        mov  ecx, [esp]                             // retrieve 'Hook' from Stub()
        mov  [eax + THREAD_DATA.pfnHook], ecx       // which we got from the call
        add  esp, 4                                 // move the stack up to the return address

        mov  dword ptr [esp], offset SwapBack       // fill in our new return address

        lea  edi, [esp + 4]                         // dst = new stack
        mov  esi, [eax + THREAD_DATA.pOldStack]     // src = old stack
        add  esi, 4                                 // note the +4s since the first dword is the return address

        cld                                         // clear direction flag
        mov  ecx, STACK_COPY_SIZE - 1               // copy off STACK_COPY_SIZE - 1 bytes
        rep  movsd                                  // do the copy

        mov  ecx, [eax + THREAD_DATA.dwEcx]         // restore ecx
        mov  esi, [eax + THREAD_DATA.dwEsi]         // restore esi
        mov  edi, [eax + THREAD_DATA.dwEdi]         // restore edi

        jmp  [eax + THREAD_DATA.pfnHook]            // jump back into the stub to do the actual

    SwapBack:

        mov  [esp - 4], eax                         // unfortunately this is the only way to store the return 

        mov  eax, fs:[0x18]                         // get the TEB
        mov  eax, [eax + TEB.THREAD_VAR]            // get our thread local pointer

        mov  [eax + THREAD_DATA.dwEcx], ecx         // backup ecx
        mov  [eax + THREAD_DATA.dwEsi], esi         // backup esi
        mov  [eax + THREAD_DATA.dwEdi], edi         // backup edi

        mov  ecx, [esp - 4]                         // get return value
        mov  [eax + THREAD_DATA.dwRet], ecx         // store return value for later

        mov  ecx, esp                               // this is where we find out how many parameters were passed
        sub  ecx, [eax + THREAD_DATA.pNewStack]     // on the stack - so we get the difference in ecx

        mov  edi, [eax + THREAD_DATA.pOldStack]     // original stack
        mov  esi, [edi]                             // read the real return address
        add  edi, ecx                               // move the stack up, so we don't copy unnecessay stack
        mov  [edi - 4], esi                         // put the return address into edi-4: this is the only time we
                                                    //  use app stack space at all
        mov  esp, edi

        mov  ecx, [eax + THREAD_DATA.dwFill]        // test how we're going to fill 
        cmp  ecx, STACK_FILL_NONE
        jz   FillDone

        mov  esi, [ecx*4 + g_arrFill]               // value to fill with

        lea  edi, [esp - 8]                         // we're going to fill backwards, so esp-8 will skip the return address
        mov  ecx, [eax + THREAD_DATA.dwFillSize]    // number of dwords to fill with

    FillStack:
        mov  [edi], esi                             // store the value
        sub  edi, 4                                 
        dec  ecx
        jnz  FillStack

    FillDone:

        mov  ecx, [eax + THREAD_DATA.dwEcx]         // restore ecx
        mov  esi, [eax + THREAD_DATA.dwEsi]         // restore esi
        mov  edi, [eax + THREAD_DATA.dwEdi]         // restore edi
        
        dec  [eax + THREAD_DATA.ulCount]            // decrement counter

        mov  eax, [eax + THREAD_DATA.dwRet]         // get the return value
        jmp  dword ptr [esp - 4]                    // return to original caller
    }
}

//
// We need the stub to do a far call to SwapStack since the stub will move, but
// I can't seem to force the far call without this method
//

DWORD_PTR g_pfnStackSwap = (DWORD_PTR)SwapStack;

/*++

  This is the stub function that is called by every API. It is copied from here 
  to blocks of executable memory and the calls and fill types are written to 
  hard coded addresses within it.

  The instuctions:

    mov  [eax + THREAD_DATA.dwFill], 0xFFFFFFFF     is replaced by
    mov  [eax + THREAD_DATA.dwFill], FILL_TYPE
    mov  [eax + THREAD_DATA.dwFillSize], 0xFFFFFFFF is replaced by
    mov  [eax + THREAD_DATA.dwFill], FILL_SIZE

  and 
  
    call g_pfnStackSwap                             is replaced by 
    call g_pAPIHooks[api].pfnOld

--*/

__declspec(naked)
void 
Stub()
{
    __asm {
        mov  eax, fs:[0x18]                         // get the TEB
        mov  eax, [eax + TEB.THREAD_VAR]            // get our thread local pointer
  
        or   eax, eax                               // our pointer is gone
        jz   Hook                                   // exit gracefully

        cmp  [eax + THREAD_DATA.ulCount], 0         // have we already swapped the stack
        jnz  Hook

        mov  [eax + THREAD_DATA.dwFill], 0xFFFFFFFF // the 0xFFFFFFFF will be replaced by the fill type
        mov  [eax + THREAD_DATA.dwFillSize], 0xFFFFFFFF // the 0xFFFFFFFF will be replaced by the fill size
        mov  [eax + THREAD_DATA.pOldStack], esp     // backup the old stack
        mov  esp, [eax + THREAD_DATA.pNewStack]     // swap the stack
        call g_pfnStackSwap                         // call into the stack swapping code
        
    Hook:
        jmp  [g_pHooks]                             // jump to the hook
    }
}

/*++

 Create a new stack

--*/

THREAD_DATA *
AllocStack()
{
    LPVOID p = VirtualAlloc(
        0, 
        sizeof(THREAD_DATA) + STACK_SIZE + STACK_GUARD_SIZE, 
        MEM_COMMIT, 
        PAGE_READWRITE);

    if (p)
    {
        DWORD dwOld;
        if (!VirtualProtect(p, STACK_GUARD_SIZE, PAGE_READONLY | PAGE_GUARD, &dwOld))
        {
            DPFN( eDbgLevelError, "Failed to place Gaurd page at the top of the stack");
        }

        THREAD_DATA *pTD = (THREAD_DATA *)((DWORD_PTR)p + STACK_SIZE + STACK_GUARD_SIZE);

        pTD->pNewStack = (LPVOID)((DWORD_PTR)pTD - STACK_COPY_SIZE * 4);

        return pTD;
    }
    else
    {
        DPFN( eDbgLevelError, "Failed to allocate new stack");
        return NULL;
    }
}

/*++

 Free the stack

--*/

BOOL
FreeStack(THREAD_DATA *pTD)
{
    BOOL bRet = FALSE;
    
    if (pTD)
    {
        LPVOID p = (LPVOID)((DWORD_PTR)pTD - STACK_SIZE - STACK_GUARD_SIZE);
        bRet = VirtualFree(p, 0, MEM_RELEASE);
    }

    if (!bRet)
    {
        DPFN( eDbgLevelError, "Failed to free a stack");
    }
    
    return bRet;
}

/*++

 Hook CreateThread so we can add our stuff to the TEB.

--*/

HANDLE 
APIHOOK(CreateThread)(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  
    DWORD dwStackSize,                         
    LPTHREAD_START_ROUTINE lpStartAddress,     
    LPVOID lpParameter,                        
    DWORD dwCreationFlags,                     
    LPDWORD lpThreadId                         
    )
{
    HANDLE hRet;
    DWORD dwFlags = dwCreationFlags;

    NEW_STACK();

    hRet = ORIGINAL_API(CreateThread)(
        lpThreadAttributes,
        dwStackSize,
        lpStartAddress,
        lpParameter,
        dwCreationFlags | CREATE_SUSPENDED,
        lpThreadId);

    if (hRet)
    {
        THREAD_BASIC_INFORMATION tbi;
        NTSTATUS Status;

        Status = NtQueryInformationThread(
            hRet,
            ThreadBasicInformation,
            &tbi,
            sizeof(tbi),
            NULL);

        if ((NT_SUCCESS(Status)) && (tbi.TebBaseAddress))
        {
            tbi.TebBaseAddress->THREAD_VAR = AllocStack();
        }

        if (!(dwFlags & CREATE_SUSPENDED))
        {
            ResumeThread(hRet);
        }
    }

    OLD_STACK();

    return hRet;
}

/*++

 Hook TerminateThread so we can clean up the thread local data.

--*/

BOOL 
APIHOOK(TerminateThread)(
    HANDLE hThread,    
    DWORD dwExitCode   
    )
{
    THREAD_BASIC_INFORMATION tbi;
    NTSTATUS Status;
    BOOL bRet;
    THREAD_DATA *pTD = NULL;
    
    Status = NtQueryInformationThread(
        hThread,
        ThreadBasicInformation,
        &tbi,
        sizeof(tbi),
        NULL);

    if ((NT_SUCCESS(Status)) && (tbi.TebBaseAddress))
    {
       pTD = (THREAD_DATA *)(tbi.TebBaseAddress->THREAD_VAR);
    }

    bRet = ORIGINAL_API(TerminateThread)(hThread, dwExitCode);
    
    FreeStack(pTD);

    return bRet;
}

/*++

 Hook ExitThread so we can clean up the thread local data.

--*/

VOID 
APIHOOK(ExitThread)(
    DWORD dwExitCode   
    )
{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION tbi;
    HANDLE hThread = GetCurrentThread();
    
    Status = NtQueryInformationThread(
        hThread,
        ThreadBasicInformation,
        &tbi,
        sizeof(tbi),
        NULL);
    
    if ((NT_SUCCESS(Status)) && (tbi.TebBaseAddress))
    {
        THREAD_DATA *pTD = (THREAD_DATA *)tbi.TebBaseAddress->THREAD_VAR;
        
        // Make sure we don't free it if we're using it
        if (pTD && (pTD->ulCount == 0))
        {
            FreeStack(pTD);
        }
    }

    ORIGINAL_API(ExitThread)(dwExitCode);
}

/*++

  Add the specified hook to the linked list - this accepts wildcards.

--*/

VOID 
AddHooks(HOOK *pHook)
{
    if (strstr(pHook->szFnName, "*") == 0)
    {
        // Now that we have a hook (not a wild card), we need to make sure it's
        // ok to add it to the list. There are some calls that cannot be shimmed

        for (int i=0; i<sizeof(Excludes)/sizeof(FNEXCLUDE); i++)
        {
            if ((_stricmp(pHook->szModule, (LPSTR)Excludes[i].pszModule) == 0) &&
                (strcmp(pHook->szFnName, (LPSTR)Excludes[i].pszFnName) == 0))
            {
                DPFN( eDbgLevelInfo,"Ignoring %s!%s", Excludes[i].pszModule, Excludes[i].pszFnName);
                return;
            }
        }
        
        // The hook passes, so add it to the list.

        HOOK *pH = (HOOK *) malloc(sizeof(HOOK));
        if (pH)
        {
            MoveMemory(pH, pHook, sizeof(HOOK));
            pH->next = g_pHooks;
            g_pHooks = pH;
        }
        return;
    }

    // Here we have to look through the exports
    LOADED_IMAGE image;
    
    if (!LoadModule(pHook->szModule, &image))
    {
        DPFN( eDbgLevelError, "Module %s not found", pHook->szModule);
        return;
    }

    EXPORT_ENUM exports;
    CHAR szFnName[MAX_PATH];

    if( StringCchCopyA(szFnName, MAX_PATH, pHook->szFnName) != S_OK )
    {
        DPFN(eDbgLevelError, "String Copy failed.");
        return;
    }

    DWORD dwLen = (DWORD)((DWORD_PTR)strstr(pHook->szFnName, "*") - (DWORD_PTR)&pHook->szFnName);

    // Enumerate the exports for this module

    BOOL bMore = EnumFirstExport(&image, &exports);
    while (bMore)
    {
        if ((dwLen == 0) ||
            (strncmp(exports.ExportFunction, szFnName, dwLen) == 0))
        {
            // We have a match
            if( StringCchCopyA(pHook->szFnName, MAX_PATH, exports.ExportFunction) != S_OK )
            {
                DPFN(eDbgLevelError, "String Copy failed.");
                return;
            }
            AddHooks(pHook);
        }
    
        bMore = EnumNextExport(&exports);
    }
        
    // Done with this module
    UnloadModule(&image);
}

/*++

 Parse the command line for APIs to fix stack problems with:

    USER32.DLL!GetDC:0; KERNEL32.DLL!CreateFile*

 The :X is to define behaviour - so:
    
    :0 fill old stack with zeroes
    :1 fill old stack with pointers
    :2 fill old stack with pointers to pointers

--*/

DWORD
ParseCommandLineA(
    LPCSTR lpCommandLine
    )
{
    char seps[] = " :,\t;!";
    char *token = NULL;
    HOOK *pHook = NULL;
    DWORD dwState = 0;
    HOOK hook;

    // Since strtok modifies the string, we need to copy it 
    LPSTR szCommandLine = (LPSTR) malloc(strlen(lpCommandLine) + 1);
    if (!szCommandLine) goto Exit;

    if( StringCchCopyA(szCommandLine, strlen(lpCommandLine) + 1, lpCommandLine) != S_OK )
    {
        DPFN(eDbgLevelError, "String Copy failed.");
        goto Exit;
    }

    //
    // See if we need to do all modules
    //
    
    if ((strcmp(szCommandLine, "") == 0) || (strcmp(szCommandLine, "*") == 0))
    {
        for (int i=0; i<sizeof(g_AllHooks)/sizeof(HOOK); i++)
        {
            AddHooks(&g_AllHooks[i]);
        }
        goto Exit;
    }

    //
    // Run the string, looking for exception names
    //

    token = _strtok(szCommandLine, seps);
   
    while (token)
    {
        switch (dwState)
        {
        case 2:     // handle the :X[(fill size)] case
            dwState = 0;

            if (token[0] && ((token[1] == '\0') || (token[1] == '(')))
            {
                switch (token[0])
                {
                case '0': 
                    hook.dwFill = STACK_FILL_ZERO;
                    break;
                case '1':
                    hook.dwFill = STACK_FILL_PTR1;
                    break;
                case '2':
                    hook.dwFill = STACK_FILL_PTR2;
                    break;
                default:
                    hook.dwFill = STACK_FILL_ZERO;
                }

                if (token[1] == '(')
                {
                    token+=2;      // advance to the beginning of the fill size
                    token[strlen(token)-1] = '\0';       // null terminate
                    hook.dwFillSize = atol(token) >> 2;  // get fill size in dwords
                    if (hook.dwFillSize == 0)
                    {
                        hook.dwFillSize = STACK_FILL_SIZE;
                    }
                }

                // We must be done, so add this hook
                AddHooks(&hook);

                break;
            }

            AddHooks(&hook);

        case 0:     // add a new API module name
            ZeroMemory(&hook, sizeof(HOOK));
            if( StringCchCopyA(hook.szModule, MAX_PATH, token) != S_OK )
            {
                DPFN(eDbgLevelError, "String Copy failed.");
                goto Exit;
            }
            hook.dwFill = STACK_FILL_NONE;
            hook.dwFillSize = STACK_FILL_SIZE;
            dwState++;

            break;
    
        case 1:     // add a new API function name
            dwState++;
            
            if (strlen(hook.szModule) == 0)
            {
                DPFN( eDbgLevelError, "Parse error with token %s", token);
                goto Exit;
            }

            if( StringCchCopyA(hook.szFnName, MAX_PATH, token) != S_OK )
            {
                DPFN(eDbgLevelError, "String Copy failed.");
                goto Exit;
            }
            break;
        }

        // Get the next token
        token = _strtok(NULL, seps);
    }

    if (dwState == 2)
    {
        AddHooks(&hook);
    }

Exit:
    if (szCommandLine)
    {
        free(szCommandLine);
    }

    if (!g_pHooks)
    {
        DPFN( eDbgLevelError, "No hooks added");
        return 0;
    }

    //
    // Dump results of command line parse
    //

    DPFN( eDbgLevelInfo, "--------------------------------------------");
    DPFN( eDbgLevelInfo, "     Stack Swapping the following APIs:     ");
    DPFN( eDbgLevelInfo, "--------------------------------------------");
    
    DWORD dwCount = 0;
    pHook = g_pHooks;
    while (pHook)
    {
        DPFN( eDbgLevelInfo, "%s!%s: Fill=%d, Size=%d", pHook->szModule, pHook->szFnName, pHook->dwFill, pHook->dwFillSize*4);
        dwCount++;
        pHook = pHook->next;
    }
    DPFN( eDbgLevelInfo, "--------------------------------------------");

    return dwCount;
}

/*++

 Builds the stubs for the hooked APIs 

--*/

DWORD 
BuildStubs()
{
    // Count the stubs
    DWORD dwCount = 0;
    HOOK *pHook = g_pHooks;
    while (pHook)
    {
        dwCount++;
        pHook = pHook->next;
    }

    // Create the stubs
    LPBYTE pStub = (LPBYTE) VirtualAlloc(
        0, 
        STUB_SIZE * dwCount, 
        MEM_COMMIT, 
        PAGE_EXECUTE_READWRITE);

    if (!pStub)
    {
        DPFN( eDbgLevelError, "Could not allocate memory for stubs");
        return 0;
    }

    pHook = g_pHooks;
    PHOOKAPI pAPIHook = &g_pAPIHooks[APIHOOK_Count];
    while (pHook)
    {
        MoveMemory(pStub, Stub, STUB_SIZE);
        
        LPDWORD p;
        
        p = (LPDWORD)((DWORD_PTR)pStub + 0x19); // fill in the fill type
        *p = pHook->dwFill;

        p = (LPDWORD)((DWORD_PTR)pStub + 0x19+7); // fill in the fill size
        *p = pHook->dwFillSize;
        
        p = (LPDWORD)((DWORD_PTR)pStub + 0x2b+7); // fill in the hook
        *p = (DWORD_PTR)&pAPIHook->pfnOld;
        
        ZeroMemory(pAPIHook, sizeof(HOOKAPI));
        pAPIHook->pszModule = pHook->szModule;
        pAPIHook->pszFunctionName = pHook->szFnName;
        pAPIHook->pfnNew = pStub;
        
        DPFN( eDbgLevelSpew, "%08lx %s!%s", pStub, pHook->szModule, pHook->szFnName);

        pStub += STUB_SIZE;
        pAPIHook++;
        pHook = pHook->next;
    }

    return dwCount;
}

/*++

 Free the stub list allocated by ParseCommandLineA

--*/

VOID
FreeStubs()
{
    HOOK *pHook = g_pHooks;
    
    while (pHook)
    {
        pHook = pHook->next;
        free(g_pHooks);
        g_pHooks = pHook;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        // Run the command line to check for hooks - returns number found
        dwStubCount = ParseCommandLineA(COMMAND_LINE);

        if (dwStubCount)
        {
            //
            // Increase the hook structure size.
            //

            g_pAPIHooks = (PHOOKAPI) realloc(g_pAPIHooks, 
                sizeof(HOOKAPI) * (APIHOOK_Count + dwStubCount));

            if (!g_pAPIHooks)
            {
                DPFN( eDbgLevelError, "Failed to re-allocate hooks"); 
                return FALSE;
            }
        }

        INIT_STACK(1024 * 128, 32);
        
        NtCurrentTeb()->THREAD_VAR = AllocStack();

        BuildStubs();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        // Ignore cleanup
        // FreeStubs();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateThread)
    APIHOOK_ENTRY(KERNEL32.DLL, TerminateThread)
    APIHOOK_ENTRY(KERNEL32.DLL, ExitThread)

    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        // Write out the new size
        *pdwHookCount = APIHOOK_Count + dwStubCount;
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\terminateexe.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
    
    TerminateExe.cpp

 Abstract:

    This shim terminates an exe on startup. (Die Die DIE!!!)

 Notes:

    This is a general purpose shim.

 History:

    05/01/2001 mnikkel      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TerminateExe)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPFN( eDbgLevelSpew, "Terminating Exe.\n");
            ExitProcess(0);
            break;

        default:
            break;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\stackswap_excludes.h ===
#ifndef _EXCLUDES_H_
#define _EXCLUDES_H_

/*++

 This file lists some of the APIs we need to exclude from the stack swapping
 system. It can be modified to include any API that uses no stack, or a that
 otherwise crashes. 

 Note that since the wildcards catch all exports, not just APIs, variable 
 names need to be included in this list.

--*/

struct FNEXCLUDE
{
   char *pszModule;         // Module name
   char *pszFnName;         // Function name
};
 
FNEXCLUDE Excludes[] = 
{
    {"KERNEL32.DLL", "EnterCriticalSection"}, 
    {"KERNEL32.DLL", "LeaveCriticalSection"},
    {"KERNEL32.DLL", "InitializeCriticalSection"},
    {"KERNEL32.DLL", "DeleteCriticalSection"},
    {"KERNEL32.DLL", "HeapAlloc"},
    {"KERNEL32.DLL", "HeapFree"},
    {"KERNEL32.DLL", "HeapReAlloc"},
    {"KERNEL32.DLL", "HeapSize"},
    {"KERNEL32.DLL", "VirtualAlloc"},
    {"KERNEL32.DLL", "VirtualAllocEx"},
    {"KERNEL32.DLL", "VirtualBufferExceptionHandler"},
    {"KERNEL32.DLL", "VirtualFree"},
    {"KERNEL32.DLL", "VirtualFreeEx"},
    {"KERNEL32.DLL", "VirtualLock"},
    {"KERNEL32.DLL", "VirtualProtect"},
    {"KERNEL32.DLL", "VirtualProtectEx"},
    {"KERNEL32.DLL", "VirtualQuery"},
    {"KERNEL32.DLL", "VirtualQueryEx"},
    {"KERNEL32.DLL", "VirtualUnlock"},
    {"KERNEL32.DLL", "WaitForSingleObject"},
    {"KERNEL32.DLL", "WaitForSingleObjectEx"},
    {"KERNEL32.DLL", "WaitForMultipleObjects"},
    {"KERNEL32.DLL", "WaitForMultipleObjectsEx"},
    {"KERNEL32.DLL", "LoadLibraryA"},
    {"KERNEL32.DLL", "LoadLibraryExA"},
    {"KERNEL32.DLL", "LoadLibraryExW"},
    {"KERNEL32.DLL", "LoadLibraryW"},
    {"KERNEL32.DLL", "GetProcessHeap"},
    {"KERNEL32.DLL", "GetProcAddress"},
    {"KERNEL32.DLL", "CreateThread"},
    {"KERNEL32.DLL", "ExitThread"},
    {"KERNEL32.DLL", "TerminateThread"},

    {"USER32.DLL", "PostThreadMessageA"},
    {"USER32.DLL", "PostThreadMessageW"},

    {"GDI32.DLL", "XFORMOBJ_bApplyXform"},
    {"GDI32.DLL", "XFORMOBJ_iGetXform"},
    {"GDI32.DLL", "XLATEOBJ_cGetPalette"},
    {"GDI32.DLL", "XLATEOBJ_hGetColorTransform"},
    {"GDI32.DLL", "XLATEOBJ_iXlate"},
    {"GDI32.DLL", "XLATEOBJ_piVector"},
    {"GDI32.DLL", "STROBJ_bEnum"},
    {"GDI32.DLL", "STROBJ_bEnumPositionsOnly"},
    {"GDI32.DLL", "STROBJ_bGetAdvanceWidths"},
    {"GDI32.DLL", "STROBJ_dwGetCodePage"},
    {"GDI32.DLL", "STROBJ_vEnumStart"},
    {"GDI32.DLL", "PATHOBJ_bEnum"},
    {"GDI32.DLL", "PATHOBJ_bEnumClipLines"},
    {"GDI32.DLL", "PATHOBJ_vEnumStart"},
    {"GDI32.DLL", "PATHOBJ_vEnumStartClipLines"},
    {"GDI32.DLL", "PATHOBJ_vGetBounds"},
    {"GDI32.DLL", "BRUSHOBJ_hGetColorTransform"},
    {"GDI32.DLL", "BRUSHOBJ_pvAllocRbrush"},
    {"GDI32.DLL", "BRUSHOBJ_pvGetRbrush"},
    {"GDI32.DLL", "BRUSHOBJ_ulGetBrushColor"},
    {"GDI32.DLL", "HT_Get8BPPMaskPalette"},
    {"GDI32.DLL", "HT_Get8BPPFormatPalette"},
    {"GDI32.DLL", "cGetTTFFromFOT"},
    {"GDI32.DLL", "bMakePathNameW"},
    {"GDI32.DLL", "bInitSystemAndFontsDirectoriesW"},
    {"GDI32.DLL", "FONTOBJ_vGetInfo"},
    {"GDI32.DLL", "FONTOBJ_pxoGetXform"},
    {"GDI32.DLL", "FONTOBJ_pvTrueTypeFontFile"},
    {"GDI32.DLL", "FONTOBJ_pifi"},
    {"GDI32.DLL", "FONTOBJ_pfdg"},
    {"GDI32.DLL", "FONTOBJ_pQueryGlyphAttrs"},
    {"GDI32.DLL", "FONTOBJ_cGetGlyphs"},
    {"GDI32.DLL", "FONTOBJ_cGetAllGlyphHandles"},
    {"GDI32.DLL", "SetSystemPaletteUse"}    
};

#endif //_EXCLUDES_H_/*++
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\trimversioninfo.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    TrimVersionInfo.cpp

 Abstract:

    This shim trims the blanks off of the end the version info string.

 Notes:

    This is a general shim.

 History:
 
  08/01/2001 mnikkel, astritz   Created
  
 --*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TrimVersionInfo)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VerQueryValueA)
APIHOOK_ENUM_END

/*++

 Return the product version with blanks trimmed from end.
  
--*/

BOOL 
APIHOOK(VerQueryValueA)(
    const LPVOID pBlock, 
    LPSTR lpSubBlock, 
    LPVOID *lplpBuffer, 
    PUINT puLen 
    )
{
    BOOL bRet = ORIGINAL_API(VerQueryValueA)( 
           pBlock, 
           lpSubBlock, 
           lplpBuffer, 
           puLen);

    if (bRet)
    {                
        CSTRING_TRY
        {
            CString csSubBlock(lpSubBlock);
            
            if (csSubBlock.Find(L"ProductVersion") != -1 ||
                csSubBlock.Find(L"FileVersion") != -1)
            {
                int nLoc = 0;
                   
                DPFN(eDbgLevelError, "[VerQueryValueA] Asking for Product or File Version, trimming blanks");
                DPFN(eDbgLevelSpew, "[VerQueryValueA] Version info is <%s>", *lplpBuffer);
                
                CString csBuffer((char *)*lplpBuffer); 
                
                //
                // Search for first blank
                //
                nLoc = csBuffer.Find(L" ");
                if (nLoc != -1)
                {
                    // if a blank is found then truncate string to that point
                    csBuffer.Truncate(nLoc);
                    StringCchCopyA((char *)*lplpBuffer, *puLen, csBuffer.GetAnsi());
                    if (puLen)
                    {
                        *puLen = nLoc;                        
                        DPFN(eDbgLevelSpew, "[VerQueryValueA] Version info Length = %d.", *puLen);
                    }
                }
                
                DPFN(eDbgLevelSpew, "[VerQueryValueA] Version info after trim is <%s>.", *lplpBuffer);
            }
        }
    	CSTRING_CATCH
    	{
            /* do nothing */
    	}        
    }

    return bRet;
}

/*++

 Register hooked functions
 
--*/

HOOK_BEGIN
    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\stackswap_exports.h ===
#ifndef _EXPORTS_H_
#define _EXPORTS_H_

typedef struct _LOADED_IMAGE 
{
    PSTR                  ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
    PIMAGE_NT_HEADERS32   FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
} LOADED_IMAGE, *PLOADED_IMAGE;

typedef struct _EXPORT_ENUM 
{
    /*user area - BEGIN*/
    PCSTR    ExportFunction;
    DWORD    ExportFunctionOrd;
    /*user area - END*/

    PLOADED_IMAGE Image;
    PIMAGE_EXPORT_DIRECTORY ImageDescriptor;
    PDWORD ExportNamesAddr;
    PUSHORT ExportOrdAddr;
    DWORD CurrExportNr;
} EXPORT_ENUM, *PEXPORT_ENUM;

BOOL LoadModule(PCSTR ModuleName, PLOADED_IMAGE ModuleImage);
BOOL UnloadModule(PLOADED_IMAGE ModuleImage);
BOOL EnumFirstExport(PLOADED_IMAGE ModuleImage, PEXPORT_ENUM ModuleExports);
BOOL EnumNextExport(PEXPORT_ENUM ModuleExports);

#endif //_EXPORTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\unmirrorimagelist.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    UnMirrorImageList.cpp

 Abstract:
 
    PictureIt 2001 calls CImageListCache::AddImage() with the ICIFLAG_MIRROR set 
	if the user default UI language is Arabic or Hebrew, This is shim to lie about 
	the default UI language.

	GetUserDefaultUILanguage will rerun English for Arabic and Hebrew languages.
    
    This shim is app specific

 History:

 04/17/2001 mhamid  created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UnMirrorImageList)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetUserDefaultUILanguage) 
APIHOOK_ENUM_END

LANGID  
APIHOOK(GetUserDefaultUILanguage)(VOID)
{
	LANGID LangID = ORIGINAL_API(GetUserDefaultUILanguage)();
	if ((LangID == MAKELANGID(LANG_ARABIC, SUBLANG_DEFAULT))||
		(LangID == MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT)))
	{
		LangID = MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);
	}
	return LangID;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetUserDefaultUILanguage)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general64\precomp.h ===
#ifndef _GPSHIMS64_PRECOMP_H_
#define _GPSHIMS64_PRECOMP_H_

#include "ShimHook.h"
#include <strsafe.h>

using namespace ShimLib;


#endif // _GPSHIMS64_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general64\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:


 Notes:

 History:

    02/27/2000 clupu Created

--*/

#include "precomp.h"
#include "ShimHookMacro.h"

DECLARE_SHIM(Win2kVersionLie64)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcGen64", eDbgLevelSpew, "General Purpose Shims 64 initialized.");
            break;

        case DLL_PROCESS_DETACH:
            DPF("AcGen64", eDbgLevelSpew, "General Purpose Shims 64 uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()

    MULTISHIM_ENTRY(Win2kVersionLie64)

    CALL_MULTISHIM_NOTIFY_FUNCTION()

MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general64\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

TARGETNAME=AcGen64

TARGETTYPE=DYNLINK

INCLUDES=$(INCLUDES);                              \
         ..;                                       \
         $(SHELL_INC_PATH)

SOURCES=..\ver.rc                                  \
        ..\Main.cpp                                \
        ..\Win2kVersionLie64.cpp


C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\kernel32.lib


DLLBASE=0x22000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\waveoutusepreferreddevice.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WaveOutUsePreferredDevice.cpp

 Abstract:

    Force the use of the preferred waveOut device (rather than a specific device)

 Notes:
    
    This is a general purpose shim.

 History:

    06/02/1999 robkenny Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WaveOutUsePreferredDevice)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(waveOutOpen) 
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsA) 
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsW) 
    APIHOOK_ENUM_ENTRY(wod32Message) 
APIHOOK_ENUM_END

/*+

  Call waveOutOpen, saving dwCallback if it is a function.

--*/
MMRESULT APIHOOK(waveOutOpen)(
  LPHWAVEOUT phwo,
  UINT uDeviceID,
  LPWAVEFORMATEX pwfx,
  DWORD dwCallback,
  DWORD dwCallbackInstance,
  DWORD fdwOpen
)
{
    MMRESULT returnValue = ORIGINAL_API(waveOutOpen)(phwo, WAVE_MAPPER, pwfx, dwCallback, dwCallbackInstance, fdwOpen);
    return returnValue;
}

MMRESULT APIHOOK(waveOutGetDevCapsA)(
    UINT uDeviceID,
    LPWAVEOUTCAPSA pwoc,
    UINT cbwoc)
{
    MMRESULT returnValue = ORIGINAL_API(waveOutGetDevCapsA)(WAVE_MAPPER, pwoc, cbwoc);
    return returnValue;
}

MMRESULT APIHOOK(waveOutGetDevCapsW)(
    UINT uDeviceID,
    LPWAVEOUTCAPSW pwoc,
    UINT cbwoc)
{
    MMRESULT returnValue = ORIGINAL_API(waveOutGetDevCapsW)(WAVE_MAPPER, pwoc, cbwoc);
    return returnValue;
}

/*+

  Catch the 16 bit applications, WOW calls this routine for 16 bit apps.

--*/

#define WODM_GETDEVCAPS         4
#define WODM_OPEN               5

DWORD APIHOOK(wod32Message)(
    UINT uDeviceID,
    UINT uMessage,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    // Change device 0 to WAVE_MAPPER for Open and GetDevCaps
    if (uDeviceID == 0) {
        if (uMessage == WODM_OPEN ||
            uMessage == WODM_GETDEVCAPS) {
            uDeviceID = -1; // Force device to WAVE_MAPPER
        }
    }

    MMRESULT returnValue = ORIGINAL_API(wod32Message)(uDeviceID, uMessage, dwInstance, dwParam1, dwParam2);
    return returnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, waveOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsA)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsW)
    APIHOOK_ENTRY(WINMM.DLL, wod32Message)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general\wing32systosys32.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinG32SysToSys32.cpp

 Abstract:
    
    During its dllmain WinG32 checks its install location. It does this by parsing the path returned from
    GetModuleFileName. If it finds that it was installed in the system directory, it will post a message box
    and fail. This is fixed by checking and tweaking the string returned from the API call.
        
 History:

    03/21/2001  alexsm  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinG32SysToSys32)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
   APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
APIHOOK_ENUM_END


DWORD
APIHOOK(GetModuleFileNameA)(HMODULE hModule, LPSTR lpFileName, DWORD nSize)
{
    DWORD nReturn = 0;
    int nFound = -1;
    char * lpNewFileName = NULL;
    WCHAR * lpSystemCheck = L"SYSTEM\\WING32.DLL";
    WCHAR * lpWinG32 = L"WING32.dll";
    CString csOldFileName;
    CString csNewFileName;
    
    nReturn = ORIGINAL_API(GetModuleFileNameA)(hModule, lpFileName, nSize);

    // Do nothing on failure.
    if( 0 == nReturn || nReturn >= nSize )
    {
        return nReturn;
    }

    // Check the string. If the string is not pointing to system32, we need to redirect.
    CSTRING_TRY
    {
        csOldFileName = lpFileName;
        csOldFileName.MakeUpper();
        nFound = csOldFileName.Find(lpSystemCheck);
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    if(nFound >= 0)
    {
        DPFN(
            eDbgLevelInfo,
            "[WinG32SysToSys32] Changing system\\wing32.dll to system32\\wing32.dll");

        CSTRING_TRY
        {
            csNewFileName.GetSystemDirectoryW();
            csNewFileName.AppendPath(lpWinG32);
            lpNewFileName = csNewFileName.GetAnsiNIE();
            if(lpNewFileName && nSize > (unsigned int)csNewFileName.GetLength())
            {
                nReturn = csNewFileName.GetLength();
                memcpy(lpFileName, lpNewFileName, sizeof(char) * (nReturn + 1));
            }
        }
        CSTRING_CATCH
        {
            DPFN(
                eDbgLevelInfo,
                "[WinG32SysToSys32] Error parsing new string");
        }
    }

    return nReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetModuleFileNameA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\inc\secutils.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    secutils.h

 Abstract:
    The security utility functions for the shims.

 History:

    02/09/2001  maonis      Created
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.

--*/

#pragma once

#ifndef _SEC_UTILS_H_
#define _SEC_UTILS_H_

#include "ShimHook.h"
#include <aclapi.h>

namespace ShimLib
{

BOOL SearchGroupForSID(DWORD dwGroup, BOOL* pfIsMember);

BOOL ShouldApplyShim();

BOOL AdjustPrivilege(LPCWSTR pwszPrivilege, BOOL fEnable);

//
// File specific
// 

BOOL RequestWriteAccess(DWORD dwCreationDisposition, DWORD dwDesiredAccess);



};  // end of namespace ShimLib

#endif // _SEC_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\general64\win2kversionlie64.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win2000VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   03/13/2000 clupu  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2kVersionLie64)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExA] called. return Win2k.");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = '\0';

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExW] called. return Win2k.");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = L'\0';

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(
        eDbgLevelInfo,
        "[GetVersion] called. return Win2k.");
    
    return (DWORD)0x08930005;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\inc\heap.h ===
/*
#pragma once
*/
#ifndef _HEAP_H
#define _HEAP_H

#include <windows.h>
#include <stdio.h>
// Disable warning C4201: nonstandard extension used : nameless struct/union
// Allows shims to be compiled at Warning Level 4
#pragma warning ( disable : 4201 ) 
#include <mmsystem.h>
#pragma warning ( default : 4201 ) 
#include <winerror.h>
#include <shellapi.h>
#include <shlobj.h>
#include <ole2.h>
#include <ddraw.h>
#include <dsound.h>
#include <commdlg.h>
#include <winspool.h>
#include "ShimDebug.h"

/*
 *  heap.h - structures and equates for the Windows 32-bit heap
 *

/***LT  busyblock_s - busy heap block header structure
 *
 *  This structure is stored at the head of every busy (not free) heap
 *  block.
 *
 *  The bh_size field is in bytes and includes the size of the
 *  heap header and any slop at the end of the block that might have
 *  been included because of the heap granularity, or to keep us
 *  from leaving a block too small to hold a free heap header.
 *
 *  bh_size is also used as a forward link to the next heap block.
 *
 *  The low two bits of the bh_size field are used to hold flags
 *  (BP_FREE must be clear and HP_PREVFREE is optionally set).
 */
struct busyheap_s {
    unsigned long   bh_size;    /* block size + flags in low 2 bits */
};

/*XLATOFF*/
#define BH_SIGNATURE    0x4842      /* busy heap block signature (BH) */
/*XLATON*/

#define BH_CDWSUM   3       /* count of dwords to sum in struct */


/***LT  freeblock_s - free heap block header structure
 *
 *  This structure is stored at the head of every free block on the
 *  heap.  In the last dword of every free heap block is a pointer
 *  the this structure.
 *
 *  The fh_size field is in bytes and includes the size of the
 *  heap header and any slop at the end of the block that might have
 *  been included because of the heap granularity, or to keep us
 *  from leaving a block too small to hold a free heap header.
 *
 *  fh_size is also used as a forward link to the next heap block.
 *
 *  The low two bits of the fh_size field are used to hold flags
 *  (HP_FREE must be set and HP_PREVFREE must be clear).
 */

struct freeheap_s {
    unsigned long      fh_size; /* block size + flags in low 2 bits */
    struct freeheap_s *fh_flink;    /* forward link to next free block */
    struct freeheap_s *fh_blink;    /* back link to previous free block */
};

/*XLATOFF*/
#define FH_SIGNATURE    0x4846      /* free heap block signature (FH) */
/*XLATON*/

#define FH_CDWSUM   4       /* count of dwords to sum in struct */

/*
 *  Equates common to all heap blocks.
 *
 *  HP_FREE and HP_PREVFREE (HP_FLAGS) are stored in the low two
 *  bits of the fh_ and bh_size field.
 *  The signature is stored in the high three bits of the size.
 */
#define HP_FREE     0x00000001  /* block is free */
#define HP_PREVFREE 0x00000002  /* previous block is free */
#define HP_FLAGS    0x00000003  /* mask for all the flags */
#define HP_SIZE     0x0ffffffc  /* mask for clearing flags */
#define HP_SIGBITS  0xf0000000  /* bits used for signature */
#define HP_SIGNATURE    0xa0000000  /* valid value of signature */

/*
 *  Misc heap equates
 */
#define hpGRANULARITY   4       /* granularity for heap allocations */
#define hpGRANMASK  (hpGRANULARITY - 1)     /* for rounding */
/*XLATOFF*/
#define hpMINSIZE   (sizeof(struct freeheap_s)+sizeof(struct freeheap_s *))
            /* min block size */

#define hpMAXALLOC  (HP_SIZE - 100) /* biggest allocatable heap block */

/* overhead for a new heap segment (header plus end sentinel) */
#define hpSEGOVERHEAD   (sizeof(struct busyheap_s) + sizeof(struct heapseg_s))

/* default reserved size of new segments added to growable heaps */
#define hpCBRESERVE (4*1024*1024)


/*XLATON*/


/*
 * Exported flags for heap calls
 */

#define HP_ZEROINIT 0x40    /* zero initialize block on HP(Re)Alloc */
#define HP_MOVEABLE 0x02    /* block can be moved (HP(Re)Alloc) */
#define HP_NOCOPY   0x20    /* don't copy data on HPReAlloc */
#define HP_NOSERIALIZE  0x01    /* don't serialize heap access */
#define HP_EXCEPT   0x04    /* generate exceptions on error */

#define HP_FIXED    0x00    /* block is at a fixed address (HPAlloc) */
#define HP_GROWABLE 0x40    /* heap can grow beyond cbreserve (HPInit) */
/*
 *  Note that flags above 0x80 will not be stored into the heap header in
 *  HPInit calls because the flags field in the header is only a byte
 */
#define HP_INITSEGMENT 0x100    /* just initialize a heap segment (HPInit) */
#define HP_DECOMMIT    0x200    /* decommit pages in free block (hpFreeSub) */
#define HP_GROWUP      0x400    /* waste last page of heap (HPInit) */

/*XLATOFF*/

/***LP  hpSize - pull size field from heap header
 *
 *  This routine depends on the size field being the first
 *  dword in the header.
 *
 *  ENTRY:  ph - pointer to heap header
 *  EXIT:   count of bytes in block (counting header).
 */
#define hpSize(ph) (*((unsigned long *)(ph)) & HP_SIZE)

/***LP  hpSetSize - set the size parameter in a heap header
 *
 *  This routine depends on the size field being the first
 *  dword in the header.
 *
 *  ENTRY:  ph - pointer to busy heap header
 *      cb - count of bytes (should be rounded using hpRoundUp)
 *  EXIT:   size is set in heap header
 */
#define hpSetSize(ph, cb) (((struct busyheap_s *)(ph))->bh_size =  \
             ((((struct busyheap_s *)(ph))->bh_size & ~HP_SIZE) | (cb)))

/* the compiler used to do a better version with this macro than the above,
 * but not any more
#define hpSetSize2(ph, cb) *(unsigned long *)(ph) &= ~HP_SIZE; \
               *(unsigned long *)(ph) |= (cb);
 */

/***LP  hpSetBusySize - set the entire bh_size dword for a busy block
 *
 *  This macro will set the bh_size field of the given heap header
 *  to the given size as well as setting the HP_SIGNATURE and clearing
 *  any HP_FREE or HP_PREVFREE bits.
 *
 *  ENTRY:  ph - pointer to busy heap header
 *      cb - count of bytes (should be rounded using hpRoundUp)
 *  EXIT:   bh_size field is initialized
 */
#define hpSetBusySize(ph, cb)   ((ph)->bh_size = ((cb) | HP_SIGNATURE))


/***LP  hpSetFreeSize - set the entire fh_size dword for a free block
 *
 *  This macro will set the fh_size field of the given heap header
 *  to the given size as well as setting the HP_SIGNATURE and HP_FREE
 *  and clearing HP_PREVFREE.
 *
 *  ENTRY:  ph - pointer to free heap header
 *      cb - count of bytes (should be rounded using hpRoundUp)
 *  EXIT:   bh_size field is initialized
 */
#define hpSetFreeSize(ph, cb)   ((ph)->fh_size = ((cb) | HP_SIGNATURE | HP_FREE))


/***LP  hpIsBusySignatureValid - check a busy heap block's signature
 *
 *  This macro checks the tiny signature (HP_SIGNATURE) in the bh_size
 *  field to see if it is set properly and makes sure that the HP_FREE
 *  bit is clear.
 *
 *  ENTRY:  ph - pointer to a busy heap header
 *  EXIT:   TRUE if signature is ok, else FALSE
 */
#define hpIsBusySignatureValid(ph) \
            (((ph)->bh_size & (HP_SIGBITS | HP_FREE)) == HP_SIGNATURE)


/***LP  hpIsFreeSignatureValid - check a free heap block's signature
 *
 *  This macro checks the tiny signature (HP_SIGNATURE) in the fh_size
 *  field to see if it is set properly and makes sure that the HP_FREE
 *  bit is also set and HP_PREVFREE is clear.
 *
 *  ENTRY:  ph - pointer to a free heap header
 *  EXIT:   TRUE if signature is ok, else FALSE
 */
#define hpIsFreeSignatureValid(ph) \
      (((ph)->fh_size & (HP_SIGBITS | HP_FREE | HP_PREVFREE)) == \
                             (HP_SIGNATURE | HP_FREE))


#define maximum(a,b)    \
        ( (a) > (b) ) ? (a) : (b)


/***LP  hpRoundUp - round up byte count to appropriate heap block size
 *
 *  Heap blocks have a minimum size of hpMINSIZE and hpGRANULARITY
 *  granularity.  This macro also adds on size for the heap header.
 *
 *  ENTRY:  cb - count of bytes
 *  EXIT:   count rounded up to hpGANULARITY boundary
 */
#define hpRoundUp(cb)   \
      max(hpMINSIZE,    \
      (((cb) + sizeof(struct busyheap_s) + hpGRANMASK) & ~hpGRANMASK))



/*XLATON*/

/***LK  freelist_s - heap free list head
 */
struct freelist_s {
    unsigned long     fl_cbmax; /* max size block in this free list */
    struct freeheap_s fl_header;    /* pseudo heap header as list head */
};
#define hpFREELISTHEADS 4   /* number of free list heads in heapinfo_s */

/***LK  heapinfo_s - per-heap information (stored at start of heap)
 *
 */
struct heapinfo_s {

    /* These first three fields must match the fields of heapseg_s */
    unsigned long   hi_cbreserve;       /* bytes reserved for heap */
    struct heapseg_s *hi_psegnext;      /* pointer to next heap segment*/

    struct freelist_s hi_freelist[hpFREELISTHEADS]; /* free list heads */
    struct heapinfo_s *hi_procnext;     /* linked list of process heaps */
    CRITICAL_SECTION  *hi_pcritsec;    /* pointer to serialization obj*/
    CRITICAL_SECTION    hi_critsec;             /* serialize access to heap */
    unsigned char   hi_flags;       /* HP_SERIALIZE, HP_LOCKED */
    unsigned char   hi_pad2;        /* unused */
    unsigned short  hi_signature;       /* should be HI_SIGNATURE */
};

/*
 * Heap Measurement functions
 */
#define  HPMEASURE_FREE    0x8000000L

#define  SAMPLE_CACHE_SIZE 1024

struct measure_s {
   char  szFile[260];
   unsigned iCur;
   unsigned uSamples[SAMPLE_CACHE_SIZE];
};

/*XLATOFF*/
#define HI_SIGNATURE  0x4948        /* heapinfo_s signature (HI) */
/*XLATON*/

#define HI_CDWSUM  1            /* count of dwords to sum */

typedef struct heapinfo_s *HHEAP;


/***LK  heapseg_s - per-heap segment structure
 *
 *  Growable heaps can have multiple discontiguous sections of memory
 *  allocated to them.  Each is headed by one of these structures.  The
 *  first segment is special, in that it has a full heapinfo_s structure,
 *  but the first fields of heapinfo_s match heapseg_s, so it can be
 *  treated as just another segment when convenient.
 */
struct heapseg_s {
    unsigned long   hs_cbreserve;   /* bytes reserved for this segment */
    struct heapseg_s *hs_psegnext;  /* pointer to next heap segment*/
};
/* XLATOFF */

/* smallest possible heap */
#define hpMINHEAPSIZE   (sizeof(struct heapinfo_s) + hpMINSIZE + \
             sizeof(struct busyheap_s))

/***LP  hpRemove - remove item from free list
 *
 *  ENTRY:  pfh - pointer to free heap block to remove from list
 *  EXIT:   none
 */
#define hpRemoveNoSum(pfh)              \
    (pfh)->fh_flink->fh_blink = (pfh)->fh_blink;    \
    (pfh)->fh_blink->fh_flink = (pfh)->fh_flink;


#define hpRemove(pfh)   hpRemoveNoSum(pfh)


/***LP  hpInsert - insert item onto the free list
 *
 *  ENTRY:  pfh - free heap block to insert onto the list
 *      pfhprev - insert pfh after this item
 *  EXIT:   none
 */
#define hpInsertNoSum(pfh, pfhprev)     \
    (pfh)->fh_flink = (pfhprev)->fh_flink;  \
    (pfh)->fh_flink->fh_blink = (pfh);  \
    (pfh)->fh_blink = (pfhprev);        \
    (pfhprev)->fh_flink = (pfh)

#define hpInsert(pfh, pfhprev)  hpInsertNoSum(pfh, pfhprev)



/*
 * critical section macros to be used by all internal heap functions
 */
    #define hpEnterCriticalSection(hheap) EnterCriticalSection(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) LeaveCriticalSection(hheap->hi_pcritsec)
    #define hpInitializeCriticalSection(hheap)              \
         {                                        \
            hheap->hi_pcritsec = &(hheap->hi_critsec);  \
            InitializeCriticalSection(hheap->hi_pcritsec);               \
         }


/*
 * Exported heap functions
 */

/*
extern HHEAP HPInit(void *hheap, void *pmem, unsigned long cbreserve,
                 unsigned long flags);
extern void * HPAlloc(HHEAP hheap, unsigned long cb,
                 unsigned long flags);

extern void * HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb,
                   unsigned long flags);
*/

/*
 * Local heap functions
 */

/*
extern void hpFreeSub(HHEAP hheap, void *pblock, unsigned cb,
                   unsigned flags);
extern BOOL hpCommit(unsigned page, int npages, unsigned flags);
extern unsigned hpCarve(HHEAP hheap, struct freeheap_s *pfh,
                unsigned cb, unsigned flags);

extern unsigned hpTakeSem(HHEAP hheap, struct busyheap_s *pbh, unsigned long flags);
extern void hpClearSem(HHEAP hheap, unsigned flags);
*/


#define hpWalk(hheap) 1



#define mmError(rc, string) SetLastError(rc)
#define mmAssert(exp, psz)

#define PAGESIZE    1024*4
#define PAGEMASK    0x00000FFF      /* Extract the page-relative offset*/

#define ERR_OUT_OF_RANGE 2

// Function prototypes
extern unsigned 
hpCarve(HHEAP hheap, struct freeheap_s *pfh, unsigned cb, unsigned flags);

extern unsigned 
hpTakeSem(HHEAP hheap, struct busyheap_s *pbh, unsigned long htsflags);

extern void 
hpClearSem(HHEAP hheap, unsigned flags);

extern void
hpFreeSub(HHEAP hheap, struct freeheap_s *pblock, unsigned cb, unsigned flags);

extern void *
HPAlloc(HHEAP hheap, unsigned long cb, unsigned long flags);

extern HHEAP 
HPInit(struct heapinfo_s *hheap,
       struct heapinfo_s *pmem,
       unsigned long cbreserve,
       unsigned long flags);

extern HANDLE SimHeapCreate(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize);

extern BOOL 
hpCommit( unsigned pmem,
               int nSize,
               unsigned flags
               );
extern VOID 
hpDeCommit(unsigned pmem,
           int nSize,
           unsigned flags
          );
extern LPVOID PageReserve(unsigned Size);
extern  VOID PageFree(LPVOID pmem);
extern  void * HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb, unsigned long flags);
extern  BOOL HeapFreeInternal(HHEAP hheap, DWORD flags, LPSTR lpMem);
extern  BOOL SimHeapDestroy(HHEAP hHeap);
extern  HANDLE SIMLocalAlloc(HHEAP hHeap,UINT dwFlags, UINT dwBytes);
extern  HANDLE SIMLocalFree(HHEAP hHeap,HANDLE hMem);
extern  HANDLE SIMLocalReAlloc(HHEAP hHeap,HANDLE hMem, UINT dwBytes, UINT dwFlags);
extern LPVOID SIMLocalLock(HHEAP hHeap,HANDLE hMem);
extern BOOL SIMLocalUnlock(HHEAP hHeap,HANDLE hMem);
extern HANDLE SIMLocalHandle(HHEAP hHeap,PVOID pMem);
extern DWORD SIMHeapSize(HHEAP hheap, DWORD flags, LPSTR lpMem);
extern UINT SIMLocalSize(HHEAP hHeap,HANDLE hMem);
extern UINT SIMLocalFlags(HHEAP hHeap,HANDLE hMem);
extern ULONG VerifyOnHeap(HHEAP hheap, PVOID p);
extern BOOL SIMHeapValidate(HHEAP hheap, DWORD dwFlags, LPCVOID lpMem);
extern UINT SIMHeapCompact(HHEAP hheap,DWORD dwFlags);
#endif //_AH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\inc\rtlutils.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    pathutils.h

 Abstract:
    
    Contains prototypes for functions from ntdll
    on XP that are not available on W2K.

 History:

    09/10/2001  rparsons    Created

--*/

#ifndef _RTLUTILS_H_
#define _RTLUTILS_H_

#include "ShimHook.h"

namespace ShimLib
{

PVOID
ShimAllocateStringRoutine(
    SIZE_T NumberOfBytes
    );

VOID
ShimFreeStringRoutine(
    PVOID Buffer
    );

const PRTL_ALLOCATE_STRING_ROUTINE RtlAllocateStringRoutine = ShimAllocateStringRoutine;
const PRTL_FREE_STRING_ROUTINE RtlFreeStringRoutine = ShimFreeStringRoutine;

RTL_PATH_TYPE
NTAPI
ShimDetermineDosPathNameType_Ustr(
    IN PCUNICODE_STRING String
    );

NTSTATUS
NTAPI
ShimNtPathNameToDosPathName(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    OUT    ULONG*                     Disposition OPTIONAL,
    IN OUT PWSTR*                     FilePart OPTIONAL
    );

NTSTATUS
ShimDuplicateUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringIn,
    PUNICODE_STRING StringOut
    );

NTSTATUS
NTAPI
ShimpEnsureBufferSize(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    );

NTSTATUS
ShimValidateUnicodeString(
    ULONG Flags,
    const UNICODE_STRING *String
    );

//
// Taken from %SDXROOT%\public\sdk\inc\NtRtlStringAndBuffer.h
//
#define ShimEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : ShimpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)) \
    )

#define ShimEnsureUnicodeStringBufferSizeBytes(Buff_, NewSizeBytes_)                            \
    (     ( ((NewSizeBytes_) + sizeof((Buff_)->String.Buffer[0])) > UNICODE_STRING_MAX_BYTES ) \
        ? STATUS_NAME_TOO_LONG                                                                 \
        : !NT_SUCCESS(ShimEnsureBufferSize(0, &(Buff_)->ByteBuffer, ((NewSizeBytes_) + sizeof((Buff_)->String.Buffer[0])))) \
        ? STATUS_NO_MEMORY                                                                      \
        : (RtlSyncStringToBuffer(Buff_))                                                       \
    )

#define ShimEnsureUnicodeStringBufferSizeChars(Buff_, NewSizeChars_) \
    (ShimEnsureUnicodeStringBufferSizeBytes((Buff_), (NewSizeChars_) * sizeof((Buff_)->String.Buffer[0])))

//
// Taken from %SDXROOT%\public\sdk\inc\NtRtlStringAndBuffer.h
//
//++
//
// NTSTATUS
// RtlAppendUnicodeStringBuffer(
//     OUT PRTL_UNICODE_STRING_BUFFER Destination,
//     IN  PCUNICODE_STRING           Source
//     );
//
// Routine Description:
//
//
// Arguments:
//
//     Destination - 
//     Source - 
//
// Return Value:
//
//     STATUS_SUCCESS
//     STATUS_NO_MEMORY
//     STATUS_NAME_TOO_LONG (64K UNICODE_STRING length would be exceeded)
//
//--
#define ShimAppendUnicodeStringBuffer(Dest, Source)                            \
    ( ( ( (Dest)->String.Length + (Source)->Length + sizeof((Dest)->String.Buffer[0]) ) > UNICODE_STRING_MAX_BYTES ) \
        ? STATUS_NAME_TOO_LONG                                                \
        : (!NT_SUCCESS(                                                       \
                ShimEnsureBufferSize(                                         \
                    0,                                                        \
                    &(Dest)->ByteBuffer,                                          \
                    (Dest)->String.Length + (Source)->Length + sizeof((Dest)->String.Buffer[0]) ) ) \
                ? STATUS_NO_MEMORY                                            \
                : ( ( (Dest)->String.Buffer = (PWSTR)(Dest)->ByteBuffer.Buffer ), \
                    ( RtlMoveMemory(                                          \
                        (Dest)->String.Buffer + (Dest)->String.Length / sizeof((Dest)->String.Buffer[0]), \
                        (Source)->Buffer,                                     \
                        (Source)->Length) ),                                  \
                    ( (Dest)->String.MaximumLength = (RTL_STRING_LENGTH_TYPE)((Dest)->String.Length + (Source)->Length + sizeof((Dest)->String.Buffer[0]))), \
                    ( (Dest)->String.Length += (Source)->Length ),            \
                    ( (Dest)->String.Buffer[(Dest)->String.Length / sizeof((Dest)->String.Buffer[0])] = 0 ), \
                    ( STATUS_SUCCESS ) ) ) )
                    
//
// Taken from %SDXROOT%\public\sdk\inc\NtRtlStringAndBuffer.h
//
//++
//
// NTSTATUS
// RtlAssignUnicodeStringBuffer(
//     IN OUT PRTL_UNICODE_STRING_BUFFER Buffer,
//     PCUNICODE_STRING                  String
//     );
// Routine Description:
//
// Arguments:
//
//     Buffer - 
//     String - 
//
// Return Value:
//
//     STATUS_SUCCESS
//     STATUS_NO_MEMORY
//--
#define ShimAssignUnicodeStringBuffer(Buff, Str) \
    (((Buff)->String.Length = 0), (ShimAppendUnicodeStringBuffer((Buff), (Str))))


};  // end of namespace ShimLib

#endif // _RTLUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\inc\parsedde.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ParseDDE.h

 Abstract:

    Helpful routines for parsing DDE commands.

 Notes:

    None

 History:

    08/14/2001  robkenny    Inserted inside the ShimLib namespace.

--*/

#pragma once


//==============================================================================
//
// This code was copied from:
// \nt\shell\shell32\unicpp\dde.cpp
//
//==============================================================================
#include <dde.h>
#include <ddeml.h>

#include "ShimLib.h"


namespace ShimLib
{

// If this were included in ShimProto.h, we would have to include all kinds of DDE include files
typedef HDDEDATA       (WINAPI *_pfn_DdeClientTransaction)(
  LPBYTE pData,       // pointer to data to pass to server
  DWORD cbData,       // length of data
  HCONV hConv,        // handle to conversation
  HSZ hszItem,        // handle to item name string
  UINT wFmt,          // clipboard data format
  UINT wType,         // transaction type
  DWORD dwTimeout,    // time-out duration
  LPDWORD pdwResult   // pointer to transaction result
);



// Extracts an alphabetic string and looks it up in a list of possible
// commands, returning a pointer to the character after the command and
// sticking the command index somewhere.
UINT* GetDDECommands(LPSTR lpCmd, const char * lpsCommands[], BOOL fLFN);
void GetGroupPath(LPCSTR pszName, CString & csPath, DWORD dwFlags, INT iCommonGroup);


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\inc\charvector.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CharVector.h

 Abstract:

   A light-weight vector implementation.


 Created:

   03/14/2000 robkenny

 Modified:
    06/19/2000  robkenny    Converted Resize() and Append() to return BOOL to know if malloc failed.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.


--*/
#pragma once


#include <new>  // for in-place new



namespace ShimLib
{


/*++

    Vector template
    This vector is extremely fast and simple.

--*/
template <class ClassType> class VectorT
{
public:
    typedef VectorT<ClassType> MyType;

protected:
    ClassType * vectorList;
    int         nVectorListMax;     // Current size of vectorList array
    int         nVectorList;        // Number of entries in the vectorList array
    bool        bListIsLocked;      // Are we allowed to modify the array? 

    inline void ValidateIndex(int index) const
    {
#if DBG
        if (index < 0 || index >= nVectorList)
        {
            DebugPrintf("VectorT", eDbgLevelError, "VectorT: index %d out of bounds.\n", index);
        }
        if (nVectorListMax < 0 || nVectorList > nVectorListMax)
        {
            DebugPrintf("VectorT", eDbgLevelError, "VectorT: invalid nVectorListMax(%d) nVectorList(%d).\n", nVectorListMax, nVectorList);
        }
#endif
    }

public:
    VectorT()
    {
        // Init
        vectorList        = NULL;
        nVectorListMax    = 0;
        nVectorList       = 0;
        bListIsLocked     = false;
    }
    ~VectorT()
    {
        Erase();
    }

    // A Copy constructor
    VectorT(const MyType & copyMe)
    {
        // Init
        vectorList        = NULL;
        nVectorListMax    = 0;
        nVectorList       = 0;
        bListIsLocked     = false;

        Duplicate(copyMe);
    }

    // Assignment operator, this gets a copy of other 
    MyType & operator = (const MyType & other)
    {
        if (this != & other)
            Duplicate(other);

        return *this;
    }

    // Copy copyMe into this
    void Duplicate(const MyType & copyMe)
    {
        Erase();

        // Copy class data
        if (Resize(copyMe.nVectorListMax))
        {
            nVectorListMax      = copyMe.nVectorListMax;
            nVectorList         = copyMe.nVectorList;
            bListIsLocked       = copyMe.bListIsLocked;

            // Copy array data
            size_t nBytes = nVectorListMax * sizeof(ClassType);
            memcpy(vectorList, copyMe.vectorList, nBytes);
        }
    }

    void CopyElement(int index, const ClassType & element)
    {
        // Use memcpy to avoid any assignment operators.
        void * dest = & Get(index);
        const void * src  = & element;
        memcpy(dest, src, sizeof(ClassType));
    }

    // Allow this to be treated like an array.
    ClassType & operator [] (int index)
    {
        ValidateIndex(index);
        return vectorList[index];
    }

    const ClassType & operator [] (int index) const
    {
        ValidateIndex(index);
        return vectorList[index];
    }

    // return the value of the index member
    ClassType & Get(int index)
    {
        ValidateIndex(index);
        return vectorList[index];
    }

    // return the const value of the index member
    const ClassType & Get(int index) const
    {
        ValidateIndex(index);
        return vectorList[index];
    }

    BOOL Resize(int size)
    {
        if (size > nVectorListMax)
        {
            size_t newVectorListSize = size * sizeof(ClassType);
            ClassType * newVectorList = (ClassType *)malloc(newVectorListSize);
            if (newVectorList)
            {
                size_t origSize = nVectorListMax * sizeof(ClassType);
                memcpy(newVectorList, vectorList, origSize);

                free(vectorList);
                vectorList = newVectorList;
                nVectorListMax = size;
            }
        }
        // We were successful if there is enough space in the array
        return nVectorListMax >= size;
    }

    // return the number of entries in the list
    int Size() const
    {
        return nVectorList;
    }

    // return the current MAXIMUM number of entries in the list
    int MaxSize() const
    {
        return nVectorListMax;
    }

    // Lock the list (prevent further additions)
    void Lock(bool lock = true)
    {
        bListIsLocked = lock;
    }

    // return true if the list is locked.
    bool IsLocked() const
    {
        return bListIsLocked;
    }

    // Reset number of entries in the list to 0
    void Reset()
    {
        nVectorList = 0;
    }

    // Remove all entries in the list
    void Erase()
    {
        Reset();
        if (vectorList)
            free(vectorList);
        vectorList = NULL;
        nVectorListMax = 0;
    }

    // Search for the member in the list, return index or -1
    int Find(const ClassType & member) const
    {
        for (int i = 0; i < Size(); ++i)
        {
            if (Get(i) == member)
                return i;
        }
        return -1;
    }

    // Add this item to the end of the list
    BOOL Append(const ClassType & member)
    {
        if (!bListIsLocked)
        {
            // Increase array size
            if (Resize(nVectorList + 1))
            {
                nVectorList += 1;
                CopyElement(nVectorList-1, member);
                return TRUE;
            }
        }
        return FALSE;
    }

    // Append this to the list, if it does not already exist
    // Return FALSE if any allocation failed.
    BOOL AppendUnique(const ClassType & member)
    {
        if (!bListIsLocked)
        {
            int index = Find(member);
            if (index == -1)
            {
                return Append(member);
            }
        }
        return TRUE;
    }

    // Add this item to the end of the list,
    // Use the assignment operator to set the new member.
    BOOL AppendConstruct(const ClassType & member)
    {
        if (!bListIsLocked)
        {
            // Increase array size
            if (Resize(nVectorList + 1))
            {
                // Must increase the size of the array before calling Get()
                // otherwise we'll over index the array.
                nVectorList += 1;

                ClassType & last = Get(nVectorList-1);
                new (&last) ClassType;  // inplace new
                last = member;

                return TRUE;
            }
        }
        return FALSE;
    }

    // remove this index from the list.  This does not keep the list order.
    void Remove(int index)
    {
        if (!bListIsLocked)
        {
            if (index >= 0 && index < Size())
            {
                // Remove the entry by copying the last entry over this index

                // Only move if this is not the last entry.
                if (index < Size() - 1)
                {
                    CopyElement(index, Get(Size() - 1));
                }

                nVectorList -= 1;
            }
        }
    }
};

/*++

    Char Vector type class.

--*/
class CharVector : public VectorT<char *>
{
};


class CAutoCrit
{
    CRITICAL_SECTION * criticalSection;

public:
    CAutoCrit(CRITICAL_SECTION * cs)
    {
        criticalSection = cs;
        EnterCriticalSection(criticalSection);
    }
    ~CAutoCrit()
    {
        LeaveCriticalSection(criticalSection);
    }
};


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\inc\classcfp.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CorrectPathChangesBase.cpp

 Abstract:
    Several paths were changed between Win9x and WinNT.  This routine defines
    the CorrectPathChangesBase routines that is called with a Win9x path and returns
    the corresponding WinNT path.

 History:
 
    03-Mar-00   robkenny    Converted CorrectPathChanges.cpp to this class.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.

--*/
#pragma once

#include "ShimHook.h"
#include "ShimLib.h"
#include "CharVector.h"
#include "StrSafe.h"


namespace ShimLib
{

class StringPairW
{
public:
    CString lpOld;
    CString lpNew;

    StringPairW()
    {
    }
    StringPairW(const WCHAR * lpszOld, const WCHAR * lpszNew)
    {
        lpOld = lpszOld;
        lpNew = lpszNew;
    }
};

class EnvironmentValues : public VectorT<StringPairW>
{
protected:
    BOOL            bInitialized;

public:
    EnvironmentValues();
    ~EnvironmentValues();

    void            Initialize();

    WCHAR *         ExpandEnvironmentValueW(const WCHAR * lpOld);
    char *          ExpandEnvironmentValueA(const char * lpOld);

    void            AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew);

    enum eAddNameEnum
    {
        eIgnoreName   = 0,
        eAddName      = 1,
    };
    enum eAddNoDLEnum
    {
        eIgnoreNoDL   = 0,
        eAddNoDL      = 1,
    };

    void            AddAll_CSIDL();
    void            Add_Variants(const WCHAR * lpEnvName, const WCHAR * lpEnvValue, eAddNameEnum eName, eAddNoDLEnum eNoDL);
    void            Add_CSIDL(const WCHAR * lpEnvName, int nFolder, eAddNameEnum eName, eAddNoDLEnum eNoDL);
};

class CorrectPathChangesBase
{
protected:

    EnvironmentValues * lpEnvironmentValues;
    VectorT<StringPairW>    vKnownPathFixes;

    BOOL                bInitialized;
    BOOL                bEnabled;

protected:
    virtual void    InitializePathFixes();
    virtual void    InitializeEnvironmentValuesW();

    void            AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew);
    void            InsertPathChangeW( const WCHAR * lpOld, const WCHAR * lpNew);

public:
    CorrectPathChangesBase();
    virtual ~CorrectPathChangesBase();

    // Init the class
    virtual BOOL    ClassInit();

    // Init all path changes, must be called after SHIM_STATIC_DLLS_INITIALIZED
    virtual void    InitializeCorrectPathChanges();

    virtual WCHAR * ExpandEnvironmentValueW(const WCHAR * lpOld);
    virtual char *  ExpandEnvironmentValueA(const char * lpOld);

    virtual void    AddPathChangeW(const WCHAR * lpOld, const WCHAR * lpNew);

    virtual void    AddCommandLineA(const char * lpCommandLine );
    virtual void    AddCommandLineW(const WCHAR * lpCommandLine );
    
    virtual void    AddFromToPairW(const WCHAR * lpFromToPair );

    virtual char *  CorrectPathAllocA(const char * str);
    virtual WCHAR * CorrectPathAllocW(const WCHAR * str);

    inline void     Enable(BOOL enable);
};


/*++
    Enable (or disable if value is FALSE) changing of paths.
--*/
inline void CorrectPathChangesBase::Enable(BOOL isEnabled)
{
    bEnabled = isEnabled;
}

// Typical path fixes
class CorrectPathChangesUser : public CorrectPathChangesBase
{
protected:
    virtual void    InitializePathFixes();
};

// Typical path fixes, moving user directories to All Users
class CorrectPathChangesAllUser : public CorrectPathChangesUser
{
protected:

    virtual void    InitializePathFixes();
};

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\inc\shimstack.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ShimStack.h

 Abstract:

    Macros for giving APIs a temporary stack.

 Notes:

    None

 History:

    02/26/2000 linstev  Created

--*/

#ifndef _SHIMSTACK_H_
#define _SHIMSTACK_H_

#ifdef _X86_

CRITICAL_SECTION g_csStack;
LPVOID g_pStack;
DWORD g_dwStackSize;
DWORD g_dwStackCopy;

// Macro to initialize memory and critical section for stack protection macros
// TotalSize : the total size for the temporary stack (in DWORDS)
// CopySize  : the size of the current stack to copy  (in DWORDS) 

#define INIT_STACK(TotalSize, CopySize)                                       \
    InitializeCriticalSection(&g_csStack);                                    \
    g_pStack = VirtualAlloc(NULL, TotalSize * 4, MEM_COMMIT, PAGE_READWRITE); \
    g_dwStackSize = TotalSize;                                                \
    g_dwStackCopy = CopySize;                           

// Macro to free the temporary stack and the critical section
#define FREE_STACK()                                                          \
    VirtualFree(g_pStack, 0, MEM_RELEASE);                                    \
    DeleteCriticalSection(&g_csStack);

// Get a new stack by copying the old to a buffer.
#define NEW_STACK()                                                           \
    EnterCriticalSection(&g_csStack);                                         \
    DWORD dwTempESP;                                                          \
    DWORD dwDiff = (g_dwStackSize - g_dwStackCopy) * 4;                       \
    __asm { mov  dwTempESP,esp                  }                             \
    __asm { push ecx                            }                             \
    __asm { push esi                            }                             \
    __asm { push edi                            }                             \
    __asm { mov  esi,dwTempESP                  }                             \
    __asm { mov  edi,g_pStack                   }                             \
    __asm { add  edi,dwDiff                     }                             \
    __asm { mov  ecx,g_dwStackCopy              }                             \
    __asm { cld                                 }                             \
    __asm { rep  movsd                          }                             \
    __asm { pop  esi                            }                             \
    __asm { pop  edi                            }                             \
    __asm { pop  ecx                            }                             \
    __asm { mov  esp,g_pStack                   }                             \
    __asm { add  esp,dwDiff                     }       

// Revert to the old stack
#define OLD_STACK()                                                           \
    __asm { mov esp,dwTempESP                   }                             \
    LeaveCriticalSection(&g_csStack);

#endif // _X86_

#endif // _SHIMSTACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\changeauthenticationlevel.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ChangeAuthenticationLevel.cpp

 Abstract:

   Sets the dwAuthnLevel for CoInitializeSecurity() to RPC_C_AUTHN_LEVEL_CONNECT.
   This fixes problems associated with a change with Windows 2000 and above where 
   RPC_C_AUTHN_LEVEL_NONE is nolonger promoted for local calls to PRIVACY.

 Notes:

   Only needed where app sets level to RPC_C_AUTHN_LEVEL_NONE.

 History:

   07/19/2000 jpipkins  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ChangeAuthenticationLevel)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CoInitializeSecurity)
APIHOOK_ENUM_END

/*++

 Adjust security level.

--*/

HRESULT
APIHOOK(CoInitializeSecurity)(
    PSECURITY_DESCRIPTOR pVoid,
    LONG cAuthSvc,
    SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
    void *pReserved1,
    DWORD dwAuthnLevel,
    DWORD dwImpLevel,
    SOLE_AUTHENTICATION_LIST *pAuthList,
    DWORD dwCapabilities,
    void *pReserved3
    )
{
    HRESULT hResult;

    DPFN( eDbgLevelInfo, "CoInitializeSecurity called");
    
    if (RPC_C_AUTHN_LEVEL_NONE == dwAuthnLevel)
    {
        LOGN( eDbgLevelWarning, "[APIHook_CoInitializeSecurity] Increasing authentication level");
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;    
    }

    hResult = ORIGINAL_API(CoInitializeSecurity)( 
        pVoid,
        cAuthSvc,
        asAuthSvc,
        pReserved1,
        dwAuthnLevel,
        dwImpLevel,
        pAuthList,
        dwCapabilities,
        pReserved3);
                                                
    return hResult;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLE32.DLL, CoInitializeSecurity)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\addwritepermissionstodevicefiles.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AddWritePermissionsToDeviceFiles.cpp

 Abstract:

    Add write permissions for IOCTL_SCSI_PASS_THROUGH under SECUROM.

    SecuRom can be debugged under a user-mode debugger but the following must 
    be done before hitting 'g' after attach:

        1. sxi av   <- ignore access violations
        2. sxi sse  <- ignore single step exception
        3. sxi ssec <- ignore single step exception continue
        4. sxi dz   <- ignore divide by zero

    It checksums it's executable, so breakpoints in certain places don't work.

 Notes:
    
    This is a general purpose shim.

 History:

    09/03/1999 v-johnwh Created
    03/09/2001 linstev  Rewrote DeviceIoControl to handle bad buffers and added 
                        debugging comments

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(AddWritePermissionsToDeviceFiles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(DeviceIoControl)
    APIHOOK_ENUM_ENTRY(CloseHandle)
APIHOOK_ENUM_END

VectorT<HANDLE> * g_hDevices;

CRITICAL_SECTION  g_CriticalSection;


// Is this letter a valid drive letter?
inline BOOL IsDriveLetter(char letter)
{
    return   (letter != '\0') &&
             ((letter >= 'a') && (letter <= 'z')) ||
             ((letter >= 'A') && (letter <= 'Z'));
}

/*++

 We need to add write permission to all CD-ROM devices

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    // Same behavior as the real CreateFileA
    if (lpFileName == NULL) {
        return INVALID_HANDLE_VALUE;
    }

    DWORD dwAccessMode = dwDesiredAccess;

    // Look for a device name: \\.\C:
    if ((lpFileName[0] == '\\') && 
        (lpFileName[1] == '\\') && 
        (lpFileName[2] == '.')  && 
        (lpFileName[3] == '\\') &&
        IsDriveLetter(lpFileName[4]) &&
        (lpFileName[5] == ':')
        ) {
        //
        // This file starts with \\.\ so it must be a device file.
         //

        if (!(dwAccessMode & GENERIC_WRITE)) {
            //
            // Make sure this device is a CD-ROM
            //
            char diskRootName[4];
            diskRootName[0] = lpFileName[4];
            diskRootName[1] = ':';
            diskRootName[2] = '\\';
            diskRootName[3] = 0;

            DWORD dwDriveType = GetDriveTypeA(diskRootName);
            if (DRIVE_CDROM == dwDriveType) {
                //
                // Add write permissions to give us NT4 behavior for device 
                // files
                //
                dwAccessMode |= GENERIC_WRITE;
            }
        }
    }

    HANDLE hRet = ORIGINAL_API(CreateFileA)(lpFileName, dwAccessMode, 
        dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
        dwFlagsAndAttributes, hTemplateFile);

    if ((hRet != INVALID_HANDLE_VALUE) && (dwAccessMode != dwDesiredAccess)) {
        //
        // Add the handle to our list so we can clean it up later.
        // 
        CAutoCrit autoCrit(&g_CriticalSection);
        g_hDevices->Append(hRet);
        LOGN( eDbgLevelError, "[CreateFileA] Added GENERIC_WRITE permission on device(%s)", lpFileName);
    }

    return hRet;
}

/*++

 Since we added write permission to CD-ROM devices for IOCTL_SCSI_PASS_THROUGH,
 we need to remove the write permission for all other IOCTLs passed to that device.

--*/

BOOL 
APIHOOK(DeviceIoControl)(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )
{
    LPVOID lpOut = lpOutBuffer;
    if (lpOutBuffer && nOutBufferSize && lpBytesReturned) {
        // 
        // Create a new output buffer, if this fails we just keep the original 
        // buffer.
        //

        lpOut = malloc(nOutBufferSize);
        if (lpOut) {
            MoveMemory(lpOut, lpOutBuffer, nOutBufferSize);
        } else {
            DPFN( eDbgLevelError, "Out of memory");
            lpOut = lpOutBuffer;
        }
    }

    BOOL bRet;
    if (IOCTL_SCSI_PASS_THROUGH != dwIoControlCode) {
        //
        // We don't care about IOCTL_SCSI_PASS_THROUGH
        //

        EnterCriticalSection(&g_CriticalSection);
        int existing = g_hDevices->Find(hDevice);
        LeaveCriticalSection(&g_CriticalSection);

        if (existing >= 0) {
            //
            // Check to see if this is a device that we added Write permissions
            // If it is, we need to create a handle with only Read permissions
            //

            HANDLE hDupped;

            bRet = DuplicateHandle(GetCurrentProcess(), hDevice, 
                GetCurrentProcess(), &hDupped, GENERIC_READ, FALSE, 0);

            if (bRet) {
                //
                // Call the IOCTL with the original (Read) permissions
                //
                bRet = ORIGINAL_API(DeviceIoControl)(hDupped, dwIoControlCode,
                    lpInBuffer, nInBufferSize, lpOut, nOutBufferSize, 
                    lpBytesReturned, lpOverlapped);

                CloseHandle(hDupped);

                goto Exit;
            }
        }
    }

    bRet = ORIGINAL_API(DeviceIoControl)(hDevice, dwIoControlCode, lpInBuffer,
        nInBufferSize, lpOut, nOutBufferSize, lpBytesReturned, lpOverlapped);

Exit:
    
    if (lpOut && (lpOut != lpOutBuffer)) {
        //
        // Need to copy the output back into the true output buffer
        //
        if (bRet && lpBytesReturned && *lpBytesReturned) {
            __try {
                MoveMemory(lpOutBuffer, lpOut, *lpBytesReturned);
            } __except(1) {
                DPFN( eDbgLevelError, "Failed to copy data into output buffer, perhaps it's read-only");
            }
        }

        free(lpOut);
    }

    return bRet;

} 

/*++

 If this handle is in our list, remove it.

--*/

BOOL 
APIHOOK(CloseHandle)(
    HANDLE hObject   
    )
{
    CAutoCrit autoCrit(&g_CriticalSection);
    int index = g_hDevices->Find(hObject);
    
    if (index >= 0) {
        g_hDevices->Remove(index);
    }

    return ORIGINAL_API(CloseHandle)(hObject);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hDevices = new VectorT<HANDLE>;
        if (g_hDevices == NULL)
        {
            return FALSE;
        }

        return InitializeCriticalSectionAndSpinCount(&g_CriticalSection, 0x80000000);
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeviceIoControl)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\duplicatehandlefix.cpp ===
/*++
 
 Copyright (c) 2001-2002 Microsoft Corporation
 
 Module Name:
 
    DuplicateHandleFix.cpp
 
 Abstract:
 
    DuplicateHandle was changed to always NULL the destination handle, even if 
    errors were generated.  THis shim ensures that the DestinationHandle is 
    not modified if the duplication was not successful.
 
 History:
 
    10/11/2001  robkenny        Created.
    02/20/2002  mnikkel         Added check for null lpTargetHandle
 
--*/
 
#include "precomp.h"
 
IMPLEMENT_SHIM_BEGIN(DuplicateHandleFix)
#include "ShimHookMacro.h"
 
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DuplicateHandle)
APIHOOK_ENUM_END
 
typedef BOOL (WINAPI *_pfn_DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions );
 
/*++
 
 Don't allow DestinationHandle to change of DuplicateHandle generates an error.
 
--*/
 
BOOL
APIHOOK(DuplicateHandle)(
    HANDLE hSourceProcessHandle,  // handle to source process
    HANDLE hSourceHandle,         // handle to duplicate
    HANDLE hTargetProcessHandle,  // handle to target process
    LPHANDLE lpTargetHandle,      // duplicate handle
    DWORD dwDesiredAccess,        // requested access
    BOOL bInheritHandle,          // handle inheritance option
    DWORD dwOptions               // optional actions
    )
{
    HANDLE origHandle = NULL;
 
    // Save the original value
    if (lpTargetHandle)
    {
        origHandle = *lpTargetHandle;
    }
 
    BOOL bSuccess = ORIGINAL_API(DuplicateHandle)(hSourceProcessHandle, 
        hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess,
        bInheritHandle, dwOptions);
 
    if (!bSuccess && lpTargetHandle)
    {
        //
        // DuplicateHandle has set *lpTargetHandle to NULL, revert to it's previous value.
        //
        *lpTargetHandle = origHandle;
 
        LOGN(eDbgLevelError, "DuplicateHandle failed, reverting *lpTargetHandle to previous value");
    }
 
    return bSuccess;
}
 
/*++
 
 Register hooked functions
 
--*/
 
HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, DuplicateHandle)
HOOK_END
 
IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\correctbitmapheader.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    CorrectBitmapHeader.cpp

 Abstract:
    If a BITMAPINFOHEADER specifies a non BI_RGB value for biCompression, it
    is supposed to specify a non zero biSizeImage.

 Notes:

    This is a general purpose shim.

 History:

    10/18/2000  maonis      Created
    03/15/2001  robkenny    Converted to CString
    02/14/2002  mnikkel     Converted to strsafe

--*/

#include "precomp.h"
#include <userenv.h>

IMPLEMENT_SHIM_BEGIN(CorrectBitmapHeader)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadImageA)
    APIHOOK_ENUM_ENTRY(LoadBitmapA)
APIHOOK_ENUM_END

typedef HBITMAP (*_pfn_LoadBitmapA)(HINSTANCE hinst, LPCSTR lpszName);

BOOL CheckForTemporaryDirA(
    LPSTR pszEnvVar,
    LPSTR pszTemporaryDir,
    DWORD dwTempSize
    )
{
    // Get Environment Variable string
    DWORD dwSize = GetEnvironmentVariableA(pszEnvVar, pszTemporaryDir, dwTempSize);
 
    // If dwSize is zero then we failed to find the string. Fail.
    if (dwSize == 0)
    {
        return FALSE;
    }

    // If dwSize is greater than dwTempSize then the buffer is too small. Fail with DPFN.
    if (dwSize > dwTempSize)
    {
        DPFN( eDbgLevelError, "[CheckTemporaryDirA] Buffer to hold %s directory path is too small.",
                pszEnvVar);
        return FALSE;
    }
 
    // Check to see if the string is a directory path.
    DWORD dwAttrib = GetFileAttributesA(pszTemporaryDir);
   
    if (dwAttrib == INVALID_FILE_ATTRIBUTES ||
        !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        return FALSE;
    }

    // We have a valid directory.
    return TRUE;
}

/*++

 Function Description:

    Get the temporary directory. We don't use GetTempPath here because it doesn't verify if 
    the temporary directory (specified by either the TEMP or the TMP enviorment variable) exists.
    If no TEMP or TMP is defined or the directory doesn't exist we get the user profile directory.

 Arguments:

    IN/OUT pszTemporaryDir - buffer to hold the temp directory upon return.

 Return Value:

    TRUE - we are able to find an appropriate temporary directory.
    FALSE otherwise.

- History:

    10/18/2000 maonis  Created
    02/20/2002 mnikkel Converted to strsafe.

--*/

BOOL 
GetTemporaryDirA(
    LPSTR pszTemporaryDir,
    DWORD dwTempSize
    )
{
    // Sanity check
    if (pszTemporaryDir == NULL || dwTempSize < 1)
    {
        return FALSE;
    }

    // Check for a TEMP environment variable
    if (CheckForTemporaryDirA("TEMP", pszTemporaryDir, dwTempSize) == FALSE)
    {
        // Didn't find TEMP, try TMP
        if (CheckForTemporaryDirA("TMP", pszTemporaryDir, dwTempSize) == FALSE)
        {
            HANDLE hToken = INVALID_HANDLE_VALUE;

            if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken) && 
                GetUserProfileDirectoryA(hToken, pszTemporaryDir, &dwTempSize))
            {
                DWORD dwAttrib =GetFileAttributesA(pszTemporaryDir);

                if (dwAttrib == INVALID_FILE_ATTRIBUTES ||
                    !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
                {
                    DPFN( eDbgLevelError, "[GetTemporaryDirA] Unable to find an appropriate temp directory");
                    return FALSE;
                }
            }
            else
            {
                DPFN( eDbgLevelError, "[GetTemporaryDirA] Unable to find an appropriate temp directory");
                return FALSE;
            }
        }
        else
        {
            DPFN( eDbgLevelInfo, "[GetTemporaryDirA] found TMP var");
        }
    }
    else
    {
        DPFN( eDbgLevelInfo, "[GetTemporaryDirA] found TEMP var");
    }

    return TRUE;
}

/*++

 Function Description:

    Copy the original file to a temporary file in the temporary directory. We use GetTempFileName
    to generate a temporary name but append .bmp to the filename because LoadImage doesn't recognize
    it if it doesn't have a .bmp extension.

 Arguments:

    IN pszFile - the name of the original file.
    IN/OUT pszNewFile - buffer to hold the new file name upon return.

 Return Value:

    TRUE - we are able to create a temporary file.
    FALSE otherwise.

 History:

    10/18/2000 maonis  Created

--*/

BOOL 
CreateTempFileA(
    LPCSTR pszFile, 
    LPSTR pszNewFile,
    DWORD dwNewSize
    )
{
    CHAR szDir[MAX_PATH];
    CHAR szTempFile[MAX_PATH];

    if (pszFile != NULL && pszNewFile != NULL && dwNewSize > 0)
    {
        // Find a temporary directory we can use
        if (GetTemporaryDirA(szDir, MAX_PATH))
        {
            // create a temp file name
            if (GetTempFileNameA(szDir, "abc", 0, szTempFile) != 0)
            {
                // Copy temp path to buffer
                if (StringCchCopyA(pszNewFile, dwNewSize, szTempFile) == S_OK &&
                    StringCchCatA(pszNewFile, dwNewSize, ".bmp") == S_OK)
                {
                    if (MoveFileA(szTempFile, pszNewFile) &&
                        CopyFileA(pszFile, pszNewFile, FALSE) &&
                        SetFileAttributesA(pszNewFile, FILE_ATTRIBUTE_NORMAL))
                    {
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}

/*++

 Function Description:

    Clean up the mapped file.

 Arguments:

    IN hFile - handle to the file.
    IN hFileMap - handle to the file view.
    IN pFileMap - pointer to the file view.

 Return Value:

    VOID.

 History:

    10/18/2000 maonis  Created

--*/

VOID 
CleanupFileMapping(
    HANDLE hFile, 
    HANDLE hFileMap, 
    LPVOID pFileMap)
{
    if (pFileMap != NULL)
    {
        UnmapViewOfFile(pFileMap);
    }

    if (hFileMap)
    {
        CloseHandle(hFileMap);
    }

    if (hFile && (hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(hFile);
    }
}

/*++

 Function Description:

    Examine the BITMAPINFOHEADER from a bitmap file and decide if we need to fix it.

 Arguments:

    IN pszFile - the name of the .bmp file.
    IN/OUT pszNewFile - buffer to hold the temporary file name if the function returns TRUE.
    
 Return Value:

    TRUE - We need to correct the header and we successfully copied the file to a temporary file.
    FALSE - Either we don't need to correct the header or we failed to create a temporary file.

 History:

    10/18/2000 maonis  Created

--*/

BOOL 
ProcessHeaderInFileA(
    LPCSTR pszFile, 
    LPSTR pszNewFile,
    DWORD dwNewSize
    )
{
    BOOL fIsSuccess = FALSE;
    HANDLE hFile = NULL;
    HANDLE hFileMap = NULL;
    LPBYTE pFileMap = NULL;

    if (pszFile == NULL || pszNewFile == NULL || dwNewSize < 1)
    {
        goto EXIT;
    }

    if (!IsBadReadPtr(pszFile, 1))
    { 
        hFile = CreateFileA(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        { 
            hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
            if (hFileMap != NULL)
            {
                pFileMap = (LPBYTE)MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
                if (pFileMap != NULL)
                {
                    BITMAPINFOHEADER* pbih = (BITMAPINFOHEADER*)(pFileMap + sizeof(BITMAPFILEHEADER));        

                    if (pbih->biSizeImage == 0 && pbih->biCompression != BI_RGB)
                    {
                        // We need to correct the header by creating a new bmp file that
                        // is identical to the original file except the header has correct
                        // image size.
                        if (CreateTempFileA(pszFile, pszNewFile, dwNewSize))
                        {
                            DPFN( eDbgLevelInfo, "[ProcessHeaderInFileA] Created a temp file %s", pszNewFile);
                            fIsSuccess = TRUE;
                        }
                        else
                        {
                            DPFN( eDbgLevelError, "[ProcessHeaderInFileA] Error create the temp file");
                        }
                    }
                    else
                    {
                        DPFN( eDbgLevelInfo, "[ProcessHeaderInFileA] The Bitmap header looks OK");
                    }
                }
            }
        }
    }

EXIT:
    
    CleanupFileMapping(hFile, hFileMap, pFileMap);    
    return fIsSuccess;
}

/*++

 Function Description:

    Make the biSizeImage field of the BITMAPINFOHEADER struct the size of the bitmap data.

 Arguments:

    IN pszFile - the name of the .bmp file.
    
 Return Value:

    TRUE - We successfully corrected the header.
    FALSE otherwise.

 History:

    10/18/2000 maonis  Created

--*/

BOOL FixHeaderInFileA(
    LPCSTR pszFile
    )
{
    BOOL fIsSuccess = FALSE;
    HANDLE hFileMap = NULL;
    LPBYTE pFileMap = NULL;

    if (pszFile == NULL)
    {
        return fIsSuccess;
    }
    
    // Open file
    HANDLE hFile = CreateFileA(
                    pszFile, 
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
        if (hFileMap != NULL)
        {
            pFileMap = (LPBYTE)MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0);
            if (pFileMap != NULL)
            {
                BITMAPFILEHEADER* pbfh = (BITMAPFILEHEADER*)pFileMap;
                BITMAPINFOHEADER* pbih = (BITMAPINFOHEADER*)(pFileMap + sizeof(BITMAPFILEHEADER));        

                // We make the image size the bitmap data size.
                pbih->biSizeImage = GetFileSize(hFile, NULL) - pbfh->bfOffBits;
                fIsSuccess = TRUE;
            }
        }
    }
  
    CleanupFileMapping(hFile, hFileMap, pFileMap);
    return fIsSuccess;
}

/*++

 Function Description:

    Adopted from the HowManyColors in \windows\core\ntuser\client\clres.c.

 Arguments:

    IN pbih - the BITMAPINFOHEADER* pointer.
    
 Return Value:

    The number of entries in the color table.

 History:

    10/18/2000 maonis  Created

--*/

DWORD HowManyColors(
    BITMAPINFOHEADER* pbih
    )
{
    if (pbih->biClrUsed) 
    {
         // If the bitmap header explicitly provides the number of colors
         // in the color table, use it.
        return (DWORD)pbih->biClrUsed;
    } 
    else if (pbih->biBitCount <= 8) 
    {
         // If the bitmap header describes a pallete-bassed bitmap
         // (8bpp or less) then the color table must be big enough
         // to hold all palette indecies.
        return (1 << pbih->biBitCount);
    } 
    else 
    {
        // For highcolor+ bitmaps, there's no need for a color table.
        // However, 16bpp and 32bpp bitmaps contain 3 DWORDS that 
        // describe the masks for the red, green, and blue components 
        // of entry in the bitmap.
        if (pbih->biCompression == BI_BITFIELDS) 
        {
            return 3;
        }
    }

    return 0;
}

/*++

 Function Description:

    Examine the BITMAPINFOHEADER in a bitmap resource and fix it as necessary.

 Arguments:

    IN hinst - the module instance where the bitmap resource resides.
    IN pszName - the resource name.
    OUT phglbBmp - the handle to the resource global memory.
    
 Return Value:

    TRUE - We successfully corrected the bitmap header if necessary.
    FALSE - otherwise.

 History:

    10/18/2000 maonis  Created

--*/

BOOL ProcessAndFixHeaderInResourceA(
    HINSTANCE hinst,   // handle to instance
    LPCSTR pszName,    // name or identifier of the image
    HGLOBAL* phglbBmp
    )
{
    HRSRC hrcBmp = FindResourceA(hinst, pszName, (LPCSTR)RT_BITMAP);
    if (hrcBmp != NULL && phglbBmp)
    {
        *phglbBmp = LoadResource(hinst, hrcBmp);
        if (*phglbBmp != NULL)
        {
            BITMAPINFOHEADER* pbih = (BITMAPINFOHEADER*)LockResource(*phglbBmp);
            if (pbih && pbih->biSizeImage == 0 && pbih->biCompression != BI_RGB)
            {
                // We need to correct the header by setting the right size in memory.
                pbih->biSizeImage = 
                    SizeofResource(hinst, hrcBmp) - 
                    sizeof(BITMAPINFOHEADER) -  
                    HowManyColors(pbih) * sizeof(RGBQUAD);

                return TRUE;
            }
        }
    }

    return FALSE;
}

HANDLE 
APIHOOK(LoadImageA)(
    HINSTANCE hinst,   // handle to instance
    LPCSTR lpszName,   // name or identifier of the image
    UINT uType,        // image type
    int cxDesired,     // desired width
    int cyDesired,     // desired height
    UINT fuLoad        // load options
    )
{
    // First call LoadImage see if it succeeds.
    HANDLE hImage = ORIGINAL_API(LoadImageA)(
                        hinst, 
                        lpszName,
                        uType,
                        cxDesired,
                        cyDesired,
                        fuLoad);
    if (hImage)
    {
        return hImage;
    }

    if (uType != IMAGE_BITMAP)
    {
        DPFN( eDbgLevelInfo, "We don't fix the non-bitmap types");
        return NULL;
    }

    // It failed. We'll correct the header.
    if (fuLoad & LR_LOADFROMFILE)
    {
        CHAR szNewFile[MAX_PATH];

        if (ProcessHeaderInFileA(lpszName, szNewFile, MAX_PATH))
        {
            // We now fix the bad header.
            if (FixHeaderInFileA(szNewFile))
            {
                // Call the API with the new file.
                hImage = ORIGINAL_API(LoadImageA)(hinst, szNewFile, uType, cxDesired, cyDesired, fuLoad);

                // Delete the temporary file.
                DeleteFileA(szNewFile);
            }
            else
            {
                DPFN( eDbgLevelError, "[LoadImageA] Error fixing the bad header in bmp file");
            }
        }
    }
    else
    {
        HGLOBAL hglbBmp = NULL;

        if (ProcessAndFixHeaderInResourceA(hinst, lpszName, &hglbBmp))
        {
            hImage = ORIGINAL_API(LoadImageA)(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);

            FreeResource(hglbBmp);
        }
    }

    if (hImage) 
    {
        LOGN( eDbgLevelInfo, "Bitmap header corrected");
    }

    return hImage;
}

HBITMAP 
APIHOOK(LoadBitmapA)(
    HINSTANCE hInstance,  // handle to application instance
    LPCSTR lpBitmapName   // name of bitmap resource
    )
{
    // First call LoadImage see if it succeeds.
    HBITMAP hImage = ORIGINAL_API(LoadBitmapA)(hInstance, lpBitmapName);

    if (hImage)
    {
        return hImage;
    }

    HGLOBAL hglbBmp = NULL;

    if (ProcessAndFixHeaderInResourceA(hInstance, lpBitmapName, &hglbBmp))
    {
        hImage = ORIGINAL_API(LoadBitmapA)(hInstance, lpBitmapName);

        if (hImage) 
        {
            LOGN( eDbgLevelInfo, "Bitmap header corrected");
        }

        FreeResource(hglbBmp);
    }

    return hImage;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, LoadImageA)
    APIHOOK_ENTRY(USER32.DLL, LoadBitmapA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\correctcreateeventname.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    CorrectCreateEventName.cpp

 Abstract:

    The \ character is not a legal character for an event.
    This shim will replace all \ characters with an underscore,
    except for Global\ or Local\ namespace tags.

 Notes:
    
    This is a general purpose shim.

 History:

    07/19/1999  robkenny    Created
    03/15/2001  robkenny    Converted to CString
    02/26/2002  robkenny    Security review.  Was not properly handling Global\ and Local\ namespaces.
                            Shim wasn't handling OpenEventA, making it pretty useless.

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectCreateEventName)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateEventA)
    APIHOOK_ENUM_ENTRY(OpenEventA)
APIHOOK_ENUM_END

typedef HANDLE (WINAPI *_pfn_OpenEventA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );


BOOL CorrectEventName(CString & csBadEventName)
{
    int nCount = 0;

    // Make sure we don't stomp Global\ or Local\ namespace prefixes.
    // Global and Local are case sensitive, and non-localized.

    if (csBadEventName.ComparePart(L"Global\\", 0, 7) == 0)
    {
        // This event exists in the global namespace
        csBadEventName.Delete(0, 7);
        nCount = csBadEventName.Replace(L'\\', '_');
        csBadEventName = L"Global\\" + csBadEventName;
    }
    else if (csBadEventName.ComparePart(L"Local\\", 0, 6) == 0)
    {
        // This event exists in the Local namespace
        csBadEventName.Delete(0, 6);
        nCount = csBadEventName.Replace(L'\\', '_');
        csBadEventName = L"Local\\" + csBadEventName;
    }
    else
    {
        nCount = csBadEventName.Replace(L'\\', '_');
    }

    return nCount != 0;
}

HANDLE 
APIHOOK(OpenEventA)(
  DWORD dwDesiredAccess,  // access
  BOOL bInheritHandle,    // inheritance option
  LPCSTR lpName          // object name
)
{
    DPFN( eDbgLevelInfo, "OpenEventA called with event name = %s.", lpName);

    if (lpName)
    {
        CSTRING_TRY
        {
            const char * lpCorrectName = lpName;

            CString csName(lpName);

            if (CorrectEventName(csName))
            {
                lpCorrectName = csName.GetAnsiNIE();
                LOGN( eDbgLevelError, 
                    "CreateEventA corrected event name from (%s) to (%s)", lpName, lpCorrectName);
            }

            HANDLE returnValue = ORIGINAL_API(OpenEventA)(dwDesiredAccess,
                                                          bInheritHandle,
                                                          lpCorrectName);
            return returnValue;
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    HANDLE returnValue = ORIGINAL_API(OpenEventA)(dwDesiredAccess,
                                                  bInheritHandle,
                                                  lpName);
    return returnValue;
}
/*+

 CreateEvent doesn't like event names that are similar to path names. This shim 
 will replace all \ characters with an underscore, unless they \ is part of either
 the Global\ or Local\ namespace tag.

--*/

HANDLE 
APIHOOK(CreateEventA)(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCSTR lpName                            // object name
    )
{
    DPFN( eDbgLevelInfo, "CreateEventA called with event name = %s.", lpName);

    if (lpName)
    {
        CSTRING_TRY
        {
            const char * lpCorrectName = lpName;

            CString csName(lpName);

            if (CorrectEventName(csName))
            {
                lpCorrectName = csName.GetAnsiNIE();
                LOGN( eDbgLevelError, 
                    "CreateEventA corrected event name from (%s) to (%s)", lpName, lpCorrectName);
            }

            HANDLE returnValue = ORIGINAL_API(CreateEventA)(lpEventAttributes,
                                                            bManualReset,
                                                            bInitialState,
                                                            lpCorrectName);
            return returnValue;
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    HANDLE returnValue = ORIGINAL_API(CreateEventA)(lpEventAttributes,
                                                    bManualReset,
                                                    bInitialState,
                                                    lpName);
    return returnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateEventA)
    APIHOOK_ENTRY(KERNEL32.DLL, OpenEventA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\correctfilepaths.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectFilePaths.cpp

 Abstract:

   This APIHooks CreateProcess and attempts to convert paths from Win9x locations to Win2000
   locations.  For example "C:\WINNT\WRITE.EXE" will be converted to C:\WINNT\SYSTEM32\WRITE.EXE"

 Notes:

   This APIHook emulates Windows 9x.

 Created:

   12/15/1999 robkenny

 Modified:

    03/14/2000  robkenny        Now uses ClassCFP instead of global routines.
    03/31/2000  robkenny        ShellExecuteEx now handle lpDirectory path as well.
    05/18/2000  a-sesk          GetCommandLineA and GetCommandLineW convert cmd line args to short path.
    06/20/2000  robkenny        Added SetFileAttributes() 
    06/22/2000  robkenny        Reordered enum list and DECLARE_APIHOOK list to match each other.
    --SERIOUS CHANGE--
    10/30/2000  robkenny        Added path specific fixes.
                                Command lines now have the EXE path removed and corrected
                                separately from the remainder of the command line.
    11/13/2000  a-alexsm        Added SetArguments & SetIconLocation hooks
    11/13/2000  robkenny        Changed CorrectPath to always return a valid string
                                by returning the original string.  Must call CorrectFree
                                to properly release the memory.
    12/14/2000  prashkud        Added hooks for _lopen and _lcreat
    03/10/2001  robkenny        Do not convert any paths until *after* all shims have been loaded.
    03/15/2001  robkenny        Converted to CString

--*/


#include "precomp.h"
#include "ClassCFP.h"

IMPLEMENT_SHIM_BEGIN(CorrectFilePaths)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(ShellExecuteA)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
    APIHOOK_ENUM_ENTRY(ShellExecuteExA)
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)

    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetCommandLineW)

    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(CopyFileExA)
    APIHOOK_ENUM_ENTRY(CopyFileExW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExW)

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)

    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExW)

    APIHOOK_ENUM_ENTRY(GetBinaryTypeA)
    APIHOOK_ENUM_ENTRY(GetBinaryTypeW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)

    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(MoveFileExA)
    APIHOOK_ENUM_ENTRY(MoveFileExW)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressA)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressW)

    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryA)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryW)

    APIHOOK_ENUM_ENTRY(OpenFile)

    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)

    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)

    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)

    APIHOOK_ENUM_ENTRY(LoadImageA)
APIHOOK_ENUM_END


// This is a private define (shlapip.h) that can mess up ShellExecuteEx
#ifndef SEE_MASK_FILEANDURL
#define SEE_MASK_FILEANDURL       0x00400000
#endif


/*++

    CorrectFree: free lpMalloc if it is different from lpOrig

--*/
inline void CorrectFree(char * lpMalloc, const char * lpOrig)
{
    if (lpMalloc != lpOrig)
    {
        free(lpMalloc);
    }
}

inline void CorrectFree(WCHAR * lpMalloc, const WCHAR * lpOrig)
{
    if (lpMalloc != lpOrig)
    {
        free(lpMalloc);
    }
}

/*++

    Our path changing class.
    Note: This is a pointer to the base class.
    Note: g_PathCorrector *MUST* remain NULL until after SHIM_STATIC_DLLS_INITIALIZED

--*/
CorrectPathChangesBase * g_PathCorrector = NULL;
CorrectPathChangesBase * g_AllocatedPathCorrector = NULL;


/*++

    Values that can be modified by the command line

--*/
enum PathCorrectorEnum
{
    ePathCorrectorBase,
    ePathCorrectorUser,
    ePathCorrectorAllUser,
};

BOOL g_bCreateProcessRoutines           = TRUE;
BOOL g_bGetCommandLineRoutines          = FALSE;
BOOL g_bRegSetValueRoutines             = FALSE;
BOOL g_bFileRoutines                    = TRUE;
BOOL g_bProfileRoutines                 = TRUE;
BOOL g_bShellLinkRoutines               = TRUE;
BOOL g_bW9xPath                         = FALSE;
BOOL g_bLoadImage                       = FALSE;


PathCorrectorEnum g_pathcorrectorType   = ePathCorrectorAllUser;

int             g_nExtraPathCorrections     = 0;
CString *       g_ExtraPathCorrections;

/*++

    Parse the command line.

--*/
BOOL ParseCommandLine(const char * commandLine)
{
    // Force the default values
    g_bCreateProcessRoutines        = TRUE;
    g_bGetCommandLineRoutines       = FALSE;
    g_bRegSetValueRoutines          = FALSE;
    g_bFileRoutines                 = TRUE;
    g_bProfileRoutines              = TRUE;
    g_bShellLinkRoutines            = TRUE;
    g_bW9xPath                      = FALSE;
    g_bLoadImage                    = FALSE;

    g_pathcorrectorType             = ePathCorrectorAllUser;
    g_nExtraPathCorrections         = 0;
    g_ExtraPathCorrections          = NULL;

    // Search the beginning of the command line for these switches
    //
    // Switch           Default     Meaning
    //================  =======     =========================================================
    // -a                  Y        Force shortcuts to All Users
    // -c                  N        Do not shim Create process routines
    // -f                  N        Do not shim File routines
    // -p                  N        Do not shim GetPrivateProfile routines
    // -s                  N        Do not shim IShellLink routines
    // -b                  N        Bare: Use the base corrector (has no built-in path changes)
    // -u                  N        User: Built-in paths correct to <username>/Start Menu and <username>/Desktop
    // +GetCommandLine     N        shim GetCommandLine routines
    // +RegSetValue        N        shim the RegSetValue and RegSetValueEx routines
    // +Win9xPath          N        Apply Win9x *path* specific fixes (does not apply to command lines)
    // -Profiles           N        Do not force shortcuts to All Users
    // +LoadBitmap         N        shim the LoadBitmapA routine
    //

    CSTRING_TRY
    {
        CString csCl(commandLine);
        CStringParser csParser(csCl, L" ");
    
        int argc = csParser.GetCount();
        if (csParser.GetCount() == 0)
        {
            return TRUE; // Not an error
        }

        // allocate for worst case
        g_ExtraPathCorrections = new CString[argc];
        if (!g_ExtraPathCorrections)
        {
            return FALSE;   // Failure
        }
        g_nExtraPathCorrections = 0;
    
        for (int i = 0; i < argc; ++i)
        {
            CString & csArg = csParser[i];
    
            DPFN( eDbgLevelSpew, "Argv[%d] == (%S)\n", i, csArg.Get());
        
            if (csArg == L"-a")
            {
                g_pathcorrectorType = ePathCorrectorAllUser;
            }
            else if (csArg == L"-b")
            {
                g_pathcorrectorType = ePathCorrectorBase;
            }
            else if (csArg == L"-u" || csArg == L"-Profiles")
            {
                g_pathcorrectorType = ePathCorrectorUser;
            }
            else if (csArg == L"-c")
            {
                g_bCreateProcessRoutines = FALSE;
            }
            else if (csArg == L"-f")
            {
                g_bFileRoutines = FALSE;
            }
            else if (csArg == L"-p")
            {
                g_bProfileRoutines = FALSE;
            }
            else if (csArg == L"-s")
            {
                g_bShellLinkRoutines = FALSE;
            }
            else if (csArg == L"+GetCommandLine")
            {
                DPFN( eDbgLevelInfo, "Command line routines will be shimmed\n");
                g_bGetCommandLineRoutines = TRUE;
            }
            else if (csArg == L"+RegSetValue")
            {
                DPFN( eDbgLevelInfo, "RegSetValue routines will be shimmed\n");
                g_bRegSetValueRoutines = TRUE;
            }
            else if (csArg == L"+Win9xPath")
            {
                DPFN( eDbgLevelInfo, "Win9x Path corrections will be applied\n");
                g_bW9xPath = TRUE;
            }
            else if (csArg == L"+LoadImage")
            {
                DPFN( eDbgLevelInfo, "LoadImageA will be shimmed\n");
                g_bLoadImage = TRUE;
            }
            else
            {
                g_ExtraPathCorrections[g_nExtraPathCorrections] = csArg;
                g_nExtraPathCorrections += 1;
            }
        }

#if DBG
        // Dump out the new path correction values.
        {
            const char *lpszPathCorrectorType = "Unknown"; 
            if (g_pathcorrectorType == ePathCorrectorBase)
            {
                lpszPathCorrectorType = "ePathCorrectorBase";
            }
            else if (g_pathcorrectorType == ePathCorrectorUser)
            {
                lpszPathCorrectorType = "ePathCorrectorUser";
            }
            else if (g_pathcorrectorType == ePathCorrectorAllUser)
            {
                lpszPathCorrectorType = "ePathCorrectorAllUser";
            }
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim CreateProcessRoutines  = %d\n", g_bCreateProcessRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim GetCommandLineRoutines = %d\n", g_bGetCommandLineRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim RegSetValueRoutines    = %d\n", g_bRegSetValueRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim FileRoutines           = %d\n", g_bFileRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim ProfileRoutines        = %d\n", g_bProfileRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim ShellLinkRoutines      = %d\n", g_bShellLinkRoutines);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim LoadImageA             = %d\n", g_bLoadImage);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim W9xPath                = %d\n", g_bW9xPath);
            DPFN( eDbgLevelInfo, "[ParseCommandLine] Shim Path Corrector Type    = %s\n", lpszPathCorrectorType);

            for (int i = 0; i < g_nExtraPathCorrections; ++i)
            {
                DPFN( eDbgLevelInfo, "[ParseCommandLine] Extra Path Change(%S)\n", g_ExtraPathCorrections[i].Get()); 
            }
        }
#endif

    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}

/*++

    Create the appropriate g_PathCorrector
    Return TRUE if we were successful in creating and initializing.

    Note: We create g_AllocatedPathCorrector because g_PathCorrector must remain NULL until SHIM_STATIC_DLLS_INITIALIZED

--*/
BOOL InitPathcorrectorClass()
{
    switch (g_pathcorrectorType)
    {
    case ePathCorrectorBase:
        g_AllocatedPathCorrector  = new CorrectPathChangesBase;
        break;

    case ePathCorrectorUser:
         g_AllocatedPathCorrector = new CorrectPathChangesUser;
        break;

    case ePathCorrectorAllUser:
    default:
         g_AllocatedPathCorrector = new CorrectPathChangesAllUser;
        break;

    };

    if (g_AllocatedPathCorrector)
    {
        return g_AllocatedPathCorrector->ClassInit();
    }

    return FALSE;
}

/*++

    Add all the path corrections to the path corrector.
    Call after SHIM_STATIC_DLLS_INITIALIZED

--*/
void InitializePathCorrections()
{
    if (g_PathCorrector)
    {
        g_PathCorrector->InitializeCorrectPathChanges();

        if (g_ExtraPathCorrections && g_nExtraPathCorrections)
        {
            // Add the command line to this Path Corrector
            for (int i = 0; i < g_nExtraPathCorrections; ++i)
            {
                g_PathCorrector->AddFromToPairW(g_ExtraPathCorrections[i]);
            }

            delete [] g_ExtraPathCorrections;
            g_ExtraPathCorrections  = NULL;
            g_nExtraPathCorrections = 0;
        }
    }
}

/*++

    Return a pointer to the PathCorrecting object

--*/
inline CorrectPathChangesBase * GetPathcorrecter()
{
    return g_PathCorrector;
}

inline void DebugSpew(const WCHAR * uncorrect, const WCHAR * correct, const char * debugMsg)
{
    if (correct && uncorrect && _wcsicmp(correct, uncorrect) != 0)
    {
        LOGN( eDbgLevelError, "%s corrected path:\n    %S\n    %S\n",
            debugMsg, uncorrect, correct);
    }
    else // Massive Spew:
    {
        DPFN( eDbgLevelSpew, "%s unchanged %S\n", debugMsg, uncorrect);
    }
}

inline void DebugSpew(const char * uncorrect, const char * correct, const char * debugMsg)
{
    if (correct && uncorrect && _stricmp(correct, uncorrect) != 0)
    {
        LOGN( eDbgLevelError, "%s corrected path:\n    %s\n    %s\n",
            debugMsg, uncorrect, correct);
    }
    else // Massive Spew:
    {
        DPFN( eDbgLevelSpew, "%s unchanged %s\n", debugMsg, uncorrect);
    }
}




/*++

    Given a string, correct the path.
    bMassagePath determines of path specific fixes are applied
       (should be FALSE for command lines)

--*/
WCHAR * CorrectorCorrectPath(CorrectPathChangesBase * pathCorrector, const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath)
{
    if (uncorrect == NULL)
        return NULL;

    if (!pathCorrector)
        return (WCHAR *)uncorrect;

    const WCHAR * W9xCorrectedPath = uncorrect;

    // Check and see if we need to perform the special Win9x path massaging
    if (bMassagePath)
    {
        W9xCorrectedPath = W9xPathMassageW(uncorrect);
    }

    WCHAR * strCorrectFile = pathCorrector->CorrectPathAllocW(W9xCorrectedPath);

    // If the allocation failed, return the original string.
    // This should allow the shim routines to pass along the orignal
    // values to the hooked APIs, which if they fail, will have the
    // proper error codes.
    if (!strCorrectFile)
    {
        strCorrectFile = (WCHAR *)uncorrect;
    }
    else if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrectFile, debugMsg);
    }

    if (W9xCorrectedPath != uncorrect)
        free((WCHAR *)W9xCorrectedPath);

    return strCorrectFile;
}

WCHAR * CorrectPath(const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    WCHAR *  wstrCorrectFile = const_cast<WCHAR *>(uncorrect);
    CSTRING_TRY
    {
        CorrectPathChangesBase * pathCorrector = GetPathcorrecter();

        wstrCorrectFile = CorrectorCorrectPath(pathCorrector, uncorrect, debugMsg, bMassagePath);
    }
    CSTRING_CATCH
    {
        // Fall through
    }

    return wstrCorrectFile;
}

/*++

    Given a string, correct the path.
    bMassagePath determines of path specific fixes are applied
       (should be FALSE for command lines)

--*/
char * CorrectPath(const char * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    char * strCorrectFile = const_cast<char *>(uncorrect);

    CSTRING_TRY
    {
        CString csUncorrect(uncorrect);

        WCHAR * wstrCorrectFile = CorrectPath(csUncorrect, NULL, bMassagePath);

        // Don't assign to strCorrectFile unless we successfully allocate the memory.
        char * lpszChar = ToAnsi(wstrCorrectFile);
        if (lpszChar)
        {
            strCorrectFile = lpszChar;
        }

        CorrectFree(wstrCorrectFile, csUncorrect);
    }
    CSTRING_CATCH
    {
        // Fall through
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrectFile, debugMsg);
    }

    return strCorrectFile;
}


DWORD APIHOOK(GetFileAttributesA)(
  LPCSTR lpFileName   // name of file or directory
)
{
    char * strCorrect = CorrectPath(lpFileName, "GetFileAttributesA");

    DWORD returnValue = ORIGINAL_API(GetFileAttributesA)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

DWORD APIHOOK(GetFileAttributesW)(
  LPCWSTR lpFileName   // name of file or directory
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "GetFileAttributesW");

    DWORD returnValue = ORIGINAL_API(GetFileAttributesW)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(SetFileAttributesA)(
  LPCSTR lpFileName,      // file name
  DWORD dwFileAttributes   // attributes
)
{
    char * strCorrect = CorrectPath(lpFileName, "SetFileAttributesA");

    DWORD returnValue = ORIGINAL_API(SetFileAttributesA)(strCorrect, dwFileAttributes);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

DWORD APIHOOK(SetFileAttributesW)(
  LPCWSTR lpFileName,      // file name
  DWORD dwFileAttributes   // attributes
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "SetFileAttributesW");

    DWORD returnValue = ORIGINAL_API(SetFileAttributesW)(strCorrect, dwFileAttributes);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(GetFileAttributesExA)(
  LPCSTR lpFileName,                   // file or directory name
  GET_FILEEX_INFO_LEVELS fInfoLevelId,  // attribute 
  LPVOID lpFileInformation              // attribute information 
)
{
    char * strCorrect = CorrectPath(lpFileName, "GetFileAttributesExA");

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExA)(strCorrect, fInfoLevelId, lpFileInformation);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(GetFileAttributesExW)(
  LPCWSTR lpFileName,                   // file or directory name
  GET_FILEEX_INFO_LEVELS fInfoLevelId,  // attribute 
  LPVOID lpFileInformation              // attribute information 
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "GetFileAttributesExW");

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExW)(strCorrect, fInfoLevelId, lpFileInformation);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for CreateProcessA

--*/
BOOL APIHOOK(CreateProcessA)(
                    LPCSTR lpApplicationName,                 
                    LPSTR lpCommandLine,                      
                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
                    BOOL bInheritHandles,                     
                    DWORD dwCreationFlags,                    
                    LPVOID lpEnvironment,                     
                    LPCSTR lpCurrentDirectory,                
                    LPSTARTUPINFOA lpStartupInfo,             
                    LPPROCESS_INFORMATION lpProcessInformation)
{
    // Application name and command line that is passed to CreateProcess
    // Will either point to lpApplicationName or strCorrectApplicationName
    // Will either point to lpCommandLine     or strCorrectCommandLine
    const char * pstrCorrectApplicationName = lpApplicationName;
    char * pstrCorrectCommandLine = lpCommandLine;

    if (lpApplicationName != NULL)
    {
        // Get a buffer containing the application name with the corrected path
        pstrCorrectApplicationName = CorrectPath(lpApplicationName, "CreateProcessA ApplicationName:");
    }

    if (lpCommandLine != NULL)
    {
        // Get a buffer containing the command line with the corrected path
        pstrCorrectCommandLine = CorrectPath(lpCommandLine, "CreateProcessA CommandLine:", FALSE);
    }

    DPFN( eDbgLevelInfo, "CreateProcessA Application(%s) CommandLine(%s)\n", pstrCorrectApplicationName, pstrCorrectCommandLine);
    
    BOOL returnValue = ORIGINAL_API(CreateProcessA)(pstrCorrectApplicationName,
                                                 pstrCorrectCommandLine,
                                                 lpProcessAttributes,
                                                 lpThreadAttributes, 
                                                 bInheritHandles,                     
                                                 dwCreationFlags,                    
                                                 lpEnvironment,                     
                                                 lpCurrentDirectory,                
                                                 lpStartupInfo,             
                                                 lpProcessInformation);

    CorrectFree(const_cast<char*>(pstrCorrectApplicationName), lpApplicationName);
    CorrectFree(pstrCorrectCommandLine, lpCommandLine);

    return returnValue;
}


/*++

    Convert Win9x paths to WinNT paths for CreateProcessW

--*/

BOOL APIHOOK(CreateProcessW)(
                    LPCWSTR lpApplicationName,
                    LPWSTR lpCommandLine,
                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                    LPSECURITY_ATTRIBUTES lpThreadAttributes,
                    BOOL bInheritHandles,
                    DWORD dwCreationFlags,
                    LPVOID lpEnvironment,
                    LPCWSTR lpCurrentDirectory,
                    LPSTARTUPINFOW lpStartupInfo,
                    LPPROCESS_INFORMATION lpProcessInformation)
{
    // Application name and command line that is passed to CreateProcess
    // Will either point to lpApplicationName or strCorrectApplicationName
    // Will either point to lpCommandLine     or strCorrectCommandLine
    const WCHAR * pstrCorrectApplicationName = lpApplicationName;
    WCHAR * pstrCorrectCommandLine = lpCommandLine;

    if (lpApplicationName != NULL)
    {
        // Get a buffer containing the application name with the corrected path
        pstrCorrectApplicationName = CorrectPath(lpApplicationName, "CreateProcessW ApplicationName:");
    }

    if (lpCommandLine != NULL)
    {
        // Get a buffer containing the command line with the corrected path
        pstrCorrectCommandLine = CorrectPath(lpCommandLine, "CreateProcessW CommandLine:", FALSE);
    }

    DPFN( eDbgLevelInfo, "CreateProcessW Application(%S) CommandLine(%S)\n", pstrCorrectApplicationName, pstrCorrectCommandLine);

    BOOL returnValue = ORIGINAL_API(CreateProcessW)(pstrCorrectApplicationName,
                                                 pstrCorrectCommandLine,
                                                 lpProcessAttributes,
                                                 lpThreadAttributes, 
                                                 bInheritHandles,                     
                                                 dwCreationFlags,                    
                                                 lpEnvironment,                     
                                                 lpCurrentDirectory,                
                                                 lpStartupInfo,             
                                                 lpProcessInformation);

    CorrectFree(const_cast<WCHAR *>(pstrCorrectApplicationName), lpApplicationName);
    CorrectFree(pstrCorrectCommandLine, lpCommandLine);

    return returnValue;
}


/*++

    Convert Win9x paths to WinNT paths for WinExec

--*/

UINT APIHOOK(WinExec)(LPCSTR lpCmdLine, UINT uCmdShow)
{
    // Get a buffer containing the command line with the corrected path
    char * strCorrect = CorrectPath(lpCmdLine, "WinExec", FALSE);

    UINT returnValue = ORIGINAL_API(WinExec)(strCorrect, uCmdShow);

    CorrectFree(strCorrect, lpCmdLine);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteA

--*/

HINSTANCE APIHOOK(ShellExecuteA)(
            HWND hwnd, 
            LPCSTR lpVerb,
            LPCSTR lpFile, 
            LPCSTR lpParameters, 
            LPCSTR lpDirectory,
            INT nShowCmd
           )
{
    HINSTANCE returnValue = (HINSTANCE)SE_ERR_OOM;
    // Since this command is executed by the shell, it may contain %env% variables,
    // expand them before calling correctpath.

    CSTRING_TRY
    {
        CString csExpandFile(lpFile);
        csExpandFile.ExpandEnvironmentStringsW();

        returnValue = ORIGINAL_API(ShellExecuteA)(hwnd, lpVerb, csExpandFile.GetAnsi(), lpParameters, lpDirectory, nShowCmd);
    }
    CSTRING_CATCH
    {
        // Error expanding the string, just pass the value thru.

        returnValue = ORIGINAL_API(ShellExecuteA)(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);
    }

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteW

--*/

HINSTANCE APIHOOK(ShellExecuteW)(
            HWND hwnd, 
            LPCWSTR lpVerb,
            LPCWSTR lpFile, 
            LPCWSTR lpParameters, 
            LPCWSTR lpDirectory,
            INT nShowCmd
           )
{
    HINSTANCE returnValue = (HINSTANCE)SE_ERR_OOM;
    // Since this command is executed by the shell, it may contain %env% variables,
    // expand them before calling correctpath.

    CSTRING_TRY
    {
        CString csExpandFile(lpFile);
        csExpandFile.ExpandEnvironmentStringsW();

        returnValue = ORIGINAL_API(ShellExecuteW)(hwnd, lpVerb, csExpandFile, lpParameters, lpDirectory, nShowCmd);
    }
    CSTRING_CATCH
    {
        // Error expanding the string, just pass the value thru.

        returnValue = ORIGINAL_API(ShellExecuteW)(hwnd, lpVerb, lpFile, lpParameters, lpDirectory, nShowCmd);
    }

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteExA

--*/

BOOL APIHOOK(ShellExecuteExA)(
            LPSHELLEXECUTEINFOA lpExecInfo
           )
{
    // Check for this magical internal flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL)
    {
        return ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
    }

    const char * lpFile      = lpExecInfo->lpFile;
    const char * lpDirectory = lpExecInfo->lpDirectory;

    char * strFileCorrect;
    char * strDirCorrect;

    // Check to see if app is expecting %env% substitution
    if (lpExecInfo->fMask & SEE_MASK_DOENVSUBST )
    {
        CSTRING_TRY
        {
            CString csExpandedFile(lpFile);
            CString csExpandedDir(lpDirectory);

            csExpandedFile.ExpandEnvironmentStringsW();
            csExpandedDir.ExpandEnvironmentStringsW();

            strFileCorrect = CorrectPath(csExpandedFile.GetAnsi(), "ShellExecuteExA");
            strDirCorrect  = CorrectPath(csExpandedDir.GetAnsi(),  "ShellExecuteExA");
        }
        CSTRING_CATCH
        {
            // Failed to expand the env values, pass all values untouched.
            return ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
        }
    }
    else
    {
        strFileCorrect = CorrectPath(lpFile,      "ShellExecuteExA");
        strDirCorrect  = CorrectPath(lpDirectory, "ShellExecuteExA");
    }

    // Save the original fileName
    lpExecInfo->lpFile      = strFileCorrect;
    lpExecInfo->lpDirectory = strDirCorrect;
    BOOL returnValue        = ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
    lpExecInfo->lpFile      = lpFile;
    lpExecInfo->lpDirectory = lpDirectory;

    CorrectFree(strFileCorrect, lpFile);
    CorrectFree(strDirCorrect, lpDirectory);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteExW

--*/

BOOL APIHOOK(ShellExecuteExW)(
            LPSHELLEXECUTEINFOW lpExecInfo
           )
{
    // Check for this magical *internal* flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL)
    {
        return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    }


    const WCHAR * lpFile      = lpExecInfo->lpFile;
    const WCHAR * lpDirectory = lpExecInfo->lpDirectory;

    WCHAR * strFileCorrect;
    WCHAR * strDirCorrect;

    // Check to see if app is expecting %env% substitution
    if (lpExecInfo->fMask & SEE_MASK_DOENVSUBST )
    {
        CSTRING_TRY
        {
            CString csExpandedFile(lpFile);
            CString csExpandedDir(lpDirectory);

            csExpandedFile.ExpandEnvironmentStringsW();
            csExpandedDir.ExpandEnvironmentStringsW();

            strFileCorrect = CorrectPath(csExpandedFile, "ShellExecuteExW");
            strDirCorrect  = CorrectPath(csExpandedDir,  "ShellExecuteExW");
        }
        CSTRING_CATCH
        {
            // Failed to expand the env values, pass all values untouched.
            return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
        }
    }
    else
    {
        strFileCorrect = CorrectPath(lpFile,      "ShellExecuteExW");
        strDirCorrect  = CorrectPath(lpDirectory, "ShellExecuteExW");
    }

    // Save the original fileName
    lpExecInfo->lpFile      = strFileCorrect;
    lpExecInfo->lpDirectory = strDirCorrect;
    BOOL returnValue        = ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    lpExecInfo->lpFile      = lpFile;
    lpExecInfo->lpDirectory = lpDirectory;

    CorrectFree(strFileCorrect, lpFile);
    CorrectFree(strDirCorrect, lpDirectory);

    return returnValue;
}



/*++
    Convert long command line paths to short paths for GetCommandLineW

--*/

LPCWSTR APIHOOK(GetCommandLineW)()
{
    static LPCWSTR wstrCorrectCommandLine = NULL;

    if (wstrCorrectCommandLine == NULL)
    {
        LPCWSTR wstrCommandLine = ORIGINAL_API(GetCommandLineW)();

        wstrCorrectCommandLine = CorrectPath(wstrCommandLine, "GetCommandLineW", FALSE);
    }
    return wstrCorrectCommandLine;
}


/*++
    Convert long command line paths to short paths for GetCommandLineA

--*/

LPCSTR APIHOOK(GetCommandLineA)()
{
    static LPCSTR strCorrectCommandLine = NULL;

    if (strCorrectCommandLine == NULL)
    {
        LPCSTR strCommandLine = ORIGINAL_API(GetCommandLineA)();

        strCorrectCommandLine = CorrectPath(strCommandLine, "GetCommandLineA", FALSE);
    }
    return strCorrectCommandLine;
}


/*++

    The PrivateProfile routines treat filenames differently than pathnames.
    If we have Win9xPath corrections enabled, it is possible to "fix" a path
    from .\example.ini to example.ini.  Unfortunately the PrivateProfile routines
    look for example.ini in %windir%
    
    If we have a path that contains path seperators, we must ensure that
    the resulting string also contains path separators.

--*/

char * ProfileCorrectPath(const char * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    char * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        char * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            if (csUncorrect.FindOneOf(L"\\/") >= 0)
            {
                // Found some path separators in the original string, check the corrected string.
                // If the corrected string does  not have any path separators,
                // then the path was corrected from .\example.ini to example.ini

                CString csCorrect(strCorrect);
                if (csCorrect.FindOneOf(L"\\/") < 0)
                {
                    // No path seperators, make this a CWD relative path

                    csCorrect.Insert(0, L".\\");

                    returnString = csCorrect.ReleaseAnsi();
                }
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}


/*++

    The PrivateProfile routines treat filenames differently than pathnames.
    If we have Win9xPath corrections enabled, it is possible to "fix" a path
    from .\example.ini to example.ini.  Unfortunately the PrivateProfile routines
    look for example.ini in %windir%
    
    If we have a path that contains path seperators, we must ensure that
    the resulting string also contains path separators.

--*/

WCHAR * ProfileCorrectPath(const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    WCHAR * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        WCHAR * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            if (csUncorrect.FindOneOf(L"\\/") >= 0)
            {
                // Found some path separators in the original string, check the corrected string.
                // If the corrected string does  not have any path separators,
                // then the path was corrected from .\example.ini to example.ini

                CString csCorrect(strCorrect);
                if (csCorrect.FindOneOf(L"\\/") < 0)
                {
                    // No path seperators, make this a CWD relative path

                    csCorrect.Insert(0, L".\\");

                    // Manually copy the buffer
                    size_t nBytes = (csCorrect.GetLength() + 1) * sizeof(WCHAR);
                    returnString = (WCHAR*) malloc(nBytes);
                    if (returnString)
                    {
                        memcpy(returnString, csCorrect.Get(), nBytes);
                    }
                }
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }
 
    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileIntA

--*/

UINT APIHOOK(GetPrivateProfileIntA)(
        LPCSTR lpAppName,   // section name
        LPCSTR lpKeyName,   // key name
        INT nDefault,       // return value if key name not found
        LPCSTR lpFileName   // initialization file name
       )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileIntA");

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntA)(lpAppName, lpKeyName, nDefault, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileIntW

--*/

UINT APIHOOK(GetPrivateProfileIntW)(
        LPCWSTR lpAppName,  // section name
        LPCWSTR lpKeyName,  // key name
        INT nDefault,       // return value if key name not found
        LPCWSTR lpFileName  // initialization file name
       )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileIntW");

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntW)(lpAppName, lpKeyName, nDefault, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionA

--*/

DWORD APIHOOK(GetPrivateProfileSectionA)(
        LPCSTR lpAppName,         // section name
        LPSTR lpReturnedString,   // return buffer
        DWORD nSize,              // size of return buffer
        LPCSTR lpFileName         // initialization file name
        )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionA");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionA)(lpAppName, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionW

--*/

DWORD APIHOOK(GetPrivateProfileSectionW)(
        LPCWSTR lpAppName,         // section name
        LPWSTR lpReturnedString,   // return buffer
        DWORD nSize,              // size of return buffer
        LPCWSTR lpFileName         // initialization file name
        )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionW");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionW)(lpAppName, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}


/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesA

--*/

DWORD APIHOOK(GetPrivateProfileSectionNamesA)(
        LPSTR lpszReturnBuffer,  // return buffer
        DWORD nSize,              // size of return buffer
        LPCSTR lpFileName        // initialization file name
        )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionNamesA");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesA)(lpszReturnBuffer, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesW

--*/

DWORD APIHOOK(GetPrivateProfileSectionNamesW)(
        LPWSTR lpszReturnBuffer,  // return buffer
        DWORD nSize,              // size of return buffer
        LPCWSTR lpFileName        // initialization file name
        )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileSectionNamesW");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesW)(lpszReturnBuffer, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesA

--*/

DWORD APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,        // section name
    LPCSTR lpKeyName,        // key name
    LPCSTR lpDefault,        // default string
    LPSTR lpReturnedString,  // destination buffer
    DWORD nSize,              // size of destination buffer
    LPCSTR lpFileName        // initialization file name
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStringA");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileSectionNamesA

--*/

DWORD APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,        // section name
    LPCWSTR lpKeyName,        // key name
    LPCWSTR lpDefault,        // default string
    LPWSTR lpReturnedString,  // destination buffer
    DWORD nSize,              // size of destination buffer
    LPCWSTR lpFileName        // initialization file name
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStringW");

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringW)(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}
/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileStructA

--*/

BOOL APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,   // section name
    LPCSTR lpszKey,       // key name
    LPVOID lpStruct,      // return buffer
    UINT uSizeStruct,     // size of return buffer
    LPCSTR lpFileName     // initialization file name
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStructA");

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructA)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileStructW

--*/

BOOL APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,   // section name
    LPCWSTR lpszKey,       // key name
    LPVOID lpStruct,      // return buffer
    UINT uSizeStruct,     // size of return buffer
    LPCWSTR lpFileName     // initialization file name
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "GetPrivateProfileStructW");

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructW)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for GetPrivateProfileStructA

--*/

BOOL APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,  // section name
    LPCSTR lpString,   // data
    LPCSTR lpFileName  // file name
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileSectionA");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionA)(lpAppName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileSectionW

--*/

BOOL APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,  // section name
    LPCWSTR lpString,   // data
    LPCWSTR lpFileName  // file name
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileSectionW");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionW)(lpAppName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStringA

--*/

BOOL APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,  // section name
    LPCSTR lpKeyName,  // key name
    LPCSTR lpString,   // string to add
    LPCSTR lpFileName  // initialization file
    )
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStringA");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringA)(lpAppName, lpKeyName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStringW

--*/

BOOL APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,  // section name
    LPCWSTR lpKeyName,  // key name
    LPCWSTR lpString,   // string to add
    LPCWSTR lpFileName  // initialization file
    )
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStringW");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringW)(lpAppName, lpKeyName, lpString, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStructA

--*/
BOOL APIHOOK(WritePrivateProfileStructA)(
  LPCSTR lpszSection,  // section name
  LPCSTR lpszKey,      // key name
  LPVOID lpStruct,      // data buffer
  UINT uSizeStruct,     // size of data buffer
  LPCSTR lpFileName        // initialization file
)
{
    char * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStructA");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructA)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for WritePrivateProfileStructW

--*/
BOOL APIHOOK(WritePrivateProfileStructW)(
  LPCWSTR lpszSection,  // section name
  LPCWSTR lpszKey,      // key name
  LPVOID lpStruct,      // data buffer
  UINT uSizeStruct,     // size of data buffer
  LPCWSTR lpFileName        // initialization file
)
{
    WCHAR * strCorrect = ProfileCorrectPath(lpFileName, "WritePrivateProfileStructW");

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructW)(lpszSection, lpszKey, lpStruct, uSizeStruct, strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}
/*++

    Convert Win9x paths to WinNT paths for IShellLinkA::SetArguments

--*/
HRESULT COMHOOK(IShellLinkA, SetArguments)( PVOID pThis, LPCSTR pszArgs )
{
    HRESULT hrReturn = E_FAIL;

    char * strCorrect = CorrectPath(pszArgs, "IShellLinkA::SetArguments", FALSE);

    _pfn_IShellLinkA_SetArguments pfnOld = ORIGINAL_COM(IShellLinkA, SetArguments, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    CorrectFree(strCorrect, pszArgs);
    
    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetArguments

--*/
HRESULT COMHOOK(IShellLinkW, SetArguments)( PVOID pThis, LPCWSTR pszArgs )
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszArgs, "IShellLinkA::SetArguments", FALSE);

    _pfn_IShellLinkW_SetArguments pfnOld = ORIGINAL_COM(IShellLinkW, SetArguments, pThis);
    if(pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    CorrectFree(strCorrect, pszArgs);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkA::SetIconLocation

--*/
HRESULT COMHOOK(IShellLinkA, SetIconLocation)(PVOID pThis, LPCSTR pszIconLocation, int nIcon )
{
    HRESULT hrReturn = E_FAIL;

    char * strCorrect = CorrectPath(pszIconLocation, "IShellLinkA::SetIconLocation");

    _pfn_IShellLinkA_SetIconLocation pfnOld = ORIGINAL_COM(IShellLinkA, SetIconLocation, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect, nIcon );

    CorrectFree(strCorrect, pszIconLocation);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetIconLocation

--*/
HRESULT COMHOOK(IShellLinkW, SetIconLocation)(PVOID pThis, LPCWSTR pszIconLocation, int nIcon )
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszIconLocation, "IShellLinkW::SetIconLocation");

    _pfn_IShellLinkW_SetIconLocation pfnOld = ORIGINAL_COM(IShellLinkW, SetIconLocation, pThis);
    if(pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect, nIcon );

    CorrectFree(strCorrect, pszIconLocation);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkA::SetPath

--*/
HRESULT COMHOOK(IShellLinkA, SetPath)(PVOID pThis,
                                   LPCSTR pszFile )
{
    HRESULT hrReturn = E_FAIL;

    char * strCorrect = CorrectPath(pszFile, "IShellLinkA::SetPath");

    _pfn_IShellLinkA_SetPath pfnOld = ORIGINAL_COM(IShellLinkA, SetPath, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    CorrectFree(strCorrect, pszFile);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetPath

--*/
HRESULT COMHOOK(IShellLinkW, SetPath)(PVOID pThis,
                                   LPCWSTR pszFile )
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszFile, "IShellLinkW::SetPath");

    _pfn_IShellLinkW_SetPath pfnOld = ORIGINAL_COM(IShellLinkW, SetPath, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect );

    CorrectFree(strCorrect, pszFile);

    return hrReturn;
}

/*++

    Convert Win9x paths to WinNT paths for IPersistFile::Save

--*/
HRESULT COMHOOK(IPersistFile, Save)(PVOID pThis,
                                  LPCOLESTR pszFileName,
                                  BOOL fRemember)
{
    HRESULT hrReturn = E_FAIL;

    WCHAR * strCorrect = CorrectPath(pszFileName, "IPersistFile_Save");

    _pfn_IPersistFile_Save pfnOld = ORIGINAL_COM(IPersistFile, Save, pThis);
    if (pfnOld)
        hrReturn = (*pfnOld)( pThis, strCorrect, fRemember );

    CorrectFree(strCorrect, pszFileName);

    return hrReturn;
}


BOOL APIHOOK(CopyFileA)(
             LPCSTR lpExistingFileName, // name of an existing file
             LPCSTR lpNewFileName,      // name of new file
             BOOL bFailIfExists          // operation if file exists
)
{
    char * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileA");
    char * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileA");

    BOOL returnValue = ORIGINAL_API(CopyFileA)(strExistingCorrect, strNewCorrect, bFailIfExists);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(CopyFileW)(
             LPCWSTR lpExistingFileName, // name of an existing file
             LPCWSTR lpNewFileName,      // name of new file
             BOOL bFailIfExists          // operation if file exists
)
{
    WCHAR * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileW");
    WCHAR * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileW");

    BOOL returnValue = ORIGINAL_API(CopyFileW)(strExistingCorrect, strNewCorrect, bFailIfExists);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}


BOOL APIHOOK(CopyFileExA)(
  LPCSTR lpExistingFileName,           // name of existing file
  LPCSTR lpNewFileName,                // name of new file
  LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
  LPVOID lpData,                        // callback parameter
  LPBOOL pbCancel,                      // cancel status
  DWORD dwCopyFlags                     // copy options
)
{
    char * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileExA");
    char * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileExA");

    BOOL returnValue = ORIGINAL_API(CopyFileExA)(strExistingCorrect, strNewCorrect, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(CopyFileExW)(
  LPCWSTR lpExistingFileName,           // name of existing file
  LPCWSTR lpNewFileName,                // name of new file
  LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
  LPVOID lpData,                        // callback parameter
  LPBOOL pbCancel,                      // cancel status
  DWORD dwCopyFlags                     // copy options
)
{
    WCHAR * strExistingCorrect = CorrectPath(lpExistingFileName, "CopyFileExW");
    WCHAR * strNewCorrect      = CorrectPath(lpNewFileName,      "CopyFileExW");

    BOOL returnValue = ORIGINAL_API(CopyFileExW)(strExistingCorrect, strNewCorrect, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);

    CorrectFree(strExistingCorrect, lpExistingFileName);
    CorrectFree(strNewCorrect, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryA)(
  LPCSTR lpPathName,                         // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
)
{
    char * strCorrect = CorrectPath(lpPathName, "CreateDirectoryA");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryA)(strCorrect, lpSecurityAttributes);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryW)(
  LPCWSTR lpPathName,                         // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
)
{
    WCHAR * strCorrect = CorrectPath(lpPathName, "CreateDirectoryW");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryW)(strCorrect, lpSecurityAttributes);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryExA)(
  LPCSTR lpTemplateDirectory,               // template directory
  LPCSTR lpNewDirectory,                    // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes // SD
)
{
    char * strTemplateCorrect = CorrectPath(lpTemplateDirectory, "CreateDirectoryExA");
    char * strNewCorrect      = CorrectPath(lpNewDirectory,      "CreateDirectoryExA");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryExA)(strTemplateCorrect, strNewCorrect, lpSecurityAttributes);

    CorrectFree(strTemplateCorrect, lpTemplateDirectory);
    CorrectFree(strNewCorrect, lpNewDirectory);

    return returnValue;
}

BOOL APIHOOK(CreateDirectoryExW)(
  LPCWSTR lpTemplateDirectory,               // template directory
  LPCWSTR lpNewDirectory,                    // directory name
  LPSECURITY_ATTRIBUTES lpSecurityAttributes // SD
)
{
    WCHAR * strTemplateCorrect = CorrectPath(lpTemplateDirectory, "CreateDirectoryExW");
    WCHAR * strNewCorrect      = CorrectPath(lpNewDirectory,      "CreateDirectoryExW");

    BOOL returnValue = ORIGINAL_API(CreateDirectoryExW)(strTemplateCorrect, strNewCorrect, lpSecurityAttributes);

    CorrectFree(strTemplateCorrect, lpTemplateDirectory);
    CorrectFree(strNewCorrect, lpNewDirectory);

    return returnValue;
}

HANDLE APIHOOK(CreateFileA)(
  LPCSTR lpFileName,                         // file name
  DWORD dwDesiredAccess,                      // access mode
  DWORD dwShareMode,                          // share mode
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition,                // how to create
  DWORD dwFlagsAndAttributes,                 // file attributes
  HANDLE hTemplateFile                        // handle to template file
)
{
    char * strCorrect = CorrectPath(lpFileName, "CreateFileA");

    HANDLE returnValue = ORIGINAL_API(CreateFileA)(strCorrect,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(CreateFileW)(
  LPCWSTR lpFileName,                         // file name
  DWORD dwDesiredAccess,                      // access mode
  DWORD dwShareMode,                          // share mode
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition,                // how to create
  DWORD dwFlagsAndAttributes,                 // file attributes
  HANDLE hTemplateFile                        // handle to template file
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "CreateFileW");

    HANDLE returnValue = ORIGINAL_API(CreateFileW)(
                strCorrect,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(DeleteFileA)(
  LPCSTR lpFileName   // file name
)
{
    char * strCorrect = CorrectPath(lpFileName, "DeleteFileA");

    BOOL returnValue = ORIGINAL_API(DeleteFileA)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(DeleteFileW)(

  LPCWSTR lpFileName   // file name
)
{
    WCHAR * strCorrect = CorrectPath(lpFileName, "DeleteFileW");

    BOOL returnValue = ORIGINAL_API(DeleteFileW)(strCorrect);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}


/*++

    Win9xPath corrections will strip a trailing . from the end of a search string.
    As a path, the . is not significant, but as a wildcard it is important--the
    difference between finding files without an extension and finding all files
    in the directory.

--*/

char * FindFirstFileCorrectPath(const char * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    char * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        char * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            CString csCorrect(strCorrect);

            CString csUncorrectLast;
            CString csCorrectLast;

            csUncorrect.GetLastPathComponent(csUncorrectLast);
            csCorrect.GetLastPathComponent(csCorrectLast);

            if (csUncorrectLast.Compare(L"*.") == 0 && csCorrectLast.Compare(L"*") == 0)
            {
                csCorrectLast += L".";
                returnString = csCorrectLast.ReleaseAnsi();
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}

/*++

    Win9xPath corrections will strip a trailing . from the end of a search string.
    As a path, the . is not significant, but as a wildcard it is important--the
    difference between finding files without an extension and finding all files
    in the directory.

--*/

WCHAR * FindFirstFileCorrectPath(const WCHAR * uncorrect, const char * debugMsg, BOOL bMassagePath = g_bW9xPath)
{
    WCHAR * strCorrect = CorrectPath(uncorrect, NULL, bMassagePath);

    if (bMassagePath && uncorrect != strCorrect)
    {
        WCHAR * returnString = NULL;

        CSTRING_TRY
        {
            CString csUncorrect(uncorrect);
            CString csCorrect(strCorrect);

            CString csUncorrectLast;
            CString csCorrectLast;

            csUncorrect.GetLastPathComponent(csUncorrectLast);
            csCorrect.GetLastPathComponent(csCorrectLast);

            if (csUncorrectLast.Compare(L"*.") == 0 && csCorrectLast.Compare(L"*") == 0)
            {
                csCorrectLast += L".";

                // Manually copy the buffer
                size_t nBytes = (csCorrectLast.GetLength() + 1) * sizeof(WCHAR);
                returnString = (WCHAR*) malloc(nBytes);
                if (returnString)
                {
                    memcpy(returnString, csCorrectLast.Get(), nBytes);
                }
            }
        }
        CSTRING_CATCH
        {
            // Some CString error occured, make sure returnString is NULL
            if (returnString != NULL)
            {
                free(returnString);
            }                      
            returnString = NULL;
        }

        if (returnString)
        {
            CorrectFree(strCorrect, uncorrect);
            strCorrect = returnString;
        }
    }

    if (debugMsg)
    {
        DebugSpew(uncorrect, strCorrect, debugMsg);
    }

    return strCorrect;
}

HANDLE APIHOOK(FindFirstFileA)(
  LPCSTR lpFileName,               // file name
  LPWIN32_FIND_DATAA lpFindFileData  // data buffer
)
{
    char * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileA");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileA)(strCorrect, lpFindFileData);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(FindFirstFileW)(
  LPCWSTR lpFileName,               // file name
  LPWIN32_FIND_DATAW lpFindFileData  // data buffer
)
{
    WCHAR * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileW");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileW)(strCorrect, lpFindFileData);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(FindFirstFileExA)(
  LPCSTR lpFileName,              // file name
  FINDEX_INFO_LEVELS fInfoLevelId, // information level
  LPVOID lpFindFileData,           // information buffer
  FINDEX_SEARCH_OPS fSearchOp,     // filtering type
  LPVOID lpSearchFilter,           // search criteria
  DWORD dwAdditionalFlags          // additional search control
)
{
    char * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileExA");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExA)(
                        strCorrect,
                        fInfoLevelId,
                        lpFindFileData,
                        fSearchOp,
                        lpSearchFilter,
                        dwAdditionalFlags);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

HANDLE APIHOOK(FindFirstFileExW)(
  LPCWSTR lpFileName,              // file name
  FINDEX_INFO_LEVELS fInfoLevelId, // information level
  LPVOID lpFindFileData,           // information buffer
  FINDEX_SEARCH_OPS fSearchOp,     // filtering type
  LPVOID lpSearchFilter,           // search criteria
  DWORD dwAdditionalFlags          // additional search control
)
{
    WCHAR * strCorrect = FindFirstFileCorrectPath(lpFileName, "FindFirstFileExW");

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExW)(
                        strCorrect,
                        fInfoLevelId,
                        lpFindFileData,
                        fSearchOp,
                        lpSearchFilter,
                        dwAdditionalFlags);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

BOOL APIHOOK(GetBinaryTypeA)(
  LPCSTR lpApplicationName,  // full file path
  LPDWORD lpBinaryType        // binary type information
)
{
    char * strCorrect = CorrectPath(lpApplicationName, "GetBinaryTypeA");

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeA)(strCorrect, lpBinaryType);

    CorrectFree(strCorrect, lpApplicationName);

    return returnValue;
}

BOOL APIHOOK(GetBinaryTypeW)(
  LPCWSTR lpApplicationName,  // full file path
  LPDWORD lpBinaryType        // binary type information
)
{
    WCHAR * strCorrect = CorrectPath(lpApplicationName, "GetBinaryTypeW");

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeW)(strCorrect, lpBinaryType);

    CorrectFree(strCorrect, lpApplicationName);

    return returnValue;
}

BOOL APIHOOK(MoveFileA)(
  LPCSTR lpExistingFileName, // file name
  LPCSTR lpNewFileName       // new file name
)
{
    char * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileA");
    char * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileA");

    BOOL returnValue = ORIGINAL_API(MoveFileA)(strCorrectExisting, strCorrectNew);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileW)(
  LPCWSTR lpExistingFileName, // file name
  LPCWSTR lpNewFileName       // new file name
)
{
    WCHAR * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileW");
    WCHAR * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileW");

    BOOL returnValue = ORIGINAL_API(MoveFileW)(strCorrectExisting, strCorrectNew);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileExA)(
  LPCSTR lpExistingFileName,  // file name
  LPCSTR lpNewFileName,       // new file name
  DWORD dwFlags                // move options
)
{
    char * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileExA");
    char * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileExA");

    BOOL returnValue = ORIGINAL_API(MoveFileExA)(strCorrectExisting, strCorrectNew, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileExW)(
  LPCWSTR lpExistingFileName,  // file name
  LPCWSTR lpNewFileName,       // new file name
  DWORD dwFlags                // move options
)
{
    WCHAR * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileExW");
    WCHAR * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileExW");

    BOOL returnValue = ORIGINAL_API(MoveFileExW)(strCorrectExisting, strCorrectNew, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileWithProgressA)(
  LPCSTR lpExistingFileName,            // file name
  LPCSTR lpNewFileName,                 // new file name
  LPPROGRESS_ROUTINE lpProgressRoutine,  // callback function
  LPVOID lpData,                         // parameter for callback
  DWORD dwFlags                          // move options
)
{
    char * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileWithProgressA");
    char * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileWithProgressA");

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressA)(strCorrectExisting, strCorrectNew, lpProgressRoutine, lpData, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(MoveFileWithProgressW)(
  LPCWSTR lpExistingFileName,            // file name
  LPCWSTR lpNewFileName,                 // new file name
  LPPROGRESS_ROUTINE lpProgressRoutine,  // callback function
  LPVOID lpData,                         // parameter for callback
  DWORD dwFlags                          // move options
)
{
    WCHAR * strCorrectExisting = CorrectPath(lpExistingFileName, "MoveFileW");
    WCHAR * strCorrectNew      = CorrectPath(lpNewFileName, "MoveFileW");

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressW)(strCorrectExisting, strCorrectNew, lpProgressRoutine, lpData, dwFlags);

    CorrectFree(strCorrectExisting, lpExistingFileName);
    CorrectFree(strCorrectNew, lpNewFileName);

    return returnValue;
}

BOOL APIHOOK(RemoveDirectoryA)(
  LPCSTR lpPathName   // directory name
)
{
    char * strCorrect = CorrectPath(lpPathName, "RemoveDirectoryA");

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryA)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(RemoveDirectoryW)(
  LPCWSTR lpPathName   // directory name
)
{
    WCHAR * strCorrect = CorrectPath(lpPathName, "RemoveDirectoryW");

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryW)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(SetCurrentDirectoryA)(
  LPCSTR lpPathName   // new directory name
)
{
    char * strCorrect = CorrectPath(lpPathName, "SetCurrentDirectoryA");

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryA)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

BOOL APIHOOK(SetCurrentDirectoryW)(
  LPCWSTR lpPathName   // new directory name
)
{
    WCHAR * strCorrect = CorrectPath(lpPathName, "SetCurrentDirectoryW");

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryW)(strCorrect);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;
}

HFILE APIHOOK(OpenFile)(
  LPCSTR lpFileName,        // file name
  LPOFSTRUCT lpReOpenBuff,  // file information
  UINT uStyle               // action and attributes
)
{
    char * strCorrect = CorrectPath(lpFileName, "OpenFile");

    HFILE returnValue = ORIGINAL_API(OpenFile)(strCorrect, lpReOpenBuff, uStyle);

    CorrectFree(strCorrect, lpFileName);

    return returnValue;
}

LONG APIHOOK(RegSetValueA)(
  HKEY hKey,         // handle to key
  LPCSTR lpSubKey,  // subkey name
  DWORD dwType,      // information type
  LPCSTR lpData,    // value data
  DWORD cbData       // size of value data
)
{
    char * strCorrect = CorrectPath(lpData, "RegSetValueA", FALSE);

    // Data key is length of string *not* including null byte.
    if (strCorrect)
    {
        cbData = strlen(strCorrect);
    }

    LONG returnValue = ORIGINAL_API(RegSetValueA)(hKey, lpSubKey, dwType, strCorrect, cbData);

    CorrectFree(strCorrect, lpData);

    return returnValue;
}

LONG APIHOOK(RegSetValueW)(
  HKEY hKey,         // handle to key
  LPCWSTR lpSubKey,  // subkey name
  DWORD dwType,      // information type
  LPCWSTR lpData,    // value data
  DWORD cbData       // size of value data
)
{
    WCHAR * strCorrect = CorrectPath(lpData, "RegSetValueW", FALSE);

    // Data key is length of string *not* including null byte.
    if (strCorrect)
        cbData = wcslen(strCorrect);

    LONG returnValue = ORIGINAL_API(RegSetValueW)(hKey, lpSubKey, dwType, strCorrect, cbData);

    CorrectFree(strCorrect, lpData);

    return returnValue;
}

LONG APIHOOK(RegSetValueExA)(
  HKEY hKey,           // handle to key
  LPCSTR lpValueName, // value name
  DWORD Reserved,      // reserved
  DWORD dwType,        // value type
  CONST BYTE *lpData,  // value data
  DWORD cbData         // size of value data
)
{
    if (dwType == REG_SZ)
    {
        char * strCorrect = CorrectPath((const char *)lpData, "RegSetValueExA", FALSE);

        // Data key is length of string *including* null byte.
        if (strCorrect)
        {
            cbData = strlen(strCorrect) + 1;
        }

        LONG returnValue = ORIGINAL_API(RegSetValueExA)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                (CONST BYTE *)strCorrect,  // value data
                cbData);
        CorrectFree(strCorrect, (const char *)lpData);

        return returnValue;
    }
    else
    {
        // Pass data on through
        LONG returnValue = ORIGINAL_API(RegSetValueExA)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                lpData,  // value data
                cbData);
        return returnValue;
    }
}

LONG APIHOOK(RegSetValueExW)(
  HKEY hKey,           // handle to key
  LPCWSTR lpValueName, // value name
  DWORD Reserved,      // reserved
  DWORD dwType,        // value type
  CONST BYTE *lpData,  // value data
  DWORD cbData         // size of value data
)
{
    if (dwType == REG_SZ)
    {
        WCHAR * strCorrect = CorrectPath((const WCHAR*)lpData, "RegSetValueExW", FALSE);

        // Data key is length of string *including* null byte.
        if (strCorrect)
        {
            cbData = wcslen(strCorrect) + 1;
        }

        LONG returnValue = ORIGINAL_API(RegSetValueExW)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                (CONST BYTE *)strCorrect,  // value data
                cbData);
        CorrectFree(strCorrect, (const WCHAR *)lpData);

        return returnValue;
    }
    else
    {
        // Pass data on through
        LONG returnValue = ORIGINAL_API(RegSetValueExW)(
                hKey,           // handle to key
                lpValueName, // value name
                Reserved,      // reserved
                dwType,        // value type
                lpData,  // value data
                cbData);
        return returnValue;
    }
}

HFILE APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    char * strCorrect = CorrectPath(lpPathName, "lopen");

    HFILE returnValue = ORIGINAL_API(_lopen)(strCorrect, iReadWrite);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;    
}

HFILE APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    char * strCorrect = CorrectPath(lpPathName, "lcreat");

    HFILE returnValue = ORIGINAL_API(_lcreat)(strCorrect, iAttribute);

    CorrectFree(strCorrect, lpPathName);

    return returnValue;    
}

HANDLE 
APIHOOK(LoadImageA)(
    HINSTANCE hinst,   // handle to instance
    LPCSTR lpszName,   // name or identifier of the image
    UINT uType,        // image type
    int cxDesired,     // desired width
    int cyDesired,     // desired height
    UINT fuLoad        // load options
    )
{
    HANDLE returnValue = NULL;

    // Another one of those incredibly overloaded API's:
    // lpszName is not always a path
    if ((uType == IMAGE_BITMAP)    &&
        (fuLoad & LR_LOADFROMFILE) &&
        !IsBadStringPtrA(lpszName, 1))
    {
        char * strCorrect = CorrectPath(lpszName, "LoadImageA");

        returnValue = ORIGINAL_API(LoadImageA)(hinst, strCorrect, uType, cxDesired, cyDesired, fuLoad);

        CorrectFree(strCorrect, lpszName);
    }
    else
    {
        returnValue = ORIGINAL_API(LoadImageA)(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
    }

    return returnValue;    
}



IMPLEMENT_COMSERVER_HOOK(SHELL32)

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    BOOL bSuccess = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        bSuccess = ParseCommandLine(COMMAND_LINE);
        if (bSuccess)
        {
            // Create g_AllocatedPathCorrector
            return InitPathcorrectorClass();
        }
    }
    else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        // It is now safe for us to do our work
        g_PathCorrector = g_AllocatedPathCorrector;
        InitializePathCorrections();
    }
    return bSuccess;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    if (g_bCreateProcessRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessA)
        APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessW)
        APIHOOK_ENTRY(KERNEL32.DLL,                          WinExec)

        APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteA)
        APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteW)
        APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExA)
        APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExW)
    }

    if (g_bGetCommandLineRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineA)
        APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineW)
    }

    if (g_bProfileRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntA)
        APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntW)
        APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesA)
        APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesW)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructW)
        APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructW)
    }

    if (g_bFileRoutines)
    {
        APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExW)
        APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExA)
        APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExW)

        APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileW)

        APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExA)
        APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExW)

        APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeA)
        APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeW)
        APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesW)
        APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExA)
        APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExW)
        APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesW)

        APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileA)
        APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileW)
        APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExA)
        APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExW)
        APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressA)
        APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressW)

        APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryW)

        APIHOOK_ENTRY(KERNEL32.DLL,                         OpenFile)
    
        // 16 bit compatibility file routines
        APIHOOK_ENTRY(KERNEL32.DLL,                         _lopen)
        APIHOOK_ENTRY(KERNEL32.DLL,                         _lcreat)
    }

    if (g_bRegSetValueRoutines)
    {
        APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExA)
        APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExW)
    }

    if (g_bShellLinkRoutines)
    {
        APIHOOK_ENTRY_COMSERVER(SHELL32)

        COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
        COMHOOK_ENTRY(ShellLink, IShellLinkW, SetPath, 20)
        COMHOOK_ENTRY(ShellLink, IShellLinkA, SetArguments, 11)
        COMHOOK_ENTRY(ShellLink, IShellLinkW, SetArguments, 11)
        COMHOOK_ENTRY(ShellLink, IShellLinkA, SetIconLocation, 17)
        COMHOOK_ENTRY(ShellLink, IShellLinkW, SetIconLocation, 17)

        COMHOOK_ENTRY(ShellLink, IPersistFile, Save, 6)
    }

    if (g_bLoadImage)
    {
        APIHOOK_ENTRY(USER32.DLL, LoadImageA)
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\correctsounddeviceid.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CorrectSoundDeviceId.cpp

 Abstract:

    This shim fixes calls to waveOutOpen, waveOutGetDevCaps, midiOutOpen and
    midiOutGetDevCaps with the uDeviceID equal to 0xFFFF, which was the constant 
    for Wave/MIDI Mapper under 16-bit windows. Under 32-bit the new constant is 
    0xFFFFFFFF. This is going to be fixed in winmm code for Whistler but we still 
    keep this shim to fix apps on w2k.

 Notes:

   This is a general purpose shim.

 History:

   01/26/2000 dmunsil Created
   10/09/2000 maonis  Added hooks for midiOutGetDevCaps and midiOutOpen.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorrectSoundDeviceId)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(waveOutOpen)
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsA)
    APIHOOK_ENUM_ENTRY(waveOutGetDevCapsW)
    APIHOOK_ENUM_ENTRY(midiOutOpen)
    APIHOOK_ENUM_ENTRY(midiOutGetDevCapsA)
APIHOOK_ENUM_END


/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for Wave Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(waveOutOpen)(
    LPHWAVEOUT      phwo,                 // return buffer         
    UINT            uDeviceID,            // id of the device to use
    LPWAVEFORMATEX  pwfx,                 // what format you need (i.e. 11K, 16bit, stereo)
    DWORD           dwCallback,           // callback for notification on buffer completion
    DWORD           dwCallbackInstance,   // instance handle for callback
    DWORD           fdwOpen               // flags
    )              
{
    if (uDeviceID == 0xFFFF) {
        LOGN(
            eDbgLevelError,
            "[waveOutOpen] Fixed invalid Wave Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(waveOutOpen)(
                            phwo,
                            uDeviceID,
                            pwfx,
                            dwCallback,
                            dwCallbackInstance,
                            fdwOpen);
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for Wave Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(waveOutGetDevCapsA)(
    UINT           uDeviceID,   // id of the device to use
    LPWAVEOUTCAPSA pwoc,        // returned caps structure
    UINT           cbwoc        // size in bytes of the WAVEOUTCAPS struct
    )                   
{
    if (uDeviceID == 0xFFFF) {
        LOGN(
            eDbgLevelError,
            "[waveOutGetDevCapsA] Fixed invalid Wave Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(waveOutGetDevCapsA)(
                            uDeviceID,
                            pwoc,
                            cbwoc);    
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for Wave Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(waveOutGetDevCapsW)(
    UINT           uDeviceID,   // id of the device to use
    LPWAVEOUTCAPSW pwoc,        // returned caps structure
    UINT           cbwoc        // size in bytes of the WAVEOUTCAPS struct
    )                   
{
    if (uDeviceID == 0xFFFF) {
        LOGN(
            eDbgLevelError,
            "[waveOutGetDevCapsW] Fixed invalid Wave Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(waveOutGetDevCapsW)(
                            uDeviceID,
                            pwoc,
                            cbwoc);    
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for MIDI Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(midiOutOpen)(
    LPHMIDIOUT phmo, 
    UINT       uDeviceID, 
    DWORD_PTR  dwCallback, 
    DWORD_PTR  dwInstance, 
    DWORD      fdwOpen
    )
{
    if (uDeviceID == 0xffff) {
        LOGN(
            eDbgLevelError,
            "[midiOutOpen] Fixed invalid MIDI Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(midiOutOpen)(
                            phmo, 
                            uDeviceID, 
                            dwCallback, 
                            dwInstance, 
                            fdwOpen);
}

/*++

 This stub function fixes calls with the uDeviceID equal to 0xFFFF, which was 
 the constant for MIDI Mapper under 16-bit windows. 

--*/

MMRESULT 
APIHOOK(midiOutGetDevCapsA)(
    UINT_PTR       uDeviceID,
    LPMIDIOUTCAPSA pmoc,
    UINT           cbmoc
    )
{
    if (uDeviceID == 0xffff) {
        LOGN(
            eDbgLevelError,
            "[midiOutGetDevCapsA] Fixed invalid MIDI Mapper device ID.");
        
        uDeviceID = (UINT)-1;
    }
    
    return ORIGINAL_API(midiOutGetDevCapsA)(
                            uDeviceID, 
                            pmoc, 
                            cbmoc);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, waveOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsA)
    APIHOOK_ENTRY(WINMM.DLL, waveOutGetDevCapsW)
    APIHOOK_ENTRY(WINMM.DLL, midiOutOpen)
    APIHOOK_ENTRY(WINMM.DLL, midiOutGetDevCapsA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\directplayenumorder.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   DirectPlayEnumOrder.cpp

 Abstract:

   Certain applications (Midtown Madness) expects the DPLAY providers to enumerate in a specific order.

 History:

   04/25/2000 robkenny

--*/


#include "precomp.h"
#include "CharVector.h"

#include <Dplay.h>

IMPLEMENT_SHIM_BEGIN(DirectPlayEnumOrder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

// A class that makes it easy to store DPlay::EnumConnections information.
class DPlayConnectionsInfo
{
public:
    BOOL            m_beenUsed;
    GUID            m_lpguidSP;
    LPVOID          m_lpConnection;
    DWORD           m_dwConnectionSize;
    DPNAME          m_lpName;
    DWORD           m_dwFlags;
    LPVOID          m_lpContext;

    // Construct our object, saveing all these values.
    DPlayConnectionsInfo(
            LPCGUID lpguidSP,
            LPVOID lpConnection,
            DWORD dwConnectionSize,
            LPCDPNAME lpName,
            DWORD dwFlags,
            LPVOID lpContext
        )
    {
        m_beenUsed              = FALSE;
        m_lpguidSP              = *lpguidSP;
        m_lpConnection          = malloc(dwConnectionSize);
        if (m_lpConnection)
        {
            memcpy(m_lpConnection, lpConnection, dwConnectionSize);
        }
        m_dwConnectionSize      = dwConnectionSize;
        m_lpName                = *lpName;
        m_lpName.lpszShortNameA = StringDuplicateA(lpName->lpszShortNameA);
        m_dwFlags               = dwFlags;
        m_lpContext             = lpContext;
    }

    // Free our allocated space, and erase values.
    void Erase()
    {
        free(m_lpConnection);
        free(m_lpName.lpszShortNameA);
        m_lpConnection          = NULL;
        m_dwConnectionSize      = 0;
        m_lpName.lpszShortNameA = NULL;
        m_dwFlags               = 0;
        m_lpContext             = 0;
    }

    // Do we match this GUID?
    BOOL operator == (const GUID & guidSP)
    {
        return IsEqualGUID(guidSP, m_lpguidSP);
    }

    // Call the callback routine with this saved information
    void CallEnumRoutine(LPDPENUMCONNECTIONSCALLBACK lpEnumCallback)
    {
        lpEnumCallback(
            &m_lpguidSP,
            m_lpConnection,
            m_dwConnectionSize,
            &m_lpName,
            m_dwFlags,
            m_lpContext
            );

        m_beenUsed = TRUE;
    }

};

// A list of DPlay connections
class DPlayConnectionsInfoVector : public VectorT<DPlayConnectionsInfo>
{
public:

    // Deconstruct the elements
    ~DPlayConnectionsInfoVector()
    {
        for (int i = 0; i < Size(); ++i)
        {
            DPlayConnectionsInfo & deleteMe = Get(i);
            deleteMe.Erase();
        }
    }

    // Find an entry that matches this GUID
    DPlayConnectionsInfo * Find(const GUID & guidSP)
    {
        const int size = Size();
        DPFN( 
            eDbgLevelSpew, 
            "Find             GUID(%08x-%08x-%08x-%08x) Size(%d).", 
            guidSP.Data1, 
            guidSP.Data2, 
            guidSP.Data3, 
            guidSP.Data4, 
            size);

        for (int i = 0; i < size; ++i)
        {
            DPlayConnectionsInfo & dpci = Get(i);
            DPFN( 
                eDbgLevelSpew, 
                "   Compare[%02d] = GUID(%08x-%08x-%08x-%08x) (%s).", 
                i,
                dpci.m_lpguidSP.Data1, 
                dpci.m_lpguidSP.Data2, 
                dpci.m_lpguidSP.Data3, 
                dpci.m_lpguidSP.Data4, 
                dpci.m_lpName.lpszShortNameA);

            if (dpci == guidSP)
            {
                DPFN( 
                    eDbgLevelSpew, 
                    "FOUND(%s).", 
                    dpci.m_lpName.lpszShortNameA);
                return &dpci;
            }
        }
        DPFN(eDbgLevelSpew, "NOT FOUND.");
        return NULL;
    }

    // Lookup the GUID and if found, call the callback routine.
    void CallEnumRoutine(const GUID & guidSP, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback)
    {
        DPFN( 
            eDbgLevelSpew, 
            "CallEnumRoutine(%08x) Find GUID(%08x-%08x-%08x-%08x).", 
            lpEnumCallback, 
            guidSP.Data1, 
            guidSP.Data2, 
            guidSP.Data3, 
            guidSP.Data4);

        DPlayConnectionsInfo * dpci = Find(guidSP);
        if (dpci)
        {
            dpci->CallEnumRoutine(lpEnumCallback);
        }
    }
};

class DPlayEnumInfo
{
public:
    DPlayEnumInfo(LPVOID context, DPlayConnectionsInfoVector * conn)
    {
        lpContext = context;
        dPlayConnection = conn;
    }

    LPVOID                          lpContext;
    DPlayConnectionsInfoVector *    dPlayConnection;
};
/*++

  Our private callback for IDirectPlay4::EnumConnections.  We simply save all
  the connections in our private list for later use.

--*/

BOOL FAR PASCAL EnumConnectionsCallback(
  LPCGUID lpguidSP,
  LPVOID lpConnection,
  DWORD dwConnectionSize,
  LPCDPNAME lpName,
  DWORD dwFlags,
  LPVOID lpContext
)
{
    DPlayEnumInfo * enumInfo = (DPlayEnumInfo*)lpContext;

    // Only add it to the list if it is not already there
    // App calls EnumConnections from inside Enum callback routine.
    if (!enumInfo->dPlayConnection->Find(*lpguidSP))
    {
        DPFN( 
            eDbgLevelSpew, 
            "EnumConnectionsCallback Add(%d) (%s).",
            enumInfo->dPlayConnection->Size(),
            lpName->lpszShortName );

        // Store the info for later
        DPlayConnectionsInfo dpci(lpguidSP, lpConnection, dwConnectionSize, lpName, dwFlags, enumInfo->lpContext);

        enumInfo->dPlayConnection->Append(dpci);
    }
    else
    {
        DPFN( 
            eDbgLevelSpew, 
            "EnumConnectionsCallback Already in the list(%s).",
            lpName->lpszShortName );
    }

    return TRUE;
}

/*++

  Win9x Direct play enumerates hosts in this order:
    DPSPGUID_IPX,
    DPSPGUID_TCPIP,
    DPSPGUID_MODEM,
    DPSPGUID_SERIAL,

  IXP, TCP, Modem, Serial.  Have EnumConnections call our callback
  routine to gather the host list, sort it, then call the app's callback routine.

--*/

HRESULT 
COMHOOK(IDirectPlay4A, EnumConnections)(
    PVOID pThis,
    LPCGUID lpguidApplication,
    LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,
    LPVOID lpContext,
    DWORD dwFlags
)
{
    DPFN( eDbgLevelSpew, "======================================");
    DPFN( eDbgLevelSpew, "COMHOOK IDirectPlay4A EnumConnections" );

    // Don't let a bad callback routine spoil our day
    if (IsBadCodePtr( (FARPROC) lpEnumCallback))
    {
        return DPERR_INVALIDPARAMS;
    }

    HRESULT hResult = DPERR_CONNECTIONLOST;

    typedef HRESULT   (*_pfn_IDirectPlay4_EnumConnections)( PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);

    _pfn_IDirectPlay4A_EnumConnections EnumConnections = ORIGINAL_COM(
        IDirectPlay4A,
        EnumConnections, 
        pThis);

    if (EnumConnections)
    {
        DPFN( eDbgLevelSpew, "EnumConnections(%08x)\n", EnumConnections );

        DPlayConnectionsInfoVector dPlayConnection;
        DPlayEnumInfo enumInfo(lpContext, &dPlayConnection);

        // Enumerate connections to our own routine.        
        hResult = EnumConnections(pThis, lpguidApplication, EnumConnectionsCallback, (LPVOID)&enumInfo, dwFlags);
        
        LOGN( eDbgLevelError, 
            "EnumConnections calling app with ordered connection list of Size(%d).", 
            dPlayConnection.Size());

        // Call the application's callback routine with the GUID in the order it expects
        if (hResult == DP_OK)
        {
            dPlayConnection.CallEnumRoutine(DPSPGUID_IPX, lpEnumCallback);
            dPlayConnection.CallEnumRoutine(DPSPGUID_TCPIP, lpEnumCallback);
            dPlayConnection.CallEnumRoutine(DPSPGUID_MODEM, lpEnumCallback);
            dPlayConnection.CallEnumRoutine(DPSPGUID_SERIAL, lpEnumCallback);

            // Now loop over the list and enum any remaining providers
            for (int i = 0; i < dPlayConnection.Size(); ++i)
            {
                DPlayConnectionsInfo & dpci = dPlayConnection.Get(i);
                if (!dpci.m_beenUsed)
                {
                    dpci.CallEnumRoutine(lpEnumCallback);
                    dpci.m_beenUsed = TRUE;
                }
            }
        }
    }

    return hResult;
}


/*++

  Do the same thing for DirectPlay3

--*/

HRESULT 
COMHOOK(IDirectPlay3A, EnumConnections)(
    PVOID pThis,
    LPCGUID lpguidApplication,
    LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,
    LPVOID lpContext,
    DWORD dwFlags
)
{
    DPFN( eDbgLevelSpew, "======================================");
    DPFN( eDbgLevelSpew, "COMHOOK IDirectPlay3A EnumConnections" );

    // Don't let a bad callback routine spoil our day
    if (IsBadCodePtr( (FARPROC) lpEnumCallback))
    {
        return DPERR_INVALIDPARAMS;
    }

    HRESULT hResult = DPERR_CONNECTIONLOST;

    typedef HRESULT   (*_pfn_IDirectPlay3A_EnumConnections)( PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);

    _pfn_IDirectPlay3A_EnumConnections EnumConnections = ORIGINAL_COM(
        IDirectPlay3A,
        EnumConnections, 
        pThis);

    if (EnumConnections)
    {
        DPFN( eDbgLevelSpew, "EnumConnections(%08x)\n", EnumConnections );

        DPlayConnectionsInfoVector dPlayConnection;
        DPlayEnumInfo enumInfo(lpContext, &dPlayConnection);

        // Enumerate connections to our own routine.        
        hResult = EnumConnections(pThis, lpguidApplication, EnumConnectionsCallback, (LPVOID)&enumInfo, dwFlags);
        
        LOGN( eDbgLevelError, 
            "EnumConnections calling app with ordered connection list of Size(%d).", 
            dPlayConnection.Size());

        // Call the application's callback routine with the GUID in the order it expects
        if (hResult == DP_OK)
        {
            dPlayConnection.CallEnumRoutine(DPSPGUID_IPX, lpEnumCallback);
            dPlayConnection.CallEnumRoutine(DPSPGUID_TCPIP, lpEnumCallback);
            dPlayConnection.CallEnumRoutine(DPSPGUID_MODEM, lpEnumCallback);
            dPlayConnection.CallEnumRoutine(DPSPGUID_SERIAL, lpEnumCallback);

            // Now loop over the list and enum any remaining providers
            for (int i = 0; i < dPlayConnection.Size(); ++i)
            {
                DPlayConnectionsInfo & dpci = dPlayConnection.Get(i);
                if (!dpci.m_beenUsed)
                {
                    dpci.CallEnumRoutine(lpEnumCallback);
                    dpci.m_beenUsed = TRUE;
                }
            }
        }
    }

    return hResult;
}


/*++

  Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectPlay, IDirectPlay4A, EnumConnections, 35)
    COMHOOK_ENTRY(DirectPlay, IDirectPlay3A, EnumConnections, 35)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatecreatefilemapping.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    EmulateCreateFileMapping.cpp

 Abstract:

    Win9x defaults to SEC_COMMIT when the SEC_NOCACHE flag is set. 
    NT fails the call.

    File mapping names, can't contain backslashes.

 Notes:

    This is a general purpose shim.

 History:
        
    02/17/2000  linstev     Created
    05/26/2001  robkenny    Replace all \ to _ in map names.
    02/28/2002  robkenny    Security review, was clobbering Global\ and Local\ namespaces.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateCreateFileMapping)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileMappingA)
    APIHOOK_ENUM_ENTRY(CreateFileMappingW)
    APIHOOK_ENUM_ENTRY(OpenFileMappingA)
    APIHOOK_ENUM_ENTRY(OpenFileMappingW)
APIHOOK_ENUM_END


/*++

 Correct the flag and name

--*/

HANDLE 
APIHOOK(CreateFileMappingW)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCWSTR lpName             
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileMappingW)(hFile, lpAttributes, 
        flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

    if (!hRet) {
        //
        // The call failed, so try correcting the parameters
        //

        DWORD flNewProtect = flProtect;
        if ((flProtect & SEC_NOCACHE) && 
            (!((flProtect & SEC_COMMIT) || (flProtect & SEC_RESERVE)))) {
            // Add the SEC_COMMIT flag
            flNewProtect |= SEC_COMMIT;
        }

        CSTRING_TRY {

            // Replace backslashes
            CString csName(lpName);
            int nCount = 0;

            if (csName.ComparePart(L"Global\\", 0, 7) == 0)
            {
                // This event exists in the global namespace
                csName.Delete(0, 7);
                nCount = csName.Replace(L'\\', '_');
                csName = L"Global\\" + csName;
            }
            else if (csName.ComparePart(L"Local\\", 0, 6) == 0)
            {
                // This event exists in the Local namespace
                csName.Delete(0, 6);
                nCount = csName.Replace(L'\\', '_');
                csName = L"Local\\" + csName;
            }
            else
            {
                nCount = csName.Replace(L'\\', '_');
            }

            LPCWSTR lpCorrectName = csName;
    
            if (nCount || (flProtect != flNewProtect)) {
                // Something happened, so log it
                if (nCount) {
                    LOGN(eDbgLevelError, 
                        "[CreateFileMapping] Corrected event name from (%S) to (%S)", lpName, lpCorrectName);
                }
                if (flProtect != flNewProtect) {
                    LOGN(eDbgLevelError, "[CreateFileMapping] Adding SEC_COMMIT flag");
                }
        
                // Call again with fixed parameters
                hRet = ORIGINAL_API(CreateFileMappingW)(hFile, lpAttributes, flNewProtect, 
                    dwMaximumSizeHigh, dwMaximumSizeLow, lpCorrectName);
            }
        }
        CSTRING_CATCH {
            // Do nothing
        }
    }

    return hRet;
}

/*++

 Pass through to CreateFileMappingW.

--*/

HANDLE 
APIHOOK(CreateFileMappingA)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCSTR lpName             
    )
{
    HANDLE hRet;

    CSTRING_TRY {
        // Convert to unicode
        CString csName(lpName);
        LPCWSTR lpwName = csName;

        hRet = APIHOOK(CreateFileMappingW)(hFile, lpAttributes, flProtect, 
            dwMaximumSizeHigh, dwMaximumSizeLow, lpwName);
    }
    CSTRING_CATCH {
        // Fall back as gracefully as possible
        hRet = ORIGINAL_API(CreateFileMappingA)(hFile, lpAttributes, flProtect, 
            dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
    }

    return hRet;
}

/*++

 Correct the name

--*/

HANDLE
APIHOOK(OpenFileMappingW)(
    DWORD dwDesiredAccess,  
    BOOL bInheritHandle,    
    LPCWSTR lpName          
    )
{
    HANDLE hRet = ORIGINAL_API(OpenFileMappingW)(dwDesiredAccess, bInheritHandle, 
        lpName);
    
    if (!hRet) {
        //
        // The call failed, so try correcting the parameters
        //

        CSTRING_TRY {

            // Replace backslashes
            CString csName(lpName);
            int nCount = 0;

            if (csName.ComparePart(L"Global\\", 0, 7) == 0)
            {
                // This event exists in the global namespace
                csName.Delete(0, 7);
                nCount = csName.Replace(L'\\', '_');
                csName = L"Global\\" + csName;
            }
            else if (csName.ComparePart(L"Local\\", 0, 6) == 0)
            {
                // This event exists in the Local namespace
                csName.Delete(0, 6);
                nCount = csName.Replace(L'\\', '_');
                csName = L"Local\\" + csName;
            }
            else
            {
                nCount = csName.Replace(L'\\', '_');
            }

            LPCWSTR lpCorrectName = csName;
    
            if (nCount) {
                // Something happened, so log it
                LOGN(eDbgLevelError, 
                    "OpenFileMappingW corrected event name from (%S) to (%S)", lpName, lpCorrectName);

                // Call again with fixed parameters
                hRet = ORIGINAL_API(OpenFileMappingW)(dwDesiredAccess, bInheritHandle, 
                    lpCorrectName);
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return hRet;
}

/*++

 Pass through to OpenFileMappingW.

--*/

HANDLE
APIHOOK(OpenFileMappingA)(
    DWORD dwDesiredAccess,  
    BOOL bInheritHandle,    
    LPCSTR lpName          
    )
{
    HANDLE hRet;

    CSTRING_TRY {
        // Convert to unicode
        CString csName(lpName);
        LPCWSTR lpwName = csName;

        hRet = APIHOOK(OpenFileMappingW)(dwDesiredAccess, bInheritHandle,
            lpwName);
    }
    CSTRING_CATCH {
        // Fall back as gracefully as possible
        hRet = ORIGINAL_API(OpenFileMappingA)(dwDesiredAccess, bInheritHandle, 
            lpName);
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileMappingW)
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFileMappingW)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateclipboarddibformat.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    EmulateClipboardDIBFormat.cpp

 Abstract:

    On Win9x when you copy a high color bitmap onto the clipboard, it always
    gets converted to a 24-bit DIB when you ask the clipboard for CF_DIB 
    format. On NT the conversion doesn't happen. So some apps are only 
    designed to handle 8-bit and 24-bit DIBs (example, Internet Commsuite).
    So we convert the high-color (16-bit and 32-bit) DIBs to 24-bit DIBs
    - we don't need to handle 24-bit ones as they should already be handled
    by the app itself (or it won't work on 9x).

 Notes:

    This is a general purpose shim.

 History:

    01/24/2001 maonis  Created

--*/
#include "precomp.h"
//#include <userenv.h>

IMPLEMENT_SHIM_BEGIN(EmulateClipboardDIBFormat)
#include "ShimHookMacro.h"

typedef HANDLE (*_pfn_GetClipboardData)(UINT);
typedef BOOL (*_pfn_CloseClipboard)(VOID);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetClipboardData)
    APIHOOK_ENUM_ENTRY(CloseClipboard)
APIHOOK_ENUM_END

BITMAPINFOHEADER* g_pv = NULL;

DWORD CalcBitmapSize(BITMAPINFOHEADER* pbih)
{
    return pbih->biWidth * pbih->biHeight * pbih->biBitCount / 8;
}

HANDLE 
APIHOOK(GetClipboardData)(
    UINT uFormat   // clipboard format
    )
{
    if (uFormat == CF_DIB)
    {
        BITMAPINFO* pbmiOriginal = (BITMAPINFO*)ORIGINAL_API(GetClipboardData)(uFormat);

        if ((pbmiOriginal->bmiHeader.biBitCount > 8) && (pbmiOriginal->bmiHeader.biBitCount != 24))
        {
            HDC hdc = CreateCompatibleDC(NULL);

            if (hdc)
            {
                VOID* pvOriginal;

                HBITMAP hbmpOriginal = CreateDIBSection(hdc, pbmiOriginal, DIB_RGB_COLORS, &pvOriginal, NULL, 0);

                if (hbmpOriginal)
                {
                    DWORD* pdwOriginal = (DWORD *)(pbmiOriginal + 1) +
                        ((pbmiOriginal->bmiHeader.biCompression == BI_BITFIELDS) ? 2 : -1);

                    // Fill in the data.
                    memcpy(pvOriginal, pdwOriginal, CalcBitmapSize(&(pbmiOriginal->bmiHeader)));

                    BITMAPINFOHEADER bmi;
                    memcpy(&bmi, pbmiOriginal, sizeof(BITMAPINFOHEADER));
                    bmi.biBitCount = 24;
                    bmi.biSizeImage = 0;
                    bmi.biCompression = BI_RGB;

                    if (GetDIBits(hdc, hbmpOriginal, 0, bmi.biHeight, NULL, (BITMAPINFO*)&bmi, DIB_RGB_COLORS))
                    {
                        // We need to allocate a contiguous block of memory to hold both the 
                        // bitmap header and the data.
                        g_pv = (BITMAPINFOHEADER*) new BYTE [sizeof(BITMAPINFOHEADER) + bmi.biSizeImage];

                        if (g_pv)
                        {
                            memcpy(g_pv, &bmi, sizeof(BITMAPINFOHEADER));

                            if (GetDIBits(hdc, hbmpOriginal, 0, bmi.biHeight, g_pv + 1, (BITMAPINFO*)&bmi, DIB_RGB_COLORS))
                            {
                                return (HANDLE)g_pv;
                            }
                        }
                    }

                    DeleteObject(hbmpOriginal);
                }

                DeleteDC(hdc);
            }
        }
    }

    return ORIGINAL_API(GetClipboardData)(uFormat);
}

BOOL 
APIHOOK(CloseClipboard)(
    VOID
    )
{
    if (g_pv)
    {
        delete g_pv;
        g_pv = NULL;   
    }
    
    return ORIGINAL_API(CloseClipboard)();
}

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetClipboardData)
    APIHOOK_ENTRY(USER32.DLL, CloseClipboard)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatedeleteobject.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateDeleteObject.cpp

 Abstract:

    This shim returns TRUE when the DeleteObject API is called regardless of 
    actual result: just like Win9x.

 Notes:

    This is a general purpose shim.

 History:

    10/10/1999 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateDeleteObject)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DeleteObject)
APIHOOK_ENUM_END

/*++

 Force DeleteObject to return TRUE.

--*/

BOOL 
APIHOOK(DeleteObject)(
    HGDIOBJ hObject
    )
{
    ORIGINAL_API(DeleteObject)(hObject);

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, DeleteObject)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatedirectdrawsync.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateDirectDrawSync.cpp

 Abstract:

    DirectDraw uses per-thread exclusive mode arbitration on NT. On Win9x this 
    is done per process. What this means is that if an app releases exclusive 
    mode from a different thread than that which acquired it, it will be in a 
    permanently bad state.
  
    This shim ensures that the mutex is obtained and released on the same 
    thread. During DLL_PROCESS_ATTACH, a new thread is started: this thread 
    manages the acquisition and release of the mutex.

    Note we can't get the mutex by catching CreateMutex because it's called 
    from the dllmain of ddraw.dll: so it wouldn't work on win2k.
  
 Notes:

    This is a general purpose shim.

 History:

    09/11/2000 prashkud  Created
    10/28/2000 linstev   Rewrote to work on win2k
    02/23/2001 linstev   Modified to handle cases where DirectDraw was used 
                         inside DllMains

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateDirectDrawSync)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WaitForSingleObject)
    APIHOOK_ENUM_ENTRY(ReleaseMutex)
    APIHOOK_ENUM_ENTRY(CloseHandle)
APIHOOK_ENUM_END

// Enum used to tell our thread what to do
enum {sNone, sWaitForSingleObject, sReleaseMutex};

// Events we use to signal our thread to do work and wait until its done
HANDLE g_hWaitEvent;
HANDLE g_hDoneEvent;
HANDLE g_hThread = NULL;

//
// Parameters that are passed between the caller thread and our thread
// Access is synchronized with a critical section
//

CRITICAL_SECTION g_csSync;
DWORD g_dwWait;
DWORD g_dwWaitRetValue;
DWORD g_dwTime;
BOOL g_bRetValue;

// Store the DirectDraw mutex handle
HANDLE g_hDDMutex = 0;

// Thread tracking data so we can identify degenerate cases
DWORD g_dwMutexOwnerThreadId = 0;

// Find the DirectDraw mutex
DWORD g_dwFindMutexThread = 0;

/*++

 Unfortunately we don't get in early enough on Win2k to get the mutex from the
 ddraw call to CreateMutex, so we have to make use of a special hack that knows
 about the ddraw internals.

 Ddraw has an export called GetOLEThunkData. The name is chosen to prevent 
 people from calling it. It is designed to be used by the test harness. One of 
 the things it can do, is release the exclusive mode mutex. This is the hack 
 we're exploiting so we can determine the mutex handle.

--*/

BOOL
FindMutex()
{
    typedef VOID (WINAPI *_pfn_GetOLEThunkData)(ULONG_PTR dwOrdinal);

    HMODULE hMod;
    _pfn_GetOLEThunkData pfnGetOLEThunkData;

    hMod = GetModuleHandleA("ddraw");
    if (!hMod) {
        DPFN( eDbgLevelError, "[FindMutex] DirectDraw not loaded");
        return FALSE;
    }

    pfnGetOLEThunkData = (_pfn_GetOLEThunkData) GetProcAddress(hMod, "GetOLEThunkData");
    if (!pfnGetOLEThunkData) {
        DPFN( eDbgLevelError, "[FindMutex] Failed to get GetOLEThunkData API");
        return FALSE;
    }

    //
    // Now we plan to go and find the mutex by getting Ddraw to call 
    // ReleaseMutex.
    //

    EnterCriticalSection(&g_csSync); 

    //
    // Set the mutex to the current thread so it can be picked up in the 
    // ReleaseMutex hook
    //

    g_dwFindMutexThread = GetCurrentThreadId();

    //
    // Call to the hard-coded (in ddraw) ReleaseMutex hack which releases the 
    // mutex
    //

    pfnGetOLEThunkData(6);

    g_dwFindMutexThread = 0;

    LeaveCriticalSection(&g_csSync);

    return (g_hDDMutex != 0);
}

/*++

 Hook WaitForSingleObject to determine when DirectDraw is testing or acquiring 
 the mutex. If we haven't got the mutex yet, we attempt to find it using our 
 hack.

--*/

DWORD
APIHOOK(WaitForSingleObject)(
    HANDLE hHandle,
    DWORD dwMilliSeconds
    )
{
    if (g_hThread) {

        //
        // Hack to find the DirectDraw mutex
        //
        if (!g_hDDMutex) {
            FindMutex();
        }
    
        if (g_hDDMutex && (hHandle == g_hDDMutex)) {

            //
            // Use our thread to acquire the mutex. We synchronize since we're
            // accessing globals to communicate with our thread.
            //
            DWORD dwRet;

            EnterCriticalSection(&g_csSync); 

            // Set globals to communicate with our thread
            g_dwTime = dwMilliSeconds;
            g_dwWait = sWaitForSingleObject;
        
            if (!ResetEvent(g_hDoneEvent))
            {
                DPFN( eDbgLevelError, "ResetEvent failed. Cannot continue");
                return WAIT_FAILED;
            }

            // Signal our thread to obtain the mutex
            if (!SetEvent(g_hWaitEvent))
            {
                DPFN( eDbgLevelError, "SetEvent failed. Cannot continue");
                return WAIT_FAILED;
            }

            // Wait until the state of the mutex has been determined
            WaitForSingleObject(g_hDoneEvent, INFINITE); 

            // Code to detect the degenerate
            if (g_dwWaitRetValue == WAIT_OBJECT_0) {
                g_dwMutexOwnerThreadId = GetCurrentThreadId();
            }

            dwRet = g_dwWaitRetValue;

            LeaveCriticalSection(&g_csSync);

            return dwRet;
        }
    }

    return ORIGINAL_API(WaitForSingleObject)(hHandle, dwMilliSeconds);
}

/*++

 Hook ReleaseMutex and release the mutex on our thread.

--*/

BOOL   
APIHOOK(ReleaseMutex)(
    HANDLE hMutex
    )
{
    if (g_hThread && (g_dwFindMutexThread == GetCurrentThreadId())) {

        //
        // We're using our hack to find the DirectDraw mutex
        // 
        DPFN( eDbgLevelInfo, "DDraw exclusive mode mutex found");
        g_hDDMutex = hMutex;
        
        // Don't release it, since we never acquired it
        return TRUE;
    }

    //
    // First try to release it on the current thread. This will only succeed if 
    // it was obtained on this thread.
    //

    BOOL bRet = ORIGINAL_API(ReleaseMutex)(hMutex);

    if (!bRet && g_hThread && g_hDDMutex && (hMutex == g_hDDMutex)) {

        //
        // Use our thread to release the mutex. We synchronize since we're
        // accessing globals to communicate with our thread.
        //
   
        EnterCriticalSection(&g_csSync);
    
        // Set globals to communicate with our thread
        g_dwWait = sReleaseMutex;

        if (!ResetEvent(g_hDoneEvent))
        {
            DPFN( eDbgLevelError, "ResetEvent failed. Cannot continue");
            return FALSE;
        }

        // Wait until our thread returns
        if (!SetEvent(g_hWaitEvent))
        {
            DPFN( eDbgLevelError, "SetEvent failed. Cannot continue");
            return FALSE;
        }

        // Signal our thread to release the mutex
        WaitForSingleObject(g_hDoneEvent, INFINITE);

        // Detect degenerate case
        if (GetCurrentThreadId() != g_dwMutexOwnerThreadId) {
            LOGN( eDbgLevelError, "[ReleaseMutex] DirectDraw synchronization error - correcting");
        }

        if (g_bRetValue) {
            g_dwMutexOwnerThreadId = 0;
        }

        bRet = g_bRetValue;

        LeaveCriticalSection(&g_csSync);

    }

    return bRet;
}

/*++

 Clear our handle in case the app frees ddraw and reloads it.

--*/    

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    if (g_hThread && (hObject == g_hDDMutex))
    {
        DPFN( eDbgLevelInfo, "DDraw exclusive mode mutex closed");
        g_hDDMutex = 0;
    }

    return ORIGINAL_API(CloseHandle)(hObject);
}

/*++

 Thread used to do all the mutex operations so we can guarantee that the thread
 that acquired the mutex is the same one that releases it.

--*/

VOID 
WINAPI 
ThreadSyncMutex(
    LPVOID /*lpParameter*/
    )
{
    for (;;) {
        // Wait until we need to acquire or release the mutex
        WaitForSingleObject(g_hWaitEvent, INFINITE);
        
        if (g_dwWait == sWaitForSingleObject) {
            // WaitForSingleobject() has been called on the Mutex object 
            g_dwWaitRetValue = ORIGINAL_API(WaitForSingleObject)(
                g_hDDMutex, g_dwTime);
        }  
        else if (g_dwWait == sReleaseMutex) {
            // ReleaseMutex has been called
            g_bRetValue = ORIGINAL_API(ReleaseMutex)(g_hDDMutex);
        }

        g_dwWait = sNone;

        if (!ResetEvent(g_hWaitEvent))
        {
            DPFN( eDbgLevelError, "ResetEvent failed. Cannot continue");
            return;
        }

        if (!SetEvent(g_hDoneEvent))
        {
            DPFN( eDbgLevelError, "SetEvent failed. Cannot continue");
            return;
        }
    }
}

/*++

 Register hooked functions

--*/    

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        //
        // We need the critical section all the time
        // Security change - InitializeCriticalSection to
        // InitializeCriticalSectionAndSpinCount. The high
        // bit of 'spincount' is set to 1 for preallocation.
        //
        if (InitializeCriticalSectionAndSpinCount(&g_csSync, 0x80000000) == FALSE)
        {
            DPFN( eDbgLevelError, "Failed to initialize critical section");
            return FALSE;
        }

        //
        // Create Events that will be used for the thread synchronization, i.e 
        // to synchronize this thread and the one we will be creating ahead. We 
        // don't clean these up by design. We have to do this stuff here, rather
        // than in the process attach, since OpenGL apps and others do DirectX 
        // stuff in their dllmains.
        // 

        g_hWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!g_hWaitEvent) {
            DPFN( eDbgLevelError, "Failed to create Event 1");
            return FALSE;
        }

        g_hDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!g_hDoneEvent) {
            DPFN( eDbgLevelError, "Failed to create Event 2");
            return FALSE;
        }

        // Create our thread
        g_hThread = CreateThread(NULL, 0, 
            (LPTHREAD_START_ROUTINE) ThreadSyncMutex, NULL, 0, 
            NULL);

        if (!g_hThread) {
            DPFN( eDbgLevelError, "Failed to create Thread");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, WaitForSingleObject)
    APIHOOK_ENTRY(KERNEL32.DLL, ReleaseMutex)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatebitmapstride.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateBitmapStride.cpp

 Abstract:

    When GetObjectA is called, modify the returned width of scan lines
    so that it is DWORD aligned for Bitmaps.  This is a bug in GetObjectA
    that will be fixed in whistler, but this shim is still needed for
    win2k.

    If a program is using the width of scan lines to determine if the bitmap
    is mono, 16, 24 bit, etc... it may cause the program to incorrectly display
    the bitmap.  Symptoms will be a skewed bitmap with colors shifted.

 Notes:

    This is a general purpose shim. 
    This bug is fixed in Whistler, so this shim is for Win2k.

 History:

    10/16/2000   mnikkel     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateBitmapStride)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetObjectA)
APIHOOK_ENUM_END

/*++

 Hook GetObjectA and align the stride if required.

--*/

int 
APIHOOK(GetObjectA)(
    HGDIOBJ hgdiobj,    // handle to graphics object
    int cbBuffer,       // size of buffer for object information
    LPVOID lpvObject    // buffer for object information
    )
{
    int  iRet= 0;

    iRet = ORIGINAL_API(GetObjectA)( 
        hgdiobj,  
        cbBuffer, 
        lpvObject);

    // If the call failed or the object is not a bitmap, pass through
    if (iRet != 0 &&
        GetObjectType(hgdiobj) == OBJ_BITMAP &&
        lpvObject != NULL)
    {
        BITMAP *pBitmap;
        LONG  lOrgSize, lSizeMod;

        // Check to see if the is a compatible bitmap or a DIB
        if (cbBuffer == sizeof(BITMAP))
        {
            pBitmap= (PBITMAP)lpvObject;
        }
        else
        {
            pBitmap= &(((PDIBSECTION)lpvObject)->dsBm);
        }

        // Check the width of scan lines to see if it is DWORD aligned
        lOrgSize = pBitmap->bmWidthBytes;
        lSizeMod = 4 - (lOrgSize & 3);
        if (lSizeMod == 4) 
        {
            lSizeMod = 0;
        }

        // If a change is necessary mod the size and log it.
        if (lSizeMod > 0)
        {
            pBitmap->bmWidthBytes += lSizeMod;
            LOGN( eDbgLevelInfo, "[GetObjectA] width of scan lines from %d to %d",
                        lOrgSize, pBitmap->bmWidthBytes );
        }

    }

    return iRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, GetObjectA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatecdfs.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateCDFS.cpp

 Abstract:

    Removes read only attributes from CD directories: just like Win9x.

    This shim has gone through several revisions. Originally it was thought 
    that win9x simply ignored the ReadOnly, DesiredAccess and ShareMode 
    parameters, but after some testing, it turns out that this is only true 
    for the CDRom drive.

    Unfortunately we have to check every file to see if it's on the CD first, 
    just in case someone opens with exclusive access and then tries to open 
    again.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000  a-jamd   Created
    12/02/2000  linstev  Separated into 2 shims: RemoveReadOnlyAttribute and this one
                         Added CreateFile hooks
    02/14/2002  mnikkel  Changed InitializeCriticalSection to InitializeCriticalSectionAndSpinCount

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(EmulateCDFS)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(CreateFileMappingA)
    APIHOOK_ENUM_ENTRY(MapViewOfFile)
    APIHOOK_ENUM_ENTRY(MapViewOfFileEx)
    APIHOOK_ENUM_ENTRY(DuplicateHandle)
    APIHOOK_ENUM_ENTRY(CloseHandle)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)        
    APIHOOK_ENUM_ENTRY(FindFirstFileW)         
    APIHOOK_ENUM_ENTRY(FindFirstFileA)             
    APIHOOK_ENUM_ENTRY(FindNextFileW)             
    APIHOOK_ENUM_ENTRY(FindNextFileA)              
    APIHOOK_ENUM_ENTRY(GetFileInformationByHandle)
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA) 
APIHOOK_ENUM_END

typedef struct _FINDFILE_HANDLE 
{
    HANDLE DirectoryHandle;
    PVOID FindBufferBase;
    PVOID FindBufferNext;
    ULONG FindBufferLength;
    ULONG FindBufferValidLength;
    RTL_CRITICAL_SECTION FindBufferLock;
} FINDFILE_HANDLE, *PFINDFILE_HANDLE;


class RO_FileMappingList
{
private:
    static VectorT<HANDLE> *    g_phROHandles;     // File mapping handles that we have forced to Read only
    static RO_FileMappingList * g_RO_Handles;
    static CRITICAL_SECTION     critSec;

    inline int GetIndex(HANDLE handle) const;

    RO_FileMappingList();
    ~RO_FileMappingList();

public:

    static void  Add(HANDLE roHandle);
    static void  Remove(HANDLE roHandle);
    static BOOL  Exist(HANDLE handle);
    static BOOL  Initialize();
};


// A global list of file mapping handles that we have forced to readonly
RO_FileMappingList * RO_FileMappingList::g_RO_Handles = NULL;
VectorT<HANDLE> *    RO_FileMappingList::g_phROHandles = NULL;     // File mapping handles that we have forced to Read only
CRITICAL_SECTION     RO_FileMappingList::critSec;


RO_FileMappingList::RO_FileMappingList()
{
}

RO_FileMappingList::~RO_FileMappingList()
{
    DeleteCriticalSection(&critSec);
}

void RO_FileMappingList::Add(HANDLE roHandle)
{
    if (roHandle != NULL)
    {
        EnterCriticalSection(&critSec);
        int index = g_RO_Handles->GetIndex(roHandle); 
        if (index == -1) // not found
        {
            DPFN(eDbgLevelSpew, "[RO_FileMappingList::Add] Handle 0x%08x", roHandle);
            g_phROHandles->Append(roHandle);    
        }
        LeaveCriticalSection(&critSec);
    }
}

void RO_FileMappingList::Remove(HANDLE roHandle)
{
    if (roHandle != NULL)
    {
        EnterCriticalSection(&critSec);
        int index = g_RO_Handles->GetIndex(roHandle); 
        if (index >= 0) // found it
        {
            DPFN(eDbgLevelSpew, "[RO_FileMappingList::Remove] Handle 0x%08x", roHandle);
            g_phROHandles->Remove(index);    
        }
        LeaveCriticalSection(&critSec);
    }
}

inline int RO_FileMappingList::GetIndex(HANDLE handle) const
{
    int index = g_phROHandles->Find(handle);
    return index;
}

BOOL RO_FileMappingList::Exist(HANDLE handle)
{
    EnterCriticalSection(&critSec);
    BOOL bExist = g_RO_Handles->GetIndex(handle) >= 0;
    LeaveCriticalSection(&critSec);

    return bExist;
}

BOOL RO_FileMappingList::Initialize()
{
        g_RO_Handles = new RO_FileMappingList;
        g_phROHandles = new VectorT<HANDLE>;

        if (g_RO_Handles && g_phROHandles)
        {
            return InitializeCriticalSectionAndSpinCount(&(g_RO_Handles->critSec),0x80000000);
        }

        return FALSE;
}
/*++

 Remove write attributes for read-only devices.

--*/

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        // file name
    LPOFSTRUCT lpReOpenBuff,  // file information
    UINT uStyle               // action and attributes
    )
{
    if ((uStyle & OF_READWRITE) && IsOnCDRomA(lpFileName))
    {
        // Remove the Read/Write bits
        uStyle &= ~OF_READWRITE;
        uStyle |= OF_READ;
        
        LOGN(eDbgLevelInfo, "[OpenFile] \"%s\": attributes modified for read-only device", lpFileName);
    }

    HFILE returnValue = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);

    return returnValue;
}

/*++

 Remove write attributes for read-only devices.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    if (((dwCreationDisposition == OPEN_EXISTING) || 
         (dwCreationDisposition == OPEN_ALWAYS)) &&
        ((dwDesiredAccess & GENERIC_WRITE) || 
         (dwShareMode != FILE_SHARE_READ)) &&
        IsOnCDRomA(lpFileName)) 
    {
        dwDesiredAccess &= ~GENERIC_WRITE;
        dwShareMode = FILE_SHARE_READ;
        
        LOGN(eDbgLevelInfo, "[CreateFileA] \"%s\": attributes modified for read-only device", lpFileName);
    }

    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING)
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;
        LOGN(eDbgLevelInfo, "[CreateFileA] \"%s\": removed NO_BUFFERING flag", lpFileName);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileA)(
                        lpFileName, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);

    DPFN(eDbgLevelSpew,
        "[CreateFileA] -File: \"%s\" -GENERIC_WRITE:%c -FILE_SHARE_WRITE:%c%s",
        lpFileName,
        (dwDesiredAccess & GENERIC_WRITE) ? 'Y' : 'N',
        (dwShareMode & FILE_SHARE_WRITE) ? 'Y' : 'N',
        (hRet == INVALID_HANDLE_VALUE) ? "\n\t***********Failed***********" : "");
    
    return hRet;
}

/*++

 Remove write attributes for read-only devices.

--*/

HANDLE 
APIHOOK(CreateFileW)(
    LPWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    if (((dwCreationDisposition == OPEN_EXISTING) || 
         (dwCreationDisposition == OPEN_ALWAYS)) &&
        ((dwDesiredAccess & GENERIC_WRITE) || 
         (dwShareMode != FILE_SHARE_READ)) &&
        IsOnCDRomW(lpFileName)) 
    {
        dwDesiredAccess &= ~GENERIC_WRITE;
        dwShareMode = FILE_SHARE_READ;
        
        LOGN(eDbgLevelError, "[CreateFileW] \"%S\": attributes modified for read-only device", lpFileName);
    }

    if (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING)
    {
        dwFlagsAndAttributes &= ~FILE_FLAG_NO_BUFFERING;
        LOGN(eDbgLevelInfo, "[CreateFileW] \"%S\": removed NO_BUFFERING flag", lpFileName);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileW)(
                        lpFileName, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);

    DPFN(eDbgLevelSpew, 
        "[CreateFileW] -File: \"%S\" -GENERIC_WRITE:%c -FILE_SHARE_WRITE:%c%s",
        lpFileName,
        (dwDesiredAccess & GENERIC_WRITE) ? 'Y' : 'N',
        (dwShareMode & FILE_SHARE_WRITE) ? 'Y' : 'N',
        (hRet == INVALID_HANDLE_VALUE) ? "\n\t***********Failed***********" : "");
    
    return hRet;
}

HANDLE
APIHOOK(CreateFileMappingA)(
    HANDLE hFile,                       // handle to file
    LPSECURITY_ATTRIBUTES lpAttributes, // security
    DWORD flProtect,                    // protection
    DWORD dwMaximumSizeHigh,            // high-order DWORD of size
    DWORD dwMaximumSizeLow,             // low-order DWORD of size
    LPCSTR lpName                       // object name
    )
{
    BOOL bChangedProtect = FALSE;
    if (!(flProtect & PAGE_READONLY) && IsOnCDRom(hFile)) 
    {
        // This handle is on a CD-ROM, force the protection to READONLY
        flProtect       = PAGE_READONLY;
        bChangedProtect = TRUE;

        LOGN(eDbgLevelError, "[CreateFileMappingA] Handle 0x%08x: attributes modified for read-only device", hFile);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileMappingA)(
                        hFile,
                        lpAttributes,
                        flProtect,
                        dwMaximumSizeHigh,
                        dwMaximumSizeLow,
                        lpName);
               
    // If the handle is on a CD-ROM, rember it
    if (bChangedProtect) 
    {
        RO_FileMappingList::Add(hRet);
    }

    DPFN(eDbgLevelSpew,
        "[CreateFileMappingA] Handle 0x%08x -PAGE_READWRITE:%c -PAGE_WRITECOPY:%c%s",
        lpName,
        (flProtect & PAGE_READWRITE) ? 'Y' : 'N',
        (flProtect & PAGE_WRITECOPY) ? 'Y' : 'N',
        (hRet == INVALID_HANDLE_VALUE) ? "\n\t***********Failed***********" : "");
    
    return hRet;
}

LPVOID  
APIHOOK(MapViewOfFile)(
    HANDLE hFileMappingObject,   // handle to file-mapping object
    DWORD dwDesiredAccess,       // access mode
    DWORD dwFileOffsetHigh,      // high-order DWORD of offset
    DWORD dwFileOffsetLow,       // low-order DWORD of offset
    SIZE_T dwNumberOfBytesToMap  // number of bytes to map
    )
{
    //
    // Check to see if we need to force Read access for CD-ROM files
    // Only the FILE_MAP_READ bit may be enabled for CD-ROM access
    //
    if ((dwDesiredAccess != FILE_MAP_READ) &&
         RO_FileMappingList::Exist(hFileMappingObject))
    {
        dwDesiredAccess = FILE_MAP_READ;
        LOGN(eDbgLevelError, "[MapViewOfFile] Handle 0x%08x: attributes modified for read-only device", hFileMappingObject);
    }

    HANDLE hRet = ORIGINAL_API(MapViewOfFile)(
        hFileMappingObject,
        dwDesiredAccess,
        dwFileOffsetHigh,
        dwFileOffsetLow,
        dwNumberOfBytesToMap);

    return hRet;
}

LPVOID  
APIHOOK(MapViewOfFileEx)(
    HANDLE hFileMappingObject,   // handle to file-mapping object
    DWORD dwDesiredAccess,       // access mode
    DWORD dwFileOffsetHigh,      // high-order DWORD of offset
    DWORD dwFileOffsetLow,       // low-order DWORD of offset
    SIZE_T dwNumberOfBytesToMap, // number of bytes to map
    LPVOID lpBaseAddress         // starting addres
    )
{
    //
    // Check to see if we need to force Read access for CD-ROM files
    // Only the FILE_MAP_READ bit may be enabled for CD-ROM access
    //
    if ((dwDesiredAccess != FILE_MAP_READ) &&
         RO_FileMappingList::Exist(hFileMappingObject))
    {
        dwDesiredAccess = FILE_MAP_READ;
        LOGN(eDbgLevelError,
            "[MapViewOfFile] Handle 0x%08x: attributes modified for read-only device", hFileMappingObject);
    }

    HANDLE hRet = ORIGINAL_API(MapViewOfFileEx)(
        hFileMappingObject,
        dwDesiredAccess,
        dwFileOffsetHigh,
        dwFileOffsetLow,
        dwNumberOfBytesToMap,
        lpBaseAddress);

    return hRet;
}

/*++

 If hSourceHandle has been mucked with, add the duplicated handle to our list

--*/

BOOL   
APIHOOK(DuplicateHandle)(
    HANDLE hSourceProcessHandle,  // handle to source process
    HANDLE hSourceHandle,         // handle to duplicate
    HANDLE hTargetProcessHandle,  // handle to target process
    LPHANDLE lpTargetHandle,      // duplicate handle
    DWORD dwDesiredAccess,        // requested access
    BOOL bInheritHandle,          // handle inheritance option
    DWORD dwOptions               // optional actions
    )
{
    BOOL retval = ORIGINAL_API(DuplicateHandle)(
        hSourceProcessHandle,
        hSourceHandle,
        hTargetProcessHandle,
        lpTargetHandle,
        dwDesiredAccess,
        bInheritHandle,
        dwOptions);

     if (retval && RO_FileMappingList::Exist(hSourceHandle))
     {
        RO_FileMappingList::Add(hTargetProcessHandle);
     }

     return retval;
}

/*++

 If hObject has been mucked with, remove it from the list.

--*/

BOOL  
APIHOOK(CloseHandle)(
    HANDLE hObject   // handle to object
    )
{
    RO_FileMappingList::Remove(hObject);

    return ORIGINAL_API(CloseHandle)(hObject);
}

/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesA)(LPCSTR lpFileName)
{    
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesA)(lpFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRomA(lpFileName))
    {
        // Flip the read-only bit.
        LOGN(eDbgLevelWarning, "[GetFileAttributesA] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

DWORD 
APIHOOK(GetFileAttributesW)(LPCWSTR wcsFileName)
{
    DWORD dwFileAttributes = ORIGINAL_API(GetFileAttributesW)(wcsFileName);
    
    // Check for READONLY and DIRECTORY attributes
    if ((dwFileAttributes != INT_PTR(-1)) &&
        (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRomW(wcsFileName))
    {
        // Flip the read-only bit.
        LOGN(eDbgLevelWarning, "[GetFileAttributesW] Removing FILE_ATTRIBUTE_READONLY");
        dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return dwFileAttributes;
}

/*++

 Remove read only attribute if it's a directory

--*/

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName, 
    LPWIN32_FIND_DATAA lpFindFileData
    )
{    
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // Flip the read-only bit
        LOGN(eDbgLevelWarning, "[FindFirstFileA] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR wcsFileName, 
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    HANDLE hFindFile = ORIGINAL_API(FindFirstFileW)(wcsFileName, lpFindFileData);

    if ((hFindFile != INVALID_HANDLE_VALUE) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // It's a directory: flip the read-only bit
        LOGN(eDbgLevelInfo, "[FindFirstFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return hFindFile;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileA)(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAA lpFindFileData 
    )
{    
    BOOL bRet = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // Flip the read-only bit.
        LOGN(eDbgLevelWarning, "[FindNextFileA] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(FindNextFileW)(
    HANDLE hFindFile, 
    LPWIN32_FIND_DATAW lpFindFileData 
    )
{
    BOOL bRet = ORIGINAL_API(FindNextFileW)(hFindFile, lpFindFileData);

    if (bRet &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFindFileData->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(((PFINDFILE_HANDLE) hFindFile)->DirectoryHandle))
    {
        // Flip the read-only bit
        LOGN(eDbgLevelWarning, "[FindNextFileW] Removing FILE_ATTRIBUTE_READONLY");
        lpFindFileData->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 Remove read only attribute if it's a directory.

--*/

BOOL 
APIHOOK(GetFileInformationByHandle)( 
    HANDLE hFile, 
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation 
    )
{
    BOOL bRet = ORIGINAL_API(GetFileInformationByHandle)(hFile, lpFileInformation);

    if (bRet &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (lpFileInformation->dwFileAttributes & FILE_ATTRIBUTE_READONLY) &&
        IsOnCDRom(hFile))
    {
        // It's a CDROM: flip the read-only bit.
        LOGN(eDbgLevelWarning, "[GetFileInformationByHandle] Removing FILE_ATTRIBUTE_READONLY");
        lpFileInformation->dwFileAttributes ^= FILE_ATTRIBUTE_READONLY;
    }

    return bRet;
}

/*++

 If the disk is a CDROM, return the same wrong numbers as Win9x

--*/

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
{
    if (IsOnCDRomA(lpRootPathName)) 
    {
        // Hard code values to match Win9x (wrong) description of CDROM
        *lpSectorsPerCluster        = 0x10;
        *lpBytesPerSector           = 0x800;
        *lpNumberOfFreeClusters     = 0;
        *lpTotalNumberOfClusters    = 0x2b7;

        return TRUE;
    } 
    else 
    {
        // Call the original API
        BOOL lRet = ORIGINAL_API(GetDiskFreeSpaceA)(
            lpRootPathName, 
            lpSectorsPerCluster, 
            lpBytesPerSector, 
            lpNumberOfFreeClusters, 
            lpTotalNumberOfClusters);

        return lRet;
    }
}

/*++

 Initialize all the registry hooks 

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // This forces the allocation of the array:
        return RO_FileMappingList::Initialize();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL, MapViewOfFile)
    APIHOOK_ENTRY(KERNEL32.DLL, MapViewOfFileEx)
    APIHOOK_ENTRY(KERNEL32.DLL, DuplicateHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileInformationByHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatecreateprocess.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    EmulateCreateProcess.cpp

 Abstract:

    This shim cleans up the StartupInfo data structure to prevent NT from
    access violating due to uninitialized members.

    It also performs a little cleanup of lpApplicationName and lpCommandLine

    Win9x uses short file names internally, so applications do not
    have any problem skipping the application name (first arg) on the command line;
    they typically skip to the first blank.


 History:

    11/22/1999  v-johnwh    Created
    04/11/2000  a-chcoff    Updated to quote lpCommandLine Properly.
    05/03/2000  robkenny    Skip leading white space in lpApplicationName and lpCommandLine
    10/09/2000  robkenny    Shim was placing quotes around lpCommandLine if it contained spaces,
                            this is totally wrong.  Since I could not find the app that required this,
                            I removed it entirely from the shim.
    03/09/2001  robkenny    Merged in CorrectCreateProcess16Bit
    03/15/2001  robkenny    Converted to CString
    05/21/2001  pierreys    Changes to DOS file handling to match 9X more precisely

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateCreateProcess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
APIHOOK_ENUM_END

BOOL g_bShortenExeOnCommandLine = FALSE;

/*++

 Clean parameters so we don't AV

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DPFN(
        eDbgLevelSpew,
        "[CreateProcessA] (%s) (%s)\n",
        (lpApplicationName ? lpApplicationName : "null"),
        (lpCommandLine ? lpCommandLine : "null"));
    
    BOOL    bStat = FALSE;
    DWORD   dwBinaryType;

    CSTRING_TRY
    {
        CString csOrigAppName(lpApplicationName);
        CString csOrigCommand(lpCommandLine);

        CString csAppName(csOrigAppName);
        CString csCommand(csOrigCommand);
        
        // Skip leading blanks.
        csAppName.TrimLeft();
        csCommand.TrimLeft();
        
        // Clean up lpStartupInfo
        if (lpStartupInfo)
        {
            if (lpStartupInfo->lpReserved ||
                lpStartupInfo->cbReserved2 ||
                lpStartupInfo->lpReserved2 ||
                lpStartupInfo->lpDesktop ||
                ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0 &&
                (lpStartupInfo->hStdInput ||
                lpStartupInfo->hStdOutput ||
                lpStartupInfo->hStdError)))
                {
    
                LOGN(
                    eDbgLevelError,
                    "[CreateProcessA] Bad params. Sanitized.");
            }
            
            //
            // Make sure that the parameters that can cause an access violation are
            // set correctly
            //
            lpStartupInfo->lpReserved  = NULL;
            lpStartupInfo->cbReserved2 = 0;
            lpStartupInfo->lpReserved2 = NULL;
    
            if ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0)
            {
                lpStartupInfo->hStdInput   = NULL;
                lpStartupInfo->hStdOutput  = NULL;
                lpStartupInfo->hStdError   = NULL;
            }
    
            lpStartupInfo->lpDesktop = NULL;
        }
    
        AppAndCommandLine acl(csAppName, csCommand);
    
        // Win9X has a rather weird behavihor: if the app is non-Win32 (Non-Console
        // and non GUI), it will use CreateProcessNonWin32. This will first check
        // if it is for a batch file, and if so it will prepend "command /c" and
        // continue on. Then there is going to be some weird creation of a 
        // REDIR32.EXE process, but that is just to make sure we have a new win32 
        // context. It will then use ExecWin16Program. The biggest weirdness is in
        // its QuoteAppName call. This procedure make sure that if the appname has
        // a space and is in the cmdline, it gets quoted. The appname, in all cases,
        // is then discarded (it is expected that the first part of the command line
        // contains the app name). So if someone like in b#373980 passes ("command", 
        // "setup", ... then 9X ends up dropping the command portion entirely since
        // it is not part of the commandline.


        
        // 16-bit process must have NULL lpAppName
        if (!csAppName.IsEmpty() &&
            GetBinaryTypeW(csAppName.Get(), &dwBinaryType) == TRUE)
        {
            switch (dwBinaryType)
            {
                case SCS_DOS_BINARY:

                    // Implementing the process.c's QuoteAppName check.
                    // If this function would return NULL, then only
                    // the cmdline would be used. Otherwise the new
                    // pszCmdFinal is used.

                    // QuoteAppName
                    // Look for white space in app name.  If we find any then we have to
                    // quote the app name portion of cmdline.
                    //
                    // LPSTR
                    // KERNENTRY
                    // QuoteAppName(
                    //    LPCSTR pszAppName,
                    //    LPCSTR pszCmdLine)
                    // {
                    //    LPSTR   pch;
                    //    LPSTR   pszApp;
                    //    LPSTR   pszCmdFinal = NULL;
                    //
                    //    // Check that there is an app name, not already quoted in the cmd line.
                    //    if( pszAppName && pszCmdLine && (*pszCmdLine != '\"')) {
                    //        // search for white space
                    //        for( pszApp = (LPSTR)pszAppName; *pszApp > ' '; pszApp++) ;
                    //
                    //        if( *pszApp) {  // found white space
                    //            // make room for the original cmd line plus 2 '"' + 0 terminator
                    //            pch = pszCmdFinal = HeapAlloc( hheapKernel, 0,
                    //                                           CbSizeSz( pszCmdLine)+3);
                    //            if( pch) { 
                    //                *pch++ = '\"'; // beginning dbl-quote
                    //                for( pszApp = (LPSTR)pszAppName; 
                    //                        *pszApp && *pszApp == *pszCmdLine;
                    //                         pszCmdLine++)
                    //                    *pch++ = *pszApp++;
                    //                if( !( *pszApp)) {
                    //                    *pch++ = '\"'; // trailing dbl-quote
                    //                     strcpy( pch, pszCmdLine);
                    //                } else {
                    //                    // app name and cmd line did not match
                    //                    HeapFree( hheapKernel, 0, pszCmdFinal);
                    //                    pszCmdFinal = NULL;
                    //                }
                    //            }
                    //        }
                    //    }
                    //    return pszCmdFinal;
                    //}

                    if ( /* app name already checked to be non empty */ !csCommand.IsEmpty() && (csCommand.Get())[0]!='\"')
                    {
                        if (csAppName.Find(L' ')!=-1)
                        {
                            int iAppLength=csAppName.GetLength();

                            if (csCommand.Find(csAppName)==0)
                            {
                                CString csCmdFinal=L"\"";
                                csCmdFinal += csAppName;
                                csCmdFinal += L"\"";
                                csCmdFinal += csCommand.Mid(iAppLength);

                                csCommand = csCmdFinal;

                                LOGN(   eDbgLevelSpew,
                                        "[CreateProcessA] Weird quoted case: cmdline %s converted to %S",
                                         lpCommandLine,
                                         csCommand.Get());
                            }

                        }
                    }

                    LOGN(   eDbgLevelSpew,
                            "[CreateProcessA] DOS file case: not using appname %s, just cmdline %s, converted to %S",
                             lpApplicationName,
                             lpCommandLine,
                             csCommand.Get());

                    csAppName.Empty();
                
                    //
                    // The old code in non-WOW case would do this.
                    //
                    if (g_bShortenExeOnCommandLine)
                    {
                        csCommand = acl.GetShortCommandLine();
                    }
                    break;

                case SCS_WOW_BINARY:
                    //
                    // This is the old code. Accoring to 9X, we should be doing
                    // the same as DOS, but we obviously found an app that 
                    // needed this.
                    //
                    csCommand = csAppName;    
                    csCommand.GetShortPathNameW();
                    csCommand += L' ';
                    csCommand += acl.GetCommandlineNoAppName();
        
                    csAppName.Empty();
                    break;

                default:
                    //
                    // The old code in non-WOW case would do this.
                    //
                    if (g_bShortenExeOnCommandLine)
                    {
                        csCommand = acl.GetShortCommandLine();
                    }
                    break;
                }
        }
        else if (g_bShortenExeOnCommandLine)
        {
            csCommand = acl.GetShortCommandLine();
        }
    
        LPCSTR  lpNewApplicationName = csAppName.GetAnsiNIE();
        LPSTR   lpNewCommandLine     = csCommand.GetAnsiNIE();
    
        // Log any changes
        if (csOrigAppName != csAppName)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessA] Sanitized lpApplicationName (%s) to (%s)",
                lpApplicationName, lpNewApplicationName);
        }
        if (csOrigCommand != csCommand)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessA] Sanitized lpCommandLine     (%s) to (%s)",
                lpCommandLine, lpNewCommandLine);
        }
    
        bStat = ORIGINAL_API(CreateProcessA)(
                                lpNewApplicationName,
                                lpNewCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }
    CSTRING_CATCH
    {
        bStat = ORIGINAL_API(CreateProcessA)(
                                lpApplicationName,
                                lpCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }

    
    return bStat;
}

/*++

 Clean parameters so we don't AV

--*/

BOOL
APIHOOK(CreateProcessW)(
    LPCWSTR               lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCWSTR               lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    DPFN(
        eDbgLevelSpew,
        "[CreateProcessW] (%S) (%S)\n",
        (lpApplicationName ? lpApplicationName : L"null"),
        (lpCommandLine ? lpCommandLine : L"null"));

    BOOL bStat = FALSE;

    CSTRING_TRY
    {
        CString csAppName(lpApplicationName);
        CString csCommand(lpCommandLine);
        
        // Skip leading blanks.
        csAppName.TrimLeft();
        csCommand.TrimLeft();
        
        // Clean up lpStartupInfo
        if (lpStartupInfo)
        {
            if (lpStartupInfo->lpReserved ||
                lpStartupInfo->cbReserved2 ||
                lpStartupInfo->lpReserved2 ||
                lpStartupInfo->lpDesktop ||
                ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0 &&
                (lpStartupInfo->hStdInput ||
                lpStartupInfo->hStdOutput ||
                lpStartupInfo->hStdError)))
                {
    
                LOGN(
                    eDbgLevelError,
                    "[CreateProcessW] Bad params. Sanitized.");
            }
            
            //
            // Make sure that the parameters that can cause an access violation are
            // set correctly
            //
            lpStartupInfo->lpReserved  = NULL;
            lpStartupInfo->cbReserved2 = 0;
            lpStartupInfo->lpReserved2 = NULL;
    
            if ((lpStartupInfo->dwFlags & STARTF_USESTDHANDLES) == 0)
            {
                lpStartupInfo->hStdInput   = NULL;
                lpStartupInfo->hStdOutput  = NULL;
                lpStartupInfo->hStdError   = NULL;
            }
    
            lpStartupInfo->lpDesktop = NULL;
        }
    
        AppAndCommandLine acl(csAppName, csCommand);
        // 16-bit process must have NULL lpAppName
        if (!csAppName.IsEmpty() && IsImage16BitW(csAppName.Get()))
        {
            csCommand = csAppName;    
            csCommand.GetShortPathNameW();
            csCommand += L' ';
            csCommand += acl.GetCommandlineNoAppName();
            
            csAppName.Empty();
        }
        else if (g_bShortenExeOnCommandLine)
        {
            csCommand = acl.GetShortCommandLine();
        }
   
        LPCWSTR  lpNewApplicationName = csAppName.GetNIE();
        LPWSTR   lpNewCommandLine     = (LPWSTR) csCommand.GetNIE(); // stupid api doesn't take const
    
        // Log any changes
        if (lpApplicationName && lpNewApplicationName && _wcsicmp(lpApplicationName, lpNewApplicationName) != 0)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessW] Sanitized lpApplicationName (%S) to (%S)",
                lpApplicationName, lpNewApplicationName);
        }
        if (lpCommandLine && lpNewCommandLine && _wcsicmp(lpCommandLine, lpNewCommandLine) != 0)
        {
            LOGN(
                eDbgLevelError,
                "[CreateProcessW] Sanitized lpCommandLine     (%S) to (%S)",
                lpCommandLine, lpNewCommandLine);
        }
    
        bStat = ORIGINAL_API(CreateProcessW)(
                                lpNewApplicationName,
                                lpNewCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }
    CSTRING_CATCH
    {
        bStat = ORIGINAL_API(CreateProcessW)(
                                lpApplicationName,
                                lpCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
    }
    
    return bStat;
}


/*++

 Clean up the command line

--*/

UINT
APIHOOK(WinExec)(
    LPCSTR lpCommandLine,  // command line
    UINT   uCmdShow        // window style
    )
{
    CSTRING_TRY
    {
        CString csOrigCommand(lpCommandLine);
        CString csCommand(csOrigCommand);
        csCommand.TrimLeft();

        LPCSTR lpNewCommandLine = csCommand.GetAnsi();
        
        if (csOrigCommand != csCommand)
        {
            LOGN(
                eDbgLevelError,
                "[WinExec] Sanitized lpCommandLine (%s) (%s)",
                lpCommandLine, lpNewCommandLine);
        }
    
        return ORIGINAL_API(WinExec)(lpNewCommandLine, uCmdShow);
    }
    CSTRING_CATCH
    {
        return ORIGINAL_API(WinExec)(lpCommandLine, uCmdShow);
    }
}

/*++

    Create the appropriate g_PathCorrector

--*/
void
ParseCommandLine(
    const char* commandLine
    )
{
    //
    // Force the default values.
    //
    g_bShortenExeOnCommandLine = FALSE;

    CString csCL(commandLine);
    if (csCL.CompareNoCase(L"+ShortenExeOnCommandLine") == 0)
    {
        g_bShortenExeOnCommandLine = TRUE;
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatedrawtext.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateDrawText.cpp

 Abstract:

    Win9x DrawText modified the rectangle coordinates if they were
    out of range.  With Win2000 the text will not appear on the
    screen with out of range formatting dimensions. The solution
    is to toggle the high order bit for out of range coordinates.

    We also cast nCount to 16-bits for apps which pass 0x0000ffff 
    instead of a true -1, because the Win9x thunk does this.

 Notes:
    
    This is a general purpose shim.

 History:

    05/03/2000 a-michni  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateDrawText)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DrawTextA)
    APIHOOK_ENUM_ENTRY(DrawTextW)
APIHOOK_ENUM_END


/*++

 Correct the formatting dimensions if necessary.

--*/
long 
Fix_Coordinate(
    long nCoord
    )
{
    if ((nCoord & 0x80000000) && ((nCoord & 0x40000000) == 0)) {
        nCoord &= 0x7FFFFFFF;
    } else if (((nCoord & 0x80000000) == 0) && (nCoord & 0x40000000)) {
        nCoord |= 0x10000000;
    }

    return nCoord;
}


LPRECT 
Fix_Coordinates(
    LPRECT lpRect
    )
{
    //
    // Check bit 32, if it is on and bit 31 is off or bit 32 is off and
    // bit 31 is on, flip bit 32.
    //
    lpRect->left  = Fix_Coordinate(lpRect->left);
    lpRect->right = Fix_Coordinate(lpRect->right);
    lpRect->top   = Fix_Coordinate(lpRect->top);
    lpRect->bottom= Fix_Coordinate(lpRect->bottom);

    return lpRect;
}


int 
APIHOOK(DrawTextA)(
    HDC     hDC,        // handle to DC
    LPCSTR  lpString,   // text to draw
    int     nCount,     // text length
    LPRECT  lpRect,     // formatting dimensions
    UINT    uFormat     // text-drawing options
    )
{
    return ORIGINAL_API(DrawTextA)(
                            hDC,
                            lpString,
                            (__int16) nCount,
                            Fix_Coordinates(lpRect),
                            uFormat);
}

int 
APIHOOK(DrawTextW)(
    HDC     hDC,        // handle to DC
    LPCWSTR lpString,   // text to draw
    int     nCount,     // text length
    LPRECT  lpRect,     // formatting dimensions
    UINT    uFormat     // text-drawing options
    )
{
    return ORIGINAL_API(DrawTextW)(
                            hDC,
                            lpString,
                            (__int16) nCount,
                            Fix_Coordinates(lpRect),
                            uFormat);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, DrawTextA)
    APIHOOK_ENTRY(USER32.DLL, DrawTextW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateenvironmentblock.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    EmulateEnvironmentBlock.cpp

 Abstract:
    
    Shrink the enviroment strings to avoid memory corruption experienced by 
    some apps when they get a larger than expected enviroment.

 Notes:

    This is a general purpose shim.

 History:

    01/19/2001 linstev  Created
    02/18/2002 mnikkel  modified to use strsafe routines.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateEnvironmentBlock)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(GetEnvironmentStrings)
    APIHOOK_ENUM_ENTRY(GetEnvironmentStringsA)
    APIHOOK_ENUM_ENTRY(GetEnvironmentStringsW)
    APIHOOK_ENUM_ENTRY(FreeEnvironmentStringsA)
    APIHOOK_ENUM_ENTRY(FreeEnvironmentStringsW)

APIHOOK_ENUM_END

#define MAX_ENV 1024

CHAR  g_szBlockA[MAX_ENV];
WCHAR g_szBlockW[MAX_ENV];

WCHAR *g_szEnv[] = {
    L"TMP=%TMP%",
    L"TEMP=%TEMP%",
    L"PROMPT=%PROMPT%",
    L"winbootdir=%WINDIR%",
    L"PATH=%WINDIR%",
    L"COMSPEC=%COMSPEC%",
    L"WINDIR=%WINDIR%",
    NULL
};

/*++

 Build a reasonable looking environment block

--*/

BOOL BuildEnvironmentStrings()
{
    WCHAR *pPtr = g_szBlockW;
    WCHAR szTmp[MAX_PATH];
    DWORD dwSize = 0;    DWORD i = 0;

    DPFN( eDbgLevelError, "Building Environment Block");

    // Calculate the remaining block size, subtract one so we can add extra null
    // terminator after all variables are added.
    DWORD dwRemainingBlockSize = ARRAYSIZE(g_szBlockW)-1;
    
    //
    // Run g_szEnv, expand all the strings and cat them together to form the 
    // new block.  pPtr points to current location to write to in g_szBlockW.
    // 
    while (g_szEnv[i])
    {
        // Expand the environment string, Note: dwSize DOES include the null terminator.
        dwSize = ExpandEnvironmentStringsW(g_szEnv[i], szTmp, MAX_PATH);
        if ((dwSize > 0) && (dwSize <= MAX_PATH))
        {
            // If expansion was successful add the string to our environment block
            // if there is room.
            if (dwSize <= dwRemainingBlockSize &&
                S_OK == StringCchCopy(pPtr, dwRemainingBlockSize, szTmp))
            {
                // update the block size remaining and move the location pointer.
                dwRemainingBlockSize -= dwSize;
                pPtr += dwSize;
                DPFN( eDbgLevelError, "\tAdding: %S", szTmp);
            }
            else
            {
                DPFN( eDbgLevelError, "Enviroment > %08lx, ignoring %S", MAX_ENV, szTmp);
            }
        }

        i++;
    }

    //
    // Add the extra null terminator and calculate size of env block.
    //
    *pPtr = L'\0';
    pPtr++;
    dwSize = pPtr - g_szBlockW;
     
    // 
    // ANSI conversion for the A functions
    // 

    WideCharToMultiByte(
        CP_ACP, 
        0, 
        (LPWSTR) g_szBlockW, 
        dwSize, 
        (LPSTR) g_szBlockA, 
        dwSize,
        0, 
        0);

    return TRUE;
}

/*++

 Return our block

--*/

LPVOID 
APIHOOK(GetEnvironmentStrings)()
{
    return (LPVOID) g_szBlockA;
}

/*++

 Return our block

--*/

LPVOID 
APIHOOK(GetEnvironmentStringsA)()
{
    return (LPVOID) g_szBlockA;
}

/*++

 Return our block

--*/

LPVOID 
APIHOOK(GetEnvironmentStringsW)()
{
    return (LPVOID) g_szBlockW;
}

/*++

 Check for our block.

--*/

BOOL 
APIHOOK(FreeEnvironmentStringsA)(
    LPSTR lpszEnvironmentBlock
    )
{
    if ((lpszEnvironmentBlock == (LPSTR)&g_szBlockA[0]) ||
        (lpszEnvironmentBlock == (LPSTR)&g_szBlockW[0]))
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(FreeEnvironmentStringsA)(lpszEnvironmentBlock);
    }
}

/*++

 Check for our block.

--*/

BOOL 
APIHOOK(FreeEnvironmentStringsW)(
    LPWSTR lpszEnvironmentBlock
    )
{
    if ((lpszEnvironmentBlock == (LPWSTR)&g_szBlockA[0]) ||
        (lpszEnvironmentBlock == (LPWSTR)&g_szBlockW[0]))
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(FreeEnvironmentStringsW)(lpszEnvironmentBlock);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return BuildEnvironmentStrings();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentStrings)
    APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentStringsA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentStringsW)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeEnvironmentStringsA)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeEnvironmentStringsW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatefindhandles.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   EmulateFindHandles.cpp

 Abstract:

    If an application calls FindFirstFile on a directory, then attempts to 
    remove that directory without first closing the FindFirstFile handle, the 
    directory will be in use; The RemoveDirectory call will return an 
    ERROR_SHARING_VIOLATION error.  This shim will force the FindFirstFile 
    handle closed to ensure the directory is removed.

    This shim also ensures the FindFirstFile handles are valid before calling
    FindNext or FindClose.

    The FindFirstFile handle will not be forced closed unless the directory
    is empty.

 History:

    04/12/2000  robkenny    Created
    11/13/2000  robkenny    Fixed PREFIX bugs, mostly by removing the W routines.
    11/20/2000  maonis      Added FindNextFile and renamed from RemoveDirectoryInUse.
    02/27/2001  robkenny    Converted to use CString
    04/26/2001  robkenny    FindFileInfo now normalizes the names for comparisons
                            Moved all AutoLockFFIV outside of the exception handlers
                            to ensure they are deconstructed correctly.
    02/14/2002  mnikkel     Changed GetHandleVector to correct Prefix errors.

--*/

#include "precomp.h"

#include "CharVector.h"
#include "parseDDE.h"

IMPLEMENT_SHIM_BEGIN(EmulateFindHandles)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindNextFileA)
    APIHOOK_ENUM_ENTRY(FindClose)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(DdeClientTransaction)
APIHOOK_ENUM_END

BOOL g_bHookDDE = TRUE; // default to hooking DDE

//---------------------------------------------------------------------------
// A class that automatically locks/unlocks the FFIV
class AutoLockFFIV
{
public:
    AutoLockFFIV();
    ~AutoLockFFIV();
};

//---------------------------------------------------------------------------
/*++

    HANDLE Vector type class.

--*/
class FindFileInfo
{
public:
    HANDLE             m_hFindHandle;
    CString            m_csFindName;

    FindFileInfo(HANDLE findHandle, LPCSTR lpFileName)
    {
        Init(findHandle, lpFileName);
    }

    // Convert csFileName into a fully qualified, long path to the *directory*
    // c:\Program Files\Some App\*.exe      should get changed to c:\Program Files\Some App
    // c:\Progra~1\Some~1\*.exe             should get changed to c:\Program Files\Some App
    // .\*.exe                              should get changed to c:\Program Files\Some App
    // *.exe                                should get changed to *.exe
    static void NormalizeName(CString & csFileName)
    {
        DWORD dwAttr = GetFileAttributesW(csFileName);
        if (dwAttr == INVALID_FILE_ATTRIBUTES)
        {
            CString csDirPart;
            csFileName.GetNotLastPathComponent(csDirPart);
            csFileName = csDirPart;
        }
    
        csFileName.GetFullPathName();
        csFileName.GetLongPathName();
    }
    // Init the values, we store the full path for safe compares
    void Init(HANDLE findHandle, LPCSTR lpFileName)
    {
        m_hFindHandle = findHandle;
        m_csFindName = lpFileName;

        NormalizeName(m_csFindName);
    }

    bool operator == (HANDLE findHandle) const
    {
        return findHandle == m_hFindHandle;
    }

    bool operator == (LPCSTR lpFileName) const
    {
        // We need to convert lpFileName the same way as done in Init()
        CString csFileName(lpFileName);
        NormalizeName(csFileName);

        return m_csFindName.CompareNoCase(csFileName) == 0;
    }
};

class FindFileInfoVector : public VectorT<FindFileInfo *>
{
protected:
    static FindFileInfoVector * g_TheHandleVector;
    CRITICAL_SECTION     m_Lock;

public:
    FindFileInfoVector()
    {
    }

    void Lock()
    {
        EnterCriticalSection(&m_Lock);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_Lock);
    }

    // Search through the list of open FindFirstFile handles for a match to hMember
    FindFileInfo * Find(HANDLE hMember)
    {
        if (hMember != INVALID_HANDLE_VALUE)
        {
            DPF(g_szModuleName,
                eDbgLevelSpew,
                "FindFileInfoVector::Find(0x%08x)\n",
                hMember);
            for (int i = 0; i < Size(); ++i)
            {
                FindFileInfo * ffi = Get(i);
                if (*ffi == hMember)
                {
                    DPF(g_szModuleName,
                        eDbgLevelSpew,
                        "FindFileInfoVector: FOUND handle 0x%08x (%S)\n",
                        ffi->m_hFindHandle, ffi->m_csFindName.Get());
                    return ffi;
                }
            }
        }
        return NULL;
    }

    // Search through the list of open FindFirstFile handles for a match to lpFileName
    FindFileInfo * Find(LPCSTR lpFileName)
    {
        if (lpFileName != NULL)
        {
            DPF(g_szModuleName,
                eDbgLevelSpew,
                "FindFileInfoVector::Find(%s)\n",
                lpFileName);
            for (int i = 0; i < Size(); ++i)
            {
                FindFileInfo * ffi = Get(i);
                if (*ffi == lpFileName)
                {
                    DPF(g_szModuleName,
                        eDbgLevelSpew,
                        "FindFileInfoVector: FOUND handle 0x%08x (%S)\n",
                        ffi->m_hFindHandle, ffi->m_csFindName.Get());
                    return ffi;
                }
#if 0
                else
                {
                    DPF(g_szModuleName,
                        eDbgLevelSpew,
                        "FindFileInfoVector: NOT FOUND handle 0x%08x (%S)\n",
                        ffi.m_hFindHandle, ffi.m_csFindName.Get());
                }

#endif
            }
        }
        return NULL;
    }

    // Remove the FindFileInfo,
    // return true if the handle was actually removed.
    bool Remove(FindFileInfo * ffi)
    {
        for (int i = 0; i < Size(); ++i)
        {
            if (Get(i) == ffi)
            {
                DPF(g_szModuleName,
                    eDbgLevelSpew,
                    "FindFileInfoVector: REMOVED handle 0x%08x (%S)\n",
                    ffi->m_hFindHandle, ffi->m_csFindName.Get());

                // Remove the entry by copying the last entry over this index

                // Only move if this is not the last entry.
                if (i < Size() - 1)
                {
                    CopyElement(i, Get(Size() - 1));
                }
                nVectorList -= 1;
            }
        }
        return false;
    }

    // Initialize the global FindFileInfoVector
    static BOOL InitializeHandleVector()
    {
        g_TheHandleVector = new FindFileInfoVector;

        if (g_TheHandleVector)
        {
            return InitializeCriticalSectionAndSpinCount(&(g_TheHandleVector->m_Lock),0x80000000);
        }

        return FALSE;
    }

    // Return a pointer to the global FindFileInfoVector
    static FindFileInfoVector * GetHandleVector()
    {
        return g_TheHandleVector;
    }
};

FindFileInfoVector * FindFileInfoVector::g_TheHandleVector = NULL;
FindFileInfoVector * OpenFindFileHandles;

AutoLockFFIV::AutoLockFFIV()
{
    FindFileInfoVector::GetHandleVector()->Lock();
}
AutoLockFFIV::~AutoLockFFIV()
{
    FindFileInfoVector::GetHandleVector()->Unlock();
}

//---------------------------------------------------------------------------

/*++
    Call FindFirstFileA, if it fails because the file doesn't exist,
    correct the file path and try again.
--*/
HANDLE 
APIHOOK(FindFirstFileA)(
  LPCSTR lpFileName,               // file name
  LPWIN32_FIND_DATAA lpFindFileData  // data buffer
)
{
    HANDLE returnValue = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if (returnValue != INVALID_HANDLE_VALUE)
    {
        DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindFirstFileA: adding   handle 0x%08x (%s)\n",
            returnValue, lpFileName);

        AutoLockFFIV lock;
        CSTRING_TRY
        {
            // Save the handle for later.
            FindFileInfo *ffi = new FindFileInfo(returnValue, lpFileName);
            FindFileInfoVector::GetHandleVector()->Append(ffi);
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

/*++

 Add the file handle to our list.

--*/

HANDLE
APIHOOK(FindFirstFileExA)(
    LPCSTR lpFileName,     
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,  
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,  
    DWORD dwAdditionalFlags 
    )
{
    HANDLE returnValue = ORIGINAL_API(FindFirstFileExA)(
                        lpFileName, 
                        fInfoLevelId,
                        lpFindFileData,
                        fSearchOp,
                        lpSearchFilter,
                        dwAdditionalFlags);

    if (returnValue != INVALID_HANDLE_VALUE)
    {
        DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindFirstFileA: adding   handle 0x%08x (%s)\n",
            returnValue, lpFileName);

        AutoLockFFIV lock;
        CSTRING_TRY
        {
            // Save the handle for later.
            FindFileInfo *ffi = new FindFileInfo(returnValue, lpFileName);
            FindFileInfoVector::GetHandleVector()->Append(ffi);
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

/*++

 Validates the FindFirstFile handle before calling FindNextFileA.
 
--*/
BOOL 
APIHOOK(FindNextFileA)(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    BOOL returnValue = FALSE;

    AutoLockFFIV lock;
    CSTRING_TRY
    {
        // Only call FindNextFileA if the handle is actually open
        FindFileInfo * ffi = FindFileInfoVector::GetHandleVector()->Find(hFindFile);
        if (ffi)
        {
            returnValue = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);

            DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindNextFile: using handle 0x%08x (%ls)\n",
            hFindFile, ffi->m_csFindName.Get());
        }
    }
    CSTRING_CATCH
    {
        returnValue = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);
    }

    return returnValue;
}

/*++

 Remove the file handle to our list.
 
--*/
BOOL 
APIHOOK(FindClose)(
  HANDLE hFindFile   // file search handle
)
{
    BOOL returnValue = FALSE;

    AutoLockFFIV lock;
    CSTRING_TRY
    {
        // Only call FindClose if the handle is actually open
        FindFileInfo * ffi = FindFileInfoVector::GetHandleVector()->Find(hFindFile);
        if (ffi)
        {
            returnValue = ORIGINAL_API(FindClose)(hFindFile);

            DPF(g_szModuleName,
            eDbgLevelSpew,
            "FindClose: removing   handle 0x%08x (%S)\n",
            hFindFile, ffi->m_csFindName.Get());

            // Remove this entry from the list of open FindFirstFile handles.
            FindFileInfoVector::GetHandleVector()->Remove(ffi);
        }
    }
    CSTRING_CATCH
    {
        returnValue = ORIGINAL_API(FindClose)(hFindFile);
    }

    return returnValue;
}



/*++
    Call RemoveDirectoryA, if it fails because the directory is in use,
    make sure all FindFirstFile handles are closed, then try again.
--*/

BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpFileName   // directory name
    )
{
    FindFileInfo * ffi;

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryA)(lpFileName);
    if (!returnValue)
    {
        AutoLockFFIV lock;

        CSTRING_TRY
        {
            DWORD dwLastError = GetLastError();
    
            // NOTE:
            // ERROR_DIR_NOT_EMPTY error takes precedence over ERROR_SHARING_VIOLATION,
            // so we will not forcably to free the FindFirstFile handles unless the directory is empty.
    
            // If the directory is in use, check to see if the app left a FindFirstFileHandle open.
            if (dwLastError == ERROR_SHARING_VIOLATION)
            {
                // Close all FindFirstFile handles open to this directory.
                ffi = FindFileInfoVector::GetHandleVector()->Find(lpFileName);
                while(ffi)
                {
                    DPF(g_szModuleName,
                        eDbgLevelError,
                        "[RemoveDirectoryA] Forcing closed FindFirstFile (%S).",
                        ffi->m_csFindName.Get());
                    
                    // Calling FindClose here would not, typically, get hooked, so we call
                    // our hook routine directly to ensure we close the handle and remove it from the list
                    // If we don't remove it from the list we'll never get out of this loop :-)
                    APIHOOK(FindClose)(ffi->m_hFindHandle);
                    ffi = FindFileInfoVector::GetHandleVector()->Find(lpFileName);
                }
    
                // Last chance
                returnValue = ORIGINAL_API(RemoveDirectoryA)(lpFileName);
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return returnValue;
}

// A list of DDE commands that we are interested in.
const char * c_sDDECommands[] =
{
    "DeleteGroup",
    NULL,
} ;

// Parse the DDE Command looking for DeleteGroup,
// If the command is found, make sure that we do not have any open FindFirstFile handles
// on that directory.
// This needs to be aware of "User"  vs.  "All Users" syntax of DDE
void CloseHandleIfDeleteGroup(LPBYTE pData)
{
    if (pData)
    {
        // Now we need to parse the string, looking for a DeleteGroup command
        // Format "[DeleteGroup(GroupName, CommonGroupFlag)]"
        // CommonGroupFlag is optional

        char * pszBuf = StringDuplicateA((const char *)pData);
        if (!pszBuf)
            return;

        UINT * lpwCmd = GetDDECommands(pszBuf, c_sDDECommands, FALSE);
        if (lpwCmd)
        {
            // Store off lpwCmd so we can free the correect addr later
            UINT *lpwCmdTemp = lpwCmd;

            // Execute a command.
            while (*lpwCmd != (UINT)-1)
            {
                UINT wCmd = *lpwCmd++;
                // Subtract 1 to account for the terminating NULL
                if (wCmd < ARRAYSIZE(c_sDDECommands)-1)
                {

                    // We found a command--it must be DeleteGroup--since there is only 1

                    BOOL iCommonGroup = -1;

                    // From DDE_DeleteGroup
                    if (*lpwCmd < 1 || *lpwCmd > 3)
                    {
                        goto Leave;
                    }
                    if (*lpwCmd == 2)
                    {
                        //
                        // Need to check for common group flag
                        //
                        if (pszBuf[*(lpwCmd + 2)] == TEXT('1')) {
                            iCommonGroup = 1;
                        } else {
                            iCommonGroup = 0;
                        }
                    }
                    const char * groupName = pszBuf + lpwCmd[1];

                    // Build a path to the directory
                    AutoLockFFIV lock;
                     
                    CSTRING_TRY
                    {
                        // Build a path to the directory
                        CString csGroupName;
                        GetGroupPath(groupName, csGroupName, 0, iCommonGroup);
                     
                        // Attempt to delete the directory, since we are calling our hooked
                        // routine, it will detect if the directory is in use and do the dirty work.
                        
                        // Close all FindFirstFile handles open to this directory.
                        
                        const char * szGroupName = csGroupName.GetAnsi();

                        for (FindFileInfo * ffi = FindFileInfoVector::GetHandleVector()->Find(szGroupName);
                             ffi != NULL;
                             ffi = FindFileInfoVector::GetHandleVector()->Find(szGroupName))
                        {
                            DPF(g_szModuleName,
                                eDbgLevelError,
                                "[DdeClientTransaction] %s Forcing closed FindFirstFile (%S).",
                                pData, ffi->m_csFindName.Get());
                            // Calling FindClose here would not, typically, get hooked, so we call
                            // our hook routine directly to ensure we close the handle and remove it from the list
                            // If we don't remove it from the list we'll never get out of this loop :-)
                            APIHOOK(FindClose)(ffi->m_hFindHandle);
                        }
                    }
                    CSTRING_CATCH
                    {
                        // Do nothing
                    }
                }

                // Next command.
                lpwCmd += *lpwCmd + 1;
            }

    Leave:
            // Tidyup...
            GlobalFree(lpwCmdTemp);
        }

        free(pszBuf);
    }
}
//==============================================================================
//==============================================================================

HDDEDATA 
APIHOOK(DdeClientTransaction)( IN LPBYTE pData, IN DWORD cbData,
        IN HCONV hConv, IN HSZ hszItem, IN UINT wFmt, IN UINT wType,
        IN DWORD dwTimeout, OUT LPDWORD pdwResult)
{
#if 0
    // Allow a longer timeout for debugging purposes.
    dwTimeout = 0x0fffffff;
#endif

    CloseHandleIfDeleteGroup(pData);

    HDDEDATA returnValue = ORIGINAL_API(DdeClientTransaction)(
                        pData,
                        cbData,
                        hConv, 
                        hszItem, 
                        wFmt, 
                        wType,
                        dwTimeout, 
                        pdwResult);

    return returnValue;
}

/*++

    Parse the command line, looking for the -noDDE switch

--*/
void ParseCommandLine(const char * commandLine)
{
    CString csCL(commandLine);

    // if (-noDDE) then g_bHookDDE = FALSE;
    g_bHookDDE = csCL.CompareNoCase(L"-noDDE") != 0;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {

        // This forces the allocation of the array:
        if (FindFileInfoVector::InitializeHandleVector()) {
            ParseCommandLine(COMMAND_LINE);
        }
        else {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindClose)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    if (g_bHookDDE)
    {
        APIHOOK_ENTRY(USER32.DLL, DdeClientTransaction)
    }

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulategetdevicecaps.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateGetDeviceCaps.cpp

 Abstract:

    Fix known incompatibilities in GetDeviceCaps.     

    Currently we know of:

        1. NUMRESERVED always returns 20 on NT, but on win9x returns 0 in non-
           palettized modes. This was considered too great a regression risk to
           change the behavior of NT.

 Notes:

    This is a general purpose shim.

    (t-adams) MSDN states that along with NUMRESERVED, both SIZEPALETTE and 
    COLORRES are valid only if the display is in paletted mode.  I've 
    experimentally determined that SIZEPALETTE always returns 0 in non-paletted 
    modes, and that COLORRES seems to follow BITSPIXEL.  These behaviors don't 
    seem like they will present any problems since SIZEPALETTE * COLORRES will 
    be 0.

 History:
        
    02/17/2000 linstev  Created
    09/13/2000 t-adams  Added to Notes

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetDeviceCaps)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDeviceCaps)
APIHOOK_ENUM_END

/*++

 Check for known problems.

--*/

int 
APIHOOK(GetDeviceCaps)(
    HDC hdc,     
    int nIndex   
    )
{
    int iRet = ORIGINAL_API(GetDeviceCaps)(hdc, nIndex);

    switch (nIndex) 
    {
    case NUMRESERVED:
        if (ORIGINAL_API(GetDeviceCaps)(hdc, BITSPIXEL) > 8) {
            iRet = 0;
        }
    }

    return iRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetDeviceCaps)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulategetcommandline.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    EmulateGetCommandLine.cpp

 Abstract:

    This app uses GetCommandLine() to figure out what the drive letter of the 
    CD-ROM is. Unfortunately the behaviour of this API is different from Win9x 
    to NT:

    Original command line:                          
        E:\Final Doom\Doom95.exe -dm -cdrom

    NT's GetCommandLine() returns:              
        Doom95.exe -dm -cdrom

    Win9x's GetCommandLine() returns:       
        E:\FINALD~1\DOOM95.EXE -dm -cdrom

    This app returns short pathnames for GetCommandLine and GetModuleFileName.

 Notes:

    This is a general purpose shim.

 Created:

    01/03/2000  markder     Created
    09/26/2000  mnikkel     GetModuleFileName added
    11/10/2000  robkenny    Fixed PREFIX bugs, removed W routines.
    11/21/2000  prashkud    Fixed the GetCommandLineA hook bug when the CommandLine
                            had the executable name/path with spaces. Used 
                            AppAndCommandLine functions.
    02/27/2001  robkenny    Converted to use CString
    05/02/2001  pierreys    If buffer is too small, GetModuleFileNameA puts \0 at end of it like 9X.


--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetCommandLine)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
APIHOOK_ENUM_END


char     * g_lpszCommandLine = NULL;

/*++

 This stub function appends the commandline returned from GetCommandLine() to a 
 pre-determined path to emulate Win9x behavior.

--*/

LPSTR 
APIHOOK(GetCommandLineA)(
    void
    )
{
    // Been here, done that
    if (g_lpszCommandLine)
    {
        return g_lpszCommandLine;
    }

    LPSTR lpszOrig = ORIGINAL_API(GetCommandLineA)();
    
    // Seperate the app name and command line
    AppAndCommandLine AppCmdLine(NULL, lpszOrig);

    CSTRING_TRY
    { 
        // retrieve the original command line
        CString csAppName(AppCmdLine.GetApplicationName());

        if (csAppName.Find(L' ') == -1)
        {
            // If no spaces in app name, return the original command line.
            g_lpszCommandLine = lpszOrig;
        }
        else
        {
            // Spaces found so return short app path name
            // and rest of original command line
            csAppName.GetShortPathName();
            csAppName += L" ";
            csAppName += AppCmdLine.GetCommandlineNoAppName();
            g_lpszCommandLine = csAppName.ReleaseAnsi();

            LOGN( eDbgLevelError,
                "[GetCommandLineA] Changed Command Line from <%s> to <%s>.",
                lpszOrig, g_lpszCommandLine);
        }
    }
    CSTRING_CATCH
    {
        g_lpszCommandLine = lpszOrig;
    }

    return g_lpszCommandLine;
}


DWORD 
APIHOOK(GetModuleFileNameA)(
    HMODULE hModule,      // handle to module
    LPSTR   lpFilename,   // file name of module
    DWORD   nSize         // size of buffer
    )
{    

    CSTRING_TRY
    {
        CString csExeFileName;           
        DWORD len;

        len = csExeFileName.GetModuleFileNameW(hModule);         
        CString csLongFileName(csExeFileName);

        if (csExeFileName.Find(L' ') > -1)
        {            
            // Spaces found so return short app path name
            // The return value 
            len = csExeFileName.GetShortPathNameW();                                

            LOGN(
                eDbgLevelError,
                "[GetModuleFileNameA] Changed <%s> to <%s>.",
                 csLongFileName.GetAnsi(), csExeFileName.GetAnsi());
            
       }        
        
        //
        // From 9X's PELDR.C. If the buffer has no room for the '\0', 9X stuff the 0 at the
        // last byte.
        //
        if (nSize) {
            //        len = pmte->iFileNameLen;
            if (len >= nSize) {
                len = nSize - 1;
                LOGN(eDbgLevelError,
                     "[GetModuleFileNameA] Will shorten <%s> to %d characters.",
                     csLongFileName.GetAnsi(), len);
            }

            RtlCopyMemory(lpFilename, csExeFileName.GetAnsi() /* pmte->cfhid.lpFilename */, len); 
            lpFilename[len] = 0;
        }

        
        // Returned the double buffered name len.
        return len;
    }
    CSTRING_CATCH
    {
         // If error return original api.
        return ORIGINAL_API(GetModuleFileNameA)(
                            hModule,
                            lpFilename,
                            nSize);

    } 
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetModuleFileNameA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulategetdiskfreespace.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:
    
    EmulateGetDiskFreeSpace.cpp

 Abstract:

    This shim APIHooks GetDiskFreeSpace and determines the true free space on 
    FAT32/NTFS systems. If it is larger than 2GB, the stub will return 2GB as 
    the available free space. If it is smaller than 2GB, it will return the 
    actual free space.

 History:

    10-Nov-99 v-johnwh  Created
    04-Oct-00 linstev   Sanitized for layer
    02/20/2002 mnikkel  Removed unused variables

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetDiskFreeSpace)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA)
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceW)
APIHOOK_ENUM_END

#define WIN9X_TRUNCSIZE 2147483648   // 2 GB


// Has this module called DPF yet, prevents millions of DPF calls
BOOL g_bDPF = FALSE;

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
/*++

 This stub function calls GetDiskFreeSpaceEx to determine the true free space 
 on FAT32/NTFS systems. If it is larger than 2GB, the stub will return 2GB as 
 the available free space. If it is smaller than 2GB, it will return the actual
 free space.

--*/
{
    LONG            lRet;
    ULARGE_INTEGER  liFreeBytesAvailableToCaller;
    ULARGE_INTEGER  liTotalNumberOfBytes;
    ULARGE_INTEGER  liTotalNumberOfFreeBytes;
    DWORD           dwOldSectorsPerClusters;
    DWORD           dwOldBytesPerSector;
        
    //
    // Call the original API
    //
    lRet = ORIGINAL_API(GetDiskFreeSpaceA)(
                    lpRootPathName, 
                    lpSectorsPerCluster, 
                    lpBytesPerSector, 
                    lpNumberOfFreeClusters, 
                    lpTotalNumberOfClusters);

    //
    // Find out how big the drive is.
    //
    if (GetDiskFreeSpaceExA(lpRootPathName,
                            &liFreeBytesAvailableToCaller,
                            &liTotalNumberOfBytes,
                            &liTotalNumberOfFreeBytes) == FALSE) {        
        return lRet;
    }

    if ((liFreeBytesAvailableToCaller.LowPart > (DWORD) WIN9X_TRUNCSIZE) ||
        (liFreeBytesAvailableToCaller.HighPart > 0)) {
        //
        // Drive bigger than 2GB. Give them the 2gb limit from Win9x
        //
        *lpSectorsPerCluster     = 0x00000040;
        *lpBytesPerSector        = 0x00000200;
        *lpNumberOfFreeClusters  = 0x0000FFF6;
        *lpTotalNumberOfClusters = 0x0000FFF6;

        lRet = TRUE;
    } else {
        //
        // For drives less than 2gb, convert the disk geometry so it looks like Win9x.
        //
        dwOldSectorsPerClusters = *lpSectorsPerCluster;
        dwOldBytesPerSector     = *lpBytesPerSector;

        *lpSectorsPerCluster = 0x00000040;
        *lpBytesPerSector    = 0x00000200;

        //
        // Calculate the free and used cluster values now.
        //
        *lpNumberOfFreeClusters = (*lpNumberOfFreeClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
        
        *lpTotalNumberOfClusters = (*lpTotalNumberOfClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
    }

    if (!g_bDPF)
    {
        g_bDPF = TRUE;

        LOGN(
            eDbgLevelInfo,
            "[GetDiskFreeSpaceA] Called. Returning <=2GB free space");
    }

    return lRet;
}

BOOL 
APIHOOK(GetDiskFreeSpaceW)(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
/*++

 This stub function calls GetDiskFreeSpaceEx to determine the true free space 
 on FAT32/NTFS systems. If it is larger than 2GB, the stub will return 2GB as 
 the available free space. If it is smaller than 2GB, it will return the actual
 free space.

--*/
{
    LONG            lRet;
    ULARGE_INTEGER  liFreeBytesAvailableToCaller;
    ULARGE_INTEGER  liTotalNumberOfBytes;
    ULARGE_INTEGER  liTotalNumberOfFreeBytes;
    DWORD           dwOldSectorsPerClusters;
    DWORD           dwOldBytesPerSector;
        
    //
    // Call the original API
    //
    lRet = ORIGINAL_API(GetDiskFreeSpaceW)(
                    lpRootPathName, 
                    lpSectorsPerCluster, 
                    lpBytesPerSector, 
                    lpNumberOfFreeClusters, 
                    lpTotalNumberOfClusters);

    //
    // Find out how big the drive is.
    //
    if (GetDiskFreeSpaceExW(lpRootPathName,
                            &liFreeBytesAvailableToCaller,
                            &liTotalNumberOfBytes,
                            &liTotalNumberOfFreeBytes) == FALSE) {        
        return lRet;
    }

    if ((liFreeBytesAvailableToCaller.LowPart > (DWORD) WIN9X_TRUNCSIZE) ||
        (liFreeBytesAvailableToCaller.HighPart > 0)) {
        //
        // Drive bigger than 2GB. Give them the 2gb limit from Win9x
        //
        *lpSectorsPerCluster     = 0x00000040;
        *lpBytesPerSector        = 0x00000200;
        *lpNumberOfFreeClusters  = 0x0000FFF6;
        *lpTotalNumberOfClusters = 0x0000FFF6;

        lRet = TRUE;
    } else {
        //
        // For drives less than 2gb, convert the disk geometry so it looks like Win9x.
        //
        dwOldSectorsPerClusters = *lpSectorsPerCluster;
        dwOldBytesPerSector     = *lpBytesPerSector;

        *lpSectorsPerCluster = 0x00000040;
        *lpBytesPerSector    = 0x00000200;

        //
        // Calculate the free and used cluster values now.
        //
        *lpNumberOfFreeClusters = (*lpNumberOfFreeClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
        
        *lpTotalNumberOfClusters = (*lpTotalNumberOfClusters * 
            dwOldSectorsPerClusters * 
            dwOldBytesPerSector) / (0x00000040 * 0x00000200);
    }

    if (!g_bDPF)
    {
        g_bDPF = TRUE;

        LOGN(
            eDbgLevelInfo,
            "[GetDiskFreeSpaceW] Called. Returning <=2GB free space");
    }

    return lRet;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateheap.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateHeap.cpp

 Abstract:
     
    This SHIM is for the layer and it emulates the Win9x heap manager. In fact, 
    much of the code is adapted from the Win9x sources .\heap.c and .\lmem.c.
    
    This SHIM hooks all the heap allocation/deallocation functions including 
    the local/global functions.
     
 Notes:

    This is a general purpose shim.

 History:
           
    11/16/2000 prashkud & linstev Created 
   
--*/

#include "precomp.h"
 
IMPLEMENT_SHIM_BEGIN(EmulateHeap)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(HeapCreate)
    APIHOOK_ENUM_ENTRY(HeapDestroy)
    APIHOOK_ENUM_ENTRY(HeapValidate)
    APIHOOK_ENUM_ENTRY(HeapCompact)
    APIHOOK_ENUM_ENTRY(HeapWalk)
    APIHOOK_ENUM_ENTRY(HeapLock)
    APIHOOK_ENUM_ENTRY(HeapUnlock)
    APIHOOK_ENUM_ENTRY(GetProcessHeap)

    APIHOOK_ENUM_ENTRY(LocalAlloc)
    APIHOOK_ENUM_ENTRY(LocalFree)
    APIHOOK_ENUM_ENTRY(LocalReAlloc)
    APIHOOK_ENUM_ENTRY(LocalLock)
    APIHOOK_ENUM_ENTRY(LocalUnlock)
    APIHOOK_ENUM_ENTRY(LocalHandle)
    APIHOOK_ENUM_ENTRY(LocalSize)
    APIHOOK_ENUM_ENTRY(LocalFlags)

    APIHOOK_ENUM_ENTRY(GlobalAlloc)
    APIHOOK_ENUM_ENTRY(GlobalFree)
    APIHOOK_ENUM_ENTRY(GlobalReAlloc)
    APIHOOK_ENUM_ENTRY(GlobalLock)
    APIHOOK_ENUM_ENTRY(GlobalUnlock)
    APIHOOK_ENUM_ENTRY(GlobalHandle)
    APIHOOK_ENUM_ENTRY(GlobalSize)
    APIHOOK_ENUM_ENTRY(GlobalFlags)

    APIHOOK_ENUM_ENTRY(RtlAllocateHeap)
    APIHOOK_ENUM_ENTRY(RtlReAllocateHeap)
    APIHOOK_ENUM_ENTRY(RtlFreeHeap)
    APIHOOK_ENUM_ENTRY(RtlSizeHeap)
APIHOOK_ENUM_END

extern "C" {
BOOL   _HeapInit();
HANDLE _HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
BOOL   _HeapDestroy(HANDLE hHeap);
LPVOID _HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
LPVOID _HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
BOOL   _HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
DWORD  _HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
HLOCAL APIENTRY _LocalAlloc(UINT dwFlags, UINT dwBytes);
HLOCAL APIENTRY _LocalFree(HLOCAL hMem);
LPVOID _LocalReAlloc(LPVOID lpMem, SIZE_T dwBytes, UINT uFlags);
LPVOID _LocalLock(HLOCAL hMem);
BOOL   _LocalUnlock(HLOCAL hMem);
HANDLE _LocalHandle(LPCVOID hMem);
UINT   _LocalSize(HLOCAL hMem);
UINT   _LocalFlags(HLOCAL hMem);
HANDLE _GetProcessHeap(void);
BOOL   _IsOurHeap(HANDLE hHeap);
BOOL   _IsOurLocalHeap(HANDLE hMem);
BOOL   _IsOnOurHeap(LPCVOID lpMem);
}

/*++

  Helper functions so as not to bloat the stubs.

--*/

BOOL UseOurHeap(HANDLE hHeap, LPCVOID lpMem)
{
    return (_IsOurHeap(hHeap) || ((hHeap == RtlProcessHeap()) && _IsOnOurHeap(lpMem)));
}

BOOL ValidateNTHeap(HANDLE hHeap, LPCVOID lpMem)
{
    BOOL bRet = FALSE;
    __try
    {
        bRet = ORIGINAL_API(HeapValidate)(hHeap, 0, lpMem);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        LOGN( eDbgLevelError, "[ValidateHeap] %08lx:%08lx is invalid", hHeap, lpMem);
    }

    return bRet;
}

/*++

  Stub APIs.

--*/

LPVOID 
APIHOOK(RtlAllocateHeap)(
    HANDLE hHeap,
    DWORD dwFlags,     
    SIZE_T dwBytes
    )
{
    if (_IsOurHeap(hHeap))
    {
        return _HeapAlloc(hHeap, dwFlags, dwBytes);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlAllocateHeap");
        return ORIGINAL_API(RtlAllocateHeap)(hHeap, dwFlags, dwBytes);
    }
}

HANDLE 
APIHOOK(HeapCreate)(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    )
{
    return _HeapCreate(flOptions, dwInitialSize, dwMaximumSize);
}

LPVOID 
APIHOOK(RtlReAllocateHeap)(
    HANDLE hHeap, 
    DWORD dwFlags,     
    LPVOID lpMem,
    SIZE_T dwBytes
    )
{
    LPVOID uRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        uRet = _HeapReAlloc(hHeap, dwFlags, lpMem, dwBytes);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlReAllocateHeap");

        if (ValidateNTHeap(hHeap, lpMem))
        {
            uRet = ORIGINAL_API(RtlReAllocateHeap)(hHeap, dwFlags, lpMem, dwBytes);
        }
    }
    return uRet;
}

BOOL 
APIHOOK(RtlFreeHeap)(
    HANDLE hHeap,
    DWORD dwFlags,    
    LPVOID lpMem
    )
{
    BOOL bRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        bRet = _HeapFree(hHeap, dwFlags, lpMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlFreeHeap");

        if (ValidateNTHeap(hHeap, lpMem))
        {
            bRet = ORIGINAL_API(RtlFreeHeap)(hHeap, dwFlags, lpMem);
        }
    }
    return bRet;
}

HANDLE 
APIHOOK(GetProcessHeap)(VOID)
{
    return _GetProcessHeap();
}
 
BOOL 
APIHOOK(HeapDestroy)(HANDLE hHeap)
{
    if (_IsOurHeap(hHeap))
    {
        return _HeapDestroy(hHeap);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapDestroy");
        return ORIGINAL_API(HeapDestroy)(hHeap);
    }
}

DWORD
APIHOOK(RtlSizeHeap)(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    )
{  
    BOOL bRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        bRet = _HeapSize(hHeap, dwFlags, lpMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: RtlSizeHeap");

        if (ValidateNTHeap(hHeap, lpMem))
        {
            bRet = ORIGINAL_API(RtlSizeHeap)(hHeap, dwFlags, lpMem);
        }        
    }

    return bRet;
}

BOOL
APIHOOK(HeapValidate)(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    )
{
    BOOL bRet = FALSE;

    if (UseOurHeap(hHeap, lpMem))
    {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        bRet = -1;
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapValidate");

        __try
        {
            bRet = ORIGINAL_API(HeapValidate)(hHeap, dwFlags, lpMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError, "[HeapValidate] %08lx:%08lx is invalid", hHeap, lpMem);
        }
    }
   return bRet;
}

HLOCAL 
APIHOOK(LocalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    return _LocalAlloc(uFlags, uBytes);
}

HLOCAL
APIHOOK(LocalFree)(
    HLOCAL hMem
    )
{
    HLOCAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
        hRet = _LocalFree(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalFree %08lx", hMem);
        __try
        {
            hRet = ORIGINAL_API(LocalFree)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalFree] Exception: Invalid Pointer %08lx", hMem);
        }       
    }

    return hRet;
}

HLOCAL 
APIHOOK(LocalReAlloc)(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
{
    HLOCAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
         hRet = _LocalReAlloc(hMem, uBytes, uFlags);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalReAlloc %08lx", hMem);
        
        __try
        {
            hRet = ORIGINAL_API(LocalReAlloc)(hMem, uBytes, uFlags);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalReAlloc] Exception: Invalid Pointer %08lx", hMem);
        }              
    }

    return hRet;
}

LPVOID
APIHOOK(LocalLock)(
    HLOCAL hMem
    )
{
    LPVOID pRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
         pRet = _LocalLock(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalLock %08lx", hMem);

        __try
        {
            pRet = ORIGINAL_API(LocalLock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalLock] Exception: Invalid Pointer %08lx", hMem);
        }                      
    }

    return pRet;
}

BOOL
APIHOOK(LocalUnlock)(
    HLOCAL hMem
    )
{
    BOOL bRet = FALSE;

    if (_IsOurLocalHeap(hMem))
    {
         bRet = _LocalUnlock(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalUnlock %08lx", hMem);

        __try
        {
            bRet = ORIGINAL_API(LocalUnlock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalUnLock] Exception: Invalid Pointer %08lx", hMem);
        }                          
    }

    return bRet;
}

HANDLE
APIHOOK(LocalHandle)(
    LPCVOID hMem
    )
{
    HANDLE hRet = NULL;

    if (_IsOurLocalHeap((HANDLE)hMem))
    {
         hRet = _LocalHandle(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalHandle %08lx", hMem);
        __try
        {
            hRet = ORIGINAL_API(LocalHandle)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalHandle] Exception: Invalid Pointer %08lx", hMem);
        }                                  
    }

    return hRet;
}

UINT
APIHOOK(LocalSize)(
    HLOCAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
         uRet = _LocalSize(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalSize %08lx", hMem);
        __try
        {
            uRet = ORIGINAL_API(LocalSize)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalSize] Exception: Invalid Pointer %08lx", hMem);
        }                   
    }

    return uRet;
}

UINT
APIHOOK(LocalFlags)(
    HLOCAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
        uRet = _LocalFlags(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: LocalFlags %08lx", hMem);

        __try
        {
            uRet = ORIGINAL_API(LocalFlags)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[LocalFlags] Exception: Invalid Pointer %08lx", hMem);
        }                  
    }

    return uRet;
}

HGLOBAL 
APIHOOK(GlobalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    uFlags = (((uFlags & GMEM_ZEROINIT) ? LMEM_ZEROINIT : 0 ) |
              ((uFlags & GMEM_MOVEABLE) ? LMEM_MOVEABLE : 0 ) |
              ((uFlags & GMEM_FIXED) ? LMEM_FIXED : 0 ));

    return _LocalAlloc(uFlags, uBytes);
}

HGLOBAL
APIHOOK(GlobalFree)(
    HGLOBAL hMem
    )
{
    HGLOBAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
         hRet = _LocalFree(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalFree %08lx", hMem);

        __try
        {
            hRet = ORIGINAL_API(GlobalFree)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalFree] Exception: Invalid Pointer %08lx", hMem);
        }               
    }

    return hRet;
}

HGLOBAL 
APIHOOK(GlobalReAlloc)(
    HGLOBAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
{
    UINT uLocalFlags = 
        (((uFlags & GMEM_ZEROINIT) ? LMEM_ZEROINIT : 0 ) |
        ((uFlags & GMEM_MOVEABLE) ? LMEM_MOVEABLE : 0 ) |
        ((uFlags & GMEM_FIXED) ? LMEM_FIXED : 0 ));

    HLOCAL hRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
        hRet = _LocalReAlloc(hMem, uBytes, uLocalFlags);
    }    
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalReAlloc %08lx", hMem);

        __try
        {
            hRet = ORIGINAL_API(GlobalReAlloc)(hMem, uBytes, uFlags);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalReAlloc] Exception: Invalid Pointer %08lx", hMem);
        }                       
    }

    return hRet;
}

LPVOID
APIHOOK(GlobalLock)(
    HGLOBAL hMem
    )
{
    LPVOID pRet = NULL;

    if (_IsOurLocalHeap(hMem))
    {
        pRet = _LocalLock(hMem);
    }
    else    
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalLock %08lx", hMem);
        
        __try
        {
            pRet = ORIGINAL_API(GlobalLock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalLock] Exception: Invalid Pointer %08lx", hMem);
        }                          
    }

    return pRet;
}

BOOL
APIHOOK(GlobalUnlock)(
    HGLOBAL hMem
    )
{
    BOOL bRet = FALSE;

    if (_IsOurLocalHeap(hMem))
    {
        bRet = _LocalUnlock(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalUnlock %08lx", hMem);

        __try
        {
            bRet = ORIGINAL_API(GlobalUnlock)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalUnLock] Exception: Invalid Pointer %08lx", hMem);
        }            
    }

    return bRet;
}

HANDLE
APIHOOK(GlobalHandle)(
    LPCVOID hMem
    )
{
    HANDLE hRet = NULL;

    if (_IsOurLocalHeap((HANDLE)hMem))
    {
         hRet = _LocalHandle(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalHandle %08lx", hMem);
        __try
        {
            hRet = ORIGINAL_API(GlobalHandle)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalHandle] Exception: Invalid Pointer %08lx for Heap",
                hMem);
        }                    
    }

    return hRet;
}

UINT
APIHOOK(GlobalSize)(
    HGLOBAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
        uRet = _LocalSize(hMem);
    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalSize %08lx", hMem);
        __try
        {
            uRet = ORIGINAL_API(GlobalSize)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalSize] Exception: Invalid Pointer %08lx for Heap",
                hMem);
        }            
    }

    return uRet;
}

UINT
APIHOOK(GlobalFlags)(
    HGLOBAL hMem
    )
{
    UINT uRet = 0;

    if (_IsOurLocalHeap(hMem))
    {
        uRet = _LocalFlags(hMem);
        // Convert the flags
        UINT uNewRet = uRet;

        uRet = 0;

        if (uNewRet & LMEM_DISCARDABLE)
        {
            uRet |= GMEM_DISCARDABLE;
        }

        if (uNewRet & LMEM_DISCARDED)
        {
            uRet |= GMEM_DISCARDED;
        }

    }
    else
    {
        DPFN( eDbgLevelInfo, "NTHEAP: GlobalFlags %08lx", hMem);
        __try
        {
            uRet = ORIGINAL_API(GlobalFlags)(hMem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            LOGN( eDbgLevelError,
                "[GlobalFlags] Exception: Invalid Pointer %08lx for Heap",
                hMem);
        }           
    }

    return uRet;
}

UINT
APIHOOK(HeapCompact)(
    HANDLE hHeap,
    DWORD dwFlags
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapCompact");
        return ORIGINAL_API(HeapCompact)(hHeap, dwFlags);
   }
}

BOOL
APIHOOK(HeapWalk)(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY pEntry
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapWalk");
        return ORIGINAL_API(HeapWalk)(hHeap, pEntry);
   }
}

BOOL
APIHOOK(HeapLock)(
    HANDLE hHeap
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapLock");
        return ORIGINAL_API(HeapLock)(hHeap);
   }
}

BOOL
APIHOOK(HeapUnlock)(
    HANDLE hHeap
    )
{
   if (_IsOurHeap(hHeap))
   {
        // Win9x return values
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return 0;
   }
   else
   {
        DPFN( eDbgLevelInfo, "NTHEAP: HeapUnlock");
        return ORIGINAL_API(HeapUnlock)(hHeap);
   }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    BOOL bRet = TRUE;
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        bRet = _HeapInit();
        if (bRet) 
        {
            LOGN(eDbgLevelInfo, "[NotifyFn] Win9x heap manager initialized");
        }
        else
        {
            LOGN(eDbgLevelError, "[NotifyFn] Win9x heap manager initialization failed!");
        }
    }

    return bRet;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, HeapCreate)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapDestroy)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapValidate)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapCompact)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapWalk)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapLock)
    APIHOOK_ENTRY(KERNEL32.DLL, HeapUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcessHeap)

    APIHOOK_ENTRY(KERNEL32.DLL, LocalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalFree)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalLock)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalSize)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalFlags)

    APIHOOK_ENTRY(KERNEL32.DLL, GlobalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalFree)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalLock)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalSize)
    APIHOOK_ENTRY(KERNEL32.DLL, GlobalFlags)

    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlReAllocateHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlFreeHeap)
    APIHOOK_ENTRY(NTDLL.DLL, RtlSizeHeap)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateheap_heap.c ===
/***	HEAP.C
 *
 *      (C) Copyright Microsoft Corp., 1988-1994
 *
 *      Heap management
 *
 *	If you are having trouble getting errors from this code, you might
 *	want to try setting one of the following variables to non-zero:
 *
 *		mmfErrorStop - enables stopping whenever there is an
 *			error returned from a memory manager function
 *
 *		hpfWalk - enables some verification of the entire heap when
 *			coming into heap functions.  Enabling heap walking
 *			can dramatically slow down heap functions
 *			but system-wide performance doesn't change too much.
 *
 *		hpfParanoid - enables even more checking during heap walking
 *			(hpfWalk must also be set) and enables heap walking
 *			coming in and out of every heap call.
 *
 *		hpfTrashStop - enables stopping in the debugger whenever
 *			we detect a trashed heap block during hpfWalk
 *			and it attempts to print the trashed address
 *
 *  Origin: Chicago
 *
 *  Change history:
 *
 *  Date       Who        Description
 *  ---------  ---------  -------------------------------------------------
 *  ?/91       BrianSm	  Created
 *  3/94       BrianSm	  Added heaps that can grow beyond initial max size
 *  6/94       BrianSm	  Decommit pages within free heap blocks
 */
#ifdef WIN32
#include <EmulateHeap_kernel32.h>
#endif

#pragma hdrstop("kernel32.pch")

#ifndef WIN32

#include <basedef.h>
#include <winerror.h>
#include <vmmsys.h>
#include <mmlocal.h>
#include <sched.h>
#include <thrdsys.h>
#include <schedsys.h>
#include <schedc.h>
#include <heap.h>

#define pthCur pthcbCur
#define hpGetTID()	(pthCur->thcb_ThreadId)
char INTERNAL hpfWalk = 1;		/* enable some heap walking */

#ifdef HPDEBUG
#define dprintf(x) dprintf##x
#define DebugStop()	mmFatalError(0)
#else
#define dprintf(x)
#endif

#define HeapFree(hheap, flags, lpMem)	HPFree(hheap, lpMem)
#define HeapSize(hheap, flags, lpMem)	HPSize(hheap, lpMem)
#define hpTakeSem(hheap, pblock, flags) hpTakeSem2(hheap, pblock)
#define hpClearSem(hheap, flags) hpClearSem2(hheap)

#else	/* WIN32 */

#define pthCur (*pptdbCur)
#define hpGetTID() (pthCur ? (((struct tcb_s *)(pthCur->R0ThreadHandle))->TCB_ThreadId) : 0);
char	mmfErrorStop = 1;		/* enable stopping for all errors */
char    INTERNAL hpfWalk = 0;		/* disable heap walking */

#ifdef HPMEASURE
BOOL PRIVATE hpMeasureItem(HHEAP hheap, unsigned uItem);
#endif

#endif /* WIN32 */

#ifdef HPDEBUG
#define hpTrash(s)	    dprintf((s));dprintf((("\nheap handle=%x\n", hheap)));if (hpfTrashStop) DebugStop()
char INTERNAL hpfParanoid = 0;		/* disable very strict walking */
char INTERNAL hpfTrashStop = 1;		/* enable stopping for trashed heap */
char INTERNAL hpWalkCount = 0;		/* keep count of times hpWalk called*/
#endif


/***LD	hpFreeSizes - the block sizes for the different free list heads
 */
unsigned long hpFreeSizes[hpFREELISTHEADS] = {32, 128, 512, (ULONG)-1};

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_VMCREATE_CODE_SEG
#endif

#ifdef DEBUG
/***EP	HeapSetFlags - set heap error flags
 *
 *	ENTRY:	dwFlags - flags to change
 *              dwFlagValues - new flag values
 *
 *      EXIT:   old values of the flags
 *              (on RETAIL, this is a stub which returns -1)
 */
#define HSF_MMFERRORSTOP    0x00000001
#define HSF_HPFPARANOID     0x00000002
#define HSF_VALIDMASK       0x00000003

DWORD APIENTRY
HeapSetFlags( DWORD  dwFlags, DWORD dwFlagValues)
{
    DWORD       dwOldFlagValues;

    dwOldFlagValues = (mmfErrorStop ? HSF_MMFERRORSTOP : 0) |
                      (hpfParanoid  ? HSF_HPFPARANOID  : 0);

    if( dwFlags & ~HSF_VALIDMASK) {
        OutputDebugString( "HeapSetFlags: invalid flags, ignored\n");
        return (DWORD)-1;     // error
    }

    if( dwFlags & HSF_MMFERRORSTOP) {
        if( dwFlagValues & HSF_MMFERRORSTOP)
            mmfErrorStop = 1;
        else
            mmfErrorStop = 0;
    }

    if( dwFlags & HSF_HPFPARANOID) {
        if( dwFlagValues & HSF_HPFPARANOID) {
	    hpfTrashStop = 1;
	    hpfWalk = 1;
	    hpfParanoid = 1;
        } else {
            hpfParanoid = 0;
	}
    }

    return dwOldFlagValues;
}
#endif


/***EP	HPInit - initialize a memory block as a heap
 *
 *	ENTRY:	hheap - heap handle for heap (same as pmem unless HP_INITSEGMENT)
 *		pmem - pointer to chunk of memory (must be page aligned)
 *		cbreserve - number of bytes reserved in block (must be PAGESIZE
 *			    multiple)
 *		flags - HP_NOSERIALIZE: don't serialize heap operations
 *			(if not, caller MUST serialize)
 *			HP_EXCEPT: generate exceptions instead of errors
 *			HP_GROWABLE: heap can grow infinitely beyond cbreserve
 *			HP_LOCKED: commit pages as fixed to heap
 *			HP_INITSEGMENT: initialize the block as an growable
 *					heap segment
 *			HP_GROWUP: waste last page in heap so heap allocs
 *				   will grow monotonically upwards from base
 *	EXIT:	handle to new heap or 0 if error.
 */
HHEAP INTERNAL
HPInit(struct heapinfo_s *hheap,
       struct heapinfo_s *pmem,
       unsigned long cbreserve,
       unsigned long flags)
{
    struct freelist_s *pfreelist;
    struct freelist_s *pfreelistend;
    unsigned *psizes;
    struct busyheap_s *pfakebusy;
    unsigned cbheader, cbmainfree;

    mmAssert(((unsigned)pmem & PAGEMASK) == 0 && cbreserve != 0 &&
	     (cbreserve & PAGEMASK) == 0, "HPInit: invalid parameter\n");


    /*
     *	Commit enough space at the beginning of the heap to hold a
     *	heapinfo_s structure and a minimal free list.
     */
    if (hpCommit((unsigned)pmem / PAGESIZE,
		 (sizeof(struct heapinfo_s)+sizeof(struct freeheap_s)+PAGEMASK)
								    / PAGESIZE,
		 flags) == 0) {
	goto error;
    }

    /*
     *	This next block of initialization stuff we only have to do if
     *	we are creating a brand new heap, not just a heap segment.
     */
    if ((flags & HP_INITSEGMENT) == 0) {
	cbheader = sizeof(struct heapinfo_s);

	/*
	 *  Fill in the heapinfo_s structure (per-heap information).
	 */
#ifdef WIN32
	pmem->hi_procnext = 0;
#endif
	pmem->hi_psegnext = 0;
	pmem->hi_signature = HI_SIGNATURE;
	pmem->hi_flags = (unsigned char)flags;

#ifdef HPDEBUG
	pmem->hi_cbreserve = cbreserve; /* this is also done below, here for sum */
	pmem->hi_sum = hpSum(pmem, HI_CDWSUM);
	pmem->hi_eip = hpGetAllocator();
	pmem->hi_tid = hpGetTID();
	pmem->hi_thread = 0;
#endif

	/*
	 *  If the caller requested that we serialize access to the heap,
	 *  create a critical section to do that.
	 */
	if ((flags & HP_NOSERIALIZE) == 0) {
	    hpInitializeCriticalSection(pmem);
	}

	/*
	 *  Initialize the free list heads.
	 *  In the future we might want to have the user pass in the
	 *  size of the free lists he would like, but for now just copy
	 *  them from the static list hpFreeSizes.
	 */
	pfreelist = pmem->hi_freelist;
	pfreelistend = pfreelist + hpFREELISTHEADS;
	psizes = hpFreeSizes;
	for (; pfreelist < pfreelistend; ++pfreelist, ++psizes) {
	    pfreelist->fl_cbmax = *psizes;
	    hpSetFreeSize(&pfreelist->fl_header, 0);
	    pfreelist->fl_header.fh_flink = &(pfreelist+1)->fl_header;
	    pfreelist->fl_header.fh_blink = &(pfreelist-1)->fl_header;
#ifdef HPDEBUG
	    pfreelist->fl_header.fh_signature = FH_SIGNATURE;
	    pfreelist->fl_header.fh_sum = hpSum(&pfreelist->fl_header, FH_CDWSUM);
#endif
	}

	/*
	 *  Make the list circular by fusing the start and beginning
	 */
	pmem->hi_freelist[0].fl_header.fh_blink =
		    &(pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header);
	pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header.fh_flink =
		    &(pmem->hi_freelist[0].fl_header);
#ifdef HPDEBUG
	pmem->hi_freelist[0].fl_header.fh_sum =
	    hpSum(&(pmem->hi_freelist[0].fl_header), FH_CDWSUM);
	pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header.fh_sum =
	    hpSum(&(pmem->hi_freelist[hpFREELISTHEADS - 1].fl_header), FH_CDWSUM);
#endif
    } else {
	cbheader = sizeof(struct heapseg_s);
    }
    pmem->hi_cbreserve = cbreserve;

    /*
     *	Put a tiny busy heap header at the very end of the heap
     *	so we can free the true last block and mark the following
     *	block as HP_PREVFREE without worrying about falling off the
     *	end of the heap.  Give him a size of 0 so we can also use
     *	him to terminate heap-walking functions.
     *	We also might need to commit a page to hold the thing.
     */
    pfakebusy = (struct busyheap_s *)((unsigned long)pmem + cbreserve) - 1;
    if (cbreserve > PAGESIZE) {
	if (hpCommit((unsigned)pfakebusy / PAGESIZE,
	    (sizeof(struct busyheap_s) + PAGEMASK) / PAGESIZE, flags) == 0) {
	    goto errordecommit;
	}
    }
    hpSetBusySize(pfakebusy, 0);
#ifdef HPDEBUG
    pfakebusy->bh_signature = BH_SIGNATURE;
    pfakebusy->bh_sum = hpSum(pfakebusy, BH_CDWSUM);
#endif


    /*
     *	Link the interior of the heap into the free list.
     *	If we create one big free block, the page at the end of the heap will
     *	be wasted because it will be committed (to hold the end sentinel) but
     *	it will won't be touched for allocations until every other page in the
     *	heap has been used.  To avoid this, we create two free blocks, one for
     *	main body of the heap and another block which has most of the last
     *	page in it.  We need to insert the last page first because hpFreeSub
     *	looks at the following block to see if we need to coalesce.
     *	The caller can force us to waste the last page by passing in HP_GROWUP.
     *	It is used by some ring 3 components who would waste tiled selectors
     *	if we had blocks being allocated from an outlying end page.
     */
    if ((flags & HP_GROWUP) == 0 && cbreserve > PAGESIZE) {
	cbmainfree = cbreserve - cbheader - PAGESIZE +	/* size of main block */
		     sizeof(struct freeheap_s *);

	/*
	 *  Put a little busy heap block at the front of the final page
	 *  to keep the final page from getting coalesced into the main free
	 *  block.
	 */
	pfakebusy = (struct busyheap_s *)((char *)pmem + cbmainfree + cbheader);
	hpSetBusySize(pfakebusy, sizeof(struct busyheap_s));
#ifdef HPDEBUG
	pfakebusy->bh_signature = BH_SIGNATURE;
	pfakebusy->bh_sum = hpSum(pfakebusy, BH_CDWSUM);
#endif

	/*
	 *  Free the rest of the last page (minus the various little bits
	 *  we have taken out)
	 */
	hpFreeSub(hheap, pfakebusy + 1,
		  PAGESIZE -			/* entire page, less... */
		  sizeof(struct freeheap_s *) - /*  back-pointer to prev free*/
		  sizeof(struct busyheap_s) -	/*  anti-coalescing busy block*/
		  sizeof(struct busyheap_s),	/*  end sentinel */
		  0);

    /*
     *	Otherwise, make the entirety of our heap between the end of the header
     *	end the end sentinel into a free block.
     */
    } else {
	cbmainfree = cbreserve - sizeof(struct busyheap_s) - cbheader;
    }

    /*
     *	Now put the main body of the heap onto the free list
     */
    hpFreeSub(hheap, (char *)pmem + cbheader, cbmainfree, 0);


#ifdef HPDEBUG
    /*
     *	Verify the heap is ok.	Note, a new heap segment will fail the test
     *	until we hook it up properly in HPAlloc, so skip the check for them.
     */
    if (hpfParanoid && hheap == pmem) {
	hpWalk(hheap);
    }
#endif

    /*
     *	Return a pointer to the start of the heap as the heap handle
     */
  exit:
    return(pmem);

  errordecommit:
    PageDecommit((unsigned)pmem / PAGESIZE,
		 (sizeof(struct heapinfo_s)+sizeof(struct freeheap_s)+PAGEMASK)
								    / PAGESIZE,
		 PC_STATIC);
  error:
    pmem = 0;
    goto exit;
}


#ifndef WIN32
/***EP	HPClone - make a duplicate of an existing heap
 *
 *	This routine is used to create a new heap that has heap blocks
 *	allocated and free in the same places as another heap.	However,
 *	the contents of the blocks will be zero-initialized, rather than
 *	the same as the other heap.
 *
 *	If this routine fails, it is the responsibility of the caller
 *	to free up any memory that might have been committed (as well as
 *	the original reserved object).
 *
 *	ENTRY:	hheap - handle to existing heap to duplicate
 *		pmem - pointer to new memory block to turn into duplicate heap
 *		       (the address must be reserved and not committed)
 *	EXIT:	handle to new heap if success, else 0 if failure
 */
HHEAP INTERNAL
HPClone(struct heapinfo_s *hheap, struct heapinfo_s *pmem)
{
    struct freeheap_s *ph;
    struct freeheap_s *phend;
#ifdef HPDEBUG
    struct freeheap_s *phnew;
#endif

    /*
     *	We need to take the heap semaphore for the old heap so no one
     *	changes its contents while we clone it (that could confuse the
     *	walking code).
     */
    if (hpTakeSem(hheap, 0, 0) == 0) {
	pmem = 0;
	goto exit;
    }

    /*
     *	First call HPInit on the new block to get it a header
     */
    if (HPInit(pmem, pmem, hheap->hi_cbreserve, (unsigned)hheap->hi_flags) == 0) {
	goto error;
    }

    /*
     *	Ring 0 heaps are layed out in the following general areas:
     *
     *	      1 heap header
     *	      2 mix of allocated and free heap blocks
     *	      3 giant free heap block (remains of initial free block)
     *	      4 a single minimum size busy heap block
     *	      5 mix of allocated and free heap blocks
     *	      6 end sentinel
     *
     *	The general method for cloning a heap is to walk the entire source
     *	heap and allocate blocks on the new heap corresponding to all
     *	the blocks on the source heap, busy or free.  Then go back through
     *	the source free list and free the corresponding blocks on the
     *	new heap.  You will then have two heaps with the same lay-out of
     *	free and busy blocks.  However, doing this will cause a huge overcommit
     *	spike when block (3) gets allocated and then freed.  To avoid this,
     *	when allocating the blocks we first allocate the blocks from area (5)
     *	then the blocks in (2) which will naturally leave us with a big
     *	free block at (3) like there should be without causing a spike.
     *	This scheme will only work if (3) is the last block on the free
     *	list, otherwise the free list will not be in the correct order when
     *	we are done.  "phend" will be pointed to block (3) if it is
     *	in the correct place for us to do our trick, otherwise we set it to (4).
     *	"ph" will start just past (4).
     */
    ph = (struct freeheap_s *)((char *)hheap + hheap->hi_cbreserve - PAGESIZE +
			       sizeof(struct freeheap_s *) +
			       sizeof(struct busyheap_s));
    phend = hheap->hi_freelist[0].fl_header.fh_blink;

    /*
     *	If the last block on the free list isn't just before (4) then
     *	reset our variables as per comment above.
     */
    if ((char *)phend + hpSize(phend)+sizeof(struct busyheap_s) != (char *)ph) {
	phend = (struct freeheap_s *)((char *)ph - sizeof(struct busyheap_s));
	mmAssert(hpIsBusySignatureValid((struct busyheap_s *)ph) &&
		 hpSize(ph) == sizeof(struct busyheap_s),
		 "HPClone: bad small busy block");
    }

    /*
     *	Now walk through the old heap and allocate corresponding blocks
     *	on the new heap.  First we allocate the blocks on the last page.
     */
    for (; hpSize(ph) != 0; (char *)ph += hpSize(ph)) {
	if (HPAlloc(pmem,hpSize(ph)-sizeof(struct busyheap_s),HP_ZEROINIT)==0){
	    mmAssert(0, "HPClone: alloc off last page failed"); /* already committed */
	}
    }

    /*
     *	Then allocate the blocks in the first part of heap, except maybe
     *	the big free block (3) if we are set up that way from above.
     */
    ph = (struct freeheap_s *)(hheap + 1);
    for (; ph != phend; (char *)ph += hpSize(ph)) {
	if (HPAlloc(pmem, hpSize(ph) - sizeof(struct busyheap_s),
		    HP_ZEROINIT) == 0) {
	    goto error;
	}
    }

    /*
     *	How go back through the heap and free up all the blocks that are
     *	free on the old heap.  We have to do this by walking the old
     *	heap's free list backwards, so the free blocks are in the same
     *	order on both heaps.
     */
    ph = hheap->hi_freelist[0].fl_header.fh_blink;
    for (; ph != &(hheap->hi_freelist[0].fl_header); ph = ph->fh_blink) {

	mmAssert(hpIsFreeSignatureValid(ph), "HPClone: bad block on free list");

	/*
	 *  Skip freeing any list heads and the "pfhbigfree" if we are
	 *  special casing him
	 */
	if (hpSize(ph) != 0 && ph != phend) {
	    if (HPFree(pmem, (char *)pmem + sizeof(struct busyheap_s) +
		       (unsigned long)ph - (unsigned long)hheap) == 0) {
		mmAssert(0, "HPClone: HPFree failed");
	    }
	}
    }

#ifdef HPDEBUG
    /*
     *	Now let's verify that they really came out the same
     */
    for (ph = (struct freeheap_s *)(hheap+1),
	 phnew = (struct freeheap_s *)(pmem + 1);
	 hpSize(ph) != 0;
	 (char *)phnew += hpSize(ph), (char *)ph += hpSize(ph)) {

	mmAssert(ph->fh_size == phnew->fh_size, "HPClone: mis-compare");
    }
#endif

  clearsem:
    hpClearSem(hheap, 0);

  exit:
    return(pmem);

  error:
    pmem = 0;
    goto clearsem;
}

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_W16_CODE_SEG
#endif

/***LP	hpWhichHeap - figure out which Dos386 heap a pointer came from
 *
 *	ENTRY:	p - pointer to heap block
 *	EXIT:	handle to appropriate heap or 0 if invalid address
 */
HHEAP INTERNAL
hpWhichHeap(ULONG p)
{
    struct heapseg_s *pseg;

    /*
     *	Check the fixed heap first, because it is sadly the most commonly used
     */
    pseg = (struct heapseg_s *)hFixedHeap;
    do {
	if (p > (ULONG)pseg && p < (ULONG)pseg + pseg->hs_cbreserve) {
	    return(hFixedHeap);
	}
	pseg = pseg->hs_psegnext;
    } while (pseg != 0);

    /*
     *	Then check the swappable heap
     */
    pseg = (struct heapseg_s *)hSwapHeap;
    do {
	if (p > (ULONG)pseg && p < (ULONG)pseg + pseg->hs_cbreserve) {
	    return(hSwapHeap);
	}
	pseg = pseg->hs_psegnext;
    } while (pseg != 0);

    /*
     *	Finally the init heap.	Note that the init heap isn't growable, so we
     *	can just do a simple range check rather than the segment looping we
     *	do for the other heaps.
     */
    if (p > (ULONG)hInitHeap && p < InitHeapEnd) {
	return(hInitHeap);
    }

    /*
     *	If we fall down to here, the address wasn't on any of the heaps
     */
    mmError(ERROR_INVALID_ADDRESS, "hpWhichHeap: block not on heap");
    return(0);
}
#endif


/***EP	HeapFree or HPFree - free a heap block
 *
 *	Mark the passed in block as free and insert it on the appropriate
 *	free list.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *		pblock - pointer to data of block to free (i.e., just past
 *			 busyheap_s structure)
 *	EXIT:	0 if error (bad hheap or pblock) or 1 if success
 */
#ifdef WIN32
BOOL APIENTRY
HeapFreeInternal(HHEAP hheap, DWORD flags, LPSTR lpMem)
#else
unsigned INTERNAL
HPFree(HHEAP hheap, void *lpMem)
#endif
{
    unsigned long cb;
    struct freeheap_s *pblock;
    

    pblock = (struct freeheap_s *)((struct busyheap_s *)lpMem - 1);
						/* point to heap header */

    if (hpTakeSem(hheap, pblock, flags) == 0) {
	return(0);
    }
    cb = hpSize(pblock);
    pblock->fh_size |= 0xf0000000;

#ifdef HPMEASURE
    if (hheap->hi_flags & HP_MEASURE) {
       hpMeasureItem(hheap, cb | HPMEASURE_FREE);
    }
#endif

    /*
     *	If the previous block is free, coalesce with it.
     */
    if (pblock->fh_size & HP_PREVFREE) {
	(unsigned)pblock = *((unsigned *)pblock - 1); /* point to prev block */
	cb += hpSize(pblock);

	/*
	 *  Remove the previous block from the free list so we can re-insert
	 *  the combined block in the right place later
	 */
	hpRemove(pblock);
    }

    /*
     *	Build a free header for the block and insert him on the appropriate
     *	free list.  This routine also marks the following block as HP_PREVFREE
     *	and performs coalescing with the following block.
     */
    hpFreeSub(hheap, pblock, cb, HP_DECOMMIT);

    hpClearSem(hheap, flags);
    return(1);
}


/***EP	HPAlloc - allocate a heap block
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		cb - size of block requested
 *		flags - HP_ZEROINIT - zero initialize new block
 *	EXIT:	none
 */
void * INTERNAL
HPAlloc(HHEAP hheap, unsigned long cb, unsigned long flags)
{
    struct freelist_s *pfreelist;
    struct freeheap_s *pfh;
    struct freeheap_s *pfhend;
    struct heapseg_s *pseg;
    unsigned cbreserve;

    /*
     *	Detect really big sizes here so that we don't have to worry about
     *	rounding up big numbers to 0
     */
    if (cb > hpMAXALLOC) {
	mmError(ERROR_NOT_ENOUGH_MEMORY, "HPAlloc: request too big\n\r");
	goto error;
    }

    if (hpTakeSem(hheap, 0, flags) == 0) {
	goto error;
    }
    cb = hpRoundUp(cb);

#ifdef HPMEASURE
    if (hheap->hi_flags & HP_MEASURE) {
       hpMeasureItem(hheap, cb);
    }
#endif

  restart:
    /*
     *	Find the first free list header that will contain a block big
     *	enough to satisfy this allocation.
     *
     *	NOTE: at the cost of heap fragmentation, we could change this
     *	to allocate from the first free list that is guaranteed to
     *	have a block big enough as its first entry.  That would
     *	cut down paging on swappable heaps.
     */
    for (pfreelist=hheap->hi_freelist; cb > pfreelist->fl_cbmax; ++pfreelist) {
    }


    /*
     *	Look for a block big enough for us on the list head returned.
     *	Even if we follow the advice of the NOTE above and pick a list
     *	that will definitely contain a block big enough for us we still
     *	have to do this scan to pass by any free list heads in the
     *	way (they have a size of 0, so we will never try to allocate them).
     *
     *	We know we have reached the end of the free list when we get to
     *	to the first free list head (since the list is circular).
     */
    pfh = pfreelist->fl_header.fh_flink;
    pfhend = &(hheap->hi_freelist[0].fl_header);
    for (; pfh != pfhend; pfh = pfh->fh_flink) {

	/*
	 *  Did we find a block big enough to hold our request?
	 */
	if (hpSize(pfh) >= cb) {

	    /*
	     *	At this point we have a block of free memory big enough to
	     *	use in pfh.
	     */
	    {
		struct busyheap_s *pbh = (struct busyheap_s *)pfh;

		if ((cb = hpCarve(hheap, pfh, cb, flags)) == 0) {
		    goto errorclearsem;
		}
		hpSetBusySize(pbh, cb);
#ifdef HPDEBUG
		pbh->bh_signature = BH_SIGNATURE;
		pbh->bh_eip = hpGetAllocator();
		pbh->bh_tid = hpGetTID();
		pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif
		hpClearSem(hheap, flags);
		return(pbh + 1);
	    }
	}
    }

    /*
     *	If we fall out of the above loop, there are no blocks available
     *	of the correct size.
     */

    /*
     *	If the heap isn't there is nothing we can do but return error.
     */
    if ((hheap->hi_flags & HP_GROWABLE) == 0) {
	mmError(ERROR_NOT_ENOUGH_MEMORY,"HPAlloc: not enough room on heap\n");
	goto errorclearsem;
    }

    /*
     *	The heap is growable but all the existing heap segments are full.
     *	So reserve a new segment here.	The "PAGESIZE*2" below will take care
     *	of the header on the new segment and the special final page, leaving
     *	a big enough free block for the actual request.
     */
    cbreserve = max(((cb + PAGESIZE*2) & ~PAGEMASK), hpCBRESERVE);

    if (((unsigned)pseg =
#ifdef WIN32
	PageReserve(((unsigned)hheap >= MINSHAREDLADDR) ? PR_SHARED : PR_PRIVATE,
		    cbreserve / PAGESIZE, PR_STATIC)) == -1) {

	mmError(ERROR_NOT_ENOUGH_MEMORY, "HPAlloc: reserve failed\n");
#else
	PageReserve(PR_SYSTEM, cbreserve / PAGESIZE, PR_STATIC |
		    ((hheap->hi_flags & HP_LOCKED) ? PR_FIXED :0))) == -1) {
#endif
	goto errorclearsem;
    }

    /*
     *	Initialize the new segment as a heap (including linking its initial
     *	free block into the heap).
     */
    if (HPInit(hheap, (HHEAP)pseg, cbreserve, hheap->hi_flags | HP_INITSEGMENT) == 0) {
	goto errorfree;
    }

    /*
     *	Link the new heap segment onto the list of segments.
     */
    pseg->hs_psegnext = hheap->hi_psegnext;
    hheap->hi_psegnext = pseg;

    /*
     *	Now go back up to restart our search, we should find the new segment
     *	to satisfy the request.
     */
    goto restart;


    /*
     *	Code below this comment is used only in the error path.
     */
  errorfree:
    PageFree((unsigned)pseg, PR_STATIC);

  errorclearsem:
    hpClearSem(hheap, flags);
#ifdef WIN32
    if ((flags | hheap->hi_flags)  & HP_EXCEPT) {
	RaiseException(STATUS_NO_MEMORY, 0, 1, &cb);
    }
#endif
  error:
    return(0);
}


/***EP	HPReAlloc - reallocate a heap block
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pblock - pointer to data of block to reallocate
 *			 (just past the busyheap_s structure)
 *		cb - new size requested (in bytes)
 *		flags - HP_ZEROINIT - on grows, fill new area with 0s
 *			HP_MOVEABLE - on grows, moving of block is allowed
 *			HP_NOCOPY - don't preserve old block's contents
 *	EXIT:	pointer to reallocated block or 0 if failure
 */
void * INTERNAL
HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb, unsigned long flags)
{
    void *pnew;
    unsigned oldsize;
    struct freeheap_s *pnext;
    struct busyheap_s *pbh;

    /*
     *	Detect really big sizes here so that we don't have to worry about
     *	rounding up big numbers to 0
     */
    if (cb > hpMAXALLOC) {
	mmError(ERROR_NOT_ENOUGH_MEMORY, "HPReAlloc: request too big\n\r");
	goto error;
    }

    pbh = (struct busyheap_s *)pblock - 1;   /* point to heap block header */
    if (hpTakeSem(hheap, pbh, flags) == 0) {
	goto error;
    }
    cb = hpRoundUp(cb); 		     /* convert to heap block size */
    oldsize = hpSize(pbh);

    /*
     *	Is this a big enough shrink to cause us to carve off the end of
     *	the block?
     */
    if (cb + hpMINSIZE <= oldsize) {
	hpFreeSub(hheap, (char *)pbh + cb, oldsize - cb, HP_DECOMMIT);
	hpSetSize(pbh, cb);
#ifdef HPDEBUG
	pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif


    /*
     *	Is this a grow?
     */
    } else if (cb > oldsize) {
	/*
	 *  See if there is a next door free block big enough for us
	 *  grow into so we can realloc in place.
	 */
	pnext = (struct freeheap_s *)((char *)pbh + oldsize);
	if ((pnext->fh_size & HP_FREE) == 0 || hpSize(pnext) < cb - oldsize) {
	    /*
	     *	We have to move the object in order to grow it.
	     *	Make sure that is ok with the caller first.
	     */
	    if (flags & HP_MOVEABLE) {
#ifdef HPDEBUG
		/*
		 *  On a debug system, remember who allocated this memory
		 *  so we don't lose the info when we allocate the new block
		 */
		ULONG eip;
		USHORT tid;

		eip = pbh->bh_eip;
		tid = pbh->bh_tid;
#endif
		/*
		 *  The size we have computed in cb includes a heap header.
		 *  Remove that since our call to HPAlloc bellow will
		 *  also add on a header.
		 */
		cb -= sizeof(struct busyheap_s);

		/*
		 *  If the caller doesn't care about the contents of the
		 *  memory block, just allocate a new chunk and free old one
		 */
		if (flags & HP_NOCOPY) {
		    HeapFree(hheap, HP_NOSERIALIZE, pblock);
		    if ((pblock = HPAlloc(hheap, cb,
					  flags | HP_NOSERIALIZE)) == 0) {
			dprintf(("HPReAlloc: HPAlloc failed 1\n"));
			goto errorclearsem;
		    }

		/*
		 *  If the caller cares about his data, allocate a new
		 *  block and copy the old stuff into it
		 */
		} else {

		    if ((pnew = HPAlloc(hheap, cb, flags | HP_NOSERIALIZE))==0){
			dprintf(("HPReAlloc: HPAlloc failed 2\n"));
			goto errorclearsem;
		    }
		    memcpy(pnew, pblock, oldsize - sizeof(struct busyheap_s));
		    HeapFree(hheap, HP_NOSERIALIZE, pblock);
		    pblock = pnew;
		}

#ifdef HPDEBUG
		/*
		 *  Put back in the original owner
		 */
		pbh = (((struct busyheap_s *)pblock) - 1);
		pbh->bh_eip = eip;
		pbh->bh_tid = tid;
		pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif

	    /*
	     *	Moving of the block is not allowed.  Return error.
	     */
	    } else {
		mmError(ERROR_LOCKED,"HPReAlloc: fixed block\n");
		goto errorclearsem;
	    }

	/*
	 *  We can grow in place into the following block
	 */
	} else {
	    if ((cb = hpCarve(hheap, pnext, cb - oldsize, flags)) == 0) {
		goto errorclearsem;
	    }
	    hpSetSize(pbh, oldsize + cb);
#ifdef HPDEBUG
	    pbh->bh_sum = hpSum(pbh, BH_CDWSUM);
#endif
	}

    /*
     *	This is place to put code for nop realloc if we ever have any.
     */
    } else {

    }

    hpClearSem(hheap, flags);
 exit:
    return(pblock);

 errorclearsem:
    hpClearSem(hheap, flags);

 error:
    pblock = 0;
    goto exit;
}

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_RARE_CODE_SEG
#endif

/***EP	HeapSize or HPSize - return size of a busy heap block (less any header)
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *		pdata - pointer to heap block (just past busyheap_s struct)
 *	EXIT:	size of block in bytes, or 0 if error
 */
#ifdef WIN32
DWORD APIENTRY
HeapSize(HHEAP hheap, DWORD flags, LPSTR lpMem)
#else
unsigned INTERNAL
HPSize(HHEAP hheap, void *lpMem)
#endif
{
    struct busyheap_s *pblock;
    unsigned long cb;

    pblock = ((struct busyheap_s *)lpMem) - 1;	/* point to heap block header*/

    if (hpTakeSem(hheap, pblock, flags) == 0) {
	return(0);
    }

    cb = hpSize(pblock) - sizeof(struct busyheap_s);

    hpClearSem(hheap, flags);
    return(cb);
}

#ifndef WIN32
#pragma VMM_PAGEABLE_DATA_SEG
#pragma VxD_W16_CODE_SEG
#endif

/***LP	hpCarve - carve off a chunk from the top of a free block
 *
 *	This is a low level worker routine and several very specific
 *	entry conditions must be true:
 *
 *	    The free block is valid.
 *	    The free block is at least as big as the chunk you want to carve.
 *	    The heap semaphore is taken.
 *
 *	No header is created for the carved-off piece.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pfh - pointer to header of free block to carve from
 *		cb - size of block to carve out
 *		flags - HP_ZEROINIT
 *	EXIT:	count of bytes in carved off block (may differ from cb if
 *		free block wasn't big enough to make a new free block from
 *		its end) or 0 if error (out of memory on commit)
 */
unsigned INTERNAL
hpCarve(HHEAP hheap, struct freeheap_s *pfh, unsigned cb, unsigned flags)
{
    unsigned cbblock = hpSize(pfh);
    unsigned pgcommit, pgnextcommit, pglastcommit;
    unsigned fcommitzero;

    /*
     *	For multi-page HP_ZEROINIT blocks, it would be nice to commit
     *	zero-filled pages rather than use memset because then we wouldn't have
     *	to make the new pages in the block present and dirty unless and until
     *	the app really wanted to use them (saving on working set and page outs).
     *	This could be a huge win if someone is allocating big objects.
     *	However, we have the problem of what to do about a new partial page at
     *	the end of a heap block.  If we commit it as zero-filled, then we are
     *	zeroing more than we have to (the part of the page not used for this
     *	block).  If we commit it un-initialized, then we have to make two
     *	separate commit calls, one for the zero-filled pages and one for the
     *	last page.  Rather than spend the time of two commit calls and the logic
     *	to figure out when to make them, we always commit zero-filled pages for
     *	everything.  Better to zero too much than too little by mistake.  We
     *	reduce the percentage cost of the mistake case by only doing this
     *	optimization for large blocks.
     *	Here we decide if the block is big enough to commit zero-filled pages.
     */
    if ((flags & HP_ZEROINIT) && cb > 4*PAGESIZE) {
	fcommitzero = HP_ZEROINIT;
    } else {
	fcommitzero = 0;
    }

    mmAssert(cbblock >= cb, "hpCarve: carving out too big a block\n");
    mmAssert((pfh->fh_size & HP_FREE), "hpCarve: target not free\n");

    /*
     *	Since pfh points to a valid free block header, we know we have
     *	committed memory up through the end of the fh structure.  However,
     *	the page following the one containing the last byte of the fh
     *	structure might not be committed.  We set "pgcommit" to that
     *	possibly uncommitted page.
     */
		   /*last byte in fh*/ /*next pg*/   /*its pg #*/
    pgcommit = ((((unsigned)(pfh+1)) - 1 + PAGESIZE) / PAGESIZE);

    /*
     *	pgnextcommit is the page number of the page just past this free block
     *	that we know is already committed.  Since free blocks have a
     *	pointer back to the header in the last dword of the free block,
     *	we know that the first byte of this dword is where we are guaranteed
     *	to have committed memory.
     */
    pgnextcommit = ((unsigned)pfh + cbblock -
		    sizeof(struct freeheap_s *)) / PAGESIZE;

    /*
     *	If the block we found is too big, carve off the end into
     *	a new free block.
     */
    if (cbblock >= cb + hpMINSIZE) {

	/*
	 *  We need to commit the memory for the new block we are allocating
	 *  plus enough space on the end for the following free block header
	 *  that hpFreeSub will make.  The page number for that last page
	 *  we need to commit is pglastcommit.	If we know that pglastcommit
	 *  is already committed because it sits on the same page as
	 *  the start of the next block (pgnextcommit), back it up one.
	 */
	pglastcommit = ((unsigned)pfh + cb + sizeof(struct freeheap_s) - 1) / PAGESIZE;
	if (pglastcommit == pgnextcommit) {
	    pglastcommit--;
	}
	if (hpCommit(pgcommit, pglastcommit - pgcommit + 1,
		     fcommitzero | hheap->hi_flags) == 0) {
	    goto error;
	}

	/*
	 *  Remove the original free block from the free list.	We need to do
	 *  this before the hpFreeSub below because it might trash our current
	 *  free links.
	 */
	hpRemove(pfh);

	/*
	 *  Link the portion we are not using onto the free list
	 */
	hpFreeSub(hheap, (struct freeheap_s *)((char *)pfh + cb), cbblock-cb,0);

    /*
     *	We are using the whole free block for our purposes.
     */
    } else {
	if (hpCommit(pgcommit, pgnextcommit - pgcommit,
		     fcommitzero | hheap->hi_flags) == 0) {
	    goto error;
	}

	/*
	 *  Remove the original free block from the free list.
	 */
	hpRemove(pfh);

	/*
	 *  Clear the PREVFREE bit from the next block since we are no longer
	 *  free.
	 */
	cb = cbblock;
	((struct busyheap_s *)((char *)pfh + cb))->bh_size &= ~HP_PREVFREE;
#ifdef HPDEBUG
	((struct busyheap_s *)((char *)pfh + cb))->bh_sum =
		     hpSum((struct busyheap_s *)((char *)pfh + cb), BH_CDWSUM);
#endif
    }

    /*
     *	Zero-fill the block if requested and return
     */
    if (flags & HP_ZEROINIT) {
	/*
	 *  If fcommitzero is set, we have multi-page heap object with the
	 *  newly committed pages already set up to be zero-filled.
	 *  So we only have to memset the partial page at the start of the
	 *  block (up to the first page we committed) and maybe the partial
	 *  page at the end.
	 */
	if (fcommitzero) {
	    memset(pfh, 0, (pgcommit * PAGESIZE) - (unsigned)pfh);

	    /*
	     *	We have to zero the partial end page of this block if we didn't
	     *	commit the page freshly this time.
	     */
	    if ((unsigned)pfh + cb > pgnextcommit * PAGESIZE) {
		memset((PVOID)(pgnextcommit * PAGESIZE), 0,
		       (unsigned)pfh + cb - (pgnextcommit * PAGESIZE));
	    }

	/*
	 *  If the block fits on one page, just fill the whole thing
	 */
	} else {
	    memset(pfh, 0, cb);
	}
#ifdef HPDEBUG
    } else {
	memset(pfh, 0xcc, cb);
#endif
    }
  exit:
    return(cb);

  error:
    cb = 0;
    goto exit;
}


/***LP	hpCommit - commit new pages of the right type into the heap
 *
 *	The new pages aren't initialized in any way.
 *	The pages getting committed must currently be uncommitted.
 *	Negative values are allowed for the "npages" parameter, they
 *	are treated the same as 0 (a nop).
 *
 *	ENTRY:	page - starting page number to commit
 *		npages - number of pages to commit (may be negative or zero)
 *		flags - HP_LOCKED: commit the new pages as fixed (otherwise
 *				   they will be swappable)
 *			HP_ZEROINIT: commit the new pages as zero-initialized
 *	EXIT:	non-zero if success, else 0 if error
 */
unsigned INTERNAL
hpCommit(unsigned page, int npages, unsigned flags)
{
    unsigned rc = 1;	/* assume success */

    if (npages > 0) {
#ifdef HPDEBUG
	MEMORY_BASIC_INFORMATION mbi;

	/*
	 *  All the pages should be currently reserved but not committed
	 *  or else our math in hpCarve is off.
	 */
	PageQuery(page * PAGESIZE, &mbi, sizeof(mbi));
#ifdef WIN32
	mmAssert(mbi.State == MEM_RESERVE &&
		 mbi.RegionSize >= (unsigned)npages * PAGESIZE,
		 "hpCommit: range not all reserved\n");
#else
	mmAssert(mbi.mbi_State == MEM_RESERVE &&
		 mbi.mbi_RegionSize >= (unsigned)npages * PAGESIZE,
		 "hpCommit: range not all reserved");
#endif
#endif
	rc = PageCommit(page, npages,
			(
#ifndef WIN32
			 (flags & HP_LOCKED) ? PD_FIXED :
#endif
							 PD_NOINIT) -
			((flags & HP_ZEROINIT) ? (PD_NOINIT - PD_ZEROINIT) : 0),
			0,
#ifndef WIN32
			((flags & HP_LOCKED) ? PC_FIXED : 0) |
			PC_PRESENT |
#endif
			PC_STATIC | PC_USER | PC_WRITEABLE);
#ifdef WIN32
	if (rc == 0) {
	    mmError(ERROR_NOT_ENOUGH_MEMORY, "hpCommit: commit failed\n");
	}
#endif
    }
    return(rc);
}


/***LP	hpFreeSub - low level block free routine
 *
 *	This routine inserts a block of memory on the free list with no
 *	checking for block validity.  It handles coalescing with the
 *	following block but not the previous one.  The block must also
 *	be big enough to hold a free header.  The heap semaphore must
 *	be taken already.  Any existing header information is ignored and
 *	overwritten.
 *
 *	This routine also marks the following block as HP_PREVFREE.
 *
 *	Enough memory must be committed at "pblock" to hold a free header and
 *	a dword must committed at the very end of "pblock".  Any whole pages
 *	in between those areas will be decommitted by this routine.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pblock - pointer to memory block
 *		cb - count of bytes in block
 *		flags - HP_DECOMMIT: decommit pages entirely within heap block
 *				     (must be specified unless pages are known
 *				     to be already decommitted)
 *	EXIT:	none
 */
void INTERNAL
hpFreeSub(HHEAP hheap, struct freeheap_s *pblock, unsigned cb, unsigned flags)
{
    struct freelist_s *pfreelist;
    struct freeheap_s *pnext;
    struct freeheap_s *pfhprev;
    struct freeheap_s **ppnext;
    unsigned pgdecommit, pgdecommitmax;
    unsigned cbfree;
    int cpgdecommit;

    mmAssert(cb >= hpMINSIZE, "hpFreeSub: bad param\n");

    /*
     *	If the following block is free, coalesce with it.
     */
    pnext = (struct freeheap_s *)((char *)pblock + cb);
    if (pnext->fh_size & HP_FREE) {
	cb += hpSize(pnext);

	/*
	 *  Remove the following block from the free list.  We will insert
	 *  the combined block in the right place later.
	 *  Here we also set "pgdecommitmax" which is the page just past the
	 *  header of the following free block we are coalescing with.
	 */
	hpRemove(pnext);
	pgdecommitmax = ((unsigned)(pnext+1) + PAGEMASK) / PAGESIZE;
	pnext = (struct freeheap_s *)((char *)pblock + cb); /* recompute */

    } else {
	pgdecommitmax = 0x100000;
    }

#ifdef HPDEBUG
    /*
     *	In debug we fill the free block with here with the byte
     *	0xfe which happens to be nice invalid value either if excecuted
     *	or referenced as a pointer.  We only fill up through the first
     *	page boundary because I don't want to deal with figuring out
     *	which pages are committed and which not.
     */
     memset(pblock, 0xfe, min(cb, (PAGESIZE - ((unsigned)pblock & PAGEMASK))));
#endif

    /*
     *	Decommit any whole pages within this free block.  We need to be
     *	careful not to decommit either part of our heap header for this block
     *	or the back-pointer to the header we store at the end of the block.
     *	It would be nice if we could double check our math by making sure
     *	that all of the pages we are decommitting are currently committed
     *	but we can't because we might be either carving off part of a currently
     *	free block or we might be coalescing with other already free blocks.
     */
    ppnext = (struct freeheap_s **)pnext - 1;

    if (flags & HP_DECOMMIT) {
			   /*last byte in fh*/ /*next pg*/  /*its pg #*/
	pgdecommit = ((unsigned)(pblock+1) - 1 + PAGESIZE) / PAGESIZE;

	/*
	 *  This max statement will keep us from re-decommitting the pages
	 *  of any block we may have coalesced with above.
	 */
	pgdecommitmax = min(pgdecommitmax, ((unsigned)ppnext / PAGESIZE));
	cpgdecommit = pgdecommitmax - pgdecommit;
	if (cpgdecommit > 0) {
#ifdef HPDEBUG
	    unsigned tmp =
#endif
	    PageDecommit(pgdecommit, cpgdecommit, PC_STATIC);
#ifdef HPDEBUG
	    mmAssert(tmp != 0, "hpFreeSub: PageDecommit failed\n");
#endif
	}

#ifdef HPDEBUG
    /*
     *	If the caller didn't specify HP_DECOMMIT verify that all the pages
     *	are already decommitted.
     */
    } else {
	pgdecommit = ((unsigned)(pblock+1) - 1 + PAGESIZE) / PAGESIZE;
	cpgdecommit = ((unsigned)ppnext / PAGESIZE) - pgdecommit;
	if (cpgdecommit > 0) {
	    MEMORY_BASIC_INFORMATION mbi;

	    PageQuery(pgdecommit * PAGESIZE, &mbi, sizeof(mbi));
#ifdef WIN32
	    mmAssert(mbi.State == MEM_RESERVE &&
		     mbi.RegionSize >= (unsigned)cpgdecommit * PAGESIZE,
		     "hpFreeSub: range not all reserved\n");
#else
	    mmAssert(mbi.mbi_State == MEM_RESERVE &&
		     mbi.mbi_RegionSize >= (unsigned)cpgdecommit * PAGESIZE,
		     "hpFreeSub: range not all reserved");
#endif /*WIN32*/
	}
#endif /*HPDEBUG*/
    }

    /*
     *	Point the last dword of the new free block to its header and
     *	mark the following block as HP_PREVFREE;
     */
    *ppnext = pblock;
    pnext->fh_size |= HP_PREVFREE;
#ifdef HPDEBUG
    ((struct busyheap_s *)pnext)->bh_sum = hpSum(pnext, BH_CDWSUM);
#endif

    /*
     *	Find the appropriate free list to insert the block on.
     *	The last free list node should have a size of -1 so don't
     *	have to count to make sure we don't fall off the end of the list
     *	heads.
     */
    for (pfreelist=hheap->hi_freelist; cb > pfreelist->fl_cbmax; ++pfreelist) {
    }

    /*
     *	Now walk starting from that list head and insert it into the list in
     *	sorted order.
     */
    pnext = &(pfreelist->fl_header);
    do {
	pfhprev = pnext;
	pnext = pfhprev->fh_flink;
	cbfree = hpSize(pnext);
    } while (cb > cbfree && cbfree != 0);

    /*
     *	Insert the block on the free list just after the list head and
     *	mark the header as free
     */
    hpInsert(pblock, pfhprev);
    hpSetFreeSize(pblock, cb);
#ifdef HPDEBUG
    pblock->fh_signature = FH_SIGNATURE;
    pblock->fh_sum = hpSum(pblock, FH_CDWSUM);
#endif
    return;
}


/***LP	hpTakeSem - get exclusive access to a heap
 *
 *	This routine verifies that the passed in heap header is valid
 *	and takes the semaphore for that heap (if HP_NOSERIALIZE wasn't
 *	specified when the heap was created).  Optionally, it will
 *	also verify the validity of a busy heap block header.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		pbh - pointer to busy heap block header (for validation)
 *		      or 0 if there is no block to verify
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *	EXIT:	0 if error (bad heap or block header), else 1
 */
#ifdef WIN32
unsigned INTERNAL
hpTakeSem(HHEAP hheap, struct busyheap_s *pbh, unsigned htsflags)
#else
unsigned INTERNAL
hpTakeSem2(HHEAP hheap, struct busyheap_s *pbh)
#endif
{
    struct heapseg_s *pseg;
#ifdef HPDEBUG
    unsigned cb;
#endif

#ifndef WIN32
#define htsflags	0

    mmAssert(!mmIsSwapping(),
	     "hpTakeSem: heap operation attempted while swapping\n");
#endif

#ifdef HPNOTTRUSTED
    /*
     * Verify the heap header.
     */
    if (hheap->hi_signature != HI_SIGNATURE) {
	mmError(ERROR_INVALID_PARAMETER,"hpTakeSem: bad header\n");
	goto error;
    }
#else
    pbh;		/* dummy reference to keep compiler happy */
    cb; 		/* dummy reference to keep compiler happy */
#endif

    /*
     *	Do the actual semaphore taking
     */
    if (((htsflags | hheap->hi_flags) & HP_NOSERIALIZE) == 0) {
#ifdef WIN32
	EnterMustComplete();
#endif
	hpEnterCriticalSection(hheap);
    }

#ifndef WIN32
    /*
     *	This is make sure that if we block while committing or decommitting
     *	pages we will not get reentered.
     */
    mmEnterPaging("hpTakeSem: bogus thcb_Paging");
#endif

#ifdef HPNOTTRUSTED

    /*
     *	If the caller wanted us to verify a heap block header, do so here.
     */
    if (pbh) {

	/*
	 *  First check that the pointer is within the specified heap
	 */
	pseg = (struct heapseg_s *)hheap;
	do {
	    if ((char *)pbh > (char *)pseg &&
		(char *)pbh < (char *)pseg + pseg->hs_cbreserve) {

		/*
		 *  We found the segment containing the block.	Validate that
		 *  it actually points to a heap block.
		 */
		if (!hpIsBusySignatureValid(pbh)
#ifdef HPDEBUG
		    || ((unsigned)pbh & hpGRANMASK) ||
		    (pbh->bh_size & HP_FREE) ||
		    (char *)pbh+(cb = hpSize(pbh)) > (char *)pseg+pseg->hs_cbreserve||
		    (int)cb < hpMINSIZE
		    || pbh->bh_signature != BH_SIGNATURE
#endif
							) {
		    goto badaddress;
		} else {
		    goto pointerok;
		}
	    }
	    pseg = pseg->hs_psegnext;	/* on to next heap segment */
	} while (pseg);

	/*
	 *  If we fell out of loop, we couldn't find the heap block on this
	 *  heap.
	 */
	goto badaddress;
    }
#endif

  pointerok:

#ifdef HPDEBUG
    /*
     *	Make sure that only one thread gets in the heap at a time
     */
    if (hheap->hi_thread && hheap->hi_thread != (unsigned)pthCur) {
	dprintf(("WARNING: two threads are using heap %x at the same time.\n",
		hheap));
	mmError(ERROR_BUSY, "hpTakeSem: re-entered\n\r");
	goto clearsem;
    }
    hheap->hi_thread = (unsigned)pthCur;

    /*
     *	Verify the heap is ok.	If hpfParanoid isn't set, only walk the heap
     *	every 4th time.
     */
    if (hpfParanoid || (hpWalkCount++ & 0x03) == 0) {
	if (hpWalk(hheap) == 0) {
	    mmError(ERROR_INVALID_PARAMETER,"Heap trashed outside of heap code -- someone wrote outside of their block!\n");
	    goto clearsem;
	}
    }
#endif
    return(1);

  badaddress:
    mmError(ERROR_INVALID_PARAMETER,"hpTakeSem: invalid address passed to heap API\n");
    goto clearsem;
  clearsem:
    hpClearSem(hheap, htsflags);
  error:
    return(0);
}

/***LP	hpClearSem - give up exclusive access to a heap
 *
 *	ENTRY:	hheap - pointer to base of heap
 *		flags (ring 3 only) - HP_NOSERIALIZE
 *	EXIT:	none
 */
#ifdef WIN32
void INTERNAL
hpClearSem(HHEAP hheap, unsigned flags)
#else
void INTERNAL
hpClearSem2(HHEAP hheap)
#endif
{

    /*
     *	Verify the heap is ok
     */
#ifdef HPDEBUG
    if (hpfParanoid) {
	hpWalk(hheap);
    }
    hheap->hi_thread = 0;
#endif
#ifndef WIN32
    mmExitPaging("hpClearSem: bogus thcb_Paging");
#endif

    /*
     *	Free the semaphore
     */
    if (((
#ifdef WIN32
	  flags |
#endif
	  hheap->hi_flags) & HP_NOSERIALIZE) == 0) {
	hpLeaveCriticalSection(hheap);
	
#ifdef WIN32
	LeaveMustComplete();
#endif
    }
}

#ifdef HPDEBUG

#ifndef WIN32
#pragma VMM_LOCKED_DATA_SEG
#pragma VMM_LOCKED_CODE_SEG
#endif

/***LP	hpWalk - walk a heap to verify everthing is OK
 *
 *	This routine is "turned-on" if the hpfWalk flag is non-zero.
 *
 *	If hpWalk is detecting an error, you might want to set
 *	hpfTrashStop which enables stopping in the debugger whenever
 *	we detect a trashed heap block	and it attempts to print the
 *	trashed address.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *	EXIT:	1 if the heap is OK, 0 if it is trashed
 */
unsigned INTERNAL
hpWalk(HHEAP hheap)
{
    struct heapseg_s *pseg;
    struct freeheap_s *pfh;
    struct freeheap_s *pend;
    struct freeheap_s *pstart;
    struct freeheap_s *pfhend;
    struct busyheap_s *pnext;
    struct freeheap_s *pprev;
    unsigned cbmax;
    unsigned cheads;


    if (hpfWalk) {
	/*
	 *  First make a sanity check of the header
	 */
	if (hheap->hi_signature != HI_SIGNATURE) {
	    dprintf(("hpWalk: bad header signature\n"));
	    hpTrash(("trashed at %x\n", &hheap->hi_signature));
	    goto error;
	}
	if (hheap->hi_sum != hpSum(hheap, HI_CDWSUM)) {
	    dprintf(("hpWalk: bad header checksum\n"));
	    hpTrash(("trashed between %x and %x\n", hheap, &hheap->hi_sum));
	    goto error;
	}

	/*
	 *  Walk through all the blocks and make sure we get to the end.
	 *  The last block in the heap should be a busy guy of size 0.
	 */
	(unsigned)pfh = (unsigned)hheap + sizeof(struct heapinfo_s);
	pseg = (struct heapseg_s *)hheap;
	for (;;) {
	    pprev = pstart = pfh;
	    (unsigned)pend = (unsigned)pseg + pseg->hs_cbreserve;
	    for (;; (unsigned)pfh += hpSize(pfh)) {

		if (pfh < pstart || pfh >= pend) {
		    dprintf(("hpWalk: bad block address\n"));
		    hpTrash(("trashed addr %x\n", pprev));
		    goto error;
		}

		/*
		 *  If the block is free...
		 */
		if (pfh->fh_signature == FH_SIGNATURE) {

		    if (pfh->fh_sum != hpSum(pfh, FH_CDWSUM)) {
			dprintf(("hpWalk: bad free block checksum\n"));
			hpTrash(("trashed addr between %x and %x\n",
				 pfh, &pfh->fh_sum));
			goto error;
		    }
		    mmAssert(hpIsFreeSignatureValid(pfh),
			     "hpWalk: bad tiny free sig\n");

		    if (hpfParanoid) {
			/*
			 *  Free blocks should be marked as HP_FREE and the following
			 *  block should be marked HP_PREVFREE and be busy.
			 *  But skip this check if the following block is 4 bytes
			 *  into a page boundary so we don't accidentally catch
			 *  the moment in  HPInit where we have two adjacent
			 *  free blocks for a minute.  Any real errors that this
			 *  skips will probably be caught later on.
			 */
			pnext = (struct busyheap_s *)((char *)pfh + hpSize(pfh));
			if (((unsigned)pnext & PAGEMASK) != sizeof(struct freeheap_s *) &&
			    ((pfh->fh_size & HP_FREE) == 0 ||
			     (pnext->bh_size & HP_PREVFREE) == 0 ||
			      pnext->bh_signature != BH_SIGNATURE)) {

			    dprintf(("hpWalk: bad free block\n"));
			    hpTrash(("trashed addr near %x or %x or %x\n",pprev, pfh, pnext));
			    goto error;
			}

			/*
			 *  Also verify that a free block is linked on the free list
			 */
			if ((pfh->fh_flink->fh_size & HP_FREE) == 0 ||
			    pfh->fh_flink->fh_blink != pfh ||
			    (pfh->fh_blink->fh_size & HP_FREE) == 0 ||
			    pfh->fh_blink->fh_flink != pfh) {

			    dprintf(("hpWalk: free block not in free list properly\n"));
			    hpTrash(("trashed addr probably near %x or %x or %x\n", pfh, pfh->fh_blink, pfh->fh_flink));
			    goto error;
			}
		    }

		/*
		 *  Busy blocks should not be marked HP_FREE and if they are
		 *  marked HP_PREVFREE the previous block better be free.
		 */
		} else if (pfh->fh_signature == BH_SIGNATURE) {

		    if (((struct busyheap_s *)pfh)->bh_sum != hpSum(pfh, BH_CDWSUM)) {
			dprintf(("hpWalk: bad busy block checksum\n"));
			hpTrash(("trashed addr between %x and %x\n",
				 pfh, &((struct busyheap_s *)pfh)->bh_sum));
			goto error;
		    }
		    mmAssert(hpIsBusySignatureValid((struct busyheap_s *)pfh),
			     "hpWalk: bad tiny busy sig\n");

		    if (hpfParanoid) {
			if (pfh->fh_size & HP_FREE) {
			    dprintf(("hpWalk: busy block marked free\n"));
			    hpTrash(("trashed addr %x\n", pfh));
			    goto error;
			}


			/*
			 *  Verify that the HP_PREVFREE bit is set only when
			 *  the previous block is free, and vice versa
			 *  But skip this check if the following block is 4 bytes
			 *  into a page boundary so we don't accidentally catch
			 *  the moment in  HPInit where we have two adjacent
			 *  free blocks for a minute.  Any real errors that this
			 *  skips will probably be caught later on.
			 */
			if (pfh->fh_size & HP_PREVFREE) {
			    if (pprev->fh_signature == FH_SIGNATURE) {
				if (*((struct freeheap_s **)pfh - 1) != pprev) {
				    dprintf(("hpWalk: free block tail doesn't point to head\n"));
				    hpTrash(("trashed at %x\n", (unsigned)pfh - 4));
				    goto error;
				}
			    } else {
				dprintf(("HP_PREVFREE erroneously set\n"));
				hpTrash(("trashed at %x\n", pfh));
				goto error;
			    }
			} else if (pprev->fh_signature == FH_SIGNATURE &&
				   ((unsigned)pfh & PAGEMASK) != sizeof(struct freeheap_s *)) {
			    dprintf(("hpWalk: HP_PREVFREE not set\n"));
			    hpTrash(("trashed addr %x\n", pfh));
			    goto error;
			}
		    }
		/*
		 *  The block should have had one of these signatures!
		 */
		} else {
		    dprintf(("hpWalk: bad block signature\n"));
		    hpTrash(("trashed addr %x\n",pfh));
		    goto error;
		}

		/*
		 *  We are at the end of the heap blocks when we hit one with
		 *  a size of 0 (the end sentinel).
		 */
		if (hpSize(pfh) == 0) {
		    break;
		}

		pprev = pfh;
	    }
	    if ((unsigned)pfh != (unsigned)pend - sizeof(struct busyheap_s) ||
		pfh->fh_signature != BH_SIGNATURE) {
		dprintf(("hpWalk: bad end sentinel\n"));
		hpTrash(("trashed addr between %x and %x\n", pfh, pend));
		goto error;
	    }

	    /*
	     *	We are done walking this segment.  If there is another one, go
	     *	on to it, otherwise, terminate the walk
	     */
	    pseg = pseg->hs_psegnext;
	    if (pseg == 0) {
		break;
	    }
	    pfh = (struct freeheap_s *)(pseg + 1);
	}

	if (hpfParanoid) {
	    /*
	     *	Walk through the free list.
	     *	cbmax is the maximum size of block we should find considering
	     *	the last free list header we ran into.
	     *	cheads is the number of list heads we found.
	     */
	    pprev = pfh = hheap->hi_freelist[0].fl_header.fh_flink;
	    cbmax = hheap->hi_freelist[0].fl_cbmax;
	    cheads = 1;
	    pfhend = &(hheap->hi_freelist[0].fl_header);
	    for (; pfh != pfhend; pfh = pfh->fh_flink) {

		if (pfh->fh_sum != hpSum(pfh, FH_CDWSUM)) {
		    dprintf(("hpWalk: bad free block checksum 2\n"));
		    hpTrash(("trashed addr between %x and %x\n",
			     pfh, &pfh->fh_sum));
		    goto error;
		}
		mmAssert(hpIsFreeSignatureValid(pfh),
			 "hpWalk: bad tiny free sig 2\n");

		/*
		 *  Keep track of the list heads we find (so we know all of them
		 *  are on the list) and make sure they are in acsending order.
		 */
		if ((HHEAP)pfh >= hheap && (HHEAP)pfh < hheap + 1) {
		    if (hpSize(pfh) != 0) {
			dprintf(("hpWalk: bad size of free list head\n"));
			hpTrash(("trashed addr near %x or %x\n", pfh, pprev));
		    }
		    if (&(hheap->hi_freelist[cheads].fl_header) != pfh) {
			dprintf(("hpWalk: free list head out of order\n"));
			hpTrash(("trashed addr probably near %x or %x\n", pfh, &(hheap->hi_freelist[cheads].fl_header)));
			goto error;
		    }
		    cbmax = hheap->hi_freelist[cheads].fl_cbmax;
		    cheads++;

		/*
		 *  Normal free heap block
		 */
		} else {
		    /*
		     *	Look through each segment for the block
		     */
		    for (pseg = (struct heapseg_s *)hheap;
			 pseg != 0; pseg = pseg->hs_psegnext) {

			if ((unsigned)pfh > (unsigned)pseg &&
			    (unsigned)pfh < (unsigned)pseg + pseg->hs_cbreserve) {

			    goto addrok;  /* found the address */
			}
		    }

		    /* If we fall out pfh isn't within any of our segments */
		    dprintf(("hpWalk: free list pointer points outside heap bounds\n"));
		    hpTrash(("trashed addr probably %x\n", pprev));
		    goto error;

		  addrok:
		    if (pfh->fh_signature != FH_SIGNATURE ||
			hpSize(pfh) > cbmax) {

			dprintf(("hpWalk: bad free block on free list\n"));
			hpTrash(("trashed addr probably %x or %x\n", pfh, pprev));
			goto error;
		    }

		    /*
		     *	Since the free list is in sorted order, this block
		     *	should be bigger than the previous one.  This check
		     *	will also pass ok for list heads since they have
		     *	size 0 and everything is bigger than that.
		     */
		    if (hpSize(pprev) > hpSize(pfh)) {
			dprintf(("hpWalk: free list not sorted right\n"));
			hpTrash(("trashed addr probably %x or %x\n", pfh, pprev));
		    }
		}
		pprev = pfh;
	    }
	    if (cheads != hpFREELISTHEADS) {
	       dprintf(("hpWalk: bad free list head count\n"));
	       hpTrash(("trashed somewhere between %x and %x\n", hheap, pend));
	       goto error;
	    }
	}
    }
    return(1);

  error:
    return(0);
}


/***LP	hpSum - compute checksum for a block of memory
 *
 *	This routine XORs all of the DWORDs in a block together and
 *	then XORs that value with a constant.
 *
 *	ENTRY:	p - pointer to block to checksum
 *		cdw - number of dwords to sum
 *	EXIT:	computed sum
 */
unsigned long INTERNAL
hpSum(unsigned long *p, unsigned long cdw)
{
    unsigned long sum;

    for (sum = 0; cdw > 0; cdw--, p++) {
	sum ^= *p;
    }
    return(sum ^ 0x17761965);
}


#ifdef WIN32

/***LP	hpGetAllocator - walk the stack to find who allocated a block
 *
 *	This routine is used by HPAlloc to figure out who owns a block of
 *	memory that is being allocated.  We determine the owner by walking
 *	up the stack and finding the first eip that is not inside the
 *	memory manager or inside any other module that obfuscates who
 *	the real allocator is (such as HMGR, which all GDI allocations
 *	go through).
 *
 *	ENTRY:	none
 *	EXIT:	eip of interesting caller
 */
extern HANDLE APIENTRY LocalAllocNG(UINT dwFlags, UINT dwBytes);

ULONG INTERNAL
hpGetAllocator(void)
{
    ULONG Caller = 0;
    _asm {
	mov	edx,[ebp]	; (edx) = HPAlloc ebp
	mov	eax,[edx+4]	; (eax) = HPAlloc caller

;	See if HPAlloc was called directly or from LocalAlloc or HeapAlloc
;	or PvKernelAlloc

	cmp	eax,offset LocalAllocNG
	jb	hga4		; jump to exit if called directly
	cmp	eax,offset LocalAllocNG + 0x300
	jb	hga20

hga4:
	cmp	eax,offset HeapAlloc
	jb	hga6		; jump to exit if called directly
	cmp	eax,offset HeapAlloc + 0x50
	jb	hga20

hga6:
	cmp	eax,offset PvKernelAlloc
	jb	hga8
	cmp	eax,offset PvKernelAlloc + 0x50
	jb	hga20

hga8:
	cmp	eax,offset PvKernelAlloc0
	jb	hgax
	cmp	eax,offset PvKernelAlloc + 0x50
	ja	hgax

;	When we get here, we know HPAlloc was called by LocalAlloc or HeapAlloc
;	or PvKernelAlloc.  See if PvKernelAlloc was called by NewObject or
;	PlstNew.

hga20:
	mov	edx,[edx]	; (edx) = Local/HeapAlloc ebp
	mov	eax,[edx+4]	; (eax) = Local/HeapAlloc caller

	cmp	eax,offset NewObject
	jb	hga34
	cmp	eax,offset NewObject + 0x50
	jb	hga40

hga34:
	cmp	eax,offset LocalAlloc
	jb	hga36
	cmp	eax,offset LocalAlloc+ 0x200
	jb	hga40

hga36:
	cmp	eax,offset PlstNew
	jb	hgax
	cmp	eax,offset PlstNew + 0x50
	ja	hgax

hga40:
	mov	edx,[edx]	; (edx) = PlstNew/NewObject ebp
	mov	eax,[edx+4]	; (eax) = PlstNew/NewObject caller

	cmp	eax,offset NewNsObject
	jb	hga50
	cmp	eax,offset NewNsObject + 0x50
	jb	hga60
hga50:
	cmp	eax,offset NewPDB
	jb	hga55
	cmp	eax,offset NewPDB + 0x50
	jb	hga60
hga55:
        cmp     eax,offset NewPevt
	jb	hgax
        cmp     eax,offset NewPevt + 0x50
	ja	hgax
hga60:
        mov     edx,[edx]       ; (edx) = NewNsObject/NewPDB/NewPevt ebp
        mov     eax,[edx+4]     ; (eax) = NewNsObject/NewPDB/NewPevt caller
hgax:
	mov	Caller, eax
    }
    return Caller;
}

#ifdef HPMEASURE

#define  FIRSTBLOCK(hheap) ((unsigned)(hheap + 1) + sizeof(struct busyheap_s))

/***EP	HPMeasure - enable measurement of heap activity.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *    pszFile - name of file to place measurement data in.
 *	EXIT:	FALSE if error (couldn't allocate buffer)
 */
BOOL APIENTRY
HPMeasure(HHEAP hheap, LPSTR pszFile)
{
   struct measure_s *pMeasure;
   HANDLE hFile;
   BOOL bSuccess = FALSE;

   if (!hpTakeSem(hheap, NULL, 0)) return FALSE;

   /* Allocate the structure & ensure it is the first block in the heap! */
   pMeasure = (struct measure_s *)HPAlloc(hheap, sizeof(struct measure_s), 0);
   if ((unsigned)pMeasure != (unsigned)FIRSTBLOCK(hheap)) {
      mmError(0, "HPMeasure: Must be called before first heap allocation.\n");
      goto cleanup;
   }

   /* verify the filename is valid and transfer the filename to the buffer */
   hFile = CreateFile(pszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                      FILE_ATTRIBUTE_NORMAL, NULL);
   if ((long)hFile == -1) {
      mmError(0, "HPMeasure: The specified file is invalid.\n");
      goto cleanup;
   }
   CloseHandle(hFile);
   lstrcpy(pMeasure->szFile, pszFile);

   /* initialize the buffer variables */
   pMeasure->iCur = 0;

   /* set the measure flag in the heap header */
   hheap->hi_flags |= HP_MEASURE;

   /* Success. */
   bSuccess = TRUE;

cleanup:
   hpClearSem(hheap, 0);
   return bSuccess;
}

/***EP	HPFlush - write out contents of sample buffer.
 *
 *	ENTRY:	hheap - pointer to base of heap
 *	EXIT:	FALSE if error (couldn't write data)
 */
BOOL APIENTRY
HPFlush(HHEAP hheap)
{
   BOOL bResult, bSuccess = FALSE;
   HANDLE hFile;
   unsigned uBytesWritten;
   struct measure_s *pMeasure = (struct measure_s *)FIRSTBLOCK(hheap);

   if (!hpTakeSem(hheap, NULL, 0)) return FALSE;

   /* open the file & seek to the end */
   hFile = CreateFile(pMeasure->szFile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, NULL);
   if ((long)hFile == -1) {
      mmError(0, "HPFlush: could not open file.\n");
      goto cleanup;
   }
   SetFilePointer(hFile, 0, 0, FILE_END);

   /* write the data out. */
   bResult = WriteFile(hFile, pMeasure->uSamples,
                       pMeasure->iCur * sizeof(unsigned),
                       &uBytesWritten, NULL);
   CloseHandle(hFile);

   if (!bResult) {
      mmError(0, "HPFlush: could not write to file.\n");
      goto cleanup;
   }

   /* Success. */
   bSuccess = TRUE;

cleanup:
   /* clear the buffer */
   pMeasure->iCur = 0;

   hpClearSem(hheap, 0);
   return bSuccess;
}

/***LP	hpMeasureItem - add item to measurement data
 *
 *	ENTRY:	hheap - pointer to base of heap
 *    uItem - piece of data to record 
 *	EXIT:	FALSE if error (couldn't write buffer)
 */
BOOL PRIVATE
hpMeasureItem(HHEAP hheap, unsigned uItem)
{
   struct measure_s *pMeasure = (struct measure_s *)FIRSTBLOCK(hheap);

   /* empty buffer if it's full */
   if (pMeasure->iCur == SAMPLE_CACHE_SIZE) {
      if (!HPFlush(hheap))
         return FALSE;
   }

   /* Add data to the list */
   pMeasure->uSamples[pMeasure->iCur++] = uItem;

   return TRUE;
}

#endif


/* routine by DonC to help debug heap leaks */
void KERNENTRY
hpDump(HHEAP hheap, char *where) {
    struct freeheap_s *pfh;
    unsigned avail = 0, acnt = 0;
    unsigned used = 0, ucnt = 0;


	/*
	 *  Walk through all the blocks and make sure we get to the end.
	 *  The last block in the heap should be a busy guy of size 0.
	 */
	(unsigned)pfh = (unsigned)hheap + sizeof(struct heapinfo_s);

	for (;; (unsigned)pfh += hpSize(pfh)) {

	    /*
	     *	If the block is free...
	     */
	    if (pfh->fh_signature == FH_SIGNATURE) {

		avail += hpSize(pfh);
		acnt++;

	    /*
	     *	Busy blocks should not be marked HP_FREE and if they are
	     *	marked HP_PREVFREE the previous block better be free.
	     */
	    } else if (pfh->fh_signature == BH_SIGNATURE) {

		used += hpSize(pfh);
		ucnt++;

	    /*
	     *	The block should have had one of these signatures!
	     */
	    } else {
		dprintf(("hpWalk: bad block signature\n"));
		hpTrash(("trashed addr %x\n",pfh));
	    }

	    /*
	     *	We are at the end of the heap blocks when we hit one with
	     *	a size of 0 (the end sentinel).
	     */
	    if (hpSize(pfh) == 0) {
		break;
	    }

	}

	DebugOut((DEB_WARN, "%ld/%ld used, %ld/%ld avail (%s)", used, ucnt, avail, acnt, where));

}
#endif

#endif /* HPDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulategetprofilestring.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateGetProfileString.cpp

 Abstract:

    GetPrivateProfileString no longer stops parsing at a space or tab 
    character. When users leave what used to be comments on the tail of the 
    string the comments are now passed to the app resulting in errors.

 Notes:

    This is a general purpose shim

 History:

    12/30/1999 a-chcoff Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateGetProfileString)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
APIHOOK_ENUM_END


/*++

 This stub function cleans up when users leave what used to be comments on 
 the tail of the string the comments were passed to the app resulting in 
 errors.  Now the string is terminated before the comments therefore 
 alleviating the errors.

--*/

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR  lpReturnedString,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    DWORD dwRet;

    char* pTemp1 = (char*)lpReturnedString;
    char* pTemp2 = (char*)lpReturnedString;

    //
    //  First just go get the string.
    //
    dwRet = ORIGINAL_API(GetPrivateProfileStringA)(
                            lpAppName, 
                            lpKeyName, 
                            lpDefault, 
                            lpReturnedString, 
                            nSize,
                            lpFileName);

    //
    // Look for comment.
    //
    while (*pTemp1 != ';' && *pTemp1) {
        pTemp1++;
    }

    if ((pTemp1 != pTemp2) && *pTemp1) {        
        LOGN(
            eDbgLevelError,
            "[GetPrivateProfileStringA] Comment after data in file \"%s\". Eliminated.",
            lpFileName);
        
        //
        // Did not make it to end of line better trim it
        // back up to ';' char
        pTemp1--;                               

        //
        // Back up past interposing whitespace.
        //
        while ((*pTemp1==' ') || (*pTemp1=='\t')) {   
           pTemp1--;                            
        }

        pTemp1++;

        //
        // Set new length.
        //
        dwRet = (DWORD)((ULONG_PTR)pTemp1 - (ULONG_PTR)pTemp2); 

        //
        // and NULL term string
        //
        *pTemp1 = '\0';                                   
    }
        
    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateheap_heap.h ===
/*
 *	heap.h - structures and equates for the Windows 32-bit heap
 *
 *  Origin: Chicago
 *
 *  Change history:
 *
 *  Date       Who	  Description
 *  ---------  ---------  -------------------------------------------------
 *  1991       BrianSm	  Created
 */

#ifdef DEBUG
#define HPDEBUG 1
#endif
#ifdef PM386
#define WIN32
#endif

#define HPNOTTRUSTED 1	/* enable parameter checking */

/***LT	busyblock_s - busy heap block header structure
 *
 *	This structure is stored at the head of every busy (not free) heap
 *	block.
 *
 *	The bh_size field is in bytes and includes the size of the
 *	heap header and any slop at the end of the block that might have
 *	been included because of the heap granularity, or to keep us
 *	from leaving a block too small to hold a free heap header.
 *
 *	bh_size is also used as a forward link to the next heap block.
 *
 *	The low two bits of the bh_size field are used to hold flags
 *	(BP_FREE must be clear and HP_PREVFREE is optionally set).
 */
#ifndef HPDEBUG
struct busyheap_s {
	unsigned long	bh_size;	/* block size + flags in low 2 bits */
};
#else
struct busyheap_s {
	unsigned long	bh_size;	/* block size + flags in low 2 bits */
	unsigned long	bh_eip; 	/* EIP of allocator */
	unsigned short	bh_tid; 	/* thread id of allocator */
	unsigned short	bh_signature;	/* signature (should be BH_SIGNATURE)*/
	unsigned long	bh_sum; 	/* checksum of this structure */
};
#endif

/*XLATOFF*/
#define BH_SIGNATURE	0x4842		/* busy heap block signature (BH) */
/*XLATON*/

#define BH_CDWSUM	3		/* count of dwords to sum in struct */


/***LT	freeblock_s - free heap block header structure
 *
 *	This structure is stored at the head of every free block on the
 *	heap.  In the last dword of every free heap block is a pointer
 *	the this structure.
 *
 *	The fh_size field is in bytes and includes the size of the
 *	heap header and any slop at the end of the block that might have
 *	been included because of the heap granularity, or to keep us
 *	from leaving a block too small to hold a free heap header.
 *
 *	fh_size is also used as a forward link to the next heap block.
 *
 *	The low two bits of the fh_size field are used to hold flags
 *	(HP_FREE must be set and HP_PREVFREE must be clear).
 */
#ifndef HPDEBUG
struct freeheap_s {
	unsigned long	   fh_size;	/* block size + flags in low 2 bits */
	struct freeheap_s *fh_flink;	/* forward link to next free block */
	struct freeheap_s *fh_blink;	/* back link to previous free block */
};
#else
struct freeheap_s {
	unsigned long	   fh_size;	/* block size + flags in low 2 bits */
	struct freeheap_s *fh_flink;	/* forward link to next free block */
	unsigned short	   fh_pad;	/* unused */
	unsigned short	   fh_signature;/* signature (should be FH_SIGNATURE)*/
	struct freeheap_s *fh_blink;	/* back link to previous free block */
	unsigned long	   fh_sum;	/* checksum of this structure */
};
#endif

/*XLATOFF*/
#define FH_SIGNATURE	0x4846		/* free heap block signature (FH) */
/*XLATON*/

#define FH_CDWSUM	4		/* count of dwords to sum in struct */

/*
 *	Equates common to all heap blocks.
 *
 *	HP_FREE and HP_PREVFREE (HP_FLAGS) are stored in the low two
 *	bits of the fh_ and bh_size field.
 *	The signature is stored in the high three bits of the size.
 */
#define HP_FREE 	0x00000001	/* block is free */
#define HP_PREVFREE	0x00000002	/* previous block is free */
#define HP_FLAGS	0x00000003	/* mask for all the flags */
#define HP_SIZE 	0x0ffffffc	/* mask for clearing flags */
#define HP_SIGBITS	0xf0000000	/* bits used for signature */
#define HP_SIGNATURE	0xa0000000	/* valid value of signature */

/*
 *	Misc heap equates
 */
#define hpGRANULARITY	4		/* granularity for heap allocations */
#define hpGRANMASK	(hpGRANULARITY - 1)		/* for rounding */
/*XLATOFF*/
#define hpMINSIZE	(sizeof(struct freeheap_s)+sizeof(struct freeheap_s *))
			/* min block size */

#define hpMAXALLOC	(HP_SIZE - 100) /* biggest allocatable heap block */

/* overhead for a new heap segment (header plus end sentinel) */
#define hpSEGOVERHEAD	(sizeof(struct busyheap_s) + sizeof(struct heapseg_s))

/* default reserved size of new segments added to growable heaps */
#define hpCBRESERVE	(4*1024*1024)


/*XLATON*/


/*
 * Exported flags for heap calls
 */
#ifdef WIN32
#define HP_ZEROINIT	0x40	/* zero initialize block on HP(Re)Alloc */
#define HP_MOVEABLE	0x02	/* block can be moved (HP(Re)Alloc) */
#define HP_NOCOPY	0x20	/* don't copy data on HPReAlloc */
#define HP_NOSERIALIZE	0x01	/* don't serialize heap access */
#define HP_EXCEPT	0x04	/* generate exceptions on error */
#ifdef HPMEASURE     
#define HP_MEASURE	0x80	/* enable heap measurement */
#endif

#else

#define HP_ZEROINIT	0x01	/* zero initialize block on HP(Re)Alloc */
#define HP_NOSERIALIZE	0x08	/* don't serialize heap access (HPInit) */
#define HP_NOCOPY	0x04	/* don't copy data on HPReAlloc */
#define HP_MOVEABLE	0x10	/* allow moving on HPReAlloc */
#define HP_LOCKED	0x80	/* put heap in locked memory (HPInit) */
#endif
#define HP_FIXED	0x00	/* block is at a fixed address (HPAlloc) */
#define HP_GROWABLE	0x40	/* heap can grow beyond cbreserve (HPInit) */
/*
 *  Note that flags above 0x80 will not be stored into the heap header in
 *  HPInit calls because the flags field in the header is only a byte
 */
#define HP_INITSEGMENT 0x100	/* just initialize a heap segment (HPInit) */
#define HP_DECOMMIT    0x200	/* decommit pages in free block (hpFreeSub) */
#define HP_GROWUP      0x400	/* waste last page of heap (HPInit) */

/*XLATOFF*/

/***LP	hpSize - pull size field from heap header
 *
 *	This routine depends on the size field being the first
 *	dword in the header.
 *
 *	ENTRY:	ph - pointer to heap header
 *	EXIT:	count of bytes in block (counting header).
 */
#define hpSize(ph) (*((unsigned long *)(ph)) & HP_SIZE)

/***LP	hpSetSize - set the size parameter in a heap header
 *
 *	This routine depends on the size field being the first
 *	dword in the header.
 *
 *	ENTRY:	ph - pointer to busy heap header
 *		cb - count of bytes (should be rounded using hpRoundUp)
 *	EXIT:	size is set in heap header
 */
#define hpSetSize(ph, cb) (((struct busyheap_s *)(ph))->bh_size =  \
		     ((((struct busyheap_s *)(ph))->bh_size & ~HP_SIZE) | (cb)))

/* the compiler used to do a better version with this macro than the above,
 * but not any more
#define hpSetSize2(ph, cb) *(unsigned long *)(ph) &= ~HP_SIZE; \
			   *(unsigned long *)(ph) |= (cb);
 */

/***LP	hpSetBusySize - set the entire bh_size dword for a busy block
 *
 *	This macro will set the bh_size field of the given heap header
 *	to the given size as well as setting the HP_SIGNATURE and clearing
 *	any HP_FREE or HP_PREVFREE bits.
 *
 *	ENTRY:	ph - pointer to busy heap header
 *		cb - count of bytes (should be rounded using hpRoundUp)
 *	EXIT:	bh_size field is initialized
 */
#define hpSetBusySize(ph, cb)	((ph)->bh_size = ((cb) | HP_SIGNATURE))


/***LP	hpSetFreeSize - set the entire fh_size dword for a free block
 *
 *	This macro will set the fh_size field of the given heap header
 *	to the given size as well as setting the HP_SIGNATURE and HP_FREE
 *	and clearing HP_PREVFREE.
 *
 *	ENTRY:	ph - pointer to free heap header
 *		cb - count of bytes (should be rounded using hpRoundUp)
 *	EXIT:	bh_size field is initialized
 */
#define hpSetFreeSize(ph, cb)	((ph)->fh_size = ((cb) | HP_SIGNATURE | HP_FREE))


/***LP	hpIsBusySignatureValid - check a busy heap block's signature
 *
 *	This macro checks the tiny signature (HP_SIGNATURE) in the bh_size
 *	field to see if it is set properly and makes sure that the HP_FREE
 *	bit is clear.
 *
 *	ENTRY:	ph - pointer to a busy heap header
 *	EXIT:	TRUE if signature is ok, else FALSE
 */
#define hpIsBusySignatureValid(ph) \
		    (((ph)->bh_size & (HP_SIGBITS | HP_FREE)) == HP_SIGNATURE)


/***LP	hpIsFreeSignatureValid - check a free heap block's signature
 *
 *	This macro checks the tiny signature (HP_SIGNATURE) in the fh_size
 *	field to see if it is set properly and makes sure that the HP_FREE
 *	bit is also set and HP_PREVFREE is clear.
 *
 *	ENTRY:	ph - pointer to a free heap header
 *	EXIT:	TRUE if signature is ok, else FALSE
 */
#define hpIsFreeSignatureValid(ph) \
	  (((ph)->fh_size & (HP_SIGBITS | HP_FREE | HP_PREVFREE)) == \
						     (HP_SIGNATURE | HP_FREE))


/***LP	hpRoundUp - round up byte count to appropriate heap block size
 *
 *	Heap blocks have a minimum size of hpMINSIZE and hpGRANULARITY
 *	granularity.  This macro also adds on size for the heap header.
 *
 *	ENTRY:	cb - count of bytes
 *	EXIT:	count rounded up to hpGANULARITY boundary
 */
#define hpRoundUp(cb)	\
      max(hpMINSIZE,	\
	  (((cb) + sizeof(struct busyheap_s) + hpGRANMASK) & ~hpGRANMASK))


/*XLATON*/

/***LK	freelist_s - heap free list head
 */
struct freelist_s {
	unsigned long	  fl_cbmax;	/* max size block in this free list */
	struct freeheap_s fl_header;	/* pseudo heap header as list head */
};
#define hpFREELISTHEADS 4	/* number of free list heads in heapinfo_s */

/***LK	heapinfo_s - per-heap information (stored at start of heap)
 *
 */
struct heapinfo_s {

	/* These first three fields must match the fields of heapseg_s */
	unsigned long	hi_cbreserve;		/* bytes reserved for heap */
	struct heapseg_s *hi_psegnext;		/* pointer to next heap segment*/

	struct freelist_s hi_freelist[hpFREELISTHEADS]; /* free list heads */
#ifdef WIN32
	struct heapinfo_s *hi_procnext; 	/* linked list of process heaps */
        CRST    *hi_pcritsec;                   /* pointer to serialization obj*/
	CRST    hi_critsec;		        /* serialize access to heap */
#ifdef HPDEBUG
	unsigned char	hi_matchring0[(76-sizeof(CRST))]; /* pad so .mh command works */
#endif
#else
	struct _MTX    *hi_pcritsec;		/* pointer to serialization obj*/
	struct _MTX	hi_critsec;		/* serialize access to heap */
#endif
#ifdef HPDEBUG
	unsigned long	hi_thread;		/* thread pointer of thread
						 * inside heap code */
	unsigned long	hi_eip; 		/* EIP of heap's creator */
	unsigned long	hi_sum; 		/* checksum of this structure*/
	unsigned short	hi_tid; 		/* thread ID of heap's creator*/
	unsigned short	hi_pad1;		/* unused */
#endif
	unsigned char	hi_flags;		/* HP_SERIALIZE, HP_LOCKED */
	unsigned char	hi_pad2;		/* unused */
	unsigned short	hi_signature;		/* should be HI_SIGNATURE */
};

/*
 * Heap Measurement functions
 */
#define  HPMEASURE_FREE    0x8000000L

#define  SAMPLE_CACHE_SIZE 1024

struct measure_s {
   char  szFile[260];
   unsigned iCur;
   unsigned uSamples[SAMPLE_CACHE_SIZE];
};

/*XLATOFF*/
#define HI_SIGNATURE  0x4948	    /* heapinfo_s signature (HI) */
/*XLATON*/

#define HI_CDWSUM  1		    /* count of dwords to sum */

typedef struct heapinfo_s *HHEAP;


/***LK	heapseg_s - per-heap segment structure
 *
 *	Growable heaps can have multiple discontiguous sections of memory
 *	allocated to them.  Each is headed by one of these structures.	The
 *	first segment is special, in that it has a full heapinfo_s structure,
 *	but the first fields of heapinfo_s match heapseg_s, so it can be
 *	treated as just another segment when convenient.
 */
struct heapseg_s {
	unsigned long	hs_cbreserve;	/* bytes reserved for this segment */
	struct heapseg_s *hs_psegnext;	/* pointer to next heap segment*/
};
/* XLATOFF */

/* smallest possible heap */
#define hpMINHEAPSIZE	(sizeof(struct heapinfo_s) + hpMINSIZE + \
			 sizeof(struct busyheap_s))

/***LP	hpRemove - remove item from free list
 *
 *	ENTRY:	pfh - pointer to free heap block to remove from list
 *	EXIT:	none
 */
#define hpRemoveNoSum(pfh)				\
	(pfh)->fh_flink->fh_blink = (pfh)->fh_blink;	\
	(pfh)->fh_blink->fh_flink = (pfh)->fh_flink;

#ifdef HPDEBUG
#define hpRemove(pfh)	hpRemoveNoSum(pfh);			\
			(pfh)->fh_flink->fh_sum =		\
			    hpSum((pfh)->fh_flink, FH_CDWSUM);	\
			(pfh)->fh_blink->fh_sum =		\
			    hpSum((pfh)->fh_blink, FH_CDWSUM);
#else
#define hpRemove(pfh)	hpRemoveNoSum(pfh)
#endif

/***LP	hpInsert - insert item onto the free list
 *
 *	ENTRY:	pfh - free heap block to insert onto the list
 *		pfhprev - insert pfh after this item
 *	EXIT:	none
 */
#define hpInsertNoSum(pfh, pfhprev)		\
	(pfh)->fh_flink = (pfhprev)->fh_flink;	\
	(pfh)->fh_flink->fh_blink = (pfh);	\
	(pfh)->fh_blink = (pfhprev);		\
	(pfhprev)->fh_flink = (pfh)

#ifdef HPDEBUG
#define hpInsert(pfh, pfhprev)	hpInsertNoSum(pfh, pfhprev);	\
			(pfh)->fh_flink->fh_sum =		\
			    hpSum((pfh)->fh_flink, FH_CDWSUM);	\
			(pfhprev)->fh_sum =			\
			    hpSum((pfhprev), FH_CDWSUM)
#else
#define hpInsert(pfh, pfhprev)	hpInsertNoSum(pfh, pfhprev)
#endif

#ifdef WIN32
#define INTERNAL
#endif

/*
 * critical section macros to be used by all internal heap functions
 */
#ifndef WIN32
    #define hpEnterCriticalSection(hheap) mmEnterMutex(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) mmLeaveMutex(hheap->hi_pcritsec)
    #define hpInitializeCriticalSection(hheap) \
        hheap->hi_pcritsec = &(hheap->hi_critsec); \
        mmInitMutex(hheap->hi_pcritsec)
#else
    #define hpEnterCriticalSection(hheap) EnterCrst(hheap->hi_pcritsec)
    #define hpLeaveCriticalSection(hheap) LeaveCrst(hheap->hi_pcritsec)
    //BUGBUG: removed special case hheapKernel code
    #define hpInitializeCriticalSection(hheap)              \
        {                                        \
            hheap->hi_pcritsec = &(hheap->hi_critsec);  \
            InitCrst(hheap->hi_pcritsec);               \
        }
#endif

/*
 * Exported heap functions
 */
extern HHEAP INTERNAL HPInit(void *hheap, void *pmem, unsigned long cbreserve,
			     unsigned long flags);
extern void * INTERNAL HPAlloc(HHEAP hheap, unsigned long cb,
			     unsigned long flags);

extern void * INTERNAL HPReAlloc(HHEAP hheap, void *pblock, unsigned long cb,
			       unsigned long flags);
#ifndef WIN32
extern unsigned INTERNAL HPFree(HHEAP hheap, void *lpMem);
extern unsigned INTERNAL HPSize(HHEAP hheap, void *lpMem);
extern HHEAP INTERNAL  HPClone(struct heapinfo_s *hheap, struct heapinfo_s *pmem);
#endif


/*
 * Local heap functions
 */
extern void INTERNAL hpFreeSub(HHEAP hheap, void *pblock, unsigned cb,
			       unsigned flags);
extern unsigned INTERNAL hpCommit(unsigned page, int npages, unsigned flags);
extern unsigned INTERNAL hpCarve(HHEAP hheap, struct freeheap_s *pfh,
				unsigned cb, unsigned flags);
#ifdef WIN32
extern unsigned INTERNAL hpTakeSem(HHEAP hheap, void *pbh, unsigned flags);
extern void INTERNAL hpClearSem(HHEAP hheap, unsigned flags);
#else
extern unsigned INTERNAL hpTakeSem2(HHEAP hheap, void *pbh);
extern void INTERNAL hpClearSem2(HHEAP hheap);
#endif

/*
 * Debug functions
 */
#ifdef HPDEBUG

extern unsigned INTERNAL hpWalk(HHEAP hheap);
extern char INTERNAL hpfWalk;
extern char INTERNAL hpfTrashStop;
extern char INTERNAL hpfParanoid;
extern char	    mmfErrorStop;
extern unsigned long INTERNAL hpGetAllocator(void);
extern unsigned long INTERNAL hpSum(PVOID p, unsigned long cdw);

#else

#define hpWalk(hheap) 1

#endif

#ifdef WIN32
#ifdef HPDEBUG
#define DebugStop() { _asm int 3 }
#define mmError(rc, string)    vDebugOut(mmfErrorStop ? DEB_ERR : DEB_WARN, string);SetError(rc)
#define mmAssert(exp, psz)     if (!(exp)) vDebugOut(DEB_ERR, psz)
#else
#define mmError(rc, string) SetError(rc)
#define mmAssert(exp, psz)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateheap_kernel32.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    kernel32.h

 Abstract:
     
    The heap manager is identical (exactly) to the Win9x heap manager. The code 
    is the same and the corresponding conversion code and defines are in 
    support.c and kernel32.h The exact win9x sources are in heap.c and lmem.c. 
    All the heap functions come in heap.c and the local/global functions come 
    in lmem.c.

    The SHIM code comes in EmulateHeap.cpp. This hooks the heap calls and calls 
    the Win9x code to emulate the Win9x heap. After the heap management by the 
    Win9x heap, the underneath calls to the Virtual memory functions are handled 
    in support.c. The only difference comes in the way Win9x handles 'SHARED' 
    and "PRIVATE' heaps.Win9x creates the process default heap as a SHARED heap 
    and uses it in kernel mode too. We also create it as a SHARED heap but do 
    not share it with the kernel. Win9x links all the PRIVATE heaps for the 
    process in the PDB data structure. We fake this structure with only the 
    required elements and allow the Win9x code to handle this structure.
     
 Notes:

    None.    

 History:
           
    11/16/2000 prashkud & linstev Created 
 
--*/

#ifndef _KERNEL32_H_
#define _KERNEL32_H_

#include "windows.h"

#define INTERNAL
#define EXTERNAL
#define KERNENTRY       WINAPI

#define PAGESHIFT	12
#define PAGESIZE	(1 << PAGESHIFT)
#define PAGEMASK	(PAGESIZE - 1)

#define CRST            CRITICAL_SECTION

//BUGBUG - did this to prevent build error, but should make no difference
#define typObj          LockCount
#define typObjCrst      0

#define InitCrst(_x_)   InitializeCriticalSection(_x_)
#define DestroyCrst(_x_) DeleteCriticalSection(_x_)
#define EnterCrst(_x_)  EnterCriticalSection(_x_)
#define LeaveCrst(_x_)  LeaveCriticalSection(_x_)
#define Assert(_x_)     

/* PageReserve flags */
#define PR_FIXED        0x00000008	/* don't move during PageReAllocate */
#define PR_4MEG         0x00000001	/* allocate on 4mb boundary */
#define PR_STATIC       0x00000010	/* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT     0x00000001	/* swappable zero-initialized pages */
#define PD_NOINIT       0x00000002	/* swappable uninitialized pages */
#define PD_FIXEDZERO	0x00000003      /* fixed zero-initialized pages */
#define PD_FIXED        0x00000004	/* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED        0x00000008	/* pages are permanently locked */
#define PC_LOCKED       0x00000080	/* pages are made present and locked*/
#define PC_LOCKEDIFDP	0x00000100      /* pages are locked if swap via DOS */
#define PC_WRITEABLE	0x00020000      /* make the pages writeable */
#define PC_USER         0x00040000	/* make the pages ring 3 accessible */
#define PC_INCR         0x40000000	/* increment "pagerdata" each page */
#define PC_PRESENT      0x80000000	/* make pages initially present */
#define PC_STATIC       0x20000000	/* allow commit in PR_STATIC object */
#define PC_DIRTY        0x08000000      /* make pages initially dirty */
#define PC_CACHEDIS     0x00100000      /* Allocate uncached pages - new for WDM */
#define PC_CACHEWT      0x00080000      /* Allocate write through cache pages - new for WDM */
#define PC_PAGEFLUSH    0x00008000      /* Touch device mapped pages on alloc - new for WDM */

/* PageReserve arena values */
#define PR_PRIVATE      0x80000400	/* anywhere in private arena */
#define PR_SHARED       0x80060000	/* anywhere in shared arena */
#define PR_SYSTEM       0x80080000	/* anywhere in system arena */

// This can be anything since it only affects flags which are ignored
#define MINSHAREDLADDR  1
// This is used for validation, which is identical on NT - no allocation can be at > 0x7fffffff
#define MAXSHAREDLADDR	0x7fffffff
// This is used for validation, old value was 0x00400000, but now just make it 1
#define MINPRIVATELADDR	1
// Used to determine if a heap is private, was 0x3fffffff, but now make it 0x7fffffff
#define MAXPRIVATELADDR	0x7fffffff

extern ULONG PageCommit(ULONG page, ULONG npages, ULONG hpd, ULONG pagerdata, ULONG flags);
extern ULONG PageDecommit(ULONG page, ULONG npages, ULONG flags);
extern ULONG PageReserve(ULONG page, ULONG npages, ULONG flags);
#define PageFree(_x_, _y_) VirtualFree((LPVOID) _x_, 0, MEM_RELEASE)

#define PvKernelAlloc0(_x_) VirtualAlloc(0, _x_, MEM_COMMIT, PAGE_READWRITE)
#define FKernelFree(_x_)    VirtualFree((LPVOID) _x_, 0, MEM_RELEASE)

extern CRITICAL_SECTION *NewCrst();
extern VOID DisposeCrst(CRITICAL_SECTION *lpcs);

#define FillBytes(a, b, c)    memset(a, c, b)

#define SetError(_x_)   SetLastError(_x_)
#define dprintf(_x_)    OutputDebugStringA(_x_)
#define DebugOut(_x_) 
#define DEB_WARN        0
#define DEB_ERR         1

#include "EmulateHeap_heap.h"

#define HeapSize         _HeapSize
#define HeapCreate       _HeapCreate
#define HeapDestroy      _HeapDestroy
#define HeapReAlloc      _HeapReAlloc
#define HeapAlloc        _HeapAlloc
#define HeapFree         _HeapFree
#define HeapFreeInternal _HeapFree
#define LocalReAlloc     _LocalReAlloc
#define LocalAllocNG     _LocalAlloc
#define LocalFreeNG      _LocalFree 
#define LocalLock        _LocalLock
#define LocalCompact     _LocalCompact
#define LocalShrink      _LocalShrink
#define LocalUnlock      _LocalUnlock
#define LocalSize        _LocalSize
#define LocalHandle      _LocalHandle
#define LocalFlags       _LocalFlags

//BUGBUG: don't think we need these - looks like they're required for kernel heap support
#define EnterMustComplete()
#define LeaveMustComplete()

// For lmem.c
typedef struct _pdb {
    struct heapinfo_s *hheapLocal;	// DON'T MOVE THIS!!! handle to heap in private memeory
    struct lhandle_s *plhFree;		// Local heap free handle list head ptr
    struct heapinfo_s *hhi_procfirst;	// linked list of heaps for this process
    struct lharray_s *plhBlock;		// local heap lhandle blocks
} PDB, *PPDB;

extern PDB **pppdbCur;
#define GetCurrentPdb() (*pppdbCur)

extern HANDLE hheapKernel;
extern HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
extern DWORD APIENTRY HeapSize(HHEAP hheap, DWORD flags, LPSTR lpMem);
extern BOOL APIENTRY HeapFreeInternal(HHEAP hheap, DWORD flags, LPSTR lpMem);

#define HEAP_SHARED  0x04000000              // put heap in shared memory
#define HEAP_LOCKED  0x00000080              // put heap in locked memory

#ifdef WINBASEAPI 
    #undef WINBASEAPI 
    #define WINBASEAPI 
#endif

#endif // _KERNEL32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateheap_lmem.c ===
//  LMEM.C
//
//      (C) Copyright Microsoft Corp., 1988-1994
//
//      Win32 wrappers for heap functions (Local* and some Heap*)
//
//  Origin: <Chicago>
//
//  Change history:
//
//  Date       Who        Description
//  ---------  ---------  -------------------------------------------------
//	       BrianSm	  Local* and Heap* APIs
//	       AtsushiK   Toolhelp
//  15-Feb-94  JonT       Code cleanup and precompiled headers

#include <EmulateHeap_kernel32.h>
#pragma hdrstop("kernel32.pch")

#include <tlhelp32.h>


#define GACF_HEAPSLACK 0x400000	// Copied from windows.h (16-bit)

SetFile();
/*
 *  Structure and equates for LocalAlloc handle management.  Some things
 *  to remember:
 *
 *  When a handle is returned to the user, we really pass him the address
 *  of the lh_pdata field because some bad apps like Excel just dereference the
 *  handle to find the pointer, rather than call LocalLock.
 *
 *  It is important that the handle value returned also be word aligned but not
 *  dword aligned (ending in a 2,6,a, or e).  We use the 0x2 bit to detect
 *  that a value is a handle and not a pointer (which will always be dword
 *  aligned).
 *
 *  If the data block get discarded, the lh_pdata field will be set to 0.
 *
 *  Free handles are kept on a free list linked through the lh_freelink
 *  field which overlays some other fields.  You can tell if a handle is free
 *  and has a valid freelink by checking that lh_sig == LH_FREESIG
 *
 *  The handles themselves are kept in heap blocks layed out as a
 *  lharray_s. We link these blocks on a per-process list so that
 *  the heap-walking functions can enumerate them.
 */


#pragma pack(1)
    
struct lhandle_s {
	unsigned short lh_signature;	/* signature (LH_BUSYSIG or LH_FREESIG)*/
	void	      *lh_pdata;	/* pointer to data for heap block */
	unsigned char  lh_flags;	/* flags (LH_DISCARDABLE) */
	unsigned char  lh_clock;	/* lock count */
};
#define lh_freelink	lh_pdata	/* free list overlays first field */
					/*    if LH_FREE is set in lh_flags */
#define LH_BUSYSIG	'SB'		/* signature for allocated handle */
#define LH_FREESIG	'SF'		/* signature for free handle */
#define LH_DISCARDABLE	0x02		/* lh_flags value for discardable mem */

#define LH_CLOCKMAX	0xff		/* maximum possible lock count */

#define LH_HANDLEBIT	 2		/* bit that is set on handles but not */
					            /*    pointers */

#define CLHGROW 	8
#define CBLHGROW	(sizeof(struct lhandle_s) * CLHGROW)


struct lharray_s {
    unsigned short lha_signature;	/* signature (LHA_SIG) */
    unsigned short lha_membercount;	/* position in linked list (for detecting loops) */
    struct lharray_s *lha_next;		/* ptr to next lharray_s */
//!!! This array *must* be dword aligned so that the handles will be 
//    *not* dword-aligned.
    struct lhandle_s lha_lh[CLHGROW];
};

#define LHA_SIGNATURE    'AL'		/* signature for lhaarray_s blocks */


#define TH32_MEMBUFFERSIZE (max(CBLHGROW,1024))

// A pointer to this private block of state info is kept in the dwResvd
// field of the HEAPENTRY32 structure.
typedef struct {
    CRST	*pcrst;		// Pointer to critical section (unencoded)

// !!! pcrst must be the first field!!!    
    PDB		*ppdb;		// PDB of process
    HHEAP	hHeap;		// Real Heap handle
    DWORD	lpbMin;		// Lowest allowed address for a heap block
    DWORD	nlocalHnd;	// # of lhandle_s structures allocated in heap
    struct heapinfo_s hi;	// Snapshot of heapinfo_s    

    
    DWORD	nSuppAvail;	// size of lpdwSuppress array in dwords
    DWORD	nSuppUsed;	// # of lpdwSuppress array dwords used.
    DWORD	*lpdwSuppress;	// Either NULL or a pointer to a NULL-terminated
				//  array of heap blocks to suppress.

    
    DWORD	dwMode;		// Current mode
    DWORD	nNextLH;	// 0 based index of next lhandle to read in curlha (THM_LHANDLES)
    
    DWORD	lpHBlock;	// Address of next heap block to read (THM_FIXEDHANDLES)
    DWORD	dwBlkAddr;	// Address of start of block data
    DWORD	dwBlkSize;	// Size of heap block (including header)
    DWORD	dwBlkFlags;	// HP_ flags.

    DWORD	curlhaaddr;	// Actual base address of curlha.
    struct lharray_s  curlha;   // Snapshot of current lharray_s

} THSTATE, *LPTHSTATE;

#define THM_INIT			0  //Init state
#define THM_LHANDLES			1  //Next object is an lhandle
#define THM_FIXEDHANDLES		2  //Next object is a fixed handle
#define THM_DONE			3  //Normal end
#define THM_ERROR			4  //Found heap error in previous advance


/*
 * these externs are needed to know whether we should destroy or dispose heap
 * critical sections
 */
extern  HANDLE  hheapKernel;		/* heap handle for the kernel heap */
VOID APIENTRY MakeCriticalSectionGlobal( LPCRITICAL_SECTION lpcsCriticalSection );

/*
 * The HP_* flags and LMEM_* flags should be interchangeable
 */
#if ((HP_ZEROINIT - LMEM_ZEROINIT) || (HP_MOVEABLE - LMEM_MOVEABLE) || (HP_FIXED - LMEM_FIXED))
# error Equates busted
#endif



extern ULONG INTERNAL VerifyOnHeap(HHEAP hheap, PVOID p);
extern KERNENTRY HouseCleanLogicallyDeadHandles(VOID);
extern BOOL KERNENTRY ReadProcessMemoryFromPDB(PPDB   ppdb,
					       LPVOID lpBaseAddress,
					       LPVOID lpBuffer,
					       DWORD nSize,
					       LPDWORD lpNumberOfBytesRead);
extern DWORD KERNENTRY GetAppCompatFlags(VOID);
extern HANDLE _GetProcessHeap(void);

/* 
     Utility function to check the local memory handle
 */

BOOL
_IsValidHandle(HANDLE hMem)
{
    BOOL bRet = FALSE;
    struct lhandle_s *plh;

	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);

	/*
	 *  Do our own little parameter validation here because the normal
	 *  validation layer can't handle the odd-ball error return of hMem
	 */
	{
	    volatile UCHAR tryerror = 0;

	    _try {
		    tryerror &= (plh->lh_clock + (UCHAR)plh->lh_signature);
	    } _except (EXCEPTION_EXECUTE_HANDLER) {
		    tryerror = 1;
	    }

	    if (tryerror) {		
		    goto error;
	    }
	}

	if ((plh->lh_signature != LH_BUSYSIG) &&
       (plh->lh_signature != LH_FREESIG)){
	    	    goto error;
	}
    // Set the return value to TRUE
    bRet = TRUE;

error:
    return bRet;
}

/* 
     Utility function to check whether the passed memory
     is in the memory range. Uses VerifyOnHeap function.
 */
BOOL
_IsOnOurHeap(LPCVOID lpMem)
{
    HANDLE hHeap = _GetProcessHeap();
    return (VerifyOnHeap(hHeap, (PVOID)lpMem));
}

/* 
     Utility function to check the local memory handle
     and the memory range. Uses VerifyOnHeap function.
 */

BOOL
_IsOurLocalHeap(HANDLE hMem)
{
    BOOL bRet = FALSE;
    HANDLE hHeap = _GetProcessHeap();

    if ((ULONG)hMem & LH_HANDLEBIT)
    {
        // This is a handle
        bRet = (VerifyOnHeap(hHeap, hMem)) &&
               (_IsValidHandle(hMem));
    }
    else
    {
        bRet = VerifyOnHeap(hHeap, hMem);
    }
    return bRet;
}


/***EP	LocalAllocNG - allocate a block from the current process's default heap
 *
 *	ENTRY:	flags - LMEM_FIXED, LMEM_MOVEABLE, LMEM_DISCARDABLE, LMEM_ZEROINIT
 *		dwBytes - counts of bytes to allocate
 *	EXIT:	flat pointer to block allocated, or 0 if failure
 *
 *  Special entry point used by the handle-grouping code to avoid unwanted
 *  recursion.
 */
HANDLE APIENTRY
LocalAllocNG(UINT dwFlags, UINT dwBytes)
{
    void *pmem;
    struct lhandle_s *plh;
    struct lhandle_s *plhend;

    
    dwFlags &= ~( ((DWORD)GMEM_DDESHARE) |
		  ((DWORD)GMEM_NOTIFY)   |
		  ((DWORD)GMEM_NOT_BANKED) );

    /*
     *	Enter the heap critical section which serializes access to the handle
     *	tables as well as the heap.
     */
    hpEnterCriticalSection(((*pppdbCur)->hheapLocal));

    /*
     *	Make sure there are no extra flags
     */
    if (dwFlags & ~(LMEM_MOVEABLE | LMEM_DISCARDABLE | LMEM_ZEROINIT |
		    LMEM_NOCOMPACT | LMEM_NODISCARD)) {
	mmError(ERROR_INVALID_PARAMETER, "LocalAlloc: invalid flags\n");
	goto error;
    }

    /*
     *	If they want moveable memory, adjust dwBytes to leave room for a back
     *	pointer to the handle structure and allocate a handle structure.
     */
    if (dwFlags & LMEM_MOVEABLE) {

	/*
	 *  Allocate a handle structure.  If there aren't any on the free
	 *  list, allocate another block of memory to hold some more handles.
	 */
	if ((*pppdbCur)->plhFree == 0) {
	    struct lharray_s *plha;
	    
	    if ((plha = HPAlloc((HHEAP)(*pppdbCur)->hheapLocal, 
				sizeof(struct lharray_s),
				HP_NOSERIALIZE)) == 0) {
		goto error;
	    }
	    plha->lha_signature = LHA_SIGNATURE;
	    plha->lha_membercount = 
		(*pppdbCur)->plhBlock ? 
		    (*pppdbCur)->plhBlock->lha_membercount + 1 : 
		    0;
	    plh = &(plha->lha_lh[0]);

	    /*
	     *	If the allocation worked, put the handle structures on the free
	     *	list and null terminate the list.  Actually, we put all of the
	     *	new blocks on the list but one, who is the guy we are trying
	     *	to allocate (he will be in plh when we are done).
	     */
	    (*pppdbCur)->plhFree = plh;
	    for (plhend = plh + CLHGROW - 1; plh < plhend; plh++) {
		plh->lh_freelink = plh + 1;
		plh->lh_signature = LH_FREESIG;
	    }
	    (plh-1)->lh_freelink = 0;
	    
	    plha->lha_next = (*pppdbCur)->plhBlock;
	    (*pppdbCur)->plhBlock = plha;

	/*
	 *  If there is something on the free list, just take the guy off of it
	 */
	} else {
	    plh = (*pppdbCur)->plhFree;
	    mmAssert(plh->lh_signature == LH_FREESIG,
		     "LocalAlloc: bad handle free list 2\n");
	    (*pppdbCur)->plhFree = plh->lh_freelink;
	}

	/*
	 *  Initialize the handle structure
	 */
	plh->lh_clock = 0;
	plh->lh_signature = LH_BUSYSIG;
	plh->lh_flags = (dwFlags & LMEM_DISCARDABLE) ? LH_DISCARDABLE : 0;

	/*
	 *  Now actually allocate the memory unless the caller wanted the
	 *  block initially discarded (dwBytes == 0)
	 */
	if (dwBytes != 0) {
	    /*
	     *	Need to check for wacky size here to make sure adding on
	     *	the 4 bytes below to the size doesn't bring it from negative
	     *	to positive.
	     */
	    if (dwBytes > hpMAXALLOC) {
		mmError(ERROR_NOT_ENOUGH_MEMORY,
			"LocalAlloc: requested size too big\n");
		goto errorfreehandle;
	    }

	    if ((pmem = HPAlloc((HHEAP)(*pppdbCur)->hheapLocal,
				dwBytes+sizeof(struct lhandle_s *),
				dwFlags | HP_NOSERIALIZE)) == 0) {
		goto errorfreehandle;
	    }
	    plh->lh_pdata = (char *)pmem + sizeof(struct lhandle_s *);

	    /*
	     *	Initialize the back pointer to the handle structure at the
	     *	front of the data block.
	     */
	    *((struct lhandle_s **)pmem) = plh;

	} else {
	    plh->lh_pdata = 0;
	}

	/*
	 *  Set "pmem" (the return value) to the lh_pdata field in the
	 *  handle structure.
	 *
	 *  When a handle is returned to the user, we really pass him the address
	 *  of the lh_pdata field because some bad apps like Excel just dereference the
	 *  handle to find the pointer, rather than call LocalLock.
	 *
	 *  It is important that the handle value returned also be word aligned but not
	 *  dword aligned (ending in a 2,6,a, or e).  We use the 0x2 bit to detect
	 *  that a value is a handle and not a pointer (which will always be dword
	 *  aligned).
	 */
	pmem = &plh->lh_pdata;
	mmAssert(((ULONG)pmem & LH_HANDLEBIT),
		 "LocalAlloc: handle value w/o LH_HANDLEBIT set\n");

    /*
     *	For fixed memory, just allocate the sucker
     */
    } else {
	if ((pmem = HPAlloc((HHEAP)(*pppdbCur)->hheapLocal, dwBytes,
			    dwFlags | HP_NOSERIALIZE)) == 0) {
	    goto errorfreehandle;
	}
	mmAssert(((ULONG)pmem & LH_HANDLEBIT) == 0,
		 "LocalAlloc: pointer value w/ LH_HANDLEBIT set\n");
    }

  exit:
    hpLeaveCriticalSection(((*pppdbCur)->hheapLocal));
    return(pmem);

    /*
     *	Error paths.
     */
  errorfreehandle:
    if (dwFlags & LMEM_MOVEABLE) {
	plh->lh_freelink = (*pppdbCur)->plhFree;
	(*pppdbCur)->plhFree = plh;
	plh->lh_signature = LH_FREESIG;
    }
  error:
    pmem = 0;
    goto exit;
}


/***EP	LocalReAlloc - resize a memory block on the default heap
 *
 *	ENTRY:	hMem - pointer to block to resize
 *		dwBytes - new size requested
 *		dwFlags - LMEM_MOVEABLE: ok to move the block if needed
 *	EXIT:	flat pointer to resized block, or 0 if failure
 *
 */
HANDLE APIENTRY
LocalReAlloc(HANDLE hMem, UINT dwBytes, UINT dwFlags)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    void *pmem;
    
    
    dwFlags &= ~((DWORD)GMEM_DDESHARE);
    HouseCleanLogicallyDeadHandles();

    hheap = (*pppdbCur)->hheapLocal;

    /*
     *	Enter the heap critical section which serializes access to the handle
     *	tables as well as the heap.
     */
    hpEnterCriticalSection(hheap);

    /*
     *	Make sure there are no extra flags
     */
    if ((dwFlags & ~(LMEM_MOVEABLE | LMEM_DISCARDABLE | LMEM_ZEROINIT |
		    LMEM_NOCOMPACT | LMEM_MODIFY)) ||
	((dwFlags & LMEM_DISCARDABLE) && (dwFlags & LMEM_MODIFY) == 0)) {
	mmError(ERROR_INVALID_PARAMETER, "LocalReAlloc: invalid flags\n");
	goto error;
    }


    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  The handle value is aligned like a handle, but is it really one?
	 *  Verify it by making sure it is within the address range of the heap
	 *  and that it's signature is set right.  HPReAlloc will verify things
	 *  more by checking that the pmem is valid.
	 */
	if (VerifyOnHeap(hheap, hMem) == 0) {
	    mmError(ERROR_INVALID_HANDLE, "LocalReAlloc: hMem out of range\n");
	    goto error;
	}
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalReAlloc: invalid hMem, bad signature\n");
	    goto error;
	}
	pmem = (char *)plh->lh_pdata - sizeof(struct lhandle_s *);

	/*
	 *  If the caller just wanted to change the flags for the block,
	 *  do it here.
	 */
	if (dwFlags & LMEM_MODIFY) {
	    plh->lh_flags &= ~LH_DISCARDABLE;
	    plh->lh_flags |= (dwFlags & LMEM_DISCARDABLE) ? LH_DISCARDABLE : 0;

	/*
	 *  If someone wants to realloc the block to size 0 (meaning discard the
	 *  sucker) do so here.  For discarding, we free the actual heap block
	 *  and store null in the lh_pdata field.
	 */
	} else if (dwBytes == 0) {

	    /*
	     *	If the lock count is not zero, you aren't allow to discard
	     */
	    if (plh->lh_clock != 0) {
		mmError(ERROR_INVALID_HANDLE,
			"LocalReAlloc: discard of locked block\n");
		goto error;
	    }

	    /*
	     *	Don't bother discarding the block if it is already discarded
	     */
	    if (plh->lh_pdata != 0) {
		if (HeapFree(hheap, HP_NOSERIALIZE, pmem) == 0) {
		    goto error;
		}
		plh->lh_pdata = 0;
	    }

	/*
	 *  If we get here, the caller actually wanted to reallocate the block
	 */
	} else {

	    dwBytes += sizeof(struct lhandle_s *);

	    /*
	     *	If the block is currently discarded, then we need to allocate
	     *	a new memory chunk for it, otherwise, do a realloc
	     */
	    if (plh->lh_pdata == 0) {
		if (dwBytes != 0) {
		    if ((pmem = HPAlloc(hheap, dwBytes,
					dwFlags | HP_NOSERIALIZE)) == 0) {
			goto error;
		    }
		    *((struct lhandle_s **)pmem) = plh;
		}
	    } else {
		if (plh->lh_clock == 0) {
		    dwFlags |= LMEM_MOVEABLE;
		}
		if ((pmem = HPReAlloc(hheap, pmem, dwBytes,
				      dwFlags | HP_NOSERIALIZE)) == 0) {
		    goto error;
		}
	    }

	    /*
	     *	Update the lh_pdata field in the handle to point to the new
	     *	memory.
	     */
	    plh->lh_pdata = (char *)pmem + sizeof(struct lhandle_s *);
	}

    /*
     *	The caller did not pass in a handle.  Treat the value as a pointer.
     *	HPReAlloc will do parameter validation on it.
     */
    } else if ((dwFlags & LMEM_MODIFY) == 0) {
	hMem = HPReAlloc(hheap, hMem, dwBytes, dwFlags | HP_NOSERIALIZE);

    } else {
	mmError(ERROR_INVALID_PARAMETER,
		"LocalReAlloc: can't use LMEM_MODIFY on fixed block\n");
	goto error;
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(hMem);

  error:
    hMem = 0;
    goto exit;
}


/***EP	LocalLock - lock a local memory handle on the default heap
 *
 *	ENTRY:	hMem - handle to block
 *	EXIT:	flat pointer to block or 0 if error
 */
LPVOID APIENTRY
LocalLock(HANDLE hMem)
{
    LPSTR pmem;
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify hMem is within the address range of the heap
     */
    if (VerifyOnHeap(hheap, hMem) == 0) {
	/*
	 *  We don't want this error to break into the debugger by default
	 *  user can call this with random address in some dialog routine
	 *  that it doesn't know if it has a handle or a pointer
	 */
	DebugOut((DEB_WARN, "LocalLock: hMem out of range"));
	SetError(ERROR_INVALID_HANDLE);
//	  mmError(ERROR_INVALID_HANDLE, "LocalLock: hMem out of range\n");
	goto error;
    }

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  The handle value is aligned like a handle, but is it really one?
	 *  Verify it by checking the signature.
	 */
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalLock: invalid hMem, bad signature\n");
	    goto error;
	}

	/*
	 *  Increment the lock count unless we are already at the max
	 */
#ifdef HPDEBUG
	if (plh->lh_clock == LH_CLOCKMAX - 1) {
	    dprintf(("LocalLock: lock count overflow, handle cannot be unlocked\n"));
	}
#endif
	if (plh->lh_clock != LH_CLOCKMAX) {
	    plh->lh_clock++;
	}
	pmem = plh->lh_pdata;

    /*
     *	If the hMem passed in isn't a handle, it is supposed to be the
     *	base address of a fixed block.	We should validate that more, but NT
     *	doesn't and I would hate to be incompatible.  So instead, just
     *	return the parameter except for the obvious error case of the block
     *	being free.
     */
    } else {
	if (hpIsFreeSignatureValid((struct freeheap_s *)
				   (((struct busyheap_s *)hMem) - 1))) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalLock: hMem is pointer to free block\n");
	    goto error;
	}
	pmem = hMem;
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(pmem);

  error:
    pmem = 0;
    goto exit;
}


/***	LocalCompact - obsolete function
 *
 *	ENTRY:	uMinFree - ignored
 *	EXIT:	0
 */

UINT APIENTRY
LocalCompact(UINT uMinFree)
{
    return(0);
}


/***	LocalShrink - obsolete function
 *
 *	ENTRY:	hMem - ignored
 *		cbNewSize - ignored
 *	EXIT:	reserved size of the local heap
 */
UINT APIENTRY
LocalShrink(HANDLE hMem, UINT cbNewSize)
{
    return((*pppdbCur)->hheapLocal->hi_cbreserve);
}

/***	LocalUnlock - unlock a local memory handle on the default heap
 *
 *	ENTRY:	hMem - handle to block
 *	EXIT:	0 if unlocked or 1 is still locked
 */
BOOL APIENTRY
LocalUnlock(HANDLE hMem)
{
    struct lhandle_s *plh;
    struct heapinfo_s *hheap;
    BOOL rc = 0;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify hMem is within the address range of the heap
     */
    if (VerifyOnHeap(hheap, hMem) == 0) {
	mmError(ERROR_INVALID_HANDLE, "LocalUnlock: hMem out of range\n");
	goto exit;
    }

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  Validate handle signature
	 */
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalUnlock: invalid hMem, bad signature\n");
	    goto exit;
	}

	/*
	 *  Decrement the lock count unless we are at the max
	 */
	if (plh->lh_clock != LH_CLOCKMAX) {
	    if (plh->lh_clock == 0) {

		/*
		 *  Just do a DebugOut since this is not an error per se,
		 *  though it probably indicates a bug in the app.
		 */
	        DebugOut((DEB_WARN, "LocalUnlock: not locked"));
		goto exit;
	    }
	    if (--plh->lh_clock != 0) {
		rc++;
	    }
	}
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);
}

/***	LocalSize - return the size of a memory block on the default heap
 *
 *	ENTRY:	hMem - handle (pointer) to block
 *	EXIT:	size in bytesof the block (not including header) or 0 if error
 */
UINT APIENTRY
LocalSize(HANDLE hMem)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    DWORD rc = 0;
    DWORD delta = 0;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  Verify hMem is within the address range of the heap
	 */
	if (VerifyOnHeap(hheap, hMem) == 0) {
	    mmError(ERROR_INVALID_HANDLE, "LocalSize: hMem out of range\n");
	    goto error;
	}

	/*
	 *  Validate handle signature
	 */
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalSize: invalid hMem, bad signature\n");
	    goto error;
	}

	/*
	 *  Discarded handles have no size
	 */
	if (plh->lh_pdata == 0) {
	    goto error;
	}

	/*
	 *  Load up hMem with pointer to data for HeapSize call below
	 */
	delta = sizeof(struct lhandle_s *);
	hMem = (char *)plh->lh_pdata - sizeof(struct lhandle_s *);
    }

    /*
     *	Either this is a fixed block or we just loaded up the data address
     *	above if it was moveable.  Call HeapSize to do the real work.
     */
    rc = HeapSize(hheap, HP_NOSERIALIZE, hMem);

    /*
     *	If this was a moveable block, subtract the 4 bytes for the back pointer
     */
    rc -= delta;

  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);

  error:
    rc = 0;
    goto exit;
}


/***	LocalFlags - return the flags and lock count of block of def heap
 *
 *	ENTRY:	hMem - handle (pointer) to block on default heap
 *	EXIT:	flags in high 3 bytes, lock count in low byte (always 1)
 */
UINT APIENTRY
LocalFlags(HANDLE hMem)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    DWORD rc = LMEM_INVALID_HANDLE;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify hMem is within the address range of the heap
     */
    if (VerifyOnHeap(hheap, hMem) == 0) {
	mmError(ERROR_INVALID_HANDLE, "LocalFlags: hMem out of range\n");
	goto exit;
    }

    /*
     *	We have to do our own pointer validation because the normal validation
     *	layer doesn't support returning LMEM_INVALID_HANDLE for errors.
     */
    _try {
	/*
	 *  Figure out if this is a handle by checking if the adress is aligned
	 *  in the right (wrong) way.
	 */
	if ((ULONG)hMem & LH_HANDLEBIT) {

	    /*
	     *	Validate handle signature
	     */
	    plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);
	    if (plh->lh_signature != LH_BUSYSIG) {
		mmError(ERROR_INVALID_HANDLE,
			"LocalFlags: invalid hMem, bad signature\n");
	    } else {

		rc = (ULONG)plh->lh_clock;

		if (plh->lh_pdata == 0) {
		    rc |= LMEM_DISCARDED;
		}
		if (plh->lh_flags & LH_DISCARDABLE) {
		    rc |= LMEM_DISCARDABLE;
		}
	    }

	/*
	 *  For fixed blocks, validate the signature.  NT always returns
	 *  0 for most fixed-like values even if they aren't really
	 *  the start of blocks.  If this causes an incompatibility we
	 *  can change this later.
	 */
	} else {
	    if (hpIsBusySignatureValid(((struct busyheap_s *)hMem) - 1)) {
		rc = 0;
	    } else {
		mmError(ERROR_INVALID_HANDLE, "LocalFlags: invalid hMem\n");
	    }
	}
    } _except (EXCEPTION_EXECUTE_HANDLER) {

	mmError(ERROR_INVALID_HANDLE, "LocalFlags: bad hMem");
    }
  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);
}


/***	LocalHandle - return the handle for a block given its start address
 *
 *	ENTRY:	pMem - pointer to block on default heap
 *	EXIT:	handle for the block
 */
HANDLE APIENTRY
LocalHandle(PVOID pMem)
{
    struct heapinfo_s *hheap;
    struct busyheap_s *pbh;
    unsigned long prevdword;
    struct lhandle_s *plh;
    HANDLE rc;

    hheap = (*pppdbCur)->hheapLocal;

    hpEnterCriticalSection(hheap);

    /*
     *	Verify pMem is within the address range of the heap and aligned like
     *	a heap block should be.
     */
    if (VerifyOnHeap(hheap, pMem) == 0) {
	mmError(ERROR_INVALID_HANDLE, "LocalHandle: pMem out of range\n");
	goto error;
    }

    /*
     *	Figure out if this is a moveable block by seeing if the previous
     *	dword points back to a handle.
     */
    prevdword = *(((unsigned long *)pMem) - 1);
    if (VerifyOnHeap(hheap, (PVOID)prevdword) != 0) {

	if (((struct lhandle_s *)prevdword)->lh_signature == LH_BUSYSIG) {

	    /*
	     *	This sure looks like a moveable block with a handle.  Return it.
	     */
	    rc = (HANDLE)(prevdword + LH_HANDLEBIT);
	    goto exit;
	}
    }

    /*
     * Did they pass in a Handle???
     */

    if ((ULONG)pMem & LH_HANDLEBIT) {
	plh = (struct lhandle_s *)((char *)pMem - LH_HANDLEBIT);
	if (plh->lh_signature == LH_BUSYSIG) {
	    rc = (HANDLE)pMem;
	    SetError(ERROR_INVALID_HANDLE); /* NT Compat */
	    goto exit;
	}
    }


    /*
     *	If we get to here, the block is not preceded by a handle back pointer.
     *	So either it is an invalid address or a fixed block.
     */
    pbh = (struct busyheap_s *)pMem - 1;
    if (hpIsBusySignatureValid(pbh) == 0) {

	/*
	 *  Not a heap block.  Return error.
	 */
	mmError(ERROR_INVALID_HANDLE, "LocalHandle: address not a heap block\n");
	goto error;

    /*
     *	If we get here, we passed all the tests.  Looks like we have a fixed
     *	heap block, so just return the pointer as the handle.
     */
    } else {
	rc = pMem;
    }

  exit:
    hpLeaveCriticalSection(hheap);
    return(rc);

  error:
    rc = 0;
    goto exit;
}

extern WINBASEAPI BOOL WINAPI vHeapFree(HANDLE hHeap, DWORD dwFlags,
					LPVOID lpMem);


/***EP	LocalFreeNG - free a block on the default heap
 *
 *	ENTRY:	hMem - handle (pointer) to block to free
 *	EXIT:	NULL if success, else hMem if failure
 *
 *  Special entry point used by the handle-grouping code to avoid unwanted
 *  recursion.
 */
HANDLE APIENTRY
LocalFreeNG(HANDLE hMem)
{
    struct heapinfo_s *hheap;
    struct lhandle_s *plh;
    void *pmem;

    /*
     *	The spec says to ignore null pointers
     */
    if (hMem == 0) {
	goto exit;
    }

    hheap = (*pppdbCur)->hheapLocal;

    /*
     *	Enter the heap critical section which serializes access to the handle
     *	tables as well as the heap.
     */
    hpEnterCriticalSection(hheap);

    /*
     *	Figure out if this is a handle by checking if the adress is aligned
     *	in the right (wrong) way.
     */
    if ((ULONG)hMem & LH_HANDLEBIT) {

	/*
	 *  The handle value is aligned like a handle, but is it really one?
	 *  Verify it by making sure it is within the address range of the heap
	 *  and that it's signature is set right.  HeapFree will verify things
	 *  more by checking that the pmem is valid.
	 */
	if (VerifyOnHeap(hheap, hMem) == 0) {
	    mmError(ERROR_INVALID_HANDLE, "LocalFree: hMem out of range\n");
	    goto error;
	}
	plh = (struct lhandle_s *)((char *)hMem - LH_HANDLEBIT);

	/*
	 *  Do our own little parameter validation here because the normal
	 *  validation layer can't handle the odd-ball error return of hMem
	 */
	{
	    volatile UCHAR tryerror = 0;

	    _try {
		tryerror &= (plh->lh_clock + (UCHAR)plh->lh_signature);
	    } _except (EXCEPTION_EXECUTE_HANDLER) {
		tryerror = 1;
	    }
	    if (tryerror) {
		mmError(ERROR_INVALID_HANDLE, "LocalFree: invalid handle");
		goto error;
	    }
	}

	if (plh->lh_signature != LH_BUSYSIG) {
	    mmError(ERROR_INVALID_HANDLE,
		    "LocalFree: invalid hMem, bad signature\n");
	    goto error;
	}

	/*
	 *  You can't free a locked block
	 */

// Commenting out to keep MFC apps from ripping under debug. 
// Not that I'm a fan of shooting the messenger, but this particular
// case seems to happen a lot because of the way Win3.x defined
// GlobalLock. See Win95C:#12103 for the non-technical reasons for
// this being a pri-1.
//
#if 0
#ifdef HPDEBUG
	if (plh->lh_clock) {
	    mmError(ERROR_INVALID_HANDLE, "LocalFree: locked\n");
	}
#endif
#endif


	/*
	 *  Don't bother freeing the block if it is already discarded.
	 *  When freeing we zero out the back pointer to the handle so
	 *  we don't get confused if someone tried to free a block twice.
	 */
    if (plh->lh_pdata != 0) {
	    pmem = (char *)plh->lh_pdata - sizeof(struct lhandle_s *);
	    /*
	     *  Under some conditions with Office, this pointer can get trashed. We
	     *  need to make sure we don't AV
	     */
        if (!IsBadWritePtr(pmem, sizeof(unsigned long))) {
            *((unsigned long *)pmem) = 0;
    	    if (HeapFree(hheap, HP_NOSERIALIZE, pmem) == 0) {
	        	goto error;
            }
        }
	}

	/*
	 *  Now free the handle structure and we are done.
	 */
	plh->lh_freelink = (*pppdbCur)->plhFree;
	(*pppdbCur)->plhFree = plh;
	plh->lh_signature = LH_FREESIG;


    /*
     *	The caller did not pass in a handle.  Treat the value as a pointer.
     *	HeapFree will do parameter validation on it.
     */
    } else {
	if (vHeapFree(hheap, HP_NOSERIALIZE, hMem) == 0) {
	    goto error;
	}
    }

    hMem = 0;		/* success */

  error:
    hpLeaveCriticalSection(hheap);
  exit:
    return(hMem);
}


/***EP	HeapCreate - initialize a memory block as a flat heap
 *
 *	ENTRY:	flOptions - HEAP_NO_SERIALIZE: don't serialize access within process
 *			    (caller MUST)
 *			    HEAP_LOCKED: make memory fixed
 *			    HEAP_SHARED: put it in shared arena
 *		dwInitialSize - initial committed memory in heap
 *		dwMaximumSize - reserved size of heap memory
 *	EXIT:	handle to new heap, or 0 if error
 */
HANDLE APIENTRY
HeapCreate(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize)
{
    char	      *pmem;
    ULONG	       rc = 0;	/* assume failure */

    /*
     *	Don't allowed shared heaps - this only works on Win9x because there is a shared arena.
     */
    if (flOptions & HEAP_SHARED) {
        flOptions &= ~HEAP_SHARED;
    }

    /*
     *	Although we don't really use InitialSize any more (except in growable
     *	heaps) we should still enforce its sanity so apps don't get lazy
     */
    if (dwInitialSize > dwMaximumSize && dwMaximumSize != 0) {
	mmError(ERROR_INVALID_PARAMETER,
		"HeapCreate: dwInitialSize > dwMaximumSize\n");
	goto exit;
    }

    /*
     *	Round the sizes up to the nearest page boundary
     */
    dwMaximumSize = (dwMaximumSize + PAGEMASK) & ~PAGEMASK;

    /*
     *	A maximum size of 0 means growable.  Start him out with 1meg, but allow
     *	more.
     */
    if (dwMaximumSize == 0) {
	flOptions |= HP_GROWABLE;
	dwMaximumSize = 1*1024*1024 + (dwInitialSize & ~PAGEMASK);
    }

    /*
     *	Allocate memory for the heap.  Use PageCommit etc... rather than
     *	VirtualAlloc for committing so we don't get zero-initialized stuff
     *	and also we can commit fixed pages and reserve shared memory.
     */
    if (((ULONG)pmem =
	 PageReserve((flOptions & HEAP_SHARED) ? PR_SHARED : PR_PRIVATE,
		   dwMaximumSize / PAGESIZE,
		   PR_STATIC |
		   ((flOptions & HEAP_LOCKED) ? PR_FIXED : 0))) == -1) {
	mmError(ERROR_NOT_ENOUGH_MEMORY, "HeapCreate: reserve failed\n");
	goto exit;
    }

    /*
     *	Call HPInit to initialize the heap structures within the new memory
     */
    #if HEAP_NO_SERIALIZE - HP_NOSERIALIZE
    # error HEAP_NO_SERIALIZE != HP_NOSERIALIZE
    #endif
    #if HEAP_GENERATE_EXCEPTIONS - HP_EXCEPT
    # error HEAP_GENERATE_EXCEPTIONS != HP_EXCEPT
    #endif
    if (((PVOID)rc = HPInit(pmem, pmem, dwMaximumSize,
			    (flOptions &
			     (HP_EXCEPT|HP_NOSERIALIZE|HP_GROWABLE)))) == 0) {
	goto free;
    }

    // if this is a shared heap and not the kernel heap, we don't
    // want the critical section to go away until the heap is destroyed
    if ( (flOptions & HEAP_SHARED) && hheapKernel ) {
        MakeCriticalSectionGlobal( (CRITICAL_SECTION *)(&(((HHEAP)pmem)->hi_critsec)) );
    }

    /*
     *	Link private heaps onto the per-process heap list.
     */
    if ((flOptions & HEAP_SHARED) == 0) {
	mmAssert(pppdbCur, "HeapCreate: private heap created too early");

	((struct heapinfo_s *)pmem)->hi_procnext = GetCurrentPdb()->hhi_procfirst;
	GetCurrentPdb()->hhi_procfirst = (struct heapinfo_s *)pmem;
    }

  exit:
    return((HANDLE)rc);

  free:
    PageFree(pmem, PR_STATIC);
    goto exit;
}


/***EP	HeapDestroy - free a heap allocated with HeapCreate
 *
 *	ENTRY:	hHeap - handle to heap to free
 *	EXIT:	non-0 if success, or 0 if failure
 */
BOOL APIENTRY
HeapDestroy(HHEAP hHeap)
{
    ULONG	       rc;
    struct heapinfo_s **ppheap;
    struct heapseg_s *pseg;
    struct heapseg_s *psegnext;

    EnterMustComplete();

    if ((rc = hpTakeSem(hHeap, 0, 0)) == 0) {
	goto exit;
    }

    /*
     *	We now hold the heap's semaphore.  Quickly clear the semaphore and
     *	delete the semaphore.  If someone comes in and blocks on the semaphore
     *	between the time we clear it and destroy it, tough luck.  They will
     *	probably fault in a second.
     */
    hpClearSem(hHeap, 0);
    if ((hHeap->hi_flags & HP_NOSERIALIZE) == 0) {
        if (hHeap == hheapKernel) {
	    DestroyCrst(hHeap->hi_pcritsec);
	} else {
            Assert(hHeap->hi_pcritsec->typObj == typObjCrst);
            if (hHeap->hi_pcritsec->typObj == typObjCrst) {
	        DisposeCrst(hHeap->hi_pcritsec);
            }
	}
    }

    /*
     *	For private heaps, find it on the per-process heap list and remove it.
     */
    if ((ULONG)hHeap < MAXPRIVATELADDR) {
	ppheap = &(GetCurrentPdb()->hhi_procfirst);
	for (; *ppheap != hHeap; ppheap = &((*ppheap)->hi_procnext)) {
	    mmAssert(*ppheap != 0, "HeapDestroy: heap not on list");
	}
	*ppheap = hHeap->hi_procnext;		/* remove from list */
    }

    /*
     *	Free the heap memory
     */
    pseg = (struct heapseg_s *)hHeap;
    do {
	psegnext = pseg->hs_psegnext;
	PageFree(pseg, PR_STATIC);
	pseg = psegnext;
    } while (pseg != 0);
  exit:
    LeaveMustComplete();
    return(rc);
}


/***EP	HeapAlloc - allocate a fixed/zero-init'ed block from the specified heap
 *
 *	ENTRY:	hHeap - heap handle (pointer to base of heap)
 *		dwFlags - HEAP_ZERO_MEMORY
 *		dwBytes - count of bytes to allocate
 *	EXIT:	pointer to block or 0 if failure
 */
LPVOID APIENTRY
HeapAlloc(HANDLE hHeap, DWORD dwFlags, DWORD dwBytes)
{
    // WordArt (32) overwrites some of his local heap blocks. So
    // we pad his allocations some. Slacker.
    if (GetAppCompatFlags() & GACF_HEAPSLACK) {
	if (hHeap == GetCurrentPdb()->hheapLocal) {
	    dwBytes += 16;
	}
    }
    
    return(HPAlloc((HHEAP)hHeap, dwBytes, (dwFlags & HEAP_GENERATE_EXCEPTIONS) |
		   ((dwFlags & HEAP_ZERO_MEMORY) ? HP_ZEROINIT : 0)));
}


/***EP	HeapReAlloc - resize a memory block on a specified heap
 *
 *	ENTRY:	hHeap - heap handle (pointer to base of heap)
 *		dwFlags - HEAP_REALLOC_IN_PLACE_ONLY
 *			  HEAP_ZERO_MEMORY
 *		lpMem - pointer to block to resize
 *		dwBytes - new size requested
 *	EXIT:	flat pointer to resized block, or 0 if failure
 */
LPVOID APIENTRY
HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPSTR lpMem, DWORD dwBytes)
{
    return((HANDLE)HPReAlloc((HHEAP)hHeap,
		       lpMem,
		       dwBytes,
		       (dwFlags & (HEAP_NO_SERIALIZE | HP_EXCEPT)) |
		       ((dwFlags & HEAP_REALLOC_IN_PLACE_ONLY) ? 0 : HP_MOVEABLE) |
		       ((dwFlags & HEAP_ZERO_MEMORY) ? HP_ZEROINIT : 0)));
}



//--------------------------------------------------------------------------
// ToolHelp32 heapwalking code.
//--------------------------------------------------------------------------

/*---------------------------------------------------------------------------
 * BOOL SafeReadProcessMemory(PPDB   ppdb,
 *			      LPVOID lpBuffer,
 *			      DWORD  cbSizeOfBuffer,
 *			      DWORD  cbBytesToRead);
 *
 * Reads memory from another process's context.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY SafeReadProcessMemory(PPDB   ppdb,
				     DWORD  dwBaseAddr,
				     LPVOID lpBuffer,
				     DWORD  cbSizeOfBuffer,
				     DWORD  cbBytesToRead)
{
    BOOL fRes;
#ifdef DEBUG
    
    if (cbSizeOfBuffer != 0) {
	FillBytes(lpBuffer, cbSizeOfBuffer, 0xcc);
    }
    
    if (cbSizeOfBuffer < cbBytesToRead) {
	DebugOut((DEB_ERR, "SafeReadProcessMemory: Input buffer too small."));
	return FALSE;
    }
#endif
    
    if (!(fRes = ReadProcessMemoryFromPDB(ppdb,
					  (LPVOID)dwBaseAddr,
					  lpBuffer,
					  cbBytesToRead,
					  NULL))) {
#ifdef DEBUG
	DebugOut((DEB_WARN, "SafeReadProcessMemory: Failed ReadProcessMemory()"));
#endif	
	return FALSE;
    }
    
    return TRUE;
    
} 

/*---------------------------------------------------------------------------
 * Make sure the caller initialized HEAPENTRY32 properly.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY ValidateHeapEntry32(LPHEAPENTRY32 lphe32)
{
    if ((lphe32 == NULL) || (lphe32->dwSize != sizeof(HEAPENTRY32))) {
	DebugOut((DEB_ERR, "HEAPENTRY32: Wrong version or dwSize."));
	return FALSE;
    }
    
    return TRUE;
}


/*---------------------------------------------------------------------------
 * Test if a linear address could plausibly be the start of a block header.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY IsValidBlockHdrAddr(LPHEAPENTRY32 lphe32, DWORD dwAddr)
{
    LPTHSTATE lpts;
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    /*
     *	A good block is always in the user address space and dword aligned
     */
    if ((dwAddr & 0x3) || dwAddr < MINPRIVATELADDR || dwAddr >= MAXSHAREDLADDR) {
	return FALSE;
    }
    return TRUE;
}

/*---------------------------------------------------------------------------
 * Test if a linear address could plausibly be the start of  block data.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY IsValidBlockDataAddr(LPHEAPENTRY32 lphe32, DWORD dwAddr)
{
    return(IsValidBlockHdrAddr(lphe32, dwAddr));
}


/*---------------------------------------------------------------------------
 * Read in and validate a lharray_s.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY SafeRdCurLHA(LPHEAPENTRY32 lphe32, DWORD dwBaseAddr)
{
    LPTHSTATE lpts;
    struct lharray_s lha;
    
    if (!(ValidateHeapEntry32(lphe32))) {
	return FALSE;
    }

    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (!IsValidBlockDataAddr(lphe32, dwBaseAddr)) {
	return FALSE;
    }
    
    
    if (!SafeReadProcessMemory(lpts->ppdb,
			       dwBaseAddr,
			       &lha,
			       sizeof(lha),
			       sizeof(lha))) {

	return FALSE;
    }	

    // Check signature.
    if (lha.lha_signature != LHA_SIGNATURE) {
        DebugOut((DEB_WARN, "lharray_s (%lx) has bad signature.", dwBaseAddr));
	return FALSE;
    }
    if (lha.lha_next && !IsValidBlockDataAddr(lphe32, (DWORD)lha.lha_next)) {
        DebugOut((DEB_WARN, "lharray_s (%lx) has bad next link.", dwBaseAddr));
	return FALSE;
    }
	
    lpts->curlha = lha;
    lpts->curlhaaddr = dwBaseAddr;
    return TRUE;	
    
} 








/*---------------------------------------------------------------------------
 * Insert a handle value to be suppressed when reading fixed blocks later.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY InsertSuppress(LPHEAPENTRY32 lphe32, DWORD dwSupp)
{
    LPTHSTATE lpts;
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (!(lpts->lpdwSuppress)) {
#ifdef DEBUG
	DebugOut((DEB_ERR, "Internal error: lpdwSuppress == NULL."));
#endif
	return FALSE;
    }
    if (lpts->nSuppUsed >= lpts->nSuppAvail) {
#ifdef DEBUG
	DebugOut((DEB_ERR, "Internal error: lpdwSuppress too small."));
#endif
	return FALSE;
    }
    lpts->lpdwSuppress[lpts->nSuppUsed++] = dwSupp;
    return TRUE;

}


/*---------------------------------------------------------------------------
 * Validate and decode a heap block header.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY DissectBlockHdr(LPHEAPENTRY32 lphe32,
			       DWORD	     dwAddr,
			       DWORD	  *lpdwSize,
			       DWORD	  *lpdwFlags,
			       DWORD      *lpdwAddr)
{
    DWORD dwHdr;
    LPTHSTATE lpts;
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (!IsValidBlockHdrAddr(lphe32, dwAddr)) {
	return FALSE;
    }
    
    *lpdwFlags = HP_SIGNATURE ^ ((DWORD)0xffffffff);
    
    if (!SafeReadProcessMemory(lpts->ppdb,
			       dwAddr,
			       &dwHdr,
			       sizeof(dwHdr),
			       sizeof(DWORD))) {
	return FALSE;
    }
    
    if ( (dwHdr & HP_SIGBITS) != HP_SIGNATURE ) {
	return FALSE;
    }
    
    *lpdwSize  = dwHdr & HP_SIZE;
    *lpdwFlags = dwHdr & HP_FLAGS;
    *lpdwAddr  = dwAddr + ( (dwHdr & HP_FREE) ? 
			   sizeof(struct freeheap_s) :
			   sizeof(struct busyheap_s) );
    
    if (*lpdwSize != 0 &&
	!IsValidBlockHdrAddr(lphe32, dwAddr + (*lpdwSize))) {
	return FALSE;
    }
    
    
    return TRUE;

}


/*---------------------------------------------------------------------------
 * Check if we're at the end of the heap (heap is terminated by a 
 * busy block of size 0).
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AtEndOfHeap32(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (lpts->dwMode != THM_FIXEDHANDLES) {
	return FALSE;
    }
    
    return (!((lpts->dwBlkFlags) & HP_FREE) && 
	    (lpts->dwBlkSize) == 0);
}



/*---------------------------------------------------------------------------
 * Internal routine (maybe make it an api?). Deallocate all internal
 * state used for heap-walking.
 *---------------------------------------------------------------------------*/
VOID KERNENTRY RealHeap32End(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;

    if (!(ValidateHeapEntry32(lphe32))) {
	return;
    }
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    // In case someone calls this after they've fallen off the end.
    if (lpts == NULL) {
	return;
    }
    EnterMustComplete();
    if (lpts->pcrst) {
	DisposeCrst(lpts->pcrst);
	lpts->pcrst = NULL;
    }
    LeaveMustComplete();
    if (lpts->lpdwSuppress) {
	FKernelFree(lpts->lpdwSuppress);
	lpts->lpdwSuppress = NULL;
    }
    FKernelFree(lpts);
    lphe32->dwResvd = 0;
    
    FillBytes(( (char*)lphe32 ) + 4, sizeof(HEAPENTRY32) - 4, 0);

}


/*---------------------------------------------------------------------------
 * Copy current heap object into HEAPENTRY32 for caller's consumption.
 * To skip this object, set *pfInteresting to FALSE.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY CopyIntoHeap32Entry(LPHEAPENTRY32 lphe32, BOOL *pfInteresting)
{
    LPTHSTATE lpts;
    
    *pfInteresting = TRUE;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    switch (lpts->dwMode) {
	
	case THM_LHANDLES: {
	    DWORD     dwSize;
	    DWORD     dwFlags;
	    DWORD     dwAddr;
	    DWORD     dwHnd;

	    struct lhandle_s *plh;
	    
	    plh = &(lpts->curlha.lha_lh[lpts->nNextLH]);
	    
	    if (plh->lh_signature == LH_FREESIG) {
		*pfInteresting = FALSE;
		return TRUE;
	    }
	    
	    if (plh->lh_signature != LH_BUSYSIG) {
                DebugOut((DEB_WARN, "lhandle_s has bad signature."));
		return FALSE;
	    }
	    
	    dwHnd = ( (DWORD)(&(plh->lh_pdata)) ) - 
		    ( (DWORD)(&(lpts->curlha)) ) +
		    lpts->curlhaaddr;
	    

	    
	    if (!plh->lh_pdata) {
		// Discarded handle.
		lphe32->hHandle       = (HANDLE)dwHnd;
		lphe32->dwAddress     = 0;
		lphe32->dwBlockSize   = 0;
		lphe32->dwFlags       = LF32_MOVEABLE;
		lphe32->dwLockCount   = (DWORD)(plh->lh_clock);
		return TRUE;
	    }
	    if (!DissectBlockHdr(lphe32, 
				 ( (DWORD)(plh->lh_pdata) ) - 4 - sizeof(struct busyheap_s),
				 &dwSize,
				 &dwFlags,
				 &dwAddr
				 )) {
		return FALSE;   // This will be caught someplace else.
	    }
	    if (dwFlags & HP_FREE) {
                DebugOut((DEB_WARN, "Local handle points to freed block!"));
		return FALSE;
	    }
	    
	    if (!InsertSuppress(lphe32,
				dwAddr-sizeof(struct busyheap_s))) {
		return FALSE;
	    }
	    
	    lphe32->hHandle       = (HANDLE)dwHnd;
	    lphe32->dwAddress     = dwAddr + 4;
	    lphe32->dwBlockSize   = dwSize - sizeof(struct busyheap_s) - 4;
	    lphe32->dwFlags       = LF32_MOVEABLE;
	    lphe32->dwLockCount   = (DWORD)(plh->lh_clock);
			     
	    return TRUE;

	    
	}

	case THM_FIXEDHANDLES: {
	    
	    
	    if ((lpts->dwBlkFlags) & HP_FREE) {
		lphe32->hHandle     = NULL;
		lphe32->dwAddress   = lpts->dwBlkAddr;
		lphe32->dwBlockSize = lpts->dwBlkSize - sizeof(struct freeheap_s);
		lphe32->dwFlags     = LF32_FREE;
		lphe32->dwLockCount = 0;
	    } else {
		
		// Supress if it's a lharray_s or the target of
		// an lhandle. Opt: we could check the first dword
		// to rule out lots of blocks.
		if (lpts->lpdwSuppress) {
		    DWORD *lpdw, *lpdwEnd;
		    DWORD dwHdrAddr = lpts->lpHBlock;
		    
		    lpdwEnd = &(lpts->lpdwSuppress[lpts->nSuppUsed]);
		    for (lpdw = lpts->lpdwSuppress; lpdw < lpdwEnd; lpdw++) {
			if (dwHdrAddr == *lpdw) {
			    *pfInteresting = FALSE;
			    return TRUE;
			}
		    }
		}
		
		
		lphe32->hHandle     = (HANDLE)(lpts->dwBlkAddr);
		lphe32->dwAddress   = lpts->dwBlkAddr;
		lphe32->dwBlockSize = lpts->dwBlkSize - sizeof(struct busyheap_s);
		lphe32->dwFlags     = LF32_FIXED;
		lphe32->dwLockCount = 0;

	    }
	    
	    return TRUE;
	}
	    
	
	case THM_ERROR:
	  DebugOut((DEB_ERR, "Internal error: Can't get here"));
	  return FALSE;
	
	case THM_DONE:
	  DebugOut((DEB_ERR, "Internal error: Can't get here"));
	  return FALSE;
	    
	
	default:
	  DebugOut((DEB_ERR, "Internal error: Bad lpthstate.dwmode"));
	  return FALSE;
	    
    }
}

/*---------------------------------------------------------------------------
 * Worker routine for AdvanceHeap32(): handles the init case.
 *
 * If the heap is the owning pdb's default heap (determined by
 * comparing hHeap with ppdb->hHeapLocal), point the state to
 * the first lharray_s. Otherwise, point the state to the first heap block.
 * 
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32Init(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    struct lharray_s *lpha;
    DWORD dwNumSupp;
    

    lpts = (LPTHSTATE)(lphe32->dwResvd);

    lpha = lpts->ppdb->plhBlock;
    if (lpts->ppdb->hheapLocal != lpts->hHeap || lpha == NULL) {
	lpts->dwMode = THM_FIXEDHANDLES;
	lpts->lpHBlock = lpts->lpbMin;
 	if (!DissectBlockHdr(lphe32,
			     lpts->lpHBlock,
			     &(lpts->dwBlkSize),
			     &(lpts->dwBlkFlags),
			     &(lpts->dwBlkAddr))) {
	    return FALSE;
	}

	return TRUE;
    }
    
    if (!SafeRdCurLHA(lphe32, (DWORD)lpha)) {
	return FALSE;
    }

    dwNumSupp = (lpts->curlha.lha_membercount + 1) * (1 + CLHGROW);
    if (!(lpts->lpdwSuppress = PvKernelAlloc0(dwNumSupp * sizeof(DWORD)))) {
	return FALSE;
    }
    lpts->nSuppAvail = dwNumSupp * sizeof(DWORD);
    lpts->nSuppUsed  = 0;
    
    if (!(InsertSuppress(lphe32, ((DWORD)lpha) - sizeof(struct busyheap_s)))) {
	return FALSE;
    }
    
    lpts->nNextLH = 0;
    lpts->dwMode = THM_LHANDLES;


    return TRUE;


    
}


/*---------------------------------------------------------------------------
 * Worker routine for AdvanceHeap32(): handles the lhandle case.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32Movable(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    WORD wOldMemberCnt;
    DWORD dwAddrNext;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    if (lpts->nNextLH < CLHGROW-1) {
	lpts->nNextLH++;
	return TRUE;
    }
    
    // End of current lhandle clump reached. Any new ones?
    if (lpts->curlha.lha_next == NULL) {
	// Nope. Go on to fixed handles.
	lpts->dwMode = THM_FIXEDHANDLES;
	lpts->lpHBlock = lpts->lpbMin;
 	if (!DissectBlockHdr(lphe32,
			     lpts->lpHBlock,
			     &(lpts->dwBlkSize),
			     &(lpts->dwBlkFlags),
			     &(lpts->dwBlkAddr))) {
	    return FALSE;
	}
	return TRUE;


    }
    
    // Get next lhandle clump.
    wOldMemberCnt = lpts->curlha.lha_membercount;
    dwAddrNext = (DWORD)(lpts->curlha.lha_next);
    if (!SafeRdCurLHA(lphe32, dwAddrNext)) {
	return FALSE;
    }
    if (lpts->curlha.lha_membercount >= wOldMemberCnt) {
        DebugOut((DEB_WARN, "lha_array clusters in wrong order."));
	return FALSE;
    }
    lpts->nNextLH = 0;


    return TRUE;
    
}


/*---------------------------------------------------------------------------
 * Worker routine for AdvanceHeap32(): handles the fixed block case.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32Fixed(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);

    // Diassect block has already checked monotonocity and range.
    lpts->lpHBlock += lpts->dwBlkSize;
    
    if (!DissectBlockHdr(lphe32, 
			 lpts->lpHBlock,
			 &(lpts->dwBlkSize),
			 &(lpts->dwBlkFlags),
			 &(lpts->dwBlkAddr)
			 )) {
	return FALSE;
    }

    return TRUE;
    
}


/*---------------------------------------------------------------------------
 * Advance the internal state to the next heap object. Validate the
 * next heap object.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY AdvanceHeap32(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    switch (lpts->dwMode) {
	case THM_INIT:
	    return AdvanceHeap32Init(lphe32);
	case THM_LHANDLES:
	    return AdvanceHeap32Movable(lphe32);
	case THM_FIXEDHANDLES:
	    return AdvanceHeap32Fixed(lphe32);
	default:
	    DebugOut((DEB_ERR, "Illegal or unexpected THM mode."));
	    return FALSE;
    }
    
}


/*---------------------------------------------------------------------------
 * Does the real work of heap32next().
 *---------------------------------------------------------------------------*/
VOID KERNENTRY Heap32NextWorker(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    BOOL      fInteresting;
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    
    do {
	if (!AdvanceHeap32(lphe32)) {
	    goto rh_error;
	}
	if (AtEndOfHeap32(lphe32)) {
	    /*
	     *	We might be at the end of the heap, or just at the end of
	     *	this heap segment.  If there is another segment, read its
	     *	header in and process its blocks.
	     */
	    if (lpts->hi.hi_psegnext) {

		lpts->lpbMin = ((DWORD)lpts->hi.hi_psegnext) + sizeof(struct heapseg_s);

		/*
		 *  Read in the next heap segment header and setup our bounds to
		 *  refer to it
		 */
		if (!(SafeReadProcessMemory(lpts->ppdb,
					    (DWORD)lpts->hi.hi_psegnext,
					    &(lpts->hi),
					    sizeof(struct heapseg_s),
					    sizeof(struct heapseg_s)))) {
#ifdef DEBUG
                    DebugOut((DEB_WARN, "Heap32NextWorker(): Invalid or corrupt psegnext: %lx\n", lpts->hi.hi_psegnext));
#endif
		    goto rh_error;
		}


		if (lpts->hi.hi_cbreserve > hpMAXALLOC ||
		    ((lpts->hi.hi_cbreserve) & PAGEMASK)) {
#ifdef DEBUG
                    DebugOut((DEB_WARN, "Heap32NextWorker(): Invalid or corrupt psegnext (3): %lx\n", lpts->lpbMin - sizeof(struct heapseg_s)));
#endif
		    goto rh_error;
		}

		/*
		 *  Setup first block on new segment
		 */
		lpts->lpHBlock = lpts->lpbMin;
		if (!DissectBlockHdr(lphe32,
				     lpts->lpHBlock,
				     &(lpts->dwBlkSize),
				     &(lpts->dwBlkFlags),
				     &(lpts->dwBlkAddr))) {
		    goto rh_error;
		}

	    /*
	     *	If we really are at the end of the heap, we are all done
	     */
	    } else {
		lpts->dwMode = THM_DONE;
		return;
	    }
	}
	fInteresting = TRUE;
	if (!CopyIntoHeap32Entry(lphe32, &fInteresting)) {
	    goto rh_error;
	}
	
    } while (!fInteresting);
    return;
    
    

    
  rh_error:
    lpts->dwMode = THM_ERROR;
    return;
}




/*---------------------------------------------------------------------------
 * Does the real work of Heap32Next(). 
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY RealHeap32Next(LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts;
    DWORD     dwMode;
    
    
    if (!(ValidateHeapEntry32(lphe32))) {
	SetError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }
    
    
    lpts = (LPTHSTATE)(lphe32->dwResvd);
    
    // In case someone calls this after they've fallen off the end.
    if (lpts == NULL) {
	SetError(ERROR_INVALID_PARAMETER);
	return FALSE;
    }

    EnterCrst(lpts->pcrst);
    Heap32NextWorker(lphe32);
    dwMode = lpts->dwMode;
    LeaveCrst(lpts->pcrst);

    
    if (dwMode == THM_ERROR ||
	dwMode == THM_DONE) {

	if (dwMode == THM_ERROR) {
	    DebugOut((DEB_WARN, "Heap32Next detected corrupted or moving heap. Bailing."));
	    SetError(ERROR_INVALID_DATA);
	} else {
	    SetError(ERROR_NO_MORE_FILES);
	}
	RealHeap32End(lphe32);
	return FALSE;
	
    }

    return TRUE;
    
}



/*---------------------------------------------------------------------------
 * Create the internal state used inside HEAPENTRY32.
 *---------------------------------------------------------------------------*/
BOOL KERNENTRY InitHeapEntry32(PPDB ppdb,
			       HANDLE hHeap,
			       LPHEAPENTRY32 lphe32)
{
    LPTHSTATE lpts = NULL;
    CRST     *pcrst = NULL;
    
    if (!ValidateHeapEntry32(lphe32)) {
	return FALSE;
    }

    EnterMustComplete();

    if (!(lphe32->dwResvd = (DWORD)PvKernelAlloc0(sizeof(THSTATE)))) {
	goto ih_error;
    }
    lpts = (LPTHSTATE)(lphe32->dwResvd);

    if (!(pcrst = lpts->pcrst = NewCrst())) {
	goto ih_error;
    }
    
    lpts->ppdb = ppdb;
    lpts->hHeap = hHeap;
    
    if (!(SafeReadProcessMemory(ppdb,
				(DWORD)hHeap,
				&(lpts->hi),
				sizeof(lpts->hi),
				sizeof(struct heapinfo_s)))) {
#ifdef DEBUG
        DebugOut((DEB_WARN, "Heap32First(): Invalid hHeap: %lx\n", hHeap));
#endif
	goto ih_error;
    }
    
    if (lpts->hi.hi_signature != HI_SIGNATURE) {
#ifdef DEBUG
        DebugOut((DEB_WARN, "Heap32First(): Invalid or corrupt hHeap: %lx\n", hHeap));
#endif
	goto ih_error;
    }
    
    lpts->lpbMin = ( (DWORD)hHeap ) + sizeof(struct heapinfo_s);
    
    if (lpts->hi.hi_cbreserve > hpMAXALLOC ||
	((lpts->hi.hi_cbreserve) & PAGEMASK)) {
#ifdef DEBUG
        DebugOut((DEB_WARN, "Heap32First(): Invalid or corrupt hHeap: %lx\n", hHeap));
#endif
	goto ih_error;
    }
    
    lpts->dwMode = THM_INIT;
    LeaveMustComplete();
    return TRUE;
    

  ih_error:
    if (lpts) {
	FKernelFree(lpts);
    }
    if (pcrst) {
	DisposeCrst(pcrst);
    }
    lphe32->dwResvd = 0;
    LeaveMustComplete();
    return FALSE;
    
}


/***LP	VerifyOnHeap - verifies a given address is on a given heap
 *
 *	Note that no validation is done on the given address except
 *	to check that it is in the range of the heap.
 *
 *	ENTRY:	hheap - heap handle
 *		p - address to verify
 *	EXIT:	0 if not within specified heap, non-zero if on
 */
ULONG INTERNAL
VerifyOnHeap(HHEAP hheap, PVOID p)
{
    struct heapseg_s *pseg;

    /*
     *	Loop through each heap segment and see if the specified address
     *	is within it.
     */
    pseg = (struct heapseg_s *)hheap;
    do {

	if ((unsigned)p > (unsigned)pseg &&
	    (unsigned)p < (unsigned)pseg + pseg->hs_cbreserve) {

	    return(1);	/* found it */
	}
	pseg = pseg->hs_psegnext;
    } while (pseg != 0);

    return(0); /* didn't find it */
}


/***LP  CheckHeapFreeAppHack - See if CVPACK app-hack applies
 *
 *	Check to see if an absolutely sick, disgusting and vomit-inducing
 *	app-hack for link.exe (msvc 1.5) is needed. msvc 1.5. Link.exe
 *	uses the contents of a heap block after it has freed it. 
 *      This routine stack-traces and reads the caller's code
 *	to see if it matches the offending profile. This part is written
 *	in C so we can use try-except.
 */
BOOL KERNENTRY
CheckHeapFreeAppHack(DWORD *lpdwESP, DWORD *lpdwEBP, DWORD dwESI)
{
    BOOL fDoAppHack = FALSE;
    
    _try {
	DWORD *lpdwEIPCaller;
	
	lpdwEIPCaller = (DWORD*)(*lpdwESP);
	if (0xc35de58b == *lpdwEIPCaller) {  // "mov esp,ebp;pop ebp; retd"
	    DWORD *lpdwEIPCallersCaller;
	    lpdwEIPCallersCaller = (DWORD*)(*(lpdwEBP + 1));
	    if (0x8b04c483 == *lpdwEIPCallersCaller &&
		0xf60b0876 == *(lpdwEIPCallersCaller+1)) {
		//"add esp,4; mov esi, [esi+8]; or esi,esi"
		if (dwESI == *(lpdwESP+3)) {
		    fDoAppHack = TRUE;
		}
	    }
	}
    } _except (EXCEPTION_EXECUTE_HANDLER) {
    }
    
    return fDoAppHack;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatejoystick.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    CheckJoyCaps.cpp

 Abstract:

    Check for error return value in joyGetDevCaps and joyGetPos and if found 
    make the structure (2nd parameter to routines) look just like it does under
    Win9x.  It also looks for handles applications that are passing in a size 
    parameter (3rd parameter) to joyGetDevCaps smaller than the current 
    structure size.  Not checking for this condition results in having the 
    applications stack stomped on.

 Notes:

    This is general shim that could be used for any application with WINMM 
    joystick problems.

 History:

    10/02/2000 a-brienw Created
    02/21/2002 mnikkel  Corrected possible buffer overrun when copying in data

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(EmulateJoystick)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(joyGetDevCapsA)
    APIHOOK_ENUM_ENTRY(joyGetPos)
APIHOOK_ENUM_END

/*++

 Hooked joyGetDevCapsA to make sure the JOYCAPS structure matched Win9x when 
 an error was the result of a call to the OS. Also make sure that the call to 
 joyGetDevCaps doesn't stomp on the applications stack by not paying attention 
 to the size passed in by the application. Check the routine joyGetDevCapsA in 
 joy.c in the WINMM code to see what it does.

--*/

MMRESULT
APIHOOK(joyGetDevCapsA)( 
    UINT uJoyID, 
    LPJOYCAPS pjc, 
    UINT cbjc 
    )
{
    MMRESULT ret = JOYERR_PARMS;
    JOYCAPSA JoyCaps;

    static const BYTE val[] = {0x00,0x70,0x6A,0x00,0x18,0xFD,0x6A,0x00,0xF8,0x58,
                               0xF9,0xBF,0x08,0x00,0x00,0x00,0xD0,0x5A,0x00,0x80,
                               0x00,0x00,0x00,0x00,0xC4,0x2F,0x73,0x81,0x00,0x00,
                               0x5A,0x00,0x18,0xFD,0x6A,0x00,0xF8,0x58,0xF9,0xBF,
                               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,
                               0x00,0x00,0x52,0xD7,0x40,0x00,0x00,0x00,0x00,0x00,
                               0xC4,0x2F,0x73,0x81,0x00,0x00,0x5A,0x00,0x03};

    if (!IsBadWritePtr(pjc, cbjc) && cbjc > 0)
    {
        ret = ORIGINAL_API(joyGetDevCapsA)(
                    uJoyID, (JOYCAPS *)&JoyCaps, sizeof(JOYCAPSA));
        
        if (ret == JOYERR_NOERROR)
        {
            // make sure the joycaps will fit in the supplied buffer
            DWORD dwSize = sizeof(JOYCAPSA);
            if (cbjc < dwSize)
            {
                dwSize = cbjc;
                LOGN( eDbgLevelWarning, "[APIHook_joyGetDevCapsA] Buffer too small, fixing");
            }

            memcpy(pjc, &JoyCaps, dwSize);
        }
        else
        {
            // make sure the joycaps will fit in the supplied buffer
            DWORD dwSize = ARRAYSIZE(val);
            if (cbjc < dwSize)
            {
                dwSize = cbjc;
                LOGN( eDbgLevelWarning, "[APIHook_joyGetDevCapsA] Buffer too small, fixing");
            }        
            //
            // Make the return structure look just like Win9x under error 
            // conditions without this CandyLand Adventure from Hasbro Interactive 
            // will do a divide by 0 during start up. Note these values were copied
            // verbatim from Win9x.
            //
            memcpy(pjc, &val, dwSize);
            DPFN( eDbgLevelSpew, "[APIHook_joyGetDevCapsA] Joystick error, returning Win9x buffer");
        }
    }
    else
    {
        DPFN( eDbgLevelError, "[APIHook_joyGetDevCapsA] Invalid buffer");
    }

    return ret;
}

/*++

 Hooked joyGetPos to make sure the JOYINFO structure matched Win9x when an error 
 was the result of a call to the OS. 
 
--*/

MMRESULT
APIHOOK(joyGetPos)(
    UINT uJoyID,
    LPJOYINFO pji
    )
{
    BYTE *bp;
    MMRESULT ret;
    
    ret = ORIGINAL_API(joyGetPos)(uJoyID, pji);

    if (ret != JOYERR_NOERROR)
    {
        if (!IsBadWritePtr(pji, sizeof(JOYINFO)))
        {
            //
            // Make the return structure look just like Win9x under error 
            // conditions.
            // 

            bp = (BYTE *)pji;

            memset(bp, 0, sizeof(JOYINFO));

            bp[0] = 0x01;
            bp[5] = 0x30;

            DPFN( eDbgLevelSpew, "[APIHook_joyGetPos] Joystick error, returning Win9x buffer");
        }
        else
        {
            DPFN( eDbgLevelError, "[APIHook_joyGetPos] Invalid buffer");
        }
    }

    return ret;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WINMM.DLL, joyGetDevCapsA)
    APIHOOK_ENTRY(WINMM.DLL, joyGetPos)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateheap_support.c ===
#include "EmulateHeap_kernel32.h"

HANDLE hheapKernel = 0;

PDB pdbCur;
PDB *ppdbCur = &pdbCur;
PDB **pppdbCur = &ppdbCur;

/***SN	PageCommit - commit physical pages to a specified linear address
 *
 *	The entire target region must have been reserved by a single previous
 *	call to PageReserve.
 *
 *	If PC_LOCKED, PC_LOCKEDIFDP, or PC_FIXED are passed into PageCommit,
 *	then all of the pages in the specified range must currently uncommitted.
 *	If none of those flags are specified, then any existing
 *	committed pages in the range will be unaffected by this call and an
 *	error will not be returned.  However, even though it is allowed,
 *	calling PageCommit on a range containing already committed memory
 *	should be avoided because it is waste of time.
 *
 *	ENTRY:	page - base virtual page number to start commit at
 *		npages - number of pages to commit
 *		hpd - handle to pager descriptor (returned from PagerRegister)
 *		      or one of these special value:
 *			PD_ZEROINIT - swappable zero-initialized
 *			PD_NOINIT - swappable uninitialized
 *			PD_FIXED - fixed uninitialized (must also pass in
 *				   PC_FIXED flag)
 *			PD_FIXEDZERO - fixed zero-initialized (must also pass
 *				       in PC_FIXED flag)
 *		pagerdata - a single dword to be stored with the page(s) for
 *			    use by the pager.  If one of the special pagers
 *			    listed above is used for the "hpd" parameter, then
 *			    this parameter is reserved and should be zero.
 *		flags - PC_FIXED - page are created permanently locked
 *			PC_LOCKED - pages are created present and locked
 *			PC_LOCKEDIFDP - page are locked if swapping is via DOS
 *			PC_STATIC - allow commit in AR_STATIC object
 *			PC_USER - make the pages ring 3 accessible
 *			PC_WRITEABLE - make the pages writeable
 *			PC_INCR - increment "pagerdata" once for each page.  If
 *				  one of the special pagers listed above is used
 *				  for the "hpd" parameter, then this flags
 *				  should not be specified.
 *			PC_PRESENT - make the pages present as they are committed
 *				(not needed with PC_FIXED or PC_LOCKED)
 *			PC_DIRTY - mark the pages as dirty as they are committed
 *				(ignored if PC_PRESENT, PC_FIXED or PC_LOCKED
 *				 isn't specified)
 *	EXIT:	non-zero if success, 0 if failure
 */
ULONG EXTERNAL
PageCommit(ULONG page, ULONG npages, ULONG hpd, ULONG pagerdata, ULONG flags)
{
    return (ULONG_PTR) VirtualAlloc((LPVOID)(page * PAGESIZE), npages * PAGESIZE, MEM_COMMIT, PAGE_READWRITE);
}

/***SN	PageDecommit - decommit physical pages from a specific address
 *
 *	The pages must be within an address range previously allocated
 *	by a single call to PageReserve.  Though it is not an error to
 *	call PageDecommit on a range including pages which are already
 *	decommitted, such behavoir is discouraged because it is a waste of time.
 *
 *	ENTRY:	page - virtual page number of first page to decommit
 *		npages - number of pages to decommit
 *		flags - PC_STATIC - allow decommit in AR_STATIC object
 *	EXIT:	non-zero if success, else 0 if failure
 */
ULONG EXTERNAL
PageDecommit(ULONG page, ULONG npages, ULONG flags)
{
    // PREFAST - This generates a PREFAST error asking us to use the MEM_RELEASE flag
    //           We do not want that and hence this error can be ignored.
    return (ULONG) VirtualFree((LPVOID)(page * PAGESIZE), npages * PAGESIZE, MEM_DECOMMIT);
}
    
/***SN	PageReserve - allocate linear address space in the current context
 *
 *	The address range allocated by PageReserve is not backed by any
 *	physical memory.  PageCommit, PageCommitPhys, or PageCommitContig
 *	should be called before actually touching a reserved region.
 *
 *	Optionally, page permission flags (PC_WRITEABLE and PC_USER) may be
 *	passed into this service.  The flags are not acted on in any way
 *	(because uncommitted memory is always inaccessible) but they are stored
 *	internally by the memory manager.  The PageQuery service returns these
 *	permissions in the mbi_AllocationProtect field of its information
 *	structure.
 *
 *	ENTRY:	page - requested base address of object (virtual page number)
 *		       or a special value:
 *			PR_PRIVATE - anywhere in current ring 3 private region
 *			PR_SHARED - anywhere in the ring 3 shared region
 *			PR_SYSTEM - anywhere in the system region
 *		npages - number of pages to reserve
 *		flags - PR_FIXED - so PageReAllocate will not move object
 *			PR_STATIC - don't allow commits, decommits or frees
 *				    unless *_STATIC flag is passed in
 *			PR_4MEG - returned address must be 4mb aligned
 *				  (this flag is ignored if a specific address
 *				   is requested by the "page" parameter)
 *			PC_WRITEABLE, PC_USER - optional, see above
 *
 *	EXIT:	linear address of allocated object or -1 if error
 */
ULONG EXTERNAL
PageReserve(ULONG page, ULONG npages, ULONG flags)
{
    ULONG uRet;

    if ((page == PR_PRIVATE) ||
        (page == PR_SHARED) ||
        (page == PR_SYSTEM))
    {
        page = 0;
    }

    uRet = (ULONG) VirtualAlloc((LPVOID)(page * PAGESIZE), npages * PAGESIZE, MEM_RESERVE, PAGE_READWRITE);

    if (!uRet)
    {
        uRet = -1;
    }

    return uRet;
}

/***SO	PageFree - De-reserved and de-commit an entire memory object
 *
 *	ENTRY:	laddr - linear address (handle) of base of object to free
 *		flags - PR_STATIC - allow freeing of AR_STATIC object
 *	EXIT:	non-0 if success, 0 if failure
 *
 */
ULONG EXTERNAL
_PageFree(ULONG laddr, ULONG flags)
{
    return VirtualFree((LPVOID) laddr, 0, MEM_RELEASE);
}


KERNENTRY 
HouseCleanLogicallyDeadHandles(VOID)
{
    return 0;
}

CRITICAL_SECTION *
NewCrst()
{
    CRITICAL_SECTION *lpcs = (CRITICAL_SECTION *) VirtualAlloc(0, sizeof(CRITICAL_SECTION), MEM_COMMIT, PAGE_READWRITE);
    
    if (lpcs)
    {
        InitializeCriticalSection(lpcs);
    }

    return lpcs;
}

VOID
DisposeCrst(CRITICAL_SECTION *lpcs)
{
    if (lpcs)
    {
        DeleteCriticalSection(lpcs);
        VirtualFree(lpcs, 0, MEM_RELEASE);
    }
}

DWORD KERNENTRY 
GetAppCompatFlags(VOID)
{
    return 0;
}

VOID APIENTRY 
MakeCriticalSectionGlobal(LPCRITICAL_SECTION lpcsCriticalSection)
{
}

BOOL KERNENTRY
ReadProcessMemoryFromPDB(
    PPDB ppdb,
    LPVOID lpBaseAddress,
    LPVOID lpBuffer,
    DWORD nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    return ReadProcessMemory(
        GetCurrentProcess(), 
        lpBaseAddress,
        lpBuffer,
        nSize,
        lpNumberOfBytesRead);
}

BOOL WINAPI 
vHeapFree(
    HANDLE hHeap, 
    DWORD dwFlags, 
    LPVOID lpMem
    )
{
    return HeapFree((HHEAP)hHeap, dwFlags, (LPSTR) lpMem);
}

BOOL
_HeapInit()
{
    ZeroMemory(&pdbCur, sizeof(PDB));
    pdbCur.hheapLocal = _HeapCreate(HEAP_SHARED, 0, 0);
    hheapKernel = pdbCur.hheapLocal;
    return (BOOL)(pdbCur.hheapLocal);
}

HANDLE
_GetProcessHeap(void)
{
    return GetCurrentPdb()->hheapLocal;
}

BOOL 
_IsOurHeap(HANDLE hHeap) 
{
    if (!IsBadReadPtr(hHeap, sizeof(HANDLE)))
    {
        return ((struct heapinfo_s *) hHeap)->hi_signature == HI_SIGNATURE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateprinter.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   EmulatePrinter.cpp

 Abstract:

    This is a general purpose shim to fix all problems we have seen
    that are remotely connected with printers.  The shim fixes the
    following:

    1) Apps call EnumPrinters passing only PRINTER_ENUM_LOCAL but expect to see
       network printers as well. For some reason Win9x enumerates network
       printers as well when this API is called with only PRINTER_ENUM_LOCAL set.

    2) Apps call EnumPrinters passing only PRINTER_ENUM_DEFAULT.  This works
       properly in win98, however the option does not exist in w2k.  This
       API performs the equivalent.

    3) EnumPrinters Level 5 is not really supported on NT.  This API calls
       Level 2 and munges the data into a level 5 structure.

    4) Win9x ignores pDefault parameter for OpenPrinter. Some native Win9x apps
       are unaware about this and assume it is safe to use PRINTER_ALL_ACCESS
       value for DesiredAccess flag, member of pDefault parameter, to open either
       local printer or remote printer server. But Windows NT requires
       SERVER_ALL_ACCESS set for this flag to access remote printer server.
       To emulate Win9x behavior, we override pDefault with NULL value.

    5) If an app calls one of several print APIs with a NULL printer name,
       looks up and supplies the default printer name, or derives it from other params.

    6) Verifies a correct handle was passed to SetPrinter.  Win98 does this
       at the start and if its a bad handle never uses the passed Information,
       however w2k does not check the handle till after looking at the information.
       This can cause an error if Level is 2 and the print buffer is null due to
       a missing check in SetPrinterA. (note: this was fixed in whistler).

    7) Verifies that the stack is correct after the proc set in SetAbortProc is
       called.

    8) Verifies that an initialized DEVMODEA has been passed to ResetDCA.

    9) Checks GetProfileStringA for a WINDOWS DEVICE (i.e. printer).  If one is
       requested then make sure the string is not being truncated, if it is then
       save the full printer name for later use.

   10) Checks for a -1 in the nFromPage for PrintDlgA and corrects it to a zero.
       Note: the OS should handle this as per the manual, however print team no-fixed it
             as too risky to change since -1 is a special value in their code.

 Notes:

    This is a general purpose shim.  This code from this shim was originally
    in two seperate shims enumnetworkprinters and handlenullprintername.

    Also added another SHIM EmulateStartPage to this.

 History:

    11/08/00   mnikkel       created
    12/07/00   prashkud      Added StartPage to this.
    01/25/01   mnikkel       Removed W routines, they were causing problems
                             and were not needed.
    02/07/01   mnikkel       Added check for too long a string, removed fixed printer
                             name sizes.
   02/27/2001  robkenny      Converted to use tcs.h
   05/21/2001  mnikkel       Added PrintDlgA check
   09/13/2001  mnikkel       Changed so that level 5 data being created from Level 2
                             data is only done on win2k.  Level 5 data was fixed for XP.
                             Also added check so shim works with printers shared out on
                             win9X while running on XP.
   12/15/2001  mnikkel       Corrected bug in shim where default printer flag was not
                             being set in enumprintersa.
   02/20/2002  mnikkel       Major cleanup to remove buffer overrun possibilities.
                             Added check for No printer in GetProfileString routine

--*/

#include "precomp.h"
#include <commdlg.h>

IMPLEMENT_SHIM_BEGIN(EmulatePrinter)
#include "ShimHookMacro.h"

#define MAX_PRINTER_NAME    221
#define MAX_DRIVERPORT_NAME  50

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DocumentPropertiesA)
    APIHOOK_ENUM_ENTRY(OpenPrinterA)
    APIHOOK_ENUM_ENTRY(SetPrinterA)
    APIHOOK_ENUM_ENTRY(CreateDCA)
    APIHOOK_ENUM_ENTRY(ResetDCA)
    APIHOOK_ENUM_ENTRY(EnumPrintersA)
    APIHOOK_ENUM_ENTRY(GetProfileStringA)
    APIHOOK_ENUM_ENTRY(SetAbortProc)
    APIHOOK_ENUM_ENTRY(StartPage)
    APIHOOK_ENUM_ENTRY(DeviceCapabilitiesA)
    APIHOOK_ENUM_ENTRY(AddPrinterConnectionA)
    APIHOOK_ENUM_ENTRY(DeletePrinterConnectionA)
    APIHOOK_ENUM_ENTRY(PrintDlgA)
APIHOOK_ENUM_END

typedef int   (WINAPI *_pfn_SetAbortProc)(HDC hdc, ABORTPROC lpAbortProc);

CString g_csFullPrinterName("");
CString g_csPartialPrinterName("");
CRITICAL_SECTION g_critSec;
BOOL g_bWin2k = FALSE;


/*++
    These functions munge data from a Level 2 Information structure
    into a Level 5 information structure.
--*/

BOOL
MungeInfo2TOInfo5_A(
    PRINTER_INFO_2A* pInfo2,
    DWORD cbBuf,
    DWORD dwInfo2Returned,
    PRINTER_INFO_5A* pInfo5,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned)
{
    DWORD dwStringBufferSize = 0;
    LPSTR lpStringBuffer = NULL;

    // Sanity check, should not occur.
    if (pInfo2 == NULL || pInfo5 == NULL)
    {
        return FALSE;
    }

    // First calculate buffer size needed
    for (DWORD i = 0; i < dwInfo2Returned; i++)
    {
        if (pInfo2[i].pPrinterName)
        {
            dwStringBufferSize += strlen(pInfo2[i].pPrinterName);
        }
        dwStringBufferSize++;

        if (pInfo2[i].Attributes & PRINTER_ATTRIBUTE_NETWORK  &&
            !(pInfo2[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) &&
            pInfo2[i].pServerName != NULL &&
            pInfo2[i].pShareName  != NULL)
        {
            dwStringBufferSize += strlen(pInfo2[i].pServerName) + 1;
            dwStringBufferSize += strlen(pInfo2[i].pShareName) + 1;
        }
        else
        {
            if (pInfo2[i].pPortName)
            {
                dwStringBufferSize += strlen(pInfo2[i].pPortName);
            }
            dwStringBufferSize++;
        }
    }

    // set the buffer size needed
    *pcbNeeded = dwInfo2Returned * sizeof(PRINTER_INFO_5A)
               + dwStringBufferSize;

    // verify that buffer passed in is big enough.
    if (cbBuf < *pcbNeeded)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    // Allocate the Level 5 information structure
    lpStringBuffer = ((LPSTR) pInfo5)
                     + dwInfo2Returned * sizeof(PRINTER_INFO_5A);

    // Munge the Level 2 information into the Level 5 structure
    for (i = 0; i < dwInfo2Returned; i++)
    {
        // Copy the printername from level 2 to level 5 structure.
        if (pInfo2[i].pPrinterName)
        {
            if (StringCchCopyA( lpStringBuffer, cbBuf, pInfo2[i].pPrinterName) != S_OK)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }
        }
        else
        {
            if (StringCchCopyA( lpStringBuffer, cbBuf, "") != S_OK)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }
        }
        pInfo5[i].pPrinterName = lpStringBuffer;
        lpStringBuffer += strlen(pInfo2[i].pPrinterName) + 1;

        // Copy in attributes to level 5 structure and set defaults
        pInfo5[i].Attributes = pInfo2[i].Attributes;
        pInfo5[i].DeviceNotSelectedTimeout = 15000; // Use defaults here
        pInfo5[i].TransmissionRetryTimeout = 45000; // Use defaults here

        // Check for a network printer
        if (pInfo2[i].Attributes & PRINTER_ATTRIBUTE_NETWORK  &&
            !(pInfo2[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) &&
            pInfo2[i].pServerName != NULL &&
            pInfo2[i].pShareName  != NULL)
        {
            // For network printer create the win98 style port name
            if (StringCchCopyA( lpStringBuffer, cbBuf, pInfo2[i].pServerName) != S_OK ||
                StringCchCatA( lpStringBuffer, cbBuf, "\\" ) != S_OK ||
                StringCchCatA( lpStringBuffer, cbBuf, pInfo2[i].pShareName) != S_OK)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }
        }
        else
        {
            // Not network printer, just copy in port name

            if (pInfo2[i].pPortName)
            {
                if (StringCchCopyA( lpStringBuffer, cbBuf, pInfo2[i].pPortName) != S_OK)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return FALSE;
                }
            }
            else
            {
                if (StringCchCopyA( lpStringBuffer, cbBuf, "") != S_OK)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return FALSE;
                }
            }
        }
        pInfo5[i].pPortName = lpStringBuffer;
        lpStringBuffer += strlen(pInfo2[i].pPortName) + 1;
    }

    // Set the number of structures munged
    *pcbReturned = dwInfo2Returned;

    return TRUE;
}


/*++

   Our Callback routine for SetAbortProc, this routine
   verifies that the stack is correct.

--*/
DWORD g_dwGuardNum = 0xABCD8765;
DWORD g_dwFailed = 0;

BOOL CALLBACK
AbortProcHook(
    ABORTPROC   pfnOld,     // address of old ABORTPROC
    HDC         hdc,        // handle to DC
    int         iError      // error value
    )
{
    DWORD dwRet= 0;


    // Flag to track whether the stack was corrected.
    g_dwFailed = 0;

    // Push a Guard number on the stack, call their
    // abort procedure, then pop the stack till we
    // find our guard number
    __asm
    {
        push ebx
        push ecx

        push g_dwGuardNum
        push iError
        push hdc

        call pfnOld      ; make call to their abort proc

        mov  ecx,16
    loc1:
        dec  ecx
        pop  ebx
        cmp  ebx, g_dwGuardNum
        jne  loc1

        cmp  ecx, 15
        jz   loc2
        mov  g_dwFailed, 1
    loc2:

        pop  ecx
        pop  ebx

        mov  dwRet, eax
    }

    if (g_dwFailed)
    {
        LOGN( eDbgLevelError, "[AbortProcHook] Fixing incorrect calling convention for AbortProc");
    }

    return (BOOL) dwRet;
}

/*++

 This stub function looks up the device name if pDeviceName is NULL

--*/

LONG
APIHOOK(DocumentPropertiesA)(
    HWND        hWnd,
    HANDLE      hPrinter,
    LPSTR       pDeviceName,
    PDEVMODEA   pDevModeOutput,
    PDEVMODEA   pDevModeInput,
    DWORD       fMode
    )
{
    LONG lRet = -1;
    PRINTER_INFO_2A *pPrinterInfo2A = NULL;

    // if they didn't supply a device name, we need to supply it.
    if (!pDeviceName)
    {
        LOGN( eDbgLevelError, "[DocumentPropertiesW] App passed NULL for pDeviceName.");

        if (hPrinter)
        {
            DWORD dwSizeNeeded = 0;
            DWORD dwSizeUsed = 0;

            // get the size
            GetPrinterA(hPrinter, 2, NULL, 0, &dwSizeNeeded);

            if (dwSizeNeeded != 0)
            {

                // allocate memory for the info
                pPrinterInfo2A = (PRINTER_INFO_2A*) malloc(dwSizeNeeded);
                if (pPrinterInfo2A) {

                    // get the info
                    if (GetPrinterA(hPrinter, 2, (LPBYTE)pPrinterInfo2A, dwSizeNeeded, &dwSizeUsed))
                    {
                        pDeviceName = pPrinterInfo2A->pPrinterName;
                    }
                }
            }
        }
    }

    if (!pDeviceName) {
        DPFN( eDbgLevelError, "[DocumentPropertiesA] Unable to gather correct pDeviceName."
                 "Problem not fixed.\n");
    }

    lRet = ORIGINAL_API(DocumentPropertiesA)(
        hWnd,
        hPrinter,
        pDeviceName,
        pDevModeOutput,
        pDevModeInput,
        fMode
        );

    if (pPrinterInfo2A) {
        free(pPrinterInfo2A);
    }

    return lRet;
}


/*++
    These functions handle the case of EnumPrinters being called with the
    PRINTER_ENUM_DEFAULT flag.
--*/

BOOL
EnumDefaultPrinterA(
    PRINTER_INFO_2A* pInfo2,
    LPBYTE  pPrinterEnum,
    DWORD cbBuf,
    DWORD Level,
    PRINTER_INFO_5A* pInfo5,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned
    )
{
    LPSTR  pszName = NULL;
    DWORD dwSize = 0;
    HANDLE hPrinter = NULL;
    BOOL bRet= FALSE;
    DWORD dwInfo2Needed = 0;
    DWORD dwDummy;
    BOOL bDefaultFail = TRUE;

    *pcbNeeded = 0;
    *pcbReturned = 0;

    // get the default printer name
    if (GetDefaultPrinterA(NULL, &dwSize) < 1)
    {
        // Now that we have the right size, allocate a buffer
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pszName = (LPSTR) malloc(dwSize);
            if (pszName)
            {
                // Now get the default printer with the right buffer size.
                if (GetDefaultPrinterA(pszName, &dwSize) > 0)
                {
                    if (OpenPrinterA(pszName, &hPrinter, NULL))
                    {
                        bDefaultFail = FALSE;
                    }
                }
                free(pszName);
            }
        }
    }

    if (bDefaultFail)
    {
        SetLastError(ERROR_INVALID_NAME);
        return FALSE;
    }

    // Printer Level 5 is not really supported on win2k.
    // We'll call Level 2 and munge the data into a level 5 structure.
    if ( g_bWin2k &&
         Level == 5 &&
         pcbNeeded != NULL &&
         pcbReturned != NULL)
    {

        LOGN(eDbgLevelError, "[EnumPrintersA] EnumPrintersA called with Level 5 set."
                 "  Fixing up Level 5 information.");

        // get the size needed for the info2 data
        if (GetPrinterA(hPrinter, 2, NULL, 0, &dwInfo2Needed) == 0 &&
            GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pInfo2 = (PRINTER_INFO_2A *) malloc(dwInfo2Needed);

            // get the info2 data and munge into level 5 structure
            if (pInfo2 &&
                GetPrinterA(hPrinter, 2, (LPBYTE)pInfo2, dwInfo2Needed, &dwDummy))
            {
                bRet= MungeInfo2TOInfo5_A(pInfo2, cbBuf, 1, pInfo5, pcbNeeded, pcbReturned);
            }

            if (pInfo2)
            {
                free(pInfo2);
            }
        }
    }

    // Not win2k or not Level 5 so just get info
    else
    {
        *pcbReturned = 1;
        bRet = GetPrinterA(hPrinter, Level, pPrinterEnum, cbBuf, pcbNeeded);
    }

    // Close the printer
    ClosePrinter(hPrinter);

    return bRet;
}


/*++

 These stub functions check for PRINTER_ENUM_DEFAULT, PRINTER_ENUM_LOCAL
 and Level 5 information structures.

--*/

BOOL
APIHOOK(EnumPrintersA)(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned
    )
{
    BOOL bRet = FALSE;

    DWORD dwInfo2Needed = 0;
    DWORD dwInfo2Returned = 0;
    DWORD dwDummy;

    PRINTER_INFO_2A* pInfo2 = NULL;
    PRINTER_INFO_5A* pInfo5 = (PRINTER_INFO_5A *) pPrinterEnum;

    // Win2k doesn't handle DEFAULT case like win98 did, so we get
    // to do it for them.
    if (Flags == PRINTER_ENUM_DEFAULT )
    {
        LOGN(eDbgLevelError, "[EnumPrintersA] Called with PRINTER_ENUM_DEFAULT flag."
                "  Providing Default printer.");

        bRet = EnumDefaultPrinterA(
                    pInfo2,
                    pPrinterEnum,
                    cbBuf,
                    Level,
                    pInfo5,
                    pcbNeeded,
                    pcbReturned);

        return bRet;
    }

    // For LOCAL also add in CONNECTIONS
    if (Flags == PRINTER_ENUM_LOCAL)
    {
        LOGN( eDbgLevelInfo, "[EnumPrintersA] Called only for "
            "PRINTER_ENUM_LOCAL. Adding PRINTER_ENUM_CONNECTIONS\n");

        Flags = (PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL);
    }

    // Printer Level 5 is not really supported on win2k.
    // We'll call Level 2 and munge the data into a level 5 structure.
    if (g_bWin2k &&
        Level == 5 &&
        pcbNeeded != NULL &&
        pcbReturned != NULL)
    {
        // get the size needed for the info2 data
        ORIGINAL_API(EnumPrintersA)(Flags,
                                      Name,
                                      2,
                                      NULL,
                                      0,
                                      &dwInfo2Needed,
                                      &dwInfo2Returned);

        if (dwInfo2Needed > 0)
        {
            // Printers found, get the info2 data and convert it to info5
            pInfo2 = (PRINTER_INFO_2A *) malloc(dwInfo2Needed);

            if (pInfo2 &&
                ORIGINAL_API(EnumPrintersA)(Flags,
                                              Name,
                                              2,
                                              (LPBYTE) pInfo2,
                                              dwInfo2Needed,
                                              &dwDummy,
                                              &dwInfo2Returned) )
            {
                bRet = MungeInfo2TOInfo5_A( pInfo2,
                                           cbBuf,
                                           dwInfo2Returned,
                                           pInfo5,
                                           pcbNeeded,
                                           pcbReturned);
            }


            if(pInfo2)
            {
                free(pInfo2);
            }
        }
    }
    else
    {
        bRet = ORIGINAL_API(EnumPrintersA)(Flags,
                                           Name,
                                           Level,
                                           pPrinterEnum,
                                           cbBuf,
                                           pcbNeeded,
                                           pcbReturned);
    }

    // For level 2 and level 5 there are some win95 only attributes
    // that need to be emulated.
    if ( (Level == 2 || Level == 5) &&
         bRet &&
         pPrinterEnum != NULL )
    {
        DWORD dwSize;

        GetDefaultPrinterA(NULL, &dwSize);

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            // Now that we have the right size, allocate a buffer
            LPSTR pszName = (LPSTR) malloc(dwSize);

            if (pszName)
            {
                // Now get the default printer with the right buffer size.
                if (GetDefaultPrinterA( pszName, &dwSize ) > 0)
                {
                    if (Level == 2)
                    {
                        if (strcmp( pszName, ((PRINTER_INFO_2A*)pPrinterEnum)->pPrinterName) == 0)
                        {
                            ((PRINTER_INFO_2A*)pPrinterEnum)->Attributes |= PRINTER_ATTRIBUTE_DEFAULT;
                        }
                    }
                    else
                    {
                        if (strcmp( pszName, ((PRINTER_INFO_5A*)pPrinterEnum)->pPrinterName) == 0)
                            ((PRINTER_INFO_5A*)pPrinterEnum)->Attributes |= PRINTER_ATTRIBUTE_DEFAULT;
                    }
                }

                free(pszName);
            }
        }
    }

    return bRet;
}


/*++
   These stub functions substitute the default printer if the pPrinterName is NULL,
   also they set pDefault to NULL to emulate win9x behavior
--*/

BOOL
APIHOOK(OpenPrinterA)(
    LPSTR pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTSA pDefault
    )
{
    LPSTR pszName = NULL;
    DWORD dwSize;
    BOOL bDefaultFail = TRUE;
    BOOL bRet;

    if (!pPrinterName)
    {
        LOGN(eDbgLevelError, "[OpenPrinterA] App passed NULL for pPrinterName, using default printer.");

        // get the default printer name
        if (GetDefaultPrinterA(NULL, &dwSize) < 1)
        {
            // Now that we have the right size, allocate a buffer
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                pszName = (LPSTR) malloc(dwSize);
                if (pszName)
                {
                    // Now get the default printer with the right buffer size.
                    if (GetDefaultPrinterA( pszName, &dwSize ) > 0)
                    {
                        pPrinterName = pszName;
                        bDefaultFail = FALSE;
                    }
                }
            }
        }

        if (bDefaultFail)
        {
            DPFN(eDbgLevelError, "[OpenPrinterA] Unable to gather default pPrinterName.\n");
        }
    }
    else
    {
        CSTRING_TRY
        {
            if (pPrinterName &&
                !g_csPartialPrinterName.IsEmpty() &&
                !g_csFullPrinterName.IsEmpty())
            {
                CString csTemp(pPrinterName);

                if (0 == g_csPartialPrinterName.Compare(csTemp))
                {
                    pPrinterName = g_csFullPrinterName.GetAnsi();
                }
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    if (pPrinterName)
    {
        DPFN( eDbgLevelInfo, "[OpenPrinterA] APIHOOK(OpenPrinterA: pPrinterName: %s\n", pPrinterName);
    }
    DPFN( eDbgLevelInfo, "[OpenPrinterA] APIHOOK(OpenPrinterA: pDefault: %x\n", pDefault);
    DPFN( eDbgLevelInfo, "[OpenPrinterA] APIHOOK(OpenPrinterA: overriding pDefault with NULL value\n");

    bRet = ORIGINAL_API(OpenPrinterA)(
                pPrinterName,
                phPrinter,
                NULL);

    if (pszName)
    {
        free(pszName);
    }

    return bRet;
}

/*++
   This stub function checks to see if the app is asking for the default printer
   string.  If it is it will be returned as follows:

          PrinterName, Driver, Port

    On Win9x, if the printer is a network printer, Port is \\server\share and
    local printers are Port: (ex. LPT1:).
    On Win2k, if the printer is a network printer, Port is NeXX: and local printers
    are Port: .
    We must query EnumPrinters in order to emulate Win9x.  Note:  If the printer
    name is to large for the input buffer we trim it and keep track of the full
    name for later us in other printer APIs.
--*/
DWORD
APIHOOK(GetProfileStringA)(
  LPCSTR lpAppName,        // section name
  LPCSTR lpKeyName,        // key name
  LPCSTR lpDefault,        // default string
  LPSTR lpReturnedString,  // destination buffer
  DWORD nSize               // size of destination buffer
)
{
    LPSTR pszProfileString = NULL;        

    if ( lpAppName &&
         lpKeyName &&
         0 == _stricmp(lpAppName, "windows") &&
         0 == _stricmp(lpKeyName, "device" ) )
    {
        DWORD dwSize = MAX_PRINTER_NAME + MAX_DRIVERPORT_NAME;
        DWORD dwProfileStringLen = 0;

        CSTRING_TRY
        {
            // loop until we have a large enough buffer
            do
            {
                if (pszProfileString != NULL)
                {
                    free(pszProfileString);
                    dwSize += MAX_PATH;
                }

                // Allocate the string
                pszProfileString = (LPSTR) malloc(dwSize);

                if (pszProfileString == NULL)
                {
                    DPFN( eDbgLevelSpew, "[GetProfileStringA] Unable to allocate memory.  Passing through.");

                    //drop through if malloc fails
                    goto DropThrough;
                }

                // Retrieve the profile string
                dwProfileStringLen = ORIGINAL_API(GetProfileStringA)( lpAppName,
                                                                    lpKeyName,
                                                                    lpDefault,
                                                                    pszProfileString,
                                                                    dwSize );

                // exit out if the size gets over 8000 so we don't loop forever
                // if buffer is not large enough dwProfileStringLen will be dwSize - 1 since
                // neither lpAppName nor lpKeyName are NULL
            } while (dwProfileStringLen == dwSize-1 && dwSize < 8000);

            // Zero length profile string, drop through
            if (dwProfileStringLen == 0 || dwSize >= 8000)
            {
                DPFN( eDbgLevelSpew, "[GetProfileStringA] Bad profile string.  Passing through.");
                goto DropThrough;
            }

            // separate out the printer, driver and port name.
            CStringToken csOrig(pszProfileString, L",");
            CString csPrinter;
            CString csDriver;
            CString csPort;
            csOrig.GetToken(csPrinter);
            csOrig.GetToken(csDriver);
            csOrig.GetToken(csPort);

            // If the printer, driver or the port are null, drop through.
            if (csPrinter.IsEmpty() || csDriver.IsEmpty() || csPort.IsEmpty())
            {
                DPFN( eDbgLevelSpew, "[GetProfileStringA] Printer, Driver or Port were null.  Passing through.");

                // Null printerdriver or printerport, drop through
                goto DropThrough;
            }

            DPFN( eDbgLevelError, "[GetProfileStringA] Printer <%S>\n Driver <%S>\n Port <%S>",
                csPrinter.Get(), csDriver.Get(), csPort.Get());

            // Check to see if this is a network printer
            if (0 == csPort.ComparePart(L"Ne", 0, 2))
            {
                PRINTER_INFO_2A* pInfo2 = NULL;
                DWORD dwInfo2Needed = 0;
                DWORD dwInfo2Returned = 0;
                DWORD dwDummy = 0;
                DWORD i = 0;
                BOOL  bEnumPrintersSuccess = FALSE;
                BOOL  bDefaultFound = FALSE;

                // Get the size of the Level 2 structure needed.
                bEnumPrintersSuccess = EnumPrintersA( PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL,
                                                        NULL,
                                                        2,
                                                        NULL,
                                                        0,
                                                        &dwInfo2Needed,
                                                        &dwInfo2Returned );

                // Get the Level 2 Info structure for the printer.
                pInfo2 = (PRINTER_INFO_2A *) malloc(dwInfo2Needed);

                bEnumPrintersSuccess = EnumPrintersA( PRINTER_ENUM_CONNECTIONS | PRINTER_ENUM_LOCAL,
                                                        NULL,
                                                        2,
                                                        (LPBYTE) pInfo2,
                                                        dwInfo2Needed,
                                                        &dwDummy,
                                                        &dwInfo2Returned );

                if (bEnumPrintersSuccess)
                {
                    // Search for default printer in PRINTER_INFO_2 array
                    for (i = 0; i < dwInfo2Returned; i++)
                    {
                        CString  csTemp(pInfo2[i].pPrinterName);
                        if (0 == csPrinter.Compare(csTemp))
                        {
                            bDefaultFound = TRUE;
                            break;
                        }
                    }

                    // Default printer was found
                    if (bDefaultFound)
                    {
                        // Double check that this is a network printer and does not have
                        // local attribute
                        if (pInfo2[i].Attributes & PRINTER_ATTRIBUTE_NETWORK  &&
                            !(pInfo2[i].Attributes & PRINTER_ATTRIBUTE_LOCAL) &&
                            pInfo2[i].pServerName != NULL &&
                            pInfo2[i].pShareName  != NULL)
                        {
                            // Modify the Port to conform with Win9x standards.
                            LOGN( eDbgLevelInfo, "[GetProfileStringA] Altering default printer string returned by GetProfileStringA.\n");
                            DPFN( eDbgLevelInfo, "[GetProfileStringA] Old: %s\n", pszProfileString);

                            csPort = CString(pInfo2[i].pServerName) + L"\\" + CString(pInfo2[i].pShareName);
                        }
                        else
                        {
                            if (pInfo2[i].pPortName == NULL)
                            {
                                // Bad portname, pass through
                                goto DropThrough;
                            }

                            // Just copy in the port
                            csPort = CString(pInfo2[i].pPortName);
                        }
                    }
                }

                free(pInfo2);
            }

            // Create a profile string based off the modifed strings.
            CString csProfile(csPrinter);
            csProfile += L"," + csDriver + L"," + csPort;
            dwProfileStringLen = csProfile.GetLength()+1;

            // If the size they give is big enough, then return.
            if (dwProfileStringLen <= nSize)
            {
                StringCchCopyA( lpReturnedString, nSize, csProfile.GetAnsi());
                DPFN( eDbgLevelInfo, "[GetProfileStringA] Default Printer: %s  Size: %d\n",
                    lpReturnedString, strlen(lpReturnedString));
                return strlen(lpReturnedString);
            }

            // Modify the printer name and keep a global of the original if the printer
            // name causes the profile string output buffer to overflow.
            // If the size we need to reduce it by is greater than the size of
            // the printer name we're screwed, pass through.
            DWORD dwPrinterNameSize = csPrinter.GetLength() - (dwProfileStringLen - nSize);
            if (dwPrinterNameSize > 0)
            {
                DPFN( eDbgLevelInfo, "[GetProfileStringA] Reducing printer name by %d characters.\n",
                    dwProfileStringLen - nSize );
                LOGN( eDbgLevelInfo, "[GetProfileStringA] Reducing printer name by %d characters.\n",
                    dwProfileStringLen - nSize );

                EnterCriticalSection(&g_critSec);

                // save the partial and full printer names for later use.
                g_csPartialPrinterName = csPrinter.Left(dwPrinterNameSize);
                g_csFullPrinterName = csPrinter;

                // Create new profile string based off of partial printer name
                StringCchCopyA( lpReturnedString, nSize, g_csPartialPrinterName.GetAnsi());
                StringCchCatA( lpReturnedString, nSize, ",");
                StringCchCatA( lpReturnedString, nSize, csDriver.GetAnsi());
                StringCchCatA( lpReturnedString, nSize, ",");
                StringCchCatA( lpReturnedString, nSize, csPort.GetAnsi());

                LeaveCriticalSection(&g_critSec);

                DPFN( eDbgLevelInfo, "[GetProfileStringA] Partial: %s\n                    Full: %s\n",
                    g_csPartialPrinterName.GetAnsi(), g_csFullPrinterName.GetAnsi() );
                DPFN( eDbgLevelInfo, "[GetProfileStringA] New: %s  Size: %d\n",
                    lpReturnedString, strlen(lpReturnedString));

                // return the modified string size.
                return strlen(lpReturnedString);
            }
        }
        CSTRING_CATCH
        {
            // Do nothing, just drop through.
        }
    }


DropThrough:

    // Either an error occurred or its not asking for default printer.
    // pass through.
    return ORIGINAL_API(GetProfileStringA)(lpAppName,
                                           lpKeyName,
                                           lpDefault,
                                           lpReturnedString,
                                           nSize);
}


/*++

 This stub function pulls the device name from the DEVMODE if pszDevice is NULL
 and the DC is not for DISPLAY

--*/


HDC
APIHOOK(CreateDCA)(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    CONST DEVMODEA *pdm
    )
{
    // if they've used a NULL device, but included a printer devmode,
    // fill in the device name from the printer devmode
    if (!pszDevice && pdm && (!pszDriver || _stricmp(pszDriver, "DISPLAY") != 0)) {
        LOGN( eDbgLevelError, "[CreateDCA] App passed NULL for pszDevice. Fixing.");
        pszDevice = (LPCSTR)pdm->dmDeviceName;
    }

    return ORIGINAL_API(CreateDCA)(
        pszDriver,
        pszDevice,
        pszPort,
        pdm
        );
}


/*++

 This stub function verifies that ResetDCA hasn't been handed an
 uninitialized InitData.

--*/
HDC
APIHOOK(ResetDCA)(
  HDC hdc,
  CONST DEVMODEA *lpInitData
)
{
    // Sanity checks to make sure we aren't getting garbage
    // or bad values.
    if (lpInitData &&
        (lpInitData->dmSize > sizeof( DEVMODEA ) ||
         ( lpInitData->dmSpecVersion != 0x401 &&
           lpInitData->dmSpecVersion != 0x400 &&
           lpInitData->dmSpecVersion != 0x320 ) ) )
    {
        LOGN( eDbgLevelError, "[ResetDCA] App passed bad DEVMODE structure, nulling.");
        return ORIGINAL_API(ResetDCA)( hdc, NULL );
    }

    return ORIGINAL_API(ResetDCA)( hdc, lpInitData );
}


/*++

 These stub functions verify that SetPrinter has a valid handle
 before proceeding.

--*/
BOOL
APIHOOK(SetPrinterA)(
    HANDLE hPrinter,  // handle to printer object
    DWORD Level,      // information level
    LPBYTE pPrinter,  // printer data buffer
    DWORD Command     // printer-state command
    )
{
    BOOL bRet;

    if (hPrinter == NULL)
    {
        LOGN(eDbgLevelError, "[SetPrinterA] Called with null handle.");
        if (pPrinter == NULL)
            LOGN( eDbgLevelError, "[SetPrinterA] Called with null printer data buffer.");
        return FALSE;
    }
    else if (pPrinter == NULL)
    {
        LOGN(eDbgLevelError, "[SetPrinterA] Called with null printer data buffer.");
        return FALSE;
    }

    bRet= ORIGINAL_API(SetPrinterA)(
                    hPrinter,
                    Level,
                    pPrinter,
                    Command);

    DPFN( eDbgLevelSpew, "[SetPrinterA] Level= %d  Command= %d  Ret= %d\n",
         Level, Command, bRet );

    return bRet;
}


/*++

   This routine hooks the SetAbortProc and replaces their
   callback with ours.
--*/

int
APIHOOK(SetAbortProc)(
    HDC hdc,                // handle to DC
    ABORTPROC lpAbortProc   // abort function
    )
{
    lpAbortProc = (ABORTPROC) HookCallback(lpAbortProc, AbortProcHook);

    return ORIGINAL_API(SetAbortProc)( hdc, lpAbortProc );
}


/*++
    When  apps start printing, they set a viewport
    on the printDC. They then call StartPage which has a different behaviour
    on 9x and WinNT. On 9x, a next call to StartPage resets the DC attributes
    to the default values.However on NT, the next call to StartPage does not
    reset the DC attributes.
        So, on 9x all subsequent output setup and drawing calls are carried
    out with a (0,0) viewport but on NT the viewport is leftover from its
    initial call. Since some apps(eg. Quicken 2000 and 2001) expect the API
    setting the (0,0) viewport,the result will be that the text and the
    lines are clipped on the left and top of the page.

    Here we hook StartPage and call SetViewportOrgEx(hdc, 0, 0, NULL) to
    set the viewport to (0,0) on every call to StartPage to emulate
    the 9x behaviour.

--*/

BOOL
APIHOOK(StartPage)(
    HDC hdc
    )
{

    if (SetViewportOrgEx(hdc, 0, 0, NULL))
    {
        // We have now made the device point(viewport) map to (0, 0).
        LOGN(eDbgLevelInfo, "[StartPage] Setting the device point map to (0,0).");
    }
    else
    {
        LOGN(eDbgLevelError, "[StartPage] Unable to set device point map to (0,0)."
                                              "Failed in a call to SetViewportOrgEx");
    }

    return ORIGINAL_API(StartPage)(hdc);

}

/*++
 This stub function verifies that DeviceCapabilities is using a correct
 printer name.
--*/
DWORD
APIHOOK(DeviceCapabilitiesA)(
  LPCSTR pDevice,
  LPCSTR pPort,
  WORD fwCapability,
  LPSTR pOutput,
  CONST DEVMODE *pDevMode
)
{
    DWORD dwRet;

    CSTRING_TRY
    {
        if ( pDevice && 
            !g_csPartialPrinterName.IsEmpty() &&
            !g_csFullPrinterName.IsEmpty()) 
        {
            CString csTemp(pDevice);

            if (0 == g_csPartialPrinterName.Compare(csTemp))
            {
                pDevice = g_csFullPrinterName.GetAnsi();
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    dwRet= ORIGINAL_API(DeviceCapabilitiesA)( pDevice,
                                             pPort,
                                             fwCapability,
                                             pOutput,
                                             pDevMode );

    if (pDevice && pPort)
    {
        DPFN( eDbgLevelSpew, "[DeviceCapabilitiesA] pDevice= %s  pPort= %s  fwC= %d  Out= %x  RC= %d\n",
             pDevice, pPort, fwCapability, pOutput, dwRet );
    }
    else
    {
        DPFN( eDbgLevelSpew, "[DeviceCapabilitiesA] fwC= %d  Out= %x  RC= %d\n",
             fwCapability, pOutput, dwRet );
    }

    return dwRet;
}

/*++
 This stub function verifies that AddPrinterConnection is using a correct
 printer name.
--*/
BOOL
APIHOOK(AddPrinterConnectionA)(
  LPSTR pName
)
{
    CSTRING_TRY
    {
        if (pName && 
            !g_csPartialPrinterName.IsEmpty() &&
            !g_csFullPrinterName.IsEmpty()) 
        {
            CString csTemp(pName);

            if (0 == g_csPartialPrinterName.Compare(csTemp))
            {
                pName = g_csFullPrinterName.GetAnsi();
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(AddPrinterConnectionA)(pName);
}

/*++
 This stub function verifies that DeletePrinterConnection is using a correct
 printer name.
--*/
BOOL
APIHOOK(DeletePrinterConnectionA)(
  LPSTR pName
)
{
    CSTRING_TRY
    {
        if (pName && 
            !g_csPartialPrinterName.IsEmpty() &&
            !g_csFullPrinterName.IsEmpty()) 
        {
            CString csTemp(pName);

            if (0 == g_csPartialPrinterName.Compare(csTemp))
            {
                pName = g_csFullPrinterName.GetAnsi();
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(DeletePrinterConnectionA)(pName);
}

/*++
 This stub function verifies that PrintDlgA is using a correct
 nFromPage and nToPage.
--*/

BOOL
APIHOOK(PrintDlgA)(
  LPPRINTDLG lppd
)
{
    // check nFromPage and nToPage for legal values.
    if (lppd)
    {
        DPFN(eDbgLevelSpew, "[PrintDlgA] nFromPage = %d  nToPage = %d",
              lppd->nFromPage, lppd->nToPage);

        if (lppd->nFromPage == 0xffff)
        {
            lppd->nFromPage = 0;
            DPFN( eDbgLevelInfo, "[PrintDlgA] Setting nFromPage to 0." );
        }

        if (lppd->nToPage == 0xffff)
        {
            lppd->nToPage = lppd->nFromPage;
            DPFN( eDbgLevelInfo, "[PrintDlgA] Setting nToPage to %d.", lppd->nFromPage );
        }
    }

    return ORIGINAL_API(PrintDlgA)(lppd);
}


/*++

 Register hooked functions

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        OSVERSIONINFOEX osvi;
        BOOL bOsVersionInfoEx;

        if (!InitializeCriticalSectionAndSpinCount(&g_critSec,0x80000000))
        {
            return FALSE;
        }

        // Check to see if we are under win2k
        ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi);

        if(bOsVersionInfoEx)
        {
            if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
                 osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0 )
            {
                g_bWin2k = TRUE;
            }
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(WINSPOOL.DRV, DocumentPropertiesA);
    APIHOOK_ENTRY(WINSPOOL.DRV, OpenPrinterA);
    APIHOOK_ENTRY(WINSPOOL.DRV, SetPrinterA);
    APIHOOK_ENTRY(WINSPOOL.DRV, EnumPrintersA);
    APIHOOK_ENTRY(WINSPOOL.DRV, OpenPrinterA);
    APIHOOK_ENTRY(WINSPOOL.DRV, DeviceCapabilitiesA);
    APIHOOK_ENTRY(WINSPOOL.DRV, AddPrinterConnectionA);
    APIHOOK_ENTRY(WINSPOOL.DRV, DeletePrinterConnectionA);

    APIHOOK_ENTRY(COMDLG32.DLL, PrintDlgA);

    APIHOOK_ENTRY(KERNEL32.DLL,GetProfileStringA);

    APIHOOK_ENTRY(GDI32.DLL, CreateDCA);
    APIHOOK_ENTRY(GDI32.DLL, ResetDCA);
    APIHOOK_ENTRY(GDI32.DLL, SetAbortProc);
    APIHOOK_ENTRY(GDI32.DLL, StartPage);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateplaysound.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulatePlaySound.cpp

 Abstract:

    If an app calls PlaySound with a SND_LOOP flag, the sould plays 
    continuously until PlaySound is called with a NULL sound name.  Win9x will 
    automatically stop the sound if a different sound is played.  This shim 
    will catch all PlaySound calls, remember the current sound and 
    automatically stop it if a different sound is to be played.

 History:

    04/05/1999 robkenny

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulatePlaySound)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PlaySoundA)
    APIHOOK_ENUM_ENTRY(PlaySoundW)
    APIHOOK_ENUM_ENTRY(sndPlaySoundA)
    APIHOOK_ENUM_ENTRY(sndPlaySoundW)
APIHOOK_ENUM_END

/*++

 Fix the flags

--*/

BOOL
APIHOOK(PlaySoundA)(
    LPCSTR  pszSound,  
    HMODULE hmod,     
    DWORD   fdwSound    
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fdwSound = 0;
    }

    return ORIGINAL_API(PlaySoundA)(pszSound, hmod, fdwSound);
}

/*++

 Fix the flags

--*/

BOOL
APIHOOK(PlaySoundW)(
    LPCWSTR pszSound,  
    HMODULE hmod,     
    DWORD   fdwSound    
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fdwSound = 0;
    }

    return ORIGINAL_API(PlaySoundW)(pszSound, hmod, fdwSound);
}

/*++

 Fix the flags

--*/

BOOL
APIHOOK(sndPlaySoundA)(
    LPCSTR pszSound,  
    UINT   fuSound       
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fuSound = 0;
    }

    return ORIGINAL_API(sndPlaySoundA)(pszSound, fuSound);
}

/*++

 Fix the flags.

--*/

BOOL
APIHOOK(sndPlaySoundW)(
    LPCWSTR pszSound,  
    UINT    fuSound       
    )
{
    //
    // Force the flags to 0 if they want to stop the current sound.
    //

    if (pszSound == NULL) {
        fuSound = 0;
    }

    return ORIGINAL_API(sndPlaySoundW)(pszSound, fuSound);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, PlaySoundA)
    APIHOOK_ENTRY(WINMM.DLL, PlaySoundW)
    APIHOOK_ENTRY(WINMM.DLL, sndPlaySoundA)
    APIHOOK_ENTRY(WINMM.DLL, sndPlaySoundW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatemissingexe.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateMissingEXE.cpp

 Abstract:

    Win9x had scandskw.exe and defrag.exe in %windir%, NT does not.
    Whistler has a hack in the shell32 for scandisk for app compatability
    purposes.  Whistler can also invoke defrag via 
    "%windir%\system32\mmc.exe %windir%\system32\dfrg.msc".

    This shim redirects CreateProcess and Winexec to execute these two
    substitutes, as well as FindFile to indicate their presence.

 Notes:

    This is a general purpose shim.

 History:

    01/02/2001  prashkud Created
    02/18/2001  prashkud Merged HandleStartKeyword SHIM with this.
    02/21/2001  prashkud Replaced most strings with CString class.                   

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateMissingEXE)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

// Type for the functions that builds the New EXES
typedef BOOL (*_pfn_STUBFUNC)(CString&, CString&, BOOL);

// Main Data structure to hold the New strings
struct REPLACEENTRY {
    WCHAR *OrigExeName;                 // original EXE to be replaced
    _pfn_STUBFUNC pfnFuncName;          // function to call to correct the name
};

CRITICAL_SECTION g_CritSec;
WCHAR *g_szSysDir = NULL;               // system directory for stubs to use

BOOL StubScandisk(CString&, CString&, BOOL);
BOOL StubDefrag(CString&, CString&, BOOL);
BOOL StubStart(CString&, CString&, BOOL);
BOOL StubControl(CString&, CString&, BOOL);
BOOL StubDxDiag(CString&, CString&, BOOL);
BOOL StubWinhlp(CString&, CString&, BOOL);
BOOL StubRundll(CString&, CString&, BOOL);
BOOL StubPbrush(CString&, CString&, BOOL);

// Add variations of these missing Exes like in HandleStartKeyword                             
// Start has been put at the top of the list as there seem to be more apps
// that need the SHIM for this EXE than others. In fact there was a 
// seperate SHIM HandleStartKeyword that was merged with this.
REPLACEENTRY g_ReplList[] = {
    {L"start",        StubStart    },
    {L"start.exe",    StubStart    },    
    {L"scandskw",     StubScandisk },
    {L"scandskw.exe", StubScandisk },
    {L"defrag",       StubDefrag   },
    {L"defrag.exe",   StubDefrag   },
    {L"control",      StubControl  },
    {L"control.exe",  StubControl  },
    {L"dxdiag",       StubDxDiag   },
    {L"dxdiag.exe",   StubDxDiag   },
    {L"winhelp",      StubWinhlp   },
    {L"winhelp.exe",  StubWinhlp   },
    {L"rundll",       StubRundll   },
    {L"rundll.exe",   StubRundll   },
    {L"Pbrush",       StubPbrush   },    
    {L"Pbrush.exe",   StubPbrush   },    
    // Always the last one
    {L"",             NULL         }
};

// Added to merge HandleStartKeyword
// Link list of shell link object this pointers.
struct THISPOINTER
{
    THISPOINTER *next;
    LPCVOID pThisPointer;
};

THISPOINTER *g_pThisPointerList;

/*++

 Function Description:

    Add a this pointer to the linked list of pointers. Does not add if the
    pointer is NULL or a duplicate.

 Arguments:

    IN  pThisPointer - the pointer to add.

 Return Value:

    None

 History:

    12/14/2000 maonis Created

--*/

VOID 
AddThisPointer(
    IN LPCVOID pThisPointer
    )
{
    EnterCriticalSection(&g_CritSec);

    if (pThisPointer)
    {
        THISPOINTER *pPointer = g_pThisPointerList;
        while (pPointer)
        {
            if (pPointer->pThisPointer == pThisPointer)
            {
                return;
            }
            pPointer = pPointer->next;
        }

        pPointer = (THISPOINTER *) malloc(sizeof THISPOINTER);

        if (pPointer)
        {
            pPointer->pThisPointer = pThisPointer;
            pPointer->next = g_pThisPointerList;
            g_pThisPointerList = pPointer;
        }      
    }

    LeaveCriticalSection(&g_CritSec);
}

/*++

 Function Description:

    Remove a this pointer if it can be found in the linked list of pointers. 

 Arguments:

    IN  pThisPointer - the pointer to remove.

 Return Value:

    TRUE if the pointer is found.
    FALSE if the pointer is not found.

 History:

    12/14/2000 maonis Created

--*/

BOOL 
RemoveThisPointer(
    IN LPCVOID pThisPointer
    )
{
    THISPOINTER *pPointer = g_pThisPointerList;
    THISPOINTER *last = NULL;
    BOOL lRet = FALSE;
    
    EnterCriticalSection(&g_CritSec);

    while (pPointer)
    {
        if (pPointer->pThisPointer == pThisPointer)
        {
            if (last)
            {
                last->next = pPointer->next;
            }
            else
            {
                g_pThisPointerList = pPointer->next;
            }

            free(pPointer);
            lRet = TRUE;    
            break;
        }

        last = pPointer;
        pPointer = pPointer->next;
    }

    LeaveCriticalSection(&g_CritSec);
    return lRet;
}


/*++

 We are here because the application name: scandskw.exe, matches the one in the 
 static array. Fill the News for scandskw.exe as: 

    rundll32.exe shell32.dll,AppCompat_RunDLL SCANDSKW

--*/

BOOL
StubScandisk(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL /*bExists*/
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\rundll32.exe";
    csNewCommandLine     = L"shell32.dll,AppCompat_RunDLL SCANDSKW";

    return TRUE;

}

/*++

 We are here because the application name: defrag.exe, matches the one in the 
 static array. Fill the News for .exe as:
    
    %windir%\\system32\\mmc.exe %windir%\\system32\\dfrg.msc

--*/

BOOL
StubDefrag(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL /*bExists*/
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\mmc.exe";

    csNewCommandLine =  g_szSysDir;
    csNewCommandLine += L"\\dfrg.msc";
    return TRUE;
}

/*++

 We are here because the application name: start.exe, matches the one in the 
 static array. Fill the News for .exe as: 
 
    %windir%\\system32\\cmd.exe" "/c start"

 Many applications have a "start.exe" in their current working directories 
 which needs to take precendence over any New we make.

--*/

BOOL
StubStart(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL bExists
    )
{
    //
    // First check the current working directory for start.exe
    //

    if (bExists) {
        return FALSE;
    }

    // 
    // There is no start.exe in the current working directory
    //
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\cmd.exe";
    csNewCommandLine     = L"/d /c start \"\"";

    return TRUE;
}

/*++

 We are here because the application name: control.exe, matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\\system32\\control.exe

--*/

BOOL
StubControl(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL /*bExists*/
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\control.exe";
    csNewCommandLine     = L"";        

    return TRUE;

}

/*++

 We are here because the application name: dxdiag.exe, matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\system32\dxdiag.exe

--*/

BOOL
StubDxDiag(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL /*bExists*/
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\dxdiag.exe";
    csNewCommandLine     = L"";

    return TRUE;
}

/*++

 We are here because the application name: Winhlp.exe, matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\system32\winhlp32.exe

--*/

BOOL
StubWinhlp(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL /*bExists*/
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\winhlp32.exe";
    // Winhlp32.exe needs the app name to be in the commandline.
    csNewCommandLine = csNewApplicationName;        

    return TRUE;
}

/*++

 We are here because the application name: rundll.exe matches the one in the 
 static array. Fill the News for .exe as:
 
    %windir%\system32\rundll32.exe

--*/

BOOL
StubRundll(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL /*bExists*/
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\rundll32.exe";
    csNewCommandLine     = L"";

    return TRUE;
}

/*++

 We are here because the application name: Pbrush.exe matches the one in the 
 static array. Fill the New for .exe as:
 
    %windir%\system32\mspaint.exe

--*/

BOOL
StubPbrush(
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL /*bExists*/
    )
{
    csNewApplicationName = g_szSysDir;
    csNewApplicationName += L"\\mspaint.exe";
    csNewCommandLine     = L"";

    return TRUE;
}

/*++

 GetTitle takes the app path and returns just the EXE name.

--*/

VOID
GetTitle(CString& csAppName,CString& csAppTitle)
{
    csAppTitle = csAppName;
    int len = csAppName.ReverseFind(L'\\');
    if (len)
    {
        csAppTitle.Delete(0, len+1);
    }    
}

/*++

 This is the main function where the New logic happens. This function 
 goes through the static array and fills the suitable New appname and 
 the commandline.

--*/

BOOL
Redirect(
    const CString& csApplicationName, 
    const CString& csCommandLine,
    CString& csNewApplicationName,
    CString& csNewCommandLine,
    BOOL  bJustCheckExePresence
    )
{
    BOOL bRet = FALSE;
    CSTRING_TRY
    {    

        CString csOrigAppName;
        CString csOrigCommandLine;
        BOOL bExists = FALSE;

        AppAndCommandLine AppObj(csApplicationName, csCommandLine);
        csOrigAppName = AppObj.GetApplicationName();
        csOrigCommandLine = AppObj.GetCommandlineNoAppName();

        if (csOrigAppName.IsEmpty())
        {
            goto Exit;
        }

        //
        // Loop through the list of redirectors 
        //
    
        REPLACEENTRY *rEntry = &g_ReplList[0];
        CString csAppTitle;
        GetTitle(csOrigAppName, csAppTitle);    

        while (rEntry && rEntry->OrigExeName[0])
        {
            if (_wcsicmp(rEntry->OrigExeName, csAppTitle) == 0)
            {
                //
                // This final parameter has been added for the merger
                // of HandleStartKeyword Shim. If this is TRUE, we don't
                // go any further but just return.
                //
                if (bJustCheckExePresence)
                {
                    bRet = TRUE;
                    goto Exit;
                }

                //
                // Check if the current working directory contains the exe in question
                //
                WCHAR *szCurrentDirectory = NULL;
                DWORD dwLen = GetCurrentDirectoryW(0, NULL);  // Just to get the length
                // The dwLen got includes the terminating NULL too.
                szCurrentDirectory = (WCHAR*)malloc(dwLen * sizeof(WCHAR));

                if (szCurrentDirectory && 
                    GetCurrentDirectoryW(dwLen, szCurrentDirectory))
                {
                    CString csFullAppName(szCurrentDirectory);
                    csFullAppName += L"\\";
                    csFullAppName += csAppTitle;
                    
                    // Check if the file exists and is not a directory
                    DWORD dwAttr = GetFileAttributesW(csFullAppName);
                    if ((dwAttr != INVALID_FILE_ATTRIBUTES) && 
                        !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
                    {
                        DPFN( eDbgLevelInfo,
                            "[Redirect] %s found in current working directory");
                        bExists = TRUE;
                    }
                    free(szCurrentDirectory);
                }
                else if(szCurrentDirectory)
                {
                    free(szCurrentDirectory);
                }
           
                //
                // We have a match, so call the corresponding function
                //            

                bRet = (*(rEntry->pfnFuncName))(csNewApplicationName,
                        csNewCommandLine, bExists);
                if (bRet) 
                {                
                    //
                    // Append the original command line 
                    //
                    csNewCommandLine += L" ";
                    csNewCommandLine += csOrigCommandLine;                
                }

                // We matched an EXE, so we're done
                break;            
            }

            rEntry++;
        }

        if (bRet) 
        {
            DPFN( eDbgLevelWarning, "Redirected:");
            DPFN( eDbgLevelWarning, "\tFrom: %S %S", csApplicationName, csCommandLine);
            DPFN( eDbgLevelWarning, "\tTo:   %S %S", csNewApplicationName, csNewCommandLine);
        }
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "Not Redirecting: Exception encountered");
        bRet = FALSE;     
    }

Exit:
    return bRet;
}

/*++

 Hooks the CreateProcessA function to see if any News need to be 
 substituted. 

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if ((NULL == lpApplicationName) &&
       (NULL == lpCommandLine))
    {
        // If both are NULL, return FALSE.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    CSTRING_TRY
    {    
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csPassedAppName(lpApplicationName);
        CString csPassedCommandLine(lpCommandLine);
        
        if ((csPassedAppName.IsEmpty()) &&
            (csPassedCommandLine.IsEmpty()))
        {
            goto exit;
        }

        // 
        // Run the list of New stubs: call to the main New routine
        //
        if (Redirect(csPassedAppName, csPassedCommandLine, csNewApplicationName, 
                csNewCommandLine, FALSE))
        {
            LOGN(
                eDbgLevelWarning,
                "[CreateProcessA] \" %s %s \": changed to \" %s %s \"",
                lpApplicationName, lpCommandLine, 
                csNewApplicationName.GetAnsi(), csNewCommandLine.GetAnsi());
        }
        else
        {
            csNewApplicationName = lpApplicationName;
            csNewCommandLine = lpCommandLine;
        }


        // Convert back to ANSI using the GetAnsi() method exposed by the CString class.
        return ORIGINAL_API(CreateProcessA)(
            csNewApplicationName.IsEmpty() ? NULL : csNewApplicationName.GetAnsi(), 
            csNewCommandLine.IsEmpty() ? NULL : csNewCommandLine.GetAnsi(),  
            lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
            dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,             
            lpProcessInformation);

    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[CreateProcessA]:Original API called.Exception occured!");
        
    }

exit:
    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine,
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,             
                lpProcessInformation);
}

/*++

 Hooks the CreateProcessW function to see if any News need to be 
 substituted. 

--*/

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if ((NULL == lpApplicationName) &&
       (NULL == lpCommandLine))
    {
        // If both are NULL, return FALSE.
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;        
    }

    CSTRING_TRY
    {    
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csApplicationName(lpApplicationName);
        CString csCommandLine(lpCommandLine);

        if ((csApplicationName.IsEmpty()) &&
            (csCommandLine.IsEmpty()))
        {
            goto exit;
        }

        // 
        // Run the list of New stubs
        //

        if (Redirect(csApplicationName, csCommandLine, csNewApplicationName, 
                csNewCommandLine, FALSE)) 
        {    
            LOGN(
                eDbgLevelWarning,
                "[CreateProcessW] \" %S %S \": changed to \" %S %S \"",
                lpApplicationName, lpCommandLine, csNewApplicationName, csNewCommandLine);            
        }
        else
        {
            csNewApplicationName = lpApplicationName;
            csNewCommandLine = lpCommandLine;
        }


        return ORIGINAL_API(CreateProcessW)(
            csNewApplicationName.IsEmpty() ? NULL : csNewApplicationName.Get(), 
            csNewCommandLine.IsEmpty() ? NULL : (LPWSTR)csNewCommandLine.Get(),  
            lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
            dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
            lpProcessInformation);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[CreateProcessW] Original API called. Exception occured!");
    }

exit:
    return ORIGINAL_API(CreateProcessW)(lpApplicationName, lpCommandLine, 
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                lpProcessInformation);
}

/*++

 Hooks WinExec to redirect if necessary. 

--*/

UINT
APIHOOK(WinExec)(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    )
{
    if (NULL == lpCmdLine)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_PATH_NOT_FOUND;
    }

    CSTRING_TRY
    {            
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csAppName;
        CString csNewCmdLine;
        CString csCommandLine(lpCmdLine);
        
        if (csCommandLine.IsEmpty())
        {
            goto exit;
        }
        // Check for redirection
        if (Redirect(csAppName, csCommandLine, csNewApplicationName,
                csNewCommandLine, FALSE))
        {
            // Modification for the WinHlp32 strange behaviour
            if (csNewCommandLine.Find(csNewApplicationName.Get()) == -1)
            {
                // If the new Command line does not contain the new application
                // name as the substring, we are here.
                csNewCmdLine = csNewApplicationName;                        
                csNewCmdLine += L" ";
            }
            csNewCmdLine += csNewCommandLine;  

            // Assign to csCommandLine as this can be commonly used      
            csCommandLine = csNewCmdLine;

            LOGN(
                eDbgLevelInfo,
                "[WinExec] \" %s \": changed to \" %s \"",
                lpCmdLine, csCommandLine.GetAnsi());       
        }

        return ORIGINAL_API(WinExec)(csCommandLine.GetAnsi(), uCmdShow);

    }
    CSTRING_CATCH
    {            
        DPFN( eDbgLevelError, "[WinExec]:Original API called.Exception occured!");        
    }

exit:
    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}

/*++

 Hooks the FindFirstFileA function to see if any replacements need to be 
 substituted. This is a requirement for cmd.exe.

--*/

HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    CSTRING_TRY
    {            
        CString csNewApplicationName;
        CString csNewCommandLine;
        CString csFileName(lpFileName);
        CString csAppName;

        // Call the main replacement routine.
        if (Redirect(csFileName, csAppName, csNewApplicationName, csNewCommandLine, FALSE)) 
        {     
            // Assign to csFileName
            csFileName = csNewApplicationName;
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileA] \" %s  \": changed to \" %s \"",
                lpFileName, csFileName.GetAnsi());
        }

        return ORIGINAL_API(FindFirstFileA)(csFileName.GetAnsi(), lpFindFileData);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[FindFirstFileA]:Original API called.Exception occured!");        
        return ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
    }
}

/*++

 Hooks the FindFirstFileW function to see if any replacements need to be 
 substituted. This is a requirement for cmd.exe.

--*/

HANDLE
APIHOOK(FindFirstFileW)(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    CSTRING_TRY
    {    
        CString csNewApplicationName(lpFileName);
        CString csNewCommandLine;
        CString csFileName(lpFileName);
        CString csAppName;
    
        // Call the main replacement routine.
        if (Redirect(csFileName, csAppName, csNewApplicationName, 
                csNewCommandLine, FALSE))
        {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileW] \" %S \": changed to \" %S \"",
                lpFileName, (const WCHAR*)csNewApplicationName);
        }

        return ORIGINAL_API(FindFirstFileW)(csNewApplicationName, lpFindFileData);
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[FindFirstFileW]:Original API called.Exception occured!");
        return ORIGINAL_API(FindFirstFileW)(lpFileName, lpFindFileData);
    }
}

// Added for the merge of HandleStartKeyword

/*++

 Hook IShellLinkA::SetPath - check if it's start, if so change it to cmd and add the 
 this pointer to the list.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetPath)(
    PVOID pThis,
    LPCSTR pszFile
    )
{
    _pfn_IShellLinkA_SetPath pfnSetPath = ORIGINAL_COM( IShellLinkA, SetPath, pThis);

    CSTRING_TRY
    {   
        CString csExeName;
        CString csCmdLine;
        CString csNewAppName;
        CString csNewCmdLine;
        CString cscmdCommandLine(pszFile);

        // Assign the ANSI string to the WCHAR CString
        csExeName = pszFile;
        csExeName.TrimLeft();
        
        // Check to see whether the Filename conatains the "Start" keyword.
        // The last parameter to the Rediect function controls this.
        if (Redirect(csExeName, csCmdLine,  csNewAppName, csNewCmdLine, TRUE))
        {
            // Found a match. We add the this pointer to the list.
            AddThisPointer(pThis);
            DPFN( eDbgLevelInfo, "[SetPath] Changing start.exe to cmd.exe\n");

            // Prefix of new "start" command line, use full path to CMD.EXE                  
            // Append the WCHAR global system directory path to ANSI CString
            cscmdCommandLine = g_szSysDir;
            cscmdCommandLine += L"\\cmd.exe";                   
        }

        return (*pfnSetPath)(pThis, cscmdCommandLine.GetAnsi());
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[SetPath] Original API called. Exception occured!");
        return (*pfnSetPath)(pThis, pszFile);
    }
}

/*++

 Hook IShellLinkA::SetArguments - if the this pointer can be found in the list, remove it
 from the list and add "/d /c start" in front of the original argument list.

--*/

HRESULT STDMETHODCALLTYPE
COMHOOK(IShellLinkA, SetArguments)(
    PVOID pThis,
    LPCSTR pszFile 
    )
{
    _pfn_IShellLinkA_SetArguments pfnSetArguments = ORIGINAL_COM(IShellLinkA, SetArguments, pThis);

    CSTRING_TRY
    {    
        CString csNewFile(pszFile);        
        if (RemoveThisPointer(pThis))
        {
            csNewFile = "/d /c start \"\" ";
            csNewFile += pszFile;

            DPFN( eDbgLevelInfo, "[SetArguments] Arg list is now %S", csNewFile);        
        }

        return (*pfnSetArguments)( pThis, csNewFile.GetAnsi());
    }
    CSTRING_CATCH
    {
        DPFN( eDbgLevelError, "[SetArguments]:Original API called.Exception occured!");
        return (*pfnSetArguments)( pThis, pszFile );
    }  
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        UINT uiLen = GetSystemDirectory(NULL, 0);
        g_szSysDir = (WCHAR*)malloc(uiLen * sizeof(WCHAR));  // This won't be deallocated..
        if (g_szSysDir && !GetSystemDirectory(g_szSysDir, uiLen))
        {
            DPFN( eDbgLevelError, "[Notify] GetSystemDirectory failed");
            return FALSE;
        }

        if (InitializeCriticalSectionAndSpinCount(&g_CritSec, 0x80000000) == FALSE)
        {
            DPFN( eDbgLevelError, "Failed to initialize critical section");
            return FALSE;            
        }
    }
    
    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY_COMSERVER(SHELL32)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetArguments, 11)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateverqueryvalue.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateVerQueryValue.cpp

 Abstract:

    This shim fixes a null version length buffer pointer.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000 jdoherty     Revised coding style.
    11/28/2000 jdoherty     Converted to framework version 2

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateVerQueryValue)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VerQueryValueA) 
    APIHOOK_ENUM_ENTRY(VerQueryValueW) 
APIHOOK_ENUM_END

/*++

 Fix the null version length buffer pointer.

--*/

BOOL 
APIHOOK(VerQueryValueA)(
    const LPVOID pBlock, 
    LPSTR lpSubBlock, 
    LPVOID *lplpBuffer, 
    PUINT puLen 
    )
{
    BOOL bRet;
    UINT nLen;

    if (!puLen) {
        puLen = &nLen;
        DPFN( eDbgLevelError, "[APIHook_VerQueryValueA] Null puLen param. Fixed.\n");
    }

    bRet = ORIGINAL_API(VerQueryValueA)( 
        pBlock, 
        lpSubBlock, 
        lplpBuffer, 
        puLen);

    return bRet;
}

/*++

 Fix the null version length buffer pointer. Unicode version.

--*/

BOOL 
APIHOOK(VerQueryValueW)(
    const LPVOID pBlock,
    LPWSTR lpSubBlock,
    LPVOID *lplpBuffer,
    PUINT puLen
    )
{
    BOOL bRet;
    UINT nLen;

    if (!puLen) {
        puLen = &nLen;
        DPFN( eDbgLevelError, "[APIHook_VerQueryValueW] Null puLen param. Fixed.\n");
    }

    bRet = ORIGINAL_API(VerQueryValueW)( 
        pBlock, 
        lpSubBlock, 
        lplpBuffer, 
        puLen);
    
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueA)
    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatewritefile.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateWriteFile.cpp

 Abstract:

    On NT, WriteFile requires the buffer passed in to be non-null. But Win9x
    assumes you want to write zeroes if the buffer is NULL. This shim emulates
    the Win9x behavior.

 Notes:

    This is a general purpose shim.

 History:

    01/21/2000 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateWriteFile)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WriteFile)
    APIHOOK_ENUM_ENTRY(AVIStreamWrite)
APIHOOK_ENUM_END

typedef HRESULT (*_pfn_AVIStreamWrite)(PAVISTREAM pavi, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags, LONG * plSampWritten, LONG * plBytesWritten);

/*++

 Allocate a buffer as required.

--*/

BOOL
APIHOOK(WriteFile)(
    HANDLE       hFile,              
    LPCVOID      lpBuffer,        
    DWORD        nNumberOfBytesToWrite,
    LPDWORD      lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped    
    )
{
    BOOL bRet;

    if (!lpBuffer) {
        
        void* pBuf = malloc(nNumberOfBytesToWrite);

        if (pBuf == NULL) {
            LOGN(eDbgLevelError, "[WriteFile] Failed to allocate %d bytes.", nNumberOfBytesToWrite);
        } else {
            ZeroMemory(pBuf, nNumberOfBytesToWrite);
        }

        bRet = ORIGINAL_API(WriteFile)(hFile, pBuf, nNumberOfBytesToWrite, 
            lpNumberOfBytesWritten, lpOverlapped);

        free(pBuf);

        LOGN(eDbgLevelError, "[WriteFile] - null buffer of size %d.", nNumberOfBytesToWrite);

    } else {
        bRet = ORIGINAL_API(WriteFile)(hFile, lpBuffer, nNumberOfBytesToWrite,
            lpNumberOfBytesWritten, lpOverlapped);
    }

    return bRet;
}

/*++

 Allocate a buffer as required.

--*/

HRESULT
APIHOOK(AVIStreamWrite)(
    PAVISTREAM pavi,       
    LONG lStart,           
    LONG lSamples,         
    LPVOID lpBuffer,       
    LONG cbBuffer,         
    DWORD dwFlags,         
    LONG * plSampWritten,  
    LONG * plBytesWritten  
    )
{
    HRESULT hRet;

    if (!lpBuffer) {
        
        void* pBuf = malloc(cbBuffer);

        if (pBuf == NULL) {
            LOGN(eDbgLevelError, "[AVIStreamWrite] Failed to allocate %d bytes.", cbBuffer);
        } else {
            ZeroMemory(pBuf, cbBuffer);
        }

        hRet = ORIGINAL_API(AVIStreamWrite)(pavi, lStart, lSamples, pBuf, 
            cbBuffer, dwFlags, plSampWritten,  plBytesWritten);

        free(pBuf);

        LOGN(eDbgLevelError, "[AVIStreamWrite] - null buffer of size %d", cbBuffer);

    } else {
        hRet = ORIGINAL_API(AVIStreamWrite)(pavi, lStart, lSamples, lpBuffer, 
            cbBuffer, dwFlags, plSampWritten,  plBytesWritten);
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, WriteFile)
    APIHOOK_ENTRY(AVIFIL32.DLL, AVIStreamWrite)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatetextcolor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EmulateTextColor.cpp

 Abstract:

    Win9x contained a hack that allowed the programmer to specify a 16 bit 
    value inside a COLORREF which would be used 'as is' for whatever GDI 
    functions were subsequenctly called. We can't have this behaviour on NT
    because the driver gets the Colorref unconverted.

    The solution is to break out the 16 bit portion and expand it to 24 bit 
    color.

 Notes:
    
    This is a general purpose shim.

 History:

    01/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateTextColor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetTextColor)
    APIHOOK_ENUM_ENTRY(SetBkColor)
APIHOOK_ENUM_END

COLORREF 
ColorConvert(
    IN HDC hdc,
    IN COLORREF crColor
    )
/*++

 Converts the DWORD from a 16 bit to a colorref

 Arguments:

    IN crColor - DWORD 16 bit color 

 Return Value: 
    
    Normal COLORREF

--*/
{
    DWORD dwCol = crColor;

    if (GetDeviceCaps(hdc, BITSPIXEL) == 16) {
        if ((dwCol & 0xFFFF0000) == 0x10FF0000) {
            LOGN(
                eDbgLevelError,
                "[ColorConvert] Fixed up bogus 16 bit COLORREF.");

            dwCol = (crColor & 0xf800) <<  8;
                    dwCol |= (crColor & 0x001f) <<  3;
                    dwCol |= (crColor >> 5) & 0x00070007L;
                    dwCol |= (crColor & 0x07e0) <<  5;
                    dwCol |= (crColor & 0x0600) >>  1;
        }
    }

    if (dwCol == 0xFFFFFFFF) {
        LOGN(
            eDbgLevelError,
            "[ColorConvert] Fixed up bogus 24 bit COLORREF.");

        dwCol = 0xFFFFFF;
    }
    
    return dwCol;
}

/*++

 Set text color to a usable one

--*/

COLORREF 
APIHOOK(SetTextColor)( 
    HDC hdc,
    COLORREF crColor
    )
{
    return ORIGINAL_API(SetTextColor)(hdc, ColorConvert(hdc, crColor));
}

/*++

 Set background color to the converted one

--*/

COLORREF 
APIHOOK(SetBkColor)(
    HDC hdc,
    COLORREF crColor
    )
{
    return ORIGINAL_API(SetBkColor)(hdc, ColorConvert(hdc, crColor));
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, SetTextColor)
    APIHOOK_ENTRY(GDI32.DLL, SetBkColor)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\enablerestarts.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EnableRestarts.cpp

 Abstract:

    This DLL APIHooks ExitWindowsEx and gives the process enough privileges to
    restart the computer.

 Notes:

    This is a general purpose shim.

 History:

    11/10/1999 v-johnwh Created.
    10/19/2000 andyseti Close process option added with command line to handle 
                        a case where A process cancel ExitWindowsEx request by 
                        B process because A process is waiting for process B to 
                        quit while process B never quit. In Win9x, process B 
                        quit as soon as it calls ExitWindowsEx so process A can 
                        quit also and the system restarts.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EnableRestarts)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ExitWindowsEx)
APIHOOK_ENUM_END

/*++

 This stub function enables appropriate privileges for the process so that it 
 can restart the machine.

--*/

BOOL 
APIHOOK(ExitWindowsEx)(
    UINT  uFlags, 
    DWORD dwReserved
    )
{
    HANDLE           hToken;
    TOKEN_PRIVILEGES structPtr;
    LUID             luid;

    if (uFlags & (EWX_POWEROFF | EWX_REBOOT | EWX_SHUTDOWN)) {
        
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
            structPtr.PrivilegeCount = 1;
            
            if (LookupPrivilegeValueW(NULL, SE_SHUTDOWN_NAME, &luid)) {
                structPtr.Privileges[0].Luid = luid;
                structPtr.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                LOGN(
                    eDbgLevelError,
                    "[ExitWindowsEx] Adding process privileges for restart.");
                
                AdjustTokenPrivileges(hToken, FALSE, &structPtr, 0, NULL, NULL);
            }
        }

        CSTRING_TRY
        {
            CString csCL(COMMAND_LINE);
            if (csCL.CompareNoCase(L"CLOSE_PROCESS") == 0) {
                LOGN(
                    eDbgLevelError,
                    "[ExitWindowsEx] Closing process.");
            
                ExitProcess(1);
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return ORIGINAL_API(ExitWindowsEx)(uFlags, dwReserved);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, ExitWindowsEx)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateslowcpu.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    EmulateSlowCPU.cpp

 Abstract:

    Modify performance testing routines to emulate slower processors.

 Notes:

    This is a general purpose shim.

 History:

    07/16/2002  mnikkel   Created.

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(EmulateSlowCPU)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(timeGetTime)
    APIHOOK_ENUM_ENTRY(QueryPerformanceCounter)
    APIHOOK_ENUM_ENTRY(QueryPerformanceFrequency)
APIHOOK_ENUM_END

typedef BOOL (*_pfn_QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
typedef BOOL (*_pfn_QueryPerformanceFrequency)(LARGE_INTEGER *lpPerformanceFreq);

DWORD g_dwDivide = 1;
BOOL g_btimeGetTime = FALSE;

/*++

 Don't allow the current time to be equal to the prev time.

--*/

DWORD
APIHOOK(timeGetTime)(VOID)
{
    if (g_btimeGetTime) {

		LARGE_INTEGER PerfFreq;
		LARGE_INTEGER PerfCount1, PerfCount2;

		if (QueryPerformanceFrequency(&PerfFreq) &&
            QueryPerformanceCounter(&PerfCount1)) {
		    do {
			    if (!QueryPerformanceCounter(&PerfCount2)) break;
		    } while (((double)(PerfCount2.QuadPart - PerfCount1.QuadPart) / PerfFreq.QuadPart) < 0.0001);
        }
    }

    return ORIGINAL_API(timeGetTime)();
}

BOOL 
APIHOOK(QueryPerformanceCounter)(
    LARGE_INTEGER *lpPerformanceCount
    )
{
    BOOL bRet = ORIGINAL_API(QueryPerformanceCounter)(lpPerformanceCount);
    if (lpPerformanceCount) {
        lpPerformanceCount->QuadPart /= g_dwDivide;
    }

    return bRet;
}

BOOL 
APIHOOK(QueryPerformanceFrequency)(
    LARGE_INTEGER *lpPerformanceFreq
    )
{
    BOOL bRet = ORIGINAL_API(QueryPerformanceFrequency)(lpPerformanceFreq);
    if (lpPerformanceFreq) {
        lpPerformanceFreq->QuadPart /= g_dwDivide;
    }
    return bRet;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        g_btimeGetTime = COMMAND_LINE && (_stricmp(COMMAND_LINE, "+timeGetTime") == 0);

        INT64 l1, l2;
        if (QueryPerformanceCounter((LARGE_INTEGER *)&l1) &&
            QueryPerformanceCounter((LARGE_INTEGER *)&l2)) {
            
            // Calculate the divide factor
            g_dwDivide = (DWORD_PTR)((l2 - l1)) / 5;

            if (g_dwDivide == 0) {
                g_dwDivide = 1;
            }
        
            LOGN(eDbgLevelInfo, "[NotifyFn] EmulateSlowCPU initialized with divisor %d", g_dwDivide);

            return TRUE;
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(WINMM.DLL, timeGetTime)
    APIHOOK_ENTRY(KERNEL32.DLL, QueryPerformanceCounter)
    APIHOOK_ENTRY(KERNEL32.DLL, QueryPerformanceFrequency)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulatetoolhelp32.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   EmulateToolHelp32.cpp

 Abstract:

   We've discovered 2 incompatibilities between the 9x and NT Toolhelp implementation so far that affect
   apps.

   1) On 9x for the szExeFile field in PROCESSENTRY32 it simply uses the name of the executable
      module (which includes the full path and the executable name); on NT this is the image name.
      Nuclear Strike looks for '\' in szExeFile. 

   2) On 9x the cntUsage field of PROCESSENTRY32 is always non-zero while on NT it's always 0. We
      make it 1.

   there are others (like on NT the th32ModuleID is always 1 while on 9x it's unique for each module)
   but we haven't seen any apps having problems with those so we aren't putting them in.

 Notes:

   This is a general purpose shim.

 History:

    11/14/2000 maonis  Created
    02/18/2002 mnikkel modified to use strsafe.h

--*/

#include "precomp.h"


// The toolhelp APIs are lame - they define all the APIs to the W version when UNICODE is defined.
// We want to hook the ANSI version so undefine UNICODE.
#ifdef UNICODE
#undef UNICODE
#include <Tlhelp32.h>
#endif

typedef BOOL (WINAPI *_pfn_Process32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
typedef BOOL (WINAPI *_pfn_Process32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

IMPLEMENT_SHIM_BEGIN(EmulateToolHelp32)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(Process32First)
    APIHOOK_ENUM_ENTRY(Process32Next)
APIHOOK_ENUM_END

/*++

  MSDN says the szExeFile field of PROCESSENTRY32 is supposed to contain the "Path and filename 
  of the executable file for the process". But really, a process doesn't really have a path - only
  modules in the process do. NT does it right (it takes the image name), 9x doesn't.

--*/

BOOL GetProcessNameFullPath(DWORD dwPID, LPSTR szExeName)
{
    BOOL bRet = FALSE;

    HANDLE hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID);

    if (hModuleSnap != INVALID_HANDLE_VALUE) {
        MODULEENTRY32 me32;
        me32.dwSize = sizeof(MODULEENTRY32); 

        // The first module in the process is the one we want.
        if (Module32First(hModuleSnap, &me32)) {
            if (StringCchCopyA(szExeName, MAX_PATH, me32.szExePath) == S_OK) {
                bRet = TRUE;
            }
        }

        CloseHandle (hModuleSnap);
    }

    return bRet;
}

/*++

  This stub function skips the first few processes that don't apply in 9x and returns the first
  9x-like process with the full path and name of the executable in lppe->szExeFile.

--*/

BOOL 
APIHOOK(Process32First)(
    HANDLE hSnapshot, 
    LPPROCESSENTRY32 lppe
    )
{
    // Skip till we find the first one we can get the module path and name.
    BOOL bRet = ORIGINAL_API(Process32First)(hSnapshot, lppe);

    // The 1st process in [System Process], we ignore it.
    if (!bRet) {
        return bRet;
    }

    // We can't get the first (or first few) process's module list - we return the first one we can.
    bRet = ORIGINAL_API(Process32Next)(hSnapshot, lppe);
    while (bRet) {
        if (GetProcessNameFullPath(lppe->th32ProcessID, lppe->szExeFile)) {
            DPFN(eDbgLevelInfo, "[APIHook_Process32First] the 1st process name is %s\n", lppe->szExeFile);

            lppe->cntUsage = 1;

            return TRUE;
        }
        bRet = ORIGINAL_API(Process32Next)(hSnapshot, lppe);
    }

    return bRet;
}

/*++

  This stub function calls the API and get the full path and the name of the executable
  and put it in lppe->szExeFile.

--*/

BOOL 
APIHOOK(Process32Next)(
    HANDLE hSnapshot, 
    LPPROCESSENTRY32 lppe
    )
{
    BOOL bRet = ORIGINAL_API(Process32Next)(hSnapshot, lppe);

    if (bRet) {
        if (!GetProcessNameFullPath(lppe->th32ProcessID, lppe->szExeFile)) {
            return FALSE;
        }

        DPFN(eDbgLevelInfo, "[APIHook_Process32Next] process name is %s\n", lppe->szExeFile);

        lppe->cntUsage = 1;
    }

    return bRet;
}

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, Process32First)
    APIHOOK_ENTRY(KERNEL32.DLL, Process32Next)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\emulateuser.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    EmulateUSER.cpp

 Abstract:

    EmulateSetWindowsHook:

        Handles a behaviour difference on the arguments passed to 
        SetWindowsHook, for the case where:

        (hMod == NULL) && (dwThreadId == 0)

        According to MSDN:

            An error may occur if the hMod parameter is NULL and the dwThreadId 
            parameter is zero or specifies the identifier of a thread created 
            by another process. 

        So the NT behaviour is correct. However, on win9x, hMod was assumed to 
        be the current module if NULL and dwThreadId == 0. 

        Note: this doesn't affect the case where the thread belongs to another 
        process.

    ForceTemporaryModeChange:

        A hack for several apps that permanently change the display mode and 
        fail to restore it correctly. Some of these apps do restore the 
        resolution, but not the refresh rate. 1024x768 @ 60Hz looks really bad.

        Also includes a hack for cursors: the cursor visibility count is not 
        persistent through mode changes.

    CorrectWndProc:

        When you specify a NULL window proc we make it DefWindowProc instead to 
        mimic the 9x behavior.

    EmulateToASCII:
   
        Remove stray characters from ToAscii. This usually manifests itself as 
        a locked keyboard since this is the API that's used to convert the scan 
        codes to actual characters.

    EmulateShowWindow:

        Win9x didn't use the high bits of nCmdShow, which means they got 
        stripped off.

    EmulateGetMessage:

        Check wMsgFilterMax in GetMessage and PeekMessage for bad values and if 
        found change them to 0x7FFF.

    PaletteRestore:

        Persist palette state through mode switches. This includes the entries 
        themselves and the usage flag (see SetSystemPaletteUse).

 Notes:

    This is a general purpose shim.

 History:

    01/20/2000 linstev  Created
    02/18/2002 mnikkel  Added check for null pointer in RegisterClassA.
                        Changed InitializeCriticalSection to InitializeCriticalSectionandSpinCount.
                        Added failure check in toascii and toasciiex

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EmulateUSER)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(SetWindowsHookExA)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsExA)
    APIHOOK_ENUM_ENTRY(ToAscii)
    APIHOOK_ENUM_ENTRY(ToAsciiEx)
    APIHOOK_ENUM_ENTRY(ShowWindow) 
    APIHOOK_ENUM_ENTRY(PeekMessageA)
    APIHOOK_ENUM_ENTRY(GetMessageA)
    APIHOOK_ENUM_ENTRY(SetSystemPaletteUse)
    APIHOOK_ENUM_ENTRY(AnimatePalette)
    APIHOOK_ENUM_ENTRY(RealizePalette)

APIHOOK_ENUM_END

CRITICAL_SECTION g_csPalette;
UINT g_uPaletteLastUse = SYSPAL_STATIC;
DWORD g_peTable[256] =
{
    0x00000000, 0x00000080, 0x00008000, 0x00008080,
    0x00800000, 0x00800080, 0x00808000, 0x00C0C0C0,
    0x00C0DCC0, 0x00F0CAA6, 0x00081824, 0x00142830,
    0x0018303C, 0x00304D61, 0x0051514D, 0x004D7161,
    0x00826D61, 0x000C1414, 0x00597582, 0x00759E08,
    0x00303438, 0x00AA6938, 0x00203428, 0x00496161,
    0x0049869E, 0x007D9A6D, 0x000869CB, 0x008E8682,
    0x0075615D, 0x000061EB, 0x00000871, 0x002C3830,
    0x000471EF, 0x008E92AA, 0x00306DF7, 0x0004C3C3,
    0x0092AAB2, 0x00101814, 0x00040C08, 0x000C7110,
    0x00CFA282, 0x000008AA, 0x0028412C, 0x00498EB2,
    0x00204D61, 0x00555955, 0x0004D3D3, 0x001C3C4D,
    0x0020A6F7, 0x0010A210, 0x0018241C, 0x005DAEF3,
    0x00719EAA, 0x00B2E720, 0x00102871, 0x0086C3D3,
    0x00288A2C, 0x000C51BA, 0x0059716D, 0x00494D4D,
    0x00AAB6C3, 0x00005100, 0x0020CBF7, 0x004D8A51,
    0x00BEC7B2, 0x00043CBA, 0x00101C18, 0x000851DF,
    0x00A6E7A6, 0x009ECF24, 0x00797592, 0x00AE7559,
    0x009E8269, 0x00CFE3DF, 0x000C2030, 0x0028692C,
    0x009EA2A2, 0x00F7C782, 0x0034617D, 0x00B6BEBE,
    0x00969E86, 0x00DBFBD3, 0x00655149, 0x0065EF65,
    0x00AED3D3, 0x00E7924D, 0x00B2BEB2, 0x00D7DBDB,
    0x00797571, 0x00344D59, 0x0086B2CF, 0x00512C14,
    0x00A6FBFB, 0x00385965, 0x00828E92, 0x001C4161,
    0x00595961, 0x00002000, 0x003C6D7D, 0x005DB2D7,
    0x0038EF3C, 0x0051CB55, 0x001C2424, 0x0061C3F3,
    0x0008A2A2, 0x0038413C, 0x00204951, 0x00108A14,
    0x00103010, 0x007DE7F7, 0x00143449, 0x00B2652C,
    0x00F7EBAA, 0x003C7192, 0x0004FBFB, 0x00696151,
    0x00EFC796, 0x000441D7, 0x00000404, 0x00388AF7,
    0x008AD3F3, 0x00006500, 0x000004E3, 0x00DBFFFF,
    0x00F7AE69, 0x00CF864D, 0x0055A2D3, 0x00EBEFE3,
    0x00EB8A41, 0x00CF9261, 0x00C3F710, 0x008E8E82,
    0x00FBFFFF, 0x00104110, 0x00040851, 0x0082FBFB,
    0x003CC734, 0x00088A8A, 0x00384545, 0x00514134,
    0x003C7996, 0x001C6161, 0x00EBB282, 0x00004100,
    0x00715951, 0x00A2AAA6, 0x00B2B6B2, 0x00C3FBFB,
    0x00000834, 0x0028413C, 0x00C7C7CF, 0x00CFD3D3,
    0x00824520, 0x0008CB0C, 0x001C1C1C, 0x00A6B29A,
    0x0071A6BE, 0x00CF9E6D, 0x006D7161, 0x00008A04,
    0x005171BE, 0x00C7D3C3, 0x00969E96, 0x00798696,
    0x002C1C10, 0x00385149, 0x00BE7538, 0x0008141C,
    0x00C3C7C7, 0x00202C28, 0x00D3E3CF, 0x0071826D,
    0x00653C1C, 0x0004EF08, 0x00345575, 0x006D92A6,
    0x00797979, 0x0086F38A, 0x00925528, 0x00E3E7E7,
    0x00456151, 0x001C499A, 0x00656961, 0x008E9EA2,
    0x007986D3, 0x00204151, 0x008AC7E3, 0x00007100,
    0x00519EBE, 0x0010510C, 0x00A6AAAA, 0x002C3030,
    0x00D37934, 0x00183030, 0x0049828E, 0x00CBFBC3,
    0x006D7171, 0x000428A6, 0x004D4545, 0x00040C14,
    0x00087575, 0x0071CB79, 0x004D6D0C, 0x00FBFBD3,
    0x00AAB2AE, 0x00929292, 0x00F39E55, 0x00005D00,
    0x00E3D7B2, 0x00F7FBC3, 0x003C5951, 0x0004B2B2,
    0x0034658E, 0x000486EF, 0x00F7FBE3, 0x00616161,
    0x00DFE3DF, 0x001C100C, 0x0008100C, 0x0008180C,
    0x00598600, 0x0024FBFB, 0x00346171, 0x00042CC7,
    0x00AEC79A, 0x0045AE4D, 0x0028A62C, 0x00EFA265,
    0x007D8282, 0x00F7D79A, 0x0065D3F7, 0x00E3E7BA,
    0x00003000, 0x00245571, 0x00DF823C, 0x008AAEC3,
    0x00A2C3D3, 0x00A6FBA2, 0x00F3FFF3, 0x00AAD7E7,
    0x00EFEFC3, 0x0055F7FB, 0x00EFF3F3, 0x00BED3B2,
    0x0004EBEB, 0x00A6E3F7, 0x00F0FBFF, 0x00A4A0A0,
    0x00808080, 0x000000FF, 0x0000FF00, 0x0000FFFF,
    0x00FF0000, 0x00FF00FF, 0x00FFFF00, 0x00FFFFFF
};

#define MODE_MASK (CDS_UPDATEREGISTRY | CDS_TEST | CDS_FULLSCREEN | CDS_GLOBAL | CDS_SET_PRIMARY | CDS_VIDEOPARAMETERS | CDS_RESET | CDS_NORESET)

/*++

 Handle NULL for hModule

--*/

HHOOK 
APIHOOK(SetWindowsHookExA)(
    int       idHook,        
    HOOKPROC  lpfn,     
    HINSTANCE hMod,    
    DWORD     dwThreadId   
    )
{
    if (!hMod && !dwThreadId) {
        LOGN(
            eDbgLevelError,
            "[SetWindowsHookExA] hMod is NULL - correcting.");

        hMod = GetModuleHandle(NULL);
    }
    
    return ORIGINAL_API(SetWindowsHookExA)(
                            idHook,
                            lpfn,
                            hMod,
                            dwThreadId);
}

/*++

 Set the WndProc to DefWndProc if it's NULL.

--*/

LONG
APIHOOK(SetWindowLongA)(
    HWND hWnd,       
    int nIndex,      
    LONG dwNewLong   
    )
{
    if ((nIndex == GWL_WNDPROC) && (dwNewLong == 0)) {
        LOGN(eDbgLevelError, "[SetWindowLongA] Null WndProc specified - correcting.");
        dwNewLong = (LONG) DefWindowProcA;
    }
    
    return ORIGINAL_API(SetWindowLongA)(hWnd, nIndex, dwNewLong);
}

/*++

 Set the WndProc to DefWndProc if it's NULL.

--*/

ATOM 
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    if (lpWndClass && !(lpWndClass->lpfnWndProc)) {
        WNDCLASSA wcNewWndClass = *lpWndClass;
        
        LOGN(eDbgLevelError, "[RegisterClassA] Null WndProc specified - correcting.");

        wcNewWndClass.lpfnWndProc = DefWindowProcA;

        return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
    }
    else
    {
        return ORIGINAL_API(RegisterClassA)(lpWndClass);
    }
}

/*++

 Change the palette entries if applicable.

--*/

void
FixPalette()
{
    EnterCriticalSection(&g_csPalette);

    //
    // We realized a palette before this, so let's have a go at restoring 
    // all the palette state.
    // 

    HDC hdc = GetDC(GetActiveWindow());

    if (hdc) {
        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) {
            //
            // We're now in a palettized mode
            //
            SetSystemPaletteUse(hdc, g_uPaletteLastUse);

            LPLOGPALETTE plogpal = (LPLOGPALETTE) malloc(sizeof(LOGPALETTE) + sizeof(g_peTable));

            if (plogpal) {
                //
                // Create a palette we can realize
                //
                plogpal->palVersion = 0x0300;
                plogpal->palNumEntries = 256;
                MoveMemory(&plogpal->palPalEntry[0], &g_peTable[0], sizeof(g_peTable));
                HPALETTE hPal = CreatePalette(plogpal);

                if (hPal) {
                    //
                    // Realize the palette
                    //
                    HPALETTE hOld = SelectPalette(hdc, hPal, FALSE);
                    RealizePalette(hdc);
                    SelectPalette(hdc, hOld, FALSE);
                    DeleteObject(hPal);
                }
        
                free(plogpal);
            }
        }

        ReleaseDC(0, hdc);
    }

    LeaveCriticalSection(&g_csPalette);
}

/*++

 Force temporary change, fixup cursor and palette.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,
    DWORD      dwFlags
    )
{
    dwFlags &= MODE_MASK;
    if (dwFlags == 0 || dwFlags == CDS_UPDATEREGISTRY) {
        dwFlags = CDS_FULLSCREEN;
        LOGN(eDbgLevelError,
             "[ChangeDisplaySettingsA] Changing flags to CDS_FULLSCREEN.");
    }

    ShowCursor(FALSE);
    INT iCntOld = ShowCursor(TRUE);

    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsA)(
        lpDevMode,
        dwFlags);

    INT iCntNew = ShowCursor(FALSE);
    while (iCntNew != iCntOld) {
        iCntNew = ShowCursor(iCntNew < iCntOld ? TRUE : FALSE);
    }

    FixPalette();

    return lRet;
}

/*++

 Force temporary change, fixup cursor and palette.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsExA)(
    LPCSTR     lpszDeviceName,
    LPDEVMODEA lpDevMode,
    HWND       hwnd,
    DWORD      dwFlags,
    LPVOID     lParam
    )
{
    dwFlags &= MODE_MASK;
    if (dwFlags == 0 || dwFlags == CDS_UPDATEREGISTRY) {
        dwFlags = CDS_FULLSCREEN;
        LOGN(eDbgLevelError,
             "[ChangeDisplaySettingsExA] Changing flags to CDS_FULLSCREEN.");
    }

    ShowCursor(FALSE);
    INT iCntOld = ShowCursor(TRUE);

    LONG lRet = ORIGINAL_API(ChangeDisplaySettingsExA)(
        lpszDeviceName, 
        lpDevMode, 
        hwnd, 
        dwFlags, 
        lParam);

    INT iCntNew = ShowCursor(FALSE);
    while (iCntNew != iCntOld) {
        iCntNew = ShowCursor(iCntNew < iCntOld ? TRUE : FALSE);
    }

    FixPalette();

    return lRet;
}

/*++

 Remove stray characters from the end of a translation. 

--*/

int
APIHOOK(ToAscii)(
    UINT   wVirtKey,
    UINT   wScanCode,
    PBYTE  lpKeyState,
    LPWORD lpChar,
    UINT   wFlags
    )
{
    int iRet = ORIGINAL_API(ToAscii)(
        wVirtKey,
        wScanCode,
        lpKeyState,
        lpChar,
        wFlags);

    // if zero or one char was translated.
    if (iRet == 0 || iRet == 1)
    {
        LPBYTE p = (LPBYTE)lpChar;
    
        p[iRet] = '\0';
    }

    return iRet;
}

/*++

 Remove stray characters from the end of a translation.

--*/

int
APIHOOK(ToAsciiEx)(
    UINT   wVirtKey,
    UINT   wScanCode,
    PBYTE  lpKeyState,
    LPWORD lpChar,
    UINT   wFlags,
    HKL    dwhkl
    )
{
    int iRet = ORIGINAL_API(ToAsciiEx)(
        wVirtKey,
        wScanCode,
        lpKeyState,
        lpChar,
        wFlags,
        dwhkl);

    // if zero or one char was translated.
    if (iRet == 0 || iRet == 1)
    {
        LPBYTE p = (LPBYTE) lpChar;
    
        p[iRet] = '\0';
    }

    return iRet;
}

/*++

 Strip the high bits off nCmdShow

--*/

LONG 
APIHOOK(ShowWindow)(
    HWND hWnd,
    int nCmdShow
    )
{
    if (nCmdShow & 0xFFFF0000) {
        LOGN( eDbgLevelWarning, "[ShowWindow] Fixing invalid parameter");

        // Remove high bits
        nCmdShow &= 0xFFFF;
    }

    return ORIGINAL_API(ShowWindow)(hWnd, nCmdShow);
}

/*++

 This fixes the bad wMsgFilterMax parameter.

--*/

BOOL
APIHOOK(PeekMessageA)( 
    LPMSG lpMsg, 
    HWND hWnd, 
    UINT wMsgFilterMin, 
    UINT wMsgFilterMax, 
    UINT wRemoveMsg 
    )
{
    if ((wMsgFilterMin == 0) && (wMsgFilterMax == 0xFFFFFFFF)) {
        LOGN( eDbgLevelWarning, "[PeekMessageA] Correcting parameters");
        wMsgFilterMax = 0;
    }

    return ORIGINAL_API(PeekMessageA)( 
        lpMsg, 
        hWnd, 
        wMsgFilterMin, 
        wMsgFilterMax, 
        wRemoveMsg);
}

/*++

 This fixes the bad wMsgFilterMax parameter.

--*/

BOOL
APIHOOK(GetMessageA)( 
    LPMSG lpMsg, 
    HWND hWnd, 
    UINT wMsgFilterMin, 
    UINT wMsgFilterMax 
    )
{
    if ((wMsgFilterMin == 0) && (wMsgFilterMax == 0xFFFFFFFF)) {
        LOGN( eDbgLevelWarning, "[GetMessageA] Correcting parameters");
        wMsgFilterMax = 0;
    }

    return ORIGINAL_API(GetMessageA)( 
        lpMsg, 
        hWnd, 
        wMsgFilterMin, 
        wMsgFilterMax);
}

/*++

 Track the system palette use

--*/

UINT 
APIHOOK(SetSystemPaletteUse)(
    HDC hdc,      
    UINT uUsage   
    )
{
    EnterCriticalSection(&g_csPalette);
    
    g_uPaletteLastUse = uUsage;

    UINT uRet = ORIGINAL_API(SetSystemPaletteUse)(hdc, uUsage);

    LeaveCriticalSection(&g_csPalette);
    
    return uRet;
}

/*++

 Fill in the last known palette if anything was realized

--*/

UINT 
APIHOOK(RealizePalette)(
    HDC hdc   
    )
{
    EnterCriticalSection(&g_csPalette);

    UINT uRet = ORIGINAL_API(RealizePalette)(hdc);

    if (uRet) {
        //
        // Copy the current logical palette to our global store
        //
        HPALETTE hPal = (HPALETTE) GetCurrentObject(hdc, OBJ_PAL);

        if (hPal) {
            GetPaletteEntries(hPal, 0, 256, (PALETTEENTRY *)&g_peTable);
        }
    }

    LeaveCriticalSection(&g_csPalette);

    return uRet;
}

/*++

 Update our private palette with the new entries.

--*/

BOOL 
APIHOOK(AnimatePalette)(
    HPALETTE hPal,            
    UINT iStartIndex,         
    UINT cEntries,            
    CONST PALETTEENTRY *ppe   
    )
{
    EnterCriticalSection(&g_csPalette);

    BOOL bRet = ORIGINAL_API(AnimatePalette)(hPal, iStartIndex, cEntries, ppe);

    if (bRet) {
        //
        // We have to populate our global settings 
        //
        PALETTEENTRY peTable[256];

        if (GetPaletteEntries(hPal, iStartIndex, cEntries, &peTable[iStartIndex]) == cEntries) {
            //
            // Replace all the entries in our global table that are reserved 
            // for animation.
            //
            for (UINT i=iStartIndex; i<iStartIndex + cEntries; i++) {
                LPPALETTEENTRY p = (LPPALETTEENTRY)&g_peTable[i];
                if (p->peFlags & PC_RESERVED) {
                    //
                    // This entry is being animated
                    //
                    p->peRed = peTable[i].peRed;
                    p->peGreen = peTable[i].peGreen;
                    p->peBlue = peTable[i].peBlue;
                }
            }
        }
    }

    LeaveCriticalSection(&g_csPalette);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Critical section for palette globals
        //
        return InitializeCriticalSectionAndSpinCount(&g_csPalette,0x80000000);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, SetWindowsHookExA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsExA)
    APIHOOK_ENTRY(USER32.DLL, ToAscii)
    APIHOOK_ENTRY(USER32.DLL, ToAsciiEx)
    APIHOOK_ENTRY(USER32.DLL, ShowWindow)
    APIHOOK_ENTRY(USER32.DLL, PeekMessageA)
    APIHOOK_ENTRY(USER32.DLL, GetMessageA)
    APIHOOK_ENTRY(GDI32.DLL, SetSystemPaletteUse);
    APIHOOK_ENTRY(GDI32.DLL, AnimatePalette);
    APIHOOK_ENTRY(GDI32.DLL, RealizePalette);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\feedbackreport.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    DisableThemes.cpp

 Abstract:

    This shim is for apps that don't support themes.

 Notes:

    This is a general purpose shim.

 History:

    01/15/2001 clupu      Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(FeedbackReport)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

void
LaunchFeedbackUI(
    void
    )
{
    CSTRING_TRY
    {
        STARTUPINFOW		si;
	    PROCESS_INFORMATION	pi;

	    CString	csCmdLine;
	    CString	csExeName;

	    ZeroMemory(&si,	sizeof(si));
	    ZeroMemory(&pi,	sizeof(pi));
    	
	    si.cb =	sizeof(si);

	    csExeName.GetModuleFileNameW(NULL);

	    csCmdLine.Format(L"ahui.exe feedback \"%s\"", csExeName);
        if (CreateProcessW(NULL,
                    (LPWSTR)csCmdLine.Get(),
                    NULL,
                    NULL,
                    FALSE,
                    0,
                    NULL,
                    NULL,
                    &si,
                    &pi))
        {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
        else
        {            
            DPFN( eDbgLevelError, "CreateProcess failed.GetLastError = %d", GetLastError());            
        }
    }
    CSTRING_CATCH
    {
    }    
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_PROCESS_DYING) {
        LaunchFeedbackUI();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\fileversioninfolie.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    FileVersionInfoLie.cpp

 Abstract:

    This shim replaces the info returned from calls to GetFileVersionInfoSize and
    GetFileVersionInfo with information stored in resource files.  The default
    is to replace file info with stored info obtained from DirectX ver 7a.
    This can be overridden with command line input.  For example:

    COMMAND_LINE("D3drgbxf.dll,IDR_D3DRGBXFINFO;dsound.vxd,IDR_DSOUNDVXDINFO")

    this would intercept the info calls for D3drgbxf.dll and dsounc.vxd and replace
    their info with the info stored in the resources named. Note: All spaces within
    the command line are considered part of the filename or resource name, only the
    commas and semicolons are delimeters.

 Notes:

    This is a general purpose shim.

 History:

    01/03/2000 a-jamd   Created
    03/28/2000 a-jamd   Added resource for ddraw16.dll
    04/04/2000 a-michni Added resource for D3drgbxf.dll
    04/07/2000 linstev  Added resource for dsound.vxd
    04/10/2000 markder  Removed GetModuleHandle("_DDRAW6V") calls -- use g_hinstDll
    04/18/2000 a-michni Modified DDraw6Versionlie to be command line input driven and
                        renamed to FileVersionInfoLie
    04/26/2000 a-batjar GetFileVersionInfo should return truncated result if passed
                        in buffer size is smaller than infosize
    07/19/2000 andyseti Added resource for shdocvw.bin
    08/11/2000 a-brienw changed g_nNumDirectX6 to 7 and added entry for dsound.dll
                        made it the same as dsound.vxd
    08/15/2000 a-vales  Added resource for dsound.dll
    11/08/2000 a-brienw changed dsound.dll entry to return dsound.vxd version info.
                        a-vales changed it from my previous entry which caused MAX2
                        to no longer work.  I changed it back and checked it with
                        MAX2 and his app Golden Nugget and it is fine with both.
    12/06/2000 mnikkel  Added resources for all directx7a dlls and also for any
                        dlls that existed in previous versions of directx but
                        were deleted.  NOTE: the resources for these files are
                        in win98 format so that apps which directly read the version
                        info will receive them in the way they are expecting.
    02/18/2002 mnikkel  Added check to make sure a null pointer was not passed into GetFileVersionInfoSizeA.
                        Added check to make sure a null pointer was not passed into GetFileVersionInfoA.

--*/
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FileVersionInfoLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeA)
APIHOOK_ENUM_END

   
// Keep a list of files to version lie.
struct LIELIST
{
    struct LIELIST * next;
    CString         szFileName;
    CString         szResource;
};

LIELIST *g_pLieList = NULL;

// DirectX 7a default files go here.
const INT   g_nNumDirectX7a = 67;

WCHAR  *g_szDirectX7aFiles[g_nNumDirectX7a] =
    { L"dplay.dll",      L"d3dim.dll",        L"d3dim700.dll",
      L"d3dpmesh.dll",   L"d3dramp.dll",      L"d3drampf.dll",
      L"d3dref.dll",     L"d3drg16f.dll",     L"d3drg24f.dll",
      L"d3drg24x.dll",   L"d3dhalf.dll",      L"d3drg32f.dll",
      L"d3drg32x.dll",   L"d3drg55x.dll",     L"d3drg56x.dll",
      L"d3drg8f.dll",    L"d3drg8x.dll",      L"d3drgbf.dll",
      L"d3drgbxf.dll",   L"d3drm.dll",        L"d3drm16f.dll",
      L"d3drm24f.dll",   L"d3drm32f.dll",     L"d3drm8f.dll",
      L"d3dxof.dll",     L"ddhelp.exe",       L"ddraw.dll",
      L"ddraw16.dll",    L"ddrawex.dll",      L"devnode1.dll",
      L"devnode2.dll",   L"dinput.dll",       L"dmband.dll",
      L"dmcompos.dll",   L"dmime.dll",        L"dmloader.dll",
      L"dmstyle.dll",    L"dmsynth.dll",      L"dmusic.dll",
      L"dmusic16.dll",   L"dmusic32.dll",     L"dplayx.dll",
      L"dpmodemx.dll",   L"dpserial.dll",     L"dpwsock.dll",
      L"dpwsockx.dll",   L"dsetup.dll",       L"dsetup16.dll",
      L"dsetup32.dll",   L"dsetup6e.dll",     L"dsetup6j.dll",
      L"dsetupe.dll",    L"dsetupj.dll",      L"dsound.dll",
      L"dsound3d.dll",   L"dx7vb.dll",        L"dxmigr.dll",
      L"gcdef.dll",      L"gchand.dll",       L"msvcrt.dll",
      L"pid.dll",        L"vjoyd.vxd",        L"dinput.vxd",
      L"dsound.vxd",     L"joyhid.vxd",       L"mtrr.vxd",
      L"ddraw.vxd"
    };

// NOTE: These are 16 bit resources!!!  This is necessary in case
// they index into the data themselves.  If they do a verqueryvalue
// the data is converted before its returned by verqueryvalue.
WCHAR  * g_szDirectX7aResource[g_nNumDirectX7a] =
    { L"IDR_dplay",      L"IDR_d3dim",        L"IDR_d3dim700",
      L"IDR_d3dpmesh",   L"IDR_d3dramp",      L"IDR_d3drampf",
      L"IDR_d3dref",     L"IDR_d3drg16f",     L"IDR_d3drg24f",
      L"IDR_d3drg24x",   L"IDR_d3dhalf",      L"IDR_d3drg32f",
      L"IDR_d3drg32x",   L"IDR_d3drg55x",     L"IDR_d3drg56x",
      L"IDR_d3drg8f",    L"IDR_d3drg8x",      L"IDR_d3drgbf",
      L"IDR_d3drgbxf",   L"IDR_d3drm",        L"IDR_d3drm16f",
      L"IDR_d3drm24f",   L"IDR_d3drm32f",     L"IDR_d3drm8f",
      L"IDR_d3dxof",     L"IDR_ddhelp",       L"IDR_ddraw",
      L"IDR_ddraw16",    L"IDR_ddrawex",      L"IDR_devnode1",
      L"IDR_devnode2",   L"IDR_dinput",       L"IDR_dmband",
      L"IDR_dmcompos",   L"IDR_dmime",        L"IDR_dmloader",
      L"IDR_dmstyle",    L"IDR_dmsynth",      L"IDR_dmusic",
      L"IDR_dmusic16",   L"IDR_dmusic32",     L"IDR_dplayx",
      L"IDR_dpmodemx",   L"IDR_dpserial",     L"IDR_dpwsock",
      L"IDR_dpwsockx",   L"IDR_dsetup",       L"IDR_dsetup16",
      L"IDR_dsetup32",   L"IDR_dsetup6e",     L"IDR_dsetup6j",
      L"IDR_dsetupe",    L"IDR_dsetupj",      L"IDR_dsound",
      L"IDR_dsound3d",   L"IDR_dx7vb",        L"IDR_dxmigr",
      L"IDR_gcdef",      L"IDR_gchand",       L"IDR_msvcrt",
      L"IDR_pid",        L"IDR_vjoydvxd",     L"IDR_dinputvxd",
      L"IDR_dsoundvxd",  L"IDR_joyhidvxd",    L"IDR_mtrrvxd",
      L"IDR_ddrawvxd"
    };


/*++

 return the size from the resource.

--*/
DWORD 
APIHOOK(GetFileVersionInfoSizeA)(
    LPSTR lpstrFilename,  
    LPDWORD lpdwHandle      
    )
{
    DWORD dwRet = 0;

    CSTRING_TRY
    {
        HRSRC hrsrcManifest = NULL;
        LIELIST *pLiePtr = g_pLieList;
        DPFN( eDbgLevelSpew, "[GetFileVersionInfoSizeA] size requested for %s\n", lpstrFilename );

        CString csFileName(lpstrFilename);
        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);

        // Search through the list of files with their matching IDR's
        while( pLiePtr )
        {
            if (csFilePart.CompareNoCase(pLiePtr->szFileName) == 0)
            {
                hrsrcManifest = FindResourceW( g_hinstDll, pLiePtr->szResource, L"FILES");
                break;
            }
            pLiePtr = pLiePtr->next;
        }

        // If a match was found, get the resource size
        if( hrsrcManifest )
        {
            dwRet = SizeofResource(g_hinstDll, hrsrcManifest);
            if (lpdwHandle)
            {
                *lpdwHandle = 0;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    if (dwRet == 0)
    {
        dwRet = ORIGINAL_API(GetFileVersionInfoSizeA)(lpstrFilename, lpdwHandle);
    }
    
    return dwRet;
}


/*++

  Return the version for the modules that shipped with Win98SE.

--*/
BOOL 
APIHOOK(GetFileVersionInfoA)(
    LPSTR lpstrFilename,
    DWORD dwHandle,
    DWORD dwLen,
    LPVOID lpData
    )
{
    BOOL bRet = FALSE;

    CSTRING_TRY
    {
        HRSRC hrsrcManifest = NULL;
        LIELIST *pLiePtr = g_pLieList;
        DPFN( eDbgLevelSpew, "[GetFileVersionInfoA] info requested for %s\n", lpstrFilename );

        CString csFileName(lpstrFilename);
        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);

        // Search through the list of files with their matching IDR's
        while( pLiePtr )
        {
            if (csFilePart.CompareNoCase(pLiePtr->szFileName) == 0)
            {
                hrsrcManifest = FindResourceW( g_hinstDll, pLiePtr->szResource, L"FILES");
                break;
            }
            pLiePtr = pLiePtr->next;
        }

        // If a match was found, get the resource size
        if( hrsrcManifest )
        {
            LOGN( eDbgLevelError, "[GetFileVersionInfoA] Getting legacy version for %s.", lpstrFilename);

            DWORD   dwManifestSize = SizeofResource(g_hinstDll, hrsrcManifest);
            HGLOBAL hManifestMem   = LoadResource (g_hinstDll, hrsrcManifest);
            PVOID   lpManifestMem  = LockResource (hManifestMem);

            if (lpManifestMem)
            {
                memcpy(lpData, lpManifestMem, dwLen >= dwManifestSize ? dwManifestSize:dwLen );
                bRet = TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    if (!bRet)
    {
        bRet = ORIGINAL_API(GetFileVersionInfoA)( 
                    lpstrFilename, 
                    dwHandle, 
                    dwLen, 
                    lpData);
    }
    
   return bRet;
}


/*++

 Parse the command line inputs.

--*/
BOOL ParseCommandLine(const char * commandLine)
{
    CSTRING_TRY
    {
        CString csCmdLine(commandLine);
    
        // if there are no command line inputs then default to
        // the DirectX 7a files needed.
        if (csCmdLine.IsEmpty())
        {
            DPFN( eDbgLevelSpew, "Defaulting to DirectX7a\n" );
    
            for(int i = 0; i < g_nNumDirectX7a; i++)
            {
                LIELIST * pLiePtr = new LIELIST;
                if (pLiePtr == NULL)
                {
                    DPFN( eDbgLevelSpew, "Out of Memory when trying to allocate list." );
                    return FALSE;
                }
                pLiePtr->szFileName =  g_szDirectX7aFiles[i];
                pLiePtr->szResource =  g_szDirectX7aResource[i];
                pLiePtr->next = g_pLieList;
                g_pLieList = pLiePtr;
            }
        }
        else
        {
            CStringToken csTokenList(csCmdLine, L";");
            CString      csEntryTok;
        
            while (csTokenList.GetToken(csEntryTok))
            {
                CStringToken csEntry(csEntryTok, L",");
                
                CString csLeft;
                CString csRight;
        
                csEntry.GetToken(csLeft);
                csEntry.GetToken(csRight);
        
                if (!csLeft.IsEmpty() && !csRight.IsEmpty())
                {
                    LIELIST * pLiePtr = new LIELIST;
                    pLiePtr->szFileName = csLeft;
                    pLiePtr->szResource = csRight;
                    pLiePtr->next = g_pLieList;
                    g_pLieList = pLiePtr;
                }
            }
        }
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    return TRUE;
}



/*++

 Register hooked functions

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoA)
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoSizeA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\force640x480.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force640x480.cpp

 Abstract:

    This shim is for games that assume the start resolution is 640x480.

 Notes:

    This is a general purpose shim.

 History:

    02/13/2001 dmunsil  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force640x480)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_WIDTH   640
#define CDS_HEIGHT  480

VOID
Force640x480_ChangeMode()
{
    DEVMODEA dm;

    __try { 
        ZeroMemory(&dm, sizeof(dm));
        dm.dmSize = sizeof(dm);
        if (EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm))
        {
            if ((dm.dmPelsWidth != CDS_WIDTH) ||
                (dm.dmPelsHeight != CDS_HEIGHT))
            {
                dm.dmPelsWidth = CDS_WIDTH;
                dm.dmPelsHeight = CDS_HEIGHT;
                dm.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
                if (ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN) != DISP_CHANGE_SUCCESSFUL)
                {
                    DPFN( eDbgLevelError, "ChangeDisplaySettings could not change the settings");
                }
            }
        }
        else
        {
            DPFN( eDbgLevelError, "Could not enumerate using EnumDisplaySettings");
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        Force640x480_ChangeMode();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END
IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\forcecdstop.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceCDStop.cpp

 Abstract:

    This shim is used to fix the problem of contention with the CD Drive.
    Some applications try and access the CD even if they are in the middle of 
    playing a movie or sound via MCI. Note that this shim assumes the app
    is running off of a single CDRom drive at a time.

 Notes:

    This is a general purpose shim.

 History:

    04/10/2000 linstev  Created
    04/12/2000 a-michni Added _hread, ReadFile and _lseek capability.
    04/28/2000 a-michni changed logic to check for IsACDRom before
                        checking for a bad handle, this way CD letter
                        is set for those routines which only have a
                        handle and no way of finding the drive letter.
    05/30/2000 a-chcoff Changed logic to do a cd stop only if error was device busy..
                        we were checking every failed access and plane crazy was making
                        lots of calls that would fail as file not found. as such the cd was
                        getting stopped when it did not need to be, causing a CD not found.
                        This shim should be changed to a faster model. maybe later..
                         
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceCDStop)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExW)
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(ReadFile)
    APIHOOK_ENUM_ENTRY(_hread)
    APIHOOK_ENUM_ENTRY(_lseek)
APIHOOK_ENUM_END


// Include these so we can get to the IOCTLs

#include <devioctl.h>
#include <ntddcdrm.h>

//
// We have to store the first opened CD drive, so that if ReadFile fails, we 
// know which drive to stop. Note, we don't need to protect this variable with
// a critical section, since it's basically atomic.
//

WCHAR g_wLastCDDrive = L'\0';

/*++

 Initialize the global CD letter variable if required. 

--*/

VOID
InitializeCDA(
    LPSTR lpFileName
    )
{
    CHAR cDrive;
    
    if (!g_wLastCDDrive) {
        if (GetDriveTypeFromFileNameA(lpFileName, &cDrive) == DRIVE_CDROM) {
            g_wLastCDDrive = (WCHAR)cDrive;
        }
    }
}

/*++

 Initialize the global CD letter variable if required.

--*/

VOID 
InitializeCDW(
    LPWSTR lpFileName
    )
{
    WCHAR wDrive;
    
    if (!g_wLastCDDrive) {
        if (GetDriveTypeFromFileNameW(lpFileName, &wDrive) == DRIVE_CDROM) {
            g_wLastCDDrive = wDrive;
        }
    }
}

/*++

 Send a STOP IOCTL to the specified drive.

--*/

BOOL 
StopDrive(
    WCHAR wDrive
    )
{
    BOOL   bRet = FALSE;
    HANDLE hDrive;
    WCHAR  wzCDROM[7] = L"\\\\.\\C:";

    wzCDROM[4] = wDrive;

    hDrive = CreateFileW(wzCDROM,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (hDrive != INVALID_HANDLE_VALUE) {
        DWORD dwBytesRead;

        // Attempt to stop the audio 
        bRet = DeviceIoControl(hDrive,
                               IOCTL_CDROM_STOP_AUDIO,
                               NULL,
                               0,
                               NULL,
                               0,
                               &dwBytesRead,
                               NULL);

        CloseHandle(hDrive);

        if (bRet) {
            DPFN( eDbgLevelInfo,
                "[StopDrive] Successfully stopped drive.\n");
        } else {
            DPFN( eDbgLevelError,
                "[StopDrive] Failed to stop drive. Error %d.\n", GetLastError());
        }
    } else {
        DPFN( eDbgLevelError,
            "[StopDrive] Unable to create cd device handle. %S Error %d.\n",
            wzCDROM, GetLastError());
    }   
    
    return bRet;
}


/*++

 Attempts to stop the CD if filename is a file on a CDROM drive.
 Returns true on a successful stop.

--*/

BOOL
StopCDA(
    LPCSTR lpFileName
    )
{
    CHAR c;
    
    if (GetDriveTypeFromFileNameA(lpFileName, &c) == DRIVE_CDROM) {
        return StopDrive((WCHAR)c);
    } else {
        return FALSE;
    }
}

/*++

 Attempts to stop the CD if filename is a file on a CDROM drive.
 Returns true on a successful stop.

--*/

BOOL
StopCDW(
    LPCWSTR lpFileName
    )
{
    WCHAR w;
    
    if (GetDriveTypeFromFileNameW(lpFileName, &w) == DRIVE_CDROM) {
        return StopDrive(w);
    } else {
        return FALSE;
    }
}

/*++

 Attempts to stop the CD on the last opened CDROM Drive.
 Returns true on a successful stop.

--*/

BOOL
StopCDH( )
{
    if (g_wLastCDDrive) {
        return StopDrive(g_wLastCDDrive);
    } else {
        return FALSE;
    }
}

/*++

 Check for CD file.

--*/

HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR             lpFileName, 
    LPWIN32_FIND_DATAA lpFindFileData 
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDA(lpFileName);

        hRet = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileA] failure \"%s\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileA] Success after CD stop: \"%s\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE
APIHOOK(FindFirstFileW)(
    LPCWSTR            lpFileName, 
    LPWIN32_FIND_DATAW lpFindFileData 
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileW)(lpFileName, lpFindFileData);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDW(lpFileName);
        
        hRet = ORIGINAL_API(FindFirstFileW)(lpFileName, lpFindFileData);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileW] failure \"%S\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileW] Success after CD stop: \"%S\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE
APIHOOK(FindFirstFileExA)(
    LPCSTR              lpFileName,
    FINDEX_INFO_LEVELS  fInfoLevelId,
    LPVOID              lpFindFileData,
    FINDEX_SEARCH_OPS   fSearchOp,
    LPVOID              lpSearchFilter,
    DWORD               dwAdditionalFlags
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileExA)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDA(lpFileName);

        hRet = ORIGINAL_API(FindFirstFileExA)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileExA] failure \"%s\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileExA] Success after CD stop: \"%s\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.
 
--*/

HANDLE
APIHOOK(FindFirstFileExW)(
    LPCWSTR             lpFileName,
    FINDEX_INFO_LEVELS  fInfoLevelId,
    LPVOID              lpFindFileData,
    FINDEX_SEARCH_OPS   fSearchOp,
    LPVOID              lpSearchFilter,
    DWORD               dwAdditionalFlags
    )
{
    HANDLE hRet = ORIGINAL_API(FindFirstFileExW)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

    if ((hRet == INVALID_HANDLE_VALUE) && (ERROR_BUSY == GetLastError())) {
        
        StopCDW(lpFileName);

        hRet = ORIGINAL_API(FindFirstFileExW)(
                            lpFileName, 
                            fInfoLevelId,
                            lpFindFileData,
                            fSearchOp,
                            lpSearchFilter,
                            dwAdditionalFlags);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[FindFirstFileExW] failure \"%S\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[FindFirstFileExW] Success after CD stop: \"%S\".", lpFileName);
        }
    }

    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR                   lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileA)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);
    
    InitializeCDA(lpFileName);
    
    if ((INVALID_HANDLE_VALUE == hRet) && (ERROR_BUSY == GetLastError())) {
        StopCDA(lpFileName);
        
        hRet = ORIGINAL_API(CreateFileA)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[CreateFileA] failure \"%s\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[CreateFileA] Success after CD stop: \"%s\".", lpFileName);
        }
    }
    
    return hRet;
}

/*++

 Check for CD file.

--*/

HANDLE 
APIHOOK(CreateFileW)(
    LPWSTR                  lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    HANDLE hRet = ORIGINAL_API(CreateFileW)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);
    
    InitializeCDW(lpFileName);
    
    if ((INVALID_HANDLE_VALUE == hRet) && (ERROR_BUSY == GetLastError())) {
        StopCDW(lpFileName);
        
        hRet = ORIGINAL_API(CreateFileW)(
                            lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

        if (hRet == INVALID_HANDLE_VALUE) {
            DPFN( eDbgLevelWarning,
                "[CreateFileW] failure \"%S\" Error %d.\n",
                lpFileName, GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[CreateFileW] Success after CD stop: \"%S\".", lpFileName);
        }
    }
    
    return hRet;
}

/*++

 Check for _lseek error.
 
--*/

long 
APIHOOK(_lseek)(
    int  handle,
    long offset,
    int  origin
    )
{
    long iRet = ORIGINAL_API(_lseek)(handle, offset, origin);

    if (iRet == -1L  && IsOnCDRom((HANDLE)handle)) {
        
        StopCDH();
        
        iRet = ORIGINAL_API(_lseek)(handle, offset, origin);

        if (iRet == -1L) {
            DPFN( eDbgLevelWarning,
                "[_lseek] failure: Error %d.\n", GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[_lseek] Success after CD stop.");
        }
    }

    return iRet;
}


/*++

 Check for _hread error.
 
--*/

long 
APIHOOK(_hread)(
    HFILE  hFile,
    LPVOID lpBuffer,
    long   lBytes
    )
{
    long iRet = ORIGINAL_API(_hread)(hFile, lpBuffer, lBytes);

    if (iRet == HFILE_ERROR && IsOnCDRom((HANDLE)hFile)) {
        StopCDH();

        iRet = ORIGINAL_API(_hread)(hFile, lpBuffer, lBytes);

        if (iRet == HFILE_ERROR) {
            DPFN( eDbgLevelWarning,
                "[_hread] failure: Error %d.\n", GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[_hread] Success after CD stop.");
        }
    }

    return iRet;
}

/*++

 Check for ReadFile error.
 
--*/

BOOL 
APIHOOK(ReadFile)(
    HANDLE       hFile,
    LPVOID       lpBuffer,
    DWORD        nNumberOfBytesToRead,
    LPDWORD      lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    BOOL bRet = ORIGINAL_API(ReadFile)(
                            hFile,
                            lpBuffer,
                            nNumberOfBytesToRead,
                            lpNumberOfBytesRead,
                            lpOverlapped);

    if ((bRet == FALSE) && (ERROR_BUSY == GetLastError()) && IsOnCDRom(hFile)) {
        
        StopCDH();

        bRet = ORIGINAL_API(ReadFile)(
                            hFile,
                            lpBuffer,
                            nNumberOfBytesToRead,
                            lpNumberOfBytesRead,
                            lpOverlapped);

        if (bRet == FALSE) {
            DPFN( eDbgLevelWarning,
                "[ReadFile] failure Error %d.\n", GetLastError());
        } else {
            LOGN(
                eDbgLevelInfo,
                "[ReadFile] Success after CD stop.");
        }
    }

    return bRet;
}


/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, ReadFile)
    APIHOOK_ENTRY(KERNEL32.DLL, _hread)
    APIHOOK_ENTRY(LIBC.DLL, _lseek)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\forcecoinitialize.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceCoInitialize.cpp

 Abstract:

    Makes sure we call CoInitialize on this thread if nobody else has.

 Notes:

    This is a general purpose shim.

 History:

    02/22/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceCoInitialize)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CoCreateInstance)
APIHOOK_ENUM_END

/*++

 Call CoInitialize if nobody else has
 
--*/

STDAPI 
APIHOOK(CoCreateInstance)(
    REFCLSID  rclsid,     
    LPUNKNOWN pUnkOuter, 
    DWORD     dwClsContext,  
    REFIID    riid,         
    LPVOID*   ppv
    )
{
    HRESULT hr = ORIGINAL_API(CoCreateInstance)(
                                rclsid,     
                                pUnkOuter, 
                                dwClsContext,  
                                riid,         
                                ppv);

    if (hr == CO_E_NOTINITIALIZED) {
        if (CoInitialize(NULL) == S_OK) {
            DPFN(
                eDbgLevelInfo,
                "[CoCreateInstance] Success: Initialized previously uninitialized COM.\n");
        }

        hr = ORIGINAL_API(CoCreateInstance)(
                                rclsid,     
                                pUnkOuter, 
                                dwClsContext,  
                                riid,         
                                ppv);
    }
    
    return hr;
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(OLE32.DLL, CoCreateInstance)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\force8bitcolor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Force8BitColor.cpp

 Abstract:

    This shim is for games that require 256 colors (8 bit).

 Notes:

    This is a general purpose shim.

 History:

    02/13/2001 dmunsil  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force8BitColor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#define CDS_BITS    8

VOID
Force8BitColor_ChangeMode()
{
    DEVMODEA dm;

    __try { 
        ZeroMemory(&dm, sizeof(dm));
        dm.dmSize = sizeof(dm);
        if (EnumDisplaySettingsA(NULL, ENUM_CURRENT_SETTINGS, &dm))
        {
            if ((dm.dmBitsPerPel != CDS_BITS))
            {
                dm.dmBitsPerPel = CDS_BITS;
                dm.dmFields |= DM_BITSPERPEL;
                if (ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN) != DISP_CHANGE_SUCCESSFUL)
                {
                    DPFN( eDbgLevelError, "ChangeDisplaySettings could not change the settings");
                }
            }
        }
        else
        {
            DPFN( eDbgLevelError, "Could not enumerate using EnumDisplaySettings");
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DPFN( eDbgLevelWarning, "Exception trying to change mode");
    };
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        Force8BitColor_ChangeMode();
    }
    
    return TRUE;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END
IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\forceansigetdisplaynameof.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ForceAnsiGetDisplayNameOf.cpp

 Abstract:

    This shim force the routine IShellFolder::GetDisplayNameOf to return
    an Ascii string whenever it detects that GetDisplayNameOf returned
    a unicode string.

 Notes:

    This is an app is generic.

 History:

    07/26/2000 mnikkel Created
    02/15/2002 mnikkel Modified to use strsafe.h

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceAnsiGetDisplayNameOf)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetDesktopFolder) 
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

/*++

 Hook SHGetDesktopFolder to get the IShellFolder Interface Pointer.

--*/

HRESULT
APIHOOK(SHGetDesktopFolder)(
    IShellFolder **ppshf
    )
{
    HRESULT hReturn;
    
    hReturn = ORIGINAL_API(SHGetDesktopFolder)(ppshf);

    if (SUCCEEDED(hReturn))
    {
        HookObject(
            NULL, 
            IID_IShellFolder, 
            (PVOID*)ppshf, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook GetDisplayName of and when it returns a unicode string convert it over to
 an ANSI string.

--*/

HRESULT
COMHOOK(IShellFolder, GetDisplayNameOf)(
    PVOID pThis,
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName
    )
{
    HRESULT hrReturn = E_FAIL;
    BOOL bNotConverted = TRUE;

    _pfn_IShellFolder_GetDisplayNameOf pfnOld = 
                ORIGINAL_COM(IShellFolder, GetDisplayNameOf, pThis);

    if (pfnOld)
    { 
        hrReturn = (*pfnOld)(pThis, pidl, uFlags, lpName);

        // Check for unicode string and validity
        if ((S_OK == hrReturn) && lpName &&
            (lpName->uType == STRRET_WSTR) && lpName->pOleStr)
        {
            LPMALLOC pMalloc;
            LPWSTR pTemp = lpName->pOleStr;

            // Get a pointer to the Shell's IMalloc interface.
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                CSTRING_TRY
                {
                    // Copy the OleStr to Cstr
                    CString  csOleStr(lpName->pOleStr);                
                    if (StringCchCopyA(lpName->cStr, ARRAYSIZE(lpName->cStr), csOleStr.GetAnsi()) == S_OK)
                    {
                        // set the uType to CSTR and free the old unicode string.
                        lpName->uType = STRRET_CSTR;
                        pMalloc->Free(pTemp);

                        LOGN(
                            eDbgLevelError,
                            "[IShellFolder_GetDisplayNameOf] Converted string from Unicode to ANSI: %s", 
                            lpName->cStr);

                        bNotConverted = FALSE;
                    }
                }              
                CSTRING_CATCH
                {
                    // do nothing
                }
            }
        }
    }

    if (bNotConverted)
    {
        LOGN(
            eDbgLevelError,
            "[IShellFolder_GetDisplayNameOf] Unable to convert string from Unicode to ANSI");
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_COMSERVER(SHELL32)
    APIHOOK_ENTRY(SHELL32.DLL, SHGetDesktopFolder)
    COMHOOK_ENTRY(ShellDesktop, IShellFolder, GetDisplayNameOf, 11)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\forcekeepfocus.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    ForceKeepFocus.cpp

 Abstract:

    Some applications destroy windows that are topmost. In this case, focus 
    falls to the next topmost window. Of course, that window might be a window
    from another application. If that is that case, then the app will 
    unexpectedly lose focus.

    The fix is to make sure that another app window has focus before we destroy
    the top one.

    An additional fix is included in this shim: after a window is created, we
    send a WM_TIMECHANGE message because Star Trek Generations blocked it's thread
    waiting for a message. On Win9x a WM_COMMAND comes through, but I haven't been
    able to repro this on other applications.

 Notes:

    This is a general purpose shim.

 History:

    06/09/2000  linstev         Created
    02/18/2002  robkenny        Converted InitializeCriticalSection to InitializeCriticalSectionAndSpinCount
                                to ensure the critical section is fully initialized.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceKeepFocus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
    APIHOOK_ENUM_ENTRY(CreateWindowExW)
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamAorW)
    APIHOOK_ENUM_ENTRY(DestroyWindow)    
APIHOOK_ENUM_END

//
// List of all app windows
//

struct HWNDITEM
{
    HWND hWndParent;
    HWND hWnd;
    HWNDITEM *next;
};
HWNDITEM *g_hWndList = NULL;

//
// Critical section for list access
//

CRITICAL_SECTION g_csList;

/*++

 Add a window to our list.

--*/

void
AddItem(
    HWND hWndParent,
    HWND hWnd
    )
{
    if (IsWindow(hWnd) && IsWindowVisible(hWndParent))
    {
        EnterCriticalSection(&g_csList);

        HWNDITEM *hitem = (HWNDITEM *) malloc(sizeof(HWNDITEM));

        if (hitem)
        {
            hitem->hWndParent = hWndParent;
            hitem->hWnd = hWnd;
            hitem->next = g_hWndList;
            g_hWndList = hitem;
            
            DPFN( eDbgLevelInfo, "Adding window %08lx with parent %08lx", 
                hWnd, 
                hWndParent);
        }
        else
        {
            DPFN( eDbgLevelError, "Failed to allocate list item");
        }

        LeaveCriticalSection(&g_csList);
    }

    //
    // Some apps get stuck waiting for a message: not really part of this
    // shim, but shouldn't be harmful
    //
    
    if (IsWindow(hWnd))
    {
        PostMessageA(hWnd, WM_TIMECHANGE, 0, 0);
    }
}

/*++

 Remove a window from the list and return another visible window that will 
 become the next top window.
 
--*/

HWND
RemoveItem(
    HWND hWnd
    )
{
    HWND hRet = NULL;

    EnterCriticalSection(&g_csList);

    //
    // Remove the window and all it's children
    //

    HWNDITEM *hcurr = g_hWndList;
    HWNDITEM *hprev = NULL;

    while (hcurr)
    {
        if ((hcurr->hWndParent == hWnd) ||
            (hcurr->hWnd == hWnd))
        {
            HWNDITEM *hfree;

            DPFN( eDbgLevelInfo, "Removing %08lx", hcurr->hWnd);

            if (hprev)
            {
                hprev->next = hcurr->next;
            }
            else
            {
                g_hWndList = hcurr->next;
            }

            hfree = hcurr;
            hcurr = hcurr->next;
            free(hfree);
            continue;
        }
        hprev = hcurr;
        hcurr = hcurr->next;
    }

    // 
    // Find another window to get focus
    //

    hcurr = g_hWndList;
    while (hcurr)
    {
        if (IsWindowVisible(hcurr->hWnd))
        {
            hRet = hcurr->hWnd;
            break;
        }
        hcurr = hcurr->next;
    }

    if (hRet)
    {
        DPFN( eDbgLevelInfo, "Giving focus to %08lx", hRet);
    }

    LeaveCriticalSection(&g_csList);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  
    LPCSTR lpWindowName, 
    DWORD dwStyle,       
    int x,               
    int y,               
    int nWidth,          
    int nHeight,         
    HWND hWndParent,     
    HMENU hMenu,         
    HINSTANCE hInstance, 
    LPVOID lpParam       
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,      
        lpWindowName,     
        dwStyle,          
        x,                
        y,                
        nWidth,           
        nHeight,          
        hWndParent,       
        hMenu,            
        hInstance,        
        lpParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND 
APIHOOK(CreateWindowExW)(
    DWORD dwExStyle,      
    LPCWSTR lpClassName,  
    LPCWSTR lpWindowName, 
    DWORD dwStyle,        
    int x,                
    int y,                
    int nWidth,           
    int nHeight,          
    HWND hWndParent,      
    HMENU hMenu,          
    HINSTANCE hInstance,  
    LPVOID lpParam        
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateWindowExW)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,     
        x,           
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,     
        hInstance, 
        lpParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogParamA)(
    HINSTANCE hInstance,     
    LPCSTR lpTemplateName,   
    HWND hWndParent,         
    DLGPROC lpDialogFunc,    
    LPARAM dwInitParam       
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogParamA)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogParamW)(
    HINSTANCE hInstance,     
    LPCWSTR lpTemplateName,  
    HWND hWndParent,         
    DLGPROC lpDialogFunc,    
    LPARAM dwInitParam       
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogParamW)(  
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogIndirectParamW)(
    HINSTANCE hInstance,       
    LPCDLGTEMPLATE lpTemplate, 
    HWND hWndParent,           
    DLGPROC lpDialogFunc,      
    LPARAM lParamInit          
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogIndirectParamW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Track the created window and post a WM_COMMAND message.

--*/

HWND
APIHOOK(CreateDialogIndirectParamAorW)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    HWND hRet;

    hRet = ORIGINAL_API(CreateDialogIndirectParamAorW)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    AddItem(hWndParent, hRet);

    return hRet;
}

/*++

 Destroy the window and make sure the focus falls to another app window, 
 rather than another app altogether.

--*/

BOOL 
APIHOOK(DestroyWindow)(
    HWND hWnd   
    )
{
    HWND hWndNew = RemoveItem(hWnd);

    if (hWndNew)
    {
        SetForegroundWindow(hWndNew);
    }

    BOOL bRet = ORIGINAL_API(DestroyWindow)(hWnd);

    if (hWndNew)
    {
        SetForegroundWindow(hWndNew);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // If we fail to initialize the critical section, fail loading this shim.
        return InitializeCriticalSectionAndSpinCount(&g_csList, 0x80000000);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamAorW)
    APIHOOK_ENTRY(USER32.DLL, DestroyWindow)

HOOK_END



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\forcemessageboxfocus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ForceMessageBoxFocus.cpp

 Abstract:

   This APIHooks MessageBox and adds the MB_SETFOREGROUND style
   so as to force the messagebox to foreground.
   
 Notes:

 History:

   01/15/2000 a-leelat Created
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceMessageBoxFocus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA) 
    APIHOOK_ENUM_ENTRY(MessageBoxW) 
    APIHOOK_ENUM_ENTRY(MessageBoxExA) 
    APIHOOK_ENUM_ENTRY(MessageBoxExW) 
APIHOOK_ENUM_END



int
APIHOOK(MessageBoxA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;

    //Add the foreground style
    uType |= MB_SETFOREGROUND;

    iReturnValue = ORIGINAL_API(MessageBoxA)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}

int
APIHOOK(MessageBoxW)(
    HWND hWnd,          // handle to owner window
    LPCWSTR lpText,     // text in message box
    LPCWSTR lpCaption,  // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;


    //Add the foreground style
    uType |= MB_SETFOREGROUND;

    iReturnValue = ORIGINAL_API(MessageBoxW)( 
        hWnd,
        lpText,
        lpCaption,
        uType);

    return iReturnValue;
}

int
APIHOOK(MessageBoxExA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;

    //Add the foreground style
    uType |= MB_SETFOREGROUND;

    iReturnValue = ORIGINAL_API(MessageBoxExA)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    return iReturnValue;
}

int
APIHOOK(MessageBoxExW)(
    HWND hWnd,          // handle to owner window
    LPCWSTR lpText,     // text in message box
    LPCWSTR lpCaption,  // message box title
    UINT uType,         // message box style
    WORD wLanguageId    // language identifier
    )
{
    int iReturnValue;
    
    //Add the foreground style
    uType |= MB_SETFOREGROUND;
    
    iReturnValue = ORIGINAL_API(MessageBoxExW)( 
        hWnd,
        lpText,
        lpCaption,
        uType,
        wLanguageId);

    
    return iReturnValue;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\forceshelllinkresolvenoui.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ForceShellLinkResolveNoUI.cpp

 Abstract:

   This shim prevents any sort of UI on the IShellLink::Resolve
   API by NULLing out the passed in HWND if SLR_NO_UI is specified
   in fFlags.

 Notes:

   This is a general purpose shim.

 History:

   04/05/2000 markder  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ForceShellLinkResolveNoUI)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

/*++

 This stub function prevents any sort of UI on the IShellLink::Resolve API by 
 NULLing out the passed in HWND if SLR_NO_UI is specified in fFlags.

--*/

HRESULT 
COMHOOK(IShellLinkA, Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags )
{
    HRESULT                  hrReturn        = E_FAIL;
    _pfn_IShellLinkA_Resolve pfnOld;

    pfnOld = (_pfn_IShellLinkA_Resolve) ORIGINAL_COM(IShellLinkA, Resolve, pThis);

    if( fFlags & SLR_NO_UI )
    {
        hwnd = NULL;
    }

    if( pfnOld )
    {
        hrReturn = (*pfnOld)( pThis, hwnd, fFlags );
    }

    return hrReturn;
}

HRESULT 
COMHOOK(IShellLinkW, Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags )
{
    HRESULT                  hrReturn        = E_FAIL;
    _pfn_IShellLinkW_Resolve pfnOld;

    pfnOld = (_pfn_IShellLinkW_Resolve) ORIGINAL_COM(IShellLinkW, Resolve, pThis);

    if( fFlags & SLR_NO_UI )
    {
        hwnd = NULL;
    }

    if( pfnOld )
    {
        hrReturn = (*pfnOld)( pThis, hwnd, fFlags );
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_COMSERVER(SHELL32)

    COMHOOK_ENTRY(ShellLink, IShellLinkA, Resolve, 19)
    COMHOOK_ENTRY(ShellLink, IShellLinkW, Resolve, 19)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\forcedxsetupsuccess.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ForceDXSetupSuccess.cpp

 Abstract:

    This DLL APIHooks LoadLibrary calls and checks to see if dsetup.dll or 
    dsetup32.dll are being loaded.  If dsetup.dll or dsetup32.dll are being 
    loaded return this module, so that subsequent calls to that dll can be 
    intercepted and stubbed out. If not dsetup.dll or dsetup32.dll then just 
    do what is expected.

 Notes:
    
    This is a general purpose shim.

 History:

    11/10/1999 v-johnwh     Created
    03/29/2000 a-michni     Added DirectXSetupGetVersion hook to return
                            a command line specified version number for
                            apps which look for a specific version.
                            example :           
                            <DLL NAME="ForceDXSetupSuccess.dll" COMMAND_LINE="0x00040005;0x0000009B"/>
   04/2000     a-batjar     check for null in input params for directxsetupgetversion
   06/30/2000  a-brienw     I added a check for dsetup32.dll to APIHook_LoadLibraryA
                            and APIHook_LoadLibraryW. Previously the routines were
                            only looking for dsetup.dll.  This was added to fix a
                            problem in the install for Earthworm Jim 3D.
   02/27/2001  robkenny     Converted to use CString

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(ForceDXSetupSuccess)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA)
    APIHOOK_ENUM_ENTRY(LoadLibraryW)
    APIHOOK_ENUM_ENTRY(LoadLibraryExA)
    APIHOOK_ENUM_ENTRY(LoadLibraryExW)
    APIHOOK_ENUM_ENTRY(GetProcAddress)
    APIHOOK_ENUM_ENTRY(FreeLibrary)
APIHOOK_ENUM_END

/*++

 This function simply returns 0, success, when called upon.

--*/

int 
DirectXSetup( 
    HWND  /*hWnd*/, 
    LPSTR /*lpszRootPath*/, 
    DWORD /*dwFlags*/
    )
{
    LOGN(
        eDbgLevelError,
        "[DirectXSetup] Returning SUCCESS.");
    
    return 0; // SUCCESS
}

int 
DirectXSetupA( 
    HWND  /*hWnd*/, 
    LPSTR /*lpszRootPath*/, 
    DWORD /*dwFlags*/
    )
{
    LOGN(
        eDbgLevelError,
        "[DirectXSetupA] Returning SUCCESS.");
    
    return 0; // SUCCESS
}

int 
DirectXSetupW( 
    HWND   /*hWnd*/, 
    LPWSTR /*lpszRootPath*/, 
    DWORD  /*dwFlags*/
    )
{
    LOGN(
        eDbgLevelError,
        "[DirectXSetupW] Returning SUCCESS.");
    
    return 0; // SUCCESS
}

/*++

 This Function returns either a COMMAND_LINE parsed value for the version and 
 rev or, if no command line is present, it returns version 7 rev 1792

--*/

int
DirectXSetupGetVersion( 
    DWORD* pdwVersion,
    DWORD* pdwRevision
    )
{
    DWORD dwVersion  = 0x00040007;
    DWORD dwRevision = 0x00000700;

    //
    // If no seperator is present or there is nothing after 
    //   seperator then return a default value of ver 7 rev 1792 
    // Otherwise parse the command line, it should contain a
    //   10 char hex version and a 10 char hex revision 
    //

    CSTRING_TRY
    {
        CStringToken csTokenizer(COMMAND_LINE, ";");

        CString csVersion;
        CString csRevision;

        if (csTokenizer.GetToken(csVersion) && csTokenizer.GetToken(csRevision))
        {
            (void)sscanf(csVersion.GetAnsi(),  "%x", &dwVersion);
            (void)sscanf(csRevision.GetAnsi(), "%x", &dwRevision);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    if (pdwVersion)
    {
        *pdwVersion = dwVersion;
    }
    if (pdwRevision)
    {
        *pdwRevision = dwRevision;
    }
    return 1;
}

/*++

 These stub functions break into LoadLibraryA and check to see if lpLibFileName 
 equals dsetup.dll.  If so return FAKE_MODULE.  If lpLibFileName does not 
 contain dsetup.dll return the original value of lpLibFileName.

--*/

HINSTANCE 
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryA] Caught %s attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryA)(lpLibFileName);
    return hInstance;
}

HINSTANCE 
APIHOOK(LoadLibraryW)(
    LPCWSTR lpLibFileName
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryW] Caught %S attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryW)(lpLibFileName);
    return hInstance;
}

HINSTANCE 
APIHOOK(LoadLibraryExA)(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD  dwFlags
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryExA] Caught %s attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryExA)(lpLibFileName, hFile, dwFlags);
    return hInstance;
}

HINSTANCE 
APIHOOK(LoadLibraryExW)(
    LPCWSTR lpLibFileName,
    HANDLE  hFile,
    DWORD   dwFlags
    )
{
    HINSTANCE hInstance = NULL;
    CSTRING_TRY
    {
        CString csName(lpLibFileName);
        CString csFilePart;
        csName.GetLastPathComponent(csFilePart);

        if (
            csFilePart.CompareNoCase(L"dsetup.dll")   == 0 ||
            csFilePart.CompareNoCase(L"dsetup")       == 0 ||
            csFilePart.CompareNoCase(L"dsetup32.dll") == 0 ||
            csFilePart.CompareNoCase(L"dsetup32")     == 0
            )
        {
            LOGN(
                eDbgLevelError,
                "[LoadLibraryExW] Caught %S attempt - returning %08lx", lpLibFileName, g_hinstDll);

            return g_hinstDll;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    hInstance = ORIGINAL_API(LoadLibraryExW)(lpLibFileName, hFile, dwFlags);
    return hInstance;
}


/*++

  Just a simple routine to make GetProcAddress look cleaner.

++*/

BOOL CheckProc(const CString & csProcName, const WCHAR * lpszCheckName)
{
    if (csProcName.Compare(lpszCheckName) == 0)
    {
        DPFN(
            eDbgLevelInfo,
            "[GetProcAddress] Caught %S query. Returning stubbed function at 0x%08X",
            lpszCheckName, DirectXSetup);
        return TRUE;
    }
    return FALSE;
}

/*++

 This stub function breaks into GetProcAddress and checks to see if hModule is 
 equal to FAKE_MODULE.  If so, and pResult contains the string "DirectXSetupA" 
 set pRet to the return value of DirectXSetup.

--*/

FARPROC 
APIHOOK(GetProcAddress)(
    HMODULE hModule, 
    LPCSTR  lpProcName 
    )
{
    if (hModule == g_hinstDll)
    {
        CSTRING_TRY
        {
            CString csProcName(lpProcName);
            csProcName.MakeLower();

            if (CheckProc(csProcName, L"directxsetup"))
            {
                return (FARPROC) DirectXSetup;
            }
            else if (CheckProc(csProcName, L"directxsetupa"))
            {
                return (FARPROC) DirectXSetupA;
            }
            else if (CheckProc(csProcName, L"directxsetupw"))
            {
                return (FARPROC) DirectXSetupW;
            }
            else if (CheckProc(csProcName, L"directxsetupgetversion"))
            {
                return (FARPROC) DirectXSetupGetVersion;
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }
    return ORIGINAL_API(GetProcAddress)(hModule, lpProcName);
}

/*++

 This stub function breaks into FreeLibrary and checks to see if hLibModule 
 equals FAKE_MODULE.  If so return TRUE.  If hLibModule does not contain 
 FAKE_MODULE return the original argument.

--*/

BOOL 
APIHOOK(FreeLibrary)(
    HMODULE hLibModule
    )
{
    BOOL bRet;

    if (hLibModule == g_hinstDll)
    {
        DPFN(
            eDbgLevelInfo,
            "[FreeLibrary] Caught DSETUP.DLL/DSETUP32.DLL free attempt. Returning TRUE");
        bRet = TRUE;
    }
    else
    {
        bRet = ORIGINAL_API(FreeLibrary)(hLibModule);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryW)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcAddress)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\handleapiexceptions.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    HandleAPIExceptions.cpp

 Abstract:

    Handle exceptions thrown by APIs that used to simply fail on Win9x. So far
    we have:

      1. BackupSeek: AVs if hFile == NULL 
      2. CreateEvent passed bad lpEventAttributes and/or lpName
      3. GetFileAttributes 

    Also emulate the win9x behavior for VirtualProtect, whereby the last 
    parameter can be NULL.

    GetTextExtentPoint32 AV's when a large/uninitialized value is passed for
    the string length. This API now emulates Win9x.

    Add sanity checks to pointers in the call to GetMenuItemInfo. This is to match 9x, as
    some apps to pass bogus pointers and it AV on NT.

    When wsprintf receives lpFormat argument as NULL, no AV on 9x.
    But it AV on XP.Shim verifies format string, if it is NULL return the call don't forward
    
 Notes:

    This is a general purpose shim.

 History:

    04/03/2000 linstev  Created
    04/01/2001 linstev  Munged with other exception handling shims
    07/11/2001 prashkud Added handling for GetTextExtentPoint32
    04/24/2002 v-ramora Added handling for wsprintfA

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HandleAPIExceptions)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(BackupSeek) 
    APIHOOK_ENUM_ENTRY(CreateEventA) 
    APIHOOK_ENUM_ENTRY(CreateEventW) 
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(VirtualProtect) 
    APIHOOK_ENUM_ENTRY(GetTextExtentPoint32A)
    APIHOOK_ENUM_ENTRY(GetMenuItemInfoA)
    APIHOOK_ENUM_ENTRY(wsprintfA) 
APIHOOK_ENUM_END

#define MAX_WIN9X_STRSIZE   8192

/*++

 Stub returns for bad parameters.

--*/

BOOL 
APIHOOK(BackupSeek)(
    HANDLE  hFile,
    DWORD   dwLowBytesToSeek,
    DWORD   dwHighBytesToSeek,
    LPDWORD lpdwLowBytesSeeked,
    LPDWORD lpdwHighBytesSeeked,
    LPVOID *lpContext
    )
{
    if (!hFile) {
        LOGN(
            eDbgLevelError,
            "[BackupSeek] Bad parameter, returning NULL");

        return NULL;
    }

    DWORD dwLowSeeked, dwHighSeeked;

    if (IsBadWritePtr(lpdwLowBytesSeeked, 4)) {
        LOGN(
            eDbgLevelError,
            "[BackupSeek] Bad parameter, fixing");

        lpdwLowBytesSeeked = &dwLowSeeked;
    }

    if (IsBadWritePtr(lpdwHighBytesSeeked, 4)) {
        LOGN(
            eDbgLevelError,
            "[BackupSeek] Bad parameter, fixing");

        lpdwHighBytesSeeked = &dwHighSeeked;
    }
    
    return ORIGINAL_API(BackupSeek)(hFile, dwLowBytesToSeek, dwHighBytesToSeek,
        lpdwLowBytesSeeked, lpdwHighBytesSeeked, lpContext);
}

/*++

 Validate parameters

--*/

HANDLE 
APIHOOK(CreateEventA)(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,  
    BOOL bInitialState, 
    LPCSTR lpName      
    )
{
    if (lpEventAttributes &&
        IsBadReadPtr(lpEventAttributes, sizeof(*lpEventAttributes))) {

        LOGN(
            eDbgLevelError,
            "[CreateEventA] Bad parameter, returning NULL");

        return NULL;
    }

    if (lpName &&
        IsBadStringPtrA(lpName, MAX_PATH)) {

        LOGN(
            eDbgLevelError,
            "[CreateEventA] Bad parameter, returning NULL");
        return NULL;
    }

    return (ORIGINAL_API(CreateEventA)(lpEventAttributes, bManualReset, 
        bInitialState, lpName));
}
 
/*++

 Validate parameters

--*/

HANDLE 
APIHOOK(CreateEventW)(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,  
    BOOL bInitialState, 
    LPCWSTR lpName      
    )
{
    if (lpEventAttributes &&
        IsBadReadPtr(lpEventAttributes, sizeof(*lpEventAttributes))) {

        LOGN(
            eDbgLevelError,
            "[CreateEventW] Bad parameter, returning NULL");

        return NULL;
    }

    if (lpName &&
        IsBadStringPtrW(lpName, MAX_PATH)) {

        LOGN(
            eDbgLevelError,
            "[CreateEventW] Bad parameter, returning NULL");
        return NULL;
    }

    return (ORIGINAL_API(CreateEventW)(lpEventAttributes, bManualReset, 
        bInitialState, lpName));
}

/*++

 This function to emulate Win9x behaviour when getting file attributes.

--*/

DWORD 
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName
    )
{
    DWORD dwFileAttributes = INVALID_FILE_ATTRIBUTES;

    if (!IsBadStringPtrA(lpFileName, MAX_PATH)) {
        dwFileAttributes = ORIGINAL_API(GetFileAttributesA)(
                                lpFileName);
    } else {
        LOGN(
            eDbgLevelError,
            "[GetFileAttributesA] Bad parameter - returning INVALID_FILE_ATTRIBUTES.");
    }

    return dwFileAttributes;
}

/*++

 This function is used to emulate Win9x behaviour when getting file attributes.

--*/

DWORD 
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName
    )
{
    DWORD dwFileAttributes = INVALID_FILE_ATTRIBUTES; 

    if (!IsBadStringPtrW(lpFileName, MAX_PATH)) {
        dwFileAttributes = ORIGINAL_API(GetFileAttributesW)(
                                lpFileName);
    } else {
        LOGN(
            eDbgLevelError,
            "[GetFileAttributesW] Bad parameter - returning INVALID_FILE_ATTRIBUTES.");
    }

    return dwFileAttributes;
}

/*++

 Win9x allowed the last parameter to be NULL.

--*/

BOOL
APIHOOK(VirtualProtect)(
    LPVOID lpAddress,     
    SIZE_T dwSize,        
    DWORD flNewProtect,   
    PDWORD lpflOldProtect 
    )
{
    DWORD dwOldProtect = 0;

    if (!lpflOldProtect) {
        //
        // Detected a bad last parameter, fix it.
        //
        LOGN(eDbgLevelError, "[VirtualProtect] Bad parameter - fixing");
        lpflOldProtect = &dwOldProtect;
    }
    
    return ORIGINAL_API(VirtualProtect)(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

/*++

 Win9x only allows 8192 for the size of the string

--*/

BOOL
APIHOOK(GetTextExtentPoint32A)(
    HDC hdc,
    LPCSTR lpString,
    int cbString,
    LPSIZE lpSize
    )
{
   
    if (cbString > MAX_WIN9X_STRSIZE) {
        //
        // Detected a bad string size, fix it.
        //

        if (!IsBadStringPtrA(lpString, cbString)) {                    
            cbString = strlen(lpString);
            LOGN(eDbgLevelError, "[GetTextExtentPoint32A] Bad parameter - fixing");
        } else {
           LOGN(eDbgLevelError, "[GetTextExtentPoint32A] Bad parameter - returning FALSE");
           return FALSE;
        }
    }

    return ORIGINAL_API(GetTextExtentPoint32A)(hdc, lpString, cbString, lpSize);
}

/*++

 Emulate Win9x bad pointer protection.

--*/

BOOL
APIHOOK(GetMenuItemInfoA)(
    HMENU hMenu,          // handle to menu
    UINT uItem,           // menu item
    BOOL fByPosition,     // meaning of uItem
    LPMENUITEMINFO lpmii  // menu item information
    )
{
    if (IsBadWritePtr(lpmii, sizeof(*lpmii))) {
        LOGN(eDbgLevelInfo, "[GetMenuItemInfoA] invalid lpmii pointer, returning FALSE");
        return FALSE;
    }

    if ((lpmii->fMask & MIIM_STRING || lpmii->fMask & MIIM_TYPE) && (lpmii->cch !=0)) {
        MENUITEMINFO MyMII={0};
        ULONG cch;

        MyMII.cbSize = sizeof(MyMII);
        MyMII.fMask = MIIM_STRING;

        if (ORIGINAL_API(GetMenuItemInfoA)(hMenu, uItem, fByPosition, &MyMII)) {
            cch = min(lpmii->cch, MyMII.cch + 1);

            if (IsBadWritePtr(lpmii->dwTypeData, cch)) {
                LOGN(eDbgLevelInfo, "[GetMenuItemInfoA] invalid pointer for string, clearing it");
                lpmii->dwTypeData = 0;
            }
        } else {
            DPFN(eDbgLevelError, "[GetMenuItemInfoA] Internal call to find string size fail (%08X)", GetLastError());
        }
    }

    return ORIGINAL_API(GetMenuItemInfoA)(hMenu, uItem, fByPosition, lpmii);
}

/*++

 Make sure format string for wsprintfA is not NULL

--*/

//Avoid wvsprintfA deprecated warning/error
#pragma warning(disable : 4995)

int 
APIHOOK(wsprintfA)(
    LPSTR lpOut,
    LPCSTR lpFmt,
    ...)
{
    int iRet = 0;

    //
    //  lpFmt can't be NULL, wvsprintfA  throw AV
    //
    if (lpFmt == NULL) {
        if (!IsBadWritePtr(lpOut, 1)) {
            *lpOut = '\0';
        }
        DPFN( eDbgLevelInfo, "[wsprintfA] received NULL as format string");
        return iRet;
    }

    va_list arglist;

    va_start(arglist, lpFmt);
    iRet = wvsprintfA(lpOut, lpFmt, arglist);
    va_end(arglist);

    return iRet;
}

//Enable back deprecated warning/error
#pragma warning(default : 4995)

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, BackupSeek)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateEventA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateEventW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, VirtualProtect)
    APIHOOK_ENTRY(GDI32.DLL, GetTextExtentPoint32A)
    APIHOOK_ENTRY(USER32.DLL, GetMenuItemInfoA)
    APIHOOK_ENTRY(USER32.DLL, wsprintfA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\handleregexpandszregistrykeys.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   HandleRegExpandSzRegistryKeys.cpp

 Abstract:

   This DLL catches REG_EXPAND_SZ registry keys and converts them to REG_SZ by 
   expanding the embedded environment strings.

 History:

   04/05/2000 markder  Created
   10/30/2000 maonis   Bug fix

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HandleRegExpandSzRegistryKeys)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
APIHOOK_ENUM_END


/*++

 Expand REG_EXPAND_SZ strings.

--*/

LONG
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,         // handle to key
    LPCSTR  lpValueName,  // value name
    LPDWORD lpReserved,   // reserved
    LPDWORD lpType,       // dwType buffer
    LPBYTE  lpData,       // data buffer
    LPDWORD lpcbData      // size of data buffer
    )
{
    if (lpcbData == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD  dwType;
    DWORD  cbPassedInBuffer = *lpcbData;
    LONG   uRet = ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName, lpReserved, &dwType, lpData, lpcbData);

    if (lpType) {
        *lpType = dwType;
    }

    if ((uRet != ERROR_SUCCESS) && (uRet != ERROR_MORE_DATA)) {
        return uRet;
    }

    if (dwType != REG_EXPAND_SZ) {
        return uRet;
    }

    // At this point all return values have been properly set.


    //
    // The type is REG_EXPAND_SZ.
    // Change to REG_SZ so app doesn't try to expand the string itself.
    //

    CSTRING_TRY
    {
        CString csExpand(reinterpret_cast<char *>(lpData));
        if (csExpand.ExpandEnvironmentStringsW() > 0)
        {
            const char * pszExpanded = csExpand.GetAnsi();

            DWORD cbExpandedBuffer = (strlen(pszExpanded) + 1) * sizeof(char);

            // Now, make sure we have enough space in the dest buffer

            if (lpData != NULL)
            {
                if (cbPassedInBuffer < cbExpandedBuffer)
                {
                    return ERROR_MORE_DATA;
                }

                // All safe to copy into the return values.

                if (StringCbCopyA((char *)lpData, cbPassedInBuffer, pszExpanded) != S_OK)
				{
					// Something failed
					return uRet;
				}
            }

            // The number of bytes placed into the buffer (including null character)
            *lpcbData = cbExpandedBuffer;

            if (lpType) {
                *lpType = REG_SZ;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing, we'll return original registry values.
    }

    return uRet;
}

/*++

 Expand REG_EXPAND_SZ strings.

--*/

LONG
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,         // handle to key
    LPCWSTR lpValueName,  // value name
    LPDWORD lpReserved,   // reserved
    LPDWORD lpType,       // dwType buffer
    LPBYTE  lpData,       // data buffer
    LPDWORD lpcbData      // size of data buffer
    )
{
    if (lpcbData == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD  dwType;
    DWORD  cbPassedInBuffer = *lpcbData;
    LONG   uRet = ORIGINAL_API(RegQueryValueExW)(hKey, lpValueName, lpReserved, &dwType, lpData, lpcbData);

    if (lpType) {
        *lpType = dwType;
    }

    if ((uRet != ERROR_SUCCESS) && (uRet != ERROR_MORE_DATA)) {
        return uRet;
    }

    if (dwType != REG_EXPAND_SZ) {
        return uRet;
    }

    // At this point all return values have been properly set.


    //
    // The type is REG_EXPAND_SZ.
    // Change to REG_SZ so app doesn't try to expand the string itself.
    //

    CSTRING_TRY
    {
        CString csExpand(reinterpret_cast<WCHAR *>(lpData));
        if (csExpand.ExpandEnvironmentStringsW() > 0)
        {
            DWORD cbExpandedBuffer = (csExpand.GetLength() + 1) * sizeof(WCHAR);

            // Now, make sure we have enough space in the dest buffer

            if (cbPassedInBuffer < cbExpandedBuffer)
            {
                return ERROR_MORE_DATA;
            }

            // All safe to copy into the return values.

            if (StringCbCopyW((WCHAR*)lpData, cbPassedInBuffer, csExpand) != S_OK)
			{
				// Something failed
				return uRet;
			}

            // The number of bytes placed into the buffer (including null character)
            *lpcbData = cbExpandedBuffer;

            if (lpType) {
                *lpType = REG_SZ;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing, we'll return original registry values.
    }

    return uRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\ignoreexception_86dis.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    86dis.cpp

 Abstract:

    Used to find out how long (in bytes) an instruction is: X86 only

 Notes:

    This is largely undocumented since it's based entirely on the original 
    implementation by Gerd Immeyer.

 History:

    10/19/1989 Gerd Immeyer  Original version
    01/09/2000 linstev       Dumbed down for a shim

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreException)
#include "ShimHookMacro.h"

#ifdef _X86_

#pragma pack(1)

#define BIT20(b)            (b & 0x07)
#define BIT53(b)            (b >> 3 & 0x07)
#define BIT76(b)            (b >> 6 & 0x03)

#define MRM                 0x40
#define COM                 0x80
#define END                 0xc0
#define SECTAB_OFFSET_1     256
#define SECTAB_OFFSET_2     236
#define SECTAB_OFFSET_3     227
#define SECTAB_OFFSET_4     215
#define SECTAB_OFFSET_5     199
#define SECTAB_OFFSET_UNDEF 260

#define O_DoDB              0
#define O_NoOperands        0
#define O_NoOpAlt5          O_NoOperands+1
#define O_NoOpAlt4          O_NoOpAlt5+2
#define O_NoOpAlt3          O_NoOpAlt4+2
#define O_NoOpAlt1          O_NoOpAlt3+2
#define O_NoOpAlt0          O_NoOpAlt1+2
#define O_NoOpStrSI         O_NoOpAlt0+2
#define O_NoOpStrDI         O_NoOpStrSI+2
#define O_NoOpStrSIDI       O_NoOpStrDI+2
#define O_bModrm_Reg        O_NoOpStrSIDI+2
#define O_vModrm_Reg        O_bModrm_Reg+3
#define O_Modrm_Reg         O_vModrm_Reg+3
#define O_bReg_Modrm        O_Modrm_Reg+3
#define O_fReg_Modrm        O_bReg_Modrm+3
#define O_Reg_Modrm         O_fReg_Modrm+3
#define O_AL_Ib             O_Reg_Modrm+3
#define O_AX_Iv             O_AL_Ib+2
#define O_sReg2             O_AX_Iv+2
#define O_oReg              O_sReg2+1
#define O_DoBound           O_oReg+1
#define O_Iv                O_DoBound+3
#define O_wModrm_Reg        O_Iv+1
#define O_Ib                O_wModrm_Reg+3
#define O_Imulb             O_Ib+1
#define O_Imul              O_Imulb+4
#define O_Rel8              O_Imul+4
#define O_bModrm_Ib         O_Rel8+1
#define O_Modrm_Ib          O_bModrm_Ib+3
#define O_Modrm_Iv          O_Modrm_Ib+3
#define O_Modrm_sReg3       O_Modrm_Iv+3
#define O_sReg3_Modrm       O_Modrm_sReg3+3
#define O_Modrm             O_sReg3_Modrm+3
#define O_FarPtr            O_Modrm+2
#define O_AL_Offs           O_FarPtr+1
#define O_Offs_AL           O_AL_Offs+2
#define O_AX_Offs           O_Offs_AL+2
#define O_Offs_AX           O_AX_Offs+2
#define O_oReg_Ib           O_Offs_AX+2
#define O_oReg_Iv           O_oReg_Ib+2
#define O_Iw                O_oReg_Iv+2
#define O_Enter             O_Iw+1
#define O_Ubyte_AL          O_Enter+2
#define O_Ubyte_AX          O_Ubyte_AL+2
#define O_AL_Ubyte          O_Ubyte_AX+2
#define O_AX_Ubyte          O_AL_Ubyte+2
#define O_DoInAL            O_AX_Ubyte+2
#define O_DoInAX            O_DoInAL+3
#define O_DoOutAL           O_DoInAX+3
#define O_DoOutAX           O_DoOutAL+3
#define O_Rel16             O_DoOutAX+3
#define O_ADR_OVERRIDE      O_Rel16+1
#define O_OPR_OVERRIDE      O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE      O_OPR_OVERRIDE+1
#define O_DoInt3            O_SEG_OVERRIDE+1
#define O_DoInt             117
#define O_OPC0F             O_DoInt+1
#define O_GROUP11           O_OPC0F+1
#define O_GROUP13           O_GROUP11+5
#define O_GROUP12           O_GROUP13+5
#define O_GROUP21           O_GROUP12+5
#define O_GROUP22           O_GROUP21+5
#define O_GROUP23           O_GROUP22+5
#define O_GROUP24           O_GROUP23+6
#define O_GROUP25           O_GROUP24+6
#define O_GROUP26           O_GROUP25+6
#define O_GROUP4            O_GROUP26+6
#define O_GROUP6            O_GROUP4+4
#define O_GROUP8            O_GROUP6+4
#define O_GROUP31           O_GROUP8+5
#define O_GROUP32           O_GROUP31+3
#define O_GROUP5            O_GROUP32+3
#define O_GROUP7            O_GROUP5+3
#define O_x87_ESC           O_GROUP7+3
#define O_bModrm            O_x87_ESC+2
#define O_wModrm            O_bModrm+2
#define O_dModrm            O_wModrm+2
#define O_fModrm            O_dModrm+2
#define O_vModrm            O_fModrm+2
#define O_vModrm_Iv         O_vModrm+2
#define O_Reg_bModrm        O_vModrm_Iv+3
#define O_Reg_wModrm        O_Reg_bModrm+3
#define O_Modrm_Reg_Ib      O_Reg_wModrm+3
#define O_Modrm_Reg_CL      O_Modrm_Reg_Ib+4
#define O_ST_iST            O_Modrm_Reg_CL+5
#define O_iST               O_ST_iST+2
#define O_iST_ST            O_iST+2
#define O_qModrm            O_iST_ST+2
#define O_tModrm            O_qModrm+2
#define O_DoRep             O_tModrm+2
#define O_Modrm_CReg        O_DoRep+1
#define O_CReg_Modrm        O_Modrm_CReg+3
#define O_AX_oReg           O_CReg_Modrm+3
#define O_MmReg_qModrm      O_AX_oReg+2
#define O_qModrm_MmReg      O_MmReg_qModrm+3
#define O_MmReg_dModrm      O_qModrm_MmReg+3
#define O_dModrm_MmReg      O_MmReg_dModrm+3
#define O_qModrm_Ib         O_dModrm_MmReg+3
#define O_PSHimw            O_qModrm_Ib+3
#define O_PSHimd            O_PSHimw+5
#define O_PSHimq            O_PSHimd+5
#define O_length            O_PSHimq+5

typedef unsigned short ActionIndex;

typedef struct Tdistbl
{
    ActionIndex opr;
} Tdistbl;

typedef struct _ADDR 
{
    USHORT      type;
    USHORT      seg;
    ULONG       off;
    union 
    {
        ULONG flat;
        ULONGLONG flat64;
    };
} ADDR, *PADDR;


typedef struct _DECODEDATA
{
  int              mod;            // mod of mod/rm byte 
  int              rm;             // rm of mod/rm byte 
  int              ttt;            // return reg value (of mod/rm) 
  unsigned char    *pMem;          // current position in instruction 
  ADDR             EAaddr[2];      // offset of effective address
  int              EAsize[2];      // size of effective address item
  BOOL             fMovX;          // indicates a MOVSX or MOVZX
  BOOL             fMmRegEa;       // Use mm? registers in reg-only EA.
} DECODEDATA;

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  GROUP,   GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  xTBYTE,  UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR,   MMWREG,  MMQWORD
            };

unsigned char actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulb       */ VAR+MRM,   VREG+COM,   MODRM+COM, IB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, GROUP,      0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IB+END,
/* group1_2    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, GROUP,      2,         LMODRM+END,
/* group6      */ xWORD+MRM, GROUP,      3,         LMODRM+END,
/* group8      */ xWORD+MRM, GROUP,      4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ xTBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END,
/* MmReg_qModrm*/ MMQWORD+MRM, MMWREG+COM, LMODRM+END,
/* qModrm_MmReg*/ MMQWORD+MRM, MODRM+COM,  MMWREG+END,
/* MmReg_dModrm*/ xDWORD+MRM, MMWREG+COM,LMODRM+END,
/* dModrm_MmReg*/ xDWORD+MRM, MODRM+COM, MMWREG+END,
/* qModrm_Ib   */ MMQWORD+MRM, MODRM+COM,IB+END,
/* PSHimw      */ MMQWORD+MRM, GROUP,    5,          LMODRM+COM, IB+END,
/* PSHimd      */ MMQWORD+MRM, GROUP,    6,          LMODRM+COM, IB+END,
/* PSHimq      */ MMQWORD+MRM, GROUP,    7,          LMODRM+COM, IB+END,
};

Tdistbl distbl[] = {
    O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    O_AL_Ib,                  /* 04 ADD AL, I                  */
    O_AX_Iv,                  /* 05 ADD AX, I                  */
    O_sReg2,                  /* 06 PUSH ES                    */
    O_sReg2,                  /* 07 POP ES                     */
    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    O_AL_Ib,                  /* 0C OR AL, I                   */
    O_AX_Iv,                  /* 0D OR AX, I                   */
    O_sReg2,                  /* 0E PUSH CS                    */
    O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    O_AL_Ib,                  /* 14 ADC AL, I                  */
    O_AX_Iv,                  /* 15 ADC AX, I                  */
    O_sReg2,                  /* 16 PUSH SS                    */
    O_sReg2,                  /* 17 POP SS                     */
    O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    O_AL_Ib,                  /* 1C SBB AL, I                  */
    O_AX_Iv,                  /* 1D SBB AX, I                  */
    O_sReg2,                  /* 1E PUSH DS                    */
    O_sReg2,                  /* 1F POP DS                     */
    O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    O_AL_Ib,                  /* 24 AND AL, I                  */
    O_AX_Iv,                  /* 25 AND AX, I                  */
    O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    O_NoOperands,             /* 27 DAA                        */
    O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    O_AL_Ib,                  /* 2C SUB AL, I                  */
    O_AX_Iv,                  /* 2D SUB AX, I                  */
    O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    O_NoOperands,             /* 2F DAS                        */
    O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    O_AL_Ib,                  /* 34 XOR AL, I                  */
    O_AX_Iv,                  /* 35 XOR AX, I                  */
    O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    O_NoOperands,             /* 37 AAA                        */
    O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    O_AL_Ib,                  /* 3C CMP AL, I                  */
    O_AX_Iv,                  /* 3D CMP AX, I                  */
    O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    O_NoOperands,             /* 3F AAS                        */
    O_oReg,                   /* 40 INC AX                     */
    O_oReg,                   /* 41 INC CX                     */
    O_oReg,                   /* 42 INC DX                     */
    O_oReg,                   /* 43 INC BX                     */
    O_oReg,                   /* 44 INC SP                     */
    O_oReg,                   /* 45 INC BP                     */
    O_oReg,                   /* 46 INC SI                     */
    O_oReg,                   /* 47 INC DI                     */
    O_oReg,                   /* 48 DEC AX                     */
    O_oReg,                   /* 49 DEC CX                     */
    O_oReg,                   /* 4A DEC DX                     */
    O_oReg,                   /* 4B DEC BX                     */
    O_oReg,                   /* 4C DEC SP                     */
    O_oReg,                   /* 4D DEC BP                     */
    O_oReg,                   /* 4E DEC SI                     */
    O_oReg,                   /* 4F DEC DI                     */
    O_oReg,                   /* 50 PUSH AX                    */
    O_oReg,                   /* 51 PUSH CX                    */
    O_oReg,                   /* 52 PUSH DX                    */
    O_oReg,                   /* 53 PUSH BX                    */
    O_oReg,                   /* 54 PUSH SP                    */
    O_oReg,                   /* 55 PUSH BP                    */
    O_oReg,                   /* 56 PUSH SI                    */
    O_oReg,                   /* 57 PUSH DI                    */
    O_oReg,                   /* 58 POP AX                     */
    O_oReg,                   /* 59 POP CX                     */
    O_oReg,                   /* 5A POP DX                     */
    O_oReg,                   /* 5B POP BX                     */
    O_oReg,                   /* 5C POP SP                     */
    O_oReg,                   /* 5D POP BP                     */
    O_oReg,                   /* 5E POP SI                     */
    O_oReg,                   /* 5F POP DI                     */
    O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    O_SEG_OVERRIDE,           /* 64                            */
    O_SEG_OVERRIDE,           /* 65                            */
    O_OPR_OVERRIDE,           /* 66                            */
    O_ADR_OVERRIDE,           /* 67                            */
    O_Iv,                     /* 68 PUSH word (286)            */
    O_Imul,                   /* 69 IMUL (286)                 */
    O_Ib,                     /* 6A PUSH byte (286)            */
    O_Imulb,                  /* 6B IMUL (286)                 */
    O_NoOperands,             /* 6C INSB (286)                 */
    O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    O_NoOperands,             /* 6E OUTSB (286)                */
    O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    O_Rel8,                   /* 70 JO                         */
    O_Rel8,                   /* 71 JNO                        */
    O_Rel8,                   /* 72 JB or JNAE or JC           */
    O_Rel8,                   /* 73 JNB or JAE or JNC          */
    O_Rel8,                   /* 74 JE or JZ                   */
    O_Rel8,                   /* 75 JNE or JNZ                 */
    O_Rel8,                   /* 76 JBE or JNA                 */
    O_Rel8,                   /* 77 JNBE or JA                 */
    O_Rel8,                   /* 78 JS                         */
    O_Rel8,                   /* 79 JNS                        */
    O_Rel8,                   /* 7A JP or JPE                  */
    O_Rel8,                   /* 7B JNP or JPO                 */
    O_Rel8,                   /* 7C JL or JNGE                 */
    O_Rel8,                   /* 7D JNL or JGE                 */
    O_Rel8,                   /* 7E JLE or JNG                 */
    O_Rel8,                   /* 7F JNLE or JG                 */
    O_GROUP11,                /* 80                            */
    O_GROUP12,                /* 81                            */
    O_DoDB,                   /* 82                            */
    O_GROUP13,                /* 83                            */
    O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    O_Reg_Modrm,              /* 8D LEA reg, mem               */
    O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    O_Modrm,                  /* 8F POP mem/reg                */
    O_NoOperands,             /* 90 NOP                        */
    O_AX_oReg,                /* 91 XCHG AX,CX                 */
    O_AX_oReg,                /* 92 XCHG AX,DX                 */
    O_AX_oReg,                /* 93 XCHG AX,BX                 */
    O_AX_oReg,                /* 94 XCHG AX,SP                 */
    O_AX_oReg,                /* 95 XCHG AX,BP                 */
    O_AX_oReg,                /* 96 XCHG AX,SI                 */
    O_AX_oReg,                /* 97 XCHG AX,DI                 */
    O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    O_FarPtr,                 /* 9A CALL seg:off               */
    O_NoOperands,             /* 9B WAIT                       */
    O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    O_NoOperands,             /* 9E SAHF                       */
    O_NoOperands,             /* 9F LAHF                       */
    O_AL_Offs,                /* A0 MOV AL, mem                */
    O_AX_Offs,                /* A1 MOV AX, mem                */
    O_Offs_AL,                /* A2 MOV mem, AL                */
    O_Offs_AX,                /* A3 MOV mem, AX                */
    O_NoOpStrSIDI,            /* A4 MOVSB                      */
    O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    O_NoOpStrSIDI,            /* A6 CMPSB                      */
    O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    O_AL_Ib,                  /* A8 TEST AL, I                 */
    O_AX_Iv,                  /* A9 TEST AX, I                 */
    O_NoOpStrDI,              /* AA STOSB                      */
    O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    O_NoOpStrSI,              /* AC LODSB                      */
    O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    O_NoOpStrDI,              /* AE SCASB                      */
    O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    O_oReg_Ib,                /* B0 MOV AL, I                  */
    O_oReg_Ib,                /* B1 MOV CL, I                  */
    O_oReg_Ib,                /* B2 MOV DL, I                  */
    O_oReg_Ib,                /* B3 MOV BL, I                  */
    O_oReg_Ib,                /* B4 MOV AH, I                  */
    O_oReg_Ib,                /* B5 MOV CH, I                  */
    O_oReg_Ib,                /* B6 MOV DH, I                  */
    O_oReg_Ib,                /* B7 MOV BH, I                  */
    O_oReg_Iv,                /* B8 MOV AX, I                  */
    O_oReg_Iv,                /* B9 MOV CX, I                  */
    O_oReg_Iv,                /* BA MOV DX, I                  */
    O_oReg_Iv,                /* BB MOV BX, I                  */
    O_oReg_Iv,                /* BC MOV SP, I                  */
    O_oReg_Iv,                /* BD MOV BP, I                  */
    O_oReg_Iv,                /* BE MOV SI, I                  */
    O_oReg_Iv,                /* BF MOV DI, I                  */
    O_GROUP21,                /* C0 shifts & rotates (286)     */
    O_GROUP22,                /* C1 shifts & rotates (286)     */
    O_Iw,                     /* C2 RET Rel16                  */
    O_NoOperands,             /* C3 RET                        */
    O_fReg_Modrm,             /* C4 LES reg, mem               */
    O_fReg_Modrm,             /* C5 LDS reg, mem               */
    O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    O_Enter,                  /* C8 ENTER (286)                */
    O_NoOperands,             /* C9 LEAVE (286)                */
    O_Iw,                     /* CA RETF I(word)               */
    O_NoOperands,             /* CB RETF                       */
    O_DoInt3,                 /* CC INT 3                      */
    O_DoInt,                  /* CD INT                        */
    O_NoOperands,             /* CE INTO                       */
    O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    O_Ib,                     /* D4 AAM                        */
    O_Ib,                     /* D5 AAD                        */
    O_DoDB,                   /* D6                            */
    O_NoOperands,             /* D7 XLAT                       */
    O_x87_ESC,                /* D8 ESC                        */
    O_x87_ESC,                /* D9 ESC                        */
    O_x87_ESC,                /* DA ESC                        */
    O_x87_ESC,                /* DB ESC                        */
    O_x87_ESC,                /* DC ESC                        */
    O_x87_ESC,                /* DD ESC                        */
    O_x87_ESC,                /* DE ESC                        */
    O_x87_ESC,                /* DF ESC                        */
    O_Rel8,                   /* E0 LOOPNE or LOOPNZ           */
    O_Rel8,                   /* E1 LOOPE or LOOPZ             */
    O_Rel8,                   /* E2 LOOP                       */
    O_Rel8,                   /* E3 JCXZ / JECXZ (386)         */
    O_AL_Ubyte,               /* E4 IN AL, I                   */
    O_AX_Ubyte,               /* E5 IN AX, I                   */
    O_Ubyte_AL,               /* E6 OUT I, AL                  */
    O_Ubyte_AX,               /* E7 OUT I, AX                  */
    O_Rel16,                  /* E8 CALL Rel16                 */
    O_Rel16,                  /* E9 JMP Rel16                  */
    O_FarPtr,                 /* EA JMP seg:off                */
    O_Rel8,                   /* EB JMP Rel8                   */
    O_DoInAL,                 /* EC IN AL, DX                  */
    O_DoInAX,                 /* ED IN AX, DX                  */
    O_DoOutAL,                /* EE OUT DX, AL                 */
    O_DoOutAX,                /* EF OUT DX, AX                 */
    O_DoRep,                  /* F0 LOCK                       */
    O_DoDB,                   /* F1                            */
    O_DoRep,                  /* F2 REPNE or REPNZ             */
    O_DoRep,                  /* F3 REP or REPE or REPZ        */
    O_NoOperands,             /* F4 HLT                        */
    O_NoOperands,             /* F5 CMC                        */
    O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    O_NoOperands,             /* F8 CLC                        */
    O_NoOperands,             /* F9 STC                        */
    O_NoOperands,             /* FA CLI                        */
    O_NoOperands,             /* FB STI                        */
    O_NoOperands,             /* FC CLD                        */
    O_NoOperands,             /* FD STD                        */
    O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    // secondary opcode table begins. Only "filled" locations are stored
    // to compress the secondary table. Hence while disassembling
    // opcode needs to be displaced appropriately to account for the.
    // The displacements are defined in 86dis.c and need to be reevaluated
    // if new opcodes are added here.

    O_GROUP6,                 /* 0 MULTI                       */
    O_GROUP7,                 /* 1 MULTI                       */
    O_Reg_Modrm,              /* 2 LAR                         */
    O_Reg_Modrm,              /* 3 LSL                         */
    O_DoDB,                   /* 4                             */
    O_NoOperands,             /* 5 LOADALL                     */
    O_NoOperands,             /* 6 CLTS                        */
    O_GROUP7,                 /* 7 MULTI                       */
    O_NoOperands,             /* 8 INVD                        */
    O_NoOperands,             /* 9 WBINVD                      */
    O_DoDB,                   /* A                             */
    O_NoOperands,             /* B UD2 undefined               */
    O_Modrm_CReg,             /* 20 MOV Rd,Cd                  */
    O_Modrm_CReg,             /* 21 MOV Rd,Dd                  */
    O_CReg_Modrm,             /* 22 MOV Cd,Rd                  */
    O_CReg_Modrm,             /* 23 MOV Dd,Rd                  */
    O_Modrm_CReg,             /* 24 MOV Rd,Td                  */
    O_DoDB,                   /* 25                            */
    O_CReg_Modrm,             /* 26 MOV Td,Rd                  */

    O_NoOperands,             /* 30 WRMSR                      */
    O_NoOperands,             /* 31 RDTSC                      */
    O_NoOperands,             /* 32 RDMSR                      */
    O_NoOperands,             /* 33 RDPMC                      */

    O_Reg_Modrm,              /* 40 CMOVO                      */
    O_Reg_Modrm,              /* 41 CMOVNO                     */
    O_Reg_Modrm,              /* 42 CMOVB                      */
    O_Reg_Modrm,              /* 43 CMOVNB                     */
    O_Reg_Modrm,              /* 44 CMOVE                      */
    O_Reg_Modrm,              /* 45 CMOVNE                     */
    O_Reg_Modrm,              /* 46 CMOVBE                     */
    O_Reg_Modrm,              /* 47 CMOVNBE                    */
    O_Reg_Modrm,              /* 48 CMOVS                      */
    O_Reg_Modrm,              /* 49 CMOVNS                     */
    O_Reg_Modrm,              /* 4A CMOVP                      */
    O_Reg_Modrm,              /* 4B CMOVNP                     */
    O_Reg_Modrm,              /* 4C CMOVL                      */
    O_Reg_Modrm,              /* 4D CMOVGE                     */
    O_Reg_Modrm,              /* 4E CMOVLE                     */
    O_Reg_Modrm,              /* 4F CMOVNLE                    */ 

    O_MmReg_qModrm,           /* 60 PUNPCKLBW                  */
    O_MmReg_qModrm,           /* 61 PUNPCKLWD                  */
    O_MmReg_qModrm,           /* 62 PUNPCKLDQ                  */
    O_MmReg_qModrm,           /* 63 PACKSSWB                   */
    O_MmReg_qModrm,           /* 64 PCMPGTB                    */
    O_MmReg_qModrm,           /* 65 PCMPGTW                    */
    O_MmReg_qModrm,           /* 66 PCMPGTD                    */
    O_MmReg_qModrm,           /* 67 PACKUSWB                   */
    O_MmReg_qModrm,           /* 68 PUNPCKHBW                  */
    O_MmReg_qModrm,           /* 69 PUNPCKHWD                  */
    O_MmReg_qModrm,           /* 6A PUNPCKHDQ                  */
    O_MmReg_qModrm,           /* 6B PACKSSDW                   */
    O_DoDB,                   /* 6C                            */
    O_DoDB,                   /* 6D                            */
    O_MmReg_dModrm,           /* 6E MOVD                       */
    O_MmReg_qModrm,           /* 6F MOVQ                       */
    O_DoDB,                   /* 70                            */
    O_PSHimw,                 /* 71 PS[LR][AL]W immediate      */
    O_PSHimd,                 /* 72 PS[LR][AL]D immediate      */
    O_PSHimq,                 /* 73 PS[LR]LQ immediate         */
    O_MmReg_qModrm,           /* 74 PCMPEQB                    */
    O_MmReg_qModrm,           /* 75 PCMPEQW                    */
    O_MmReg_qModrm,           /* 76 PCMPEQD                    */
    O_NoOperands,             /* 77 EMMS                       */
    O_DoDB,                   /* 78                            */
    O_DoDB,                   /* 79                            */
    O_DoDB,                   /* 7A                            */
    O_DoDB,                   /* 7B                            */
    O_DoDB,                   /* 7C                            */
    O_bModrm,                 /* 7D SETNL                      */
    O_dModrm_MmReg,           /* 7E MOVD                       */
    O_qModrm_MmReg,           /* 7F MOVQ                       */
    O_Rel16,                  /* 80 JO                         */
    O_Rel16,                  /* 81 JNO                        */
    O_Rel16,                  /* 82 JB                         */
    O_Rel16,                  /* 83 JNB                        */
    O_Rel16,                  /* 84 JE                         */
    O_Rel16,                  /* 85 JNE                        */
    O_Rel16,                  /* 86 JBE                        */
    O_Rel16,                  /* 87 JNBE                       */
    O_Rel16,                  /* 88 JS                         */
    O_Rel16,                  /* 89 JNS                        */
    O_Rel16,                  /* 8A JP                         */
    O_Rel16,                  /* 8B JNP                        */
    O_Rel16,                  /* 8C JL                         */
    O_Rel16,                  /* 8D JNL                        */
    O_Rel16,                  /* 8E JLE                        */
    O_Rel16,                  /* 8F JNLE                       */
    O_bModrm,                 /* 90 SETO                       */
    O_bModrm,                 /* 91 SETNO                      */
    O_bModrm,                 /* 92 SETB                       */
    O_bModrm,                 /* 93 SETNB                      */
    O_bModrm,                 /* 94 SETE                       */
    O_bModrm,                 /* 95 SETNE                      */
    O_bModrm,                 /* 96 SETBE                      */
    O_bModrm,                 /* 97 SETNBE                     */
    O_bModrm,                 /* 98 SETS                       */
    O_bModrm,                 /* 99 SETNS                      */
    O_bModrm,                 /* 9A SETP                       */
    O_bModrm,                 /* 9B SETNP                      */
    O_bModrm,                 /* 9C SETL                       */
    O_bModrm,                 /* 9D SETGE                      */
    O_bModrm,                 /* 9E SETLE                      */
    O_bModrm,                 /* 9F SETNLE                     */
    O_sReg2,                  /* A0 PUSH FS                    */
    O_sReg2,                  /* A1 POP FS                     */
    O_NoOperands,             /* A2 CPUID                      */
    O_Modrm_Reg,              /* A3 BT                         */
    O_Modrm_Reg_Ib,           /* A4 SHLD                       */
    O_Modrm_Reg_CL,           /* A5 SHLD                       */
    O_DoDB,                   /* A6                            */
    O_DoDB,                   /* A7                            */
    O_sReg2,                  /* A8 PUSH GS                    */
    O_sReg2,                  /* A9 POP GS                     */
    O_NoOperands,             /* AA RSM                        */
    O_vModrm_Reg,             /* AB BTS                        */
    O_Modrm_Reg_Ib,           /* AC SHRD                       */
    O_Modrm_Reg_CL,           /* AD SHRD                       */
    O_DoDB,                   /* AE                            */
    O_Reg_Modrm,              /* AF IMUL                       */
    O_bModrm_Reg,             /* B0 CMPXCH                     */
    O_Modrm_Reg,              /* B1 CMPXCH                     */
    O_fReg_Modrm,             /* B2 LSS                        */
    O_Modrm_Reg,              /* B3 BTR                        */
    O_fReg_Modrm,             /* B4 LFS                        */
    O_fReg_Modrm,             /* B5 LGS                        */
    O_Reg_bModrm,             /* B6 MOVZX                      */
    O_Reg_wModrm,             /* B7 MOVZX                      */
    O_DoDB,                   /* B8                            */
    O_DoDB,                   /* B9                            */
    O_GROUP8,                 /* BA MULTI                      */
    O_Modrm_Reg,              /* BB BTC                        */
    O_Reg_Modrm,              /* BC BSF                        */
    O_Reg_Modrm,              /* BD BSR                        */
    O_Reg_bModrm,             /* BE MOVSX                      */
    O_Reg_wModrm,             /* BF MOVSX                      */
    O_bModrm_Reg,             /* C0 XADD                       */
    O_Modrm_Reg,              /* C1 XADD                       */
    O_DoDB,                   /* C2                            */
    O_DoDB,                   /* C3                            */
    O_DoDB,                   /* C4                            */
    O_DoDB,                   /* C5                            */
    O_DoDB,                   /* C6                            */
    O_qModrm,                 /* C7 CMPXCHG8B                  */
    O_oReg,                   /* C8 BSWAP                      */
    O_oReg,                   /* C9 BSWAP                      */
    O_oReg,                   /* CA BSWAP                      */
    O_oReg,                   /* CB BSWAP                      */
    O_oReg,                   /* CC BSWAP                      */
    O_oReg,                   /* CD BSWAP                      */
    O_oReg,                   /* CE BSWAP                      */
    O_oReg,                   /* CF BSWAP                      */
    O_DoDB,                   /* D0                            */
    O_MmReg_qModrm,           /* D1 PSRLW                      */
    O_MmReg_qModrm,           /* D2 PSRLD                      */
    O_MmReg_qModrm,           /* D3 PSRLQ                      */
    O_DoDB,                   /* D4                            */
    O_MmReg_qModrm,           /* D5 PMULLW                     */
    O_DoDB,                   /* D6                            */
    O_DoDB,                   /* D7                            */
    O_MmReg_qModrm,           /* D8 PSUBUSB                    */
    O_MmReg_qModrm,           /* D9 PSUBUSW                    */
    O_DoDB,                   /* DA                            */
    O_MmReg_qModrm,           /* DB PAND                       */
    O_MmReg_qModrm,           /* DC PADDUSB                    */
    O_MmReg_qModrm,           /* DD PADDUSW                    */
    O_DoDB,                   /* DE                            */
    O_MmReg_qModrm,           /* DF PANDN                      */
    O_DoDB,                   /* E0                            */
    O_MmReg_qModrm,           /* E1 PSRAW                      */
    O_MmReg_qModrm,           /* E2 PSRAD                      */
    O_DoDB,                   /* E3                            */
    O_DoDB,                   /* E4                            */
    O_MmReg_qModrm,           /* E5 PMULHW                     */
    O_DoDB,                   /* E6                            */
    O_DoDB,                   /* E7                            */
    O_MmReg_qModrm,           /* E8 PSUBSB                     */
    O_MmReg_qModrm,           /* E9 PSUBSW                     */
    O_DoDB,                   /* EA                            */
    O_MmReg_qModrm,           /* EB POR                        */
    O_MmReg_qModrm,           /* EC PADDSB                     */
    O_MmReg_qModrm,           /* ED PADDSW                     */
    O_DoDB,                   /* EE                            */
    O_MmReg_qModrm,           /* EF PXOR                       */
    O_DoDB,                   /* F0                            */
    O_MmReg_qModrm,           /* F1 PSLLW                      */
    O_MmReg_qModrm,           /* F2 PSLLD                      */
    O_MmReg_qModrm,           /* F3 PSLLQ                      */
    O_DoDB,                   /* F4                            */
    O_MmReg_qModrm,           /* F5 PMADDWD                    */
    O_DoDB,                   /* F6                            */
    O_DoDB,                   /* F7                            */
    O_MmReg_qModrm,           /* F8 PSUBB                      */
    O_MmReg_qModrm,           /* F9 PSUBW                      */
    O_MmReg_qModrm,           /* FA PSUBD                      */
    O_DoDB,                   /* FB                            */
    O_MmReg_qModrm,           /* FC PADDB                      */
    O_MmReg_qModrm,           /* FD PADDW                      */
    O_MmReg_qModrm,           /* FE PADDD                      */
};

Tdistbl groupt[][8] = {
/* 00  00                     x87-D8-1                   */
        { O_dModrm,     /* D8-0 FADD    */
          O_dModrm,     /* D8-1 FMUL    */
          O_dModrm,     /* D8-2 FCOM    */
          O_dModrm,     /* D8-3 FCOMP   */
          O_dModrm,     /* D8-4 FSUB    */
          O_dModrm,     /* D8-5 FSUBR   */
          O_dModrm,     /* D8-6 FDIV    */
          O_dModrm },   /* D8-7 FDIVR   */
/* 01                         x87-D8-2                   */
        { O_ST_iST,     /* D8-0 FADD    */
          O_ST_iST,     /* D8-1 FMUL    */
          O_iST,        /* D8-2 FCOM    */
          O_iST,        /* D8-3 FCOMP   */
          O_ST_iST,     /* D8-4 FSUB    */
          O_ST_iST,     /* D8-5 FSUBR   */
          O_ST_iST,     /* D8-6 FDIV    */
          O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
        { O_dModrm,     /* D9-0 FLD     */
          O_DoDB,       /* D9-1         */
          O_dModrm,     /* D9-2 FST     */
          O_dModrm,     /* D9-3 FSTP    */
          O_Modrm,      /* D9-4 FLDENV  */
          O_Modrm,      /* D9-5 FLDCW   */
          O_Modrm,      /* D9-6 FSTENV  */
          O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
        { O_iST,        /* D9-0 FLD     */
          O_iST,        /* D9-1 FXCH    */
          O_NoOperands, /* D9-2 FNOP    */
          O_iST,        /* D9-3 FSTP    */
          O_DoDB,       /* D9-4         */
          O_DoDB,       /* D9-5         */
          O_DoDB,       /* D9-6         */
          O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
        { O_dModrm,     /* DA-0 FIADD   */
          O_dModrm,     /* DA-1 FIMUL   */
          O_dModrm,     /* DA-2 FICOM   */
          O_dModrm,     /* DA-3 FICOMP  */
          O_dModrm,     /* DA-4 FISUB   */
          O_dModrm,     /* DA-5 FISUBR  */
          O_dModrm,     /* DA-6 FIDIV   */
          O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
        { O_ST_iST,     /* DA-0 FCMOVB  */
          O_ST_iST,     /* DA-1 FCMOVE  */
          O_ST_iST,     /* DA-2 FCMOVBE */
          O_ST_iST,     /* DA-3 FCMOVU  */
          O_DoDB,       /* DA-4         */
          O_NoOperands, /* DA-5         */
          O_DoDB,       /* DA-6         */
          O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
        { O_dModrm,     /* DB-0 FILD    */
          O_DoDB,       /* DB-1         */
          O_dModrm,     /* DB-2 FIST    */
          O_dModrm,     /* DB-3 FISTP   */
          O_DoDB,       /* DB-4         */
          O_tModrm,     /* DB-5 FLD     */
          O_DoDB,       /* DB-6         */
          O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
        { O_NoOperands, /* DB-0 FENI    */
          O_NoOperands, /* DB-1 FDISI   */
          O_NoOperands, /* DB-2 FCLEX   */
          O_NoOperands, /* DB-3 FINIT   */
          O_DoDB,       /* DB-4 FSETPM  */
          O_DoDB,       /* DB-5         */
          O_DoDB,       /* DB-6         */
          O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
        { O_qModrm,     /* DC-0 FADD    */
          O_qModrm,     /* DC-1 FMUL    */
          O_qModrm,     /* DC-2 FCOM    */
          O_qModrm,     /* DC-3 FCOMP   */
          O_qModrm,     /* DC-4 FSUB    */
          O_qModrm,     /* DC-5 FSUBR   */
          O_qModrm,     /* DC-6 FDIV    */
          O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
        { O_iST_ST,     /* DC-0 FADD    */
          O_iST_ST,     /* DC-1 FMUL    */
          O_iST,        /* DC-2 FCOM    */
          O_iST,        /* DC-3 FCOMP   */
          O_iST_ST,     /* DC-4 FSUB    */
          O_iST_ST,     /* DC-5 FSUBR   */
          O_iST_ST,     /* DC-6 FDIVR   */
          O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
        { O_qModrm,     /* DD-0 FLD     */
          O_DoDB,       /* DD-1         */
          O_qModrm,     /* DD-2 FST     */
          O_qModrm,     /* DD-3 FSTP    */
          O_Modrm,      /* DD-4 FRSTOR  */
          O_DoDB,       /* DD-5         */
          O_Modrm,      /* DD-6 FSAVE   */
          O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
        { O_iST,        /* DD-0 FFREE   */
          O_iST,        /* DD-1 FXCH    */
          O_iST,        /* DD-2 FST     */
          O_iST,        /* DD-3 FSTP    */
          O_iST,        /* DD-4 FUCOM   */
          O_iST,        /* DD-5 FUCOMP  */
          O_DoDB,       /* DD-6         */
          O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
        { O_wModrm,     /* DE-0 FIADD   */
          O_wModrm,     /* DE-1 FIMUL   */
          O_wModrm,     /* DE-2 FICOM   */
          O_wModrm,     /* DE-3 FICOMP  */
          O_wModrm,     /* DE-4 FISUB   */
          O_wModrm,     /* DE-5 FISUBR  */
          O_wModrm,     /* DE-6 FIDIV   */
          O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
        { O_iST_ST,     /* DE-0 FADDP   */
          O_iST_ST,     /* DE-1 FMULP   */
          O_iST,        /* DE-2 FCOMP   */
          O_NoOperands, /* DE-3 FCOMPP  */
          O_iST_ST,     /* DE-4 FSUBP   */
          O_iST_ST,     /* DE-5 FSUBRP  */
          O_iST_ST,     /* DE-6 FDIVP   */
          O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
        { O_wModrm,     /* DF-0 FILD    */
          O_DoDB,       /* DF-1         */
          O_wModrm,     /* DF-2 FIST    */
          O_wModrm,     /* DF-3 FISTP   */
          O_tModrm,     /* DF-4 FBLD    */
          O_qModrm,     /* DF-5 FILD    */
          O_tModrm,     /* DF-6 FBSTP   */
          O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
        { O_iST,        /* DF-0 FFREE   */
          O_iST,        /* DF-1 FXCH    */
          O_iST,        /* DF-2 FST     */
          O_iST,        /* DF-3 FSTP    */
          O_NoOperands, /* DF-4 FSTSW   */
          O_ST_iST,     /* DF-5 FUCOMIP */
          O_ST_iST,     /* DF-6 FCOMIP  */
          O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
        { O_NoOperands, /* D9-0 FCHS    */
          O_NoOperands,  /* D9-1 FABS   */
          O_DoDB,       /* D9-2         */
          O_DoDB,       /* D9-3         */
          O_NoOperands, /* D9-4 FTST    */
          O_NoOperands, /* D9-5 FXAM    */
          O_DoDB,       /* D9-6         */
          O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
        { O_NoOperands, /* D9-0 FLD1    */
          O_NoOperands, /* D9-1 FLDL2T  */
          O_NoOperands, /* D9-2 FLDL2E  */
          O_NoOperands, /* D9-3 FLDPI   */
          O_NoOperands, /* D9-4 FLDLG2  */
          O_NoOperands, /* D9-5 FLDLN2  */
          O_NoOperands, /* D9-6 FLDZ    */
          O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
        { O_NoOperands,   /* D9-0 F2XM1   */
          O_NoOperands,   /* D9-1 FYL2X   */
          O_NoOperands,   /* D9-2 FPTAN   */
          O_NoOperands,   /* D9-3 FPATAN  */
          O_NoOperands,   /* D9-4 FXTRACT */
          O_NoOperands,   /* D9-5 FPREM1  */
          O_NoOperands,   /* D9-6 FDECSTP */
          O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
        { O_NoOperands,   /* D9-0 FPREM   */
          O_NoOperands,   /* D9-1 FYL2XP1 */
          O_NoOperands,   /* D9-2 FSQRT   */
          O_NoOperands,   /* D9-3 FSINCOS */
          O_NoOperands,   /* D9-4 FRNDINT */
          O_NoOperands,   /* D9-5 FSCALE  */
          O_NoOperands,   /* D9-6 FSIN    */
          O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
        { O_bModrm_Ib,    /* F6-0 TEST    */
          O_DoDB,         /* F6-1         */
          O_bModrm,       /* F6-2 NOT     */
          O_bModrm,       /* F6-3 NEG     */
          O_bModrm,       /* F6-4 MUL     */
          O_bModrm,       /* F6-5 IMUL    */
          O_bModrm,       /* F6-6 DIV     */
          O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
        { O_vModrm_Iv,    /* F7-0 TEST    */
          O_DoDB,         /* F7-1         */
          O_vModrm,       /* F7-2 NOT     */
          O_vModrm,       /* F7-3 NEG     */
          O_vModrm,       /* F7-4 MUL     */
          O_vModrm,       /* F7-5 IMUL    */
          O_vModrm,       /* F7-6 DIV     */
          O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
        { O_vModrm,     /* FF-0 INC       */
          O_vModrm,     /* FF-1 DEC       */
          O_vModrm,     /* FF-2 CALL      */
          O_fModrm,     /* FF-3 CALL      */
          O_vModrm,     /* FF-4 JMP       */
          O_fModrm,     /* FF-5 JMP       */
          O_vModrm,     /* FF-6 PUSH      */
          O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
        { O_Modrm,      /* 0F-0 SGDT      */
          O_Modrm,      /* 0F-1 SIDT      */
          O_Modrm,      /* 0F-2 LGDT      */
          O_Modrm,      /* 0F-3 LIDT      */
          O_wModrm,     /* 0F-4 MSW       */
          O_DoDB,       /* 0F-5           */
          O_wModrm,     /* 0F-6 LMSW      */
          O_Modrm },    /* 0F-7 INVLPG    */

/* 24                 x87-DB Mod=3 TTT != 4                */
        { O_ST_iST,     /* DB-0 FCMOVNB   */
          O_ST_iST,     /* DB-1 FCMOVNE   */
          O_ST_iST,     /* DB-2 FCMOVNBE  */
          O_ST_iST,     /* DB-3 FCMOVNU   */
          O_DoDB,       /* DB-4           */
          O_ST_iST,     /* DB-5 FUCOMI    */
          O_ST_iST,     /* DB-6 FCOMI     */
          O_DoDB }      /* DB-7           */
        };

DWORD 
GetInstructionLengthFromAddress(LPBYTE pEip)
{
    
    int     G_mode_32;
    int     mode_32;                    // local addressing mode indicator 
    int     opsize_32;                  // operand size flag 
    int     opcode;                     // current opcode 
    int     olen = 2;                   // operand length 
    int     alen = 2;                   // address length 
    int     end = FALSE;                // end of instruction flag 
    int     mrm = FALSE;                // indicator that modrm is generated
    unsigned char *action;              // action for operand interpretation
    long    tmp;                        // temporary storage field 
    int     indx;                       // temporary index 
    int     action2;                    // secondary action 
    int     instlen;                    // instruction length 
    int     segOvr = 0;                 // segment override opcode 
    unsigned char BOPaction;
    int     subcode;                    // bop subcode 
    DECODEDATA decodeData;

    decodeData.mod       = 0;
    decodeData.rm        = 0;
    decodeData.ttt       = 0;
    decodeData.fMovX     = FALSE;
    decodeData.fMmRegEa  = FALSE;
    decodeData.EAsize[0] = decodeData.EAsize[1] = 0;          //  no effective address

    G_mode_32 = 1;

    mode_32 = opsize_32 = (G_mode_32 == 1); // local addressing mode 
    olen = alen = (1 + mode_32) << 1;   // set operand/address lengths
                                        // 2 for 16-bit and 4 for 32-bit
    decodeData.pMem = pEip;             // point to begin of instruction 
    opcode = *(decodeData.pMem)++;      // get opcode 
    
    if (opcode == 0xc4 && *(decodeData.pMem) == 0xC4) 
    {
        (decodeData.pMem)++;
        action = &BOPaction;
        BOPaction = IB | END;
        subcode =  *(decodeData.pMem);
        if (subcode == 0x50 || subcode == 0x52 || 
            subcode == 0x53 || subcode == 0x54 || 
            subcode == 0x57 || subcode == 0x58 || 
            subcode == 0x58) 
        {
            BOPaction = IW | END;
        }
    } else 
    {
        action = actiontbl + distbl[opcode].opr; /* get operand action */
    }

    // loop through all operand actions

    do {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f) {
            case ALT:                   // alter the opcode if 32-bit 
                if (opsize_32) 
                {
                    indx = *action++;
                }
                break;

            case STROP:
                //  compute size of operands in indx
                //  also if dword operands, change fifth
                //  opcode letter from 'w' to 'd'.

                if (opcode & 1) 
                {
                    if (opsize_32) 
                    {
                        indx = 4;
                    }
                    else
                    {
                        indx = 2;
                    }
                }
                else
                {
                    indx = 1;
                }

                break;

            case CHR:                   // insert a character 
                action++;
                break;

            case CREG:                  // set debug, test or control reg 
                break;

            case SREG2:                 // segment register 
                // Handle special case for fs/gs (OPC0F adds SECTAB_OFFSET_5
                // to these codes)
                if (opcode > 0x7e)
                {
                    decodeData.ttt = BIT53((opcode-SECTAB_OFFSET_5));
                }
                else
                {
                    decodeData.ttt = BIT53(opcode);    //  set value to fall through
                }

            case SREG3:                 // segment register 
                break;

            case BRSTR:                 // get index to register string 
                decodeData.ttt = *action++;        //    from action table 
                goto BREGlabel;

            case BOREG:                 // byte register (in opcode) 
                decodeData.ttt = BIT20(opcode);    // register is part of opcode 
                goto BREGlabel;

            case ALSTR:
                decodeData.ttt = 0;     // point to AL register 
    BREGlabel:
            case BREG:                  // general register 
                break;

            case WRSTR:                 // get index to register string 
                decodeData.ttt = *action++;        //    from action table 
                goto WREGlabel;

            case VOREG:                 // register is part of opcode 
                decodeData.ttt = BIT20(opcode);
                goto VREGlabel;

            case AXSTR:
                decodeData.ttt = 0;     // point to eAX register 
    VREGlabel:
            case VREG:                  // general register 
    WREGlabel:
            case WREG:                  // register is word size 
                break;

            case MMWREG:
                break;

            case IST_ST:
                break;

            case ST_IST:
                ;
            case IST:
                ;
                break;

            case xBYTE:                 // set instruction to byte only 
                decodeData.EAsize[0] = 1;
                break;

            case VAR:
                if (opsize_32)
                    goto DWORDlabel;

            case xWORD:
                decodeData.EAsize[0] = 2;
                break;

            case EDWORD:
                opsize_32 = 1;          //  for control reg move, use eRegs
            case xDWORD:
DWORDlabel:
                decodeData.EAsize[0] = 4;
                break;

            case MMQWORD:
                decodeData.fMmRegEa = TRUE;

            case QWORD:
                decodeData.EAsize[0] = 8;
                break;

            case xTBYTE:
                decodeData.EAsize[0] = 10;
                break;

            case FARPTR:
                if (opsize_32) {
                    decodeData.EAsize[0] = 6;
                    }
                else {
                    decodeData.EAsize[0] = 4;
                    }
                break;

            case LMODRM:                //  output modRM data type
                if (decodeData.mod != 3)
                    ;
                else
                    decodeData.EAsize[0] = 0;

            case MODRM:                 // output modrm string 
                if (segOvr)             // in case of segment override 
                    0;
                break;

            case ADDRP:                 // address pointer 
                decodeData.pMem += olen + 2;
                break;

            case REL8:                  // relative address 8-bit 
                tmp = (long)*(char *)(decodeData.pMem)++; // get the 8-bit rel offset 
                goto DoRelDispl;

            case REL16:                 // relative address 16-/32-bit 
                tmp = 0;
                if (mode_32)
                    MoveMemory(&tmp,decodeData.pMem,sizeof(long));
                else
                    MoveMemory(&tmp,decodeData.pMem,sizeof(short));
                decodeData.pMem += alen;           // skip over offset 
DoRelDispl:
                break;

            case UBYTE:                 //  unsigned byte for int/in/out
                decodeData.pMem++;
                break;

            case IB:                    // operand is immediate byte 
                if ((opcode & ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a
                    if (*(decodeData.pMem)++ != 0x0a) // test post-opcode byte
                        0;
                    break;
                    }
                olen = 1;               // set operand length 
                goto DoImmed;

            case IW:                    // operand is immediate word 
                olen = 2;               // set operand length 

            case IV:                    // operand is word or dword 
DoImmed:
                decodeData.pMem += olen;
                break;

            case OFFS:                  // operand is offset 
                decodeData.EAsize[0] = (opcode & 1) ? olen : 1;

                if (segOvr)             // in case of segment override 
                   0;

                decodeData.pMem += alen;
                break;

            case GROUP:                 // operand is of group 1,2,4,6 or 8 
                action++;               // output opcode symbol 
                break;

            case GROUPT:                // operand is of group 3,5 or 7 
                indx = *action;         // get indx into group from action 
                goto doGroupT;

            case EGROUPT:               // x87 ESC (D8-DF) group index 
                indx = BIT20(opcode) * 2; // get group index from opcode 
                if (decodeData.mod == 3) 
                {                       // some operand variations exists 
                                        // for x87 and mod == 3 
                    ++indx;             // take the next group table entry 
                    if (indx == 3) 
                    {                   // for x87 ESC==D9 and mod==3 
                        if (decodeData.ttt > 3) 
                        {               // for those D9 instructions 
                            indx = 12 + decodeData.ttt; // offset index to table by 12 
                            decodeData.ttt = decodeData.rm;   // set secondary index to rm 
                        }
                    }
                    else if (indx == 7) 
                    { // for x87 ESC==DB and mod==3 
                        if (decodeData.ttt == 4) 
                        {               
                            decodeData.ttt = decodeData.rm;     // set secondary group table index 
                        } else if ((decodeData.ttt<4)||(decodeData.ttt>4 && decodeData.ttt<7)) 
                        {
                            // adjust for pentium pro opcodes
                            indx = 24;   // offset index to table by 24
                        }
                    }
                }
doGroupT:
                // handle group with different types of operands 
                action = actiontbl + groupt[indx][decodeData.ttt].opr;
                // get new action 

                break;
            //
            // The secondary opcode table has been compressed in the
            // original design. Hence while disassembling the 0F sequence,
            // opcode needs to be displaced by an appropriate amount depending
            // on the number of "filled" entries in the secondary table.
            // These displacements are used throughout the code.
            //

            case OPC0F:              // secondary opcode table (opcode 0F) 
                opcode = *(decodeData.pMem)++;    // get real opcode 
                decodeData.fMovX  = (BOOL)(opcode == 0xBF || opcode == 0xB7);
                if (opcode < 12) // for the first 12 opcodes 
                    opcode += SECTAB_OFFSET_1; // point to begin of sec op tab
                else if (opcode > 0x1f && opcode < 0x27)
                    opcode += SECTAB_OFFSET_2; // adjust for undefined opcodes
                else if (opcode > 0x2f && opcode < 0x34)
                    opcode += SECTAB_OFFSET_3; // adjust for undefined opcodes
                else if (opcode > 0x3f && opcode < 0x50)
                    opcode += SECTAB_OFFSET_4; // adjust for undefined opcodes
                else if (opcode > 0x5f && opcode < 0xff)
                    opcode += SECTAB_OFFSET_5; // adjust for undefined opcodes
                else
                    opcode = SECTAB_OFFSET_UNDEF; // all non-existing opcodes
                goto getNxtByte1;

            case ADR_OVR:               // address override 
                mode_32 = !G_mode_32;   // override addressing mode 
                alen = (mode_32 + 1) << 1; // toggle address length 
                goto getNxtByte;

            case OPR_OVR:               // operand size override 
                opsize_32 = !G_mode_32; // override operand size 
                olen = (opsize_32 + 1) << 1; // toggle operand length 
                goto getNxtByte;

            case SEG_OVR:               // handle segment override 
                segOvr = opcode;        // save segment override opcode 
                goto getNxtByte;

            case REP:                   // handle rep/lock prefixes 
    getNxtByte:
                opcode = *(decodeData.pMem)++;        // next byte is opcode 
    getNxtByte1:
                action = actiontbl + distbl[opcode].opr;

            default:                    // opcode has no operand 
                break;
            }

            switch (action2) 
            {              // secondary action 
                case MRM:                   // generate modrm for later use 
                    if (!mrm) 
                    {             // ignore if it has been generated 
                        //DIdoModrm(segOvr, &decodeData);

                        int     newmrm;                        // modrm byte 
                        int     sib = 0;
                        int     ss;
                        int     ind;
                        int     oldrm;

                        newmrm = *(decodeData.pMem)++;                // get the mrm byte from instruction 
                        decodeData.mod = BIT76(newmrm);               // get mod 
                        decodeData.ttt = BIT53(newmrm);               // get reg - used outside routine 
                        decodeData.rm  = BIT20(newmrm);               // get rm 

                        if (decodeData.mod == 3) 
                        {                                             // register only mode 
                            decodeData.EAsize[0] = 0;                 //  no EA value to output
                        }
                        else
                        {

                            // 32-bit addressing mode 
                            oldrm = decodeData.rm;
                            if (decodeData.rm == 4) 
                            {                                               // rm == 4 implies sib byte 
                                sib = *(decodeData.pMem)++;                // get s_i_b byte 
                                decodeData.rm = BIT20(sib);                // return base 
                            }

                            if (decodeData.mod == 0 && decodeData.rm == 5) 
                            {
                                decodeData.pMem += 4;
                            }

                            if (oldrm == 4) 
                            {               
                                //  finish processing sib
                                ind = BIT53(sib);
                                if (ind != 4) 
                                {
                                    ss = 1 << BIT76(sib);
                                }
                            }

                            //  output any displacement
                            if (decodeData.mod == 1) 
                            {
                                decodeData.pMem++;
                            }
                            else if (decodeData.mod == 2) 
                            {
                                decodeData.pMem += 4;
                            }
                        }

                        mrm = TRUE;         // remember its generation 
                    }
                    break;

                case COM:                   // insert a comma after operand 
                    break;

                case END:                   // end of instruction 
                    end = TRUE;
                    break;
        }
    } 
    while (!end);                        // loop til end of instruction 

    instlen = (decodeData.pMem) - pEip;

    return instlen;   
}

#endif

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\ignoreexception.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:
    
    IgnoreException.cpp

 Abstract:

    This shim is for handling exceptions that get thrown by bad apps.
    The primary causes of unhandled exceptions are:

        1. Priviliged mode instructions: cli, sti, out etc
        2. Access violations

    In most cases, ignoring an Access Violation will be fatal for the app,
    but it works in some cases, eg: 
    
        Deer Hunter 2 - their 3d algorithm reads too far back in a lookup 
        buffer. This is a game bug and doesn't crash win9x because that memory
        is usually allocated.

    Interstate 76 also requires a Divide by Zero exception to be ignored.

 Notes:

    This is a general purpose shim.

 History:

    02/10/2000  linstev     Created
    10/17/2000  maonis      Bug fix - now it ignores AVs correctly.
    02/27/2001  robkenny    Converted to use CString
    02/15/2002  robkenny    Shim was copying data into a temp buffer without verifying
                            that the buffer was large enough.
                            Cleaned up some signed/unsigned comparison mismatch.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreException)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

// Exception code for OutputDebugString
#define DBG_EXCEPTION  0x40010000L

// Determine how to manage second chance exceptions
BOOL g_bWin2000 = FALSE;
DWORD g_dwLastEip = 0;

extern DWORD GetInstructionLengthFromAddress(LPBYTE pEip);

typedef enum 
{
    eActive = 0, 
    eFirstChance, 
    eSecondChance,
    eExitProcess
} EMODE;

WCHAR * ToWchar(EMODE emode)
{
    switch (emode)
    {
    case eActive:
        return L"Active";

    case eFirstChance:
        return L"FirstChance";

    case eSecondChance:
        return L"SecondChance";

    case eExitProcess:
        return L"ExitProcess";
    };

    return L"ERROR";
}

// Convert a text version of EMODE to a EMODE value
EMODE ToEmode(const CString & csMode)
{
    if (csMode.Compare(L"0") == 0 || csMode.Compare(ToWchar(eActive)) == 0)
    {
        return eActive;
    }
    else if (csMode.Compare(L"1") == 0 || csMode.Compare(ToWchar(eFirstChance)) == 0)
    {
        return eFirstChance;
    }
    else if (csMode.Compare(L"2") == 0 || csMode.Compare(ToWchar(eSecondChance)) == 0)
    {
        return eSecondChance;
    }
    else if (csMode.Compare(L"3") == 0 || csMode.Compare(ToWchar(eExitProcess)) == 0)
    {
        return eExitProcess;
    }

    // Default value
    return eFirstChance;
}


static const DWORD DONT_CARE = 0xFFFFFFFF;

/*++

 This is the list of all the exceptions that this shim can handle. The fields are

    1. cName      - the name of the exception as accepted as a parameter and 
                    displayed in debug spew
    2. dwCode     - the exception code
    3. dwSubCode  - parameters specified by the exception: -1 = don't care
    4. dwIgnore   - ignore this exception: 
                    0 = don't ignore
                    1 = ignore 1st chance
                    2 = ignore 2nd chance
                    3 = exit process on 2nd chance.

--*/

struct EXCEPT
{
    WCHAR * cName;
    DWORD dwCode;
    DWORD dwSubCode;
    EMODE dwIgnore;
};

static EXCEPT g_eList[] =
{
    {L"ACCESS_VIOLATION_READ"    , (DWORD)EXCEPTION_ACCESS_VIOLATION        , 0 ,          eActive},
    {L"ACCESS_VIOLATION_WRITE"   , (DWORD)EXCEPTION_ACCESS_VIOLATION        , 1 ,          eActive},
    {L"ARRAY_BOUNDS_EXCEEDED"    , (DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED   , DONT_CARE,   eActive},
    {L"BREAKPOINT"               , (DWORD)EXCEPTION_BREAKPOINT              , DONT_CARE,   eActive},
    {L"DATATYPE_MISALIGNMENT"    , (DWORD)EXCEPTION_DATATYPE_MISALIGNMENT   , DONT_CARE,   eActive},
    {L"FLT_DENORMAL_OPERAND"     , (DWORD)EXCEPTION_FLT_DENORMAL_OPERAND    , DONT_CARE,   eActive},
    {L"FLT_DIVIDE_BY_ZERO"       , (DWORD)EXCEPTION_FLT_DIVIDE_BY_ZERO      , DONT_CARE,   eActive},
    {L"FLT_INEXACT_RESULT"       , (DWORD)EXCEPTION_FLT_INEXACT_RESULT      , DONT_CARE,   eActive},
    {L"FLT_INVALID_OPERATION"    , (DWORD)EXCEPTION_FLT_INVALID_OPERATION   , DONT_CARE,   eActive},
    {L"FLT_OVERFLOW"             , (DWORD)EXCEPTION_FLT_OVERFLOW            , DONT_CARE,   eActive},
    {L"FLT_STACK_CHECK"          , (DWORD)EXCEPTION_FLT_STACK_CHECK         , DONT_CARE,   eActive},
    {L"FLT_UNDERFLOW"            , (DWORD)EXCEPTION_FLT_UNDERFLOW           , DONT_CARE,   eActive},
    {L"ILLEGAL_INSTRUCTION"      , (DWORD)EXCEPTION_ILLEGAL_INSTRUCTION     , DONT_CARE,   eActive},
    {L"IN_PAGE_ERROR"            , (DWORD)EXCEPTION_IN_PAGE_ERROR           , DONT_CARE,   eActive},
    {L"INT_DIVIDE_BY_ZERO"       , (DWORD)EXCEPTION_INT_DIVIDE_BY_ZERO      , DONT_CARE,   eActive},
    {L"INT_OVERFLOW"             , (DWORD)EXCEPTION_INT_OVERFLOW            , DONT_CARE,   eActive},
    {L"INVALID_DISPOSITION"      , (DWORD)EXCEPTION_INVALID_DISPOSITION     , DONT_CARE,   eActive},
    {L"NONCONTINUABLE_EXCEPTION" , (DWORD)EXCEPTION_NONCONTINUABLE_EXCEPTION, DONT_CARE,   eActive},
    {L"PRIV_INSTRUCTION"         , (DWORD)EXCEPTION_PRIV_INSTRUCTION        , DONT_CARE,   eFirstChance},
    {L"SINGLE_STEP"              , (DWORD)EXCEPTION_SINGLE_STEP             , DONT_CARE,   eActive},
    {L"STACK_OVERFLOW"           , (DWORD)EXCEPTION_STACK_OVERFLOW          , DONT_CARE,   eActive},
    {L"INVALID_HANDLE"           , (DWORD)EXCEPTION_INVALID_HANDLE          , DONT_CARE,   eActive}
};

#define ELISTSIZE sizeof(g_eList) / sizeof(g_eList[0])

/*++

 Custom exception handler.

--*/

LONG 
ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    DWORD dwCode = ExceptionInfo->ExceptionRecord->ExceptionCode;

    if ((dwCode & DBG_EXCEPTION) == DBG_EXCEPTION) // for the DebugPrints
    {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    CONTEXT *lpContext = ExceptionInfo->ContextRecord;
    const WCHAR * szException = L"Unknown";
    BOOL bIgnore = FALSE;

    //
    // Run the list of exceptions to see if we're ignoring it
    //

    for (int i = 0; i < ELISTSIZE; i++)
    {
        const EXCEPT *pE = g_eList + i;

        // Matched the major exception code
        if (dwCode == pE->dwCode)
        {
            // See if we care about the subcode
            if ((pE->dwSubCode != DONT_CARE) && 
                (ExceptionInfo->ExceptionRecord->ExceptionInformation[0] != pE->dwSubCode))
            {
                continue;
            }

            szException = pE->cName;
            
            // Determine how to handle the exception
            switch (pE->dwIgnore)
            {
            case eActive: 
                bIgnore = FALSE;
                break;
            
            case eFirstChance:
                bIgnore = TRUE;
                break;
            
            case eSecondChance:
                bIgnore = g_bWin2000 || (g_dwLastEip == lpContext->Eip);
                g_dwLastEip = lpContext->Eip;
                break;

            case eExitProcess:
                // Try using unhandled exception filters to catch this
                bIgnore = TRUE;//g_bWin2000 || IsBadCodePtr((FARPROC)lpContext->Eip);
                if (bIgnore)
                {
                    ExitProcess(0);
                }
                g_dwLastEip = lpContext->Eip;
                break;
            }
            
            if (bIgnore) break;
        }
    }
    
    //
    //  Dump out the exception
    //

    DPFN( eDbgLevelWarning, "Exception %S (%08lx)\n", 
        szException,
        dwCode);

    #ifdef DBG
        DPFN( eDbgLevelWarning, "eip=%08lx\n", 
            lpContext->Eip);

        DPFN( eDbgLevelWarning, "eax=%08lx, ebx=%08lx, ecx=%08lx, edx=%08lx\n", 
            lpContext->Eax, 
            lpContext->Ebx, 
            lpContext->Ecx, 
            lpContext->Edx);

        DPFN( eDbgLevelWarning, "esi=%08lx, edi=%08lx, esp=%08lx, ebp=%08lx\n", 
            lpContext->Esi, 
            lpContext->Edi, 
            lpContext->Esp, 
            lpContext->Ebp);

        DPFN( eDbgLevelWarning, "cs=%04lx, ss=%04lx, ds=%04lx, es=%04lx, fs=%04lx, gs=%04lx\n", 
            lpContext->SegCs, 
            lpContext->SegSs, 
            lpContext->SegDs, 
            lpContext->SegEs,
            lpContext->SegFs,
            lpContext->SegGs);
    #endif

    LONG lRet;

    if (bIgnore) 
    {
        if ((DWORD)lpContext->Eip <= (DWORD)0xFFFF)
        {
            LOGN( eDbgLevelError, "[ExceptionFilter] Exception %S (%08X), stuck at bad address, killing current thread.", szException, dwCode);    
            lRet = EXCEPTION_CONTINUE_SEARCH;
            return lRet;
        }

        LOGN( eDbgLevelWarning, "[ExceptionFilter] Exception %S (%08X) ignored.", szException, dwCode);

        lpContext->Eip += GetInstructionLengthFromAddress((LPBYTE)lpContext->Eip);
        g_dwLastEip = 0;
        lRet = EXCEPTION_CONTINUE_EXECUTION;
    }
    else
    {
        DPFN( eDbgLevelWarning, "Exception NOT handled\n\n");
        lRet = EXCEPTION_CONTINUE_SEARCH;
    }

    return lRet;
}

/*++

 Parse the command line for particular exceptions. The format of the command
 line is:

    [EXCEPTION_NAME[:0|1|2]];[EXCEPTION_NAME[:0|1|2]]...

 or "*" which ignores all first chance exceptions.

 Eg:
    ACCESS_VIOLATION:2;PRIV_INSTRUCTION:0;BREAKPOINT

 Will ignore:
    1. Access violations            - second chance
    2. Priviliged mode instructions - do not ignore
    3. Breakpoints                  - ignore

--*/

BOOL 
ParseCommandLine(
    LPCSTR lpCommandLine
    )
{
    CSTRING_TRY
    {
        CStringToken csTok(lpCommandLine, L" ;");
        //
        // Run the string, looking for exception names
        //
        
        CString token;
    
        // Each cl token may be followed by a : and an exception type
        // Forms can be:
        // *
        // *:SecondChance
        // INVALID_DISPOSITION
        // INVALID_DISPOSITION:Active
        // INVALID_DISPOSITION:0
        //
 
        while (csTok.GetToken(token))
        {
            CStringToken csSingleTok(token, L":");

            CString csExcept;
            CString csType;

            // grab the exception name and the exception type
            csSingleTok.GetToken(csExcept);
            csSingleTok.GetToken(csType);
            
            // Convert ignore value to emode (defaults to eFirstChance)
            EMODE emode = ToEmode(csType);

            if (token.Compare(L"*") == 0)
            {
                for (int i = 0; i < ELISTSIZE; i++)
                {
                    g_eList[i].dwIgnore = emode;
                }
            }
            else
            {
                // Find the exception specified
                for (int i = 0; i < ELISTSIZE; i++)
                {
                    if (csExcept.CompareNoCase(g_eList[i].cName) == 0)
                    {
                        g_eList[i].dwIgnore = emode;
                        break;
                    }
                }
            }
        }
    }
    CSTRING_CATCH
    {
        return FALSE;
    }

    //
    // Dump results of command line parse
    //

    DPFN( eDbgLevelInfo, "===================================\n");
    DPFN( eDbgLevelInfo, "          Ignore Exception         \n");
    DPFN( eDbgLevelInfo, "===================================\n");
    DPFN( eDbgLevelInfo, "  1 = First chance                 \n");
    DPFN( eDbgLevelInfo, "  2 = Second chance                \n");
    DPFN( eDbgLevelInfo, "  3 = ExitProcess on second chance \n");
    DPFN( eDbgLevelInfo, "-----------------------------------\n");
    for (int i = 0; i < ELISTSIZE; i++)
    {
        if (g_eList[i].dwIgnore != eActive)
        {
            DPFN( eDbgLevelInfo, "%S %S\n", ToWchar(g_eList[i].dwIgnore), g_eList[i].cName);
        }
    }

    DPFN( eDbgLevelInfo, "-----------------------------------\n");

    return TRUE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // Run the command line to check for adjustments to defaults
        if (!ParseCommandLine(COMMAND_LINE))
        {
            return FALSE;
        }
    
        // Try to find new exception handler
        _pfn_RtlAddVectoredExceptionHandler pfnExcept;
        pfnExcept = (_pfn_RtlAddVectoredExceptionHandler)
            GetProcAddress(
                GetModuleHandle(L"NTDLL.DLL"), 
                "RtlAddVectoredExceptionHandler");

        if (pfnExcept)
        {
            (_pfn_RtlAddVectoredExceptionHandler) pfnExcept(
                0, 
                (PVOID)ExceptionFilter);
            g_bWin2000 = FALSE;
        }
        else
        {
            // Windows 2000 reverts back to the old method which unluckily 
            // doesn't get called for C++ exceptions

            SetUnhandledExceptionFilter(ExceptionFilter);
            g_bWin2000 = TRUE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\ignoreoleuninitialize.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreOleUninitialize.cpp

 Abstract:

     HTML Editor 8.7 calls ole32!OleUnitialize after the ExitProcess
     in the DllMain of hhctrl.ocx. This worked on Windows 2000
     but does not any more on Whistler.

    This is an general purpose shim.

 History:
 
    01/25/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreOleUninitialize)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OleUninitialize)
APIHOOK_ENUM_END


/*++

    This hooks Ole32!OleUninitialize and returns
    immediately as this is being called from 
    DllMain in hhctrl.ocx

--*/

void
APIHOOK(OleUninitialize)()
{
    return;    
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLE32.DLL, OleUninitialize)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\hidedisplaymodes.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    RestrictDisplayModes.cpp

 Abstract:

    Restrict the mode list enumerated by EnumDisplaySettings. This shim was 
    built for an application that enumerated only 10 modes and was hoping to 
    find 800x600 in that list. However, other applications that have fixed 
    size buffers for mode tables may also find this shim useful.

 Notes:

    This is a general purpose shim.

 History:

    05/05/2000  linstev     Created
    02/18/2002  robkenny    Protected g_pModeTable with a critical section

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(HideDisplayModes)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(EnumDisplaySettingsA)
    APIHOOK_ENUM_ENTRY(EnumDisplaySettingsW)
APIHOOK_ENUM_END

//
// Data needed in mode table
//

typedef struct _MODE
{
    DWORD dmBitsPerPel;
    DWORD dmPelsWidth;
    DWORD dmPelsHeight;
    DWORD dmDisplayFlags;
    DWORD dmDisplayFrequency;
    DWORD dwActualIndex;
    DWORD bIgnore;
} MODE;

// Used by BuildModeList to prevent multiple simultaneous access to g_pModeTable
CRITICAL_SECTION g_CriticalSection;

// Permanent mode table
MODE* g_pModeTable = NULL;

// Number of entries in the mode table
DWORD g_dwCount = 0;

// Build the mode table on first call
BOOL g_bInit = FALSE;
void BuildModeList(void);

/*++

 Lookup from the sanitized mode table.

--*/

BOOL 
APIHOOK(EnumDisplaySettingsA)(
    LPCSTR     lpszDeviceName,
    DWORD      iModeNum,
    LPDEVMODEA lpDevMode
    )
{
    BuildModeList();
    
    BOOL bRet = FALSE;

    if (lpszDeviceName || ((LONG)iModeNum < 0) || !g_pModeTable) {
        bRet = ORIGINAL_API(EnumDisplaySettingsA)(
                                lpszDeviceName,
                                iModeNum,
                                lpDevMode);
    } else if (iModeNum < g_dwCount) {
        MODE* pmode = g_pModeTable + iModeNum;

        bRet = ORIGINAL_API(EnumDisplaySettingsA)(
                                lpszDeviceName,
                                pmode->dwActualIndex,
                                lpDevMode);

        if (bRet) {
            LOGN(
                eDbgLevelError,
                "[EnumDisplaySettingsA] Returning shorter list of display modes.");
            
            lpDevMode->dmBitsPerPel = pmode->dmBitsPerPel;
            lpDevMode->dmPelsWidth = pmode->dmPelsWidth;
            lpDevMode->dmPelsHeight = pmode->dmPelsHeight;
            lpDevMode->dmDisplayFlags = pmode->dmDisplayFlags;
            lpDevMode->dmDisplayFrequency = pmode->dmDisplayFrequency;
        }
    }

    return bRet;
}

/*++

 Lookup from the sanitized mode table.

--*/

BOOL 
APIHOOK(EnumDisplaySettingsW)(
    LPCWSTR    lpszDeviceName,
    DWORD      iModeNum,
    LPDEVMODEW lpDevMode
    )
{
    BuildModeList();
    
    BOOL bRet = FALSE;

    if (lpszDeviceName || ((LONG)iModeNum < 0) || !g_pModeTable) {
        bRet = ORIGINAL_API(EnumDisplaySettingsW)(
                                lpszDeviceName,
                                iModeNum,
                                lpDevMode);
    } else if (iModeNum < g_dwCount) {
        MODE* pmode = g_pModeTable + iModeNum;

        bRet = ORIGINAL_API(EnumDisplaySettingsW)(
                                lpszDeviceName,
                                pmode->dwActualIndex,
                                lpDevMode);

        if (bRet) {
            LOGN(
                eDbgLevelError,
                "[EnumDisplaySettingsW] Returning shorter list of display modes.");
            
            lpDevMode->dmBitsPerPel = pmode->dmBitsPerPel;
            lpDevMode->dmPelsWidth = pmode->dmPelsWidth;
            lpDevMode->dmPelsHeight = pmode->dmPelsHeight;
            lpDevMode->dmDisplayFlags = pmode->dmDisplayFlags;
            lpDevMode->dmDisplayFrequency = pmode->dmDisplayFrequency;
        }
    }

    return bRet;
}

/*++

 Sort the table by Width+Height+BitsPerPel+Frequency in that order so that 
 they can be easily filtered.

--*/

int 
_cdecl
compare1(
    const void* a1,
    const void* a2
    )
{
    MODE* arg1 = (MODE*)a1;
    MODE* arg2 = (MODE*)a2;

    int d;

    d = arg1->dmPelsWidth - arg2->dmPelsWidth;

    if (d == 0) {
        d = arg1->dmPelsHeight - arg2->dmPelsHeight;
    }

    if (d == 0) {
        d = arg1->dmBitsPerPel - arg2->dmBitsPerPel;
    }

    if (d == 0) {
        d = arg1->dmDisplayFrequency - arg2->dmDisplayFrequency;
    }

    return d;
}

/*++

 Sort the table so it looks like a Win9x mode table, i.e. BitsPerPel is the
 primary sort key.

--*/

int 
_cdecl
compare2(
    const void* a1,
    const void* a2
    )
{
    MODE* arg1 = (MODE*)a1;
    MODE* arg2 = (MODE*)a2;

    int d;

    d = arg1->dmBitsPerPel - arg2->dmBitsPerPel;

    if (d == 0) {
        d = arg1->dmPelsWidth - arg2->dmPelsWidth;
    }

    if (d == 0) {
        d = arg1->dmPelsHeight - arg2->dmPelsHeight;
    }

    if (d == 0) {
        d = arg1->dmDisplayFrequency - arg2->dmDisplayFrequency;
    }

    return d;
}


/*++

 Create a new mode table based upon the sanitized existing table. To do this, 
 we do the following:
 
    1. Get the entire table
    2. Sort it - to allow efficient removal of duplicates
    3. Remove duplicates and unwanted modes
    4. Build a new table with only the modes that 'pass'

--*/

void
BuildModeList(
    void
    )
{
    CAutoCrit autoCrit(&g_CriticalSection);

    if (g_bInit) {
        return;
    }

    DEVMODEA dm;
    ULONG    i, j;
    
    dm.dmSize = sizeof(DEVMODEA);

    //
    // Figure out how many modes there are.
    //

    i = 0;
    
    while (EnumDisplaySettingsA(NULL, i, &dm)) {
        i++;
    }

    //
    // Allocate the full mode table.
    //
    MODE* pTempTable = (MODE*)malloc(sizeof(MODE) * i);
    
    if (!pTempTable) {
        LOGN(
            eDbgLevelError,
            "[BuildModeList] Failed to allocate %d bytes.",
            sizeof(MODE) * i);
        
        return;
    }

    MODE* pmode = pTempTable;

    //
    // Get all the modes.
    //
    i = 0;
    
    while (EnumDisplaySettingsA(NULL, i, &dm)) {
        pmode->dmBitsPerPel       = dm.dmBitsPerPel;
        pmode->dmPelsWidth        = dm.dmPelsWidth;
        pmode->dmPelsHeight       = dm.dmPelsHeight;
        pmode->dmDisplayFlags     = dm.dmDisplayFlags;
        pmode->dmDisplayFrequency = 0; // dm.dmDisplayFrequency;
        pmode->dwActualIndex      = i;
        pmode->bIgnore            = FALSE;

        pmode++;
        i++;
    }
    
    //
    // Sort the full table so we can remove duplicates easily.
    //
    qsort((void*)pTempTable, (size_t)i, sizeof(MODE), compare1);

    //
    // Strip away bad modes by setting them as ignored.
    //
    pmode = pTempTable;
    
    MODE* pprev = NULL;

    for (j = 0; j < i; j++) {
        if ((pmode->dmBitsPerPel < 8) || 
            (pmode->dmPelsWidth < 640) ||
            (pmode->dmPelsHeight < 480) ||
            (pmode->dmPelsWidth > 1280) || 
            (pprev &&
            (pprev->dmBitsPerPel == pmode->dmBitsPerPel) &&
            (pprev->dmPelsWidth == pmode->dmPelsWidth) &&
            (pprev->dmPelsHeight == pmode->dmPelsHeight))) {
            
            //
            // Special-case 640x480x4bit.
            //
            if ((pmode->dmBitsPerPel == 4) && 
                (pmode->dmPelsWidth == 640) &&
                (pmode->dmPelsHeight == 480)) {
                
                g_dwCount++;
            } else {
                pmode->bIgnore = TRUE;
            }
        } else {
            g_dwCount++;
        }

        pprev = pmode;
        pmode++;
        
    }

    //
    // Build the new table with only the modes that passed.
    //
    g_pModeTable = (MODE*)malloc(sizeof(MODE) * g_dwCount);
    
    if (!g_pModeTable) {
        LOGN(
            eDbgLevelError,
            "[BuildModeList] Failed to allocate %d bytes.",
            sizeof(MODE) * g_dwCount);
        
        free(pTempTable);
        return;
    }

    MODE* pmoden = g_pModeTable;
    
    pmode = pTempTable;

    for (j = 0; j < i; j++) {
        if (!pmode->bIgnore) {
            MoveMemory(pmoden, pmode, sizeof(MODE));
            pmoden++;
        }
        pmode++;
    }

    //
    // Sort the full table so we can remove duplicates easily.
    //
    qsort((void*)g_pModeTable, (size_t)g_dwCount, sizeof(MODE), compare2);

    free(pTempTable);

    g_bInit = TRUE;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return InitializeCriticalSectionAndSpinCount(&g_CriticalSection, 0x80000000);
    } 
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN


    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, EnumDisplaySettingsA)
    APIHOOK_ENTRY(USER32.DLL, EnumDisplaySettingsW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\ignorescheduler.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreScheduler.cpp

 Abstract:

    Includes the following hooks:
    
    SetThreadPriority: Normalize the thread priority to prevent some application synchronization 
    issues.
    
    SetPriorityClass: Normalize process class. 
    
    SuspendThread:  Prevent a thread from suspending itself.
    
    ResumeThread: Prevent a thread from resumming itself.

 Notes:

    This is a general purpose shim.

 History:

    10/20/2000 jpipkins  Created: SetPriorityClass created and merged with SetThreadPriority(linstev),
    SuspendThread/ResumeThread(dmunsil/a-brienw).

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreScheduler)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(SetThreadPriority)
    APIHOOK_ENUM_ENTRY(SetPriorityClass)
    APIHOOK_ENUM_ENTRY(ResumeThread)
    APIHOOK_ENUM_ENTRY(SuspendThread)
APIHOOK_ENUM_END

/*++

 Remove any creation flags that specify process priority.

--*/

#define PRIORITYMASK (ABOVE_NORMAL_PRIORITY_CLASS | BELOW_NORMAL_PRIORITY_CLASS | HIGH_PRIORITY_CLASS | IDLE_PRIORITY_CLASS | REALTIME_PRIORITY_CLASS)

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (dwCreationFlags & PRIORITYMASK) {
        LOGN(eDbgLevelInfo, "[CreateProcessA] Forcing priority class to normal");
    
        dwCreationFlags &= ~PRIORITYMASK;
        dwCreationFlags |= NORMAL_PRIORITY_CLASS;
    }
    
    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine,
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,             
                lpProcessInformation);
}

/*++

 Remove any creation flags that specify process priority.

--*/

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (dwCreationFlags & PRIORITYMASK) {
        LOGN(eDbgLevelInfo, "[CreateProcessW] Forcing priority class to normal");
    
        dwCreationFlags &= ~PRIORITYMASK;
        dwCreationFlags |= NORMAL_PRIORITY_CLASS;
    }

    return ORIGINAL_API(CreateProcessW)(lpApplicationName, lpCommandLine, 
                lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
                dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo,
                lpProcessInformation);
}

/*++

 Normalize thread priority.

--*/

BOOL 
APIHOOK(SetThreadPriority)(
    HANDLE hThread, 
    int    nPriority   
    )
{
    if (nPriority != THREAD_PRIORITY_NORMAL) {
        LOGN(
            eDbgLevelInfo,
            "[SetThreadPriority] Forcing thread priority to normal.");
    }

    return ORIGINAL_API(SetThreadPriority)(hThread, THREAD_PRIORITY_NORMAL);
}

/*++

 Normalize Class priority.

--*/

BOOL 
APIHOOK(SetPriorityClass)(
    HANDLE hProcess, 
    DWORD  dwPriorityClass   
    )
{
    if (dwPriorityClass != NORMAL_PRIORITY_CLASS) {
        LOGN(
            eDbgLevelInfo,
            "[SetPriorityClass] Forcing priority class to normal.");
    }

    return ORIGINAL_API(SetPriorityClass)(hProcess, NORMAL_PRIORITY_CLASS);
}

/*++

 Get Thread ID for ResumeThread and SuspendThread Hooks

--*/


DWORD
dwGetThreadID(
    HANDLE hThread
    )
{
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    NTSTATUS                 Status;

    Status = NtQueryInformationThread(hThread,
                                      ThreadBasicInformation,
                                      &ThreadBasicInfo,
                                      sizeof(ThreadBasicInfo),
                                      NULL);

    if (NT_SUCCESS(Status)) {
        return (DWORD)ThreadBasicInfo.ClientId.UniqueThread;
    } else {
        LOGN(
            eDbgLevelError,
            "[dwGetThreadID] NtQueryInfomationThread failed.");
        return 0;
    }
}

/*++

 Disallow suspending self

--*/

DWORD
APIHOOK(SuspendThread)(
    HANDLE hThread   // handle to the thread
    )
{
    //
    // If we're trying to suspend our own thread, refuse.
    //
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(SuspendThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Disallow resuming self, for same reason

--*/

DWORD
APIHOOK(ResumeThread)(
    HANDLE hThread   // handle to the thread
    )
{
    //
    // If we're trying to resume our own thread, refuse.
    //
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(ResumeThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL, SetThreadPriority)
    APIHOOK_ENTRY(KERNEL32.DLL, SetPriorityClass)
    APIHOOK_ENTRY(KERNEL32.DLL, SuspendThread)
    APIHOOK_ENTRY(KERNEL32.DLL, ResumeThread)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\handlewvsprintfexceptions.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   HandleWvsprintfExceptions.cpp

 Abstract:

   This fix provides a facility to fix argument list from LPSTR into va_list.

   Some native Win9x app use LPSTR (pointer of string) instead of 
   va_list (pointer to pointer of string). 
   Without properly checking the return value, these apps assume that it is safe
   to use wvsprintf like that because it doesn't cause AV.
   In NT, this will cause AV.

   This shim takes one command line: "arglistfix" (case insensitive).
   By default - if there is no command line - it will do exactly
   what Win9x's wvsprintfA has : 
   Do nothing inside the exception handler if there is an exception occurs.
   If arglistfix specified in command line, it will try to fix the argument
   list (va_list).

 History:

    09/29/2000  andyseti    Created
    11/28/2000  jdoherty    Converted to framework version 2
    03/15/2001  robkenny    Converted to CString

--*/

#include "precomp.h"


int   g_iWorkMode = 0;

enum
{
    WIN9X_MODE = 0,
    ARGLISTFIX_MODE
} TEST;

IMPLEMENT_SHIM_BEGIN(HandleWvsprintfExceptions)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(wvsprintfA) 
APIHOOK_ENUM_END

int Fix_wvsprintf_ArgList(
    LPSTR lpOut,
    LPCSTR lpFmt,
    ...)
{
    int iRet;

    va_list argptr;
    va_start( argptr, lpFmt );

    iRet = ORIGINAL_API(wvsprintfA)(
        lpOut,                         
        lpFmt,                     
        argptr);

    va_end( argptr );
    return iRet;
}

int 
APIHOOK(wvsprintfA)(
    LPSTR lpOut,
    LPCSTR lpFmt,
    va_list arglist)
{
    int iRet = 0;

    __try {
        iRet = ORIGINAL_API(wvsprintfA)(
                lpOut,                         
                lpFmt,                     
                arglist);
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {
        
        if (g_iWorkMode == ARGLISTFIX_MODE)
        {
            DPFN( eDbgLevelInfo,
                "Exception occurs in wvsprintfA. \narglist contains pointer to string: %s.\n" , arglist);
            iRet = Fix_wvsprintf_ArgList(lpOut,lpFmt,arglist);
        }
        else
        {
            // Copied from Win9x's wvsprintfA
            __try {
                // tie off the output
                *lpOut = 0;
            } 
            
            __except( EXCEPTION_EXECUTE_HANDLER) {
                // Do nothing
            }

            iRet = 0;
        }

    }

    return iRet;
}

    
void ParseCommandLine()
{
    CString csCmdLine(COMMAND_LINE);

    if (csCmdLine.CompareNoCase(L"arglistfix") == 0)
    {
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions called with argument: %S.\n", csCmdLine.Get());
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions mode: Argument List Fix.\n");
        g_iWorkMode = ARGLISTFIX_MODE;
    }
    else
    {
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions called with no argument.\n");
        DPFN( eDbgLevelInfo,
            "HandleWvsprintfExceptions mode: Win9x.\n");
        g_iWorkMode = WIN9X_MODE;
    }
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL, KERNEL32 and MSVCRT APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        DPFN( eDbgLevelInfo, "HandleWvsprintfExceptions initialized.");
        ParseCommandLine();
    } 
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, wvsprintfA)
    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\ignoreloadlibrary.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IgnoreLoadLibrary.cpp

 Abstract:

    This shim allows the user to specified a list of libraries it tries to ignore and 
    optionally the return values of the LoadLibrary call. Some apps try to load libraries
    they don't use but expect the LoadLibrary call to succeed.

    Use ; as the delimeter of the item and optionally use : to specify the return value.
    If you don't specify a return value we'll make the return value NULL.
    Eg:

    video_3dfx.dll;video_3dfx
    helper32.dll:1234;helper.dll

 Notes:
    
    This is a general purpose shim.

 History:

    04/13/2000 a-jamd   Created
    10/11/2000 maonis   Added support for specifying return values and renamed it from 
                        FailLoadLibrary to IgnoreLoadLibrary.
    11/16/2000 linstev  Added SetErrorMode emulation

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IgnoreLoadLibrary)
#include "ShimHookMacro.h"

// Globals are zero initialized by default. see c++ spec 3.6.2.
CString *   g_csIgnoreLib;
int         g_csIgnoreLibCount;
DWORD *     g_rgReturnValues;

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
    APIHOOK_ENUM_ENTRY(LoadLibraryExA) 
    APIHOOK_ENUM_ENTRY(LoadLibraryW) 
    APIHOOK_ENUM_ENTRY(LoadLibraryExW) 
APIHOOK_ENUM_END


/*++

 This function parses the COMMAND_LINE for the libraries you wish to ignore.

--*/

BOOL ParseCommandLine(LPCSTR lpszCommandLine)
{
    CSTRING_TRY
    {
        DPF(g_szModuleName, eDbgLevelInfo, "[ParseCommandLine] CommandLine(%s)\n", lpszCommandLine);

        CString csCl(lpszCommandLine);
        CStringParser csParser(csCl, L" ;");
    
        g_csIgnoreLibCount  = csParser.GetCount();
        g_csIgnoreLib       = csParser.ReleaseArgv();
        g_rgReturnValues    = (DWORD *)malloc(sizeof(*g_rgReturnValues) * g_csIgnoreLibCount);
    
        if (g_csIgnoreLibCount && !g_rgReturnValues)
        {
            return FALSE;
        }
    
        // Iterate over all strings looking for a return value
        for (int i = 0; i < g_csIgnoreLibCount; ++i)
        {
            CStringToken csIgnore(g_csIgnoreLib[i], L":");
            CString csLib;
            CString csValue;
            
            csIgnore.GetToken(csLib);
            csIgnore.GetToken(csValue);
            
            if (!csValue.IsEmpty())
            {
                WCHAR *unused;
    
                g_csIgnoreLib[i]    = csLib;   
                g_rgReturnValues[i] = wcstol(csValue, &unused, 10);
            }
            else
            {
                // g_csIgnoreLib[i] is already initialized
                g_rgReturnValues[i] = 0;
            }
            
            
            DPF(g_szModuleName, eDbgLevelInfo, "[ParseCommandLine] library (%S) return value(%d)\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
        }

        return TRUE;
    }
    CSTRING_CATCH
    {
        // Do nothing.
    }
    return FALSE;
}


/*++

 These stub functions break into LoadLibrary and check to see if lpLibFileName equals 
 one of the specified dll's.  If so return the specified return value.  If not call LoadLibrary on it.

--*/

HINSTANCE 
APIHOOK(LoadLibraryA)(LPCSTR lpLibFileName)
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryA] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew, "LoadLibraryA Allow(%s)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryA)(lpLibFileName);
    
    SetErrorMode(uLastMode);
    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryExA)(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryExA] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew, "LoadLibraryExA Allow(%s)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryExA)(lpLibFileName, hFile, dwFlags);

    SetErrorMode(uLastMode);
    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryW)(LPCWSTR lpLibFileName)
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryW] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew,"LoadLibraryW Allow(%S)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryW)(lpLibFileName);

    SetErrorMode(uLastMode);
    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryExW)(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    CSTRING_TRY
    {
        CString csFilePath(lpLibFileName);
        CString csFileName;
        csFilePath.GetLastPathComponent(csFileName);
    
        for (int i = 0; i < g_csIgnoreLibCount; i++)
        {
            if (g_csIgnoreLib[i].CompareNoCase(csFileName) == 0)
            {
                LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryExW] Caught attempt loading %s, return %d\n", g_csIgnoreLib[i].Get(), g_rgReturnValues[i]);
                return (HINSTANCE) g_rgReturnValues[i];
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    DPF(g_szModuleName, eDbgLevelSpew,"APIHook_LoadLibraryExW Allow(%S)", lpLibFileName);
    
    UINT uLastMode;
    HINSTANCE hRet;
    uLastMode = SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    hRet = ORIGINAL_API(LoadLibraryExW)(lpLibFileName, hFile, dwFlags);

    SetErrorMode(uLastMode);
    return hRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ParseCommandLine(COMMAND_LINE);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryW)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:

 Notes:

 History:

    15/11/2000 clupu Created

--*/

#include "precomp.h"

#include "ShimHookMacro.h"
                        
DECLARE_SHIM(AddWritePermissionsToDeviceFiles)
DECLARE_SHIM(ChangeAuthenticationLevel)
DECLARE_SHIM(CorrectBitmapHeader)
DECLARE_SHIM(CorrectCreateEventName)
DECLARE_SHIM(CorrectFilePaths)
DECLARE_SHIM(CorrectSoundDeviceId)
DECLARE_SHIM(DirectPlayEnumOrder)
DECLARE_SHIM(DuplicateHandleFix)
DECLARE_SHIM(EmulateBitmapStride)
DECLARE_SHIM(EmulateCDFS)
DECLARE_SHIM(EmulateClipboardDIBFormat)
DECLARE_SHIM(EmulateCreateFileMapping)
DECLARE_SHIM(EmulateCreateProcess)
DECLARE_SHIM(EmulateDeleteObject)
DECLARE_SHIM(EmulateDirectDrawSync)
DECLARE_SHIM(EmulateDrawText)
DECLARE_SHIM(EmulateEnvironmentBlock)
DECLARE_SHIM(EmulateFindHandles)
DECLARE_SHIM(EmulateGetCommandLine)
DECLARE_SHIM(EmulateGetDeviceCaps)
DECLARE_SHIM(EmulateGetDiskFreeSpace)
DECLARE_SHIM(EmulateJoystick)
DECLARE_SHIM(EmulateGetProfileString)
DECLARE_SHIM(EmulateHeap)
DECLARE_SHIM(EmulateMissingEXE)
DECLARE_SHIM(EmulatePlaySound)
DECLARE_SHIM(EmulatePrinter)
DECLARE_SHIM(EmulateSlowCPU)
DECLARE_SHIM(EmulateTextColor)
DECLARE_SHIM(EmulateToolHelp32)
DECLARE_SHIM(EmulateUSER);
DECLARE_SHIM(EmulateVerQueryValue)
DECLARE_SHIM(EmulateWriteFile)
DECLARE_SHIM(EnableRestarts)
DECLARE_SHIM(FileVersionInfoLie)
DECLARE_SHIM(FeedbackReport)
DECLARE_SHIM(Force640x480)
DECLARE_SHIM(Force8BitColor)
DECLARE_SHIM(ForceAnsiGetDisplayNameOf)
DECLARE_SHIM(ForceCDStop)
DECLARE_SHIM(ForceCoInitialize)
DECLARE_SHIM(ForceDXSetupSuccess)
DECLARE_SHIM(ForceKeepFocus)
DECLARE_SHIM(ForceMessageBoxFocus)
DECLARE_SHIM(ForceShellLinkResolveNoUI)
DECLARE_SHIM(HandleAPIExceptions)
DECLARE_SHIM(HandleRegExpandSzRegistryKeys)
DECLARE_SHIM(HandleWvsprintfExceptions)
DECLARE_SHIM(HideDisplayModes)
DECLARE_SHIM(IgnoreException)
DECLARE_SHIM(IgnoreLoadLibrary)
DECLARE_SHIM(IgnoreOleUninitialize)
DECLARE_SHIM(IgnoreScheduler)
DECLARE_SHIM(MapMemoryB0000)
DECLARE_SHIM(ProfilesEnvStrings)
DECLARE_SHIM(ProfilesGetFolderPath)
DECLARE_SHIM(ProfilesRegQueryValueEx)
DECLARE_SHIM(Shrinker)
DECLARE_SHIM(SingleProcAffinity)
DECLARE_SHIM(SyncSystemAndSystem32)
DECLARE_SHIM(VirtualRegistry)
DECLARE_SHIM(WinXPVersionLie)
DECLARE_SHIM(WinXPSP1VersionLie)
DECLARE_SHIM(Win2000VersionLie)
DECLARE_SHIM(Win2000SP1VersionLie)
DECLARE_SHIM(Win2000SP2VersionLie)
DECLARE_SHIM(Win2000SP3VersionLie)
DECLARE_SHIM(Win95VersionLie)
DECLARE_SHIM(Win98VersionLie)
DECLARE_SHIM(WinExecRaceConditionFix)
DECLARE_SHIM(WinNT4SP5VersionLie)
DECLARE_SHIM(Win2kPropagateLayer)


VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcLayers", eDbgLevelSpew, "Layer Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("AcLayers", eDbgLevelSpew, "Layer Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(AddWritePermissionsToDeviceFiles)
    MULTISHIM_ENTRY(ChangeAuthenticationLevel)
    MULTISHIM_ENTRY(CorrectBitmapHeader)
    MULTISHIM_ENTRY(CorrectCreateEventName)
    MULTISHIM_ENTRY(CorrectFilePaths)
    MULTISHIM_ENTRY(CorrectSoundDeviceId)
    MULTISHIM_ENTRY(DirectPlayEnumOrder)
    MULTISHIM_ENTRY(DuplicateHandleFix)
    MULTISHIM_ENTRY(EmulateBitmapStride)
    MULTISHIM_ENTRY(EmulateCDFS)
    MULTISHIM_ENTRY(EmulateClipboardDIBFormat)
    MULTISHIM_ENTRY(EmulateCreateFileMapping)
    MULTISHIM_ENTRY(EmulateCreateProcess)
    MULTISHIM_ENTRY(EmulateDeleteObject)
    MULTISHIM_ENTRY(EmulateDirectDrawSync)
    MULTISHIM_ENTRY(EmulateDrawText)
    MULTISHIM_ENTRY(EmulateEnvironmentBlock)
    MULTISHIM_ENTRY(EmulateFindHandles)
    MULTISHIM_ENTRY(EmulateGetCommandLine)
    MULTISHIM_ENTRY(EmulateGetDeviceCaps)
    MULTISHIM_ENTRY(EmulateGetDiskFreeSpace)
    MULTISHIM_ENTRY(EmulateGetProfileString)
    MULTISHIM_ENTRY(EmulateJoystick)
    MULTISHIM_ENTRY(EmulateHeap)
    MULTISHIM_ENTRY(EmulateMissingEXE)
    MULTISHIM_ENTRY(EmulatePlaySound)
    MULTISHIM_ENTRY(EmulatePrinter)
    MULTISHIM_ENTRY(EmulateSlowCPU)
    MULTISHIM_ENTRY(EmulateTextColor)
    MULTISHIM_ENTRY(EmulateToolHelp32)
    MULTISHIM_ENTRY(EmulateUSER)
    MULTISHIM_ENTRY(EmulateVerQueryValue)
    MULTISHIM_ENTRY(EmulateWriteFile)
    MULTISHIM_ENTRY(EnableRestarts)
    MULTISHIM_ENTRY(FeedbackReport)
    MULTISHIM_ENTRY(FileVersionInfoLie)
    MULTISHIM_ENTRY(Force640x480)
    MULTISHIM_ENTRY(Force8BitColor)
    MULTISHIM_ENTRY(ForceAnsiGetDisplayNameOf)
    MULTISHIM_ENTRY(ForceCDStop)
    MULTISHIM_ENTRY(ForceCoInitialize)
    MULTISHIM_ENTRY(ForceDXSetupSuccess)
    MULTISHIM_ENTRY(ForceKeepFocus)
    MULTISHIM_ENTRY(ForceMessageBoxFocus)
    MULTISHIM_ENTRY(ForceShellLinkResolveNoUI)
    MULTISHIM_ENTRY(HandleAPIExceptions)
    MULTISHIM_ENTRY(HandleRegExpandSzRegistryKeys)
    MULTISHIM_ENTRY(HandleWvsprintfExceptions)
    MULTISHIM_ENTRY(HideDisplayModes)
    MULTISHIM_ENTRY(IgnoreException)
    MULTISHIM_ENTRY(IgnoreLoadLibrary)
    MULTISHIM_ENTRY(IgnoreOleUninitialize)
    MULTISHIM_ENTRY(IgnoreScheduler)
    MULTISHIM_ENTRY(MapMemoryB0000)
    MULTISHIM_ENTRY(ProfilesEnvStrings)
    MULTISHIM_ENTRY(ProfilesGetFolderPath)
    MULTISHIM_ENTRY(ProfilesRegQueryValueEx)
    MULTISHIM_ENTRY(Shrinker)
    MULTISHIM_ENTRY(SingleProcAffinity)
    MULTISHIM_ENTRY(SyncSystemAndSystem32)
    MULTISHIM_ENTRY(VirtualRegistry)
    MULTISHIM_ENTRY(WinXPVersionLie)
    MULTISHIM_ENTRY(WinXPSP1VersionLie)
    MULTISHIM_ENTRY(Win2000VersionLie)
    MULTISHIM_ENTRY(Win2000SP1VersionLie)
    MULTISHIM_ENTRY(Win2000SP2VersionLie)
    MULTISHIM_ENTRY(Win2000SP3VersionLie)
    MULTISHIM_ENTRY(Win95VersionLie)
    MULTISHIM_ENTRY(Win98VersionLie)
    MULTISHIM_ENTRY(WinExecRaceConditionFix)
    MULTISHIM_ENTRY(WinNT4SP5VersionLie)
    MULTISHIM_ENTRY(Win2kPropagateLayer)


    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\precomp.h ===
#ifndef _GPSHIMS_PRECOMP_H_
#define _GPSHIMS_PRECOMP_H_

#include "ShimHook.h"
#include <shlwapi.h>
#include "StrSafe.h"

using namespace ShimLib;


#endif // _GPSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\mapmemoryb0000.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MapMemoryB0000.cpp

 Abstract:

    Map memory at 0xB0000 for applications that use this memory. On Win9x, this 
    is always a valid memory block.
   
 Notes:

    This is a general purpose shim.

 History:

    05/11/2000 linstev  Created
    10/26/2000 linstev  Removed unnecessary free code

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MapMemoryB0000)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        if (VirtualAlloc((LPVOID)0xB0000, 0x10000, MEM_COMMIT, PAGE_READWRITE)) {
            
            LOGN(
                eDbgLevelInfo,
                "[NotifyFn] Created block at 0xB0000.");
        } else {
            LOGN(
                eDbgLevelError,
                "[NotifyFn] Failed to create block at 0xB0000.");
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\profilesenvstrings.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ProfilesEnvStrings.cpp

 Abstract:

   This DLL hooks GetEnvironmentVariableA and ExpandEnvironmentStringsA. Any application
   that is looking for %USERPROFILE% will be told the location of %ALLUSERSPROFILE% instead.

   This shim is designed to fool install apps that use env variables obtain the users profile
   location.

 Notes:

 History:

    08/07/2000  reinerf Created
    02/28/2001  robkenny    Converted to CString
*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(ProfilesEnvStrings)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetEnvironmentVariableA)
    APIHOOK_ENUM_ENTRY(ExpandEnvironmentStringsA)
APIHOOK_ENUM_END


// if apps try to read the %USERPROFILE% env variable, we lie to them
DWORD
APIHOOK(GetEnvironmentVariableA)(
    LPCSTR lpName,      // environment variable name
    LPSTR  lpBuffer,    // buffer for variable value
    DWORD  nSize        // size of buffer
    )
{
    if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_NEUTRAL),SORT_DEFAULT),
                          NORM_IGNORECASE, lpName, -1,
                          "USERPROFILE",-1) == CSTR_EQUAL) {
        LOGN(
            eDbgLevelInfo,
            "[GetEnvironmentVariableA] overriding USERPROFILE with ALLUSERSPROFILE.");
        
        return ORIGINAL_API(GetEnvironmentVariableA)("ALLUSERSPROFILE", lpBuffer, nSize);
    }

    return ORIGINAL_API(GetEnvironmentVariableA)(lpName, lpBuffer, nSize);
}


DWORD
APIHOOK(ExpandEnvironmentStringsA)(
    LPCSTR lpSrc,       // string with environment variables
    LPSTR lpDst,        // string with expanded strings 
    DWORD nSize         // maximum characters in expanded string
    )
{
    DWORD dwRet = 0;

    CSTRING_TRY
    {
        // replace UserProfile with AllUserProfile
        CString csEnvironments(lpSrc);
        csEnvironments.ReplaceI(L"%userprofile%", L"%alluserprofile%");
        dwRet = ORIGINAL_API(ExpandEnvironmentStringsA)(csEnvironments.GetAnsi(), lpDst, nSize);
    }
    CSTRING_CATCH
    {
        dwRet = ORIGINAL_API(ExpandEnvironmentStringsA)(lpSrc, lpDst, nSize);
    }

    return dwRet;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(KERNEL32.DLL, GetEnvironmentVariableA);
                APIHOOK_ENTRY(KERNEL32.DLL, ExpandEnvironmentStringsA);
            }
        }
    }
    
    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\profilesgetfolderpath.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ProfilesGetFolderPath.cpp

 Abstract:

    This DLL hooks shell32!SHGetFolderLocation, shell32!SHGetSpecialFolderLocation, and
    shell32!SHGetFolderPathA. Any application that is looking for a per-user CSIDL will 
    be returned the corosponding all-users location instead.

    This shim is designed to fool install apps that call shell32.dll api's to obtain
    shell folder locations.

 History:

    08/07/2000  reinerf Created
    05/11/2001  markder Modified   Removed Desktop redirection as it makes the shim
                                   too invasive.
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ProfilesGetFolderPath)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetFolderLocation)
    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderLocation)
    APIHOOK_ENUM_ENTRY(SHGetFolderPathA)
APIHOOK_ENUM_END


int
TranslateCSIDL(
    int nFolder
    )
{
    switch (nFolder) {

    case CSIDL_STARTMENU:
        DPFN(
            eDbgLevelInfo,
            "[TranslateCSIDL] overriding CSIDL_STARTMENU with CSIDL_COMMON_STARTMENU\n");
        return CSIDL_COMMON_STARTMENU;
        break;

    case CSIDL_STARTUP:
        DPFN(
            eDbgLevelInfo,
            "[TranslateCSIDL] overriding CSIDL_STARTUP with CSIDL_COMMON_STARTUP\n");
        return CSIDL_COMMON_STARTUP;
        break;

    case CSIDL_PROGRAMS:
        DPFN(
            eDbgLevelInfo,
            "[TranslateCSIDL] overriding CSIDL_PROGRAMS with CSIDL_COMMON_PROGRAMS\n");
        return CSIDL_COMMON_PROGRAMS;
        break;

    default:
        return nFolder;
    }
}


HRESULT
APIHOOK(SHGetSpecialFolderLocation)(
    HWND          hwndOwner, 
    int           nFolder,
    LPITEMIDLIST* ppidl
    )
{
    return ORIGINAL_API(SHGetSpecialFolderLocation)(hwndOwner,
                                                    TranslateCSIDL(nFolder),
                                                    ppidl);
}


HRESULT
APIHOOK(SHGetFolderLocation)(
    HWND          hwndOwner,
    int           nFolder,
    HANDLE        hToken,
    DWORD         dwReserved,
    LPITEMIDLIST* ppidl
    )
{
    return ORIGINAL_API(SHGetFolderLocation)(hwndOwner,
                                             TranslateCSIDL(nFolder),
                                             hToken,
                                             dwReserved,
                                             ppidl);
}


HRESULT
APIHOOK(SHGetFolderPathA)(
    HWND   hwndOwner,
    int    nFolder,
    HANDLE hToken,
    DWORD  dwFlags,
    LPSTR  pszPath
    )
{
    return ORIGINAL_API(SHGetFolderPathA)(hwndOwner,
                                          TranslateCSIDL(nFolder),
                                          hToken,
                                          dwFlags,
                                          pszPath);
}


// Register hooked functions
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                  !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(SHELL32.DLL, SHGetFolderLocation);
                APIHOOK_ENTRY(SHELL32.DLL, SHGetSpecialFolderLocation);
                APIHOOK_ENTRY(SHELL32.DLL, SHGetFolderPathA);
            }
        }
    }
    
    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\shrinker.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   Shrinker.cpp

 Abstract:

    Fix Shrinker library problem. This library is hacking some ntdll and kernel32 opcode
    with unreliable way to do it.

    First, they try to search the matching opcode within 32 bytes from the hacked 
    function (the function address retrieved from GetProcAddress and the opcode bytes
    retrieved via ReadProcessMemory).
    If they found it, then they replaced it with their opcode to redirect the call
    into their own routine.

    Unfortunately, opcode in Whistler has changed. So, the result will be unpredictable.
    They could be ended up with unexpected behavior from misreplacement of opcode
    or the app decided to terminated itself since the matching opcode can't be found.

    We fixed this by providing an exact matching opcode.

    Addition:  Shrinker also checks against ExitProcess for exact opcodes, these
    values have recently changed and no longer match against their hard coded
    values.  We now provide matching opcodes for ExitProcess also.
   
 Notes:

   Hooking ntdll!LdrAccessResource to emulate Win2K's version of it.
   Hooking Kernel32!ExitProcess to emulate Win2K's version of it.

 History:

   11/17/2000 andyseti  Created
   04/30/2001 mnikkel   Added ExitProcess
   05/01/2001 mnikkel   Corrected calls to ldraccessresource and exitprocess
   02/20/2002 mnikkel   Corrected exitprocess parameter to remove w4 warning

--*/

#include "precomp.h"
#include <nt.h>


IMPLEMENT_SHIM_BEGIN(Shrinker)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LdrAccessResource) 
    APIHOOK_ENUM_ENTRY(ExitProcess) 
APIHOOK_ENUM_END

__declspec(naked)
NTSTATUS
APIHOOK(LdrAccessResource)(
    IN PVOID /*DllHandle*/,
    IN const IMAGE_RESOURCE_DATA_ENTRY* /*ResourceDataEntry*/,
    OUT PVOID * /*Address*/ OPTIONAL,
    OUT PULONG /*Size*/ OPTIONAL)
{
    _asm {
        push [esp+0x10]     // shrinker lib needs these opcode signature (found in Win2K), -
        push [esp+0x10]     // but the actual LdrAccessResource doesn't have them
        push [esp+0x10]
        push [esp+0x10]

        call dword ptr [LdrAccessResource]

        ret 0x10            // when exit, pop 16 bytes from stack.
    }
}

__declspec(naked)
VOID
APIHOOK(ExitProcess)(
    UINT /*uExitCode*/
    )
{
    _asm {
        push ebp             // shrinker is looking for these exact op codes in
        mov  ebp,esp         // ExitProcess, but the routine has changed.
        push 0xFFFFFFFF
        push 0x77e8f3b0

        push [ebp+4]
        call dword ptr [ExitProcess]

        pop  ebp
        ret  4 
    }
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(NTDLL.DLL, LdrAccessResource)
    APIHOOK_ENTRY(KERNEL32.DLL, ExitProcess)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\singleprocaffinity.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SingleProcAffinity.cpp

 Abstract:

    Make the process have single processor affinity to workaround bugs that
    are exposed in multi-processor environments.
   
 Notes:

    This is a general purpose shim.

 History:

    03/19/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SingleProcAffinity)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Set single processor affinity
        // 
        SetProcessAffinityMask(GetCurrentProcess(), 1);

        LOGN( eDbgLevelInfo, "[NotifyFn] Single processor affinity set");
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\profilesregqueryvalueex.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   RegQueryValueEx.cpp

 Abstract:

   This DLL hooks RegQueryValueExA so that we can return the "all-users" location
   for the StartMenu, Desktop and Startup folders instead of the per-user location.

   We also hook RegCreateKeyA/RegCreateKeyExA to make people who add entries to the
   HKCU "run" and "Uninstall" keys really add them to HKLM.

 Notes:

 History:

    08/07/2000  reinerf     Created
    02/27/2001  robkenny    Converted to use CString
    02/14/2002  mnikkel     Changed from legalstr.h to strsafe.h

*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ProfilesRegQueryValueEx)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
APIHOOK_ENUM_END


#ifndef MAX
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

LPCSTR g_aBadKeys[] = 
{
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"},
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall"},
};

LPCSTR g_aBadShellFolderKeys[] = 
{
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"},
    {"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders"},
};


// given an hkey, call NtQueryObject to lookup its name.
// returns strings in the format: "\REGISTRY\USER\S-1-5-xxxxx\Software\Microsoft\Windows\CurrentVersion"
BOOL GetKeyName(HKEY hk, LPSTR pszName, DWORD cchName)
{
    BOOL bRet = FALSE;
    ULONG cbSize = 0;

    // get the size needed for the name buffer
    NtQueryObject(hk, ObjectNameInformation, NULL, 0, &cbSize);

    if (cbSize)
    {
        POBJECT_NAME_INFORMATION pNameInfo = (POBJECT_NAME_INFORMATION)LocalAlloc(LPTR, cbSize);

        if (pNameInfo)
        {
            NTSTATUS status = NtQueryObject(hk, ObjectNameInformation, (void*)pNameInfo, cbSize, NULL);
        
            if (NT_SUCCESS(status) && WideCharToMultiByte(CP_ACP, 0, pNameInfo->Name.Buffer, -1, pszName, cchName, NULL, NULL))
            {
                bRet = TRUE;
            }

            LocalFree(pNameInfo);
        }
    }

    return bRet;
}


// If hk points underneath HKCU and matches pszSearchName, then return TRUE
BOOL DoesKeyMatch(HKEY hk, LPCSTR pszSearchName)
{
    BOOL bRet = FALSE;

    // make sure it is not one of the pre-defined keys (eg HKEY_LOCAL_MACHINE)
    if (!((LONG)((ULONG_PTR)hk) & 0x80000000))
    {
        CHAR szKeyName[MAX_PATH * 2];  // should be big enought to hold any registry key path

        if (GetKeyName(hk, szKeyName, ARRAYSIZE(szKeyName)))
        {
            // is the key under HKCU ?
            if (StrCmpNIA(szKeyName, "\\REGISTRY\\USER\\", ARRAYSIZE("\\REGISTRY\\USER\\")-1) == 0)
            {
                LPSTR psz = StrRStrIA(szKeyName, NULL, pszSearchName);

                if (psz && (lstrlenA(psz) == lstrlenA(pszSearchName)))
                {
                    // we found a substring and its the same length, so our hkey matches the search!
                    bRet = TRUE;
                }
            }
        }
    }

    return bRet;
}


BOOL IsBadHKCUKey(HKEY hk, LPCSTR* ppszNewKey)
{
    BOOL bRet = FALSE;
    int i;

    for (i=0; i < ARRAYSIZE(g_aBadKeys); i++)
    {
        if (DoesKeyMatch(hk, g_aBadKeys[i]))
        {
            *ppszNewKey = g_aBadKeys[i];
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


BOOL IsBadShellFolderKey(HKEY hk, LPCSTR* ppszNewKey)
{
    BOOL bRet = FALSE;
    int i;

    for (i=0; i < ARRAYSIZE(g_aBadShellFolderKeys); i++)
    {
        if (DoesKeyMatch(hk, g_aBadShellFolderKeys[i]))
        {
            *ppszNewKey = g_aBadShellFolderKeys[i];
            bRet = TRUE;
            break;
        }
    }

    return bRet;
}


LONG
APIHOOK(RegCreateKeyA)(
    HKEY   hKey,
    LPCSTR pszSubKey,
    PHKEY  phkResult
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegCreateKeyA)(hKey, pszSubKey, phkResult);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HKCU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegCreateKeyA)(HKEY_LOCAL_MACHINE, pszNewHKLMKey, phkResult);
        
        LOGN(eDbgLevelInfo, "[RegCreateKeyA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }

    return lRet;
}


LONG
APIHOOK(RegCreateKeyExA)(
    HKEY                  hKey,
    LPCSTR                pszSubKey,
    DWORD                 Reserved,
    LPSTR                 lpClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegCreateKeyExA)(hKey,
                                              pszSubKey,
                                              Reserved,
                                              lpClass,
                                              dwOptions,
                                              samDesired,
                                              lpSecurityAttributes,
                                              phkResult,
                                              lpdwDisposition);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HCKU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegCreateKeyExA)(HKEY_LOCAL_MACHINE,
                                             pszNewHKLMKey,
                                             Reserved,
                                             lpClass,
                                             dwOptions,
                                             samDesired,
                                             lpSecurityAttributes,
                                             phkResult,
                                             lpdwDisposition);

        LOGN(eDbgLevelInfo, "[RegCreateKeyExA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }

    return lRet;
}


LONG
APIHOOK(RegOpenKeyA)(
    HKEY   hKey,
    LPCSTR pszSubKey,
    PHKEY  phkResult
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegOpenKeyA)(hKey, pszSubKey, phkResult);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HCKU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegOpenKeyA)(HKEY_LOCAL_MACHINE, pszNewHKLMKey, phkResult);

        LOGN(eDbgLevelInfo, "[RegOpenKeyA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }
    
    return lRet;
}


LONG
APIHOOK(RegOpenKeyExA)(
    HKEY   hKey,
    LPCSTR pszSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegOpenKeyExA)(hKey, pszSubKey, ulOptions, samDesired, phkResult);

    if ((lRet == ERROR_SUCCESS) &&
        IsBadHKCUKey(*phkResult, &pszNewHKLMKey))
    {
        // its a bad HCKU key-- redirect to HKLM
        RegCloseKey(*phkResult);

        lRet = ORIGINAL_API(RegOpenKeyExA)(HKEY_LOCAL_MACHINE, pszNewHKLMKey, ulOptions, samDesired, phkResult);
        
        LOGN(eDbgLevelInfo, "[RegOpenKeyExA] overriding \"%s\" create key request w/ HKLM value (return = %d)", pszSubKey, lRet);
    }

    return lRet;
}


LONG
GetAllUsersRegValueA(
    LPSTR  szRegValue,
    DWORD  cbOriginal,
    DWORD* pcbData,
    int    nFolder,
    int    nFolderCommon
    )
{
    LONG lRet = ERROR_SUCCESS;

    if (!szRegValue)
    {
        // if the caller is querying for the necessary size, return the "worst case" since we don't know if
        // we are going to have to lie or not
        *pcbData = MAX_PATH;
    }
    else if (szRegValue[0] != '\0')
    {
        CHAR szPath[MAX_PATH];

        if (SUCCEEDED(SHGetFolderPathA(NULL, nFolder, NULL, SHGFP_TYPE_CURRENT, szPath))) {
            CHAR szShortRegPath[MAX_PATH];
            CHAR szShortGSFPath[MAX_PATH];
            BOOL bUseLFN = FALSE;
            BOOL bSame = FALSE;
        
            if (lstrcmpiA(szPath, szRegValue) == 0) {
                bSame = TRUE;
                bUseLFN = TRUE;
            } else {
                DWORD dwSize = GetShortPathNameA(szPath, szShortGSFPath, ARRAYSIZE(szShortGSFPath));
                DWORD dwSize2= GetShortPathNameA(szRegValue, szShortRegPath, ARRAYSIZE(szShortRegPath));
                if (dwSize  > 0 && dwSize < ARRAYSIZE(szShortGSFPath) &&
                    dwSize2 > 0 && dwSize < ARRAYSIZE(szShortRegPath) &&
                    lstrcmpiA(szShortGSFPath, szShortRegPath) == 0 ) {
                    bSame = TRUE;
                
                    //
                    // Since the sfn was returned, use that to copy over the output buffer.
                    //
                    bUseLFN = FALSE;
                }
            }

            if (bSame && SUCCEEDED(SHGetFolderPathA(NULL, nFolderCommon, NULL, SHGFP_TYPE_CURRENT, szPath))) {
                if (bUseLFN) {
                    if ((lstrlenA(szPath) + 1) <= (int)cbOriginal) {
                        LOGN(
                            eDbgLevelInfo,
                            "[GetAllUsersRegValueA] overriding per-user reg value w/ common value");
                        StringCchCopyA(szRegValue, MAX_PATH, szPath);                    
                    } else {
                        LOGN(
                            eDbgLevelInfo,
                            "[GetAllUsersRegValueA] returning ERROR_MORE_DATA for special folder value");
                        lRet = ERROR_MORE_DATA;
                    }

                    //
                    // Either we used this much room, or this is how much we need to have.
                    //
                    *pcbData = lstrlenA(szPath) + 1;
            
                } else {
                    DWORD dwSize = GetShortPathNameA(szPath, szShortGSFPath, ARRAYSIZE(szShortGSFPath));
                    if (dwSize > 0 && dwSize < ARRAYSIZE(szShortGSFPath)) {
                
                        if ((lstrlenA(szShortGSFPath) + 1) <= (int)cbOriginal) {
                            LOGN(
                                eDbgLevelInfo,
                                "[GetAllUsersRegValueA] overriding per-user reg value w/ common value");
                        
                            StringCchCopyA(szRegValue, cbOriginal, szShortGSFPath);                    
                        } else {
                            LOGN(
                                eDbgLevelInfo,
                                "[GetAllUsersRegValueA] returning ERROR_MORE_DATA for special folder value");
                            lRet = ERROR_MORE_DATA;
                        }

                        //
                        // Either we used this much room, or this is how much we need to have.
                        //
                        *pcbData = lstrlenA(szShortGSFPath) + 1;
                    }
                }
            }
        }
    }

    return lRet;
}


//
// If the app is asking for the per-user "Desktop", "Start Menu" or "Startup" values by
// groveling the registry, then redirect it to the proper per-machine values.
//
LONG
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,           // handle to key
    LPCSTR  lpValueName,    // value name
    LPDWORD lpReserved,     // reserved
    LPDWORD lpType,         // type buffer
    LPBYTE  lpData,         // data buffer
    LPDWORD lpcbData        // size of data buffer
    )
{
    DWORD cbOriginal = (lpcbData ? *lpcbData : 0);  // save off the original buffer size
    LPCSTR pszNewHKLMKey;
    LONG lRet = ORIGINAL_API(RegQueryValueExA)(hKey,
                                               lpValueName,
                                               lpReserved,
                                               lpType,
                                               lpData,
                                               lpcbData);

    if ((lpValueName && lpcbData) &&    // (not simply checking for existance of the value...)
        IsBadShellFolderKey(hKey, &pszNewHKLMKey))
    {
        CHAR  szTemp[MAX_PATH];
    
        if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_NEUTRAL),SORT_DEFAULT),
                           NORM_IGNORECASE, lpValueName, -1,
                           "Desktop",-1) == CSTR_EQUAL) {            
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Desktop' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData,
                                            cbOriginal,
                                            lpcbData,
                                            CSIDL_DESKTOP,
                                            CSIDL_COMMON_DESKTOPDIRECTORY);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }

        } else if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_NEUTRAL),SORT_DEFAULT),
                                  NORM_IGNORECASE, lpValueName, -1,
                                  "Start Menu",-1) == CSTR_EQUAL) {                  
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Start Menu' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData,
                                            cbOriginal,
                                            lpcbData,
                                            CSIDL_STARTMENU,
                                            CSIDL_COMMON_STARTMENU);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }
        
        } else if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_NEUTRAL),SORT_DEFAULT),
                                  NORM_IGNORECASE, lpValueName, -1,
                                  "Startup",-1) == CSTR_EQUAL) {         
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Startup' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData, cbOriginal, lpcbData, CSIDL_STARTUP, CSIDL_COMMON_STARTUP);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_STARTUP, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }

        } else if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_NEUTRAL),SORT_DEFAULT),
                                  NORM_IGNORECASE, lpValueName, -1,
                                  "Programs",-1) == CSTR_EQUAL) {                    
            DPFN(
                eDbgLevelInfo,
                "[RegQueryValueExA] querying for 'Programs' value\n");

            if (lRet == ERROR_SUCCESS) {
                lRet = GetAllUsersRegValueA((LPSTR)lpData, cbOriginal, lpcbData, CSIDL_PROGRAMS, CSIDL_COMMON_PROGRAMS);
            
            } else if (lRet == ERROR_MORE_DATA) {
                
                if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT, szTemp))) {
                    *lpcbData = MAX(*lpcbData, (DWORD)((lstrlenA(szTemp) + 1) * sizeof(CHAR)));
                }
            }
        }
    }

    return lRet;
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA);
                APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA);
            }
        }
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\versionlietemplate.h ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

   VersionLieTemplate.h

 Abstract:

   Blank template for version lie shims.

 History:

   09/05/2002   robkenny    Created.

--*/

extern DWORD       MajorVersion;
extern DWORD       MinorVersion;
extern DWORD       BuildNumber;
extern SHORT       SpMajorVersion;
extern SHORT       SpMinorVersion;
extern DWORD       PlatformId;
extern CString *   csServicePack;


#define SIZE(x)  sizeof(x)/sizeof(x[0])

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with the specified credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExA] called. return %d.%d %S", MajorVersion, MinorVersion, csServicePack->Get());

        //
        // Fixup the structure with the WinXP data.
        //
        lpVersionInformation->dwMajorVersion = MajorVersion;
        lpVersionInformation->dwMinorVersion = MinorVersion;
        lpVersionInformation->dwBuildNumber  = BuildNumber;
        lpVersionInformation->dwPlatformId   = PlatformId;
                
        CSTRING_TRY
        {
            if (S_OK == StringCbCopyExA(lpVersionInformation->szCSDVersion, 
                            SIZE(lpVersionInformation->szCSDVersion),                        
                            csServicePack->GetAnsi(), NULL , NULL, STRSAFE_NULL_ON_FAILURE))
            {
                if (lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXA) ) 
                {
                    // They passed a OSVERSIONINFOEX structure.
                    LPOSVERSIONINFOEXA osVersionInfo = (LPOSVERSIONINFOEXA)lpVersionInformation;

                    // Set the major and minor service pack numbers.
                    osVersionInfo->wServicePackMajor = SpMajorVersion;
                    osVersionInfo->wServicePackMinor = SpMinorVersion;
                }

                bReturn = TRUE;
            }
        }
        CSTRING_CATCH
        {
            bReturn = FALSE;
        }

    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with the specified credentials.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExW] called. return %d.%d %S", MajorVersion, MinorVersion, csServicePack->Get());

        //
        // Fixup the structure with the WinXP data.
        //
        lpVersionInformation->dwMajorVersion = MajorVersion;
        lpVersionInformation->dwMinorVersion = MinorVersion;
        lpVersionInformation->dwBuildNumber  = BuildNumber;
        lpVersionInformation->dwPlatformId   = PlatformId;
                
        if (S_OK == StringCbCopyExW(lpVersionInformation->szCSDVersion, 
                        SIZE(lpVersionInformation->szCSDVersion),                        
                        csServicePack->Get(), NULL , NULL, STRSAFE_NULL_ON_FAILURE))
        {
            if (lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXW) ) 
            {
                // They passed a OSVERSIONINFOEX structure.
                LPOSVERSIONINFOEXW osVersionInfo = (LPOSVERSIONINFOEXW)lpVersionInformation;

                // Set the major and minor service pack numbers.
                osVersionInfo->wServicePackMajor = SpMajorVersion;
                osVersionInfo->wServicePackMinor = SpMinorVersion;
            }

            bReturn = TRUE;
        }
    }
    return bReturn;
}

/*++

 This stub function returns the specified credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    DWORD dwVersion = ((PlatformId ^ 0x2) << 30) |
                       (BuildNumber       << 16) |
                       (MinorVersion      << 8)  |
                       (MajorVersion)            ;
    LOGN(
        eDbgLevelInfo,
        "[GetVersion] called. return 0x%08x", dwVersion);

    return dwVersion;
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        csServicePack = new CString();
        if (csServicePack == NULL)
        {
            return FALSE;
        }

        CSTRING_TRY
        {
            if (SpMajorVersion > 0)
            {
                csServicePack->Format(L"Service Pack %d", SpMajorVersion);
            }
            else
            {
                *csServicePack = L"";
            }
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\vregistry.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    VRegistry.cpp

 Abstract:

    A virtual registry for misbehaving registry readers.

    This engine has 5 main features:
        1. Key redirection
           Eg: HKLM\Software -> HKLM\Hardware
        2. Key and Value spoofing
           Eg: HKLM\Software\VersionNumber can be made to appear as a valid 
               value
               HKEY_DYN_DATA can appear valid
        3. Expansion of REG_EXPAND_SZ value type to REG_SZ
           Eg: %SystemRoot%\Media will result in C:\WINNT\Media
        4. Support for EnumKey, EnumValue and QueryInfoKey on virtual keys
        5. Support for CreateKey

    Other features:
        1. Strip leading '\' characters from keys
        2. Add MAXIMUM_ALLOWED security attributes to all keys
        3. Adjust parameters of QueryInfoKey to match Win95
        4. Enable key deletion for key which still has subkeys 
           in order to match Win95 behavior for RegDeleteKey
        5. Values and keys can be protected from modification and deletion
        6. Custom triggers on opening a key.
        7. Values that have extra data beyond end of string can be queried
           even though the provided buffer is too small for extra data.

    Known limitations:
        No support for RegSetValue and RegSetValueEx other than known parameter 
        error and value protection.

 Notes:

    This is for apps with registry problems

 History:

    01/06/2000  linstev     Created
    01/10/2000  linstev     Added support for RegEnumKey, RegEnumValue 
    01/10/2000  linstev     Added support for RegCreateKey
    05/05/2000  linstev     Parameterized
    10/03/2000  maonis      Bug fixes and got rid of the cleanup code in process detach.
    10/30/2000  andyseti    Added support for RegDeleteKey
    02/27/2001  robkenny    Converted to use CString
    08/07/2001  mikrause    Added protectors, enumeration of virtual & non-virtual keys & values,
                            triggers on opening a key, and querying values with extra data
                            and a too small buffer.
    10/12/2001  mikrause    Added support for custom callbacks on SetValue.
                            Reimplemented value protectors as do-nothing callbacks.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)
#include "ShimHookMacro.h"
#include "VRegistry.h"
#include "VRegistry_Worker.h"


// Allows us to have only one code path for dumping all APIs or just the APIs 
// that had errors
#define ELEVEL(lRet) SUCCESS(lRet) ? eDbgLevelInfo : eDbgLevelError

CRITICAL_SECTION csRegCriticalSection;

// Global instance of Virtual Registry class
CVirtualRegistry VRegistry;

// Used to enable win9x only features
BOOL g_bWin9x = TRUE;

/*++

 Class Description:

    This class is designed to simplify locking logic. If an object of this 
    class is instantiated, then internal lock will be taken. As soon as object 
    is destroyed lock will be released. We also check if the registry has been 
    initialized. This has to happen late because we don't get notified after 
    we've been loaded.

 History:

    01/10/2000 linstev  Created

--*/

static BOOL g_bInitialized = FALSE;

BOOL ParseCommandLineA(LPCSTR lpCommandLine);

class CRegLock
{
public:
    CRegLock()
    {
        EnterCriticalSection(&csRegCriticalSection);
        if (!g_bInitialized)
        {

           VENTRY* ventry = g_pVList;
           while (ventry->pfnBuilder)
           {
              if (ventry->bShouldCall)
              {
                 DPFN( eDbgLevelInfo, "  %S", ventry->cName);
                 ventry->pfnBuilder(ventry->szParam);
                 if (ventry->szParam)
                 {
                    free(ventry->szParam);
                 }
                 ventry->bShouldCall = FALSE;
              }
              ventry++;
           }
           g_bInitialized = TRUE;           
        }
    }
    ~CRegLock()
    {
       LeaveCriticalSection(&csRegCriticalSection);     
    }
};

/*++

 Function Description:

    Remove leading slash from an Unicode string 

 Arguments:

    IN lpSubKey - path to string

 Return Value:

    Subkey without leading \

 History:

    01/06/2000 linstev  Created

--*/

LPCWSTR 
TrimSlashW(
    IN OUT LPCWSTR lpSubKey
    )     
{
    if (!lpSubKey)
    {
        return lpSubKey;
    }
    
    LPWSTR lpNew = (LPWSTR) lpSubKey;
    
    #define REG_MACHINE   L"\\Registry\\Machine"
    #define REG_USER      L"\\Registry\\User"

    //
    // Pull off the old NT4 legacy stuff. This only works on NT4, but we're 
    // making it for everyone since it's low risk.
    //
    if (wcsistr(lpNew, REG_MACHINE) == lpNew)
    {
        LOGN( eDbgLevelError, "[TrimSlashW] Bypass \\Registry\\Machine");
        lpNew += wcslen(REG_MACHINE);
    }
    else if (wcsistr(lpNew, REG_USER) == lpNew)
    {
        LOGN( eDbgLevelError, "[TrimSlashW] Bypass \\Registry\\User");
        lpNew += wcslen(REG_USER);
    }
    
    if (*lpNew == L'\\')
    {
        LOGN( eDbgLevelError, "[TrimSlashW] Removed slash from key beginning");
        lpNew++;
    }

    return lpNew;
}

/*++

 Function Description:

    Convert a key from registry format to virtual registry format. i.e.:
    HKEY, Path -> VPath. The VPath format has the base included as "HKLM" 
    instead of HKEY_LOCAL_MACHINE etc.

    Algorithm:
        1. Case the different keys and output a 4 letter string
        2. Append subkey if available

 Arguments:

    IN  hkBase   - Base key, eg: HKEY_LOCAL_MACHINE
    IN  lpSubKey - Subkey, eg: SOFTWARE
    OUT lpPath   - Output, eg: HKLM\SOFTWARE

 Return Value:

    A string path of the form HKLM\SOFTWARE

 History:

    01/06/2000 linstev  Created

--*/

LPWSTR 
MakePath(
    IN HKEY hkBase, 
    IN LPCWSTR lpKey,
    IN LPCWSTR lpSubKey
    )
{
    DWORD dwSize = 0;

    if (hkBase)
    {
        // Length of HKCU + NULL
        dwSize = 5;
    }
    if (lpKey)
    {
        dwSize += wcslen(lpKey) + 1;
    }
    if (lpSubKey)
    {
        dwSize += wcslen(lpSubKey) + 1;
    }

    LPWSTR lpPath = (LPWSTR) malloc((dwSize + 1) * sizeof(WCHAR));

    if (!lpPath)
    {
        if (dwSize)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
        }
        return NULL;
    }
    
    *lpPath = L'\0';

    HRESULT hr;
    if (hkBase)
    {
        if (hkBase == HKEY_CLASSES_ROOT)
        {
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKCR");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }
        }
        else if (hkBase == HKEY_CURRENT_CONFIG)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKCC");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }
        }           
        else if (hkBase == HKEY_CURRENT_USER)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKCU");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }
        else if (hkBase == HKEY_LOCAL_MACHINE)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKLM");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }            
        else if (hkBase == HKEY_USERS)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKUS");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }           
        else if (hkBase == HKEY_PERFORMANCE_DATA)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKPD");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }
        else if (hkBase == HKEY_DYN_DATA)
        {        
           hr = StringCchCopyW(lpPath, dwSize + 1, L"HKDD");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }            
        else
        {
            DPFN( eDbgLevelWarning, 
                "Key not found: %08lx - did not get an openkey or createkey", 
                hkBase);
        }
    }

    // Add the key 
    if (lpKey)
    {
        if (wcslen(lpPath) != 0)
        {
           hr = StringCchCatW(lpPath, dwSize + 1, L"\\");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }
        }
        hr = StringCchCatW(lpPath, dwSize + 1, lpKey);
        if (FAILED(hr))
        {
           goto ErrorCleanup;
        }        
    }

    // Add the subkey
    if (lpSubKey)
    {
        if (wcslen(lpPath) != 0)
        {
           hr = StringCchCatW(lpPath, dwSize + 1, L"\\");
           if (FAILED(hr))
           {
              goto ErrorCleanup;
           }            
        }
        hr = StringCchCatW(lpPath, dwSize + 1, lpSubKey);
        if (FAILED(hr))
        {
           goto ErrorCleanup;
        }
    }

    // The key name can have a trailing slash, so we clean this up
    DWORD dwLen = wcslen(lpPath);
    if (dwLen && (lpPath[dwLen - 1] == L'\\'))
    {
        lpPath[dwLen - 1] = L'\0';
    }

    return lpPath;

ErrorCleanup:
   free(lpPath);
   return NULL;
}

/*++

 Function Description:

    Convert a key from Path format into key and subkey format.

    Algorithm:
        1. Case the different keys and output a 4 letter string
        2. Append subkey if available

 Arguments:

    IN lpPath    - Path,   eg: HKLM\Software
    OUT hkBase   - Key,    eg: HKEY_LOCAL_MACHINE
    OUT lpSubKey - Subkey, eg: Software

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

LPWSTR
SplitPath(
    IN LPCWSTR lpPath,
    OUT HKEY *hkBase
    )
{
    LPWSTR p = (LPWSTR) lpPath;

    // Find first \ or NULL
    while (*p && (*p != L'\\')) p++;

    if (wcsncmp(lpPath, L"HKCR", 4) == 0)
        *hkBase = HKEY_CLASSES_ROOT;

    else if (wcsncmp(lpPath, L"HKCC", 4) == 0)
        *hkBase = HKEY_CURRENT_CONFIG;

    else if (wcsncmp(lpPath, L"HKCU", 4) == 0)
        *hkBase = HKEY_CURRENT_USER;

    else if (wcsncmp(lpPath, L"HKLM", 4) == 0)
        *hkBase = HKEY_LOCAL_MACHINE;

    else if (wcsncmp(lpPath, L"HKUS", 4) == 0)
        *hkBase = HKEY_USERS;

    else if (wcsncmp(lpPath, L"HKPD", 4) == 0)
        *hkBase = HKEY_PERFORMANCE_DATA;

    else if (wcsncmp(lpPath, L"HKDD", 4) == 0)
        *hkBase = HKEY_DYN_DATA;

    else
        *hkBase = 0;

    // Don't allow an invalid base key to get through.
    if (*hkBase && lpPath[4] != '\\')
    {
       *hkBase = 0;
    }

    if (*p)
    {
        p++;
    }

    return p;
}

/*++

 Function Description:
    
    Add a virtual key: a key contains other keys and values and will behave 
    like a normal registry key, but of course has no persistent storage.

    Algorithm:
        1. The input string is split apart and a tree is created recursively
        2. The key is created only if it doesn't already exist

 Arguments:

    IN lpPath - Path to key, eg: "HKLM\\Software"

 Return Value:

    Pointer to key or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALKEY *
VIRTUALKEY::AddKey(
    IN LPCWSTR lpPath
    )
{
    VIRTUALKEY *key;
    LPWSTR p = (LPWSTR)lpPath;

    // Find first \ or NULL
    while (*p && (*p != L'\\')) p++;

    // Check if this part already exists 
    key = keys;
    while (key != NULL)
    {
        if (_wcsnicmp(lpPath, key->wName, p - lpPath) == 0)
        {
            if (*p == L'\\')     
            {
                // Continue the search
                return key->AddKey(p + 1);
            }
            else                
            {
                // We already added this key
                return key;
            }
        }
        key = key->next;
    }

    // Create a new key

    key = (VIRTUALKEY *) malloc(sizeof(VIRTUALKEY));
    if (!key)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(key, sizeof(VIRTUALKEY));
    
    //
    // Still use wcsncpy, because here it specifies number of characters
    // to copy, not size of the destination buffer.  Add in check
    // for destination buffer size.
    //
    if ( (p - lpPath) > sizeof(key->wName)/sizeof(WCHAR))
    {
       free (key);
       return NULL;
    }       
    wcsncpy((LPWSTR)key->wName, lpPath, p - lpPath);
    key->next = keys;
    keys = key;

    DPFN( eDbgLevelSpew, "Adding Key %S", key->wName);

    if (*p == L'\0')
    {
        // We are at the end of the chain, so just return this one
        return key;
    }
    else
    {
        // More subkeys to go
        return key->AddKey(p + 1);
    }
}

/*++

 Function Description:

    Add a value to a virtual key. The actual registry key may exist and the 
    value may even exist, but this value will override.

    Algorithm:
        1. If lpData is a string and cbData is 0, calculate the size 
        2. Add this value (no duplicate checking)

 Arguments:

    IN lpValueName - Value name
    IN dwType      - Type of key; eg: REG_SZ, REG_DWORD etc
    IN lpData      - Data, use unicode if string
    IN cbData      - Size of lpData

 Return Value:

    Pointer to value or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddValue(
    IN LPCWSTR lpValueName, 
    IN DWORD dwType, 
    IN BYTE *lpData, 
    IN DWORD cbData
    )
{
   // Parameter validation
   if (lpData == NULL && cbData != 0)
   {
      return NULL;
   }

    VIRTUALVAL *value = (VIRTUALVAL *) malloc(sizeof(VIRTUALVAL));
    if (!value)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(value, sizeof(VIRTUALVAL));
    
    // Auto calculate size if cbData is 0
    if (lpData && (cbData == 0))
    {
        switch (dwType)
        {
        case REG_SZ:
        case REG_EXPAND_SZ:
            cbData = wcslen((LPWSTR)lpData)*2 + sizeof(WCHAR);
            break;

        case REG_DWORD:
            cbData = sizeof(DWORD);
            break;
        }
    }

    // lpValueName can == NULL, which means default value
    if (lpValueName)
    {
       HRESULT hr = StringCchCopy(value->wName, sizeof(value->wName)/sizeof(WCHAR), lpValueName);
       if (FAILED(hr))
       {
          free(value);
          return NULL;
       }
    }

    if (cbData)
    {
        // Make a copy of the data if needed
        value->lpData = (BYTE *) malloc(cbData);

        if (!value->lpData)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            free(value);
            return NULL;
        }

        MoveMemory(value->lpData, lpData, cbData);
        value->cbData = cbData;
    }

    value->pfnQueryValue = NULL;
    value->pfnSetValue = NULL;
    value->dwType = dwType;
    value->next = values;
    values = value;

    if (lpData && ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ)))
    {
        DPFN( eDbgLevelSpew, "Adding Value %S\\%S = %S", wName, lpValueName, lpData);
    }
    else
    {
        DPFN( eDbgLevelSpew, "Adding Value %S\\%S", wName, lpValueName);
    }
    
    return value;
}

/*++

 Function Description:

    Add a dword value to a key. Calls off to AddValue.

 Arguments:

    IN lpValueName - Value name
    IN Value       - DWord value

 Return Value:

    Pointer to a virtual dword value

 History:

    05/25/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddValueDWORD(
    IN LPCWSTR lpValueName,
    IN DWORD dwValue
    )
{
    return AddValue(lpValueName, REG_DWORD, (LPBYTE)&dwValue);
}

/*++

 Function Description:

    Add an expander to a key. An expander causes QueryValue to expand the 
    REG_EXPAND_SZ type to a REG_SZ type. The expander itself is just 
    a virtual value which allows us to intercept queries to it.

 Arguments:

    IN lpValueName - Value name

 Return Value:

    Pointer to a virtual value

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddExpander(
    IN LPCWSTR lpValueName
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnQueryValue = VR_Expand;
    }

    return value;
}

/*++

 Function Description:

    Add a protector on a value. A protector causes SetValue to
    be ignored.  This is implemented through a custom setvalue
    callback that does nothing.

 Arguments:

    IN lpValueName - Value name

 Return Value:

    Pointer to a virtual value

 History:

    10/12/2001 mikrause  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddProtector(
    IN LPCWSTR lpValueName
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnSetValue = VR_Protect;
    }

    return value;
}

/*++

 Function Description:

    Add a custom queryvalue routine

 Arguments:

    IN lpValueName - Value name
    IN pfnQueryValue - routine to call when this value is queried

 Return Value:

    Pointer to a virtual value

 History:

    07/18/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddCustom(
    IN LPCWSTR lpValueName,
    _pfn_QueryValue pfnQueryValue
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnQueryValue = pfnQueryValue;
    }

    return value;
}

/*++

 Function Description:

    Add a custom setvalue routine

 Arguments:

    IN lpValueName - Value name
    IN pfnSetValue - routine to call when this value is set

 Return Value:

    Pointer to a virtual value

 History:

    11/06/2001 mikrause  Created

--*/

VIRTUALVAL *
VIRTUALKEY::AddCustomSet(
    IN LPCWSTR lpValueName,
    _pfn_SetValue pfnSetValue
    )
{
    VIRTUALVAL *value = AddValue(lpValueName, REG_SZ, 0, 0);
    
    if (value)
    {
        value->pfnSetValue = pfnSetValue;
    }

    return value;
}

/*++

 Function Description:

    Find a subkey of a key.

    Algorithm:
        1. Recursively search the tree for the matching subkey

 Arguments:

    IN lpKeyName - Name of key to find

 Return Value:

    Pointer to value or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALKEY *
VIRTUALKEY::FindKey(
    IN LPCWSTR lpPath
    )
{
    VIRTUALKEY *key = keys;
    LPWSTR p = (LPWSTR)lpPath;

    if (!lpPath) 
    {
        return NULL;
    }
    
    // Find first \ or NULL
    while (*p && (*p != L'\\')) p++;

    // recursively look for the key
    while (key)
    {
        if (_wcsnicmp(
                lpPath, 
                key->wName, 
                max((DWORD_PTR)(p - lpPath), wcslen(key->wName))) == 0)
        {
            if (*p == L'\\')
            {
                key = key->FindKey(p + 1);
            }
            break;
        }

        key = key->next;
    }
    
    // We're at the end of the chain
    return key;
}

/*++

 Function Description:

    Find a value in a key. 

 Arguments:

    IN key         - Key used for expanders; unused at this time
    IN lpValueName - Value name

 Return Value:

    Pointer to value or NULL

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALVAL *
VIRTUALKEY::FindValue(
    IN LPCWSTR lpValueName
    )
{
    VIRTUALVAL *value = values;
    WCHAR wDef[1] = L"";
    LPWSTR lpName;

    if (!lpValueName) 
    {
        lpName = (LPWSTR)wDef;
    }
    else
    {
        lpName = (LPWSTR)lpValueName;
    }

    // Find the value
    while (value)
    {
        if (_wcsicmp(lpName, value->wName) == 0)
        {
            LOGN( eDbgLevelWarning, "[FindValue] Using virtual value:  %S", value->wName);
            break;
        }
        value = value->next;
    }
    
    return value;
}

/*++

 Function Description:

    Free the subkeys and values belonging to a key

    Algorithm:
        1. Free all values belonging to a key, including any data
        2. Free all subkeys recursively

 Arguments:

    None

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

VOID 
VIRTUALKEY::Free()
{
    VIRTUALVAL *value = values;
    VIRTUALKEY *key = keys;

    while (value)
    {
        values = value->next;
        if (value->lpData)
        {
            free((PVOID) value->lpData);
        }
        free((PVOID) value);
        value = values;
    }

    while (key)
    {
        keys = key->next;
        key->Free();
        free((PVOID) key);
        key = keys;
    }

    DPFN( eDbgLevelSpew, "Free keys and values from %S", wName);
}

/*++

 Function Description:

    Allocate a new enum entry

 Arguments:

    IN wzPath - Key path or value name of entry.
    IN next - Next entry in the list.    

 Return Value:

    Pointer to new entry or NULL

 History:

    08/21/2001 mikrause  Created

--*/

ENUMENTRY*
CreateNewEnumEntry(
    IN LPWSTR wzPath,
    IN ENUMENTRY* next)
{
    ENUMENTRY* enumEntry;
    enumEntry = (ENUMENTRY*)malloc(sizeof(ENUMENTRY));
    if (enumEntry == NULL)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(enumEntry, sizeof(ENUMENTRY));

    enumEntry->wzName = (LPWSTR)malloc((wcslen(wzPath) + 1)*sizeof(WCHAR));
    if (enumEntry->wzName == NULL)
    {
        free(enumEntry);
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    HRESULT hr = StringCchCopyW(enumEntry->wzName, wcslen(wzPath)+1, wzPath);
    if (FAILED(hr))
    {
       free(enumEntry->wzName);
       free(enumEntry);
       return NULL;
    }    

    enumEntry->next = next;

    return enumEntry;
}

/*++

 Function Description:

    Add enumeration entries to a list.  Templatized,
    so the same code works for keys or values.

 Arguments:

    IN entryHead - Head of the list containing virtual keys or values.
    IN enumFunc - Enumeration function to use.  Either RegEnumKey or RegEnumValue  

 Return Value:

    Pointer to the head of the entry list, or NULL.

 History:

    08/21/2001 mikrause  Created

--*/

template<class T>
ENUMENTRY*
OPENKEY::AddEnumEntries(T* entryHead, _pfn_EnumFunction enumFunc)
{
    LONG lRet;
    DWORD dwIndex;
    DWORD dwSize;
    WCHAR wzName[MAX_PATH + 1];
    ENUMENTRY* enumEntryList = NULL;
    ENUMENTRY* newEnumEntry = NULL;

    // Add virtual entries to the list.
    T* entry = entryHead;
    while (entry)
    {
        // Create a new entry.
        newEnumEntry = CreateNewEnumEntry(entry->wName, enumEntryList);

        if (newEnumEntry != NULL)
        {
            enumEntryList = newEnumEntry;         
        }
                
        entry = entry->next;
    }

    // Now non-virtuals.
    if (bVirtual == FALSE)
    {
        dwIndex = 0;

        for (;;)
        {
            dwSize = MAX_PATH * sizeof(WCHAR);
            lRet = enumFunc(hkOpen, dwIndex, wzName, &dwSize, NULL, NULL, NULL, NULL);

            // No more items, we're done.
            if (lRet == ERROR_NO_MORE_ITEMS)
            {
                break;
            }

            // 
            // Check for error.
            // On Win2K, this can return more data if there are additional keys.
            //
            if (lRet != ERROR_SUCCESS && lRet != ERROR_MORE_DATA)
            {
                break;
            }

            // Check if this key is a duplicate.
            entry = entryHead;
            while (entry)
            {
                if (_wcsicmp(entry->wName, wzName) == 0)
                {
                    break;
                }

                entry = entry->next;
            }

            // Add this key to the list, if it's not a duplicate.
            if (entry == NULL)
            {
                // Create a new entry.
                newEnumEntry = CreateNewEnumEntry(wzName, enumEntryList);
                if (newEnumEntry != NULL)
                {
                    enumEntryList = newEnumEntry;            
                }
            }
            dwIndex++;
        }
    }

    return enumEntryList;
}

/*++

 Function Description:

    Builds the list of enumerated keys and values.

 Arguments:

    None

 Return Value:

    None

 History:

    08/10/2001 mikrause  Created

--*/

VOID
OPENKEY::BuildEnumList()
{
    VIRTUALKEY* keyHead = NULL;
    VIRTUALVAL* valHead = NULL;

    if (vkey)
    {
        keyHead = vkey->keys;
        valHead = vkey->values;
    }

    enumKeys = AddEnumEntries(keyHead, (_pfn_EnumFunction)ORIGINAL_API(RegEnumKeyExW));
    enumValues = AddEnumEntries(valHead, (_pfn_EnumFunction)ORIGINAL_API(RegEnumValueW));
}

/*++

 Function Description:

    Flushes all enumerated data..

 Arguments:

    None

 Return Value:

    None

 History:

    08/10/2001 mikrause  Created

--*/

VOID
OPENKEY::FlushEnumList()
{
    ENUMENTRY *enumentry;

    DPFN(eDbgLevelInfo, "Flushing enumeration data for %S", wzPath);
    while (enumKeys)
    {
        enumentry = enumKeys;
        enumKeys = enumKeys->next;

        if (enumentry->wzName)
        {
            free(enumentry->wzName);
        }

        free(enumentry);
    }

    while (enumValues)
    {
        enumentry = enumValues;
        enumValues = enumValues->next;

        if (enumentry->wzName)
        {
            free(enumentry->wzName);
        }

        free(enumentry);
    }

    enumKeys = enumValues = NULL;
}

/*++

 Function Description:

    Initialize the virtual registry. This would ordinarily go into the 
    constructor, but because of the shim architecture, we need to explicity 
    initialize and free the virtual registry.

 Arguments:

    None

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

BOOL 
CVirtualRegistry::Init()
{
    OpenKeys = NULL; 
    Redirectors = NULL;
    KeyProtectors = NULL;    
    OpenKeyTriggers = NULL;

    Root = (VIRTUALKEY *) malloc(sizeof(VIRTUALKEY));
    if (!Root)
    {
       DPFN(eDbgLevelError, szOutOfMemory);
       return FALSE;
    }
    ZeroMemory(Root, sizeof(VIRTUALKEY));
    HRESULT hr = StringCchCopyW(Root->wName, sizeof(Root->wName)/sizeof(WCHAR), L"ROOT");
    if (FAILED(hr))
    {
       return FALSE;
    }
    
    DPFN( eDbgLevelSpew, "Initializing Virtual Registry");
    return TRUE;
}

/*++

 Function Description:

    Free the lists contained by the virtual registry. This includes keys, 
    their values and redirectors.

    Algorithm:
        1. Free virtual root key which recursively frees subkeys and values
        2. Free open keys
        3. Free redirectors

 Arguments:

    None

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

VOID 
CVirtualRegistry::Free()
{
    OPENKEY *key;
    REDIRECTOR *redirect;
    OPENKEYTRIGGER *trigger;
    PROTECTOR *protector;

    DPFN( eDbgLevelSpew, "Freeing Virtual Registry");

    // Free Root and all subkeys/values
    if (Root)
    {
        Root->Free();
        free(Root);
        Root = NULL;
    }
    
    // Delete all enumeration data.
    FlushEnumLists();

    // Free list of open registry keys
    key = OpenKeys;
    while (key)
    {
        OpenKeys = key->next;
        free(key->wzPath);
        free(key);
        key = OpenKeys;
    }

    // Free redirectors
    redirect = Redirectors;
    while (redirect)
    {
        Redirectors = redirect->next;
        free(redirect->wzPath);
        free(redirect->wzPathNew);
        free(redirect);
        redirect = Redirectors;
    }

    // Free open key triggers
    trigger = OpenKeyTriggers;
    while(trigger)
    {
        OpenKeyTriggers = trigger->next;
        free(trigger->wzPath);
        free(trigger);
        trigger = OpenKeyTriggers;
    }

    // Free Protectors
    protector = KeyProtectors;
    while(protector)
    {
        KeyProtectors = protector->next;
        free(protector->wzPath);
        free(protector);
        protector = KeyProtectors;
    }
}

/*++

 Function Description:

    Create a dummy key for use as a virtual key. We need to have unique handles
    in order to look up the keys, so by creating a key off HKLM, we can be 
    sure it won't fail. 
    
    We can't damage the registry like this because writes to this key will fail.
    Calls to QueryValue, QueryInfo and EnumKey will work correctly because the 
    virtual registry is used in preference to the real one.

 Arguments:

    None

 Return Value:

    Dummy key

 History:

    01/06/2000 linstev  Created

--*/

HKEY 
CVirtualRegistry::CreateDummyKey()
{
    HKEY key = NULL;

    LONG lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software", 0, KEY_READ, &key);
    if (lRet != ERROR_SUCCESS)
    {
       return NULL;
    }
    
    return key;
}

/*++

 Function Description:

    Find an open key in the list of open keys.

    Algorithm:
        1. Search the list of open keys for a match

 Arguments:

    IN hKey - Open HKEY 

 Return Value:

    Pointer to a key or NULL

 History:

    01/06/2000 linstev  Created

--*/

OPENKEY *
CVirtualRegistry::FindOpenKey(
    IN HKEY hKey
    )
{
    OPENKEY *key = OpenKeys;

    while (key)
    {
        if (key->hkOpen == hKey) 
        {
            return key;
        }
        key = key->next;
    }        
    return NULL;
}

/*++

 Function Description:

    If this key is to be redirected, we adjust the path to the redirected 
    version. This works even if the requested path is a 'subpath' of a 
    redirector, eg: 
        Input       = HKLM\Software\Test
        Redirector  = HKLM\Software -> HKLM\Hardware
        Output      = HKLM\Hardware\Test
    If no redirector is present for this key/path, then lpPath is unchanged

    Algorithm:
        1. Find a key whose base is a redirector
        2. Substitute the new base for the key

 Arguments:

    IN OUT lpPath - Path to redirect

 Return Value:

    TRUE if redirected

 History:

    01/06/2000 linstev  Created

--*/

BOOL
CVirtualRegistry::CheckRedirect(
    IN OUT LPWSTR *lpPath
    )
{
    REDIRECTOR *redirect = Redirectors;
    DWORD sza = wcslen(*lpPath);

    // Go through the list of redirectors
    while (redirect)
    {
        DWORD szb = wcslen(redirect->wzPath);
 
        if ((szb <= sza) &&
            (_wcsnicmp(*lpPath, redirect->wzPath, szb) == 0) &&
            ((*lpPath)[szb] == L'\\' || (*lpPath)[szb] == L'\0'))
        {
            WCHAR *p = *lpPath + szb;
            
            DWORD cchPathSize = wcslen(redirect->wzPathNew) + wcslen(p) + 1;
            LPWSTR wzPathNew = (LPWSTR) malloc(cchPathSize * sizeof(WCHAR));
            if (wzPathNew)
            {
               HRESULT hr;
               hr = StringCchCopyW(wzPathNew, cchPathSize, redirect->wzPathNew);
               if (FAILED(hr))
               {
                  free (wzPathNew);
                  return FALSE;
               }
               hr = StringCchCatW(wzPathNew, cchPathSize, p);
               if (FAILED(hr))
               {
                  free(wzPathNew);
                  return FALSE;
               }                
                
               // return the new path
               LOGN( eDbgLevelWarning, "Redirecting: %S -> %S", *lpPath, wzPathNew);
               
               free(*lpPath);
               *lpPath = wzPathNew;
               
               return TRUE;
            }
            else
            {
                DPFN( eDbgLevelError, szOutOfMemory);
                return FALSE;
            }
        }
        redirect = redirect->next;
    }

    return FALSE;
}

/*++

 Function Description:


    Returns true if a protector guards this key.
    This will even work on a subkey of a protector.

 Arguments:

    IN lpPath - Path to protect

 Return Value:

    TRUE if protected

 History:

    08/07/2001 mikrause  Created

--*/

BOOL
CVirtualRegistry::CheckProtected(
    IN LPWSTR lpPath
    )
{
    PROTECTOR *protect;
        
    DWORD sza = wcslen(lpPath);
    DWORD szb;

    protect = KeyProtectors;
    while (protect)
    {
        szb = wcslen(protect->wzPath);

        // Check if we have a key or subkey match.
        if ((szb <= sza) &&
            (_wcsnicmp(protect->wzPath, lpPath, szb) == 0) &&
            (lpPath[szb] == L'\\' || lpPath[szb] == L'\0'))
        {
            // Protector found.
            LOGN( eDbgLevelWarning, "\tProtecting: %S", lpPath);
            return TRUE;                     
        }

        protect = protect->next;
    }

    // Fell through, no protector found.
    return FALSE;
}

/*++

 Function Description:

    Checks if any triggers should be called on this path,
    and calls them.

 Arguments:

    IN lpPath - Path to check triggers for.    

 Return Value:

    None

 History:

    08/09/2001 mikrause  Created

--*/

VOID
CVirtualRegistry::CheckTriggers(
    IN LPWSTR lpPath)
{
    OPENKEYTRIGGER *trigger;
    DWORD sza, szb;

    sza = wcslen(lpPath);
    trigger = OpenKeyTriggers;

    //
    // Loop through all triggers and check. Even after finding a match,
    // keep repeating, because a single OpenKey can cause multiple triggers.
    //
    while (trigger)
    {                
        szb = wcslen(trigger->wzPath);
        if ((szb <= sza) &&
            (_wcsnicmp(lpPath, trigger->wzPath, szb)==0) &&
            (lpPath[szb] == L'\\' || lpPath[szb] == L'\0'))
        {
            DPFN(eDbgLevelInfo, "Triggering %S on opening of %S", trigger->wzPath, lpPath);
            trigger->pfnTrigger(lpPath);
        }

        trigger = trigger->next;
    }
}

/*++

 Function Description:

    Flushes all enumerated lists.

 Arguments:

    IN lpPath    - Path to redirect, eg: HKLM\Software\Microsoft
    IN lpPathNew - Redirect to this path

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

VOID
CVirtualRegistry::FlushEnumLists()
{
    OPENKEY *key;

    key = OpenKeys;
    while (key)
    {
        key->FlushEnumList();
        key = key->next;
    }
}

/*++

 Function Description:

    Add a redirector to the virtual registry. See CheckRedirect().

 Arguments:

    IN lpPath    - Path to redirect, eg: HKLM\Software\Microsoft
    IN lpPathNew - Redirect to this path

 Return Value:

    None

 History:

    01/06/2000 linstev  Created

--*/

REDIRECTOR *
CVirtualRegistry::AddRedirect(
    IN LPCWSTR lpPath, 
    IN LPCWSTR lpPathNew)
{
    REDIRECTOR *redirect = (REDIRECTOR *) malloc(sizeof(REDIRECTOR));
    
    if (!redirect)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(redirect, sizeof(REDIRECTOR));

    DWORD cchPath = wcslen(lpPath) + 1;
    DWORD cchNewPath = wcslen(lpPathNew) + 1;
    redirect->wzPath = (LPWSTR) malloc(cchPath * sizeof(WCHAR));
    redirect->wzPathNew = (LPWSTR) malloc(cchNewPath * sizeof(WCHAR));

    if (redirect->wzPath && redirect->wzPathNew)
    {
       HRESULT hr;
       hr = StringCchCopyW(redirect->wzPath, cchPath, lpPath);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       }
       hr = StringCchCopyW(redirect->wzPathNew, cchNewPath, lpPathNew);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       }        
    }
    else
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        goto ErrorCleanup;
        
    }

    redirect->next = Redirectors;
    Redirectors = redirect;

    DPFN( eDbgLevelSpew, "Adding Redirector:  %S ->\n  %S", lpPath, lpPathNew);

    return redirect;

ErrorCleanup:
   free(redirect->wzPath);
   free(redirect->wzPathNew);
   free(redirect);
   return NULL;   
}

/*++

 Function Description:

    Add a key protector to the virtual registry. See CheckProtected().

 Arguments:

    IN lpPath    - Path to protector, eg: HKLM\Software\Microsoft

 Return Value:

    None

 History:

    08/21/2001 mikrause  Created

--*/

PROTECTOR *
CVirtualRegistry::AddKeyProtector(
    IN LPCWSTR lpPath)
{
    PROTECTOR *protect = (PROTECTOR *) malloc(sizeof(PROTECTOR));
    
    if (!protect)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(protect, sizeof(PROTECTOR));

    DWORD cchPath = wcslen(lpPath) + 1;
    protect->wzPath = (LPWSTR) malloc(cchPath * sizeof(WCHAR));

    if (protect->wzPath)
    {
       HRESULT hr;
       hr = StringCchCopyW(protect->wzPath, cchPath, lpPath);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       } 
    }
    else
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        goto ErrorCleanup;
    }   

    DPFN( eDbgLevelSpew, "Adding Key Protector:  %S", lpPath);
    protect->next = KeyProtectors;
    KeyProtectors = protect;    

    return protect;

ErrorCleanup:
   free(protect->wzPath);
   free(protect);
   return NULL;
}

/*++

 Function Description:

    Add an open key trigger to the virtual registry.

 Arguments:

    IN lpPath    - Path to trigger on, eg: HKLM\Software\Microsoft
    IN pfnOpenKey - Function to be called when key is opened.

 Return Value:

    New open key trigger, or NULL on failure.

 History:

    08/07/2001 mikrause  Created

--*/

OPENKEYTRIGGER*
CVirtualRegistry::AddOpenKeyTrigger(
    IN LPCWSTR lpPath,
    IN _pfn_OpenKeyTrigger pfnOpenKey)
{
    OPENKEYTRIGGER *openkeytrigger = (OPENKEYTRIGGER *) malloc(sizeof(OPENKEYTRIGGER));
    
    if (!openkeytrigger)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return NULL;
    }

    ZeroMemory(openkeytrigger, sizeof(OPENKEYTRIGGER));

    DWORD cchPath = wcslen(lpPath) + 1;
    openkeytrigger->wzPath = (LPWSTR) malloc(cchPath * sizeof(WCHAR));

    if (openkeytrigger->wzPath)
    {
       HRESULT hr = StringCchCopyW(openkeytrigger->wzPath, cchPath, lpPath);
       if (FAILED(hr))
       {
          goto ErrorCleanup;
       }        
    }
    else
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        goto ErrorCleanup;
    }

    openkeytrigger->pfnTrigger = pfnOpenKey;
    openkeytrigger->next = OpenKeyTriggers;
    OpenKeyTriggers = openkeytrigger;

    DPFN( eDbgLevelSpew, "Adding Open Key Trigger:  %S, func@0x%x", lpPath, pfnOpenKey);

    return openkeytrigger;

ErrorCleanup:
   free(openkeytrigger->wzPath);
   free(openkeytrigger);
   return NULL;
}

/*++

 Function Description:

    Allow user to specify VRegistry.AddKey instead of VRegistry.Root->AddKey.

 Arguments:

    IN lpPath - Path of key

 Return Value:

    Virtual key

 History:

    01/06/2000 linstev  Created

--*/

VIRTUALKEY *
CVirtualRegistry::AddKey(
    IN LPCWSTR lpPath
    )
{
    return Root->AddKey(lpPath);
}

/*++

 Function Description:

    Virtualized version of RegCreateKeyA, RegCreateKeyExA, RegOpenKeyA and RegOpenKeyExA
    See RegOpenKey* and RegCreateKey* for details

    Algorithm:
        1. Convert lpSubKey and lpClass to WCHAR
        2. Pass through to OpenKeyW

 Arguments:

    IN  hKey      - Handle to open key or HKLM etc
    IN  lpSubKey  - Subkey to open
    IN  lpClass   - Address of a class string
    IN  DWORD dwOptions - special options flag
    OUT phkResult       - Handle to open key if successful
    OUT lpdwDisposition - Address of disposition value buffer
    IN  bCreate   - Create the key if it doesn't exist

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG CVirtualRegistry::OpenKeyA(
    IN HKEY hKey, 
    IN LPCSTR lpSubKey, 
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes,
    OUT HKEY *phkResult,
    OUT LPDWORD lpdwDisposition,
    IN BOOL bCreate
    )
{
    LONG lRet;
    LPWSTR wzSubKey = NULL; 
    LPWSTR wzClass = NULL;

    if (lpSubKey)
    {
        wzSubKey = ToUnicode(lpSubKey);
        if (!wzSubKey)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpClass)
    {
        wzClass = ToUnicode(lpClass);
        if (!wzClass)
        {
            free(wzSubKey);
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    lRet = OpenKeyW(
        hKey,
        wzSubKey,
        wzClass,
        dwOptions,
        samDesired,
        pSecurityAttributes,
        phkResult,
        lpdwDisposition,
        bCreate,
        FALSE,
        NULL);

    free(wzSubKey);
    free(wzClass);

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegOpenKeyExW, RegOpenKeyW, RegCreateKeyW and RegCreateKeyExW

    Algorithm:
       1. Strip leading '\' characters
       2. Inherit already open key data to get full key path
       3. Redirect if necessary
       4. RegOpenKeyEx with maximum possible security attributes
       5. If the open failed, check for virtual key
       6. If virtual, return a dummy key and succeed
       7. Find the virtual key if it exists and attach it to the open key

 Arguments:

    IN  hKey      - Handle to open key or HKLM etc
    IN  lpSubKey  - Subkey to open
    IN  lpClass   - Address of a class string
    IN  DWORD dwOptions - special options flag
    OUT phkResult       - Handle to open key if successful
    OUT lpdwDisposition - Address of disposition value buffer
    IN  bCreate   - Create the key if it doesn't exist
    IN  bRemote   - Opening the remote registry.
    IN  lpMachineName - Machine name.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::OpenKeyW(
    IN HKEY hKey, 
    IN LPCWSTR lpSubKey, 
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes,
    OUT HKEY *phkResult,
    OUT LPDWORD lpdwDisposition,
    IN BOOL bCreate,
    IN BOOL bRemote,
    IN LPCWSTR lpMachineName
    )
{
    // Just a paranoid sanity check 
    if (!hKey)
    {
        DPFN( eDbgLevelError, "NULL handle passed to OpenKeyW");
        return ERROR_INVALID_HANDLE;
    }

    // Hack for Mavis Beacon which uses really old stack for this parameter
    if (lpdwDisposition && IsBadWritePtr(lpdwDisposition, sizeof(DWORD_PTR)))
    {
        DPFN( eDbgLevelError, "HACK: Ignoring bad lpdwDispostion pointer");
        lpdwDisposition = NULL;
    }

    LONG lRet;
    OPENKEY *key;
    BOOL bVirtual, bRedirected;
    VIRTUALKEY *vkey;
    LPWSTR wzPath = NULL;

    __try 
    {
        // Base error condition
         lRet = ERROR_INVALID_HANDLE;

        // Everybody AVs if this ones bad
        *phkResult = 0;

        samDesired &= (KEY_WOW64_64KEY | KEY_WOW64_32KEY);
        samDesired |= MAXIMUM_ALLOWED;

        // Win9x ignores the options parameter
        if (g_bWin9x)
        {
            if (dwOptions & REG_OPTION_VOLATILE)
            {
                LOGN( eDbgLevelWarning, "[OpenKeyW] Removing volatile flag");
            }
            dwOptions = REG_OPTION_NON_VOLATILE;
        }
        
        // Trim leading stuff, e.g. '\' character
        lpSubKey = TrimSlashW(lpSubKey);

        // Inherit from previously opened key
        key = FindOpenKey(hKey);
        if (key)
        {
            bVirtual = key->bVirtual;
            bRedirected = key->bRedirected;
            wzPath = MakePath(0, key->wzPath, lpSubKey);
        }
        else
        {
            bVirtual = FALSE;
            bRedirected = FALSE;
            wzPath = MakePath(hKey, NULL, lpSubKey);
        }
        
        if (!wzPath)
        {
            // Set the error code appropriately
            lRet = ERROR_NOT_ENOUGH_MEMORY;
        }
        // Check if we need to trigger on this key
        else
        {
            CheckTriggers(wzPath);
        }

        // Now that we have the full path, see if we want to redirect it
        if (!bRedirected && wzPath && CheckRedirect(&wzPath))
        {
            //
            // Turn off virtual mode - since we don't know anything about the
            // key we're redirecting to...
            // 

            bVirtual = FALSE;

            //
            // Make sure we know we've been redirected so we don't get into recursive 
            // problems if the destination is a subkey of the source.
            //

            bRedirected = TRUE;

            //
            // We've been redirected, so we can no longer open the key directly: 
            // we have to get the full path in order to open the right key.
            //

            lpSubKey = SplitPath(wzPath, &hKey);
        }

        // Try and open the key if it's not already virtual
        if (!bVirtual)
        {
            //
            // Since we aren't virtual yet, we need to try for the original 
            // key. If one of these fail, then we'll go ahead and try for a 
            // virtual key.
            //

            if (bCreate)
            {
                lRet = ORIGINAL_API(RegCreateKeyExW)(
                    hKey, 
                    lpSubKey, 
                    0, 
                    lpClass, 
                    dwOptions, 
                    samDesired,
                    pSecurityAttributes,
                    phkResult,
                    lpdwDisposition);

                if (lRet == ERROR_SUCCESS)
                {
                    // Possible change in enumeration data, flush lists.
                    FlushEnumLists();
                }
            }
            else
            {
                //
                // bRemote is only true when this is called by the 
                // RegConnectRegistry hook so bCreate can't be true.
                //

                if (bRemote)
                {
                    lRet = ORIGINAL_API(RegConnectRegistryW)(
                        lpMachineName, 
                        hKey, 
                        phkResult);
                }
                else
                {
                    lRet = ORIGINAL_API(RegOpenKeyExW)(
                        hKey, 
                        lpSubKey, 
                        0, 
                        samDesired,
                        phkResult);
                }
            }
        }

        //
        // We have to look up the virtual key even if we managed to open an 
        // actual key, because when we query, we look for virtual values 
        // first. i.e. the virtual values override existing values.
        //

        vkey = Root->FindKey(wzPath);

        // Check if our key is virtual, or may need to become virtual
        if (bVirtual || FAILURE(lRet))
        {
            if (vkey)
            {
                //
                // We have a virtual key, so create a dummy handle to hand back
                // to the app. 
                //

                *phkResult = CreateDummyKey();

                if (*phkResult)
                {
                   bVirtual = TRUE;
                   lRet = ERROR_SUCCESS;
                }
                else
                {
                   // Couldn't create the dummy key, something seriously wrong.
                   DPFN(eDbgLevelError, "Couldn't create dummy key in OpenKeyW");
                   lRet = ERROR_FILE_NOT_FOUND;
                }
                
            }
        }

        if (SUCCESS(lRet) && wzPath)
        {
            // Made it this far, so make a new key entry
            key = (OPENKEY *) malloc(sizeof(OPENKEY));
            if (key)
            {
                key->vkey = vkey;
                key->bVirtual = bVirtual;
                key->bRedirected = bRedirected;
                key->hkOpen = *phkResult;
                key->wzPath = wzPath;
                key->enumKeys = NULL;
                key->enumValues = NULL;
                key->next = OpenKeys;
                OpenKeys = key;
            }
            else
            {
                DPFN( eDbgLevelError, szOutOfMemory);
                
                 // Clean up the dummy key
                 RegCloseKey(*phkResult);

                 lRet = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
         
        DPFN( ELEVEL(lRet), "%08lx=OpenKeyW(Key=%04lx)", lRet, hKey);
        if (wzPath)
        {
            DPFN( ELEVEL(lRet), "    Path=%S", wzPath);
        }
        DPFN( ELEVEL(lRet), "    Result=%04lx", *phkResult);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in OpenKeyW");
        lRet = ERROR_BAD_ARGUMENTS;
    }

    if (FAILURE(lRet))
    {
        //
        // If we failed for any reason, we didn't create an OPENKEY and so we 
        // can kill wzPath which was allocated by MakePath.
        //
        free(wzPath);
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegQueryValueExA and RegQueryValue.
    See QueryValueW for more details.
    
    Algorithm:
        1. Call QueryValueW
        2. If it's a string, convert back to ANSI

    Note: this whole function is slightly more complex than it needs to be 
    because we don't want to query the value twice: once to get it's type 
    and the second time to get the value.

    Most of the complications are due to the strings: we have to make sure we 
    have a buffer large enough so we can figure out how large the (possibly
    DBCS) string is.

 Arguments:

    IN hKey         - Handle to open key 
    IN lpValueName  - Value to query
    IN lpType       - Type of data, eg: REG_SZ
    IN OUT lpData   - Buffer for queries data
    IN OUT lpcbData - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::QueryValueA(
    IN HKEY hKey, 
    IN LPSTR lpValueName, 
    IN LPDWORD lpType, 
    IN OUT LPBYTE lpData, 
    IN OUT LPDWORD lpcbData
    )
{
    LONG lRet;
    WCHAR wValueName[MAX_PATH];
    DWORD dwType;
    DWORD dwSize, dwOutSize;
    LPBYTE lpBigData = NULL;
    BOOL bText;

    __try
    {
        // Can't have this
        if (lpData && !lpcbData)
        {
            return ERROR_INVALID_PARAMETER;
        }

        // Convert the Value Name to WCHAR
        if (lpValueName)
        {
           if (MultiByteToWideChar(
              CP_ACP, 
              0, 
              lpValueName, 
              -1, 
              (LPWSTR)wValueName, 
              MAX_PATH) == 0)
           {
              return ERROR_INVALID_PARAMETER;
           }
        }
        else
        {
           wValueName[0] = L'\0';           
        }

        //
        // Get an initial size to use: if they sent us a buffer, we start with 
        // that size, otherwise, we try a reasonable string length
        //

        if (lpData && *lpcbData)
        {
            dwSize = *lpcbData;
        }
        else
        {
            dwSize = MAX_PATH;
        }        

Retry:
        //
        // We can't touch their buffer unless we're going to succeed, so we 
        // have to double buffer the call.
        //

        lpBigData = (LPBYTE) malloc(dwSize);

        if (!lpBigData)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        lRet = QueryValueW(hKey, wValueName, &dwType, lpBigData, &dwSize);

        //
        // We need to know if it's a string, since then we have to do extra 
        // work to calculate the real size of the buffer etc.
        //

        bText = (SUCCESS(lRet) || (lRet == ERROR_MORE_DATA)) &&
                ((dwType == REG_SZ) || 
                 (dwType == REG_EXPAND_SZ) || 
                 (dwType == REG_MULTI_SZ));

        if (bText && (lRet == ERROR_MORE_DATA))
        {
            //
            // The buffer wasn't big enough: we have to actually query the value 
            // so we can get the real length in case it's DBCS, so we retry. 
            // Note: dwSize now contains the required size, so it will succeed
            // this time around.
            //

            free(lpBigData);

            goto Retry;
        }

        //
        // Calculate the size of the output buffer: if it's text, it may be
        // a DBCS string, so we need to get the right size
        //

        if (bText)
        {
            dwOutSize = WideCharToMultiByte(
                CP_ACP, 
                0, 
                (LPWSTR) lpBigData, 
                dwSize / sizeof(WCHAR), 
                NULL, 
                NULL,
                0, 
                0);
        }
        else
        {
            // It's not text, so we just use the actual size
            dwOutSize = dwSize;
        }

        //
        // If they gave us a buffer, we fill it in with what we got back
        //

        if (SUCCESS(lRet) && lpData)
        {
            //
            // Make sure we have enough space: lpcbData is guaranteed to be 
            // valid since lpData is ok.
            //

            if (*lpcbData >= dwOutSize)
            {
                if (bText)
                {
                    //
                    // Convert the string back to ANSI. The buffer must have been big 
                    // enough since QueryValue succeeded.
                    // Note: we have to give the exact size to convert otherwise we 
                    // use more of the buffer than absolutely necessary. Some apps, 
                    // like NHL 98 say they have a 256 byte buffer, but only give us 
                    // a 42 byte buffer. On NT, everything is done in place on that 
                    // buffer: so we always use more than the exact string length.
                    // This shim gets around that because we use separate buffers.
                    //

                    if (WideCharToMultiByte(
                        CP_ACP, 
                        0, 
                        (LPWSTR)lpBigData, 
                        dwSize / 2, 
                        (LPSTR)lpData, 
                        dwOutSize, // *lpcbData, 
                        0, 
                        0) == 0)
                    {
                       free(lpBigData);
                       return ERROR_INVALID_PARAMETER;
                    }
                }
                else 
                {
                    MoveMemory(lpData, lpBigData, dwSize);
                }
            }
            else
            {
                lRet = ERROR_MORE_DATA;
            }
        }

        free(lpBigData);

        // Fill the output structures in if possible
        if (lpType)
        {
            *lpType = dwType;
        }

        if (lpcbData)
        {
            *lpcbData = dwOutSize;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in QueryValueA");
        lRet = ERROR_BAD_ARGUMENTS;
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegQueryValueExW and RegQueryValue. We first see if the value 
    is virtual because virtual values override actual values

    Algorithm:
        1. Check if it's a virtual value and if so, spoof it
        2. If it's not virtual, query registry normally

 Arguments:

    IN hKey         - Handle to open key 
    IN lpValueName  - Value to query
    IN lpType       - Type of data, eg: REG_SZ
    IN OUT lpData   - Buffer for queries data
    IN OUT lpcbData - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::QueryValueW(
    IN HKEY hKey, 
    IN LPWSTR lpValueName, 
    IN LPDWORD lpType, 
    IN OUT LPBYTE lpData, 
    IN OUT LPDWORD lpcbData
    )
{
    // Just a paranoid sanity check 
    if (!hKey)
    {
        DPFN( eDbgLevelError, "NULL handle passed to OpenKeyW");
        return ERROR_INVALID_HANDLE;
    }

    LONG lRet;
    OPENKEY *key;
    VIRTUALKEY *vkey;
    VIRTUALVAL *vvalue;
    DWORD dwType;
    WCHAR* lpBuffer;
    DWORD dwStringSize;
    DWORD cbData = 0;
    BOOL  bDataPresent = TRUE;

    __try
    {
        lRet = ERROR_FILE_NOT_FOUND;
        
        // Can't have this
        if (lpData && !lpcbData)
        {   
            return ERROR_INVALID_PARAMETER;
        }

        // We always need the type
        if (!lpType)
        {
            lpType = &dwType;
        }

        // Do we want to spoof this
        key = FindOpenKey(hKey);
        vkey = key ? key->vkey : NULL;
        vvalue = vkey ? vkey->FindValue(lpValueName) : NULL;        

        if (key && vkey && vvalue &&
            (vvalue->cbData != 0 || vvalue->pfnQueryValue))
        {
            // Use the callback if available
            if (vvalue->pfnQueryValue)
            {
                //
                // Note, the callback puts it's values into the vvalue field,
                // just as if we knew it all along. In addition, we can fail
                // the call... but that doesn't allow us defer to the original
                // value. 
                //

                lRet = (*vvalue->pfnQueryValue)(
                    key,
                    vkey,
                    vvalue);
            }
            else
            {
                lRet = ERROR_SUCCESS;
            }

            // Copy the virtual value into the buffer
            if (SUCCESS(lRet))
            {
                *lpType = vvalue->dwType;

                if (lpData)
                {
                    if (vvalue->cbData <= *lpcbData)
                    {
                        MoveMemory(lpData, vvalue->lpData, vvalue->cbData);
                    }
                    else 
                    {
                        lRet = ERROR_MORE_DATA;
                    }
                }

                if (lpcbData)
                {
                    *lpcbData = vvalue->cbData;
                }
            }
        }
        else if (key && vkey && vvalue &&
            (vvalue->cbData == 0))
        {
            bDataPresent = FALSE;
            lRet = ERROR_SUCCESS;
        }
        else
        {
            // Save the size of the data buffer.
            if (lpcbData)
            {
                cbData = *lpcbData;
            }

            //
            // Get the key normally as if it weren't virtual at all
            //

            lRet = ORIGINAL_API(RegQueryValueExW)(
                hKey, 
                lpValueName, 
                NULL, 
                lpType, 
                lpData, 
                lpcbData);

            //
            // Some apps store bogus data beyond the end of the string.
            // Attempt to fix.
            //

            // Only try this if it's a string.
            if (lRet == ERROR_MORE_DATA && (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ))
            {
                //
                // Create a buffer large enough to hold the data
                // We read from lpcbData here, but this should be ok,
                // since RegQueryValueEx shouldn't return ERROR_MORE_DATA
                // if lpcbData is NULL.
                //
                lpBuffer = (WCHAR*)malloc(*lpcbData);
                if (lpBuffer)
                {
                    // Requery with new buffer.
                    lRet = ORIGINAL_API(RegQueryValueExW)(
                        hKey, 
                        lpValueName, 
                        NULL, 
                        lpType, 
                        (BYTE*)lpBuffer, 
                        lpcbData);

                    if (lRet == ERROR_SUCCESS)
                    {
                        dwStringSize = wcslen(lpBuffer)*sizeof(WCHAR) + sizeof(WCHAR);
                        // If size of dest buffer can hold the string . . .
                        if (cbData >= dwStringSize)
                        {
                            DPFN(eDbgLevelInfo, "\tTrimming data beyond end of string in Query for %S", lpValueName);

                            // Copy the data to the caller's buffer,                             
                            CopyMemory(lpData, lpBuffer, dwStringSize);

                            *lpcbData = dwStringSize;
                        }
                        else
                        {
                            // Set *lpcbData to the correct size, and return more data error
                            *lpcbData = dwStringSize;

                            lRet = ERROR_MORE_DATA;
                        }
                    }                                        

                    free(lpBuffer);
                }
            }

            //
            // Here's another hack for us: if the value is NULL or an empty string
            // Win9x defers to QueryValue...
            //

            if (g_bWin9x && (lRet == ERROR_FILE_NOT_FOUND) && 
                (!lpValueName || !lpValueName[0]))
            {
                lRet = ORIGINAL_API(RegQueryValueW)(
                    hKey,
                    NULL,
                    (LPWSTR)lpData,
                    (PLONG)lpcbData);

                if (SUCCESS(lRet))
                {
                    *lpType = REG_SZ;
                }
            }
        }

        DPFN( ELEVEL(lRet), "%08lx=QueryValueW(Key=%04lx)", 
            lRet,
            hKey);
    
        if (key)
        {
            DPFN( ELEVEL(lRet), "    Path=%S\\%S", key->wzPath, lpValueName);
        }
        else
        {
            DPFN( ELEVEL(lRet), "    Value=%S", lpValueName);
        }
        
        if (SUCCESS(lRet) && 
            ((*lpType == REG_SZ) || 
             (*lpType == REG_EXPAND_SZ))&&
             (bDataPresent == TRUE))
        {
            DPFN( eDbgLevelInfo, "    Result=%S", lpData);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in QueryValueW");
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumKeyA
    Call out to EnumKeyW and convert the name back to ANSI. Note we pass the
    size given to us (in lpcbName) down to EnumKeyW in case the lpName buffer
    is too small.

    Algoritm:
        1. EnumKeyW with a large buffer
        2. Convert the key back to ansi if it succeeds

 Arguments:

    IN hKey         - Handle to open key 
    IN dwIndex      - Index to enumerate
    OUT lpName      - Name of subkey
    IN OUT lpcbName - Size of name buffer

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::EnumKeyA(
    IN HKEY hKey,          
    IN DWORD dwIndex,      
    OUT LPSTR lpName,      
    OUT LPDWORD lpcbName
    )
{
    LONG lRet = ERROR_NO_MORE_ITEMS;
    WCHAR wKey[MAX_PATH + 1];
    DWORD dwcbName = MAX_PATH + 1;

    __try
    {
        lRet = EnumKeyW(hKey, dwIndex, (LPWSTR)wKey, &dwcbName);

        if (SUCCESS(lRet))
        {
            DWORD dwByte = WideCharToMultiByte(
                CP_ACP, 
                0, 
                (LPWSTR)wKey, 
                dwcbName, 
                (LPSTR)lpName, 
                *lpcbName, 
                0, 
                0);
            
            lpName[dwByte] = '\0'; 
            *lpcbName = dwByte;
            if (!dwByte)
            {
                lRet = GetLastError();
                
                // Generate a registry error code
                if (lRet == ERROR_INSUFFICIENT_BUFFER)
                {
                    lRet = ERROR_MORE_DATA;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumKeyW. 
    
    Algorithm:
        1. Build enumeration list, if necessary.
        2. Iterate through enumeration list until index is found.
    
 Arguments:

    IN hKey      - Handle to open key 
    IN dwIndex   - Index to enumerate
    OUT lpName   - Name of subkey
    OUT lpcbName - Size of name buffer

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::EnumKeyW(
    HKEY hKey,          
    DWORD dwIndex,      
    LPWSTR lpName,      
    LPDWORD lpcbName
    )
{
    LONG lRet = ERROR_BAD_ARGUMENTS;
    OPENKEY *key;
    ENUMENTRY *enumkey;
    DWORD i;

    __try
    {
        key = FindOpenKey(hKey);
        if (key)
        {
            if (key->enumKeys == NULL)
            {
                key->BuildEnumList();
            }

            i = 0;
            enumkey = key->enumKeys;
            while (enumkey)
            {
                if (dwIndex == i)
                {
                    DWORD len = wcslen(enumkey->wzName);

                    if (*lpcbName > len)
                    {
                       HRESULT hr;
                       hr = StringCchCopyW(lpName, *lpcbName, enumkey->wzName);
                       if (FAILED(hr))
                       {
                          lRet = ERROR_MORE_DATA;
                       }
                       else
                       {
                          *lpcbName = len;
                          lRet = ERROR_SUCCESS;
                       }
                    }
                    else
                    {
                        lRet = ERROR_MORE_DATA;
                    }

                    break;
                }

                i++;
                enumkey = enumkey->next;
            }

            // No key found for index
            if (enumkey == NULL)
            {
                lRet = ERROR_NO_MORE_ITEMS;
            }    
        }
        else
        {
            lRet = ORIGINAL_API(RegEnumKeyExW)(
                hKey,
                dwIndex,
                lpName,
                lpcbName,
                0,
                0,
                0,
                0);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    DPFN( ELEVEL(lRet), "%08lx=EnumKeyW(hKey=%04lx,dwIndex=%d)", 
        lRet,
        hKey, 
        dwIndex);
    
    if (SUCCESS(lRet))
    {
        DPFN( eDbgLevelInfo, "    Result=%S", lpName);
    }
    
    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumValueA. Thunks to QueryValueW.
    This function calls QueryValueA to get the data 
    out of the value, so most error handling is done by QueryValueA.

 Arguments:

    IN hKey              - Handle to open key 
    IN dwIndex           - Index of value to enumerate      
    IN OUT lpValueName   - Value name buffer
    IN OUT lpcbValueName - Sizeof value name buffer
    IN OUT lpType        - Type of data, eg: REG_SZ
    IN OUT lpData        - Buffer for queries data
    IN OUT lpcbData      - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/
 
LONG 
CVirtualRegistry::EnumValueA(
    IN HKEY hKey,          
    IN DWORD dwIndex,      
    IN OUT LPSTR lpValueName,      
    IN OUT LPDWORD lpcbValueName,
    IN OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    LONG lRet;
    WCHAR wzValueName[MAX_PATH];
    DWORD dwValNameSize;
    

    __try
    {
        dwValNameSize = MAX_PATH;
        lRet = EnumValueW(hKey, dwIndex, wzValueName, &dwValNameSize, NULL, NULL, NULL);
        if (lRet == ERROR_SUCCESS)
        {
            dwValNameSize = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                wzValueName,
                                -1,
                                lpValueName,
                                *lpcbValueName,
                                NULL,
                                NULL);
            if (dwValNameSize != 0)
            {
                // Just do a normal query value for the remaining parameters.
                lRet = QueryValueA(hKey, lpValueName, lpType, lpData, lpcbData);
            }
            else
            {
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {
                    lRet = ERROR_MORE_DATA;
                    *lpcbValueName = WideCharToMultiByte(
                                        CP_ACP,
                                        0,
                                        wzValueName,
                                        -1,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);
                }
                else
                {
                    lRet = GetLastError();
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegEnumValueW. This function calls QueryValueW to get the data 
    out of the value, so most error handling is done by QueryValueW.

    Algorithm:
        1. Check if key has virtual values, if not default to RegEnumValueW.
        2. Build enumeration list, if necessary.
        3. Iterate through enumeration list until index is found.

 Arguments:

    IN hKey              - Handle to open key 
    IN dwIndex           - Index of value to enumerate      
    IN OUT lpValueName   - Value name buffer
    IN OUT lpcbValueName - Sizeof value name buffer
    IN OUT lpType        - Type of data, eg: REG_SZ
    IN OUT lpData        - Buffer for queries data
    IN OUT lpcbData      - Size of input buffer/size of returned data

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/
 
LONG 
CVirtualRegistry::EnumValueW(
    IN HKEY hKey,          
    IN DWORD dwIndex,      
    IN OUT LPWSTR lpValueName,      
    IN OUT LPDWORD lpcbValueName,
    IN OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    LONG lRet;
    OPENKEY *key;
    ENUMENTRY *enumval;
    
    // Check if it has virtual values . . .
    key = FindOpenKey(hKey);
    if (key && key->vkey && key->vkey->values)
    {
        DWORD i = 0;
        if (key->enumValues == NULL)
        {
            key->BuildEnumList();
        }

        enumval = key->enumValues;

        lRet = ERROR_NO_MORE_ITEMS;

        while (enumval)
        {
            if (dwIndex == i)
            {
                DWORD len = wcslen(enumval->wzName);

                if (*lpcbValueName > len)
                {
                   // Copy the name and query the data
                   HRESULT hr = StringCchCopyW(lpValueName, *lpcbValueName, enumval->wzName);
                   if (FAILED(hr))
                   {
                      lRet = ERROR_MORE_DATA;
                   }
                   else
                   {                  
                       *lpcbValueName = len;
                       lRet = QueryValueW(
                           hKey, 
                           enumval->wzName, 
                           lpType, 
                           lpData, 
                           lpcbData);
                   }
                }
                else
                {
                    // The buffer given for name wasn't big enough
                    lRet = ERROR_MORE_DATA;
                }
                
                break;
            }
            i++;
            enumval = enumval->next;
        }
    }
    // No virtual values, fall through to original API.
    else
    {
        lRet = ORIGINAL_API(RegEnumValueW)(
            hKey,
            dwIndex,
            lpValueName,
            lpcbValueName,
            0,
            lpType,
            lpData,
            lpcbData);
    }

    DPFN( ELEVEL(lRet), "%08lx=EnumValueW(hKey=%04lx,dwIndex=%d)", 
        lRet,
        hKey, 
        dwIndex);

    if (SUCCESS(lRet))
    {
        DPFN( eDbgLevelInfo, "    Result=%S", lpValueName);
    }
    
    return lRet;
}

/*++

 Function Description:

    Wrapper for RegQueryInfoKeyA. 
    We don't need to worry about the conversion of ansi->unicode in the sizes 
    of values and keys because they are defined as string lengths.
    
    Algorithm:
        1. Convert the class string to unicode
        2. Call QueryInfoW


 Arguments:

    IN hKey                     - handle to key to query
    OUT lpClass                 - address of buffer for class string
    OUT lpcbClass               - address of size of class string buffer
    OUT lpReserved              - reserved
    OUT lpcSubKeys              - address of buffer for number of subkeys
    OUT lpcbMaxSubKeyLen        - address of buffer for longest subkey  
    OUT lpcbMaxClassLen         - address of buffer for longest class string length
    OUT lpcValues               - address of buffer for number of value entries
    OUT lpcbMaxValueNameLen     - address of buffer for longest value name length
    OUT lpcbMaxValueLen         - address of buffer for longest value data length
    OUT lpcbSecurityDescriptor  - address of buffer for security descriptor length
    OUT lpftLastWriteTime       - address of buffer for last write time

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::QueryInfoA(
    IN HKEY hKey,                
    OUT LPSTR lpClass,           
    OUT LPDWORD lpcbClass,        
    OUT LPDWORD lpReserved,       
    OUT LPDWORD lpcSubKeys,       
    OUT LPDWORD lpcbMaxSubKeyLen, 
    OUT LPDWORD lpcbMaxClassLen,  
    OUT LPDWORD lpcValues,        
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,  
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime   
    )
{
    LONG lRet;

    if (lpClass && !lpcbClass)
    {
        LOGN( eDbgLevelError, "[QueryInfoA] NULL passed for lpClass but not lpcbClass. Fixing.");
        lpcbClass = NULL;
    }
    
    if (lpClass && lpcbClass)
    {
        WCHAR wClass[MAX_PATH];
        DWORD dwSize;
        
        if (MultiByteToWideChar(
            CP_ACP, 
            0, 
            lpClass, 
            -1, 
            (LPWSTR)wClass, 
            MAX_PATH) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }

        dwSize = *lpcbClass * 2;

        lRet = QueryInfoW(
            hKey, 
            wClass, 
            &dwSize, 
            lpReserved,       
            lpcSubKeys,       
            lpcbMaxSubKeyLen, 
            lpcbMaxClassLen,  
            lpcValues,        
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,  
            lpcbSecurityDescriptor,
            lpftLastWriteTime);


        if (SUCCESS(lRet))
        {
            if (WideCharToMultiByte(
                CP_ACP, 
                0, 
                (LPWSTR)wClass, 
                dwSize, 
                (LPSTR)lpClass, 
                *lpcbClass, 
                0, 
                0) == 0)
            {
               return ERROR_INVALID_PARAMETER;
            }
        }

        *lpcbClass = dwSize / 2;
    }
    else
    {
        lRet = QueryInfoW(
            hKey, 
            NULL, 
            NULL, 
            lpReserved,       
            lpcSubKeys,       
            lpcbMaxSubKeyLen, 
            lpcbMaxClassLen,  
            lpcValues,        
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,  
            lpcbSecurityDescriptor,
            lpftLastWriteTime);
    }

    return lRet;    
}

/*++

 Function Description:

    Wrapper for RegQueryInfoKeyW. 
    
    Algorithm:
        1. Revert to the old API if the key isn't virtual
        2. Calculate all the virtual key and value name lengths by going through
           them individually.
        3. Add all non-virtual key and value's that don't have overriding virtual's.

 Arguments:

    IN hKey                    - handle to key to query
    OUT lpClass                - address of buffer for class string
    OUT lpcbClass              - address of size of class string buffer
    OUT lpReserved             - reserved
    OUT lpcSubKeys             - address of buffer for number of subkeys
    OUT lpcbMaxSubKeyLen       - address of buffer for longest subkey  
    OUT lpcbMaxClassLen        - address of buffer for longest class string length
    OUT lpcValues              - address of buffer for number of value entries
    OUT lpcbMaxValueNameLen    - address of buffer for longest value name length
    OUT lpcbMaxValueLen        - address of buffer for longest value data length
    OUT lpcbSecurityDescriptor - address of buffer for security descriptor length
    OUT lpftLastWriteTime      - address of buffer for last write time

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created
    08/03/2001 mikrause Added support for counting both virtual & non-virtual keys & values.

--*/

LONG 
CVirtualRegistry::QueryInfoW(
    IN HKEY hKey,                
    OUT LPWSTR lpClass,           
    OUT LPDWORD lpcbClass,        
    OUT LPDWORD lpReserved,       
    OUT LPDWORD lpcSubKeys,       
    OUT LPDWORD lpcbMaxSubKeyLen, 
    OUT LPDWORD lpcbMaxClassLen,  
    OUT LPDWORD lpcValues,        
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,  
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime   
    )
{
    LONG lRet;
    OPENKEY *key;

    DWORD cbData = 0;
    ENUMENTRY *enumkey;
    ENUMENTRY *enumval;
    
    if (lpClass && !lpcbClass)
    {
        LOGN( eDbgLevelError, "[QueryInfoW] NULL passed for lpClass but not lpcbClass. Fixing.");
        lpcbClass = NULL;
    }
     
    key = FindOpenKey(hKey);
    if (key)
    {
        if (lpClass)
        {
           lpClass[0] = L'\0';            
        }

        if (lpcbClass)
        {
            *lpcbClass = 0;
        }

        if (lpcbMaxClassLen)
        {
            *lpcbMaxClassLen = 0;
        }

        if (lpReserved)
        {
            *lpReserved = 0;
        }

        if (lpcSubKeys || lpcbMaxSubKeyLen)
        {   
            DWORD i = 0;
            DWORD len = 0;

            // Count virtual keys.
            if (!key->enumKeys)
            {
                key->BuildEnumList();
            }

            enumkey = key->enumKeys;
            while (enumkey)
            {
                i++;
                len = max(len, wcslen(enumkey->wzName));
                enumkey = enumkey->next;
            }

            if (lpcSubKeys)
            {
                *lpcSubKeys = i;
            }
            if (lpcbMaxSubKeyLen)
            {
                *lpcbMaxSubKeyLen = len;
            }
        }

        if (lpcValues || lpcbMaxValueNameLen || lpcbMaxValueLen)
        {
            // Check if this key has virtual values or is virtual.
            if (key->bVirtual || (key->vkey && key->vkey->values))
            {
                DWORD i = 0; 
                DWORD lenA = 0, lenB = 0;

                if (key->enumValues == NULL)
                {
                    key->BuildEnumList();
                }

                enumval = key->enumValues;
                while (enumval)
                {
                    i++;
                    QueryValueW(key->hkOpen, enumval->wzName, NULL, NULL, &cbData);

                    lenA = max(lenA, cbData);
                    lenB = max(lenB, wcslen(enumval->wzName));
                    enumval = enumval->next;
                }

                if (lpcValues)
                {
                    *lpcValues = i;
                }
                if (lpcbMaxValueLen)
                {
                    *lpcbMaxValueLen = lenA;
                }
                if (lpcbMaxValueNameLen)
                {
                    *lpcbMaxValueNameLen = lenB;
                }
            }
            // No virtual values, do a normal query.
            else
            {
                lRet = ORIGINAL_API(RegQueryInfoKeyW)(
                    key->hkOpen,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    lpcValues,
                    lpcbMaxValueNameLen,
                    lpcbMaxValueLen,
                    NULL,
                    lpftLastWriteTime);

            }
        }
        if (lpcbSecurityDescriptor)
        {
            *lpcbSecurityDescriptor = NULL;
        }

        lRet = ERROR_SUCCESS;
    }
    else
    {
        lRet = ORIGINAL_API(RegQueryInfoKeyW)(
                    hKey, 
                    lpClass, 
                    lpcbClass, 
                    lpReserved,       
                    lpcSubKeys,       
                    lpcbMaxSubKeyLen, 
                    lpcbMaxClassLen,  
                    lpcValues,        
                    lpcbMaxValueNameLen,
                    lpcbMaxValueLen,  
                    lpcbSecurityDescriptor,
                    lpftLastWriteTime);
    }

    DPFN( ELEVEL(lRet), "%08lx=QueryInfoW(hKey=%04lx)", 
        lRet,
        hKey);

    if (key)
    {
        DPFN( ELEVEL(lRet), "    Path=%S", key->wzPath);
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegSetValueA.

    Algorithm:
    1. Convert value name and data (if string) to Unicode.
    2. Call SetValueW

 Arguments:

    hKey - Key to set value in.
    lpValueName - Name of value to set.
    dwType - Type of value (string, DWORD, etc.)
    lpData - Buffer containing data to write.
    cbData - Size of lpData in bytes.

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG
CVirtualRegistry::SetValueA(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )
{
    LONG lRet;
    DWORD dwSize;
    WCHAR* wszValName = NULL;
    BYTE* lpExpandedData = (BYTE*)lpData;

    if (lpValueName != NULL)
    {
        dwSize = (DWORD)(lstrlenA(lpValueName) + 1);
        dwSize *= sizeof(WCHAR);
        wszValName = (WCHAR*)malloc(dwSize);
        if (wszValName == NULL)
        {
            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (MultiByteToWideChar(
            CP_ACP, 
            0, 
            lpValueName, 
            -1, 
            (LPWSTR)wszValName, 
            dwSize/sizeof(WCHAR)) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }
    }

    dwSize = cbData;

    //
    // Expand text buffers
    //
    if (lpData && (dwType == REG_SZ || dwType == REG_EXPAND_SZ || dwType == REG_MULTI_SZ))
    {
        if ((dwType != REG_MULTI_SZ) && g_bWin9x)
        {
            dwSize = (DWORD)(lstrlenA((char*)lpData) + 1);
        }

        lpExpandedData = (BYTE*) malloc(dwSize * sizeof(WCHAR));
        if (lpExpandedData == NULL)
        {
            if (wszValName)
            {
                free(wszValName);
            }

            DPFN( eDbgLevelError, szOutOfMemory);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if (MultiByteToWideChar(
            CP_ACP, 
            0, 
            (LPCSTR)lpData, 
            dwSize, 
            (LPWSTR)lpExpandedData, 
            dwSize) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }
        
        dwSize = dwSize * sizeof(WCHAR);
    }

    lRet = SetValueW(hKey, wszValName, dwType, lpExpandedData, dwSize);

    if (lpExpandedData != lpData)
    {
        free(lpExpandedData);
    }

    if (wszValName)
    {
        free(wszValName);
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegSetValueW.
    Also protects for non-zero buffer length with zero buffer AV.

    Algorithm:
    1. If non-protected key, write to registry using RegSetValueW

 Arguments:

    hKey - Key to set value in.
    lpValueName - Name of value to set.
    dwType - Type of value (string, DWORD, etc.)
    lpData - Buffer containing data to write.
    cbData - Size of lpData in bytes.

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG
CVirtualRegistry::SetValueW(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )
{
    LONG lRet;

    // Just a paranoid sanity check 
    if (!hKey)
    {
        DPFN( eDbgLevelError, "NULL handle passed to SetValueW");
        return ERROR_INVALID_HANDLE;
    }
    __try
    {
        lRet = ERROR_FILE_NOT_FOUND;

        // To duplicate Win95/win98 behavior automatically override
        // the cbData with the actual length of the lpData for REG_SZ.
        if (g_bWin9x && lpData && 
            ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ)))
        {
            cbData = (wcslen((WCHAR *)lpData)+1)*sizeof(WCHAR);
        }

        VIRTUALKEY *vkey;
        VIRTUALVAL *vvalue;
        OPENKEY* key = FindOpenKey(hKey);
        if (key)
        {
            // Check if we should execute a custom action.
            vkey = key->vkey;
            vvalue = vkey ? vkey->FindValue(lpValueName) : NULL;
            if (vkey && vvalue &&
                vvalue->pfnSetValue)
            {
                lRet = vvalue->pfnSetValue(key, vkey, vvalue,
                        dwType, lpData,cbData);
            }
            else
            {
                // No custom action, just set value as normal.
                lRet = ORIGINAL_API(RegSetValueExW)(
                    hKey,
                    lpValueName,
                    0,
                    dwType,
                    lpData,
                    cbData);
            }
            // Possible change in enumeration data, flush lists.
            if (lRet == ERROR_SUCCESS)
            {
                key->FlushEnumList();
            }
        }
        // No key, fall through to original API
        else
        {
            lRet = ORIGINAL_API(RegSetValueExW)(
                    hKey,
                    lpValueName,
                    0,
                    dwType,
                    lpData,
                    cbData);
        }
                    
        DPFN( ELEVEL(lRet), "%08lx=SetValueW(Key=%04lx)", 
            lRet,
            hKey);

        if (key)
        {
            DPFN( ELEVEL(lRet), "    Path=%S\\%S", key->wzPath, lpValueName);
        }
        else
        {
            DPFN( ELEVEL(lRet), "    Value=%S", lpValueName);
        }

        if (SUCCESS(lRet) && 
            ((dwType == REG_SZ) || 
            (dwType == REG_EXPAND_SZ)))
        {
            DPFN( eDbgLevelInfo, "    Result=%S", lpData);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "Exception occurred in SetValueW");
        lRet = ERROR_BAD_ARGUMENTS;    
    }

    return lRet;
}

/*++

 Function Description:

    Wrapper for RegDeleteKeyA.

    Algorithm:
    1. Convert key name to Unicode.
    2. Call DeleteKeyW

 Arguments:

    hKey - Key that contains subkey to delete.    
    lpSubKey - Key name to delete.

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG
CVirtualRegistry::DeleteKeyA(
    IN HKEY hKey,
    IN LPCSTR lpSubKey
    )
{
    LONG lRet;
    DWORD dwSize;
    WCHAR*  wszSubKey = NULL;

    dwSize = (DWORD)(lstrlenA(lpSubKey) + 1);
    dwSize *= sizeof(WCHAR);
    wszSubKey = (WCHAR*)malloc(dwSize);
    if (wszSubKey == NULL)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (MultiByteToWideChar(
        CP_ACP, 
        0, 
        lpSubKey, 
        -1, 
        (LPWSTR)wszSubKey, 
        dwSize/sizeof(WCHAR)) == 0)
    {
       return ERROR_INVALID_PARAMETER;
    }

    lRet = DeleteKeyW(hKey, wszSubKey);

    free(wszSubKey);

    return lRet;
}

/*++

 Function Description:

    Wrapper for DeleteKeyW.

    Algorithm:
    1. If key is not protected, delete key.
    2. If in 9x compat mode, recursively delete all subkeys.

 Arguments:

    hKey - Key to that contains subkey to delete.
    lpSubKey - Name of key to delete    

 Return Value:

    ERROR_SUCCESS on success, failure code otherwise.

 History:

    08/07/2001 mikrause  Created

--*/

LONG 
CVirtualRegistry::DeleteKeyW(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )
{
    LONG hRet;
    OPENKEY* key = FindOpenKey(hKey);
    LPWSTR wzPath = NULL;
    BOOL bProtected;

    // Key not found, assume it's a root key.
    if (!key)
    {
        DPFN( eDbgLevelInfo, "Key not found!");
        wzPath = MakePath(hKey, 0, lpSubKey);
        if (!wzPath)
        {
           DPFN(eDbgLevelError, szOutOfMemory);
           return ERROR_NOT_ENOUGH_MEMORY;
        }
        DPFN( eDbgLevelInfo, "Using path %S", wzPath);
    }
    else if (lpSubKey)
    {   
        DWORD dwSize = wcslen(key->wzPath) + wcslen(L"\\") + wcslen(lpSubKey) + 1;
        wzPath = (LPWSTR) malloc(dwSize * sizeof(WCHAR));
        if (!wzPath)
        {
           DPFN(eDbgLevelError, szOutOfMemory);
           return ERROR_NOT_ENOUGH_MEMORY;
        }
        ZeroMemory(wzPath, dwSize);

        StringCchCopyW(wzPath, dwSize, key->wzPath);
        StringCchCatW(wzPath, dwSize, L"\\");
        StringCchCatW(wzPath, dwSize, lpSubKey);
    }

    bProtected = (key && CheckProtected(key->wzPath))
        || (wzPath && CheckProtected(wzPath));
    if (!bProtected)
    {
        if (g_bWin9x)
        {
            //
            // Find out whether hKey has any subkeys under it or not.
            // If not, then proceed as normal.
            // If yes, recursively delete the subkeys under it
            // Then proceed as normal.
            //

            DWORD cSize = 0;
            WCHAR lpSubKeyName[MAX_PATH];
            HKEY hSubKey;

            DPFN( eDbgLevelInfo, "RegDeleteKeyW called with hKey: %x, SubKey: %S", hKey, lpSubKey);

            hRet = ORIGINAL_API(RegOpenKeyExW)(
                    hKey,
                    lpSubKey,
                    0,
                    KEY_ENUMERATE_SUB_KEYS,
                    &hSubKey);
            
            if (SUCCESS(hRet))
            {
                for (;;)
                {
                    cSize = MAX_PATH;
            
                    hRet = ORIGINAL_API(RegEnumKeyExW)(
                        hSubKey,
                        0,              
                        lpSubKeyName,
                        &cSize,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

                    if (SUCCESS(hRet))
                    {                    
                        LOGN( eDbgLevelInfo, 
                            "[DeleteKeyW] Deleting subkey %S for key %S.",
                            lpSubKeyName,
                            lpSubKey);         
                     
                        hRet = DeleteKeyW(
                                hSubKey,
                                lpSubKeyName);
                    
                        if (SUCCESS(hRet))
                        {
                            LOGN( eDbgLevelInfo, "[DeleteKeyW] subkey %S was deleted.",lpSubKeyName);            
                        }
                        else
                        {
                            LOGN( eDbgLevelInfo, "[DeleteKeyW] subkey %S was not deleted.",lpSubKeyName);            
                            break;
                        }                        
                    }
                    else
                    {
                        DPFN( eDbgLevelInfo, "[DeleteKeyW] No more subkey under key %S.",lpSubKey);
                        break;
                    }
                } 

                ORIGINAL_API(RegCloseKey)(hSubKey);
            }
        }

        DPFN( eDbgLevelInfo, "[RegDeleteKeyW] Deleting subkey %S.",lpSubKey);
        
        hRet = ORIGINAL_API(RegDeleteKeyW)(
            hKey,
            lpSubKey);     
    }
    else
    {
        // Protected, just say it succeeded
        hRet = ERROR_SUCCESS;
    }

    if (wzPath) 
    {
        free(wzPath);
    }

    // Possible change in enumeration data, flush lists.
    FlushEnumLists();

    return hRet;
}

/*++

 Function Description:

    Wrapper for RegCloseKey. Note that we make sure we know about the key before closing it.

    Algorithm:
        1. Run the list of open keys and free if found
        2. Close the key 

 Arguments:

    IN hKey - Handle to open key to close

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    01/06/2000 linstev  Created

--*/

LONG 
CVirtualRegistry::CloseKey(
    IN HKEY hKey
    )
{
    OPENKEY *key = OpenKeys, *last = NULL;
    LONG lRet;

    __try
    {
        lRet = ERROR_INVALID_HANDLE;

        while (key)
        {
            if (key->hkOpen == hKey)
            {
                if (last)
                {
                    last->next = key->next;
                }
                else
                {
                    OpenKeys = key->next;
                }
        
                lRet = ORIGINAL_API(RegCloseKey)(hKey);
            
                free(key->wzPath);
                free(key);
                break;
            }

            last = key;
            key = key->next;
        }

        if (key == NULL)
        {
           RegCloseKey(hKey);
        }

        DPFN( ELEVEL(lRet), "%08lx=CloseKey(Key=%04lx)", lRet, hKey);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lRet = ERROR_INVALID_HANDLE;
    }

    return lRet;
}


/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyA)(
    HKEY hKey,         
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult, 
        0,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE, 
        MAXIMUM_ALLOWED,
        NULL,
        phkResult, 
        0,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY hKey,                
    LPCSTR lpSubKey,         
    DWORD /* Reserved */,           
    LPSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY hKey,                
    LPCWSTR lpSubKey,         
    DWORD /* Reserved */,
    LPWSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(hKey, lpSubKey, 0, 0, MAXIMUM_ALLOWED, NULL, phkResult, 0, FALSE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(hKey, lpSubKey, 0, 0, MAXIMUM_ALLOWED, NULL, phkResult, 0, FALSE);
}

/*++

 Pass through to virtual registry to handle call.

--*/


LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD /* ulOptions */,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyA(hKey, lpSubKey, 0, 0, samDesired, NULL, phkResult, 0, FALSE);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD /* ulOptions */,
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(hKey, lpSubKey, 0, 0, samDesired, NULL, phkResult, 0, FALSE);
}

/*++

 Not yet implemented

--*/

LONG 
APIHOOK(RegQueryValueA)(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPSTR  lpData,
    PLONG lpcbData
    )
{
    CRegLock Lock;

    return ORIGINAL_API(RegQueryValueA)(
        hKey, 
        lpSubKey, 
        lpData, 
        lpcbData);
}

/*++

 Not yet implemented

--*/

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPWSTR  lpData,
    PLONG lpcbData
    )
{
    CRegLock Lock;

    return ORIGINAL_API(RegQueryValueW)(
        hKey, 
        lpSubKey, 
        lpData, 
        lpcbData);
}

/*++

 Pass through to virtual registry to handle call.
 
--*/

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPSTR   lpValueName,
    LPDWORD /* lpReserved */,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRegLock Lock;

    return VRegistry.QueryValueA(hKey, lpValueName, lpType, lpData, lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPWSTR  lpValueName,
    LPDWORD /* lpReserved */,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRegLock Lock;

    return VRegistry.QueryValueW(hKey, lpValueName, lpType, lpData, lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegCloseKey)(HKEY hKey)
{
    CRegLock Lock;

    return VRegistry.CloseKey(hKey);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumValueA)(
    HKEY hKey,              
    DWORD dwIndex,          
    LPSTR lpValueName,     
    LPDWORD lpcbValueName,  
    LPDWORD /* lpReserved */, 
    LPDWORD lpType,         
    LPBYTE lpData,          
    LPDWORD lpcbData        
    )
{
    CRegLock Lock;

    return VRegistry.EnumValueA(
        hKey, 
        dwIndex, 
        lpValueName, 
        lpcbValueName, 
        lpType, 
        lpData, 
        lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumValueW)(
    HKEY hKey,              
    DWORD dwIndex,          
    LPWSTR lpValueName,     
    LPDWORD lpcbValueName,  
    LPDWORD /* lpReserved */,
    LPDWORD lpType,         
    LPBYTE lpData,          
    LPDWORD lpcbData        
    )
{
    CRegLock Lock;

    return VRegistry.EnumValueW(
        hKey, 
        dwIndex, 
        lpValueName, 
        lpcbValueName, 
        lpType, 
        lpData, 
        lpcbData);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,          
    DWORD dwIndex,      
    LPSTR lpName,      
    LPDWORD lpcbName,   
    LPDWORD /* lpReserved */, 
    LPSTR /* lpClass */,     
    LPDWORD /* lpcbClass */,  
    PFILETIME /* lpftLastWriteTime */
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyA(hKey, dwIndex, lpName, lpcbName);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,          
    DWORD dwIndex,      
    LPWSTR lpName,      
    LPDWORD lpcbName,   
    LPDWORD /* lpReserved */, 
    LPWSTR /* lpClass */,
    LPDWORD /* lpcbClass */,
    PFILETIME /* lpftLastWriteTime */ 
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyW(hKey, dwIndex, lpName, lpcbName);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegEnumKeyA)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyA(hKey, dwIndex, lpName, &cbName);
}

/*++

 Calls down to RegEnumKeyExW

--*/

LONG 
APIHOOK(RegEnumKeyW)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    CRegLock Lock;

    return VRegistry.EnumKeyW(hKey, dwIndex, lpName, &cbName);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegQueryInfoKeyW)(
    HKEY hKey,                
    LPWSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRegLock Lock;

    return VRegistry.QueryInfoW(
        hKey,
        lpClass,           
        lpcbClass,        
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG 
APIHOOK(RegQueryInfoKeyA)(
    HKEY hKey,                
    LPSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,        
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRegLock Lock;

    return VRegistry.QueryInfoA(
        hKey,
        lpClass,           
        lpcbClass,        
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,  
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegSetValueExA)(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD /* Reserved */, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    LONG lRet = 0;

    if (!lpData && cbData)
    {
        lRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CRegLock lock;
        lRet = VRegistry.SetValueA(hKey, lpSubKey, dwType, lpData, cbData);
    }

    return lRet;
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegSetValueExW)(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD /* Reserved */, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    LONG lRet = 0;

    if (!lpData && cbData)
    {
        lRet = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CRegLock lock;
        lRet = VRegistry.SetValueW(hKey, lpSubKey, dwType, lpData, cbData);
    }

    return lRet;
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    CRegLock Lock;

    return VRegistry.DeleteKeyA(hKey, lpSubKey);
}

/*++

 Pass through to virtual registry to handle call.

--*/

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    CRegLock Lock;

    return VRegistry.DeleteKeyW(hKey, lpSubKey);
}

LONG 
APIHOOK(RegConnectRegistryW)(
    LPCWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    )
{
    CRegLock Lock;

    return VRegistry.OpenKeyW(
        hKey, 
        NULL, 
        0, 
        0, 
        MAXIMUM_ALLOWED,
        NULL,
        phkResult, 
        0, 
        FALSE, 
        TRUE, 
        lpMachineName);
}

LONG 
APIHOOK(RegConnectRegistryA)(
    LPCSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    )
{
    WCHAR wMachineName[MAX_COMPUTERNAME_LENGTH + 1] = L"";

    if (lpMachineName)
    {
        if (MultiByteToWideChar(
            CP_ACP,
            0, 
            lpMachineName, 
            -1, 
            wMachineName, 
            MAX_COMPUTERNAME_LENGTH + 1) == 0)
        {
           return ERROR_INVALID_PARAMETER;
        }
    }

    return APIHOOK(RegConnectRegistryW)(wMachineName, hKey, phkResult);
}

/*++

 Parse the command line for fixes:

    FIXA(param); FIXB(param); FIXC(param) ...

    param is optional, and can be omitted (along with parenthesis's)

--*/

BOOL
ParseCommandLineA(
    LPCSTR lpCommandLine
    )
{
    const char szDefault[] = "Win9x";

    // Add all the defaults if no command line is specified
    if (!lpCommandLine || (lpCommandLine[0] == '\0'))
    {
        // Default to win9x API emulation
        g_bWin9x = TRUE;
        lpCommandLine = szDefault;
    }

    CSTRING_TRY
    {    
       CStringToken csCommandLine(lpCommandLine, " ,\t;");
       CString csTok;
       int nLeftParam, nRightParam;
       CString csParam;
   
   
       VENTRY *ventry;
   
       //
       // Run the string, looking for fix names
       //
       
       DPFN( eDbgLevelInfo, "----------------------------------");
       DPFN( eDbgLevelInfo, "         Virtual registry         ");
       DPFN( eDbgLevelInfo, "----------------------------------");
       DPFN( eDbgLevelInfo, "Adding command line:");
   
       while (csCommandLine.GetToken(csTok))
       {
           PURPOSE ePurpose;
   
           // Get the parameter
           nLeftParam = csTok.Find(L'(');
           nRightParam = csTok.Find(L')');
           if (nLeftParam != -1 &&
               nRightParam != -1)
           {
               if ( (nLeftParam + 1) < (nRightParam - 1))
               {
                   csParam = csTok.Mid(nLeftParam+1, nRightParam-nLeftParam-1);
               }
   
               // Strip off the () from the token.
               csTok.Truncate(nLeftParam);
           }
           else
           {
               csParam = L"";
           }
   
           if (csTok.CompareNoCase(L"Win9x") == 0)
           {
               // Turn on all win9x fixes
               ePurpose = eWin9x;
               g_bWin9x = TRUE;
           }
           else if (csTok.CompareNoCase(L"WinNT") == 0)
           {
               // Turn on all NT fixes
               ePurpose = eWinNT;
               g_bWin9x = FALSE;
           }
           else if (csTok.CompareNoCase(L"Win2K") == 0) 
           {
               // Turn on all Win2K fixes
               ePurpose = eWin2K;
               g_bWin9x = FALSE;
           }
           else if (csTok.CompareNoCase(L"WinXP") == 0) 
           {
               // Turn on all Win2K fixes
               ePurpose = eWinXP;
               g_bWin9x = FALSE;
           }
           else
           {
               // A custom fix
               ePurpose = eCustom;
           }
           
           // Find the specified fix and run it's function
           ventry = g_pVList;
           while (ventry && (ventry->cName[0]))
           {
               if (((ePurpose != eCustom) && (ventry->ePurpose == ePurpose)) ||
                   ((ePurpose == eCustom) && (csTok.CompareNoCase(ventry->cName) == 0)))
               {
                   if (ventry->bShouldCall == FALSE)
                   {
                      ventry->szParam = (char*) malloc(csParam.GetLength() + 1);
                      if (ventry->szParam)
                      {
                         if (SUCCEEDED(StringCchCopyA(ventry->szParam, csParam.GetLength() + 1, csParam.GetAnsi())))
                         {
                            ventry->bShouldCall = TRUE;
                         }
                         else
                         {
                            free(ventry->szParam);
                            ventry->szParam = NULL;
                            return FALSE;
                         }
                      }
                      else
                      {
                         return FALSE;
                      }
                   }                   
               }
               ventry++;
           }
       }
   
       DPFN( eDbgLevelInfo, "----------------------------------");
    }
    CSTRING_CATCH
    {
       DPFN(eDbgLevelError, szOutOfMemory);
       return FALSE;
    }

    return TRUE;
}

/*++

 Initialize all the registry hooks 

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        if (InitializeCriticalSectionAndSpinCount(&csRegCriticalSection, 0x80000000) == FALSE ||
            VRegistry.Init() == FALSE ||
            ParseCommandLineA(COMMAND_LINE) == FALSE)
        {
           DPFN(eDbgLevelError, szOutOfMemory);
           return FALSE;
        }
    }

    // Ignore cleanup because some apps call registry functions during process detach.
    /*
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (g_bInitialized)
        {
            VRegistry.Free();
            
            DeleteCriticalSection(&csRegCriticalSection);
        }

        DeleteCriticalSection(&csRegTestCriticalSection);
        
        return;
    }
    */

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(ADVAPI32.DLL, RegConnectRegistryA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegConnectRegistryW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA);
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

INCLUDES=$(INCLUDES);                       \
         ..;                                \
         $(SHELL_INC_PATH);                 \
         $(BASE_INC_PATH);                  \
         $(WINDOWS_INC_PATH)

TARGETNAME=AcLayers

TARGETTYPE=DYNLINK

SOURCES=..\Layer.rc                                \
        ..\Main.cpp                                \
        ..\AddWritePermissionsToDeviceFiles.cpp    \
        ..\ChangeAuthenticationLevel.cpp           \
        ..\CorrectBitmapHeader.cpp                 \
        ..\CorrectCreateEventName.cpp              \
        ..\CorrectFilePaths.cpp                    \
        ..\CorrectSoundDeviceId.cpp                \
        ..\DirectPlayEnumOrder.cpp                 \
        ..\DuplicateHandleFix.cpp                  \
        ..\EmulateBitmapStride.cpp                 \
        ..\EmulateCDFS.cpp                         \
        ..\EmulateClipboardDIBFormat.cpp           \
        ..\EmulateCreateFileMapping.cpp            \
        ..\EmulateCreateProcess.cpp                \
        ..\EmulateDeleteObject.cpp                 \
        ..\EmulateDirectDrawSync.cpp               \
        ..\EmulateDrawText.cpp                     \
        ..\EmulateEnvironmentBlock.cpp             \
        ..\EmulateFindHandles.cpp                  \
        ..\EmulateGetCommandLine.cpp               \
        ..\EmulateGetDeviceCaps.cpp                \
        ..\EmulateGetDiskFreeSpace.cpp             \
        ..\EmulateGetProfileString.cpp             \
        ..\EmulateHeap.cpp                         \
        ..\EmulateHeap_support.c                   \
        ..\EmulateHeap_heap.c                      \
        ..\EmulateHeap_lmem.c                      \
        ..\EmulateJoystick.cpp                     \
        ..\EmulateMissingEXE.cpp                   \
        ..\EmulatePlaySound.cpp                    \
        ..\EmulatePrinter.cpp                      \
        ..\EmulateSlowCPU.cpp                      \
        ..\EmulateTextColor.cpp                    \
        ..\EmulateToolHelp32.cpp                   \
        ..\EmulateUSER.cpp                         \
        ..\EmulateVerQueryValue.cpp                \
        ..\EmulateWriteFile.cpp                    \
        ..\EnableRestarts.cpp                      \
        ..\FeedbackReport.cpp                      \
        ..\FileVersionInfoLie.cpp                  \
        ..\Force640x480.cpp                        \
        ..\Force8BitColor.cpp                      \
        ..\ForceAnsiGetDisplayNameOf.cpp           \
        ..\ForceCDStop.cpp                         \
        ..\ForceCoInitialize.cpp                   \
        ..\ForceDxSetupSuccess.cpp                 \
        ..\ForceKeepFocus.cpp                      \
        ..\ForceMessageBoxFocus.cpp                \
        ..\ForceShellLinkResolveNoUI.cpp           \
        ..\HandleAPIExceptions.cpp                 \
        ..\HandleRegExpandSzRegistryKeys.cpp       \
        ..\HandleWvsprintfExceptions.cpp           \
        ..\HideDisplayModes.cpp                    \
        ..\IgnoreException_86dis.cpp               \
        ..\IgnoreException.cpp                     \
        ..\IgnoreLoadLibrary.cpp                   \
        ..\IgnoreOleUninitialize.cpp               \
        ..\IgnoreScheduler.cpp                     \
        ..\MapMemoryB0000.cpp                      \
        ..\ProfilesEnvStrings.cpp                  \
        ..\ProfilesGetFolderPath.cpp               \
        ..\ProfilesRegQueryValueEx.cpp             \
        ..\Shrinker.cpp                            \
        ..\SingleProcAffinity.cpp                  \
        ..\SyncSystemAndSystem32.cpp               \
        ..\VRegistry_Custom.cpp                    \
        ..\VRegistry_Worker.cpp                    \
        ..\VRegistry_DSound.cpp                    \
        ..\VRegistry.cpp                           \
        ..\WinXPVersionLie.cpp                     \
        ..\WinXPSP1VersionLie.cpp                  \
        ..\Win2000VersionLie.cpp                   \
        ..\Win2000SP1VersionLie.cpp                \
        ..\Win2000SP2VersionLie.cpp                \
        ..\Win2000SP3VersionLie.cpp                \
        ..\Win95VersionLie.cpp                     \
        ..\Win98VersionLie.cpp                     \
        ..\WinExecRaceConditionFix.cpp             \
        ..\WinNT4SP5VersionLie.cpp                 \
        ..\Win2kPropagateLayer.cpp                 \
        ..\Win2kPropagateLayer_Cleanup.cpp         \
        ..\Win2kPropagateLayer_Environment.cpp     \
        ..\Win2kPropagateLayer_WowTask.cpp


C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\ntdll.lib            \
           $(SDK_LIB_PATH)\user32.lib           \
           $(SDK_LIB_PATH)\gdi32.lib            \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\shell32.lib          \
           $(SDK_LIB_PATH)\shlwapi.lib          \
           $(SDK_LIB_PATH)\ole32.lib            \
           $(SDK_LIB_PATH)\userenv.lib          \
           $(SDK_LIB_PATH)\winspool.lib         \
           $(SDBAPI_PATH)\lib\$(O)\sdbapil.lib  \
           $(SDK_LIB_PATH)\version.lib

DELAYLOAD = version.dll

DLOAD_ERROR_HANDLER=shell32.dll

DLLBASE=0x23000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\syncsystemandsystem32.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   SyncSystemAndSystem32.cpp

 Abstract:

   This shim takes a semi-colon delimited command line of filenames.
   At process termination, the DLL will parse the extract each filename
   from the command line and make sure that the file exists in both
   the System directory and System32 (if it exists in either).

   Some older apps expect certain DLLs to be in System when under NT they
   belong in System32 (and vice versa).

 History:

   03/15/2000 markder   Created
   10/18/2000 a-larrsh  Add Wild Card support for command line.

--*/

#include "precomp.h"
#include "CharVector.h"

IMPLEMENT_SHIM_BEGIN(SyncSystemAndSystem32)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
   APIHOOK_ENUM_ENTRY(CreateFileA)
   APIHOOK_ENUM_ENTRY(CreateFileW)
   APIHOOK_ENUM_ENTRY(CloseHandle)
   APIHOOK_ENUM_ENTRY(CopyFileA)
   APIHOOK_ENUM_ENTRY(CopyFileW)
   APIHOOK_ENUM_ENTRY(CopyFileExA)
   APIHOOK_ENUM_ENTRY(CopyFileExW)
   APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeA)
   APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeW)
APIHOOK_ENUM_END


int                 g_nrgFilesToSync    = 0;
CString *           g_rgFilesToSync     = NULL;

CString *           g_csSystem          = NULL; // c:\windows\system
CString *           g_csSystem32        = NULL; // c:\windows\system32

//---------------------------------------------------------------------------------------
/*+

  A vector of handles objects.
  Access to this list must be inside a critical section.

--*/
class CachedHandleList : public VectorT<HANDLE>
{
private:
    // Prevent copy
    CachedHandleList(const CachedHandleList & );
    CachedHandleList & operator = (const CachedHandleList & );

private:
    static CachedHandleList *   TheCachedHandleList;
    CRITICAL_SECTION            TheCachedHandleListLock;

    inline                      CachedHandleList() {}
    inline                      ~CachedHandleList();

    static CachedHandleList *   GetLocked();
    inline void                 Lock();
    inline void                 Unlock();

    int                         FindHandleIndex(HANDLE handle) const;

public:

    // All access to this class is through these static interfaces.
    // The app has no direct access to the list, therefore cannot accidentally
    // leave the list locked or unlocked.
    // All operations are Atomic.
    static BOOL                 Init();
    static BOOL                 FindHandle(HANDLE handle);
    static BOOL                 AddHandle(HANDLE handle);
    static void                 RemoveHandle(HANDLE handle);
};

/*+

  A static pointer to the one-and-only handle list.

--*/
CachedHandleList * CachedHandleList::TheCachedHandleList = NULL;

/*+

  Init the class

--*/
inline BOOL CachedHandleList::Init()
{
    TheCachedHandleList = new CachedHandleList;
    if( TheCachedHandleList )
    {
        return InitializeCriticalSectionAndSpinCount(&TheCachedHandleList->TheCachedHandleListLock, 0x80000000);
    }
    return FALSE;
}

/*+

  Clean up, releasing all resources.

--*/
inline CachedHandleList::~CachedHandleList()
{
    DeleteCriticalSection(&TheCachedHandleListLock);
}

/*+

  Enter the critical section

--*/
inline void CachedHandleList::Lock()
{
    EnterCriticalSection(&TheCachedHandleListLock);
}

/*+

  Unlock the list

--*/
inline void CachedHandleList::Unlock()
{
    LeaveCriticalSection(&TheCachedHandleListLock);
}

/*+

  Return a locked pointer to the list

--*/
CachedHandleList * CachedHandleList::GetLocked()
{
    if (TheCachedHandleList)
        TheCachedHandleList->Lock();
    
    return TheCachedHandleList;
}

/*+

  Search for the member in the list, return index or -1

--*/
int CachedHandleList::FindHandleIndex(HANDLE handle) const
{
    for (int i = 0; i < Size(); ++i)
    {
        if (Get(i) == handle)
            return i;
    }
    return -1;
}

BOOL CachedHandleList::FindHandle(HANDLE handle)
{
    BOOL bRet                               = FALSE;
    CachedHandleList * CachedHandleList     = NULL;
    
    CachedHandleList = CachedHandleList::GetLocked();
    if (!CachedHandleList)
        goto Exit;

    bRet = CachedHandleList->FindHandleIndex(handle) != -1;

Exit:
    if( CachedHandleList )
    {
        CachedHandleList->Unlock();
    }

    return bRet;
}


/*+

  Add this handle to the global list.

--*/
BOOL CachedHandleList::AddHandle(HANDLE handle)
{
    BOOL bRet                               = FALSE;
    int index                               = -1;
    CachedHandleList * CachedHandleList     = NULL;

    CachedHandleList = CachedHandleList::GetLocked();
    if (!CachedHandleList)
    {
        goto Exit;
    }

    index = CachedHandleList->FindHandleIndex(handle);
    if ( -1 == index )
    {
        bRet = CachedHandleList->Append(handle);
    }

Exit:
    // unlock the list
    if(CachedHandleList)
    {
        CachedHandleList->Unlock();
    }

    return bRet;
}

/*+

  Remove the handle from the global list

--*/
void CachedHandleList::RemoveHandle(HANDLE handle)
{
    int index                               = -1;
    CachedHandleList * CachedHandleList     = NULL;
    
    // Get a pointer to the locked list   
    CachedHandleList = CachedHandleList::GetLocked();
    if (!CachedHandleList)
    {
        goto Exit;
    }

    // Look for our handle remove it.
    index = CachedHandleList->FindHandleIndex(handle);
    if (index >= 0)
    {
        CachedHandleList->Remove(index);
    }

Exit:
    // unlock the list
    if( CachedHandleList )
    {
        CachedHandleList->Unlock();
    }
}

void 
SyncDir(const CString & csFileToSync, const CString & csSrc, const CString & csDest)
{
    // Don't need our own excpetion handler,
    // this routine is only called inside one already.
    CString csSrcFile(csSrc);
    csSrcFile.AppendPath(csFileToSync);
    
    WIN32_FIND_DATAW FindFileData;
  
    HANDLE hFind = FindFirstFileW(csSrcFile, &FindFileData);
    if (hFind != INVALID_HANDLE_VALUE) 
    {
        // csFileToSync might be a wildcard
        do
        {
            CString csDestFile(csDest);
            csDestFile.AppendPath(FindFileData.cFileName);

            if (GetFileAttributesW(csDestFile) == INVALID_FILE_ATTRIBUTES)
            {
                // In System but not System32, copy it over
                CopyFileW(csSrcFile, csDestFile, FALSE);

                DPFN( eDbgLevelInfo, "File found in %S but not in %S: %S", csSrc.Get(), csDest.Get(), FindFileData.cFileName);
                DPFN( eDbgLevelInfo, "Copied over");
            }
        }
        while (FindNextFileW(hFind, &FindFileData));
      
        FindClose(hFind);
    }

}

void 
SyncSystemAndSystem32(const CString & csFileToSync)
{
    SyncDir(csFileToSync, *g_csSystem, *g_csSystem32);
    SyncDir(csFileToSync, *g_csSystem32, *g_csSystem);
}


void 
SyncAllFiles()
{
    CSTRING_TRY
    {
        for (int nFileCount = 0; nFileCount < g_nrgFilesToSync; ++nFileCount)
        {
            SyncSystemAndSystem32(g_rgFilesToSync[nFileCount]);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
}

BOOL
IsFileToSync(const CString & csFileName)
{
    CSTRING_TRY
    {
        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);
    
        for (int i = 0; i < g_nrgFilesToSync; ++i)
        {
            if (csFilePart == g_rgFilesToSync[i])
            {
                LOGN( eDbgLevelWarning, "File to sync detected: %S", csFileName.Get());
                return TRUE;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    return FALSE;
}

BOOL
IsFileToSync(LPCSTR szFileName)
{
    CSTRING_TRY
    {
        CString csFileName(szFileName);
        return IsFileToSync(csFileName);
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    return FALSE;
}

BOOL
IsFileToSync(LPCWSTR szFileName)
{
    CSTRING_TRY
    {
        CString csFileName(szFileName);
        return IsFileToSync(csFileName);
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    return FALSE;
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,                          // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile                        // handle to template file
    )
{
    HANDLE hRet;

    hRet = ORIGINAL_API(CreateFileA)(
        lpFileName,                         
        dwDesiredAccess,                     
        dwShareMode,                         
        lpSecurityAttributes,
        dwCreationDisposition,               
        dwFlagsAndAttributes,                
        hTemplateFile);

    if (hRet != INVALID_HANDLE_VALUE)
    {
        if (IsFileToSync(lpFileName)) 
        {
            CachedHandleList::AddHandle(hRet);
        }
    }

    return hRet;
}

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,                         // file name
    DWORD dwDesiredAccess,                      // access mode
    DWORD dwShareMode,                          // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
    DWORD dwCreationDisposition,                // how to create
    DWORD dwFlagsAndAttributes,                 // file attributes
    HANDLE hTemplateFile                        // handle to template file
    )
{
    HANDLE hRet;

    hRet = ORIGINAL_API(CreateFileW)(
        lpFileName,                         
        dwDesiredAccess,                     
        dwShareMode,                         
        lpSecurityAttributes,
        dwCreationDisposition,               
        dwFlagsAndAttributes,                
        hTemplateFile);

    if (hRet != INVALID_HANDLE_VALUE)
    {
        if (IsFileToSync(lpFileName)) 
        {
            CachedHandleList::AddHandle(hRet);
        }
    }

    return hRet;
}

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    if (CachedHandleList::FindHandle(hObject))
    {
        CachedHandleList::RemoveHandle(hObject);
        SyncAllFiles();
    }

    return ORIGINAL_API(CloseHandle)(hObject);
}

BOOL 
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,  // name of an existing file
    LPCSTR lpNewFileName,       // name of new file
    BOOL bFailIfExists          // operation if file exists
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileA)(
        lpExistingFileName,
        lpNewFileName,
        bFailIfExists);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

BOOL 
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName, // name of an existing file
    LPCWSTR lpNewFileName,      // name of new file
    BOOL bFailIfExists          // operation if file exists
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileW)(
        lpExistingFileName,
        lpNewFileName,
        bFailIfExists);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

BOOL 
APIHOOK(CopyFileExA)(
    LPCSTR lpExistingFileName,            // name of existing file
    LPCSTR lpNewFileName,                 // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
    LPVOID lpData,                        // callback parameter
    LPBOOL pbCancel,                      // cancel status
    DWORD dwCopyFlags                     // copy options
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileExA)(
        lpExistingFileName,
        lpNewFileName,     
        lpProgressRoutine, 
        lpData,            
        pbCancel,          
        dwCopyFlags);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

BOOL 
APIHOOK(CopyFileExW)(
    LPCWSTR lpExistingFileName,           // name of existing file
    LPCWSTR lpNewFileName,                // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine, // callback function
    LPVOID lpData,                        // callback parameter
    LPBOOL pbCancel,                      // cancel status
    DWORD dwCopyFlags                     // copy options
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(CopyFileExW)(
        lpExistingFileName,
        lpNewFileName,     
        lpProgressRoutine, 
        lpData,            
        pbCancel,          
        dwCopyFlags);

    if (bRet)
    {
        if (IsFileToSync(lpNewFileName))
        {
            SyncAllFiles();
        }
    }

    return bRet;
}

//
// GetFileVersionInfoSize was added for the Madeline series.
// There was a specific point at which the sync had to occur.
//

DWORD 
APIHOOK(GetFileVersionInfoSizeA)(
    LPSTR lptstrFilename,   // file name
    LPDWORD lpdwHandle      // set to zero
    )
{
    if (IsFileToSync(lptstrFilename))
    {
        SyncAllFiles();
    }

    return ORIGINAL_API(GetFileVersionInfoSizeA)(lptstrFilename, lpdwHandle);
}

DWORD 
APIHOOK(GetFileVersionInfoSizeW)(
    LPWSTR lptstrFilename,  // file name
    LPDWORD lpdwHandle      // set to zero
    )
{
    if (IsFileToSync(lptstrFilename))
    {
        SyncAllFiles();
    }

    return ORIGINAL_API(GetFileVersionInfoSizeW)(lptstrFilename, lpdwHandle);
}

BOOL 
ParseCommandLine()
{
    CSTRING_TRY
    {
        CString         csCl(COMMAND_LINE);
        CStringParser   csParser(csCl, L";");

        g_nrgFilesToSync    = csParser.GetCount();
        g_rgFilesToSync     = csParser.ReleaseArgv();

        // Create strings to %windir%\system and %windir%\system32
        g_csSystem   = new CString;
        if( g_csSystem )
        {
            if( g_csSystem->GetWindowsDirectoryW() ) {
                g_csSystem->AppendPath(L"System");

                g_csSystem32 = new CString;
                if( g_csSystem32 ) {

                    if( g_csSystem32->GetWindowsDirectoryW() ) {
                        g_csSystem32->AppendPath(L"System32");
                        return TRUE;
                    }
                    delete g_csSystem32;
                }
            }
            delete g_csSystem;
        }

    }
    CSTRING_CATCH
    {
    }

    return FALSE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        if( !CachedHandleList::Init() || !ParseCommandLine() ) 
        {
            return FALSE;
        }
    }
    else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        SyncAllFiles();
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        SyncAllFiles();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileW);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileExA);
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileExW);
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoSizeA);
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoSizeW);

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\vregistry.h ===
#ifndef _VREGISTRY_H_
#define _VREGISTRY_H_

#include "precomp.h"

#define SUCCESS(x) ((x) == ERROR_SUCCESS)
#define FAILURE(x) (!SUCCESS(x))
#define szOutOfMemory "ERROR OUT OF MEMORY"

struct VIRTUALKEY;
struct VIRTUALVAL;
struct ENUMENTRY;
struct OPENKEY;

//
// Callback for QueryValue
//

typedef LONG (WINAPI *_pfn_QueryValue)(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue);

//
// Callback for SetValue
//
typedef LONG (WINAPI *_pfn_SetValue)(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue,
    DWORD dwType,
    const BYTE* pbData,
    DWORD cbData);

//
// Callback for OpenKey, called before virtual keys are searched.
//
typedef LONG (WINAPI *_pfn_OpenKeyTrigger)(WCHAR* wszKey);

//
// A generic prototype for RegEnumValue and RegEnumKeyEx.
// This is used to simplify the enumeration code.
// When using this function pointer, the last four parameters
// must be NULL.
//
typedef LONG (WINAPI *_pfn_EnumFunction)(HKEY hKey, DWORD dwIndex, LPWSTR lpName,
                                         LPDWORD lpcName, void*, void*, void*, void*);
//
// Redirector: maps a key from one location to another
//

struct REDIRECTOR
{
    REDIRECTOR *next;

    LPWSTR wzPath;
    LPWSTR wzPathNew;
};

//
// Protector: Prevents the key in the path from being deleted or modified.
//

struct PROTECTOR
{
    PROTECTOR *next;

    LPWSTR wzPath;
};

//
// Open registry key as opened with RegCreateKey/Ex or RegOpenKey/Ex
//

struct OPENKEY
{
    OPENKEY *next;
    
    HKEY hkOpen;
    BOOL bVirtual;
    BOOL bRedirected;
    VIRTUALKEY *vkey;
    LPWSTR wzPath;

    ENUMENTRY* enumKeys;
    ENUMENTRY* enumValues;

    template<class T>
    ENUMENTRY* AddEnumEntries(T* entryHead, _pfn_EnumFunction enumFunc);

    VOID BuildEnumList();
    VOID FlushEnumList();
};

//
// Virtual value: holds virtual registry value, owned by VIRTUALKEY
//

struct VIRTUALVAL
{
    VIRTUALVAL *next;

    WCHAR wName[MAX_PATH];
    DWORD dwType;
    BYTE *lpData;
    DWORD cbData;
    _pfn_QueryValue pfnQueryValue;
    _pfn_SetValue   pfnSetValue;
};

//
// Virtual key: holds virtual key and values, owned by other virtualkeys
//

struct VIRTUALKEY
{
    VIRTUALKEY *next;
    VIRTUALKEY *keys;
    VIRTUALVAL *values;

    WCHAR wName[MAX_PATH];

    VIRTUALKEY *AddKey(
        LPCWSTR lpPath
        );

    VIRTUALVAL *AddValue(
        LPCWSTR lpValueName, 
        DWORD dwType, 
        BYTE *lpData, 
        DWORD cbData = 0
        );

    VIRTUALVAL *AddValueDWORD(
        LPCWSTR lpValueName, 
        DWORD dwValue
        );

    VIRTUALVAL *AddExpander(LPCWSTR lpValueName);
    VIRTUALVAL *AddProtector(LPCWSTR lpValueName);

    VIRTUALVAL *AddCustom(
        LPCWSTR lpValueName,         
        _pfn_QueryValue pfnQueryValue
        );

    VIRTUALVAL *AddCustomSet(
        LPCWSTR lpValueName,
        _pfn_SetValue pfnSetValue
        );

    VIRTUALKEY *FindKey(LPCWSTR lpKeyName);

    VIRTUALVAL *FindValue(
        LPCWSTR lpValueName
        );

    VOID Free();
};

//
// Enum entry: An entry in a list of all enumerated items belonging to a key.
//
struct ENUMENTRY
{
    ENUMENTRY* next;

    LPWSTR wzName;
};

//
// Open Key Trigger: Describes a function to be called when a key is opened.
//
struct OPENKEYTRIGGER
{
    OPENKEYTRIGGER* next;

    LPWSTR wzPath;

    _pfn_OpenKeyTrigger pfnTrigger;
};

// Class to wrap the virtual registry functionality
class CVirtualRegistry
{
private:
    OPENKEY *OpenKeys;
    VIRTUALKEY *Root;
    REDIRECTOR *Redirectors;
    PROTECTOR  *KeyProtectors;
    OPENKEYTRIGGER *OpenKeyTriggers;
    
    HKEY CreateDummyKey();

    OPENKEY *FindOpenKey(HKEY hKey);

    BOOL CheckRedirect(
        LPWSTR *lpPath
        );

    BOOL CheckProtected(
        LPWSTR lpPath
        );
    
    VOID CheckTriggers(
        LPWSTR lpPath
        );

    VOID FlushEnumLists();

public:
    BOOL Init();
    VOID Free();
    
    REDIRECTOR *AddRedirect(
        LPCWSTR lpPath, 
        LPCWSTR lpPathNew);

    PROTECTOR *AddKeyProtector(
        LPCWSTR lpPath);

    OPENKEYTRIGGER* AddOpenKeyTrigger(
        LPCWSTR lpPath,
        _pfn_OpenKeyTrigger pfnOpenKey);

    VIRTUALKEY *AddKey(LPCWSTR lpPath);

    LONG OpenKeyA(
        HKEY hKey, 
        LPCSTR lpSubKey,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES pSecurityAttributes,
        HKEY *phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG OpenKeyW(
        HKEY hKey, 
        LPCWSTR lpSubKey, 
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES pSecurityAttributes,
        HKEY *phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate,
        BOOL bRemote = FALSE,
        LPCWSTR lpMachineName = NULL
        );

    LONG QueryValueA(
        HKEY hKey, 
        LPSTR lpValueName, 
        LPDWORD lpType, 
        LPBYTE lpData, 
        LPDWORD lpcbData
        );

    LONG QueryValueW(
        HKEY hKey, 
        LPWSTR lpValueName, 
        LPDWORD lpType, 
        LPBYTE lpData, 
        LPDWORD lpcbData
        );

    LONG EnumKeyA(
        HKEY hKey,          
        DWORD dwIndex,      
        LPSTR lpName,      
        LPDWORD lpcbName
        );

    LONG EnumKeyW(
        HKEY hKey,          
        DWORD dwIndex,      
        LPWSTR lpName,      
        LPDWORD lpcbName
        );

    LONG EnumValueA(
        HKEY hKey,          
        DWORD dwIndex,      
        LPSTR lpValueName,      
        LPDWORD lpcbValueName,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumValueW(
        HKEY hKey,          
        DWORD dwIndex,      
        LPWSTR lpValueName,      
        LPDWORD lpcbValueName,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG QueryInfoA(
        HKEY hKey,                
        LPSTR lpClass,           
        LPDWORD lpcbClass,        
        LPDWORD lpReserved,       
        LPDWORD lpcSubKeys,       
        LPDWORD lpcbMaxSubKeyLen, 
        LPDWORD lpcbMaxClassLen,  
        LPDWORD lpcValues,        
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,  
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime   
        );

    LONG QueryInfoW(
        HKEY hKey,                
        LPWSTR lpClass,           
        LPDWORD lpcbClass,        
        LPDWORD lpReserved,       
        LPDWORD lpcSubKeys,       
        LPDWORD lpcbMaxSubKeyLen, 
        LPDWORD lpcbMaxClassLen,  
        LPDWORD lpcValues,        
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,  
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime   
        );

    LONG SetValueA(
        HKEY hKey,
        LPCSTR lpValueName,
        DWORD dwType,
        CONST BYTE* lpData,
        DWORD cbData
        );

    LONG SetValueW(
        HKEY hKey,
        LPCWSTR lpValueName,
        DWORD dwType,
        CONST BYTE* lpData,
        DWORD cbData
        );

    LONG DeleteKeyA(
        HKEY hKey,
        LPCSTR lpSubKey
        );

    LONG DeleteKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

    LONG CloseKey(HKEY hKey);
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegConnectRegistryA)
    APIHOOK_ENUM_ENTRY(RegConnectRegistryW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegEnumValueA)
    APIHOOK_ENUM_ENTRY(RegEnumValueW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyA)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END

extern CVirtualRegistry VRegistry;
extern LPWSTR MakePath(HKEY hkBase, LPCWSTR lpKey, LPCWSTR lpSubKey);
extern LPWSTR SplitPath(LPCWSTR lpPath, HKEY *hkBase);

// Type for the functions that build the keys
typedef VOID (*_pfn_Builder)(char* szParam);

enum PURPOSE {eWin9x, eWinNT, eWin2K, eWinXP, eCustom};

// Entry in the table of custom registry settings
struct VENTRY
{
    WCHAR cName[64];
    _pfn_Builder pfnBuilder;
    PURPOSE ePurpose;

    // Indicates if this entry should be called as part of VRegistry initialization
    BOOL bShouldCall;

    // Parameter
    char* szParam;
};

extern VENTRY *g_pVList;

#endif //_VREGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\vregistry_custom.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Custom.cpp

 Abstract:

    Module to add custom behaviour to virtual registry.

 Fixes:

    VersionNumber string for Microsoft Playpack
    Expanders for DevicePath, ProgramFilesPath and WallPaperDir
    Redirectors for screen savers
    Virtual HKEY_DYN_DATA structure
    Add ProductName to all Network Cards
    Locale has been moved
    Wordpad filenames
    NoDriveTypeAutorun has a different type

 Notes:

    This file should be used to add custom behavior to virtual registry.

 History:

    05/05/2000  linstev     Created
    09/01/2000  t-adams     Added support for PCI devices to BuildDynData()
    09/01/2000  robkenny    Added Krondor
    09/09/2000  robkenny    Updated Wordpad to return a short path to the exe
    09/21/2000  prashkud    Added fix for SpellItDeluxe
    10/25/2000  maonis      Added CookieMaster
    10/17/2000  robkenny    Added HKEY_DYN_DATA\Display\Settings
    11/27/2000  a-fwills    Added display guid to redirectors
    12/28/2000  a-brienw    Added BuildTalkingDictionary for American Heritage
                            Talking Dictionary which is looking for a SharedDir key
    01/15/2001  maonis      Added PageKeepPro
    02/06/2001  a-larrsh    Added FileNet Web Server
    02/27/2001  maonis      Added PageMaker
    02/27/2001  robkenny    Converted to use tcs.h
    03/01/2001  prashkud    Added NetBT keys in BuildNetworkCards()
    04/05/2001  mnikkel     Added HKLM\Microsoft\Windows\CurrentVersion\App Paths\DXDIAG.EXE
    04/27/2001  prashkud    Added custom MiddleSchoolAdvantage 2001 entry
    05/04/2001  prashkud    Added custom entry for BOGUSCTRLID - Win2K layer
    05/19/2001  hioh        Added NOWROBLUE, BuildNowroBlue
    06/13/2001  carlco      Added Princeton ACT
    08/10/2001  mikrause    Added Airline Tycoon, DirectSound hacks.
    11/06/2001  mikrause    Added Delphi 5.0 Pro
    01/02/2002  mamathas    Added NortonAntiVirus2002, BuildNortonAntiVirus
    04/23/2002  garyma      Added Word Perfect Office 2002
    08/20/2002  mnikkel     Added BuildIBMDirector
    11/13/2002  astritz     Added WebSphereSetup

--*/

#define SHIM_LIB_BUILD_FLAG

#include "precomp.h"

#include "secutils.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)
#include "ShimHookMacro.h"
#include "VRegistry.h"
#include "VRegistry_dsound.h"

//
// Functions that modify the behaviour of virtualregistry
//

void BuildWin98SE(char* szParam);
void BuildRedirectors(char* szParam);
void BuildCookiePath(char* szParam);
void BuildHasbro(char* szParam);
void BuildDynData(char* szParam);
void BuildCurrentConfig(char* szParam);
void BuildLocale(char* szParam);
void BuildWordPad(char* szParam);
void BuildAutoRun(char* szParam);
void BuildTalkingDictionary(char* szParam);
void BuildNetworkCards(char* szParam);
void BuildNT4SP5(char* szParam);
void BuildNT50(char* szParam);
void BuildNT51(char* szParam);
void BuildBogusCtrlID(char* szParam);
void BuildExpanders(char* szParam);
void BuildDX7A(char* szParam);
void BuildDXDiag(char* szParam);
void BuildFutureCop(char* szParam);
void BuildKrondor(char* szParam);
void BuildPageKeepProDirectory(char* szParam);
void BuildProfile(char* szParam);
void BuildSpellItDeluxe(char* szParam);
void BuildIE401(char* szParam);
void BuildIE55(char* szParam);
void BuildIE60(char* szParam);
void BuildJoystick(char* szParam);
void BuildIllustrator8(char* szParam);
void BuildModemWizard(char* szParam);
void BuildMSI(char* szParam);
void BuildFileNetWebServer(char* szParam);
void BuildPrinter(char* szParam);
void BuildPageMaker65(char* szParam);
void BuildStarTrekArmada(char* szParam);
void BuildMSA2001(char* szParam);
void BuildNowroBlue(char* szParam);
void BuildRegisteredOwner(char* szParam);
void BuildPrincetonACT(char* szParam);
void BuildHEDZ(char* szParam);
void BuildAirlineTycoon(char* szParam);
void BuildDSDevAccel(char* szParam);
void BuildDSPadCursors(char* szParam);
void BuildDSCachePositions(char* szParam);
void BuildDSReturnWritePos(char* szParam);
void BuildDSSmoothWritePos(char* szParam);
void BuildDSDisableDevice(char* szParam);
void BuildDelphi5Pro(char* szParam);
void BuildNortonAntiVirus(char* szParam);
void BuildWordPerfect2002(char* szParam);
void BuildIBMDirector(char* szParam);
void BuildXpLie(char* szParam);
void BuildXpSp1Lie(char* szParam);
void BuildWin2kSp2Lie(char* szParam);
void BuildWin2kSp3Lie(char* szParam);
void BuildWebSphereSetup(char* szParam);

// Table that contains all the fixes - note, must be terminated by a NULL entry.

VENTRY g_VList[] =
{
    {L"WIN98SE",           BuildWin98SE,                 eWin9x,  FALSE, NULL },
    {L"REDIRECT",          BuildRedirectors,             eWin9x,  FALSE, NULL },
    {L"COOKIEPATH",        BuildCookiePath,              eWin9x,  FALSE, NULL },
    {L"HASBRO",            BuildHasbro,                  eWin9x,  FALSE, NULL },
    {L"DYN_DATA",          BuildDynData,                 eWin9x,  FALSE, NULL },
    {L"CURRENT_CONFIG",    BuildCurrentConfig,           eWin9x,  FALSE, NULL },
    {L"LOCALE",            BuildLocale,                  eWin9x,  FALSE, NULL },
    {L"WORDPAD",           BuildWordPad,                 eWin9x,  FALSE, NULL },
    {L"AUTORUN",           BuildAutoRun,                 eWin9x,  FALSE, NULL },
    {L"TALKINGDICTIONARY", BuildTalkingDictionary,       eWin9x,  FALSE, NULL },
    {L"PRINTER",           BuildPrinter,                 eWin9x,  FALSE, NULL },
    {L"REGISTEREDOWNER",   BuildRegisteredOwner,         eWin9x,  FALSE, NULL },
    {L"NETWORK_CARDS",     BuildNetworkCards,            eWinNT,  FALSE, NULL },
    {L"NT4SP5",            BuildNT4SP5,                  eWinNT,  FALSE, NULL },
    {L"NT50",              BuildNT50,                    eWin2K,  FALSE, NULL },
    {L"BOGUSCTRLID",       BuildBogusCtrlID,             eWin2K,  FALSE, NULL },    
    {L"NT51",              BuildNT51,                    eWinXP,  FALSE, NULL },
    {L"EXPAND",            BuildExpanders,               eCustom, FALSE, NULL },
    {L"DX7A",              BuildDX7A,                    eCustom, FALSE, NULL },
    {L"DXDIAG",            BuildDXDiag,                  eCustom, FALSE, NULL },
    {L"FUTURECOP",         BuildFutureCop,               eCustom, FALSE, NULL },
    {L"KRONDOR",           BuildKrondor,                 eCustom, FALSE, NULL },
    {L"PROFILE",           BuildProfile,                 eCustom, FALSE, NULL },
    {L"SPELLITDELUXE",     BuildSpellItDeluxe,           eCustom, FALSE, NULL },
    {L"IE401",             BuildIE401,                   eCustom, FALSE, NULL }, 
    {L"IE55",              BuildIE55,                    eCustom, FALSE, NULL }, 
    {L"IE60",              BuildIE60,                    eCustom, FALSE, NULL }, 
    {L"JOYSTICK",          BuildJoystick,                eCustom, FALSE, NULL },
    {L"ILLUSTRATOR8",      BuildIllustrator8,            eCustom, FALSE, NULL },
    {L"PAGEKEEPPRO30",     BuildPageKeepProDirectory,    eCustom, FALSE, NULL },
    {L"MODEMWIZARD",       BuildModemWizard,             eCustom, FALSE, NULL },
    {L"MSI",               BuildMSI,                     eCustom, FALSE, NULL },
    {L"FILENETWEBSERVER",  BuildFileNetWebServer,        eCustom, FALSE, NULL },
    {L"PAGEMAKER65",       BuildPageMaker65,             eCustom, FALSE, NULL },
    {L"STARTREKARMADA",    BuildStarTrekArmada,          eCustom, FALSE, NULL },
    {L"MSA2001",           BuildMSA2001,                 eCustom, FALSE, NULL },    
    {L"NOWROBLUE",         BuildNowroBlue,               eCustom, FALSE, NULL },
    {L"PRINCETONACT",      BuildPrincetonACT,            eCustom, FALSE, NULL },    
    {L"HEDZ",              BuildHEDZ,                    eCustom, FALSE, NULL },
    {L"AIRLINETYCOON",     BuildAirlineTycoon,           eCustom, FALSE, NULL },
    {L"DSDEVACCEL",        BuildDSDevAccel,              eCustom, FALSE, NULL },
    {L"DSPADCURSORS",      BuildDSPadCursors,            eCustom, FALSE, NULL },
    {L"DSCACHEPOSITIONS",  BuildDSCachePositions,        eCustom, FALSE, NULL },
    {L"DSRETURNWRITEPOS",  BuildDSReturnWritePos,        eCustom, FALSE, NULL },
    {L"DSSMOOTHWRITEPOS",  BuildDSSmoothWritePos,        eCustom, FALSE, NULL },
    {L"DSDISABLEDEVICE",   BuildDSDisableDevice,         eCustom, FALSE, NULL },
    {L"DELPHI5PRO",        BuildDelphi5Pro,              eCustom, FALSE, NULL },
    {L"NORTONANTIVIRUS",   BuildNortonAntiVirus,         eCustom, FALSE, NULL },
    {L"WORDPERFECT2002",   BuildWordPerfect2002,         eCustom, FALSE, NULL },
    {L"IBMDIRECTOR",       BuildIBMDirector,             eCustom, FALSE, NULL },
    {L"XPLIE",             BuildXpLie,                   eCustom, FALSE, NULL },
    {L"XPSP1LIE",          BuildXpSp1Lie,                eCustom, FALSE, NULL },
    {L"WIN2KSP2LIE",       BuildWin2kSp2Lie,             eCustom, FALSE, NULL },
    {L"WIN2KSP3LIE",       BuildWin2kSp3Lie,             eCustom, FALSE, NULL },
    {L"WEBSPHERESETUP",    BuildWebSphereSetup,          eCustom, FALSE, NULL },

    // Must Be The Last Entry   
    {L"",                  NULL,                         eCustom, FALSE, NULL }
};
VENTRY *g_pVList = &g_VList[0];

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add Win98 SE registry value - so far we only know about the Play Pack that 
    needs it.

 History:

    05/04/2000 linstev  Created

--*/

void
BuildWin98SE(char* /*szParam*/)
{
    VIRTUALKEY *key;

    // Add version number string for emulation of Win98 SE
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"VersionNumber", REG_SZ, (LPBYTE)L"4.10.2222");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Known moved locations for which we need redirectors

 History:

    05/04/2000 linstev  Created

--*/

void
BuildRedirectors(char* /*szParam*/)
{
    // Display property page add ons and controls have changed location.
    VRegistry.AddRedirect(
        L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\Display",
        L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Controls Folder\\Desk");

    // this key moved somewhere around build 2200.
    // System config scan type apps (ip.exe bundled in EA sports)
    // starting failing again.
    VRegistry.AddRedirect(
        L"HKLM\\System\\CurrentControlSet\\Services\\Class",
        L"HKLM\\System\\CurrentControlSet\\Control\\Class");

    // Nightmare Ned wasn't finding display starting from Class.
    // Directing it from Display to the GUID.
    VRegistry.AddRedirect(
        L"HKLM\\System\\CurrentControlSet\\Services\\Class\\Display",
        L"HKLM\\System\\CurrentControlSet\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}");

}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    CookieMaster gets the wrong path to cookies
    because HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Special Paths\\Cookies
    contains bogus value (shell is going to fix this). We change this to the correct value %USERPROFILE%\Cookies.
    
 History:

    10/25/2000 maonis  Created

--*/

void
BuildCookiePath(char* /*szParam*/)
{
    WCHAR wCookiePath[] = L"%USERPROFILE%\\Cookies";

    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Special Paths\\Cookies");
    if (key)
    {
        key->AddValue(L"Directory", REG_EXPAND_SZ, (LPBYTE)wCookiePath, 0);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

  During the Slingo installation, the program places a value in the registry
  called 'PALFILE'. When you run the app, it checks this value to determine
  where the CD-ROM is located. For example, if the CD-ROM drive is 'E', it
  should put 'E:\Slingo.pal'. It fails to do this correctly on Win2K or Whistler,
  as it puts the install path instead. When the app runs, if the value doesn't
  refer to 'x:\Slingo.pal (where x is the CD-ROM drive)', the app immediately
  starts to do a FindFirstFile->FindNextFile looking for the file on the hard
  drive. Eventually it AVs during the search with no error message. This code
  sets the value in the registry on behalf of the app.

 History:

    11/1/2000   rparsons     Created

--*/

LONG 
WINAPI
VR_Hasbro(
    OPENKEY *key,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue
    )
{
    DWORD dwType;
    WCHAR wszPath[MAX_PATH];
    DWORD dwSize = sizeof(wszPath);
    DWORD dwAttributes;

    //
    // Query the original value
    //

    LONG lRet = RegQueryValueExW(
        key->hkOpen, 
        vvalue->wName, 
        NULL, 
        &dwType, 
        (LPBYTE)wszPath, 
        &dwSize);
    
    //
    // Query failed - something went wrong
    //

    if (FAILURE(lRet))
    {
        DPFN( eDbgLevelError, "[Hasbro hack] Failed to query %S for expansion", vvalue->wName);
        goto Exit;
    }

    //
    // Not a string type!
    //

    if ((dwType != REG_SZ) || (dwSize > sizeof(wszPath)))
    {
        DPFN( eDbgLevelError, "[Hasbro hack] Failed to query %S", vvalue->wName);
        lRet = ERROR_BAD_ARGUMENTS;
        goto Exit;
    }

    // Check what's there
    dwAttributes = GetFileAttributes(wszPath);

    // If it's not a file, or it's a directory, then we have to find it ourselves
    if ((dwAttributes == (DWORD)-1) || (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        WCHAR *lpDrives = L"";
        DWORD dwBufferLen = 0;

        //
        // The plan is to run all the drives and find one with a .PAL file on 
        // it. We also have the restriction that it must be a CDRom. It has
        // been pointed out that if the user has multiple CD drives and has
        // different HasBro titles in each drive, we could cause a failure, 
        // but we're considering that a pathological case for now. Especially 
        // considering we have no way of knowing what the palfile name is ahead
        // of time.
        //

        dwBufferLen = GetLogicalDriveStringsW(0, lpDrives);
        if (dwBufferLen)
        {
            lpDrives = (WCHAR *) malloc((dwBufferLen + 1) * sizeof(WCHAR));
            if (lpDrives)
            {
                GetLogicalDriveStrings(dwBufferLen, lpDrives);

                WCHAR *lpCurrent = lpDrives;
                while (lpCurrent && lpCurrent[0])
                {
                    if (GetDriveTypeW(lpCurrent) == DRIVE_CDROM)
                    {
                        //
                        // We've found a CD drive, now see if it has a .PAL 
                        // file on it.
                        //

                        WCHAR wszFile[MAX_PATH];
                        WIN32_FIND_DATAW ffData;
                        HANDLE hFindFile;
                        
                        if (SUCCEEDED(StringCchCopyW(wszFile, MAX_PATH, lpCurrent)) &&
                            SUCCEEDED(StringCchCatW(wszFile, MAX_PATH, L"*.PAL")))

                        {                                                                        
                           hFindFile = FindFirstFileW(wszFile, &ffData);
   
                           if (hFindFile != INVALID_HANDLE_VALUE)
                           {
                               // A .PAL file exists, return that.
                               FindClose(hFindFile);

                               if (SUCCEEDED(StringCchCopyW(wszPath, MAX_PATH, lpCurrent)) &&
                                   SUCCEEDED(StringCchCatW(wszPath, MAX_PATH, ffData.cFileName)))
                               {                                                              
   
                                  LOGN( eDbgLevelInfo, "[Hasbro hack] Returning path %S", wszPath);
                                  break;
                               }
                            }
                        }
                    }
                    
                    // Advance to the next drive letter
                    lpCurrent += wcslen(lpCurrent) + 1;
                }

                free(lpDrives);
            }
        }
    }

    // Copy the result into the output of QueryValue

    vvalue->cbData = (wcslen(wszPath) + 1) * sizeof(WCHAR);
    vvalue->lpData = (LPBYTE) malloc(vvalue->cbData);

    if (!vvalue->lpData)
    {
        DPFN( eDbgLevelError, szOutOfMemory);
        lRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    MoveMemory(vvalue->lpData, wszPath, vvalue->cbData);

    //
    // Never call us again, since we've done the work to set this value up and
    // stored it in our virtual value
    //
    vvalue->pfnQueryValue = NULL;

    lRet = ERROR_SUCCESS;

Exit:
    return lRet;
}

void
BuildHasbro(char* /*szParam*/)
{
    HKEY hHasbroKey;    
    WCHAR wszKeyName[MAX_PATH];
    DWORD dwIndex;

    const WCHAR wszHasbroPath[] = L"SOFTWARE\\Hasbro Interactive";

    if (FAILURE(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszHasbroPath, 0, KEY_READ, &hHasbroKey)))
    {
        DPFN( eDbgLevelSpew, "[Hasbro hack] Ignoring fix - no titles found");
        return;
    }
    
    //
    // Enum the keys under Hasbro Interactive and add a virtual PALFILE value.
    // Attach our callback to this value (see above)
    //

    dwIndex = 0;

    while (SUCCESS(RegEnumKeyW(hHasbroKey, dwIndex, wszKeyName, MAX_PATH)))
    {
        WCHAR wszName[MAX_PATH] = L"HKLM\\";

        if (SUCCEEDED(StringCchCatW(wszName, MAX_PATH, wszHasbroPath)) &&
            SUCCEEDED(StringCchCatW(wszName, MAX_PATH, L"\\")) &&
            SUCCEEDED(StringCchCatW(wszName, MAX_PATH, wszKeyName)))
        {
           VIRTUALKEY *key = VRegistry.AddKey(wszName);
           if (key)
           {
               VIRTUALVAL *val = key->AddValue(L"PALFILE", REG_SZ, 0, 0);
               if (val)
               {
                   val->pfnQueryValue = VR_Hasbro;
               }
 
               DPFN( eDbgLevelInfo, "[Hasbro hack] Adding fix for %S", wszKeyName);
          }
        }
        dwIndex++;
    }

    RegCloseKey(hHasbroKey);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    A simple DYN_DATA structure which emulates win9x.

 History:

    05/04/2000 linstev  Created
    09/01/2000 t-adams  Added support for PCI devices so EA's 3dSetup.exe & others can
                        detect hardware.

--*/

#define ENUM_BASE 0xC29A28C0

void
BuildDynData(char* /*szParam*/)
{
    VIRTUALKEY *key, *nkey;
    HKEY hkPCI = 0;
    DWORD i = 0;
    DWORD dwNameLen = 0;
    LPWSTR wstrName = NULL;
    LPWSTR wstrVName = NULL;
    FILETIME fileTime;
    DWORD dwValue;

    // Entries in HKDD\Config Manager\Enum were references to entries in HKLM\Enum\PCI that are now
    //   located at HKLM\SYSTEM\CurrentControlSet\Enum\PCI
    VRegistry.AddRedirect(
        L"HKLM\\Enum",
        L"HKLM\\SYSTEM\\CurrentControlSet\\Enum");

    // Construct HKDD\Config Manager\Enum so that it reflects the entries in HKLM\SYSTEM\CurrentControlSet\Enum\PCI
    key = VRegistry.AddKey(L"HKDD\\Config Manager\\Enum");
    if (!key)
    {
        goto exit;
    }

    if (SUCCESS(RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Enum\\PCI",0, KEY_READ, &hkPCI)))
    {
        dwNameLen = MAX_PATH;
        wstrName = (LPWSTR) malloc(dwNameLen * sizeof(WCHAR));
        if (NULL == wstrName)
        {
            goto exit;
        }

        wstrVName = (LPWSTR) malloc(dwNameLen * sizeof(WCHAR));
        if (NULL == wstrName)
        {
            goto exit;
        }

        i = 0;
        while (ERROR_SUCCESS == RegEnumKeyExW(hkPCI, i, wstrName, &dwNameLen, NULL, NULL, NULL, &fileTime))
        {            
            if (FAILED(StringCchPrintf(wstrVName, MAX_PATH, L"%x", ENUM_BASE+i)))
            {
               continue;
            }
            
            nkey = key->AddKey(wstrVName);
            if (!nkey) continue;

            if (SUCCEEDED(StringCchCopy(wstrVName, MAX_PATH, L"PCI\\")) &&
                SUCCEEDED(StringCchCat(wstrVName, MAX_PATH, wstrName)))                
            {
               nkey->AddValue(L"HardWareKey", REG_SZ, (LPBYTE)wstrVName);
            }            
            nkey->AddValueDWORD(L"Problem", 0);

            dwNameLen = MAX_PATH;
            ++i;
        }
    }

    key = VRegistry.AddKey(L"HKDD\\Config Manager\\Global");

    key = VRegistry.AddKey(L"HKDD\\PerfStats");
    
    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StartSrv");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM", REG_BINARY, (LPBYTE)&dwValue, 4);
    }
    
    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StartStat");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL\\CPUUsage", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\Threads", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\VMs", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VCACHE\\cCurPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMacPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMinPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\FailedRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Hits", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRUBuffers", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRURecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Misses", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\RandomRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VFAT\\BReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\BWritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\DirtyData", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\ReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\WritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VMM\\cDiscards", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cInstanceFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageIns", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageOuts", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgCommit", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMac", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMid", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMin", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgFree", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLocked", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLockedNonCache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgOther", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSharedPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwap", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFile", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileDefective", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileInUse", REG_BINARY, (LPBYTE)&dwValue, 4);
    }

    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StatData");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL\\CPUUsage", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\Threads", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\VMs", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VCACHE\\cCurPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMacPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMinPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\FailedRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Hits", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRUBuffers", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRURecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Misses", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\RandomRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VFAT\\BReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\BWritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\DirtyData", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\ReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\WritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VMM\\cDiscards", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cInstanceFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageIns", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageOuts", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgCommit", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMac", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMid", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMin", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgFree", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLocked", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLockedNonCache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgOther", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSharedPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwap", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFile", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileDefective", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileInUse", REG_BINARY, (LPBYTE)&dwValue, 4);
    }

    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StopSrv");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT",   REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM",    REG_BINARY, (LPBYTE)&dwValue, 4);
    }

    key = VRegistry.AddKey(L"HKDD\\PerfStats\\StopStat");
    if (key)
    {
        dwValue = 0x0000001;
        key->AddValue(L"KERNEL\\CPUUsage", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\Threads", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"KERNEL\\VMs", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VCACHE\\cCurPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMacPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\cMinPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\FailedRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Hits", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRUBuffers", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\LRURecycles", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\Misses", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VCACHE\\RandomRecycles", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VFAT\\BReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\BWritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\DirtyData", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\ReadsSec", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VFAT\\WritesSec", REG_BINARY, (LPBYTE)&dwValue, 4);

        key->AddValue(L"VMM\\cDiscards", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cInstanceFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageFaults", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageIns", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cPageOuts", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgCommit", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMac", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMid", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgDiskcacheMin", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgFree", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLocked", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgLockedNonCache", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgOther", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSharedPages", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwap", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFile", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileDefective", REG_BINARY, (LPBYTE)&dwValue, 4);
        key->AddValue(L"VMM\\cpgSwapFileInUse", REG_BINARY, (LPBYTE)&dwValue, 4);
    }

exit:
    if (NULL != wstrName)
    {
        free(wstrName);
    }

    if (NULL != wstrVName)
    {
        free(wstrVName);
    }

    if (0 != hkPCI)
    {
        RegCloseKey(hkPCI);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

  DisplaySettings

 History:

    10/17/2000 robkenny Added HKEY_CURRENT_CONFIG

--*/

void
BuildCurrentConfig(char* /*szParam*/)
{
    DEVMODE devMode;
    memset(&devMode, 0, sizeof(devMode));
    devMode.dmSize = sizeof(devMode);

    // Get the current display settings
    BOOL bSuccessful = EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &devMode);
    if (bSuccessful)
    {
        // Create fake registry keys with dmPelsWidth, dmPelsHeight, dmPelsWidth and dmBitsPerPel
        VIRTUALKEY *key = VRegistry.AddKey(L"HKCC\\Display\\Settings");
        if (key)
        {
            WCHAR lpValue[100];
            if (SUCCEEDED(StringCchPrintf(lpValue, 100, L"%d",devMode.dmBitsPerPel)))
            {
               key->AddValue(L"BitsPerPixel", REG_SZ, (LPBYTE)lpValue, 0);
            }
            
            if (SUCCEEDED(StringCchPrintf(lpValue, 100,L"%d,%d", devMode.dmPelsWidth, devMode.dmPelsHeight)))
            {
               key->AddValue(L"Resolution", REG_SZ, (LPBYTE)lpValue, 0);
            }
        }
    }

    // Redirect the current desktop fonts
    VRegistry.AddRedirect(
        L"HKCC\\Display\\Fonts",
        L"HKCC\\Software\\Fonts");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Make RegQueryValue return the value that's in the "(Default)" value, rather 
    than the NULL which is in there now. Not sure why the Locale key has this 
    difference.

 History:

    06/29/2000 linstev  Created

--*/

void
BuildLocale(char* /*szParam*/)
{
    #define LOCALE_KEY    HKEY_LOCAL_MACHINE
    #define LOCALE_SUBKEY L"System\\CurrentControlSet\\Control\\Nls\\Locale"

    HKEY hkBase;

    if (FAILURE(RegOpenKeyExW(
            LOCALE_KEY,
            LOCALE_SUBKEY,
            0,
            KEY_READ,
            &hkBase)))
    {
        return;
    }

    WCHAR wValue[MAX_PATH];
    DWORD dwSize = MAX_PATH * sizeof(WCHAR);

    if (SUCCESS(RegQueryValueExW(hkBase, L"(Default)", 0, 0, (LPBYTE)wValue, &dwSize)))
    {
        LPWSTR wzPath;
        VIRTUALKEY *localekey;

        // Convert the KEY and SUBKEY into a path we can use for the vregistry
        wzPath = MakePath(LOCALE_KEY, 0, LOCALE_SUBKEY);
        if (wzPath)
        {
            localekey = VRegistry.AddKey(wzPath);
            if (localekey)
            {
                localekey->AddValue(L"", REG_SZ, (LPBYTE)wValue);
            }
            free(wzPath);
        }
    }

    RegCloseKey(hkBase);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    On NT, the strings in these values are of the form:

          C:\Program Files\Windows NT\Accessories\WORDPAD.EXE "%1"

    Note that the entire string is NOT quoted. On win9x, the string was:

          C:\Windows\wordpad.exe "%1"

    This causes problems when apps parse the NT version, because they hit the 
    space between Program and Files.

    The fix is to return a shortened pathname to wordpad.exe

 History:

    05/04/2000 linstev  Created
    05/04/2000 robkenny Updated to return a correct short pathname to wordpad.exe

--*/

void
BuildWordPad(char* /*szParam*/)
{
    // Allocate memory so we don't use up lots of stack
    WCHAR *lpwzWordpadOpen = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));
    WCHAR *lpwzWordpadPrint = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));
    WCHAR *lpwzWordpadPrintTo = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));

    WCHAR *lpwzWordpadLong = lpwzWordpadOpen; // borrow the buffer to save space
    WCHAR *lpwzWordpadShort = (WCHAR *)malloc(MAX_PATH * sizeof(WCHAR));

    DWORD lpType;
    DWORD cbValue;
    LONG result;

    if (lpwzWordpadOpen == NULL ||
        lpwzWordpadPrint == NULL ||
        lpwzWordpadPrintTo == NULL ||
        lpwzWordpadShort == NULL)
    {
        goto AllDone;
    }

    // Read the path to WORDPAD.EXE directly from the registry.
    HKEY hKeyAppPaths;
    result = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\WORDPAD.EXE",
        0, 
        KEY_QUERY_VALUE,
        &hKeyAppPaths
        );
    
    if (result != ERROR_SUCCESS)
    {
        goto AllDone;
    }

    cbValue = MAX_PATH * sizeof(DWORD);
    result = RegQueryValueExW(
        hKeyAppPaths,
        NULL, // default value
        NULL,
        &lpType,
        (LPBYTE)lpwzWordpadLong,
        &cbValue);

    RegCloseKey(hKeyAppPaths);
    if (result != ERROR_SUCCESS)
    {
        goto AllDone;
    }

    // turn bytes into string length (includes EOS)
    DWORD cchValue = cbValue /sizeof(WCHAR); 

    if (lpType == REG_EXPAND_SZ)
    {
        WCHAR * lpwzWordpadExpand = lpwzWordpadPrintTo; // borrow the lpwzWordpadPrintTo buffer for a moment.

        cchValue = ExpandEnvironmentStringsW(lpwzWordpadLong, lpwzWordpadExpand, MAX_PATH);
        if (cchValue == 0 || cchValue > MAX_PATH )
            goto AllDone;

        lpwzWordpadLong = lpwzWordpadExpand;
    }

    // Rip off the trailing Quote
    lpwzWordpadLong[cchValue-2] = 0;
    lpwzWordpadLong += 1;

    // Build the short path to wordpad
    cchValue = GetShortPathNameW(lpwzWordpadLong, lpwzWordpadShort, MAX_PATH);
    if (cchValue == 0 || cchValue > MAX_PATH)
    {
        goto AllDone;
    }

    if (FAILED(StringCchPrintf(lpwzWordpadOpen, MAX_PATH,L"%s \"%%1\"", lpwzWordpadShort)) ||
        FAILED(StringCchPrintf(lpwzWordpadPrint, MAX_PATH, L"%s /p \"%%1\"",lpwzWordpadShort)) ||
        FAILED(StringCchPrintf(lpwzWordpadPrintTo, MAX_PATH,L"%s /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\"", lpwzWordpadShort)))
    {
       goto AllDone;
    }    

    #define WORDPAD_OPEN    ((LPBYTE)lpwzWordpadOpen)
    #define WORDPAD_PRINT   ((LPBYTE)lpwzWordpadPrint)
    #define WORDPAD_PRINTTO ((LPBYTE)lpwzWordpadPrintTo)

    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKCR\\rtffile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKCR\\rtffile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKCR\\rtffile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKCR\\Wordpad.Document.1\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKCR\\Wordpad.Document.1\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKCR\\Wordpad.Document.1\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKCR\\wrifile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKCR\\wrifile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKCR\\wrifile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Applications\\wordpad.exe\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Applications\\wordpad.exe\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Applications\\wordpad.exe\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\rtffile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\rtffile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\rtffile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Wordpad.Document.1\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Wordpad.Document.1\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\Wordpad.Document.1\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\wrifile\\shell\\open\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_OPEN);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\wrifile\\shell\\print\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINT);
    key = VRegistry.AddKey(L"HKLM\\Software\\Classes\\wrifile\\shell\\printto\\command");
    if (key) key->AddValue(0, REG_SZ, WORDPAD_PRINTTO);

AllDone:
    free(lpwzWordpadOpen);
    free(lpwzWordpadPrint);
    free(lpwzWordpadPrintTo);

    free(lpwzWordpadShort);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    This is a REG_BINARY on win9x

 History:

    07/18/2000 linstev  Created

--*/

void
BuildAutoRun(char* /*szParam*/)
{
    #define AUTORUN_KEY    HKEY_CURRENT_USER
    #define AUTORUN_SUBKEY L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"

    HKEY hkBase;

    if (FAILURE(RegOpenKeyExW(
            AUTORUN_KEY,
            AUTORUN_SUBKEY,
            0,
            KEY_READ,
            &hkBase)))
    {
        return;
    }

    DWORD dwValue;
    DWORD dwSize = sizeof(DWORD);

    if (SUCCESS(RegQueryValueExW(hkBase, L"NoDriveTypeAutoRun", 0, 0, (LPBYTE)&dwValue, &dwSize)))
    {
        LPWSTR wzPath;
        VIRTUALKEY *vkey;

        // Convert the KEY and SUBKEY into a path we can use for the vregistry
        wzPath = MakePath(AUTORUN_KEY, 0, AUTORUN_SUBKEY);
        if (wzPath)
        {
            vkey = VRegistry.AddKey(wzPath);
            if (vkey)
            {
                vkey->AddValue(L"NoDriveTypeAutoRun", REG_BINARY, (LPBYTE)&dwValue, sizeof(DWORD));
            }
            free(wzPath);
        }
    }

    RegCloseKey(hkBase);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add SharedDir value to HKLM\Software\Microsoft\Windows\CurrentVersion\Setup
    The SharedDir in this case is just the windows directory (as it was on 9x).

 History:

    12/28/2000 a-brienw  Created

--*/

void
BuildTalkingDictionary(char* /*szParam*/)
{
    VIRTUALKEY *key;
    WCHAR szWindowsDir[MAX_PATH];
    
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
    if (key)
    {
        DWORD cchSize = GetWindowsDirectoryW( (LPWSTR)szWindowsDir, MAX_PATH);
        if (cchSize != 0 && cchSize <= MAX_PATH)
            key->AddValue(L"SharedDir", REG_SZ, (LPBYTE)szWindowsDir);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add a ProductName value to every network card description as on NT 4. The 
    product name in this case is just the first 8 characters of the 
    description.

 History:

    01/18/2000 linstev  Created
    03/01/2001 prashkud Added NetBT\Adapter key and the corresponding values

--*/

void 
BuildNetworkCards(char* /*szParam*/)
{
    #define NETCARD_KEY    HKEY_LOCAL_MACHINE
    #define NETCARD_SUBKEY L"Software\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"
    #define NETBT_SUBKEY   L"System\\CurrentControlSet\\Services\\NetBT"
    
    // For NetBT
    LPWSTR wzNetBTPath;
    WCHAR wAdapter[MAX_PATH];   
    VIRTUALKEY *vkAdapter = NULL;
    HKEY hkNetBT;

    if (FAILURE(RegOpenKeyExW(
            NETCARD_KEY,
            NETBT_SUBKEY,
            0,
            KEY_READ,
            &hkNetBT)))
    {
        DPFN( eDbgLevelError, "Failed to add NetBT settings");
        return;
    }

    if (FAILED(StringCchCopy(wAdapter, MAX_PATH, NETBT_SUBKEY)))
    {
       RegCloseKey(hkNetBT);
       return;
    }
    if (FAILED(StringCchCat(wAdapter, MAX_PATH, L"\\Adapters")))
    {
       RegCloseKey(hkNetBT);
       return;
    }
    
    // Make this a Virtual path
    wzNetBTPath = MakePath(NETCARD_KEY, 0, wAdapter);
    if (!wzNetBTPath)
    {
        DPFN( eDbgLevelError, "Failed to make NetBT path");
        RegCloseKey(hkNetBT);
        return;
    }

    // Adding the Adapters subkey to NetBT
    vkAdapter = VRegistry.AddKey(wzNetBTPath);
    free(wzNetBTPath);

    HKEY hkBase;

    // Check for network cards
    if (FAILURE(RegOpenKeyExW(
            NETCARD_KEY,
            NETCARD_SUBKEY,
            0,
            KEY_READ,
            &hkBase)))
    {
        DPFN( eDbgLevelError, "Failed to add Network card registry settings");
        return;
    }

    LPWSTR wzPath;
    VIRTUALKEY *netkey;

    // Convert the KEY and SUBKEY into a path we can use for the vregistry
    wzPath = MakePath(NETCARD_KEY, 0, NETCARD_SUBKEY);
    netkey = wzPath ? VRegistry.AddKey(wzPath) : NULL;
    
    if (wzPath && netkey)
    {
        // Enumerate the keys and add them to the virtual registry
        DWORD dwIndex = 0;
        WCHAR wName[MAX_PATH];

        while (SUCCESS(RegEnumKeyW(
                hkBase,
                dwIndex,
                wName,
                MAX_PATH)))
        {
            HKEY hKey;
            VIRTUALKEY *keyn;
            WCHAR wTemp[MAX_PATH];

            keyn = netkey->AddKey(wName);

            if (!keyn)
            {
                break;
            }

            if (SUCCEEDED(StringCchCopy(wTemp, MAX_PATH, NETCARD_SUBKEY)) &&
                SUCCEEDED(StringCchCat(wTemp, MAX_PATH, L"\\")) &&
                SUCCEEDED(StringCchCat(wTemp, MAX_PATH,wName)))

            {            
               // Open the actual key
               if (SUCCESS(RegOpenKeyExW(
                       NETCARD_KEY,
                       wTemp,
                       0,
                       KEY_READ,
                       &hKey)))
               {
                   WCHAR wDesc[MAX_PATH];
                   WCHAR wServName[MAX_PATH];
                   DWORD dwSize = MAX_PATH; 
   
                   // check for description
                   if (SUCCESS(RegQueryValueExW(
                           hKey,
                           L"Description",
                           0,
                           0,
                           (LPBYTE)wDesc,
                           &dwSize)))
                   {
                       // Max out at 8 characters
                       wDesc[8] = L'\0';
                       keyn->AddValue(L"ProductName", REG_SZ, (LPBYTE)wDesc);
                   }
   
                   // Query for the ServiceName Value
                   dwSize = MAX_PATH;
                   if (SUCCESS(RegQueryValueExW(
                          hKey,
                          L"ServiceName",
                          0,
                          0,
                          (LPBYTE)wServName,
                          &dwSize)))
                   {                                       
                       if (vkAdapter)
                       {                       
                           if (!vkAdapter->AddKey(wServName))
                           {
                               DPFN( eDbgLevelError, "Error adding the Key to NetBT");                        
                           }
                       }
                   }
   
                   RegCloseKey(hKey);
               }
            }

            dwIndex++;
        }
    }

    free(wzPath);

    RegCloseKey(hkBase);
    RegCloseKey(hkNetBT);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add NT4 SP5 Credentials.

 History:

    05/23/2000 linstev  Created

--*/

void
BuildNT4SP5(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CSDVersion", REG_SZ, (LPBYTE)L"Service Pack 5");
    }

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CurrentVersion", REG_SZ, (LPBYTE)L"4.0");
    }

    key = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Control\\Windows");
    if (key)
    {
        key->AddValueDWORD(L"CSDVersion", 0x0500);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add Win2k version number

 History:

    05/22/2001 linstev  Created

--*/

void
BuildNT50(char* /*szParam*/)
{
    VIRTUALKEY *key;

    // Add Win2k version number 
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CurrentVersion", REG_SZ, (LPBYTE)L"5.0");
        key->AddValue(L"ProductName", REG_SZ, (LPBYTE)L"Microsoft Windows 2000");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add WinXP version number

 History:

    05/01/2002 linstev  Created

--*/

void
BuildNT51(char* /*szParam*/)
{
    VIRTUALKEY *key;

    // Add Win2k version number 
    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"CurrentVersion", REG_SZ, (LPBYTE)L"5.1");
        key->AddValue(L"ProductName", REG_SZ, (LPBYTE)L"Microsoft Windows XP");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    This function adds the Shell compatibility flag for apps that need the 
    bogus Ctrl ID of IDOK for ToolBarWindows32 class.

    This also gets applied through the Win2K layer as this is a regression from 
    Win2K.

 History:

    05/04/2001 prashkud  Created

--*/

void
BuildBogusCtrlID(char* /*szParam*/)
{            
    CSTRING_TRY
    {
        WCHAR wszFileName[MAX_PATH];
        CString csFileName, csFileTitle;
        CString csRegPath(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Applications");
        VIRTUALKEY *Key;

        if (GetModuleFileName(NULL, wszFileName, MAX_PATH))
        {
            csFileName = wszFileName;
            csFileName.GetLastPathComponent(csFileTitle);
            csRegPath.AppendPath(csFileTitle);

            Key = VRegistry.AddKey(csRegPath.Get());
            if (Key)
            {
                Key->AddValue(L"FILEOPENBOGUSCTRLID", REG_SZ, 0, 0);                
                LOGN(eDbgLevelInfo, "Added FILEOPENBOGUSCTRLID value for app %S", csFileTitle.Get());
            }
        }
    }
    CSTRING_CATCH
    {
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Known different values from Win9x.

 History:

    05/04/2000 linstev  Created

--*/

void
BuildExpanders(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion");
    if (key)
    {
        // These are REG_EXPAND_SZ on NT and REG_SZ on Win9x
        key->AddExpander(L"DevicePath");
        key->AddExpander(L"ProgramFilesPath");
        key->AddExpander(L"WallPaperDir");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add DX7a Credentials.

 History:

    05/23/2000 linstev  Created

--*/

void
BuildDX7A(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\DirectX");
    if (key)
    {
        key->AddValue(L"Version", REG_SZ, (LPBYTE)L"4.07.00.0716");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add DXDIAG path.

 History:

    04/05/2001 mnikkel  Created

--*/

void
BuildDXDiag(char* /*szParam*/)
{
    VIRTUALKEY *key;
    WCHAR wszPathDir[MAX_PATH];   
    DWORD cchSize = GetSystemDirectoryW(wszPathDir, MAX_PATH);
    
    if (cchSize == 0 || cchSize > MAX_PATH)
    {
        DPFN( eDbgLevelError, "BuildDXDiag: GetSystemDirectory Failed");
        return;
    }
    
    if (FAILED(StringCchCat(wszPathDir, MAX_PATH,  L"\\dxdiag.exe")))
    {
       return;
    }    

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\DXDIAG.EXE");
    if (key)
    {
        key->AddValue(L"", REG_EXPAND_SZ, (LPBYTE)wszPathDir, 0);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add FullScreen == 1 to fix bug in Future Cop that makes it not always run
    in fullscreen mode.

 History:

    09/01/2000 linstev  Created

--*/

void
BuildFutureCop(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Electronic Arts\\Future Cop\\Settings");
    if (key)
    {
        key->AddValueDWORD(L"FullScreen", 0x01);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Return to Krondor attempts to find ACM drivers, this key was moved and renamed.
    Was: HKLM\System\CurrentControlSet\Control\MediaResources\ACM\MSACM.MSADPCM\drivers = msadp32.acm
    Is:  HKLM\Software\Microsoft\Windows NT\CurrentVersion\Drivers32\Msacm.Msadpcm = msadp32.acm
    Grab the current value from the registry, and build a virtual key and value

 History:

    09/06/2000 robkenny  Created

--*/

void
BuildKrondor(char* /*szParam*/)
{
    HKEY msadpcmKey;
    LONG error = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32",
        0, KEY_READ, &msadpcmKey);

    if (SUCCESS(error))
    {
        // Found the key, grab the name of the driver
        WCHAR driverName[MAX_PATH];
        DWORD driverNameSize = sizeof(driverName);
        DWORD driverNameType = REG_SZ;

        error = RegQueryValueExW(
            msadpcmKey, 
            L"MSACM.MSADPCM", 
            0, &driverNameType, 
            (LPBYTE)driverName, 
            &driverNameSize);

        if (SUCCESS(error))
        {
            // We got all the data, so we can now add the virtual key and value
            VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Control\\MediaResources\\ACM\\MSACM.MSADPCM");
            if (key)
            {
                key->AddValue(L"driver", REG_SZ, (LPBYTE)driverName, 0);
            }
        }

        RegCloseKey(msadpcmKey);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Redirect changes from CURRENT_USER to LOCAL_MACHINE.

 History:

    09/17/2000 linstev  Created

--*/

void
BuildProfile(char* /*szParam*/)
{
    VRegistry.AddRedirect(
        L"HKCU\\Software\\Microsoft\\Windows",
        L"HKLM\\Software\\Microsoft\\Windows");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

  In Spell it Deluxe setup, the path for the SpeechFonts DLL ECN_1K8.DLL is 
  hardcoded to " C:\Voices32". If the installation is on a D: partition, the
  LoadLibraryA( ) call fails and the App AV's. 
  Now the current partition drive will be taken and added to the path.

 History:

    09/21/2000 prashkud  Created

--*/

void
BuildSpellItDeluxe(char* /*szParam*/)
{
    HKEY hSpeechFonts;
    WCHAR wszSystemDir[MAX_PATH], wszPathDir[MAX_PATH];
       
    if (GetSystemDirectory(wszSystemDir, MAX_PATH))
    {
        *(wszSystemDir+3) = L'\0';
    }
    else
    {
        DPFN( eDbgLevelError, "SpellIt: GetSystemDirectory Failed");
        return;
    }
    
    
    if (FAILED(StringCchCopy(wszPathDir, MAX_PATH, wszSystemDir)))
    {
       return;
    }
    if (FAILED(StringCchCat(wszPathDir, MAX_PATH, L"Voices32")))
    {
       return;
    }

    LONG error = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        L"Software\\FirstByte\\ProVoice\\SpeechFonts",
        0, KEY_READ | KEY_WRITE, &hSpeechFonts);

    if (SUCCESS(error))
    {
        if (FAILED(RegSetValueExW(
            hSpeechFonts,
            L"Path",
            0,
            REG_SZ,
            (LPBYTE) wszPathDir,
            wcslen(wszPathDir) * sizeof(WCHAR))))                          
        {
            DPFN( eDbgLevelError, "SpellIt: RegSetValueEx failed");
        }

        RegCloseKey(hSpeechFonts);
    }
    else
    {
        DPFN( eDbgLevelError, "SpellIt: RegOpenKeyExW failed");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Some applications need internet explorer for their functionality. The 
    applications try get the version of the internet explorer from the following 
    registry key : HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion. But 
    under WHISTLER environment, the key entry will not be created. So, the apps 
    fail to continue.

    The app looks for the version info of the Internet Explorer in the registry
    at HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion from the "Plus! 
    VersionNumber" Key. In WHISTLER the key will not be created in the registry. 

    To solve the problem we use Virtual Registry Keys. So, the app will assume 
    the key is existing in the registry.

    WHISTLER, by default, will install I.E.6. So, I have created the key as 
    "IE 6 6.0.2404.0000" and this is the latest version of I.E. on WHISTLER as 
    on today.(11/22/2000).

 History:

    11/22/2000 v-rbabu  Created
    07/03/2001 linstev  Added IE 5.5 from Win2k 

--*/

void
BuildIE401(char* /*szParam*/)
{
    
    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Internet Explorer");
    if (key)
    {
        key->AddValue(L"Version", REG_SZ, (LPBYTE)L"4.72.2106.9", 0);
    }
}

void
BuildIE55(char* /*szParam*/)
{
    
    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Internet Explorer");
    if (key)
    {
        key->AddValue(L"Version", REG_SZ, (LPBYTE)L"5.50.4522.1800", 0);
    }
}

void
BuildIE60(char* /*szParam*/)
{
    WCHAR wIE[] = L"IE 6 6.0.2404.0000";
    
    // Now add the virtual key and value
    VIRTUALKEY *key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"Plus! VersionNumber", REG_SZ, (LPBYTE)wIE, 0);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    The idea here is to fix apps that depend on short names for input devices.
    We just trim the name to 32 characters (including terminator).
    
 History:

    12/06/2000 linstev  Created

--*/

void
BuildJoystick(char* /*szParam*/)
{
    HKEY hJoystickKey;    
    WCHAR wszKeyName[MAX_PATH];
    DWORD dwIndex;

    const WCHAR wszJoystickPath[] = L"System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM";

    if (FAILURE(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszJoystickPath, 0, KEY_READ, &hJoystickKey)))
    {
        DPFN( eDbgLevelSpew, "[Joystick hack] No joysticks found");
        return;
    }
    
    //
    // Enum the keys under Joystick and make virtual entries 
    //

    dwIndex = 0;

    while (SUCCESS(RegEnumKeyW(hJoystickKey, dwIndex, wszKeyName, MAX_PATH)))
    {
        WCHAR wszID[MAX_PATH] = L"HKLM\\";
        if (SUCCEEDED(StringCchCat(wszID, MAX_PATH, wszJoystickPath)) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH, L"\\")) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH, wszKeyName)))
        {
           HKEY hkOEM;
           if (SUCCESS(RegOpenKeyExW(hJoystickKey, wszKeyName, 0, KEY_READ, &hkOEM)))
           {
               WCHAR wszName[MAX_PATH + 1];
               DWORD dwSize = MAX_PATH * sizeof(WCHAR);
               if (SUCCESS(RegQueryValueExW(hkOEM, L"OEMName", 0, NULL, (LPBYTE) wszName, &dwSize)))
               {
                   if (dwSize > 31 * sizeof(WCHAR))
                   {
                       VIRTUALKEY *key = VRegistry.AddKey(wszID);
                       if (key)
                       {
                           dwSize = 31 * sizeof(WCHAR);
                           wszName[31] = L'\0';
                           key->AddValue(L"OEMName", REG_SZ, (LPBYTE) wszName);
                       }
                   }
               }
   
               RegCloseKey(hkOEM);
           }
        }

        dwIndex++;
    }
    
    RegCloseKey(hJoystickKey);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Adobe Illustrator 8

 History:

    12/18/2000 linstev  Created

--*/

void
BuildIllustrator8(char* /*szParam*/)
{
    if (ShouldApplyShim())
    {
        // Redirect everything 
        VRegistry.AddRedirect(
            L"HKLM\\Software\\Adobe",
            L"HKCU\\Software\\Adobe");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Adobe PageMaker 6.5

 History:

    02/27/2001 maonis Created

--*/

void BuildPageMaker65(char* /*szParam*/)
{
    if (ShouldApplyShim())
    {
        VRegistry.AddRedirect(
            L"HKCU\\Software\\Adobe\\PageMaker65",
            L"HKLM\\Software\\Adobe\\PageMaker65");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for PageKeepPro30.
    
 History:

    01/15/2000 maonis  Created

--*/

void
BuildPageKeepProDirectory(char* /*szParam*/)
{
    // We cannot call ShGetSpecialFolderPath since we are still in our DLL main,
    // so we get the path to "My Documents" directly from the registry.
    HKEY hkFolders;
    if (SUCCESS(RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders", 0, KEY_READ, &hkFolders)))
    {
        DWORD dwType;
        WCHAR wszPath[MAX_PATH];
        DWORD dwSize = MAX_PATH*sizeof(WCHAR);

        if (SUCCESS(RegQueryValueExW( hkFolders, L"Personal", NULL, &dwType, (LPBYTE)wszPath, &dwSize)))
        {
            VIRTUALKEY *key = VRegistry.AddKey(L"HKCU\\Software\\Caere Corp\\PageKeepPro30\\Preference");
            if (key)
            {
                key->AddValue(L"Directory", REG_EXPAND_SZ, (LPBYTE)wszPath, 0);
            }
        }
        RegCloseKey(hkFolders);
    }

    // Secondly, since we don't support using UI-less mode for TWAIN layer 
    // we mandatorily set BASICMODE for scanners to 2 instead of 0 - 2 means
    // to always use UI mode.
    HKEY hkScanners;
    WCHAR wszKeyName[MAX_PATH] = L"";
    DWORD dwIndex;

    const WCHAR wszScanner[] = L"Software\\Caere Corp\\Scan Manager\\4.02\\Scanners";

    if (FAILURE(RegOpenKeyExW(HKEY_LOCAL_MACHINE, wszScanner,0, KEY_READ, &hkScanners)))
    {
        DPFN( eDbgLevelSpew, "[PageKeepPro 3.0] No scanner found");
        return;
    }
    
    dwIndex = 0;

    while (SUCCESS(RegEnumKeyW(hkScanners, dwIndex, wszKeyName, MAX_PATH)))
    {
        WCHAR wszID[MAX_PATH] = L"HKLM\\";
        
        if (SUCCEEDED(StringCchCat(wszID, MAX_PATH,wszScanner)) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH,L"\\")) &&
            SUCCEEDED(StringCchCat(wszID, MAX_PATH,wszKeyName)))
        {        
           HKEY hkScanner;
           if (SUCCESS(RegOpenKeyExW(hkScanners, wszKeyName, 0, KEY_READ, &hkScanner)))
           {
               VIRTUALKEY *keyMode = VRegistry.AddKey(wszID);
               if (keyMode)
               {
                   keyMode->AddValueDWORD(L"BASICMODE", 2);
               }
   
               RegCloseKey(hkScanner);
           }
        }

        dwIndex++;
    }
    
    RegCloseKey(hkScanners);

}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for ModemWizard because the keys moved

 History:

    01/18/2001 linstev & a-leelat Created

--*/

void
BuildModemWizard(char* /*szParam*/)
{
    // Redirect everything 
    VRegistry.AddRedirect(
        L"HKLM\\SYSTEM\\CurrentControlSet\\Enum\\Root",
        L"HKLM\\SYSTEM\\CurrentControlSet\\Enum");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Office2000 Developer 1.5 which looks in the wrong place for 
    components. 

    From ChetanP:

        Basically the redirect code would have to do something like this -

        if HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\UserData\<user sid>\Components\359E92CC2CB71D119A12000A9CE1A22A
            exists, redirect to that location
        else if HKLM\Software\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Components\359E92CC2CB71D119A12000A9CE1A22A
            exists, redirect to that location
        else, no redirection.

    Whistler Bug #241596

 History:

    02/01/2001 linstev  Created

--*/

#define SIZE_OF_TOKEN_INFORMATION                 \
    sizeof(TOKEN_USER) +                          \
    sizeof(SID) +                                 \
    sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES

#define SIZE_OF_SID_MAX                           \
    sizeof(SID) +                                 \
    SID_MAX_SUB_AUTHORITIES * sizeof(DWORD) 

#define cchMaxSID                               256

//
// Get the current SID as text
//

BOOL 
GetStringSID(
    WCHAR *szSID
    )
{
    BOOL bRet = TRUE;
    HANDLE hToken = NULL;
    int i;
    PISID pISID;
    UCHAR rgSID[SIZE_OF_SID_MAX];
    UCHAR TokenInformation[SIZE_OF_TOKEN_INFORMATION];
    ULONG ReturnLength;
    WCHAR Buffer[cchMaxSID];

    // 
    // Get a token
    //
    
    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_IMPERSONATE | TOKEN_QUERY, 
            TRUE, 
            &hToken))
    {
        if (GetLastError() == ERROR_NO_TOKEN)
        {
            bRet = OpenProcessToken(
                GetCurrentProcess(), 
                TOKEN_IMPERSONATE | TOKEN_QUERY, 
                &hToken);
        }
        else
        {
            bRet = FALSE;
        }
    }

    if (!bRet) 
    {
        DPFN( eDbgLevelError, "[GetStringSID] Failed to OpenProcessToken");
        goto Exit;
    }

    // 
    // Get the binary form of the token
    //

    bRet = GetTokenInformation(
        hToken,
        TokenUser,
        TokenInformation,
        sizeof(TokenInformation),
        &ReturnLength);

    if (bRet)
    {
        bRet = FALSE;
        pISID = (PISID)((PTOKEN_USER) TokenInformation)->User.Sid;
    
        if (!CopySid(SIZE_OF_SID_MAX, rgSID, pISID))
        {
            DPFN( eDbgLevelError, "CopySID failed");
            goto Exit;
        }
    
        //
        // Get the text form of the token
        //
        
        HRESULT hr = StringCchPrintf(Buffer, cchMaxSID,L"S-%u-", (USHORT) pISID->Revision);
        if (FAILED(hr))
        {
           goto Exit;
        }
        hr = StringCchCopy(szSID, 1024, Buffer);
        if (FAILED(hr))
        {
           goto Exit;
        }        
    
        if ((pISID->IdentifierAuthority.Value[0] != 0) ||
            (pISID->IdentifierAuthority.Value[1] != 0))
        {
            hr = StringCchPrintf(Buffer, cchMaxSID,
                                 L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                                 (USHORT) pISID->IdentifierAuthority.Value[0],
                                 (USHORT) pISID->IdentifierAuthority.Value[1],
                                 (USHORT) pISID->IdentifierAuthority.Value[2],
                                 (USHORT) pISID->IdentifierAuthority.Value[3],
                                 (USHORT) pISID->IdentifierAuthority.Value[4],
                                 (USHORT) pISID->IdentifierAuthority.Value[5]);
            if (FAILED(hr))
            {
               goto Exit;
            }

            hr = StringCchCat(szSID, 1024, Buffer);
            if (FAILED(hr))
            {
               goto Exit;
            }
        } 
        else 
        {
            ULONG Tmp = 
                (ULONG) pISID->IdentifierAuthority.Value[5]         +
                (ULONG)(pISID->IdentifierAuthority.Value[4] <<  8)  +
                (ULONG)(pISID->IdentifierAuthority.Value[3] << 16)  +
                (ULONG)(pISID->IdentifierAuthority.Value[2] << 24);
    
            hr = StringCchPrintf(Buffer, cchMaxSID, L"%lu", Tmp);
            if (FAILED(hr))
            {
               goto Exit;
            }
            hr = StringCchCat(szSID, 1024, Buffer);
            if (FAILED(hr))
            {
               goto Exit;
            }
        }
    
        for (i=0; i < pISID->SubAuthorityCount; i++) 
        {
            hr = StringCchPrintf(Buffer, cchMaxSID, L"-%lu", pISID->SubAuthority[i]);
            if (FAILED(hr))
            {
               goto Exit;
            }

            hr = StringCchCat(szSID, 1024, Buffer);
            if (FAILED(hr))
            {
               goto Exit;
            }            
        }
    }
    else
    {
        DPFN( eDbgLevelError, "GetTokenInformation failed");
        goto Exit;
    }

    bRet = TRUE;
Exit:
    if (hToken)
    {
        CloseHandle(hToken);
    }
    return bRet;
}

void
BuildMSI(char* /*szParam*/)
{
    WCHAR szSID[1024];

    // Get the current users SID as a string
    if (!GetStringSID(szSID))
    {
        DPFN( eDbgLevelError, "BuildMSI Failed");
        return;
    }

    HKEY hKey;
    WCHAR szTemp[1024];

    const WCHAR szBase[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\";
    const WCHAR szComp[] = L"\\Components\\359E92CC2CB71D119A12000A9CE1A22A";

    HRESULT hr;
    hr = StringCchCopy(szTemp, 1024, szBase);
    if (FAILED(hr))
    {
       return;
    }
    hr = StringCchCat(szTemp, 1024, szSID);
    if (FAILED(hr))
    {
       return;
    }
    hr = StringCchCat(szTemp, 1024, szComp);
    if (FAILED(hr))
    {
       return;
    }
    // Attempt to open szBase + <user sid> + szComp
    if (RegOpenKeyW(HKEY_LOCAL_MACHINE, szTemp, &hKey) != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);

        // Attempt to open szBase + S-1-5-18 + szComp
        hr = StringCchCopy(szTemp, 1024, szBase);
        if (FAILED(hr))
        {
           return;
        }
        hr = StringCchCat(szTemp, 1024, L"S-1-5-18");
        if (FAILED(hr))
        {
           return;
        }
        hr = StringCchCat(szTemp, 1024, szComp);
        if (FAILED(hr))
        {
           return;
        }

        if (RegOpenKeyW(HKEY_LOCAL_MACHINE, szTemp, &hKey) != ERROR_SUCCESS)
        {
            DPFN( eDbgLevelError, "BuildMSI Failed to find keys");
            RegCloseKey(hKey);
            return;
        }
    }

    // Redirect as appropriate
    WCHAR szTarget[1024] = L"HKLM\\";
    hr = StringCchCat(szTarget,1024, szTemp);
    if (FAILED(hr))
    {
       return;
    }
    VRegistry.AddRedirect(
        L"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Components\\359E92CC2CB71D119A12000A9CE1A22A",
        szTarget);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Added FileNet Web Server

 History:

    02/06/2001 a-larrsh  Created

--*/

void 
BuildFileNetWebServer(char* /*szParam*/)
{
    VIRTUALKEY *key;    

    key = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Services\\W3SVC\\Parameters");
    if (key)
    {
        key->AddValueDWORD(L"MajorVersion", 0x00000005);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Added default printer key. We have to effectively delay load this, because 
    we can't be guaranteed that winspool will have had it's init routine loaded
    before us. Of course, we still can't guarentee that somebody won't try to 
    get at this key from their dllmain, so we wrap the whole thing in an 
    exception handler.

 History:

    02/06/2001 linstev & mnikkel Created

--*/

LONG 
WINAPI
VR_Printer(
    OPENKEY * /* key */,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue
    )
{
    LOGN( eDbgLevelInfo, "[Printer] Query for legacy printer");

    __try 
    {
        DWORD dwSize;

        // Get the default printer name
        if (GetDefaultPrinterW(NULL, &dwSize) == 0)
        {
            // Now that we have the right size, allocate a buffer
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                LPWSTR pszName = (LPWSTR) malloc(dwSize * sizeof(WCHAR));
                if (pszName)
                {
                    // Now get the default printer with the right buffer size.
                    if (GetDefaultPrinterW(pszName, &dwSize))
                    {
                        //
                        // Set up the virtual value. Note we don't have free the 
                        // memory since it's a once off allocation that persists 
                        // with the value
                        //
                        vvalue->cbData = dwSize * sizeof(WCHAR);
                        vvalue->lpData = (LPBYTE) pszName;

                        //
                        // Never call us again, since we've found the printer and
                        // stored it in our virtual value
                        //
                        vvalue->pfnQueryValue = NULL;
                        return ERROR_SUCCESS;
                    }
                    else
                    {
                        //
                        // We failed to get the default printer, may as well 
                        // clean up gracefully.
                        //

                        free(pszName);
                    }
                }

            }
        }
        
        DPFN( eDbgLevelError, "[Printer] No printers found or out of memory");
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPFN( eDbgLevelError, "[Printer] Exception encountered, winspool not initialized?");
    }

    //
    // Going for the graceful exit: there's no default printer or we get an 
    // error trying to find it.
    //
    
    return ERROR_FILE_NOT_FOUND;
}

void
BuildPrinter(char* /*szParam*/)
{
    VIRTUALKEY *key;
    
    key = VRegistry.AddKey(L"HKCC\\System\\CurrentControlSet\\Control\\Print\\Printers");
    
    if (key)
    {
        VIRTUALVAL *val = key->AddValue(L"Default", REG_SZ, 0, 0);
        if (val)
        {
            val->pfnQueryValue = VR_Printer;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    The app is multi-threaded, but the app sets the DX DDSCL_MULTITHREADED flag 
    too late: after D3D is initialized. This hack basically turns on 
    multi-threaded locking for D3D.

 History:

    02/27/2001 rankala + ssteiner  Created

--*/

void
BuildStarTrekArmada(char* /*szParam*/)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\SOFTWARE\\Microsoft\\Direct3D");
    if (key)
    {
        key->AddValueDWORD(L"DisableST", 1);
    }
}

/*++

 Function Description:

    This function gets called whenever the app queries for "Health" value.This 
    is not set properly by the app and this causes the app not to function 
    properly. We fix this issue by obtaining the right path which the app sets 
    in another registry key and sending that back as the value for "Health".

 History:

    05/04/2001 prashkud  Created

--*/

LONG 
WINAPI
VR_MSA2001(
    OPENKEY * /* key */,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue
    )
{
    HKEY hPath = NULL;
    LONG lRet = ERROR_SUCCESS;

    CSTRING_TRY
    {
        CString csBody5Reg(L"Software\\Classes\\Body5\\Open\\Shell\\Command");        
        WCHAR wPath[MAX_PATH];
        DWORD dwSize = MAX_PATH*sizeof(WCHAR);
            
        if (FAILURE(lRet = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    csBody5Reg.Get(),
                    0, KEY_READ, &hPath)))
        {
            DPFN(eDbgLevelError, "MSA2001: RegOpenKeyExW failed");
            goto exit;
        }

        if (FAILURE( lRet = RegQueryValueExW(
                hPath, L"",    // Default value
                0, NULL, (LPBYTE)wPath, &dwSize)))                          
        {
            DPFN(eDbgLevelError, "MSA2001: RegQueryValueEx failed");
            goto exit;
        }           

        CString csPath(wPath);
        int len = csPath.Find(L" ");

        // We get the space in the string
        wPath[len] = L'\0';
        csPath = wPath;
        CString csPathName;
        csPath.GetNotLastPathComponent(csPathName);

        vvalue->cbData = (csPathName.GetLength()+1) * sizeof(WCHAR);
        vvalue->lpData = (LPBYTE) malloc(vvalue->cbData);
 
        if (!vvalue->lpData)
        {
            DPFN(eDbgLevelError, szOutOfMemory);
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        MoveMemory(vvalue->lpData, csPathName.Get(), vvalue->cbData);
        DPFN(eDbgLevelInfo, "MSA2001: The data value is %S",csPathName.Get());

        lRet = ERROR_SUCCESS;
        vvalue->dwType = REG_SZ;

        return lRet;        
    }
    CSTRING_CATCH
    {
    }

exit:
    if (hPath)
    {
        RegCloseKey(hPath);
    }

    return lRet;
}

/*++

 Function Description:


 History:

    04/27/2001 prashkud  Created

--*/

void
BuildMSA2001(char* /*szParam*/)
{
    VIRTUALKEY *Key = VRegistry.AddKey(L"HKLM\\Software\\Encore Software\\Middle School Advantage 2001\\1.0");

    if (Key)
    {
        VIRTUALVAL *val = Key->AddValue(L"health", REG_SZ, 0, 0);
        if (val) 
        {
            val->pfnQueryValue = VR_MSA2001;
            DPFN(eDbgLevelInfo, "[Middle School Advantage 2001]  Added Health");
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Hack for Nowro Blue (Korean App)

 History:

    05/17/2001 hioh Created

--*/

void BuildNowroBlue(char* /*szParam*/)
{
    // Below HKCU include location of files.
    // Non install user could not locate files and could not run app properly.
    // Redirect from HKCU to HKLM for commonly use.
    VRegistry.AddRedirect(
        L"HKCU\\Software\\nowcom",
        L"HKLM\\Software\\nowcom");
    VRegistry.AddRedirect(
        L"HKCU\\Software\\nowirc",
        L"HKLM\\Software\\nowirc");
    VRegistry.AddRedirect(
        L"HKCU\\Software\\nownuri",
        L"HKLM\\Software\\nownuri");
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    To enable the trial version, WebWasher looks for RegisteredOrganization at:

      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion

    rather than:

      HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion

 History:

    05/31/2001 stevepro Created

--*/

void
BuildRegisteredOwner(char* /*szParam*/)
{
    HKEY hkCurrentVersion;

    if (FAILURE(RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &hkCurrentVersion)))
    {
        return;
    }

    // Read the registered owner values from the old location
    WCHAR szOrg[MAX_PATH];
    *szOrg = L'\0';
    DWORD dwSize = ARRAYSIZE(szOrg);
    if (FAILURE(RegQueryValueExW(
                        hkCurrentVersion,
                        L"RegisteredOrganization",
                        NULL,
                        NULL,
                        (LPBYTE)szOrg,
                        &dwSize)))
    {
       RegCloseKey(hkCurrentVersion);
       return;
    }

    WCHAR szOwner[MAX_PATH];
    *szOwner = L'\0';
    dwSize = ARRAYSIZE(szOwner);
    if (FAILURE(RegQueryValueExW(
       hkCurrentVersion,
       L"RegisteredOwner",
       NULL,
       NULL,
       (LPBYTE)szOwner,
       &dwSize)))
    {
       RegCloseKey(hkCurrentVersion);
       return;
    }

    RegCloseKey(hkCurrentVersion);

    // Add them as virtual values to the new location
    if (*szOrg || *szOwner)
    {
        VIRTUALKEY *pKey = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion");
        if (pKey)
        {
            if (*szOrg)
            {
                pKey->AddValue(L"RegisteredOrganization", REG_SZ, (LPBYTE)szOrg);
            }

            if (*szOwner)
            {
                pKey->AddValue(L"RegisteredOwner", REG_SZ, (LPBYTE)szOwner);
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    The ACT CD of Princeton review looks for and, if not found, creates an "MSN"
    key illegally in the root of HKLM. Win9x allows this, but Win2k does not. 
    This fix will redirect the program to look in the normal location for this
    key.
    

 History:

    02/22/2001 a-noahy Created

--*/

void
BuildPrincetonACT(char* /*szParam*/)
{
    VRegistry.AddRedirect(
        L"HKLM\\MSN",
        L"HKLM\\Software\\Microsoft\\MSN");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Fix for HEDZ which uses the registry to determine the resolution

 History:

    06/28/2001 linstev  Created

--*/

void
BuildHEDZ(char* /*szParam*/)
{
    VIRTUALKEY *key;

    //
    // Add just what this app needs - don't bother with full emulation of this 
    // part of the registry
    //
    key = VRegistry.AddKey(L"HKLM\\Config\\0001\\Display\\Settings");
    if (key)
    {
        WCHAR wzRes[10];
        DWORD dwCX, dwCY;
        key->AddValue(L"BitsPerPixel", REG_SZ, (LPBYTE)L"16");
        dwCX = GetSystemMetrics(SM_CXSCREEN);
        dwCY = GetSystemMetrics(SM_CYSCREEN);
        if (FAILED(StringCchPrintfW(
                                 wzRes, 10, L"%d,%d", dwCX, dwCY)))
        {
           return;
        }

        key->AddValue(L"Resolution", REG_SZ, (LPBYTE)wzRes);
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Called by BuildAirlineTycoon to recursively search for the key describing a CDROM

 History:

    08/07/2001 mikrause  Created

--*/

void FindCDROMKey(HKEY hKey, CString& csCurrentPath)
{   
    LONG lRet;
    DWORD dwKeyNameSize = MAX_PATH;
    WCHAR wszKeyName[MAX_PATH];
    HKEY hSubKey;
    DWORD dwIndex = 0;

    // Recurse into all subkeys.
    while( ORIGINAL_API(RegEnumKeyExW)(hKey, dwIndex, wszKeyName, &dwKeyNameSize,
        NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        lRet = ORIGINAL_API(RegOpenKeyExW)(hKey, wszKeyName, 0, KEY_READ, &hSubKey);
        if (lRet == ERROR_SUCCESS)
        {
            // Add this key to the path
            csCurrentPath += L"\\";
            csCurrentPath += wszKeyName;

            // Check this key's subkeys.                        
            FindCDROMKey(hSubKey, csCurrentPath);
            ORIGINAL_API(RegCloseKey)(hSubKey);

            // Trim the path back.
            int index = csCurrentPath.ReverseFind(L'\\');
            csCurrentPath.Truncate(index);
        }

        dwKeyNameSize = MAX_PATH;
        dwIndex++;
    }

    // Check if this key has a Class value equal to "cdrom"

    DWORD dwDataSize;
    BYTE pData[MAX_PATH*sizeof(WCHAR)];

    DWORD dwType;

    dwDataSize = MAX_PATH * sizeof(WCHAR);

    lRet = ORIGINAL_API(RegQueryValueExW)(hKey, L"CLASS", NULL, &dwType, pData,
        &dwDataSize);
    if ( (lRet == ERROR_SUCCESS) && (dwType == REG_SZ)
        && (_wcsicmp((LPWSTR)pData, L"CDROM")==0))
    {                         
        // Get location information on the device
        WCHAR wszLocationInformation[MAX_PATH];
        DWORD dwLocInfoSize = MAX_PATH * sizeof(WCHAR);
        
        lRet = ORIGINAL_API(RegQueryValueExW)(hKey, L"LocationInformation",
            NULL, &dwType, (BYTE*)wszLocationInformation, &dwLocInfoSize);
        if ( (lRet == ERROR_SUCCESS) && (dwType == REG_SZ))
        {
            // Create the device name (like "\\?\cdrom0\".
            CString csDevice = L"\\\\?\\cdrom";
            csDevice += wszLocationInformation;
            csDevice += L"\\";

            // Find which volume name this is mapped to.
            WCHAR wszCDRomMountPoint[50];
            if (GetVolumeNameForVolumeMountPoint(csDevice.Get(),
                wszCDRomMountPoint, 50))
            {
                // Find which drive this is mapped to.
                WCHAR wszDriveMountPoint[50];
                WCHAR wszDrive[] = L"A:\\";
                
                // Find what drive has an identical volume mount point.
                for(; wszDrive[0] <= L'Z'; wszDrive[0]++)
                {                    
                    if (GetVolumeNameForVolumeMountPoint(wszDrive,
                        wszDriveMountPoint, 50))
                    {
                        // Check if the CD-ROM and this disk drive
                        // map to the same volume.
                        if (_wcsicmp(wszDriveMountPoint, wszCDRomMountPoint)==0)
                        {
                            // Add a value to the CD-ROM key.
                            VIRTUALKEY* key = VRegistry.AddKey(csCurrentPath);
                            if (key)
                            {
                                // Only use a single letter.
                                wszDrive[1] = L'\0';
                                VIRTUALVAL* val =
                                    key->AddValue(L"CurrentDriveLetterAssignment",
                                        REG_SZ, (BYTE*) wszDrive, sizeof(WCHAR));
                                if (val)
                                {
                                    DPFN(eDbgLevelInfo,
                                        "[Airline Tycoon]Added drive letter \
                                        %S for %S to PNP data", wszDrive,
                                        csDevice.Get());
                                }
                            }
                            break;
                        }
                    }        
                }
            }
        }                
    }    
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Fix for Airline Tycoon which uses PNP registry entries to determine the
    drive letter assignments for CD-ROM drives.

 History:

    08/07/2001 mikrause  Created

--*/

void
BuildAirlineTycoon(char* /*szParam*/)
{    
    // Search for CD-ROM keys in the registry.
    HKEY hKey;
    LONG lRet;
    lRet = ORIGINAL_API(RegOpenKeyExW)(HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Enum", 0, KEY_READ, &hKey);
    if (lRet != ERROR_SUCCESS)
    {
        DPFN(eDbgLevelError, "[AirlineTycoon] Cannot open ENUM key!");
        return;
    }

    // Enumerate subkeys
    CString csBasePath = L"HKLM\\System\\CurrentControlSet\\Enum";
    FindCDROMKey(hKey, csBasePath);

    ORIGINAL_API(RegCloseKey)(hKey);

    // Set up so that PNP data is redirected.
    BuildDynData("");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

   Sets the DirectSound acceleration level the app will be allowed to use.

 Arguments:

    szParam - Command line of the form: accellevel | device1 | device2 | ...
              Accellevel is the device acceleration level, and devices 1 through n
              are the devices to apply to.
              Accellevel can be: NONE, STANDARD, or FULL
              Devices can be: EMULATEDRENDER, KSRENDER, EMULATEDCAPTURE, KSCAPTURE 

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSDevAccel(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;

    DWORD dwAccelLevel;
    DWORD dwDevices = 0;

    if (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"NONE")==0)
        {
            dwAccelLevel = DSAPPHACK_ACCELNONE;
        }
        else if (csTok.CompareNoCase(L"STANDARD")==0)
        {
            dwAccelLevel = DSAPPHACK_ACCELSTANDARD;
        }
        else if (csTok.CompareNoCase(L"FULL")==0)
        {
            dwAccelLevel = DSAPPHACK_ACCELFULL;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSDEVACCEL] Invalid Acceleration Level %s", csTok.GetAnsi());
            return;
        }
    }
    else
    {
        DPFN(eDbgLevelError, "[DSDEVACCEL] Invalid Parameters");
        return;
    }

    while (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSDEVACCEL] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSDEVACCEL] No devices specified.");
        return;
    }

    if (AddDSHackDeviceAcceleration(dwAccelLevel, dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSDEVACCEL] Unabled to add DirectSound hack");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Makes IDirectSoundBuffer::GetCurrentPosition() tell the app
    that the play and write cursors are X milliseconds further
    along than they really are.
 
 Arguments:

    szParam - Command line of the form: milliseconds
              Where milliseconds is the number of milliseconds to pad the cursors.

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSPadCursors(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CString csParam(szParam);
    DWORD dwMilliseconds = 0;

    dwMilliseconds = atol(csParam.GetAnsi());
    if ( dwMilliseconds == 0)
    {
        DPFN(eDbgLevelWarning, "[DSPADCURSORS] Invalid number of milliseconds");
        return;
    }

    if (AddDSHackPadCursors(dwMilliseconds) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSPADCURSORS] Unabled to add DirectSound hack");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Caches the positions of the cursors for apps that abuse
    IDirectSoundBuffer::GetCurrentPosition().

 Arguments:
    szParam - Command line of the form: Dev1 | Dev2 | . . .
              Devices affected.  See BuildDSDevAccel().

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSCachePositions(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;
   
    DWORD dwDevices = 0;

    while (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSCACHEPOSITIONS] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSCACHEPOSITIONS] No devices specified.");
        return;
    }

    if (AddDSHackCachePositions(dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSCACHEPOSITIONS] Unabled to add DirectSound hack");
    }
}

/*++

 Function Description:

    When the app asks for the play cursor, we give it the
    write cursor instead.  The correct way to stream audio
    into a looping dsound buffer is to key off the write cursor,
    but some apps (e.g. QuickTime) use the play cursor instead.
    This apphacks alleviates them.
 
 Arguments:

    szParam - Parameters of the form dev1 | dev2 | . . . 
    See BuildDSDevAccel() for valid devices.

 History:

    08/10/2001 mikrause  Created

--*/
void
BuildDSReturnWritePos(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;
   
    DWORD dwDevices = 0;

    while (csParam.GetToken(csTok))
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] No devices specified.");
        return;
    }

    if (AddDSHackReturnWritePos(dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] Unabled to add DirectSound hack");
    }
}

/*++

 Function Description:

    Makes dsound always return a write position which is X
    milliseconds ahead of the play position, rather than
    the real write position. 
 
 Arguments:

    szParam - Milliseconds of padding.

 History:

    08/10/2001 mikrause  Created

--*/


void
BuildDSSmoothWritePos(
    char* szParam)
{
    // No Try/Catch needed, already in ParseCommandLine
    CString csParam(szParam);
    DWORD dwMilliseconds = 0;

    dwMilliseconds = atol(csParam.GetAnsi());
    if ( dwMilliseconds == 0)
    {
        DPFN(eDbgLevelWarning, "[DSSMOOTHWRITEPOS] Invalid number of milliseconds");
        return;
    }

    if (AddDSHackSmoothWritePos(dwMilliseconds) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSSMOOTHWRITEPOS] Unabled to add DirectSound hack");
    }
    else
    {
        DPFN(eDbgLevelInfo, "[DSSMOOTHWRITEPOS] Added DS Hack Smooth Write Pos, %d ms",
            dwMilliseconds);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

     NortonAntiVirus trys to set the registry value to hide the language bar.
     Protecting the registry value.

 History:

    01/02/2002 mamathas Created

--*/

void BuildNortonAntiVirus(char* /*szParam*/)
{    
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKCU\\Software\\Microsoft\\CTF\\LangBar");
    if (key)
    {
        // Block all writes to ShowStatus
        key->AddProtector(L"ShowStatus");
    }
}


///////////////////////////////////////////////////////////////////////////////

/*++

 Function Description:

    Disabled some category of devices altogether, forces
    playback through emulated path.
 
 Arguments:

    szParam - Combination of device that this hack applies to, see BuildDSDevAccel().

 History:

    08/10/2001 mikrause  Created

--*/

void
BuildDSDisableDevice(
    char* szParam)
{
    // No try/catch needed.  Already done in ParseCommandLine
    CStringToken csParam(szParam, "|");
    CString csTok;
   
    DWORD dwDevices = 0;

    while (csParam.GetToken(csTok)==TRUE)
    {
        if (csTok.CompareNoCase(L"EMULATEDRENDER"))
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDRENDER;
        }
        else if (csTok.CompareNoCase(L"KSRENDER")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSRENDER;
        }
        else if (csTok.CompareNoCase(L"EMULATEDCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_EMULATEDCAPTURE;
        }
        else if (csTok.CompareNoCase(L"KSCAPTURE")==0)
        {
            dwDevices |= DSAPPHACK_DEV_KSCAPTURE;
        }
        else
        {
            DPFN(eDbgLevelError, "[DSDISABLEDEVICE] Unknown device %s", csTok.GetAnsi());
        }
    }

    if (dwDevices == 0)
    {
        DPFN(eDbgLevelError, "[DSDISABLEDEVICE] No devices specified.");
        return;
    }

    if (AddDSHackDisableDevice(dwDevices) == FALSE)
    {
        DPFN(eDbgLevelError, "[DSRETURNWRITEPOSITION] Unabled to add DirectSound hack");
    }
}

LONG WINAPI 
Delphi5SetValue(
    OPENKEY *key,
    VIRTUALKEY * /* vkey */,
    VIRTUALVAL *vvalue,
    DWORD dwType,
    const BYTE* pbData,
    DWORD cbData)
{
    // Only accept attempts to set a valid REG_SZ value.
    if (dwType == REG_SZ && !IsBadStringPtrW((PWSTR)pbData, cbData/sizeof(WCHAR)))
    {
       CSTRING_TRY
       {    
          CString csValue = (PWSTR)pbData;
      
          int idx = csValue.Find(L"InstReg.exe");
          
          // if we found "InstReg.exe" and the string does not begin w/ a quote, then
          // add quotes around the executable name
          if ((idx != -1) && (csValue[0] != L'\"'))
          {
             csValue.Insert(idx + lstrlenW(L"InstReg.exe"), L'\"');
             csValue.Insert(0, L'\"');
         
             return RegSetValueExW(key->hkOpen, vvalue->wName, 0, dwType, (BYTE*)csValue.Get(), 
                 (csValue.GetLength()+1)*sizeof(WCHAR));
          }
       }
       CSTRING_CATCH
       {
          DPFN(eDbgLevelError, "CString exception occured in Delphi5SetValue");
       }
    }              

    // Got here, something went wrong.  Default to normal RegSetValue
    return RegSetValueExW(key->hkOpen, vvalue->wName, 0, dwType, pbData, cbData);    
}

void
BuildDelphi5Pro(
    char* /* szParam */)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
    if (key)
    {
        key->AddCustomSet(L"BorlandReboot1", Delphi5SetValue);
    }
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

     Word Perfect Office Suite 2002 attempts to delete ODBC key during uninstall.
     Protecting the registry value.

 History:

    04/23/2002 garyma  Created

--*/

void BuildWordPerfect2002(char* /*szParam*/)
{    
    VRegistry.AddKeyProtector(L"HKLM\\Software\\ODBC");
}


///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

     IBM Director installs twgproc.dll in AppInit_DLLs.  This causes a hang
     in login for .net .   Protecting the registry value.

 History:

    08/20/2002 nikkel Created

--*/

void BuildIBMDirector(char* /*szParam*/)
{    
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows");
    if (key)
    {
        // Block all writes to AppInit_DLLs
        key->AddProtector(L"AppInit_DLLs");
    }
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Change the usual suspects for version lies

 History:

    09/05/2002 robkenny  Created

--*/

void
BuildVersionLie(
    LPCWSTR productName,
    LPCWSTR currentVersion,
    LPCWSTR currentBuildNumber,
    LPCWSTR csdVersion)
{
    VIRTUALKEY * key = VRegistry.AddKey(L"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion");
    if (key)
    {
        key->AddValue(L"ProductName",           REG_SZ, (LPBYTE)productName);
        key->AddValue(L"CurrentVersion",        REG_SZ, (LPBYTE)currentVersion);
        key->AddValue(L"CurrentBuildNumber",    REG_SZ, (LPBYTE)currentBuildNumber);
        key->AddValue(L"CSDVersion",            REG_SZ, (LPBYTE)csdVersion);
    }

}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add WinXP version number

 History:

    09/05/2002 robkenny  Created

--*/

void
BuildXpLie(char* /*szParam*/)
{
    BuildVersionLie(L"Microsoft Windows XP",
                    L"5.1",
                    L"2600",
                    L"");
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add WinXP SP1 version number

 History:

    09/05/2002 robkenny  Created

--*/

void
BuildXpSp1Lie(char* /*szParam*/)
{
    BuildVersionLie(L"Microsoft Windows XP",
                    L"5.1",
                    L"2600",
                    L"Service Pack 1");
}
///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add Win2K Sp2 version number

 History:

    09/05/2002 robkenny  Created

--*/

void
BuildWin2kSp2Lie(char* szParam)
{
    BuildVersionLie(L"Microsoft Windows 2000",
                    L"5.0",
                    L"2165",
                    L"Service Pack 2");
}
///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add Win2K Sp3 version number

 History:

    09/05/2002 robkenny  Created

--*/

void
BuildWin2kSp3Lie(char* szParam)
{
    BuildVersionLie(L"Microsoft Windows 2000",
                    L"5.0",
                    L"2165",
                    L"Service Pack 3");

}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Add redirector for WebSphere's Setup.

 History:

    11/13/2002 astritz  Created

--*/

void
BuildWebSphereSetup(char* szParam)
{
    VIRTUALKEY *key;

    key = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\services\\W3svc\\Parameters");
    if (key)
    {
        DWORD dwValue = 0x5;
        key->AddValueDWORD(L"MajorVersion", 0x5);
    }
}

///////////////////////////////////////////////////////////////////////////////

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\vregistry_dsound.h ===
#pragma once

#ifndef VREGISTRY_DSOUND_H
#define VREGISTRY_DSOUND_H

// DirectSound Acceleration levels.
#define DSAPPHACK_ACCELNONE     0xF
#define DSAPPHACK_ACCELSTANDARD 0x8
#define DSAPPHACK_ACCELFULL     0x0

// DirectSound Device Types
#define DSAPPHACK_DEV_EMULATEDRENDER	0x01
#define DSAPPHACK_DEV_KSRENDER          0x04
#define DSAPPHACK_DEV_EMULATEDCAPTURE	0x08
#define DSAPPHACK_DEV_KSCAPTURE         0x10

// Functions to set DirectSound app hacks.
BOOL AddDSHackDeviceAcceleration(DWORD dwAcceleration, DWORD dwDevicesAffected);
BOOL AddDSHackDisableDevice(DWORD dwDevicesAffected);
BOOL AddDSHackPadCursors(LONG lCursorPad);
BOOL AddDSHackReturnWritePos(DWORD dwDevicesAffected);
BOOL AddDSHackSmoothWritePos(LONG lCursorPad);
BOOL AddDSHackCachePositions(DWORD dwDevicesAffected);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\vregistry_dsound.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    VRegistry_DSound.cpp

 Abstract:

    Module to add DSound apphacks with VRegistry

 History:

    08/10/2001  mikrause    Created    

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)

#include <windows.h>
#include "shimhookmacro.h"
#include "vregistry.h"
#include "vregistry_dsound.h"

#define DSAPPHACK_MAXNAME   (MAX_PATH + 16 + 16)

BOOL AddDirectSoundAppHack(DWORD dwHack,DWORD dwParam1,DWORD dwParam2);
BOOL GetDirectSoundAppId(LPTSTR pszAppId);

// Available DirectSound hacks
#define DSAPPHACKID_DEVACCEL            1
#define DSAPPHACKID_PADCURSORS          2
#define DSAPPHACKID_CACHEPOSITIONS      3
#define DSAPPHACKID_RETURNWRITEPOS      4
#define DSAPPHACKID_SMOOTHWRITEPOS      5
#define DSAPPHACKID_DISABLEDEVICE       6

/*++

 Function Description:

    Sets the acceleration level the app will be allowed to use.
 
 Arguments:

    IN dwAcceleration - Acceleration level needed.
    IN dwDevicesAffected - Combination of device that this hack applies to.

 Notes:
    
    See vregistry_dsound.h for acceleration levels and device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackDeviceAcceleration(
    IN DWORD dwAcceleration,
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_DEVACCEL, dwAcceleration,
        dwDevicesAffected);
}

/*++

 Function Description:

    Disabled some category of devices altogether, forces
    playback through emulated path.
 
 Arguments:

    IN dwDevicesAffected - Combination of device that this hack applies to.

 Notes:
    
    See vregistry_dsound.h for device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackDisableDevice(
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_DISABLEDEVICE, dwDevicesAffected,
        0);
}

/*++

 Function Description:

    Makes IDirectSoundBuffer::GetCurrentPosition() tell the app
    that the play and write cursors are X milliseconds further
    along than they really are.
 
 Arguments:

    IN lCursorPad - Number of milliseconds to pad cursors.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackPadCursors(
    IN LONG lCursorPad)
{
    return AddDirectSoundAppHack(DSAPPHACKID_PADCURSORS, (DWORD)lCursorPad,
        0);
}

/*++

 Function Description:

    When the app asks for the play cursor, we give it the
    write cursor instead.  The correct way to stream audio
    into a looping dsound buffer is to key off the write cursor,
    but some apps (e.g. QuickTime) use the play cursor instead.
    This apphacks alleviates them.
 
 Arguments:

    IN dwDevicesAffected - Combination of devices to apply hack to.

 Notes:
    
    See vregistry_dsound.h for device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackReturnWritePos(
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_RETURNWRITEPOS, dwDevicesAffected,
        0);
}

/*++

 Function Description:

    Makes dsound always return a write position which is X
    milliseconds ahead of the play position, rather than
    the real write position. 
 
 Arguments:

    IN lCursorPad - Milliseconds of padding.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackSmoothWritePos(
    IN LONG lCursorPad)
{
    return AddDirectSoundAppHack(DSAPPHACKID_SMOOTHWRITEPOS, 1,
        (DWORD)lCursorPad);
}

/*++

 Function Description:

    Caches the play/write positions last returned by
    GetCurrentPosition(), and reuses them if the app
    calls it again within 5ms (great for apps that
    abuse GetCurrentPosition(), which is more expensive
    on WDM devices than it was on the Win9X VxD devices
    many of these games were tested with).  This hack
    should spring to mind if you see slow or jerky graphics
    or stop-and-go sound  the GetCurrentPosition() calls are
    probably pegging the CPU (to confirm, use debug spew
    level 6 on DSound.dll).
 
 Arguments:

    IN dwDevicesAffected - Combination of devices to apply this hack to.


 Notes:
    
    See vregistry_dsound.h for device types.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDSHackCachePositions(
    IN DWORD dwDevicesAffected)
{
    return AddDirectSoundAppHack(DSAPPHACKID_CACHEPOSITIONS, dwDevicesAffected,
        0);
}

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Adds a DirectSound app hack to the registry.
 
 Arguments:

    IN dwHack - ID of app hack to apply.
    IN dwParam1 - First parameter.  Depends on app hack.
    IN dwParam2 - Second paramter.  Depends on app hack.

 Notes:
    
    See vregistry_dsound.h for more information on specific hacks.

 Returns:
    
    True if app hack applied, false otherwise.

 History:

    08/10/2001 mikrause  Created

--*/

BOOL
AddDirectSoundAppHack(
    IN DWORD dwHack,
    IN DWORD dwParam1,
    IN DWORD dwParam2)
{
    WCHAR  wzAppID[MAX_PATH];
    LPWSTR wzValName;
    DWORD dwData[2];
    DWORD dwDataSize;
    VIRTUALKEY *dsoundKey;
    VIRTUALKEY *appKey;
    VIRTUALVAL *val;

    if (GetDirectSoundAppId(wzAppID) == FALSE)
    {
        DPFN(eDbgLevelError, "Unable to create DirectSound app ID");
        return FALSE;
    }    

    dwData[0] = dwParam1;
    dwData[1] = dwParam2;

    switch(dwHack)
    {
    case DSAPPHACKID_DEVACCEL:
        wzValName = L"DSAPPHACKID_DEVACCEL";
        dwDataSize = 2 * sizeof(DWORD);
        break;

    case DSAPPHACKID_PADCURSORS:
        wzValName = L"DSAPPHACKID_PADCURSORS";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    case DSAPPHACKID_CACHEPOSITIONS:
        wzValName = L"DSAPPHACKID_CACHEPOSITIONS";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    case DSAPPHACKID_RETURNWRITEPOS:
        wzValName = L"DSAPPHACKID_RETURNWRITEPOS";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    case DSAPPHACKID_SMOOTHWRITEPOS:
        wzValName = L"DSAPPHACKID_SMOOTHWRITEPOS";
        dwDataSize = 2 * sizeof(DWORD);
        break;

    case DSAPPHACKID_DISABLEDEVICE:
        wzValName = L"DSAPPHACKID_DISABLEDEVICE";
        dwDataSize = 1 * sizeof(DWORD);
        break;

    default:
        DPFN(eDbgLevelError, "Unknown DirectSound AppHack");
        return FALSE;
    }

    dsoundKey = VRegistry.AddKey(L"HKLM\\System\\CurrentControlSet\\Control\\MediaResources\\DirectSound\\Application Compatibility");
    if (dsoundKey == NULL)
    {
        DPFN(eDbgLevelError, "Cannot create virtual registry key");
        return FALSE;
    }

    appKey = dsoundKey->AddKey(wzAppID);
    if (appKey == NULL)
    {
        DPFN(eDbgLevelError, "Cannot create virtual registry key");
        return FALSE;
    }

    val = appKey->AddValue(wzValName,REG_BINARY,(BYTE*)dwData, dwDataSize);
    if (val == NULL)
    {
        DPFN(eDbgLevelError, "Cannot create virtual registry value");
        return FALSE;
    }

    DPFN(eDbgLevelWarning, "DirectSound Apphack \"%S\" enabled, arguments: %X %X", wzValName, dwData[0], dwData[1]);

    return TRUE;
}

// Arguments:
//   LPTSTR szExecPath: full pathname of the app (e.g. C:\program files\foo\foo.exe)
//   LPTSTR szExecName: executable name of the app (e.g. foo.exe)
//   LPTSTR pszAppId: returns the dsound app ID.  (Pass in an array of DSAPPHACK_MAXNAME TCHARs.)
// Return code:
//   BOOL: true if we obtained the application ID successfully.

///////////////////////////////////////////////////////////////////////////////
/*++

 Function Description:

    Gets an AppID for the running application.
 
 Arguments:
    IN OUT wzAppId: Buffer for the dsound app ID.  (Pass in an array of DSAPPHACK_MAXNAME TCHARs.)

 Returns:
    
    TRUE if app ID created, FALSE otherwise.

 History:

    08/10/2001 mikrause  Created

--*/
BOOL
GetDirectSoundAppId(
    IN OUT LPWSTR wzAppId)
{
    WCHAR wzExecPath[MAX_PATH];
    LPWSTR wzExecName;
    IMAGE_NT_HEADERS nth;
    IMAGE_DOS_HEADER dh;
    DWORD cbRead;
    DWORD dwFileSize;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL fSuccess = FALSE;

    __try
    {
        // Get the name of the running EXE, and its full path.
        if (GetModuleFileNameW(NULL, wzExecPath, MAX_PATH) == FALSE)
        {
            __leave;
        }

        wzExecName = wcsrchr(wzExecPath, L'\\');
        if (wzExecName == NULL)
        {
            __leave;;
        }

        wzExecName++;
        
        // Open the executable
        hFile = CreateFile(wzExecPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            __leave;
        }

        // Read the executable's DOS header
        fSuccess = ReadFile(hFile, &dh, sizeof(dh), &cbRead, NULL);
        if (!fSuccess || cbRead != sizeof(dh))
        {
            // Log("Unable to read DOS header");
            __leave;
        }    

        if (dh.e_magic != IMAGE_DOS_SIGNATURE)
        {
            // Log("Invalid DOS signature");
            __leave;
        }

        // Read the executable's PE header
        cbRead = SetFilePointer(hFile, dh.e_lfanew, NULL, FILE_BEGIN);
        if ((LONG)cbRead != dh.e_lfanew)
        {
            // Log("Unable to seek to PE header");
            __leave;
        }    
        
        if ((ReadFile(hFile, &nth, sizeof(nth), &cbRead, NULL) == FALSE)
             || cbRead != sizeof(nth))
        {
            // Log("Unable to read PE header");
            __leave;
        }

        if (nth.Signature != IMAGE_NT_SIGNATURE)
        {
            // Log("Invalid PE signature");
            __leave;
        }

        // Get the executable's size
        // Assuming < 4 GB
        dwFileSize = GetFileSize(hFile, NULL);
        if (dwFileSize == INVALID_FILE_SIZE )
        {
            // Log("Unable to get file size");
            __leave;
        }    

        // Create the application ID 
        if (FAILED(StringCchPrintfW(
                                 wzAppId,
                                 MAX_PATH,
                                 L"%s%8.8lX%8.8lX",
                                 wzExecName,
                                 nth.FileHeader.TimeDateStamp,
                                 dwFileSize)))
        {
           __leave;
        }
        CharUpperW(wzAppId);

        fSuccess = TRUE;
    }
    __finally
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
        }
    }

    return fSuccess;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\vregistry_worker.h ===
#pragma once

#ifndef _WORKER_H_
#define _WORKER_H_

LONG 
WINAPI
VR_Expand(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue
    );

LONG
WINAPI
VR_Protect(
    OPENKEY *key,
    VIRTUALKEY *vkey,
    VIRTUALVAL *vvalue,
    DWORD dwType,
    const BYTE* pbData,
    DWORD cbData
    );

#endif //_WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2000sp3versionlie.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

   Win2000SP3VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000 SP3
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   09/05/2002   robkenny    Created.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2000SP3VersionLie)
#include "ShimHookMacro.h"

DWORD       MajorVersion    = 5;
DWORD       MinorVersion    = 0;
DWORD       BuildNumber     = 2195;
SHORT       SpMajorVersion  = 3;
SHORT       SpMinorVersion  = 0;
DWORD       PlatformId      = VER_PLATFORM_WIN32_NT;
CString *   csServicePack   = NULL;

#include "VersionLieTemplate.h"

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2000sp2versionlie.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

   Win2000SP2VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000 SP2
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   09/05/2002   robkenny    Created.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2000SP2VersionLie)
#include "ShimHookMacro.h"

DWORD       MajorVersion    = 5;
DWORD       MinorVersion    = 0;
DWORD       BuildNumber     = 2195;
SHORT       SpMajorVersion  = 2;
SHORT       SpMinorVersion  = 0;
DWORD       PlatformId      = VER_PLATFORM_WIN32_NT;
CString *   csServicePack   = NULL;

#include "VersionLieTemplate.h"

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2000versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win2000VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   03/13/2000 clupu  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2000VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExA] called. return Win2k.");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = '\0';

        if( lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXA) ) 
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMajor = 0;
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMinor = 0;
        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExW] called. return Win2k.");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = L'\0';

        if( lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXW) ) 
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMajor = 0;
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMinor = 0;
        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(
        eDbgLevelInfo,
        "[GetVersion] called. return Win2k.");
    
    return (DWORD)0x08930005;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\vregistry_worker.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Worker.cpp

 Abstract:

    These are the worker functions for virtual registry. They are called 
    whenever a non-static value is queried. 

 Notes:
    

 History:

    07/18/2000 linstev  Created
    10/11/2001 mikrause Added protectors.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VirtualRegistry)
#include "ShimHookMacro.h"
#include "VRegistry.h"
#include "VRegistry_Worker.h"

/*++

 Expand REG_EXPAND_SZ for this value

--*/

LONG 
WINAPI
VR_Expand(
    OPENKEY *key,
    VIRTUALKEY*,
    VIRTUALVAL *vvalue
    )
{
    DWORD dwType;
    WCHAR wSrc[MAX_PATH];
    DWORD dwSize = sizeof(wSrc);

    //
    // Query the original value
    //

    LONG lRet = ORIGINAL_API(RegQueryValueExW)(
        key->hkOpen, 
        vvalue->wName, 
        NULL, 
        &dwType, 
        (LPBYTE)wSrc, 
        &dwSize);
    
    //
    // Query failed - this should never happen 
    //

    if (FAILURE(lRet))
    {
        DPFN( eDbgLevelError, "Failed to query %S for expansion", vvalue->wName);
        goto Exit;
    }

    //
    // Not a string type!
    //

    if (!((dwType == REG_EXPAND_SZ) || (dwType == REG_SZ)) && 
        (dwSize > sizeof(wSrc)))
    {
        DPFN( eDbgLevelError, "Expander: Not a string type");
        lRet = ERROR_BAD_ARGUMENTS;
        goto Exit;
    }

    //
    // Expand the string and store it in the value
    //

    vvalue->cbData = ExpandEnvironmentStringsW(wSrc, NULL, 0) * 2;   

    if (vvalue->cbData == 0)
    {
       lRet = ERROR_BAD_ARGUMENTS;
       goto Exit;
    }

    vvalue->lpData = (LPBYTE) malloc(vvalue->cbData);
    if (!vvalue->lpData)
    {
       DPFN( eDbgLevelError, szOutOfMemory);
       lRet = ERROR_NOT_ENOUGH_MEMORY;
       goto Exit;
    }

    if (ExpandEnvironmentStringsW(wSrc, (PWSTR)vvalue->lpData, vvalue->cbData / 2) != vvalue->cbData / sizeof(WCHAR))
    {
       lRet = ERROR_NOT_ENOUGH_MEMORY;
       goto Exit;
    }

    //
    // Value is now cached, so we don't need to get called again
    //

    vvalue->pfnQueryValue = NULL;

    lRet = ERROR_SUCCESS;

    DPFN( eDbgLevelInfo, "Expanded Value=%S\n", vvalue->lpData);

Exit:
    return lRet;
}

/*++

 Do nothing, the SetValue is ignored.

--*/

LONG
WINAPI
VR_Protect(
    OPENKEY*,
    VIRTUALKEY*,
    VIRTUALVAL*,
    DWORD,
    const BYTE*,
    DWORD)
{
    return ERROR_SUCCESS;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2000sp1versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win2000SP1VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 2000 SP1
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   04/25/2000 prashkud  Created

--*/

#include "precomp.h"

//This module has been given an official blessing to use the str routines
//#include "LegalStr.h"
#include "StrSafe.h"

IMPLEMENT_SHIM_BEGIN(Win2000SP1VersionLie)
#include "ShimHookMacro.h"

#define SIZE(x)  sizeof(x)/sizeof(x[0])

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 2000 SP1 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExA] called. return Win2k SP1");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;        
        //strcpy(lpVersionInformation->szCSDVersion, "Service Pack 1");
                
        StringCbCopyExA(lpVersionInformation->szCSDVersion, 
                        SIZE(lpVersionInformation->szCSDVersion),                        
                        "Service Pack 1", NULL , NULL, STRSAFE_NULL_ON_FAILURE);
                        


        if (lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXA))
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMajor = 1;
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMinor = 0;

        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExW] called. return Win2k SP1");

        //
        // Fixup the structure with the Win2k data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber  = 2195;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        //wcscpy(lpVersionInformation->szCSDVersion, L"Service Pack 1");
        StringCbCopyExW(lpVersionInformation->szCSDVersion, 
                        SIZE(lpVersionInformation->szCSDVersion),                        
                        L"Service Pack 1", NULL , NULL, STRSAFE_NULL_ON_FAILURE);

        if (lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXW))
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMajor = 1;
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMinor = 0;

        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(
        eDbgLevelInfo,
        "[GetVersion] called. return Win2k SP1");
    
    return (DWORD)0x08930005;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2kpropagatelayer_cleanup.cpp ===
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#define APPCOMPAT_KEYW L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

BOOL
CleanupRegistryForCurrentExe(
    void
    )
{
    NTSTATUS          status;
    OBJECT_ATTRIBUTES objA;
    HANDLE            hkey;
    WCHAR             wszExeName[MAX_PATH];
    WCHAR             wszKey[MAX_PATH];
    UNICODE_STRING    strKey;
    UNICODE_STRING    strValue;

    DWORD dwChars = GetModuleFileNameW(NULL, wszExeName, MAX_PATH);

    // If there was an error, or the path was truncated.
    if (dwChars == 0 || dwChars == MAX_PATH) {
        return FALSE;
    }
    
    WCHAR* pwsz = wszExeName + dwChars;

    while (pwsz >= wszExeName) {

        if (*pwsz == '\\') {
            break;
        }
        pwsz--;
    }

    pwsz++;

    LOGN(
        eDbgLevelInfo,
        "[CleanupRegistryForCurrentExe] Cleanup for \"%S\"",
        pwsz);
    
    if( FAILED(StringCchPrintf(wszKey, MAX_PATH, L"%ls\\%ls", APPCOMPAT_KEYW, pwsz)) )
    {
        return FALSE;
    }

    RtlInitUnicodeString(&strKey, wszKey);
    
    InitializeObjectAttributes(&objA,
                               &strKey,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    status = NtOpenKey(&hkey,
                       MAXIMUM_ALLOWED,
                       &objA);

    if (!NT_SUCCESS(status)) {
        LOGN(
            eDbgLevelError,
            "[CleanupRegistryForCurrentExe] Failed to open key \"%S\"",
            wszKey);
        return TRUE;
    }
    
    RtlInitUnicodeString(&strValue, L"DllPatch-y");
    NtDeleteValueKey(hkey, &strValue);

    RtlInitUnicodeString(&strValue, L"y");
    NtDeleteValueKey(hkey, &strValue);

    //
    // Now check to see if there are any more values under this key.
    // Delete it if there are no more values.
    //
    
    KEY_FULL_INFORMATION keyInfo;
    DWORD                dwReturnLength = 0;
    
    status = NtQueryKey(hkey,
                        KeyFullInformation,
                        &keyInfo,
                        sizeof(keyInfo),
                        &dwReturnLength);

    if (NT_SUCCESS(status) && keyInfo.Values == 0) {
        NtDeleteKey(hkey);
    }

    NtClose(hkey);

    return TRUE;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2kpropagatelayer.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win2kPropagateLayer.cpp

 Abstract:

   This shim propagates a layer from a process to its child processes on Win2k. 

 Notes:

   This is a layer shim.

 History:

   03/13/2000 clupu  Created
   10/26/2000 Vadimb Merged WowProcessHistory functionality, new environment-handling cases

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include "Win2kPropagateLayer.h"
#include "stdio.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(UserRegisterWowHandlers)
APIHOOK_ENUM_END


#define LI_WIN95    0x00000001
#define LI_NT4      0x00000002
#define LI_WIN98    0x00000004

#define LS_MAGIC    0x07036745

typedef struct tagLayerStorageHeader {
    DWORD       dwItemCount;    // number of items in the file
    DWORD       dwMagic;        // magic to identify the file
    SYSTEMTIME  timeLast;       // time of last access
} LayerStorageHeader, *PLayerStorageHeader;


typedef struct tagLayeredItem {
    WCHAR   szItemName[MAX_PATH];
    DWORD   dwFlags;

} LayeredItem, *PLayeredItem;



#define APPCOMPAT_KEY L"System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility"

WCHAR g_szLayerStorage[MAX_PATH] = L"";


CHAR g_szCompatLayerVar[]    = "__COMPAT_LAYER";
CHAR g_szProcessHistoryVar[] = "__PROCESS_HISTORY";
CHAR g_szShimFileLogVar[]    = "SHIM_FILE_LOG";


WCHAR g_wszCompatLayerVar[]  = L"__COMPAT_LAYER";
WCHAR g_wszProcessHistroyVar[] = L"__PROCESS_HISTORY";
//
// This variable receives current process' compat layer
//

WCHAR* g_pwszCompatLayer = NULL;
WCHAR* g_pwszProcessHistory = NULL;

//
// Unicode equivalent of the above
//
UNICODE_STRING g_ustrProcessHistoryVar = RTL_CONSTANT_STRING(L"__PROCESS_HISTORY");
UNICODE_STRING g_ustrCompatLayerVar    = RTL_CONSTANT_STRING(L"__COMPAT_LAYER");

//
// Global flags
//
BOOL g_bIsNTVDM    = FALSE;
BOOL g_bIsExplorer = FALSE;

INT    g_argc    = 0;
CHAR** g_argv    = NULL;

//
// is this a separate wow ?
//

BOOL* g_pSeparateWow = NULL;


BOOL
InitLayerStorage(
    BOOL bDelete
    )
{
    if (GetSystemWindowsDirectoryW(g_szLayerStorage, MAX_PATH) >= MAX_PATH) {
        return FALSE;
    }

    if (lstrlenW(g_szLayerStorage) >= 1 && g_szLayerStorage[lstrlenW(g_szLayerStorage) - 1] == L'\\') {
        g_szLayerStorage[lstrlenW(g_szLayerStorage) - 1] = 0;
    }

    if (FAILED(StringCchCatW(g_szLayerStorage, MAX_PATH, L"\\AppPatch\\LayerStorage.dat"))) {
        return FALSE;
    }

    if (bDelete) {
        DeleteFileW(g_szLayerStorage);
    }

    return TRUE;
}

void
ReadLayeredStorage(
    LPWSTR  pszItem,
    LPDWORD lpdwFlags
    )
{
    HANDLE              hFile        = INVALID_HANDLE_VALUE;
    HANDLE              hFileMapping = NULL;
    DWORD               dwFileSize;
    PBYTE               pData        = NULL;
    PLayerStorageHeader pHeader      = NULL;
    PLayeredItem        pItems;
    PLayeredItem        pCrtItem     = NULL;
    int                 nLeft, nRight, nMid, nItem;

    LOGN(
        eDbgLevelInfo,
        "[ReadLayeredStorage] for \"%S\"",
        pszItem);

    //
    // Make sure we don't corrupt the layer storage.
    //
    if (lstrlenW(pszItem) + 1 > MAX_PATH) {
        pszItem[MAX_PATH - 1] = 0;
    }

    hFile = CreateFileW(g_szLayerStorage,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LOGN(
            eDbgLevelInfo,
            "[ReadLayeredStorage] the layer storage doesn't exist.");
        *lpdwFlags = 0;
        return;
    }

    //
    // The file already exists. Create a file mapping that will allow
    // for querying the item.
    //
    dwFileSize = GetFileSize(hFile, NULL);

    hFileMapping = CreateFileMapping(hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     dwFileSize,
                                     NULL);

    if (hFileMapping == NULL) {
        LOGN(
            eDbgLevelError,
            "[ReadLayeredStorage] CreateFileMapping failed 0x%X",
            GetLastError());
        goto done;
    }

    pData = (PBYTE)MapViewOfFile(hFileMapping,
                                 FILE_MAP_READ | FILE_MAP_WRITE,
                                 0,
                                 0,
                                 0);

    if (pData == NULL) {
        LOGN(
            eDbgLevelError,
            "[ReadLayeredStorage] MapViewOfFile failed 0x%X",
            GetLastError());
        goto done;
    }

    pHeader = (PLayerStorageHeader)pData;

    pItems = (PLayeredItem)(pData + sizeof(LayerStorageHeader));

    //
    // Make sure it's our file.
    //
    if (dwFileSize < sizeof(LayerStorageHeader) || pHeader->dwMagic != LS_MAGIC) {
        LOGN(
            eDbgLevelError,
            "[ReadLayeredStorage] invalid file magic 0x%X",
            pHeader->dwMagic);
        goto done;
    }

    //
    // First search for the item. The array is sorted so we do binary search.
    //
    nItem = -1, nLeft = 0, nRight = (int)pHeader->dwItemCount - 1;

    while (nLeft <= nRight) {

        int nVal;

        nMid = (nLeft + nRight) / 2;

        pCrtItem  = pItems + nMid;

        nVal = _wcsnicmp(pszItem, pCrtItem->szItemName, lstrlenW(pCrtItem->szItemName));

        if (nVal == 0) {
            nItem = nMid;
            break;
        } else if (nVal < 0) {
            nRight = nMid - 1;
        } else {
            nLeft = nMid + 1;
        }
    }

    if (nItem == -1) {
        LOGN(
            eDbgLevelInfo,
            "[ReadLayeredStorage] the item was not found in the file.");

        *lpdwFlags = 0;
    } else {
        //
        // The item is in the file.
        //
        LOGN(
            eDbgLevelInfo,
            "[ReadLayeredStorage] the item is in the file.");

        *lpdwFlags = pCrtItem->dwFlags;
    }

done:

    if (pData != NULL) {
        UnmapViewOfFile(pData);
    }

    if (hFileMapping != NULL) {
        CloseHandle(hFileMapping);
    }

    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}


BOOL
GetFileNameFromCmdLine(
    LPWSTR lpFileName,
    DWORD  dwFileNameSize,
    LPCWSTR lpCmdLine
    )
{
    LPCWSTR pSrc = lpCmdLine;
    LPCWSTR pStart;
    BOOL    bQuote = FALSE;
    BOOL    bInitialQuote = FALSE;
    BOOL    bDone = FALSE;
    DWORD   dwLength; // length of the result, in chars

    pSrc += wcsspn(pSrc, L" \t");
    if (*pSrc == L'\"') {
        ++pSrc;
        bQuote = TRUE;
        bInitialQuote = TRUE;
    }

    pStart = pSrc; // note -- we're past the quote

    // we end when: 1) we start we the quote -- we end with the quote or
    // we did not start with the quote -- we encounter space then
    
    while (*pSrc && !bDone) {
        switch(*pSrc) {
            case L'\"':
                bQuote = !bQuote;
                break;
                
            case L' ':
                bDone = !bQuote; // out of quotes? this is the end
                break;
        }
        
        if (!bDone) {
            ++pSrc;
        }
    }   

    if (pSrc > pStart && bInitialQuote && *(pSrc-1) == L'\"') {
        --pSrc;
    }

    //
    // now that we ended the run, copy 
    //
    dwLength = (DWORD)(pSrc - pStart);

    if (dwFileNameSize < (dwLength + 1)) {
        // too big 
        LOGN( eDbgLevelError, 
            "[GetFileNameFromCmdLine] filename is too long\"%S\".\n", lpCmdLine);
        return FALSE;
    }

    RtlCopyMemory(lpFileName, pStart, dwLength * sizeof(WCHAR));
    lpFileName[dwLength] = L'\0';
    return TRUE;

}
    
BOOL
AddSupport(
    LPCWSTR lpCommandLine,
    LPVOID* ppEnvironment,
    LPDWORD lpdwCreationFlags
    )
{
    WCHAR    szKey[MAX_PATH];
    WCHAR    szFullPath[MAX_PATH + 3] = L"\"";
    WCHAR    szExeName[MAX_PATH + 1];
    HKEY     hkey;
    DWORD    type;
    DWORD    cbData = 0;
    BOOL     bBraket = FALSE;
    LPVOID   pEnvironmentNew  = NULL;
    DWORD    dwCreationFlags  = *lpdwCreationFlags;
    BOOL     bUserEnvironment = (*ppEnvironment != NULL);
    NTSTATUS Status;
    LPCWSTR  pszEnd;
    LPCWSTR  pszStart = lpCommandLine;

    //
    // Need to look in lpCommandLine for the first token
    //
    LPCWSTR  psz = lpCommandLine;

    while (*psz == L' ' || *psz == L'\t') {
        psz++;
    }

    if (*psz == L'\"') {
        pszStart = psz + 1;
        bBraket = TRUE;
    } else {
        pszStart = psz;
    }

    while (*psz != 0) {
        if (*psz == L'\"') {
            bBraket = !bBraket;
        } else if (*psz == L' ' && !bBraket) {
            break;
        }

        psz++;
    }

    pszEnd = psz;

    //
    // Now walk back to get the caracters.
    //
    psz--;

    // Be careful not to walk back past the beginning of the command line.
    if (psz > lpCommandLine && *psz == L'\"') {
        psz--;
        pszEnd--;
    }

    // Don't under- or over-flow.
    // szFullPath is of size MAX_PATH + 3.  We can copy in:
    // MAX_PATH + 3 - 2 (quotes) - 1 (NULL) = MAX_PATH characters.
    if( pszEnd <= pszStart || pszEnd - pszStart > MAX_PATH ) {
        return FALSE;
    }

    memcpy(szFullPath + 1, pszStart, (pszEnd - pszStart) * sizeof(WCHAR));
    szFullPath[pszEnd - pszStart + 1] = L'\"';
    szFullPath[pszEnd - pszStart + 2] = 0;

    pszStart = lpCommandLine;

    pszEnd = psz + 1;

    while (psz >= lpCommandLine) {
        if (*psz == L'\\') {
            pszStart = psz + 1;
            break;
        }
        psz--;
    }

    // We already know that pszEnd - pszStart is <= MAX_PATH because, since the
    // test above, we have only possibly reduced the size.  Since szExeName is of
    // size MAX_PATH + 1, we are okay to do the memcopy.
    memcpy(szExeName, pszStart, (pszEnd - pszStart) * sizeof(WCHAR));
    szExeName[pszEnd - pszStart] = 0;

    if (g_bIsExplorer) {
        DWORD    dwFlags = 0;

        ReadLayeredStorage(szFullPath, &dwFlags);

        if (dwFlags != LI_WIN95 && dwFlags != LI_NT4 && dwFlags != LI_WIN98) {
            //
            // no layer support
            //

            LOGN(
                eDbgLevelInfo,
                "[AddSupport] No Layer specified for \"%S\".",
                lpCommandLine);

            return TRUE;
        }

        // we are using layer -- clone the environment
        Status = ShimCloneEnvironment(&pEnvironmentNew, *ppEnvironment, !!(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT));
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[AddSupport] Failed to Clone the environment. Status = 0x%x",
                Status);
            return FALSE;
        }

        if (LI_WIN95 == dwFlags) {
            Status = ShimSetEnvironmentVar(&pEnvironmentNew, g_wszCompatLayerVar, L"Win95");

            LOGN( eDbgLevelInfo, "[AddSupport] Env var \"Win95\" added.");

        } else if (LI_WIN98 == dwFlags) {
            Status = ShimSetEnvironmentVar(&pEnvironmentNew, g_wszCompatLayerVar, L"Win98");

            LOGN( eDbgLevelInfo, "[AddSupport] Env var \"Win98\" added.");

        } else if (LI_NT4 == dwFlags) {
            Status = ShimSetEnvironmentVar(&pEnvironmentNew, g_wszCompatLayerVar, L"NT4SP5");

            LOGN( eDbgLevelInfo, "[AddSupport] Env var \"NT4SP5\" added.");

        }

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[AddSupport] Failed to set the environment variable. Status = 0x%x",
                Status);
            ShimFreeEnvironment(pEnvironmentNew);
            return FALSE;
        }

        //
        // We have succeeded, set the output values.
        //
        *ppEnvironment = pEnvironmentNew;
        *lpdwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;

    } else {
        //
        // not explorer - set the environment variable up
        // compat_layer will be inherited by the child process if bUserEnvironment is FALSE
        //
        if (bUserEnvironment) {

            //
            // Clone the environment and add the layer variable to the new env.
            //
            Status = ShimCloneEnvironment(&pEnvironmentNew,
                                            *ppEnvironment,
                                            !!(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT));
            if (!NT_SUCCESS(Status)) {
                LOGN(
                    eDbgLevelError,
                    "[AddSupport] Failed to clone the environment. Status = 0x%x",
                    Status);
                return FALSE;
            }

            Status = ShimSetEnvironmentVar(&pEnvironmentNew,
                                           g_wszCompatLayerVar,
                                           g_pwszCompatLayer);

            if (!NT_SUCCESS(Status)) {
                ShimFreeEnvironment(pEnvironmentNew);
                LOGN(
                    eDbgLevelError,
                    "[AddSupport] Failed to set compat layer variable. Status = 0x%x",
                    Status);
                return FALSE;
            }

            LOGN(
                eDbgLevelInfo,
                "[AddSupport] Env var \"%S\" added.",
                g_pwszCompatLayer);

            *ppEnvironment = pEnvironmentNew;
            *lpdwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;
        }
    }

    //
    // Build the registry key.
    //
    if( FAILED(StringCchPrintfW(szKey, MAX_PATH, L"%s\\%s", APPCOMPAT_KEY, szExeName)) )
    {
        return FALSE;
    }

    if (RegCreateKeyW(HKEY_LOCAL_MACHINE, szKey, &hkey) != ERROR_SUCCESS) {
        LOGN(
            eDbgLevelError,
            "Failed to open/create the appcompat key \"%s\"",
            szKey);
    } else {
        if (RegQueryValueExA(hkey, "DllPatch-x", NULL, &type, NULL, &cbData) != ERROR_SUCCESS) {

            BYTE data[16] = {0x0c, 0, 0, 0, 0, 0, 0, 0,
                             0x06, 0, 0, 0, 0, 0, 0, 0};

            //
            // The value doesn't exist. Create it.
            //
            RegSetValueExA(hkey,
                           "y",
                           NULL,
                           REG_BINARY,
                           data,
                           sizeof(data));

            data[0] = 0;

            RegSetValueExA(hkey,
                           "DllPatch-y",
                           NULL,
                           REG_SZ,
                           data,
                           2);
        }
    }

    RegCloseKey(hkey);

    //
    // Finally, set a separate vdm flag
    // if we are here, it means that we are running under the layer
    // and the next exe is going to be shimmed.
    //
    *lpdwCreationFlags &= ~CREATE_SHARED_WOW_VDM;
    *lpdwCreationFlags |= CREATE_SEPARATE_WOW_VDM;

    return TRUE;
}


LPVOID
ShimCreateWowEnvironment_U(
    LPVOID lpEnvironment,       // pointer to the existing environment
    DWORD* lpdwFlags,           // process creation flags
    BOOL   bNewEnvironment      // when set, forces us to clone environment ptr
    )
{
    WOWENVDATA     WowEnvData   = { 0 };
    LPVOID         lpEnvRet     = lpEnvironment;
    LPVOID         lpEnvCurrent = NULL;
    NTSTATUS       Status       = STATUS_SUCCESS;
    DWORD          dwFlags      = *lpdwFlags;
    UNICODE_STRING ustrProcessHistory = { 0 };
    ANSI_STRING    strProcessHistory  = { 0 };
    DWORD          dwProcessHistoryLength = 0;
    UNICODE_STRING ustrCompatLayer    = { 0 };
    ANSI_STRING    strCompatLayer     = { 0 };

    if (!ShimRetrieveVariablesEx(&WowEnvData)) {
        //
        // If no data, we have failed. Return the current data.
        //
        goto Fail;
    }

    if (bNewEnvironment) {
        Status = ShimCloneEnvironment(&lpEnvCurrent,
                                      lpEnvironment,
                                      !!(dwFlags & CREATE_UNICODE_ENVIRONMENT));
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to clone the environment. Status = 0x%x",
                Status);
            goto Fail;
        }
    } else {
        lpEnvCurrent = lpEnvironment;
    }

    //
    // Now we are ready to set the environment in place.
    //

    //
    // Nuke the existing process history first. We don't care for the return result.
    //
    RtlSetEnvironmentVariable(&lpEnvCurrent, &g_ustrProcessHistoryVar, NULL);

    if (WowEnvData.pszProcessHistory != NULL ||
        WowEnvData.pszCurrentProcessHistory != NULL) {

        //
        // Convert the process history which consists of 2 strings.
        //
        // The length is the existing process history length + 1 (for ';') +
        // new process history length + 1 (for '\0')
        //
        dwProcessHistoryLength = ((WowEnvData.pszProcessHistory == NULL) ? 0 : (strlen(WowEnvData.pszProcessHistory) + 1)) +
                                 ((WowEnvData.pszCurrentProcessHistory == NULL) ? 0 : strlen(WowEnvData.pszCurrentProcessHistory)) + 1;

        //
        // Allocate process history buffer and convert it, allocating resulting unicode string.
        //
        strProcessHistory.Buffer = (PCHAR)ShimMalloc(dwProcessHistoryLength);

        if (strProcessHistory.Buffer == NULL) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] failed to allocate %d bytes for process history.",
                dwProcessHistoryLength);
            Status = STATUS_NO_MEMORY;
            goto Fail;
        }

        strProcessHistory.MaximumLength = (USHORT)dwProcessHistoryLength;

        if (WowEnvData.pszProcessHistory != NULL) {
            // This StringCpy won't fail because strProcessHistory.Buffer has been allocated to the proper length.
            StringCchCopyA(strProcessHistory.Buffer, dwProcessHistoryLength, WowEnvData.pszProcessHistory);
            strProcessHistory.Length = strlen(WowEnvData.pszProcessHistory);
        } else {
            strProcessHistory.Length = 0;
        }

        if (WowEnvData.pszCurrentProcessHistory != NULL) {

            //
            // Append ';' if the string was not empty.
            //
            if (strProcessHistory.Length) {
                Status = RtlAppendAsciizToString(&strProcessHistory, ";");
                if (!NT_SUCCESS(Status)) {
                    LOGN(
                        eDbgLevelError,
                        "[ShimCreateWowEnvironment_U] failed to append ';' to the process history. Status = 0x%x",
                        Status);
                    goto Fail;
                }
            }

            Status = RtlAppendAsciizToString(&strProcessHistory,
                                             WowEnvData.pszCurrentProcessHistory);
            if (!NT_SUCCESS(Status)) {
                LOGN(
                    eDbgLevelError,
                    "[ShimCreateWowEnvironment_U] failed to build the process history. Status = 0x%x",
                    Status);
                goto Fail;
            }

        }

        //
        // Convert the process history.
        //
        Status = RtlAnsiStringToUnicodeString(&ustrProcessHistory, &strProcessHistory, TRUE);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] failed to convert process history to UNICODE. Status = 0x%x",
                Status);
            goto Fail;
        }

        //
        // Now we can set the process history.
        //
        Status = RtlSetEnvironmentVariable(&lpEnvCurrent,
                                           &g_ustrProcessHistoryVar,
                                           &ustrProcessHistory);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] failed to set the process history. Status = 0x%x",
                Status);
            goto Fail;
        }
    }

    //
    // Now we pass along any compat layer that we might have.
    //
    if (g_pwszCompatLayer != NULL) {

        //
        // Pass along this thing, we have been started under layer.
        //
        LOGN(
            eDbgLevelInfo,
            "[ShimCreateWowEnvironment_U] Propagating CompatLayer from the ntvdm environment __COMPAT_LAYER=\"%S\"",
            g_pwszCompatLayer);

        RtlInitUnicodeString(&ustrCompatLayer, g_pwszCompatLayer);

        Status = RtlSetEnvironmentVariable(&lpEnvCurrent, &g_ustrCompatLayerVar, &ustrCompatLayer);

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to set compatlayer environment variable. Status = 0x%x",
                Status);
            goto Fail;
        }

    } else if (WowEnvData.pszCompatLayerVal != NULL) {

        LOGN(
            eDbgLevelInfo,
            "[ShimCreateWowEnvironment_U] Propagating CompatLayer from the parent WOW app \"%s\"",
            WowEnvData.pszCompatLayer);

        RtlInitString(&strCompatLayer, WowEnvData.pszCompatLayerVal);

        Status = RtlAnsiStringToUnicodeString(&ustrCompatLayer, &strCompatLayer, TRUE);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to convert compatlayer to UNICODE. Status = 0x%x",
                Status);
            goto Fail;
        }

        Status = RtlSetEnvironmentVariable(&lpEnvCurrent, &g_ustrCompatLayerVar, &ustrCompatLayer);

        RtlFreeUnicodeString(&ustrCompatLayer);

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCreateWowEnvironment_U] Failed to set compatlayer environment variable. Status = 0x%x",
                Status);
            goto Fail;
        }
    }

    //
    // We have been successful. The return environment is UNICODE now.
    //
    lpEnvRet   = (LPVOID)lpEnvCurrent;
    *lpdwFlags = dwFlags | CREATE_UNICODE_ENVIRONMENT;
    Status     = STATUS_SUCCESS;

Fail:

    if (!NT_SUCCESS(Status) && lpEnvCurrent != NULL && bNewEnvironment) {
        //
        // This points to the cloned environment ALWAYS.
        //
        RtlDestroyEnvironment(lpEnvCurrent);
    }

    RtlFreeUnicodeString(&ustrProcessHistory);

    if (strProcessHistory.Buffer != NULL) {
        ShimFree(strProcessHistory.Buffer);
    }

    //
    // This call is only necessary when using ShimRetrieveVariables.
    // It is not needed when using ShimRetrieveVariablesEx.
    //
    // ShimFreeWOWEnvData(&WowEnvData);
    //

    return lpEnvRet;
}

ULONG
Win2kPropagateLayerExceptionHandler(
    PEXCEPTION_POINTERS pexi,
    char*               szFile,
    DWORD               dwLine
    )
{
    LOGN(
        eDbgLevelError,
        "[Win2kPropagateLayerExceptionHandler] %#x in module \"%s\", line %d,"
        " at address %#p. flags:%#x. !exr %#p !cxr %#p",
        pexi->ExceptionRecord->ExceptionCode,
        szFile,
        dwLine,
        CONTEXT_TO_PROGRAM_COUNTER(pexi->ContextRecord),
        pexi->ExceptionRecord->ExceptionFlags,
        pexi->ExceptionRecord,
        pexi->ContextRecord);

#if DBG
    DbgBreakPoint();
#endif // DBG

    return EXCEPTION_EXECUTE_HANDLER;
}

/*++

    Stub functions that are intercepted from WOW initialization code
    (through APIHook_UserRegisterWowHandlers)
    
--*/



NSWOWUSERP::PFNINITTASK   g_pfnInitTask;
NSWOWUSERP::PFNWOWCLEANUP g_pfnWowCleanup;

BOOL WINAPI
StubInitTask(
    UINT   dwExpWinVer,
    DWORD  dwAppCompatFlags,
    LPCSTR lpszModName,
    LPCSTR lpszBaseFileName,
    DWORD  hTaskWow,
    DWORD  dwHotkey,
    DWORD  idTask,
    DWORD  dwX,
    DWORD  dwY,
    DWORD  dwXSize,
    DWORD  dwYSize
    )
{
    BOOL bReturn;
    
    bReturn = g_pfnInitTask(dwExpWinVer,
                            dwAppCompatFlags,
                            lpszModName,
                            lpszBaseFileName,
                            hTaskWow,
                            dwHotkey,
                            idTask,
                            dwX,
                            dwY,
                            dwXSize,
                            dwYSize);
    if (bReturn) {
        CheckAndShimNTVDM((WORD)hTaskWow);
        UpdateWowTaskList((WORD)hTaskWow);
    }


    return bReturn;
}


BOOL WINAPI
StubWowCleanup(
    HANDLE hInstance,
    DWORD  hTaskWow
    )
{
    BOOL bReturn;

    bReturn = g_pfnWowCleanup(hInstance, hTaskWow);

    if (bReturn) {
        CleanupWowTaskList((WORD)hTaskWow);
    }

    return bReturn;
}


/*++
    APIHook_UserRegisterWowHandlers

        Trap InitTask and WowCleanup functions and
        replace them with stubs

--*/

ULONG_PTR
APIHOOK(UserRegisterWowHandlers)(
    NSWOWUSERP::APFNWOWHANDLERSIN  apfnWowIn,
    NSWOWUSERP::APFNWOWHANDLERSOUT apfnWowOut
    )
{
    ULONG_PTR ulRet;

    ulRet = ORIGINAL_API(UserRegisterWowHandlers)(apfnWowIn, apfnWowOut);

    g_pfnInitTask = apfnWowOut->pfnInitTask;
    apfnWowOut->pfnInitTask = StubInitTask;

    g_pfnWowCleanup = apfnWowOut->pfnWOWCleanup;
    apfnWowOut->pfnWOWCleanup = StubWowCleanup;

    return ulRet;
}

BOOL 
CheckWOWExe(
    LPCWSTR lpApplicationName,
    LPVOID  lpEnvironment, 
    LPDWORD lpdwCreationFlags
    )
{
    BOOL bSuccess;
    BOOL bReturn = FALSE;
    NTSTATUS Status;
    LPVOID pEnvironmentNew = lpEnvironment;
    SDBQUERYRESULT QueryResult;
    DWORD dwBinaryType = 0;
    HSDB hSDB = NULL;
    DWORD dwExes;
    WCHAR wszAppName[MAX_PATH];

    bSuccess = GetFileNameFromCmdLine(wszAppName, CHARCOUNT(wszAppName), lpApplicationName);
    if (!bSuccess) {
        return FALSE;
    }
    
    bSuccess = GetBinaryTypeW(wszAppName, &dwBinaryType);
    if (!bSuccess || dwBinaryType != SCS_WOW_BINARY) {
        LOGN( eDbgLevelInfo, "[CheckWowExe] can't get binary type\n");
        return FALSE;
    }

    //
    // for these binaries we shall perform the good deed of running the detection
    //
    hSDB = SdbInitDatabase(0, NULL);
    if (hSDB == NULL) {
        LOGN( eDbgLevelError, "[CheckWowExe] Failed to init the database.");
        return FALSE;
    }
  
    if (lpEnvironment != NULL && !(*lpdwCreationFlags & CREATE_UNICODE_ENVIRONMENT)) { // non-null unicode env?
        Status = ShimCloneEnvironment(&pEnvironmentNew, 
                                      lpEnvironment, 
                                      FALSE); 
        if (!NT_SUCCESS(Status)) {
            LOGN( eDbgLevelError, "[ShimCloneEnvironment] failed with status 0x%lx\n", Status);
            goto cleanup;
        }
    }

    //
    // all parameters below have to be unicode
    //
    
    dwExes = SdbGetMatchingExe(hSDB,
                               wszAppName,
                               NULL,
                               (LPCWSTR)pEnvironmentNew,
                               0,
                               &QueryResult);
    bSuccess = (QueryResult.atrExes  [0] != TAGREF_NULL || 
                QueryResult.atrLayers[0] != TAGREF_NULL);

    //
    // if we have been successful -- layers apply to this thing
    //

    if (!bSuccess) {
        goto cleanup;
    }

    //
    // set the separate ntvdm flag and be on our way out
    //
    *lpdwCreationFlags &= ~CREATE_SHARED_WOW_VDM;
    *lpdwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
    
    bReturn = TRUE;
    
cleanup:

    if (pEnvironmentNew != lpEnvironment) {
        ShimFreeEnvironment(pEnvironmentNew);
    }

    if (hSDB) {
        SdbReleaseDatabase(hSDB);
    }     

    return bReturn;
}

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,
    LPSTR                   lpCommandLine,
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    BOOL                    bInheritHandles,
    DWORD                   dwCreationFlags,
    LPVOID                  lpEnvironment,
    LPCSTR                  lpCurrentDirectory,
    LPSTARTUPINFOA          lpStartupInfo,
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    BOOL   bRet;
    LPVOID lpEnvironmentNew        = lpEnvironment;
    LPSTR  pszApp                  = NULL;

    LOGN(
        eDbgLevelError,
        "[CreateProcessA] called for:");

    LOGN(
        eDbgLevelError,
        "[CreateProcessA]    lpApplicationName : \"%s\"",
        (lpApplicationName == NULL ? "null": lpApplicationName));

    LOGN(
        eDbgLevelError,
        "[CreateProcessA]    lpCommandLine     : \"%s\"",
        (lpCommandLine == NULL ? "null": lpCommandLine));

    if (lpApplicationName != NULL) {
        pszApp = (LPSTR)lpApplicationName;
    } else if (lpCommandLine != NULL) {
        pszApp = lpCommandLine;
    } else {
        LOGN(
            eDbgLevelError,
            "[CreateProcessA] called with NULL params.");
    }

    __try {

        WCHAR wszApp[MAX_PATH];

        if (pszApp != NULL) {
        
            if( MultiByteToWideChar(CP_ACP,
                                0,
                                pszApp,
                                -1,
                                wszApp,
                                MAX_PATH) )
            {
                AddSupport(wszApp, &lpEnvironmentNew, &dwCreationFlags);
            }
        }

        if (g_bIsNTVDM) {

            //
            // if the environment stayed the same as it was passed in -- clone it to propagate process history
            // if it was modified in AddSupport -- use it
            //

            lpEnvironmentNew = ShimCreateWowEnvironment_U(lpEnvironmentNew,
                                                          &dwCreationFlags,
                                                          lpEnvironmentNew == lpEnvironment);
        }
    

        if (pszApp != NULL && !(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
            // since the separate vdm flag is not set -- we need to determine whether we have 
            // any kind of fixes to care about. 
            CheckWOWExe(wszApp, lpEnvironmentNew, &dwCreationFlags);
        }


    } __except(WOWPROCESSHISTORYEXCEPTIONFILTER) {

        //
        // cleanup the mess, if we have allocated the environment, free it now
        //
        if (lpEnvironmentNew != lpEnvironment) {

            ShimFreeEnvironment(lpEnvironmentNew);

            lpEnvironmentNew = lpEnvironment;
        }
    }


    bRet = ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironmentNew,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);

    if (lpEnvironmentNew != lpEnvironment) {
        //
        // The function below does not need a __try/__except wrapper, it has it internally
        //
        ShimFreeEnvironment(lpEnvironmentNew);
    }

    return bRet;
}

BOOL
APIHOOK(CreateProcessW)(
    LPCWSTR                 lpApplicationName,
    LPWSTR                  lpCommandLine,
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    BOOL                    bInheritHandles,
    DWORD                   dwCreationFlags,
    LPVOID                  lpEnvironment,
    LPCWSTR                 lpCurrentDirectory,
    LPSTARTUPINFOW          lpStartupInfo,
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    LPWSTR pszApp = NULL;
    BOOL   bRet;
    LPVOID lpEnvironmentNew = lpEnvironment;

    LOGN(
        eDbgLevelInfo,
        "[CreateProcessW] called for:");

    LOGN(
        eDbgLevelInfo,
        "[CreateProcessW]    lpApplicationName : \"%S\"",
        (lpApplicationName == NULL ? L"null": lpApplicationName));

    LOGN(
        eDbgLevelInfo,
        "[CreateProcessW]    lpCommandLine     : \"%S\"",
        (lpCommandLine == NULL ? L"null": lpCommandLine));

    if (lpApplicationName != NULL) {
        pszApp = (LPWSTR)lpApplicationName;
    } else if (lpCommandLine != NULL) {
        pszApp = lpCommandLine;
    } else {
        LOGN(
            eDbgLevelError,
            "[CreateProcessW] called with NULL params.");
    }

    __try {

        if (pszApp != NULL) {

            AddSupport(pszApp, &lpEnvironmentNew, &dwCreationFlags);
        }

        if (g_bIsNTVDM) {

            lpEnvironmentNew = ShimCreateWowEnvironment_U(lpEnvironmentNew,
                                                          &dwCreationFlags,
                                                          lpEnvironment == lpEnvironmentNew);
        }

        //
        // typically we need to find out whether the current app is ntvdm
        //

        if (!(dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
            // since the separate vdm flag is not set -- we need to determine whether we have 
            // any kind of fixes to care about. 
            CheckWOWExe(pszApp, lpEnvironmentNew, &dwCreationFlags);
        }
        
    } __except(WOWPROCESSHISTORYEXCEPTIONFILTER) {

        if (lpEnvironmentNew != lpEnvironment) {

            ShimFreeEnvironment(lpEnvironmentNew);

            lpEnvironmentNew = lpEnvironment; // reset the pointer
        }
    }

    bRet = ORIGINAL_API(CreateProcessW)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironmentNew,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);

    if (lpEnvironmentNew != lpEnvironment) {

        ShimFreeEnvironment(lpEnvironmentNew);

    }

    return bRet;
}

BOOL
GetVariableFromEnvironment(
    LPCWSTR pwszVariableName,
    LPWSTR* ppwszVariableValue
    )
{
    DWORD dwLength;
    DWORD dwLen;
    BOOL  bSuccess = FALSE;
    LPWSTR pwszVariableValue = *ppwszVariableValue;

    dwLength = GetEnvironmentVariableW(pwszVariableName, NULL, 0);

    if (dwLength == 0) {
        LOGN(
            eDbgLevelInfo,
            "[GetCompatLayerFromEnvironment] Not under the compatibility layer.");
        *ppwszVariableValue = NULL;
        return FALSE;
    }

    if (pwszVariableValue != NULL) {
        LOGN(
            eDbgLevelError,
            "[GetCompatLayerFromEnvironment] called twice!");
        ShimFree(pwszVariableValue);
        pwszVariableValue = NULL;
    }

    pwszVariableValue = (WCHAR*)ShimMalloc(dwLength * sizeof(WCHAR));

    if (pwszVariableValue == NULL) {
        LOGN(
            eDbgLevelError,
            "[GetCompatLayerFromEnvironment] Failed to allocate %d bytes for Compat Layer.",
            dwLength * sizeof(WCHAR));
        goto out;
    }

    *pwszVariableValue = L'\0';

    dwLen = GetEnvironmentVariableW(pwszVariableName, 
                                  pwszVariableValue, 
                                  dwLength);

    bSuccess = (dwLen != 0 && dwLen < dwLength);

    if (!bSuccess) {
        LOGN(
            eDbgLevelError,
            "[GetCompatLayerFromEnvironment] Failed to get compat layer variable.");
        ShimFree(pwszVariableValue);
        pwszVariableValue = NULL;
    }
    
out:

    *ppwszVariableValue = pwszVariableValue;

    return bSuccess;
}

BOOL 
GetCompatLayerFromEnvironment(
    VOID
    )
{
    return GetVariableFromEnvironment(g_wszCompatLayerVar, &g_pwszCompatLayer);
}


BOOL 
GetSeparateWowPtr(
    VOID
    )
{

    HMODULE hMod = GetModuleHandle(NULL);
    
    g_pSeparateWow = (BOOL*)GetProcAddress(hMod, "fSeparateWow");
    if (g_pSeparateWow == NULL) {
        LOGN( eDbgLevelError, "[GetSeparateWowPtr] Failed 0x%lx\n", GetLastError());
        return FALSE;
    }    

    return TRUE;
}


VOID
ParseCommandLine(
    LPCSTR commandLine
    )
{
    int   i;
    char* pArg;

    g_argc = 0;
    g_argv = NULL;

    g_bIsNTVDM    = FALSE;
    g_bIsExplorer = FALSE;

    g_argv = _CommandLineToArgvA(commandLine, &g_argc);

    if (0 == g_argc || NULL == g_argv) {
        return; // nothing to do
    }

    for (i = 0; i < g_argc; ++i) {
        pArg = g_argv[i];

        if (!_strcmpi(pArg, "ntvdm")) {
            LOGN( eDbgLevelInfo, "[ParseCommandLine] Running NTVDM.");
            g_bIsNTVDM = TRUE;

        } else if (!_strcmpi(pArg, "explorer")) {
            LOGN( eDbgLevelInfo, "[ParseCommandLine] Running Explorer.");
            g_bIsExplorer = TRUE;

        } else {
            LOGN(
                eDbgLevelError,
                "[ParseCommandLine] Unrecognized argument: \"%s\"",
                pArg);
        }
    }

    if (g_bIsNTVDM && g_bIsExplorer) {
        LOGN(
            eDbgLevelError,
            "[ParseCommandLine] Conflicting arguments! Neither will be applied.");
        g_bIsNTVDM    = FALSE;
        g_bIsExplorer = FALSE;
    }
}


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    OSVERSIONINFO osvi;
    BOOL          bHook = FALSE;

    if (fdwReason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    GetVersionEx(&osvi);

    if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) {

        ParseCommandLine(COMMAND_LINE);

        if( InitLayerStorage(FALSE) ) {
            CleanupRegistryForCurrentExe();

            if (g_bIsNTVDM) {

                bHook = TRUE;

                //
                // Retrieve the compat layer variable that we have been started with (just in case)
                //
                GetCompatLayerFromEnvironment();

                GetSeparateWowPtr(); // retrieve ptr to a sep flag

            } else if (g_bIsExplorer) {

                //
                // Cleanup compat layer variable
                //
                SetEnvironmentVariableW(g_wszCompatLayerVar, NULL);
                bHook = TRUE;

            } else {
                //
                // Neither explorer nor ntvdm. Get the compat layer.
                //
                bHook = GetCompatLayerFromEnvironment();
                if (!bHook) {
                    LOGN(
                        eDbgLevelInfo,
                        "[NOTIFY_FUNCTION] Not under the compatibility layer.");
                }
            }
        }
    }

    if (bHook) {
        APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)
        APIHOOK_ENTRY(USER32.DLL,   UserRegisterWowHandlers)
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2kpropagatelayer_environment.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Environment.Cpp

 Abstract:

   Various environment-related function

 Notes:

   Cloning environment for the purpose of using it in Rtl* environment-related functions

 History:

   10/26/00 VadimB  Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include "Win2kPropagateLayer.h"
//
//  This is so we can compare offsets if we know the segments are equal
//

#define OFFSET(x) (LOWORD((DWORD)(x)))
//
//  I'm cheating here to make some functions a little faster;
//  we won't have to push a word on the stack every time
//

static WORD gwMatch;

// 
//  ChrCmp -  Case sensitive character comparison for DBCS
//  Assumes   w1, gwMatch are characters to be compared
//  Return    FALSE if they match, TRUE if no match
//

static BOOL ChrCmp( WORD w1 )
{
    //
    //  Most of the time this won't match, so test it first for speed.
    //

    if( LOBYTE( w1 ) == LOBYTE( gwMatch ) )
    {
        if( IsDBCSLeadByte( LOBYTE( w1 ) ) )
        {
            return( w1 != gwMatch );
        }
        return FALSE;
    }
    return TRUE;
}

//
//  StrRChr - Find last occurrence of character in string
//  Assumes   lpStart points to start of string
//            lpEnd   points to end of string (NOT included in search)
//            wMatch  is the character to match
//  returns ptr to the last occurrence of ch in str, NULL if not found.
//

static LPSTR StrRChr( LPSTR lpStart, LPSTR lpEnd, WORD wMatch )
{
    LPSTR lpFound = NULL;

    if( !lpEnd )
        lpEnd = lpStart + strlen( lpStart );

    gwMatch = wMatch;

    for(  ; OFFSET( lpStart ) < OFFSET( lpEnd ); lpStart = CharNextA( lpStart ) )
    {
        if( !ChrCmp( *(LPWORD)lpStart ) )
            lpFound = lpStart;
    }

    return( lpFound );
}


//
// Find environment variable pszName within the buffer pszEnv
// ppszVal receives pointer to the variable's value
//

PSZ
ShimFindEnvironmentVar(
    PSZ  pszName,
    PSZ  pszEnv,
    PSZ* ppszVal
    )
{
    int nNameLen = strlen(pszName);
    PSZ pTemp;

    if (pszEnv != NULL) {

        while (*pszEnv != '\0') {
            //
            // Check the first char to be speedy.
            //
            if (*pszName == *pszEnv) {
                //
                // Compare the rest now.
                //
                if ((pTemp = StrRChr(pszEnv, NULL, '=')) != NULL &&
                    (int)(pTemp - pszEnv) == nNameLen &&
                    !_strnicmp(pszEnv, pszName, nNameLen)) {
                    
                    //
                    // Found it.
                    //
                    if (ppszVal != NULL) {
                        *ppszVal = pTemp + 1;
                    }
                    return pszEnv;
                }
            }

            pszEnv += strlen(pszEnv) + 1;
        }
    }

    return NULL;
}

//
// returns size in characters
// of an env block
// pStrCount receives the number of env strings
//
DWORD
ShimGetEnvironmentSize(
    PSZ     pszEnv,
    LPDWORD pStrCount
    )
{
    PSZ   pTemp   = pszEnv;
    DWORD dwCount = 0;

    while (*pTemp != '\0') {
        dwCount++;
        pTemp += strlen(pTemp) + 1;
    }
    
    pTemp++;

    if (pStrCount != NULL) {
        *pStrCount = dwCount;
    }
    return (DWORD)(pTemp - pszEnv);
}

// returns size (in characters) of an environment block

DWORD
ShimGetEnvironmentSize(
    WCHAR*  pwszEnv,
    LPDWORD pStrCount
    )
{
    WCHAR* pTemp   = pwszEnv;
    DWORD  dwCount = 0;

    while(*pTemp != L'\0') {
        dwCount++;
        pTemp += wcslen(pTemp) + 1;
    }
    
    pTemp++; // include terminating '\0'

    if (pStrCount != NULL) {
        *pStrCount = dwCount;
    }

    return (DWORD)(pTemp - pwszEnv);

}

//
// returns cloned (unicode) environment
//

NTSTATUS
ShimCloneEnvironment(
    LPVOID* ppEnvOut,
    LPVOID  lpEnvironment,
    BOOL    bUnicode
    )
{
    NTSTATUS Status    = STATUS_INVALID_PARAMETER;
    DWORD    dwEnvSize = 0;
    LPVOID   lpEnvNew  = NULL;

    MEMORY_BASIC_INFORMATION MemoryInformation;

    if (lpEnvironment == NULL) {
        Status = RtlCreateEnvironment(TRUE, &lpEnvNew);
    } else {

        //
        // Find the environment's size in characters but recalc in unicode.
        //
        dwEnvSize = (bUnicode ? ShimGetEnvironmentSize((WCHAR*)lpEnvironment, NULL) :
                                ShimGetEnvironmentSize((PSZ)lpEnvironment, NULL));

        //
        // Allocate memory -- using Zw routines (that is what rtl is using).
        //
        MemoryInformation.RegionSize = (dwEnvSize + 2) * sizeof(UNICODE_NULL);
        Status = ZwAllocateVirtualMemory(NtCurrentProcess(),
                                         &lpEnvNew,
                                         0,
                                         &MemoryInformation.RegionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);

        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimCloneEnvironment] Failed to allocate %d bytes for the environment block.",
                dwEnvSize * sizeof(UNICODE_NULL));
            return Status;
        }

        if (bUnicode) {
            //
            // Unicode, just copy the environment
            //
            RtlMoveMemory(lpEnvNew, lpEnvironment, dwEnvSize * sizeof(UNICODE_NULL));

        } else {

            //
            // The environment is ANSI, so we need to convert.
            //
            UNICODE_STRING UnicodeBuffer;
            ANSI_STRING    AnsiBuffer;

            AnsiBuffer.Buffer = (CHAR*)lpEnvironment;
            AnsiBuffer.Length = AnsiBuffer.MaximumLength = (USHORT)dwEnvSize; // size in bytes = size in chars, includes \0\0

            UnicodeBuffer.Buffer        = (WCHAR*)lpEnvNew;
            UnicodeBuffer.Length        = (USHORT)dwEnvSize * sizeof(UNICODE_NULL);
            UnicodeBuffer.MaximumLength = (USHORT)(dwEnvSize + 2) * sizeof(UNICODE_NULL); // leave room for \0

            Status = RtlAnsiStringToUnicodeString(&UnicodeBuffer, &AnsiBuffer, FALSE);
            if (!NT_SUCCESS(Status)) {
                LOGN(
                    eDbgLevelError,
                    "[ShimCloneEnvironment] Failed to convert ANSI environment to UNICODE. Status = 0x%x",
                    Status);
            }
        }
    }

    if (NT_SUCCESS(Status)) {

        *ppEnvOut = lpEnvNew;

    } else {

        if (lpEnvNew != NULL) {
            RtlDestroyEnvironment(lpEnvNew);
        }
    }

    return Status;

}

NTSTATUS
ShimFreeEnvironment(
    LPVOID lpEnvironment
    )
{
    NTSTATUS Status;

    __try {

        Status = RtlDestroyEnvironment(lpEnvironment);
        if (!NT_SUCCESS(Status)) {
            LOGN(
                eDbgLevelError,
                "[ShimFreeEnvironment] RtlDestroyEnvironment failed. Status = 0x%x",
                Status);
        }
    } __except(WOWPROCESSHISTORYEXCEPTIONFILTER) {

        Status = STATUS_ACCESS_VIOLATION;

    }

    return Status;
}

//
// Set environment variable, possibly create or clone provided environment
//

NTSTATUS
ShimSetEnvironmentVar(
    LPVOID* ppEnvironment,
    WCHAR*  pwszVarName,
    WCHAR*  pwszVarValue
    )
{
    UNICODE_STRING ustrVarName;
    UNICODE_STRING ustrVarValue;
    NTSTATUS       Status;

    RtlInitUnicodeString(&ustrVarName, pwszVarName);
    
    if (NULL != pwszVarValue) {
        RtlInitUnicodeString(&ustrVarValue, pwszVarValue);
    }
    
    Status = RtlSetEnvironmentVariable(ppEnvironment,
                                       &ustrVarName,
                                       (NULL == pwszVarValue) ? NULL : &ustrVarValue);
    if (!NT_SUCCESS(Status)) {
        LOGN(
            eDbgLevelError,
            "[ShimSetEnvironmentVar] RtlSetEnvironmentVariable failed. Status = 0x%x",
            Status);
    }

    return Status;
}

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2kpropagatelayer.h ===
#ifndef _WIN2KPROPAGATELAYER_H
#define _WIN2KPROPAGATELAYER_H


#ifdef __cplusplus
extern "C" {
#endif

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "zwapi.h"

#ifdef __cplusplus
}
#endif

#define SHIM_LIB_BUILD_FLAG
#include "vdmdbg.h"
#include "stddef.h"


#ifdef __cplusplus
extern "C" {
#endif

#include "wownt32.h"


#ifdef __cplusplus
}
#endif

//
// WINUSERP defines TAG type which conflicts
// with the definition available in shimdb.h
// we define it inside the separate namespace
// avoiding any conflicts
//

namespace NSWOWUSERP {

#ifdef __cplusplus
extern "C" {
#endif

#include "winuserp.h"
#include "wowuserp2k.h"

#ifdef __cplusplus
}
#endif

}

typedef ULONG_PTR (WINAPI *_pfn_UserRegisterWowHandlers)(NSWOWUSERP::APFNWOWHANDLERSIN apfnWowIn,
                                                         NSWOWUSERP::APFNWOWHANDLERSOUT apfnWowOut);


/////////////////////////////////////////////////////////////////////////////
//
// 16-bit TDB structure, stolen from base\mvdm\inc\tdb16.h
// Keep this in-sync
//


/*
 * Task Data Block - 16 Bit Kernel Data Structure
 *
 *   Contains all 16 bit task specific data.
 *
 */

#define numTaskInts 7
#define THUNKELEM   8   // (62*8) = 512-16 (low arena overhead)
#define THUNKSIZE   8



#pragma pack(2)

typedef struct TDB  {       /* tdb16 */

     WORD TDB_next    ;     // next task in dispatch queue
     WORD TDB_taskSP      ;     // Saved SS:SP for this task
     WORD TDB_taskSS      ;     //
     WORD TDB_nEvents     ;     // Task event counter
     BYTE TDB_priority    ;     // Task priority (0 is highest)
     BYTE TDB_thread_ordinal  ;     // ordinal number of this thread
     WORD TDB_thread_next   ;       // next thread
     WORD TDB_thread_tdb      ; // the real TDB for this task
     WORD TDB_thread_list   ;       // list of allocated thread structures
     WORD TDB_thread_free   ;       // free list of availble thread structures
     WORD TDB_thread_count  ;       // total count of tread structures
     WORD TDB_FCW         ; // Floating point control word
     BYTE TDB_flags   ;     // Task flags
     BYTE TDB_filler      ;     // keep word aligned
     WORD TDB_ErrMode     ;     // Error mode for this task
     WORD TDB_ExpWinVer   ;     // Expected Windows version for this task
     WORD TDB_Module      ;     // Task module handle to free in killtask
     WORD TDB_pModule     ;     // Pointer to the module database.
     WORD TDB_Queue   ;     // Task Event Queue pointer
     WORD TDB_Parent      ;     // TDB of the task that started this up
     WORD TDB_SigAction   ;     // Action for app task signal
     DWORD TDB_ASignalProc   ;      // App's Task Signal procedure address
     DWORD TDB_USignalProc   ;      // User's Task Signal procedure address
     DWORD TDB_GNotifyProc    ; // Task global discard notify proc.
     DWORD TDB_INTVECS[numTaskInts] ;   // Task specfic harare interrupts
     WORD TDB_CompatFlags ;     // Compatibility flags
     WORD TDB_CompatFlags2 ;        // Upper 16 bits
     WORD TDB_CompatHandle ;    // for dBase bug
     WORD TDB_WOWCompatFlagsEx ;     // More WOW Compatibility flags
     WORD TDB_WOWCompatFlagsEx2 ;        // Upper 16 bits
     BYTE TDB_Free[3] ;         // Filler to keep TDB size unchanged
     BYTE TDB_cLibrary    ;     // tracks  add/del of ALL libs in system EMS
     DWORD TDB_PHT        ; // (HANDLE:OFFSET) to private handle table
     WORD TDB_PDB         ; // MSDOS Process Data Block (PDB)
     DWORD TDB_DTA        ; // MSDOS Disk Transfer Address
     BYTE TDB_Drive  ;      // MSDOS current drive
     BYTE TDB_Directory[65] ;       // *** not used starting with win95
     WORD TDB_Validity    ;     // initial AX to be passed to a task
     WORD TDB_Yield_to    ;     // DirectedYield arg stored here
     WORD TDB_LibInitSeg      ; // segment address of libraries to init
     WORD TDB_LibInitOff      ; // MakeProcInstance thunks live here.
     WORD TDB_MPI_Sel     ;     // Code selector for thunks
     WORD TDB_MPI_Thunks[((THUNKELEM*THUNKSIZE)/2)]; //
     BYTE TDB_ModName[8] ;      // Name of Module.
     WORD TDB_sig         ; // Signature word to detect bogus code
     DWORD TDB_ThreadID   ;     // 32-Bit Thread ID for this Task (use TDB_Filler Above)
     DWORD TDB_hThread    ; // 32-bit Thread Handle for this task
     WORD  TDB_WOWCompatFlags;  // WOW Compatibility flags
     WORD  TDB_WOWCompatFlags2; // WOW Compatibility flags
#ifdef FE_SB
     WORD  TDB_WOWCompatFlagsJPN;  // WOW Compatibility flags for JAPAN
     WORD  TDB_WOWCompatFlagsJPN2; // WOW Compatibility flags for JAPAN
#endif // FE_SB
     DWORD TDB_vpfnAbortProc;   // printer AbortProc
     BYTE TDB_LFNDirectory[260]; // Long directory name

} TDB;
typedef TDB UNALIGNED *PTDB;

// This bit is defined for the TDB_Drive field
#define TDB_DIR_VALID 0x80
#define TDB_SIGNATURE 0x4454

#define TDBF_OS2APP   0x8
#define TDBF_WINOLDAP 0x1


// NOTE TDB_ThreadID MUST be DWORD aligned or else it will fail on MIPS

#pragma pack()


/////////////////////////////////////////////////////////////////////////////
//
// DOSPDB structure, stolen from base\mvdm\inc\doswow.h
//
//


#pragma pack(1)

typedef struct _DOSPDB {                        // DOS Process Data Block
    CHAR   PDB_Not_Interested[44];      // Fields we are not interested in
    USHORT PDB_environ;             // segment of environment
    DWORD  PDB_User_stack;
    USHORT PDB_JFN_Length;          // JFT length
    ULONG  PDB_JFN_Pointer;         // JFT pointer
} DOSPDB, *PDOSPDB;

#pragma pack()


///////////////////////////////////////////////////////////////////////////////
//
//
// Variables and functions that are local to this project
//

//
// defined in wowprocesshistory.cpp
//

extern CHAR     g_szCompatLayerVar[];
extern CHAR     g_szProcessHistoryVar[];
extern CHAR     g_szShimFileLogVar[];

extern WCHAR    g_wszCompatLayerVar[];

extern BOOL     g_bIsNTVDM;
extern BOOL     g_bIsExplorer;

extern WCHAR*   g_pwszCompatLayer;

//
// Function in Win2kPropagateLayer that allows us to create env from wow data
//

LPVOID
ShimCreateWowEnvironment_U(
    LPVOID lpEnvironment,       // pointer to the existing environment
    DWORD* lpdwFlags,           // process creation flags
    BOOL   bNewEnvironment      // when set, forces us to clone environment ptr
    );


//
// functions in environment.cpp
//
PSZ
ShimFindEnvironmentVar(
    PSZ  pszName,
    PSZ  pszEnv,
    PSZ* ppszVal
    );

DWORD
ShimGetEnvironmentSize(
    PSZ     pszEnv,
    LPDWORD pStrCount
    );

DWORD
ShimGetEnvironmentSize(
    WCHAR*  pwszEnv,
    LPDWORD pStrCount
    );

NTSTATUS
ShimCloneEnvironment(
    LPVOID* ppEnvOut,
    LPVOID  lpEnvironment,
    BOOL    bUnicode
    );

NTSTATUS
ShimFreeEnvironment(
    LPVOID lpEnvironment
    );

NTSTATUS
ShimSetEnvironmentVar(
    LPVOID* ppEnvironment,
    WCHAR*  pwszVarName,
    WCHAR*  pwszVarValue
    );

//
// stuff in wowtask.cpp
//

//
// Structure to reflect WOW environment values
//

typedef struct tagWOWENVDATA {

    PSZ   pszCompatLayer; // fully-formed compat layer variable
    PSZ   pszCompatLayerVal;

    PSZ   pszProcessHistory; // fully-formed process history variable
    PSZ   pszProcessHistoryVal;

    PSZ   pszShimFileLog;   // file log variable
    PSZ   pszShimFileLogVal;

    // buffer that we use for the accomulated process history,
    PSZ   pszCurrentProcessHistory;

} WOWENVDATA, *PWOWENVDATA;



//
// function to retrieve all the "interesting" things out of wow environment
//


BOOL
ShimRetrieveVariablesEx(
    PWOWENVDATA pData
    );

//
// Store information about wow task
//

BOOL
UpdateWowTaskList(
    WORD hTask16
    );

//
// wow task exits, cleanup the list
//

BOOL
CleanupWowTaskList(
    WORD hTask16
    );


//
// Functions in cleanup.cpp
//


BOOL
CleanupRegistryForCurrentExe(
    void
    );

//
// functions in win2kpropagatelayer.cpp
//

BOOL
InitLayerStorage(
    BOOL bDelete
    );

BOOL
AddSupport(
    LPCWSTR lpCommandLine,
    LPVOID* ppEnvironment,
    LPDWORD lpdwCreationFlags
    );

BOOL
CheckAndShimNTVDM(
    WORD hTask16
    );



//
// Exception filter, proto for the function in WowProcessHistory.cpp
//
//

ULONG
Win2kPropagateLayerExceptionHandler(
    PEXCEPTION_POINTERS pexi,
    char * szFile,
    DWORD dwLine
    );

//
// Exception filter to use with our hooks
//

#define WOWPROCESSHISTORYEXCEPTIONFILTER \
    Win2kPropagateLayerExceptionHandler(GetExceptionInformation(), __FILE__, __LINE__)


#endif // _WIN2KPROPAGATELAYER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win2kpropagatelayer_wowtask.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   WoWTask.cpp

 Abstract:

   Functions that retrieve process-history related information from
   16-bit environment. This includes the retrieval of the correct
   __PROCESS_HISTORY that was passed in from the parent (32-bit)process
   and tracing the process history through WOW

 Notes:


 History:

   10/26/00 VadimB  Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win2kPropagateLayer)
#include "ShimHookMacro.h"

#include "Win2kPropagateLayer.h"


typedef struct tagFINDWOWTASKDATA {
    BOOL  bFound;
    DWORD dwProcessId;
    DWORD dwThreadId;
    WORD  hMod16;
    WORD  hTask16;

} FINDWOWTASKDATA, *PFINDWOWTASKDATA;


//
// Dynamically Linked apis
//
//  from WOW32.dll
//

typedef LPVOID (WINAPI *PFNWOWGetVDMPointer)(DWORD vp,
                                             DWORD dwBytes,
                                             BOOL  fProtectedMode);

//
//  from vdmdbg.dll - defined in the header file
//
//

typedef INT (WINAPI *PFNVDMEnumTaskWOW)(DWORD        dwProcessId,
                                        TASKENUMPROC fp,
                                        LPARAM       lparam);

//
// Api importing -- modules
//
WCHAR g_wszWOW32ModName[]  = L"wow32.dll";
WCHAR g_wszVdmDbgModName[] = L"VdmDbg.dll";

//
// Api importing - module handles and function pointers
//

HMODULE g_hWow32;
HMODULE g_hVdmDbg;
BOOL    g_bInitialized;  // set to true when imports are initialized

PFNWOWGetVDMPointer  g_pfnWOWGetVDMPointer;
PFNVDMEnumTaskWOW    g_pfnVDMEnumTaskWOW;

extern BOOL* g_pSeparateWow;


//
// function in this module to import apis
//

BOOL ImportWowApis(VOID);


//
// Marcro to access 16-bit memory
//


#define SEGPTR(seg,off)  ((g_pfnWOWGetVDMPointer)((((ULONG)seg) << 16) | (off), 0, TRUE))

//
// task enum proc, called back from vdmdbg
//

BOOL WINAPI MyTaskEnumProc(
    DWORD dwThreadId,
    WORD  hMod16,
    WORD  hTask16,
    LPARAM lParam
    )
{
    PFINDWOWTASKDATA pFindData = (PFINDWOWTASKDATA)lParam;

    if (dwThreadId == pFindData->dwThreadId) {
        pFindData->hMod16  = hMod16;
        pFindData->hTask16 = hTask16;
        pFindData->bFound  = TRUE;
        return TRUE;
    }

    return FALSE;
}


BOOL FindWowTask(
    DWORD dwProcessId,
    DWORD dwThreadId,
    PFINDWOWTASKDATA pFindData
    )
{
    RtlZeroMemory(pFindData, sizeof(*pFindData));

    pFindData->dwProcessId = dwProcessId;
    pFindData->dwThreadId  = dwThreadId;

    g_pfnVDMEnumTaskWOW(dwProcessId, (TASKENUMPROC)MyTaskEnumProc, (LPARAM)pFindData);

    return pFindData->bFound;
}


//
// get the pointer to task database block from hTask
//


PTDB
GetTDB(
    WORD wTDB
    )
{
    PTDB pTDB;

    pTDB = (PTDB)SEGPTR(wTDB, 0);
    if (NULL == pTDB || TDB_SIGNATURE != pTDB->TDB_sig) {
        LOGN(
            eDbgLevelError,
            "[GetTDB] TDB is invalid for task 0x%x",
            (DWORD)wTDB);
        return NULL;
    }

    return pTDB;
}


//
// GetModName
//   wTDB      - TDB entry
//   szModName - pointer to the buffer that receives module name
//               buffer should be at least 9 characters long
//
// returns FALSE if the entry is invalid


BOOL
GetModName(
    WORD wTDB,
    PCH  szModName
    )
{
    PTDB pTDB;
    PCH  pch;

    pTDB = GetTDB(wTDB);
    if (NULL == pTDB) {
        return FALSE;
    }

    RtlCopyMemory(szModName, pTDB->TDB_ModName, 8 * sizeof(CHAR)); // we have modname now
    szModName[8] = '\0';

    pch = &szModName[8];
    while (--pch >= szModName && *pch == ' ') {
        *pch = 0;
    }

    if( pch < szModName ) {
        return FALSE;
    }

    return TRUE;
}


//
// ShimGetTaskFileName
//      IN wTask - 16-bit task handle
// Returns:
//      Fully qualified exe that is running in this task's context
//


PSZ
ShimGetTaskFileName(
    WORD wTask
    )
{
    PSZ pszFileName = NULL;
    PTDB pTDB;

    pTDB = GetTDB(wTask);
    if (NULL == pTDB) {
        // this is really bad -- the module is invalid, debug output is generated by GetTDB
        return pszFileName;
    }

    if (NULL == pTDB->TDB_pModule) {
        LOGN(
            eDbgLevelError,
            "[ShimGetTaskFileName] module pointer is NULL for 0x%x",
            (DWORD)wTask);
        return pszFileName;
    }

    pszFileName = (PSZ)SEGPTR(pTDB->TDB_pModule, (*(WORD *)SEGPTR(pTDB->TDB_pModule, 10)) + 8);
    return pszFileName;
}


PSZ 
ShimGetTaskEnvptr(
    WORD hTask16
    )
{
    PTDB pTDB = GetTDB(hTask16);
    PSZ  pszEnv = NULL;
    PDOSPDB pPSP;

    if (NULL == pTDB) {
        LOGN( eDbgLevelError, 
            "[ShimGetTaskEnvptr] Bad TDB entry 0x%x",  hTask16);
        return NULL;
    }
    
    //
    // Prepare environment data - this buffer is used when we're starting a new task from the
    // root of the chain (as opposed to spawning from an existing 16-bit task)
    //

    pPSP   = (PDOSPDB)SEGPTR(pTDB->TDB_PDB, 0); // psp
        
    if (pPSP != NULL) {
        pszEnv = (PCH)SEGPTR(pPSP->PDB_environ, 0);
    }

    return pszEnv;
}
    

// IsWowExec
//      IN wTDB - entry into the task database
// Returns:
//      TRUE if this particular entry points to WOWEXEC
//
// Note:
//      WOWEXEC is a special stub module that always runs on NTVDM
//      new tasks are spawned by wowexec (in the most typical case)
//      it is therefore the "root" module and it's environment's contents
//      should not be counted, since we don't know what was ntvdm's parent process
//

BOOL
IsWOWExec(
    WORD wTDB
    )
{
    PTDB pTDB;
    CHAR szModName[9];

    pTDB = GetTDB(wTDB);
    if (NULL == pTDB) {
        LOGN(
            eDbgLevelError,
            "[IsWOWExec] Bad TDB entry 0x%x",
            (DWORD)wTDB);
        return FALSE;
    }

    if (!GetModName(wTDB, szModName)) { // can we get modname ?
        LOGN(
            eDbgLevelError,
            "[IsWOWExec] GetModName failed.");
        return FALSE;
    }

    return (0 == _strcmpi(szModName, "wowexec")); // is the module named WOWEXEC ?
}

//
// ImportWowApis
//      Function imports necessary apis from wow32.dll and vdmdbg.dll
//
//

BOOL
ImportWowApis(
    VOID
    )
{
    g_hWow32 = LoadLibraryW(g_wszWOW32ModName);
    
    if (g_hWow32 == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to load wow32.dll Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_pfnWOWGetVDMPointer = (PFNWOWGetVDMPointer)GetProcAddress(g_hWow32, "WOWGetVDMPointer");
    
    if (g_pfnWOWGetVDMPointer == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to get address of WOWGetVDMPointer Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_hVdmDbg = LoadLibraryW(g_wszVdmDbgModName);
    
    if (g_hVdmDbg == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to load vdmdbg.dll Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_pfnVDMEnumTaskWOW = (PFNVDMEnumTaskWOW)GetProcAddress(g_hVdmDbg, "VDMEnumTaskWOW");
    
    if (g_pfnVDMEnumTaskWOW == NULL) {
        LOGN(
            eDbgLevelError,
            "[ImportWowApis] Failed to get address of VDMEnumTaskWOW Error 0x%x",
            GetLastError());
        goto Fail;
    }

    g_bInitialized = TRUE;

    return TRUE;

Fail:

    if (g_hWow32) {
        FreeLibrary(g_hWow32);
        g_hWow32 = NULL;
    }
    if (g_hVdmDbg) {
        FreeLibrary(g_hVdmDbg);
        g_hVdmDbg = NULL;
    }
    g_pfnWOWGetVDMPointer = NULL;
    g_pfnVDMEnumTaskWOW   = NULL;

    return FALSE;

}


/////////////////////////////////////////////////////////////////////////////////////////////
//
//
// WOWTaskList
//
// We maintain a shadow list of running wow tasks complete with respective process history and
// inherited process history
//
//

typedef struct tagWOWTASKLISTITEM* PWOWTASKLISTITEM;

typedef struct tagWOWTASKLISTITEM {

    WORD  hTask16;                 // 16-bit tdb entry

    DWORD dwThreadId;              // thread id of the task

    WOWENVDATA EnvData;            // environment data (process history, compat layer, etc)

    PWOWTASKLISTITEM pTaskNext;

} WOWTASKLISTITEM;

PWOWTASKLISTITEM g_pWowTaskList;


/*++

    FindWowTaskInfo

        IN hTask16                   16-bit task's handle
        IN dwThreadId OPTIONAL       32-bit thread id of the task, might be 0

    Returns: pointer to the task information structure

--*/

PWOWTASKLISTITEM
FindWowTaskInfo(
    WORD  hTask16,
    DWORD dwThreadId
    )
{
    PWOWTASKLISTITEM pTask = g_pWowTaskList;

    while (NULL != pTask) {

        if (hTask16 == pTask->hTask16) {

            if (dwThreadId == 0 || dwThreadId == pTask->dwThreadId) {
                break;
            }
        }

        pTask = pTask->pTaskNext;
    }

    return pTask;
}

/*++

    UpdateWowTaskList

        IN hTask16              16-bit task's handle

    Returns: True if the task was added successfully
    Note:    wowexec is not among the "legitimate" tasks

--*/


BOOL
UpdateWowTaskList(
    WORD hTask16
    )
{
    PTDB             pTDB;
    WORD             wTaskParent;
    PWOWTASKLISTITEM pTaskParent = NULL;
    LPSTR            lpszFileName;
    PSZ              pszEnv;
    WOWENVDATA       EnvData;
    PWOWENVDATA      pData = NULL;
    DWORD            dwLength;
    PWOWTASKLISTITEM pTaskNew;
    PCH              pBuffer;
    PDOSPDB          pPSP;
    BOOL             bSuccess;

    //
    // see that we are initialized, import apis
    //
    if (!g_bInitialized) { // first call, link apis
        bSuccess = ImportWowApis();
        if (!bSuccess) {
            LOGN(
                eDbgLevelError,
                "[UpdateWowTaskList] Failed to import apis.");
            return FALSE;
        }
    }

    //
    // If this task is WOWEXEC -- just return, it's not an error condition, but we don't need
    // wowexec in our list
    //

    if (IsWOWExec(hTask16)) {  // this is ok, we don't want wowexec
        return FALSE;
    }

    //
    // next, see what the parent item is, to do so -- access it through TDB
    //

    pTDB = GetTDB(hTask16);
    if (NULL == pTDB) {
        LOGN(
            eDbgLevelError,
            "[UpdateWowTaskList] Bad TDB entry 0x%x",
            hTask16);
        return FALSE;
    }

    //
    // Prepare environment data - this buffer is used when we're starting a new task from the
    // root of the chain (as opposed to spawning from an existing 16-bit task)
    //

    RtlZeroMemory(&EnvData, sizeof(EnvData));
    pData = &EnvData;

    wTaskParent = pTDB->TDB_Parent;
    
    if (IsWOWExec(wTaskParent) || GetTDB(wTaskParent) == NULL) {
        //
        // Root task, extract process history, compat layer, etc
        //
        pszEnv = NULL;
        pPSP   = (PDOSPDB)SEGPTR(pTDB->TDB_PDB, 0); // psp
        
        if (pPSP != NULL) {
            pszEnv = (PCH)SEGPTR(pPSP->PDB_environ, 0);
        }

        //
        // we have a pointer to the current environment here, pData is initialized
        //
        if (pszEnv != NULL) {
            pData->pszProcessHistory = ShimFindEnvironmentVar(g_szProcessHistoryVar,
                                                              pszEnv,
                                                              &pData->pszProcessHistoryVal);
            
            pData->pszCompatLayer    = ShimFindEnvironmentVar(g_szCompatLayerVar,
                                                              pszEnv,
                                                              &pData->pszCompatLayerVal);
            
            pData->pszShimFileLog    = ShimFindEnvironmentVar(g_szShimFileLogVar,
                                                              pszEnv,
                                                              &pData->pszShimFileLogVal);
        }

    } else {
        //
        // Not a root task, find parent process
        //
        pTaskParent = FindWowTaskInfo(wTaskParent, 0); // we can't determine which thread owns the task

        if (pTaskParent == NULL) {
            //
            // something is very wrong
            // we can't inherit
            //

            LOGN(
                eDbgLevelError,
                "[UpdateWowTaskList] Task 0x%x is not root but parent not listed 0x%x",
                (DWORD)hTask16,
                (DWORD)wTaskParent);
            //
            // we still allow building up process history. The initial variables will be empty
            //


        } else {
            //
            // inherit everything from the parent and add it's module name (later)
            //

            pData = &pTaskParent->EnvData;
        }
    }

    //
    // Get the filename involved
    //
    //

    lpszFileName = ShimGetTaskFileName(hTask16);

    //
    // now calculate how much space is required to hold all of the data
    //

    dwLength = sizeof(WOWTASKLISTITEM) +
               (NULL == pData->pszProcessHistory        ? 0 : (strlen(pData->pszProcessHistory) + 1) * sizeof(CHAR)) +
               (NULL == pData->pszCompatLayer           ? 0 : (strlen(pData->pszCompatLayer) + 1) * sizeof(CHAR)) +
               (NULL == pData->pszShimFileLog           ? 0 : (strlen(pData->pszShimFileLog) + 1) * sizeof(CHAR)) +
               (NULL == pData->pszCurrentProcessHistory ? 0 : (strlen(pData->pszCurrentProcessHistory) + 2) * sizeof(CHAR)) +
               (NULL == lpszFileName                    ? 0 : (strlen(lpszFileName) + 1) * sizeof(CHAR));


    pTaskNew = (PWOWTASKLISTITEM)ShimMalloc(dwLength);
    
    if (pTaskNew == NULL) {
        LOGN(
            eDbgLevelError,
            "[UpdateWowTaskList] failed to allocate 0x%x bytes",
            dwLength);
        return FALSE;
    }

    RtlZeroMemory(pTaskNew, dwLength);

    //
    // now this entry has to be setup
    // process history is first
    //

    pBuffer = (PCH)(pTaskNew + 1);
    // Keep track of how much of the buffer is left.
    size_t cchRemaining = dwLength - sizeof(WOWTASKLISTITEM);

    pTaskNew->hTask16    = hTask16;
    pTaskNew->dwThreadId = GetCurrentThreadId();

    if (pData->pszProcessHistory != NULL) {

        //
        // Copy process history. The processHistoryVal is a pointer into the buffer
        // pointed to by pszProcessHistory: __PROCESS_HISTORY=c:\foo;c:\docs~1\install
        // then pszProcessHistoryVal will point here ---------^
        //
        // we are copying the data and moving the pointer using the calculated offset

        pTaskNew->EnvData.pszProcessHistory = pBuffer;
        StringCchCopyExA(pTaskNew->EnvData.pszProcessHistory, cchRemaining, pData->pszProcessHistory, NULL, &cchRemaining, 0);
        pTaskNew->EnvData.pszProcessHistoryVal = pTaskNew->EnvData.pszProcessHistory +
                                                 (INT)(pData->pszProcessHistoryVal - pData->pszProcessHistory);
        //
        // There is enough space in the buffer to accomodate all the strings, so
        // move pointer past current string to point at the "empty" space
        //

        pBuffer += strlen(pData->pszProcessHistory) + 1;
    }

    if (pData->pszCompatLayer != NULL) {
        pTaskNew->EnvData.pszCompatLayer = pBuffer;
        StringCchCopyExA(pTaskNew->EnvData.pszCompatLayer, cchRemaining, pData->pszCompatLayer, NULL, &cchRemaining, 0);
        pTaskNew->EnvData.pszCompatLayerVal = pTaskNew->EnvData.pszCompatLayer +
                                              (INT)(pData->pszCompatLayerVal - pData->pszCompatLayer);
        pBuffer += strlen(pData->pszCompatLayer) + 1;
    }

    if (pData->pszShimFileLog != NULL) {
        pTaskNew->EnvData.pszShimFileLog = pBuffer;
        StringCchCopyExA(pTaskNew->EnvData.pszShimFileLog, cchRemaining, pData->pszShimFileLog, NULL, &cchRemaining, 0);
        pTaskNew->EnvData.pszShimFileLogVal = pTaskNew->EnvData.pszShimFileLog +
                                              (INT)(pData->pszShimFileLogVal - pData->pszShimFileLog);
        pBuffer += strlen(pData->pszShimFileLog) + 1;
    }

    if (pData->pszCurrentProcessHistory != NULL || lpszFileName != NULL) {
        //
        // Now process history
        //
        pTaskNew->EnvData.pszCurrentProcessHistory = pBuffer;
        
        if (pData->pszCurrentProcessHistory != NULL) {
            StringCchCopyExA(pTaskNew->EnvData.pszCurrentProcessHistory, cchRemaining, pData->pszCurrentProcessHistory, NULL, &cchRemaining, 0);
            if (lpszFileName != NULL ) {
                StringCchCatExA(pTaskNew->EnvData.pszCurrentProcessHistory, cchRemaining, ";", NULL, &cchRemaining, 0);
            }
        }
        
        if (lpszFileName != NULL) {
            StringCchCatA(pTaskNew->EnvData.pszCurrentProcessHistory, cchRemaining, lpszFileName);
        }
    }

    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] Running           : \"%s\"",
        lpszFileName);
    
    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] ProcessHistory    : \"%s\"",
        pTaskNew->EnvData.pszCurrentProcessHistory);
    
    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] BaseProcessHistory: \"%s\"",
        pTaskNew->EnvData.pszProcessHistory);
    
    LOGN(
        eDbgLevelInfo,
        "[UpdateWowTaskList] CompatLayer       : \"%s\"",
        pTaskNew->EnvData.pszCompatLayer);


    //
    // We are done, link the entry into the list
    //
    pTaskNew->pTaskNext = g_pWowTaskList;

    g_pWowTaskList = pTaskNew;

    return TRUE;
}


/*++

    CleanupWowTaskList

        IN hTask16  16-bit task handle that is to be removed from the list of running tasks

    Returns : TRUE if the function succeeds

--*/

BOOL
CleanupWowTaskList(
    WORD hTask16
    )
{
    PWOWTASKLISTITEM pTask = g_pWowTaskList;
    PWOWTASKLISTITEM pTaskPrev = NULL;

    while (pTask != NULL) {

        if (pTask->hTask16 == hTask16) {
            // this is the item
            break;
        }

        pTaskPrev = pTask;
        pTask = pTask->pTaskNext;
    }

    if (pTask == NULL) {
        LOGN(
            eDbgLevelError,
            "[CleanupWowTaskList] Failed to locate task information for 0x%x",
            (DWORD)hTask16);
        return FALSE;
    }


    if (pTaskPrev == NULL) {

        g_pWowTaskList = pTask->pTaskNext;

    } else {

        pTaskPrev->pTaskNext = pTask->pTaskNext;

    }

    ShimFree(pTask);

    return TRUE;

}

/*++

    ShimRetrieveVariablesEx

        IN pData        Structure that receives pointers to all the relevant environment information
                        for the calling thread. The threads are scheduled non-preemptively by user and
                        threadid is used to identify the calling 16-bit task
                        All the real work on information retrieval is done in UpdateWowTaskList

    Returns: TRUE if success
--*/

BOOL
ShimRetrieveVariablesEx(
    PWOWENVDATA pData
    )
{
    DWORD            dwProcessId = GetCurrentProcessId();
    DWORD            dwThreadId  = GetCurrentThreadId();
    PWOWTASKLISTITEM pTask;
    FINDWOWTASKDATA  FindData;
    WORD             hTask;
    BOOL             bSuccess;

    RtlZeroMemory(pData, sizeof(*pData));

    if (!g_bInitialized) { // first call, link apis
        bSuccess = ImportWowApis();
        if (!bSuccess) {
            LOGN(
                eDbgLevelError,
                "[ShimRetrieveVariablesEx] Failed to import apis.");
            return FALSE;
        }
    }

    if (!FindWowTask(dwProcessId, dwThreadId, &FindData)) {
        LOGN(
            eDbgLevelError,
            "[ShimRetrieveVariablesEx] Task not found ProcessId 0x%x ThreadId 0x%x",
            dwProcessId,
            dwThreadId);
        return FALSE;
    }

    hTask = FindData.hTask16;

    pTask = FindWowTaskInfo(hTask, dwThreadId);
    
    if (pTask == NULL) {
        LOGN(
            eDbgLevelError,
            "[ShimRetrieveVariablesEx] Failed to locate wow task.");
        return FALSE;
    }

    //
    // Found this one. Copy the info.
    //
    RtlMoveMemory(pData, &pTask->EnvData, sizeof(*pData));

    return TRUE;
}

/*++ 
    ShimThisProcess

    Function invokes Shim Engine for dynamic shimming of the current process 
    Which happens to be ntvdm, naturally. This ntvdm is a separate ntvdm 
    (which is insured through various checks in CheckAndShimNTVDM) 

--*/

BOOL
ShimThisProcess(
    HMODULE hModShimEngine,
    HSDB    hSDB,
    SDBQUERYRESULT* pQueryResult
    )
{
    typedef BOOL    (WINAPI *PFNDynamicShim)(LPCWSTR , HSDB , SDBQUERYRESULT*, LPCSTR, LPDWORD);
    PFNDynamicShim  pfnDynamicShim = NULL;
    WCHAR wszFileName[MAX_PATH];
    DWORD dwLength;
    DWORD dwDynamicToken = 0;

    pfnDynamicShim = (PFNDynamicShim) GetProcAddress(hModShimEngine, "SE_DynamicShim");
    if (NULL == pfnDynamicShim) {
        LOGN( eDbgLevelError, 
            "[ShimThisProcess] failed to obtain dynamic shim proc address\n");
        return FALSE;
    }

    dwLength = GetModuleFileNameW(GetModuleHandle(NULL), wszFileName, CHARCOUNT(wszFileName));
    if (!dwLength || dwLength == CHARCOUNT(wszFileName)) {
        LOGN( eDbgLevelError, 
            "[ShimThisProcess] failed to obtain module file name\n");
        return FALSE;
    }

    return pfnDynamicShim(wszFileName, hSDB, pQueryResult, NULL, &dwDynamicToken);
}

/*++ 
    CheckAndShimNTVDM
    
    Procedure checks ntvdm application for having to be shimmed. If an application is located in 
    appcompat database, this ntvdm would have to be running as a separate ntvdm (explorer is shimmed as 
    well, as a result it will have checked the binary first and set the separate vdm flag in CreateProcess)

    Further, this call comes through InitTask (intercepted between ntvdm and user32) -- as a parameter it 
    takes hTask16 - which we're able to use to retrieve application's environment and other important 
    information.
--*/


BOOL
CheckAndShimNTVDM(
    WORD hTask16
    )
{
    HMODULE  hModShimEngine;
    CString  csTaskFileName;
    PSZ      pszEnv  = NULL;
    PTDB     pTDB    = NULL;
    PVOID    pEnvNew = NULL;
    BOOL     bSuccess = FALSE;
    BOOL     bMatch;
    BOOL     bNewEnv  = FALSE;
    HSDB     hSDB;
    NTSTATUS Status;
    SDBQUERYRESULT QueryResult;
    DWORD    dwFlags;

    hModShimEngine = GetModuleHandle(TEXT("shim.dll"));
    if (hModShimEngine == NULL) {
        // impossible -- shim.dll is not injected!!!
        return FALSE;
    }
    
    if (g_pSeparateWow != NULL && *g_pSeparateWow == FALSE) {
        // 
        // not a separate wow
        //
        LOGN( eDbgLevelError,
            "[CheckAndShimNTVDM] running in shared wow, no shimming\n");
        return FALSE;
    }

    if (!g_bInitialized) { // first call, link apis
        bSuccess = ImportWowApis();
        if (!bSuccess) {
            LOGN( eDbgLevelError,
                "[CheckAndShimNTVDM] Failed to import apis.\n");
            return FALSE;
        }
    }

    if (IsWOWExec(hTask16)) {
        LOGN( eDbgLevelError,
            "[CheckAndShimNTVDM] not touching wowexec\n");
        
        return FALSE;
    }

    csTaskFileName = ShimGetTaskFileName(hTask16);
    if (csTaskFileName.IsEmpty()) {
        LOGN( eDbgLevelError,
            "[CheckAndShimNTVDM] failed to get the filename for task 0x%lx\n", hTask16);
        return FALSE;
    }
    
    //
    // init database
    //
    hSDB = SdbInitDatabase(0, NULL);

    if (hSDB == NULL) {
        LOGN( eDbgLevelError, 
            "[CheckAndShimNTVDM] failed to init shim database\n");
        return FALSE;
    } 


    //
    // process history please -- 
    // if we end up here, we are a separate ntvdm 
    // running with a process history in the env, was retrieved in init
    //

    pTDB = GetTDB(hTask16);
    if (NULL == pTDB) {
        LOGN( eDbgLevelError, "[UpdateWowTaskList] Bad TDB entry 0x%x",  hTask16);
        return FALSE;
    }

    //
    // Prepare environment data - this buffer is used when we're starting a new task from the
    // root of the chain (as opposed to spawning from an existing 16-bit task)
    //

    pszEnv = ShimGetTaskEnvptr(hTask16);
    if (NULL != pszEnv) {
        Status = ShimCloneEnvironment(&pEnvNew, (LPVOID)pszEnv, FALSE);
        if (!NT_SUCCESS(Status)) {
            LOGN( eDbgLevelError, 
                "[CheckAndShimNTVDM] cannot clone environment 0x%lx\n", Status);
            pEnvNew = NULL;
            bNewEnv = TRUE;
        }

        // 
        // if this call has come the way of VDM - we need to carry over our environment stuff
        // which is stored separately in this shim
        //
        // should the call to ShimCloneEnvironment fail, we will have pEnvNew == NULL
        // and bNewEnv = TRUE, as a result, we shall try again to clone the environment

        
        dwFlags = CREATE_UNICODE_ENVIRONMENT;
        pEnvNew = ShimCreateWowEnvironment_U(pEnvNew, &dwFlags, bNewEnv);
    }
    
    //
    // run detection please
    //
    
    bMatch = SdbGetMatchingExe(hSDB,
                               (LPCWSTR)csTaskFileName,
                               NULL, // we can give out module name as well -- but WHY?
                               (LPCWSTR)pEnvNew,
                               0,
                               &QueryResult);
                                  
    if (bMatch) {
        bSuccess = ShimThisProcess(hModShimEngine, hSDB, &QueryResult);
    }
                     
    if (pEnvNew != NULL) {
        ShimFreeEnvironment(pEnvNew);
    }
    
    return bSuccess;
}
    


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win95versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win95VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 95
   version credentials. Applications often check to ensure that they are 
   running on a Win9x system, even though they will run OK on an NT based 
   system.

 Notes:

   This is a general purpose shim.

 History:

   11/10/1999 v-johnwh  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win95VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersion)
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
APIHOOK_ENUM_END

// Used for layer to turn on SafeDisc checking
BOOL g_bCheckSafeDisc = FALSE;

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExA)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
            
            LOGN(eDbgLevelInfo, "[GetVersionExA] Return Win95");
            
            //
            // Fixup the structure with the Win95 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 0;
            lpVersionInformation->dwBuildNumber = 950;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = '\0';

            bReturn = TRUE;
        }
        
        return bReturn;
    }
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExW)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
            
            LOGN(eDbgLevelInfo, "[GetVersionExW] Return Win95");
            
            //
            // Fixup the structure with the Win95 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 0;
            lpVersionInformation->dwBuildNumber = 950;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = L'\0';

            bReturn = TRUE;
        }
        
        return bReturn;
    }
}

/*++

 This stub function returns Windows 95 credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersion)();
    } else {
        LOGN(eDbgLevelInfo, "[GetVersion] Return Win95");
        return (DWORD)0xC3B60004;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_bCheckSafeDisc = COMMAND_LINE && (_stricmp(COMMAND_LINE, "Detect_SafeDisc") == 0);

        if (g_bCheckSafeDisc && bIsSafeDisc1())
        {
            LOGN(eDbgLevelWarning, "SafeDisc 1.x detected: ignoring shim");
            return FALSE;
        }
    }
    
    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\winnt4sp5versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinNT4SP5VersionLie.cpp

 Abstract:

   This DLL APIHooks GetVersion and GetVersionEx so that they return Windows NT
   Service Pack 5 version credentials. Applications often check to ensure that 
   they are running on a certain Win NTsystem, even though the current system 
   is of higher build then the one they are checking for.

 Notes:

   This is a general purpose shim.

 History:

    11/10/1999 v-johnwh Created
    02/14/2002 mnikkel  Converted to use strsafe.h

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinNT4SP5VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA) 
    APIHOOK_ENUM_ENTRY(GetVersionExW) 
    APIHOOK_ENUM_ENTRY(GetVersion) 
APIHOOK_ENUM_END

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows NT Service Pack 5 credentials.

--*/

BOOL 
APIHOOK(GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation)
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation))  {
        // Fixup the structure with the NT data
        lpVersionInformation->dwMajorVersion = 4;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber = 1381;
        lpVersionInformation->dwPlatformId = VER_PLATFORM_WIN32_NT;
        //szCSDVersion is 128 TCHAR, our string fits with no problems.
        StringCchCopyA(lpVersionInformation->szCSDVersion,
                ARRAYSIZE(lpVersionInformation->szCSDVersion), "Service Pack 5");

        DPFN( eDbgLevelInfo, "GetVersionExA called. return NT4 SP5\n");

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is returned to 
 the caller with Win NT Service Pack 5 credentials. This is the 
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation)
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation))  {
        // Fixup the structure with the Win NT Service Pack 5 data
        lpVersionInformation->dwMajorVersion = 4;
        lpVersionInformation->dwMinorVersion = 0;
        lpVersionInformation->dwBuildNumber = 1381;
        lpVersionInformation->dwPlatformId = VER_PLATFORM_WIN32_NT;
        //szCSDVersion is 128 TCHAR, our string fits with no problems.
        StringCchCopyW(lpVersionInformation->szCSDVersion,
                ARRAYSIZE(lpVersionInformation->szCSDVersion), L"Service Pack 5");

        DPFN( eDbgLevelInfo, "GetVersionExW called. return NT4 SP5\n");
        
        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows NT 4.0 credentials.

--*/

DWORD 
APIHOOK(GetVersion)()
{
    DPFN( eDbgLevelInfo, "GetVersion called. return NT4 SP5\n");
    return (DWORD) 0x05650004;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA )
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW )
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\winxpversionlie.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

   WinXPVersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows XP
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   04/24/2002 garyma  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinXPVersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END


/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows XP credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExA] called. return WinXP.");

        //
        // Fixup the structure with the WinXP data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 1;
        lpVersionInformation->dwBuildNumber  = 2600;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = '\0';

        if( lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXA) ) 
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMajor = 0;
            ((LPOSVERSIONINFOEXA)lpVersionInformation)->wServicePackMinor = 0;
        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 95 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(
            eDbgLevelInfo,
            "[GetVersionExW] called. return WinXP.");

        //
        // Fixup the structure with the WinXP data.
        //
        lpVersionInformation->dwMajorVersion = 5;
        lpVersionInformation->dwMinorVersion = 1;
        lpVersionInformation->dwBuildNumber  = 2600;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = L'\0';

        if( lpVersionInformation->dwOSVersionInfoSize == sizeof(OSVERSIONINFOEXW) ) 
        {
            // We are here as we are passed a OSVERSIONINFOEX structure.
            // Set the major and minor service pack numbers.
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMajor = 0;
            ((LPOSVERSIONINFOEXW)lpVersionInformation)->wServicePackMinor = 0;
        }

        bReturn = TRUE;
    }
    return bReturn;
}

/*++

 This stub function returns Windows XP credentials.

--*/

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(
        eDbgLevelInfo,
        "[GetVersion] called. return WinXP.");
    
    return (DWORD)0x0A280005;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\win98versionlie.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   Win98VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows 98
   version credentials. Applications often check to ensure that they are 
   running on a Win9x system, even though they will run OK on an NT based 
   system.

 Notes:

   This is a general purpose shim.

 History:

   11/08/2000 v-hyders  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Win98VersionLie)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA) 
    APIHOOK_ENUM_ENTRY(GetVersionExW) 
    APIHOOK_ENUM_ENTRY(GetVersion) 
APIHOOK_ENUM_END

BOOL g_bCheckSafeDisc = FALSE;

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 98 credentials.

--*/

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExA)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {

            LOGN(eDbgLevelInfo, "[GetVersionExA] called. return Win98");

            //
            // Fixup the structure with the Win98 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 10;
            lpVersionInformation->dwBuildNumber = 0x040A08AE;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = '\0';

            bReturn = TRUE;
        }

        return bReturn;
    }
}

/*++

 This stub function fixes up the OSVERSIONINFO structure that is
 returned to the caller with Windows 98 credentials. This is the
 wide-character version of GetVersionExW.

--*/

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersionExW)(lpVersionInformation);
    } else {
        BOOL bReturn = FALSE;

        if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {

            LOGN(eDbgLevelInfo, "[GetVersionExW] called. return Win98");

            //
            // Fixup the structure with the Win98 data.
            //
            lpVersionInformation->dwMajorVersion = 4;
            lpVersionInformation->dwMinorVersion = 10;
            lpVersionInformation->dwBuildNumber = 0x040A08AE;
            lpVersionInformation->dwPlatformId = 1;
            *lpVersionInformation->szCSDVersion = '\0';

            bReturn = TRUE;
        }

        return bReturn;
    }
}

/*++

 This stub function returns Windows 98 credentials.

--*/
DWORD
APIHOOK(GetVersion)(
    void
    )
{
    if (g_bCheckSafeDisc && bIsSafeDisc2()) {
        return ORIGINAL_API(GetVersion)();
    } else {
        LOGN(eDbgLevelInfo, "[GetVersion] Return Win98");
        return (DWORD) 0xC0000A04;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_bCheckSafeDisc = COMMAND_LINE && (_stricmp(COMMAND_LINE, "Detect_SafeDisc") == 0);

        if (g_bCheckSafeDisc && bIsSafeDisc1())
        {
            LOGN(eDbgLevelWarning, "SafeDisc 1.x detected: ignoring shim");
            return FALSE;
        }
    }
    
    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\wowuserp2k.h ===
/******************************Module*Header*******************************\
* Module Name: wowuserp.h                                                  *
*                                                                          *
* Declarations of USER services provided to WOW.                           *
*                                                                          *
* Created: 03-Mar-1993                                                     *
* Author: John Colleran [johnc]                                            *
*                                                                          *
* Copyright (c) 1993-1998 Microsoft Corporation                            *
\**************************************************************************/

#include "w32w64.h"

#pragma pack(1)
typedef struct _NE_MODULE_SEG {
    USHORT ns_sector;
    USHORT ns_cbseg;
    USHORT ns_flags;
    USHORT ns_minalloc;
    USHORT ns_handle;
} NEMODULESEG;
typedef struct _NE_MODULE_SEG UNALIGNED *PNEMODULESEG;
#pragma pack()


// Shared WOW32 prototypes called by USER32.
typedef HLOCAL  (WINAPI *PFNLALLOC)(UINT dwFlags, UINT dwBytes, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLREALLOC)(HLOCAL hMem, UINT dwBytes, UINT dwFlags, HANDLE hInstance, PVOID* ppv);
typedef LPVOID  (WINAPI *PFNLLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef BOOL    (WINAPI *PFNLUNLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef UINT    (WINAPI *PFNLSIZE)(HLOCAL hMem, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLFREE)(HLOCAL hMem, HANDLE hInstance);
typedef WORD    (WINAPI *PFN16GALLOC)(UINT flags, DWORD cb);
typedef VOID    (WINAPI *PFN16GFREE)(WORD h16Mem);
typedef DWORD   (WINAPI *PFNGETMODFNAME)(HANDLE hModule, LPTSTR lpszPath, DWORD cchPath);
typedef VOID    (WINAPI *PFNEMPTYCB)(VOID);
typedef DWORD   (WINAPI *PFNGETEXPWINVER)(HANDLE hModule);
typedef HANDLE  (WINAPI *PFNFINDA)(HANDLE hModule, LPCSTR lpName,  LPCSTR lpType,  WORD wLang);
typedef HANDLE  (WINAPI *PFNFINDW)(HANDLE hModule, LPCWSTR lpName, LPCWSTR lpType, WORD wLang);
typedef HANDLE  (WINAPI *PFNLOAD)(HANDLE hModule, HANDLE hResInfo);
typedef BOOL    (WINAPI *PFNFREE)(HANDLE hResData, HANDLE hModule);
typedef LPSTR   (WINAPI *PFNLOCK)(HANDLE hResData, HANDLE hModule);
typedef BOOL    (WINAPI *PFNUNLOCK)(HANDLE hResData, HANDLE hModule);
typedef DWORD   (WINAPI *PFNSIZEOF)(HANDLE hModule, HANDLE hResInfo);
typedef DWORD   (WINAPI *PFNWOWWNDPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef BOOL    (WINAPI *PFNWOWDLGPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef int     (WINAPI *PFNWOWEDITNEXTWORD)(LPSTR lpch, int ichCurrent, int cch, int code, DWORD dwProc16);
typedef VOID    (WINAPI *PFNWOWCBSTOREHANDLE)(WORD wFmt, WORD h16);
typedef WORD    (FASTCALL *PFNGETPROCMODULE16)(DWORD vpfn);
typedef VOID    (FASTCALL *PFNWOWMSGBOXINDIRECTCALLBACK)(DWORD vpfnCallback, LPHELPINFO lpHelpInfo);
typedef int     (WINAPI *PFNWOWILSTRCMP)(LPCWSTR lpString1, LPCWSTR lpString2);
typedef VOID    (FASTCALL *PFNWOWTELLWOWTHEHDLG)(HWND hDlg);

// Shared USER32 prototypes called by WOW32
typedef HWND    (WINAPI *PFNCSCREATEWINDOWEX)(DWORD dwExStyle, LPCTSTR lpClassName,
        LPCTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HANDLE hInstance, LPVOID lpParam, DWORD Flags);
typedef VOID    (WINAPI *PFNDIRECTEDYIELD)(DWORD ThreadId);
typedef VOID    (WINAPI *PFNFREEDDEDATA)(HANDLE hDDE, BOOL fIgnorefRelease, BOOL fFreeTruelyGlobalObjects);
typedef LONG    (WINAPI *PFNGETCLASSWOWWORDS)(HINSTANCE hInstance, LPCTSTR pString);
typedef BOOL    (WINAPI *PFNINITTASK)(UINT dwExpWinVer, DWORD dwAppCompatFlags, LPCSTR lpszModName, LPCSTR lpszBaseFileName, DWORD hTaskWow, DWORD dwHotkey, DWORD idTask, DWORD dwX, DWORD dwY, DWORD dwXSize, DWORD dwYSize);
typedef ATOM    (WINAPI *PFNREGISTERCLASSWOWA)(PVOID lpWndClass, LPDWORD pdwWOWstuff);
typedef BOOL    (WINAPI *PFNREGISTERUSERHUNGAPPHANDLERS)(PFNW32ET pfnW32EndTask, HANDLE hEventWowExec);
typedef HWND    (WINAPI *PFNSERVERCREATEDIALOG)(HANDLE hmod, LPDLGTEMPLATE lpDlgTemplate, DWORD cb, HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam, UINT fFlags);
typedef HCURSOR (WINAPI *PFNSERVERLOADCREATECURSORICON)(HANDLE hmod, LPTSTR lpModName, DWORD dwExpWinVer, LPCTSTR lpName, DWORD cb, PVOID pcur, LPTSTR lpType, BOOL fClient);
typedef HMENU   (WINAPI *PFNSERVERLOADCREATEMENU)(HANDLE hMod, LPTSTR lpName, CONST LPMENUTEMPLATE pmt, DWORD cb, BOOL fCallClient);
typedef BOOL    (WINAPI *PFNWOWCLEANUP)(HANDLE hInstance, DWORD hTaskWow);
typedef BOOL    (WINAPI *PFNWOWMODULEUNLOAD)(HANDLE hModule);
typedef HWND    (WINAPI *PFNWOWFINDWINDOW)(LPCSTR lpClassName, LPCSTR lpWindowName);
typedef HBITMAP (WINAPI *PFNWOWLOADBITMAPA)(HINSTANCE hmod, LPCSTR lpName, LPBYTE pResData, DWORD cbResData);
typedef BOOL    (WINAPI *PFNWOWWAITFORMSGANDEVENT)(HANDLE hevent);
typedef BOOL    (WINAPI *PFNYIELDTASK)(VOID);
typedef DWORD   (WINAPI *PFNGETFULLUSERHANDLE)(WORD wHandle);
typedef DWORD   (WINAPI *PFNGETMENUINDEX)(HMENU hMenu, HMENU hSubMenu);
typedef WORD    (WINAPI *PFNWOWGETDEFWINDOWPROCBITS)(PBYTE pDefWindowProcBits, WORD cbDefWindowProcBits);
typedef VOID    (WINAPI *PFNFILLWINDOW)(HWND hwndParent, HWND hwnd, HDC hdc, HANDLE hBrush);

// other prototypes
typedef BOOL    (WINAPI *PFNWOWGLOBALFREEHOOK)(HGLOBAL hMem);


/*
 * MEASUREITEMSTRUCT itemWidth tag telling wow the itemData is a flat pointer
 */
#define MIFLAG_FLAT      0x464C4154

/*
 * CallWindowProc Bits
 */
#define WOWCLASS_RPL_MASK  0x00060000  // the LDT bits that store the 2 high bits
#define WNDPROC_WOWPROC     0xC0000000  // These bits for WOW Window Procs
#define WNDPROC_WOWMASK     0x3fffffff  // To mask off wow bits
#define WNDPROC_HANDLE      0xFFFF      // HIWORD(x) == 0xFFFF for handle

// USER needs a way to distinguish between a WOW and a Win32 window proc. We
// used to achieve this by always setting the MSB of a 16:16 address as 1 (and
// storing the MSB in the Table indicator bit of the LDT which is always 1). The
// MSB of a user mode flat address was guranteed to be never 1 as the user mode
// address space was limited to 2GB. Starting with NT 5.0, user mode address
// space is being increased to 3GB. This change breaks the above assumption
// that a 32bit user mode flat address will never have the MSB as 1.
// To work around this problem, WOW is going to use the  two bits of a
// 16:16 address instead of just one. We will set both these bits as 1 because
// with 3GB address space, the user mode flat addresses cannot have 11 as the
// first two bits. To achieve this, we will save the 2 most significant bits of
// the selector in the bit 1 and bit 2. We are able to do this because for WOW
// because both these bits have fixed values.
//
// SudeepB 21-Nov-1996

#ifndef _WIN64

// MarkWOWProc
// zero out the RPL bits
// get the high two bit in position where they have to be saved
// save the high bits and mark it a wow proc

#define MarkWOWProc(vpfnProc,result)                                  \
{                                                                     \
    ULONG temp1,temp2;                                                \
    temp1 = (ULONG)vpfnProc & ~WOWCLASS_RPL_MASK;                     \
    temp2 = ((ULONG)vpfnProc & WNDPROC_WOWPROC) >> 13;                \
    (ULONG)result = temp1 | temp2 | WNDPROC_WOWPROC;                  \
}

// UnMarkWOWProc
// mask off the marker bits
// get the saved bits to right places
// restore the saved bits and set the RPL field correctly

#define UnMarkWOWProc(vpfnProc,result)                     \
{                                                          \
    ULONG temp1,temp2;                                     \
    temp1 = (ULONG)vpfnProc & WNDPROC_WOWMASK;             \
    temp2 = ((ULONG)vpfnProc & WOWCLASS_RPL_MASK) << 13;   \
    result = temp1 | temp2 | WOWCLASS_RPL_MASK;            \
}

#define IsWOWProc(vpfnProc) (((ULONG)vpfnProc & WNDPROC_WOWPROC) == WNDPROC_WOWPROC)

#else

#define MarkWOWProc(vpfnProc,result)    DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define UnMarkWOWProc(vpfnProc,result)  DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define IsWOWProc(vpfnProc)             (FALSE)

#endif

/*
 * CreateWindow flags
 */
#define CW_FLAGS_ANSI       0x00000001

typedef struct tagAPFNWOWHANDLERSIN
{
    // In'ees - passed from WOW32 to USER32 and called by USER32
    PFNLALLOC                           pfnLocalAlloc;
    PFNLREALLOC                         pfnLocalReAlloc;
    PFNLLOCK                            pfnLocalLock;
    PFNLUNLOCK                          pfnLocalUnlock;
    PFNLSIZE                            pfnLocalSize;
    PFNLFREE                            pfnLocalFree;
    PFNGETEXPWINVER                     pfnGetExpWinVer;
    PFN16GALLOC                         pfn16GlobalAlloc;
    PFN16GFREE                          pfn16GlobalFree;
    PFNEMPTYCB                          pfnEmptyCB;
    PFNFINDA                            pfnFindResourceEx;
    PFNLOAD                             pfnLoadResource;
    PFNFREE                             pfnFreeResource;
    PFNLOCK                             pfnLockResource;
    PFNUNLOCK                           pfnUnlockResource;
    PFNSIZEOF                           pfnSizeofResource;
    PFNWOWWNDPROCEX                     pfnWowWndProcEx;
    PFNWOWDLGPROCEX                     pfnWowDlgProcEx;
    PFNWOWEDITNEXTWORD                  pfnWowEditNextWord;
    PFNWOWCBSTOREHANDLE                 pfnWowCBStoreHandle;
    PFNGETPROCMODULE16                  pfnGetProcModule16;
    PFNWOWMSGBOXINDIRECTCALLBACK        pfnWowMsgBoxIndirectCallback;
    PFNWOWILSTRCMP                      pfnWowIlstrsmp;
    PFNWOWTELLWOWTHEHDLG                pfnWOWTellWOWThehDlg;
} PFNWOWHANDLERSIN, * APFNWOWHANDLERSIN;


typedef struct tagAPFNWOWHANDLERSOUT
{
    // Out'ees - passed from USER32 to WOW32 and called/used by WOW32
    DWORD                               dwBldInfo;
    PFNCSCREATEWINDOWEX                 pfnCsCreateWindowEx;
    PFNDIRECTEDYIELD                    pfnDirectedYield;
    PFNFREEDDEDATA                      pfnFreeDDEData;
    PFNGETCLASSWOWWORDS                 pfnGetClassWOWWords;
    PFNINITTASK                         pfnInitTask;
    PFNREGISTERCLASSWOWA                pfnRegisterClassWOWA;
    PFNREGISTERUSERHUNGAPPHANDLERS      pfnRegisterUserHungAppHandlers;
    PFNSERVERCREATEDIALOG               pfnServerCreateDialog;
    PFNSERVERLOADCREATECURSORICON       pfnServerLoadCreateCursorIcon;
    PFNSERVERLOADCREATEMENU             pfnServerLoadCreateMenu;
    PFNWOWCLEANUP                       pfnWOWCleanup;
    PFNWOWMODULEUNLOAD                  pfnWOWModuleUnload;
    PFNWOWFINDWINDOW                    pfnWOWFindWindow;
    PFNWOWLOADBITMAPA                   pfnWOWLoadBitmapA;
    PFNWOWWAITFORMSGANDEVENT            pfnWowWaitForMsgAndEvent;
    PFNYIELDTASK                        pfnYieldTask;
    PFNGETFULLUSERHANDLE                pfnGetFullUserHandle;
    PFNGETMENUINDEX                     pfnGetMenuIndex;
    PFNWOWGETDEFWINDOWPROCBITS          pfnWowGetDefWindowProcBits;
    PFNFILLWINDOW                       pfnFillWindow;
    INT *                               aiWowClass;
} PFNWOWHANDLERSOUT, * APFNWOWHANDLERSOUT;


//
// The WW structure is embedded at the end of USER's WND structure.
// However, WOW and USER use different names to access the WW
// fields. So this structure is defined as a union of two structures,
// WHICH MUST HAVE THE SAME SIZE, just different field names.
//
// Make sure that WND_CNT_WOWDWORDS matches the number of DWORDs
//  used by the WOW only fields.
//
// FindPWW(hwnd) returns a read-only pointer to this structure for
// a given window.  To change elements of this structure, use
// SETWW (== SetWindowLong) with the appropriate GWL_WOW* offset
// defined below.
//

/* WOW class/handle type identifiers (see WARNING below)
 */

#define FNID_START                  0x0000029A
#define FNID_END                    0x000002B4

#define WOWCLASS_UNKNOWN    0   // here begin our "window handle" classes
#define WOWCLASS_WIN16      1
#define WOWCLASS_BUTTON     2
#define WOWCLASS_COMBOBOX   3
#define WOWCLASS_EDIT       4
#define WOWCLASS_LISTBOX    5
#define WOWCLASS_MDICLIENT  6
#define WOWCLASS_SCROLLBAR  7
#define WOWCLASS_STATIC     8
#define WOWCLASS_DESKTOP    9
#define WOWCLASS_DIALOG     10
#define WOWCLASS_ICONTITLE  11
#define WOWCLASS_MENU       12
#define WOWCLASS_SWITCHWND  13
#define WOWCLASS_COMBOLBOX  14
#define WOWCLASS_MAX        14  // Always equal to the last value used.

#define WOWCLASS_NOTHUNK    0xFF // not an actual class index
//
// WARNING! The above sequence and values must be maintained otherwise the
// table in WMSG16.C for message thunking must be changed.  Same goes for
// table in WALIAS.C.
//


//
// When including this from USER, VPWNDPROC is undefined
//
#ifndef _WALIAS_
typedef DWORD VPWNDPROC;
typedef DWORD VPSZ;
#endif

typedef struct tagWOWCLS {
    VPSZ       vpszMenu;
    WORD       iClsExtra;   // app's value for class extra
    WORD       hMod16;
    } WC;

typedef WC UNALIGNED *PWC;

typedef struct _WW { /* ww */
    /*
     *
     * WOW/USER fields
     * NOTE: The order and size of the following 4 fields is assumed
     *       by the SetWF, ClrWF, TestWF, MaskWF macros.
     *       Specifically, state must remain the first field in this structure.
     *
     */
    DWORD         state;        // State flags
    DWORD         state2;       //
    DWORD         ExStyle;      // Extended Style
    DWORD         style;        // Style flags

    KHANDLE       hModule;      // Handle to module instance data (32-bit).
    WORD          hMod16;       // WOW only -- hMod of wndproc
    WORD          fnid;         // record window proc used by this hwnd
                        // access through GETFNID

} WW, *PWW, **PPWW;

// this is tied to WFISINITIALIZED in ntuser\inc\user.h
#define WINDOW_IS_INITIALIZED   0x80000000

ULONG_PTR UserRegisterWowHandlers(APFNWOWHANDLERSIN apfnWowIn, APFNWOWHANDLERSOUT apfnWowOut);

VOID WINAPI RegisterWowBaseHandlers(PFNWOWGLOBALFREEHOOK pfn);

BOOL
InitTask(
    UINT dwExpWinVer,
    DWORD dwAppCompatFlags,
    LPCSTR lpszModName,
    LPCSTR lpszBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize);

BOOL YieldTask(VOID);

#define DY_OLDYIELD     ((DWORD)-1)
VOID DirectedYield(DWORD ThreadId);
DWORD UserGetInt16State(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\winxpsp1versionlie.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

   WinXPSP1VersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return Windows XP
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   09/05/2002   robkenny    Created.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinXPSP1VersionLie)
#include "ShimHookMacro.h"


DWORD       MajorVersion    = 5;
DWORD       MinorVersion    = 1;
DWORD       BuildNumber     = 2600;
SHORT       SpMajorVersion  = 1;
SHORT       SpMinorVersion  = 0;
DWORD       PlatformId      = VER_PLATFORM_WIN32_NT;
CString *   csServicePack   = NULL;

#include "VersionLieTemplate.h"

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\layer\winexecraceconditionfix.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinExecRaceConditionFix.cpp

 Abstract:

    This Shim uses the command line parameter to indicate how it works:

    If passed 'nowait', it enables the WinExec functionality:
    The WinExec in this DLL is identical to the actual WinExec API but without
    the WaitForUserinputIdleRoutine, which inverts an almost race condition 
    between the launcher and the launchee.  9x does not have this wait, so the
    programmers were able to (possibly inadvertently) use the same window class
    exclusion matching for both since, in 9x, the launcher kills itself before
    the launchee can check for a duplicate window.  This shim leaves out the
    wait condition, allowing 9x like behavior.

    If passed a number, it sleeps in initialization for that number of
    microseconds.

 Notes:

    This shim has no app specific information.

 History:

    03/22/2000 a-charr  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinExecRaceConditionFix)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WinExec)
APIHOOK_ENUM_END

/*++

 This function breaks into WinExec and calls CreateProcessA without
 waiting afterward.
  
--*/

UINT 
APIHOOK(WinExec)(
    LPCSTR lpCmdLine, 
    UINT   uCmdShow 
    )
/*++

 This is a direct copy of the actual WinExec API minus two sections,

 1. UserWaitForInputIdleRoutine is removed because it is waiting for the spawned 
    process to begin its event loop, but the spawned process is killing itself 
    before starting the event loop because the spawning process is waiting for 
    it.

 2. Some app specific appcompat code that seems to be hanging around from who
    knows when.
      
--*/
{
    STARTUPINFOA        StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL                CreateProcessStatus;
    DWORD               ErrorCode;
    
    LOGN(
        eDbgLevelInfo,
        "[WinExec] Called. Returning without waiting for new process to start.");
    
    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    
    CreateProcessStatus = CreateProcessA(
        NULL,
        (LPSTR)lpCmdLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation);
    
    if (CreateProcessStatus) {
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);

        return 33;
    } else {
        ErrorCode = GetLastError();
        
        switch (ErrorCode) {
        case ERROR_FILE_NOT_FOUND:
            return 2;
            
        case ERROR_PATH_NOT_FOUND:
            return 3;
            
        case ERROR_BAD_EXE_FORMAT:
            return 11;
            
        default:
            return 0;
        }
    }
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Sleep when starting up, if the command line is a number.
        //
        long lSleepTicks = atol(COMMAND_LINE);

        if (lSleepTicks > 0) {
            Sleep((DWORD)lSleepTicks);
        }
    }

    return TRUE;
}


/*++

  Register hooked functions
  
--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)
    
    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\appandcommandline.cpp ===
/*++

 Copyright (c) 2000, 2001 Microsoft Corporation

 Module Name:

    AppAndCommandLine.cpp

 Abstract:

    This class takes an application name and command line and
    parses them *exactly* as as they would by CreateProcess.
    If the Set routine returns TRUE, then the application name
    will contain a value; however, it does not guarantee that the application
    actually exists.

    Example:
    AppAndCommandLine.Set(NULL, "notepad.exe readme.txt");
    GetApplicationName()        == "notepad.exe"
    GetCommandline()            == "notepad.exe readme.txt"
    GetCommandlineNoAppName()   == "readme.txt"


 Notes:

    None

 History:

    07/21/2000  robkenny    Created
    12/18/2000  prashkud    Modified GetAppAndCommandLine to fix the AV
                            caused by EmulateGetCommandLine when the
                            layer was applied to Oregon Trail 4th Edition.
    03/04/2001  robkenny    Converted to use CString
    03/29/2001  prashkud    Modified GetAppnameAndCommandline to set
                            the application name even when there is only
                            Commandline passed and the application name
                            passed is NULL.
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.


--*/

#include "ShimLib.h"
#include "StrSafe.h"



namespace ShimLib
{

AppAndCommandLine::AppAndCommandLine(const char * applicationName, const char * commandLine)
{
    CString csApp(applicationName);
    CString csCl(commandLine);

    GetAppnameAndCommandline(csApp.GetNIE(), csCl.GetNIE());
}

AppAndCommandLine::AppAndCommandLine(const WCHAR * applicationName, const WCHAR * commandLine)
{
    GetAppnameAndCommandline(applicationName, commandLine);
}

// If the application name is the first entry on the command line,
// we convert the appName to its short name; thereby removing any spaces.
const CString & AppAndCommandLine::GetShortCommandLine()
{
    // If lpCommandLineNoAppName is not the same as lpCommandLine,
    // then the command line contains the application name.
    if ( csShortCommandLine.IsEmpty() &&                             // Haven't been here
        !csApplicationName.IsEmpty() &&                              // Set() has been called
        !csCommandLine.IsEmpty() &&                                  // Set() has been called
        csShortCommandLine.GetLength() != csCommandLine.GetLength()) // Command line actually contains app name
    {
        csShortCommandLine = csApplicationName;
        csShortCommandLine.GetShortPathNameW();
        csShortCommandLine += L" ";
        csShortCommandLine += csCommandLineNoAppName;
    }

    // If we still don't have a short version of the command line,
    // just duplicate the current command line
    if (csShortCommandLine.IsEmpty())
    {
        csShortCommandLine = csCommandLine;
    }
    return csShortCommandLine;
}

BOOL AppAndCommandLine::GetAppnameAndCommandline(const WCHAR * lpcApp, const WCHAR * lpcCl)
{
    BOOL SearchRetry = TRUE;
    ULONG Length = 0;
    WCHAR * NameBuffer = NULL;
    BOOL success = FALSE;
    DWORD dwAppNameLen = 0;
    CString csTempAppName;
    BOOL bFound = TRUE;

    // It is really, really bad to remove the const from the Get,
    // However we never change the length of the string, so it should be okay
    WCHAR * lpApplicationName = (WCHAR *)lpcApp;
    WCHAR * lpCommandLine     = (WCHAR *)lpcCl;

    // The following is done as there are lot of instances when the
    // the pointer is not NULL but contains an EMPTY string.
    if (lpApplicationName && !(*lpApplicationName))
    {
        lpApplicationName = NULL;
    }

    if (lpCommandLine && !(*lpCommandLine))
    {
        lpCommandLine = NULL;
    }

    if (lpApplicationName == NULL && lpCommandLine == NULL)
    {
        // Degenerate case
        csApplicationName      = L"";
        csCommandLine          = csApplicationName;
        csCommandLineNoAppName = csApplicationName;
        return FALSE; // Didn't find application name
    }

    csCommandLine = lpCommandLine;

    DPF("Common",
        eDbgLevelSpew,
        "[AppAndCommandLineT::Set] BEFORE App(%S) CL(%S)\n",
        lpApplicationName, lpCommandLine);

    if (lpApplicationName == NULL)         
    {
        DWORD fileattr;
        WCHAR TempChar;
        //
        // Locate the image
        //

        NameBuffer = (WCHAR *) malloc(MAX_PATH * sizeof( WCHAR ));
        if ( !NameBuffer )
        {
            goto errorExit;
        }
        lpApplicationName = lpCommandLine;
        WCHAR * TempNull = lpApplicationName;
        WCHAR * WhiteScan = lpApplicationName;
        DWORD QuoteFound = 0;

        //
        // check for lead quote
        //
        if ( *WhiteScan == L'\"' ) {
            SearchRetry = FALSE;
            WhiteScan++;
            lpApplicationName = WhiteScan;
            while(*WhiteScan) {
                if ( *WhiteScan == L'\"' ) {
                    TempNull = WhiteScan;
                    QuoteFound = 2;
                    break;
                    }
                WhiteScan++;
                TempNull = WhiteScan;
                }
            }
        else {
retrywsscan:
            lpApplicationName = lpCommandLine;
            while(*WhiteScan) {
                if ( *WhiteScan == L' ' ||
                     *WhiteScan == L'\t' ) {
                    TempNull = WhiteScan;
                    break;
                    }
                WhiteScan++;
                TempNull = WhiteScan;
                }
            }
        TempChar = *TempNull;
        *TempNull = 0;

        WCHAR * filePart;
        Length = SearchPathW(
                    NULL,
                    lpApplicationName,
                    L".exe",
                    MAX_PATH,
                    NameBuffer,
                    &filePart
                    )*sizeof(WCHAR);

        if (Length != 0 && Length < MAX_PATH * sizeof( WCHAR )) {
            //
            // SearchPathW worked, but file might be a directory
            // if this happens, we need to keep trying
            //
            fileattr = GetFileAttributesW(NameBuffer);
            if ( fileattr != 0xffffffff &&
                 (fileattr & FILE_ATTRIBUTE_DIRECTORY) ) {
                Length = 0;
            } else {
                Length++;
                Length++;
            }
        }

        if ( !Length || Length >= MAX_PATH<<1 ) {

            //
            // restore the command line
            //

            *TempNull = TempChar;
            lpApplicationName = lpCommandLine;

            //
            // If we still have command line left, then keep going
            // the point is to march through the command line looking
            // for whitespace so we can try to find an image name
            // launches of things like:
            // c:\word 95\winword.exe /embedding -automation
            // require this. Our first iteration will stop at c:\word, our next
            // will stop at c:\word 95\winword.exe
            //
            if (*WhiteScan && SearchRetry) {
                WhiteScan++;
                TempNull = WhiteScan;
                goto retrywsscan;
            }

            // If we are here then the Application has not been found.
            // We used to send back lpApplicationName as NULL earlier
            // but now instead we fill the ApplicationName with the
            // commandline till the first space or tab.This was added
            // to support EmulateMissingExe SHIM which will fail if 
            // we return NULL as we used to earlier.
            bFound = FALSE;
            
            if (QuoteFound == 0)
            {
                // No quotes were found.
                lpApplicationName = lpCommandLine;

                // Since we just reset to the entire command line, we need to skip leading white space
                SkipBlanksW(lpApplicationName);

                TempNull = lpApplicationName;

                while (*TempNull)
                {
                    if ((*TempNull == L' ') ||
                       (*TempNull == L'\t') )
                    {
                        TempChar = *TempNull;
                        *TempNull = 0;
                        break;
                    }
                    TempNull++;
                }
            }
            else
            {
                // Quotes were found.
                lpApplicationName = lpCommandLine + 1;  // Skip leading quote.
                *TempNull = 0;
            }

            csTempAppName = lpApplicationName;                        
            *TempNull = TempChar;
            dwAppNameLen = (DWORD)(TempNull - lpCommandLine) + QuoteFound;
            lpApplicationName = (WCHAR*)csTempAppName.Get();

            goto successExit;       
        }

        dwAppNameLen = (DWORD)(TempNull - lpApplicationName) + QuoteFound;

        //
        // restore the command line
        //

        *TempNull = TempChar;
        lpApplicationName = NameBuffer;
    }
    else if (lpCommandLine == NULL || *lpCommandLine == 0 )
    {
        lpCommandLine = lpApplicationName;
            
        dwAppNameLen = wcslen(lpApplicationName);
    }

    // If they provided both, check to see if the app name
    // is the first entry on the command line.
    else if (lpApplicationName != NULL && lpCommandLine != NULL )
    {
        int appNameLen = wcslen(lpApplicationName);

        if (
            _wcsnicmp(lpApplicationName, lpCommandLine, appNameLen) == 0 &&
            (lpCommandLine[appNameLen] == 0 || iswspace(lpCommandLine[appNameLen]))
            )
        {
            // lpApplicationName is the first entry on the command line
            dwAppNameLen = appNameLen;
        }
        // check for quoted lpApplicationName
        else if (
            lpCommandLine[0] == L'"' && 
            _wcsnicmp(lpApplicationName, lpCommandLine+1, appNameLen) == 0 &&
            lpCommandLine[appNameLen+1] == L'"' &&                                  
            (lpCommandLine[appNameLen+2] == 0 || iswspace(lpCommandLine[appNameLen+2]))
            )
        {
            // lpApplicationName is the first *quoted* entry on the command line
            dwAppNameLen = appNameLen + 2;
        }
        else
        {
            // Didn't find the application name at the beginning of the command line
            dwAppNameLen = 0;
        }
    }

successExit:
    if (bFound)
    {
        success = TRUE;
    }    

    csApplicationName       = lpApplicationName;
    csCommandLineNoAppName  = lpCommandLine + dwAppNameLen;
    csCommandLineNoAppName.TrimLeft();

errorExit:

    free(NameBuffer);

    DPF("Common",
        eDbgLevelSpew,
        "[AppAndCommandLineT::Set] AFTER  App(%S) CL(%S)\n",
        csApplicationName.Get(), csCommandLine.Get());
    
    DPF("Common",
        eDbgLevelSpew,
        "[AppAndCommandLineT::Set] CL without App(%S)\n",
        csCommandLineNoAppName.Get());

    return success;
}



};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\argva.cpp ===
/***
*argvw.c - create Unicode version of argv arguments
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line
*
*Revision History:
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
*
*******************************************************************************/

// This routine actually lives in shell32.dll,
// we have a private copy so we don't have to link to the library.

#include <windows.h>

#include "StrSafe.h"

namespace ShimLib
{

/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_CmdlineA (
    LPCSTR cmdstart,
    LPSTR* argv,
    LPSTR  lpstr,
    INT *  numargs,
    INT *  numbytes
    )
{
    LPCSTR p;
    char c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(char);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(char);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(char);
            if (lpstr)
                *lpstr++ = *p;

            c = (char) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(char);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(char);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(char);
    }

}


/***
*CommandLineToArgvW - set up Unicode "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line
*
*Exit:
*       "argv" points to a null-terminated list of pointers to UNICODE
*       strings, each of which is an argument from the command line.
*       The list of pointers is also located on the heap or stack.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

LPSTR * _CommandLineToArgvA (LPCSTR lpCmdLine, int*pNumArgs)
{
    LPSTR*argv_U;
    LPCSTR cmdstart;                 /* start of command line to parse */
    INT    numbytes;

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    cmdstart = lpCmdLine;

    /* first find out how much space is needed to store args */
    Parse_CmdlineA(cmdstart, NULL, NULL, pNumArgs, &numbytes);

    /* allocate space for argv[] vector and strings */
    argv_U = (LPSTR*)LocalAlloc(LMEM_ZEROINIT,
                                (*pNumArgs + 1) * sizeof(LPSTR) + numbytes);
    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    /* store args and argv ptrs in just allocated block */
    Parse_CmdlineA(cmdstart,
                   argv_U,
                   (LPSTR)(((LPBYTE)argv_U) + *pNumArgs * sizeof(LPSTR)),
                   pNumArgs,
                   &numbytes);

    return argv_U;
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\classcfp.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    CorrectPathChangesBase.cpp

 Abstract:
    Several paths were changed between Win9x and WinNT.  This routine defines
    the CorrectPathChangesBase routines that is called with a Win9x path and returns
    the corresponding WinNT path.

 History:

    03-Mar-00   robkenny        Converted CorrectPathChanges.cpp to this class.
    21-Mar-00   robkenny        StringISub("abc", "abcd") now works
    06/20/2000  robkenny        EnvironmentValues::Initialize now checks the return status of the system calls
    12/12/2000  mnikkel         Some apps look for ddhelp.exe to exist to confirm directx is installed,
                                set this to look for ddraw.dll since ddhelp.exe no longer exists in directx.
    02/13/2001  robkenny/a-larrsh Added AllProfile and UserProfile to EnvironmentValues
    03/22/2001  robkenny        Do not redirect files to directories that the user does not have permission.
    08/14/2001  robkenny        Moved code inside the ShimLib namespace.
    

--*/
#include "ClassCFP.h"
#include "StrSafe.h"
#include "Userenv.h"
#include <stdio.h>


namespace ShimLib
{


WCHAR *
ReplaceAllStringsAllocW(const WCHAR * lpOrig,
                        const VectorT<StringPairW> & pathFixes)
{
    CSTRING_TRY
    {
        CString csReplaced(lpOrig);


        for (DWORD i = 0; i < pathFixes.Size(); ++i)
        {
            const StringPairW & stringPair = pathFixes[i];

            // Attempt a string substitution
            csReplaced.ReplaceI(stringPair.lpOld, stringPair.lpNew);
        }

        // Wasteful, but all calling routines expect ownership of the return value.
        return StringDuplicateW(csReplaced);
    }
    CSTRING_CATCH
    {
        // Fall thru
    }

    return NULL;
}

//-------------------------------------------------------------------------------------------------------------

EnvironmentValues::EnvironmentValues()
{
    bInitialized = FALSE;
}

EnvironmentValues::~EnvironmentValues()
{
    // Clear the list
    Erase();
}

// Given an CLSIDL, create an environment variable and its two variants
// CSIDL_WINDOWS would add c:\windows, \windows and windows
void EnvironmentValues::Add_Variants(const WCHAR * lpEnvName, const WCHAR * lpEnvValue, eAddNameEnum addName, eAddNoDLEnum noDL)
{
    CSTRING_TRY
    {
        CString csEnvName;
        CString csEnvValue(lpEnvValue);

        csEnvName.Format(L"%%%s%%", lpEnvName);
        AddEnvironmentValue(csEnvName, csEnvValue);

        // Remove the drive letter and the colon.
        if (noDL == eAddNoDL)
        {
            CString csNoDL(csEnvValue);
            csNoDL.Delete(0, 2);

            csEnvName.Format(L"%%%s_NODL%%", lpEnvName);
            AddEnvironmentValue(csEnvName, csNoDL);
        }

        // Use the last path component as the name.
        if (addName == eAddName)
        {
            CString csName;
            csEnvValue.GetLastPathComponent(csName);

            csEnvName.Format(L"%%%s_NAME%%", lpEnvName);
            AddEnvironmentValue(csEnvName, csName);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
}

// Given an CLSIDL, create an environment variable and its two variants
// CSIDL_WINDOWS would add c:\windows, \windows and windows
void EnvironmentValues::Add_CSIDL(const WCHAR * lpEnvName, int nFolder, eAddNameEnum addName, eAddNoDLEnum noDL)
{
    CSTRING_TRY
    {
        CString csPath;
        SHGetSpecialFolderPathW(csPath, nFolder);

        if (csPath.GetLength() > 0)
        {
            Add_Variants(lpEnvName, csPath, addName, noDL);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
}

// Add all _CSIDL values as environment variables.
void EnvironmentValues::AddAll_CSIDL()
{
    Add_CSIDL(L"CSIDL_APPDATA",                 CSIDL_APPDATA,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_ADMINTOOLS",       CSIDL_COMMON_ADMINTOOLS,        eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_APPDATA",          CSIDL_COMMON_APPDATA,           eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_DESKTOPDIRECTORY", CSIDL_COMMON_DESKTOPDIRECTORY,  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_DOCUMENTS",        CSIDL_COMMON_DOCUMENTS,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_FAVORITES",        CSIDL_COMMON_FAVORITES,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_MUSIC",            CSIDL_COMMON_MUSIC,             eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_PICTURES",         CSIDL_COMMON_PICTURES,          eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_PROGRAMS",         CSIDL_COMMON_PROGRAMS,          eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_STARTMENU",        CSIDL_COMMON_STARTMENU,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_STARTUP",          CSIDL_COMMON_STARTUP,           eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COMMON_TEMPLATES",        CSIDL_COMMON_TEMPLATES,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_COOKIES",                 CSIDL_COOKIES,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_DESKTOPDIRECTORY",        CSIDL_DESKTOPDIRECTORY,         eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_FAVORITES",               CSIDL_FAVORITES,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_FONTS",                   CSIDL_FONTS,                    eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_HISTORY",                 CSIDL_HISTORY,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_INTERNET_CACHE",          CSIDL_INTERNET_CACHE,           eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_LOCAL_APPDATA",           CSIDL_LOCAL_APPDATA,            eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_MYMUSIC",                 CSIDL_MYMUSIC,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_MYPICTURES",              CSIDL_MYPICTURES,               eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_NETHOOD",                 CSIDL_NETHOOD,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PERSONAL",                CSIDL_PERSONAL,                 eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PRINTHOOD",               CSIDL_PRINTHOOD,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROFILE",                 CSIDL_PROFILE,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROGRAM_FILES",           CSIDL_PROGRAM_FILES,            eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROGRAM_FILES_COMMON",    CSIDL_PROGRAM_FILES_COMMON,     eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_PROGRAMS",                CSIDL_PROGRAMS,                 eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_RECENT",                  CSIDL_RECENT,                   eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_SENDTO",                  CSIDL_SENDTO,                   eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_STARTMENU",               CSIDL_STARTMENU,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_STARTUP",                 CSIDL_STARTUP,                  eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_SYSTEM",                  CSIDL_SYSTEM,                   eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_TEMPLATES",               CSIDL_TEMPLATES,                eAddName, eAddNoDL);
    Add_CSIDL(L"CSIDL_WINDOWS",                 CSIDL_WINDOWS,                  eAddName, eAddNoDL);
}

void EnvironmentValues::Initialize()
{
    if (bInitialized == FALSE)
    {
        bInitialized = TRUE;

        WCHAR   lpDir[MAX_PATH];
        DWORD   dwSize;
        HRESULT result;
        DWORD   dwChars;
        BOOL    bResult;

        dwChars = GetWindowsDirectoryW(lpDir, MAX_PATH);
        if (dwChars > 0 && dwChars <= MAX_PATH)
        {
            AddEnvironmentValue( L"%WinDir%", lpDir );
            AddEnvironmentValue( L"%SystemRoot%", lpDir );

            lpDir[2] = 0;
            AddEnvironmentValue( L"%SystemDrive%", lpDir );
        }

        dwChars = GetSystemDirectoryW( lpDir, MAX_PATH);
        if (dwChars > 0 && dwChars <= MAX_PATH)
        {
            AddEnvironmentValue( L"%SystemDir%", lpDir );
        }

        dwSize = ARRAYSIZE(lpDir);
        bResult = GetUserNameW(lpDir, &dwSize);
        if (bResult)
        {
            AddEnvironmentValue( L"%Username%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%ProgramFiles%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserStartMenu%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllStartMenu%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserDesktop%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllDesktop%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_FAVORITES, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserFavorites%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_FAVORITES, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllFavorites%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_APPDATA, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%UserAppData%", lpDir );
        }

        result = SHGetFolderPathW( NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_DEFAULT, lpDir );
        if (SUCCEEDED(result))
        {
            AddEnvironmentValue( L"%AllAppData%", lpDir );
        }


        // C:\Documents and Settings\All Users 
        dwSize = ARRAYSIZE(lpDir);
        bResult = GetAllUsersProfileDirectoryW(lpDir, &dwSize);
        if (bResult)
        {
            Add_Variants( L"AllUsersProfile", lpDir, eAddName, eAddNoDL); // same as real Env var
        }

        // C:\Documents and Settings\owner
        HANDLE hProcessHandle = GetCurrentProcess();
        HANDLE hUserToken;
        if (OpenProcessToken(hProcessHandle, TOKEN_QUERY, &hUserToken))
        {
            dwSize = MAX_PATH;
            bResult = GetUserProfileDirectoryW(hUserToken, lpDir, &dwSize);
            if (bResult)
            {
                Add_Variants( L"UserProfile", lpDir, eAddName, eAddNoDL);
            }
        }


        // Add the new CLSIDL variables (some have duplicate values to above)
        AddAll_CSIDL();
    }
}


WCHAR * EnvironmentValues::ExpandEnvironmentValueW(const WCHAR * lpOld)
{
    Initialize();

    // Replace all the "environment" values into their real values
    const VectorT<StringPairW> & stringPairVector = *this;

    WCHAR * lpMassagedOld = ReplaceAllStringsAllocW(lpOld, stringPairVector);

    return lpMassagedOld;
}


char * EnvironmentValues::ExpandEnvironmentValueA(const char * lpOld)
{
    Initialize();

    char * lpMassagedOld = NULL;

    WCHAR * lpOldWide = ToUnicode(lpOld);
    if (lpOldWide)
    {
        const VectorT<StringPairW> & stringPairVector = *this;

        WCHAR * lpMassagedOldWide = ReplaceAllStringsAllocW(lpOldWide, stringPairVector);
        if (lpMassagedOldWide)
        {
            lpMassagedOld = ToAnsi(lpMassagedOldWide);
            free(lpMassagedOldWide);
        }

        free(lpOldWide);
    }

    return lpMassagedOld;
}


void EnvironmentValues::AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew)
{
    Initialize();

    StringPairW appendThis(lpOld, lpNew);
    if (AppendConstruct(appendThis))
    {
        DPF("EnvironmentValues",
            eDbgLevelInfo,
            "AddEnvironmentValue: (%S) to (%S)\n",
            appendThis.lpOld.Get(),
            appendThis.lpNew.Get() );
    }
}



//-------------------------------------------------------------------------------------------------------------
CorrectPathChangesBase::CorrectPathChangesBase()
{
    lpEnvironmentValues         = NULL;
    bInitialized                = FALSE;
    bEnabled                    = TRUE;
}

CorrectPathChangesBase::~CorrectPathChangesBase()
{
    if (lpEnvironmentValues)
        delete lpEnvironmentValues;

    // Call the destructor on each item in the vector list.
    for (int i = 0; i < vKnownPathFixes.Size(); ++i)
    {
        StringPairW & stringPair = vKnownPathFixes[i];

        // Call the destuctor explicitly
        stringPair.~StringPairW();
    }
}

BOOL CorrectPathChangesBase::ClassInit()
{
    lpEnvironmentValues = new EnvironmentValues;
    return lpEnvironmentValues != NULL;
}


/*++

  Func:   AddEnvironmentValue

  Params: dwIndex
          lpOld        Name of "environment" variable
          lpNew        Value of "environment" variable

--*/
void CorrectPathChangesBase::AddEnvironmentValue(const WCHAR * lpOld, const WCHAR * lpNew )
{
    if (lpEnvironmentValues)
    {
        lpEnvironmentValues->AddEnvironmentValue(lpOld, lpNew);
    }
}

/*++

  Func:   InsertPathChangeW

  Params:
          lpOld     Old Win9x path
          lpNew     New Win2000 path

  Desc:   Insert the Old/New string pair into lpKnownPathFixes
          making sure the list is large enough.
--*/
void CorrectPathChangesBase::InsertPathChangeW( const WCHAR * lpOld, const WCHAR * lpNew )
{
    // Ignore identical strings
    if (lstrcmpiW(lpOld, lpNew) == 0)
        return;

    // Ignore duplicates
    int i;
    for (i = 0; i < vKnownPathFixes.Size(); ++i)
    {
        StringPairW & stringPair = vKnownPathFixes[i];

        if (stringPair.lpOld.CompareNoCase(lpOld) == 0)
        {
            DPF("CorrectPathChangesBase", eDbgLevelSpew, "Duplicate PathChange (%S) to (%S)\n", lpOld, lpNew );
            return;
        }
    }

    CSTRING_TRY
    {
        StringPairW appendThis(lpOld, lpNew);
        if (vKnownPathFixes.AppendConstruct(appendThis))
        {
            DPF("CorrectPathChangesBase", eDbgLevelInfo, "PathChange (%S) to (%S)\n", lpOld, lpNew);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing.
    }
}


/*++

  Func:   AddPathChangeW

  Params:
          lpOld     Old Win9x path
          lpNew     New Win2000 path

  Desc:   Add lpOld/lpNew combo to the list, two times:
          first:    lpOld/short(lpNew)
          second:   short(lpOld)/short(lpNew)

--*/

void CorrectPathChangesBase::AddPathChangeW( const WCHAR * lpOld, const WCHAR * lpNew )
{
    InitializeCorrectPathChanges();

    // Replace all the "environment" values into their real values
    WCHAR * lpExpandedOld = ExpandEnvironmentValueW(lpOld);
    WCHAR * lpExpandedNew = ExpandEnvironmentValueW(lpNew);

    const WCHAR * lpNewShort = lpExpandedNew;

    // Convert lpNew to its short name
    WCHAR   lpNewShortBuffer[MAX_PATH];
    DWORD status = GetShortPathNameW(lpExpandedNew, lpNewShortBuffer, MAX_PATH);
    if (status > 0 && status < MAX_PATH)
    {
        lpNewShort = lpNewShortBuffer;
    }

    // first: lpOld/short(lpNew)
    InsertPathChangeW(lpExpandedOld, lpNewShort);

    // Convert lpOld to its short name
    WCHAR lpOldShort[MAX_PATH];
    status = GetShortPathNameW(lpExpandedOld, lpOldShort, MAX_PATH);
    if (status > 0 && status < MAX_PATH) // successfully got the short path
    {
        if (_wcsicmp(lpOld, lpOldShort) != 0)
        {
            // second:   short(lpOld)/short(lpNew)
            InsertPathChangeW( lpOldShort, lpNewShort );
        }
    }

    free(lpExpandedOld);
    free(lpExpandedNew);
}

/*++

  Func:   ExpandEnvironmentValueA

  Params:  lpOld     string with environment vars

  Desc:    Return a pointer to a malloc() string with all internal env values expanded.

--*/

char * CorrectPathChangesBase::ExpandEnvironmentValueA(const char * lpOld)
{
    WCHAR * lpOldWide = ToUnicode(lpOld);

    // Replace all the "environment" values into their real values
    WCHAR * lpExpandedOldWide = ExpandEnvironmentValueW(lpOldWide);

    char * lpExpandedOld = ToAnsi(lpExpandedOldWide);

    free(lpOldWide);
    free(lpExpandedOldWide);

    return lpExpandedOld;
}

/*++

  Func:   ExpandEnvironmentValueW

  Params:  lpOld     string with environment vars

  Desc:    Return a pointer to a malloc() string with all internal env values expanded.

--*/

WCHAR * CorrectPathChangesBase::ExpandEnvironmentValueW(const WCHAR * lpOld)
{
    WCHAR * lpMassagedOld = NULL;

    InitializeCorrectPathChanges();

    if (lpEnvironmentValues)
    {
        lpMassagedOld = lpEnvironmentValues->ExpandEnvironmentValueW(lpOld);
    }

    return lpMassagedOld;
}

/*++

  Func:   InitializeEnvironmentValuesW

  Params: None, applies changes to lpEnvironmentValues

  Desc:   This function initializes the Environment strings
--*/
void CorrectPathChangesBase::InitializeEnvironmentValuesW( )
{
    if (lpEnvironmentValues)
    {
        lpEnvironmentValues->Initialize();
    }
}


/*++

  Func:   InitializePathFixes

  Params: None, applies changes to lpEnvironmentValues

  Desc:   This function initializes the built-in path changes
--*/
void CorrectPathChangesBase::InitializePathFixes( )
{
}

/*++

  Func:   InitializeCorrectPathChanges

  Params: None.

  Desc:   Initialize the CorrectPathChangesBase values, both A and W versions.
          This *must* be called prior to calling either CorrectPathChangesA or CorrectPathChangesW
--*/
void CorrectPathChangesBase::InitializeCorrectPathChanges( )
{
    if (!bInitialized)
    {
        BOOL isEnabled = bEnabled; // remember previous enabled state

        // We must not be enabled while we are initializing, otherwise
        // we can (and do!) hook routines that we are trying to use while
        // grabbing values from the system.
        bEnabled = FALSE;
        bInitialized = TRUE;

        InitializeEnvironmentValuesW();
        InitializePathFixes();

        bEnabled = isEnabled;
    }
}


/*++

   Helper routine to call CorrectPathA, allocates necessary buffer space and returns a pointer
   to the corrected path.  Caller is responsible for releasing the memory by calling free().

--*/

char *  CorrectPathChangesBase::CorrectPathAllocA(const char * str)
{
    if (str == NULL)
        return NULL;

    // Convert lpOrig to WCHAR, correct the WCHAR path, then convert back to char

    WCHAR * strWide = ToUnicode(str);

    // Correct
    WCHAR * strCorrectedWide = CorrectPathAllocW(strWide);

    char * strCorrected = ToAnsi(strCorrectedWide);

    free(strWide);
    free(strCorrectedWide);

    return strCorrected;
}

/*++

   Helper routine to call CorrectPathW, allocates necessary buffer space and returns a pointer
   to the corrected path.  Caller is responsible for releasing the memory by calling free().

--*/

WCHAR * CorrectPathChangesBase::CorrectPathAllocW(const WCHAR * str)
{
    if (str == NULL)
        return NULL;

    // Make sure the paths have been initialized.
    InitializeCorrectPathChanges();

    if (bEnabled)
    {
        WCHAR * strCorrected = ReplaceAllStringsAllocW(str, vKnownPathFixes);

        return strCorrected;
    }
    else
    {
        return StringDuplicateW(str);
    }
}

void CorrectPathChangesBase::AddFromToPairW(const WCHAR * lpFromToPair )
{
    // Make sure the paths have been initialized.
    InitializeCorrectPathChanges();

    WCHAR * FromPath = NULL;
    WCHAR * ToPath = NULL;
    const WCHAR * PathBegin = NULL;
    char argSeperator = 0; // Stop parsing the string when we reach this char

    SkipBlanksW(lpFromToPair);

    // Malformed input, stop processing
    if (*lpFromToPair == 0)
        goto AllDone;

    // If the beginning of the string is a quote, look for the matching close quote
    if (*lpFromToPair == '"')
    {
        argSeperator = L'"';
        lpFromToPair += 1;
    }

    // The beginning of the From path
    PathBegin = lpFromToPair;

    // Search for the first from/to seperator, this is end of the From path
    while (*lpFromToPair != L';')
    {
        // Malformed input, stop processing
        if (*lpFromToPair == 0)
            goto AllDone;

        lpFromToPair += 1;
    }

    // Malformed input, stop processing
    if (lpFromToPair == PathBegin)
        goto AllDone;

    // Copy into our From string
    FromPath = StringNDuplicateW(PathBegin, (int)(lpFromToPair - PathBegin));

    lpFromToPair += 1; // Skip the from/to seperator

    // The beginning of the To path
    PathBegin = lpFromToPair;

    // Search for argSeperator, this is end of the To path
    while (*lpFromToPair != argSeperator)
    {
        // Found the end of the string, To path is definately complete
        if (*lpFromToPair == 0)
            break;

        lpFromToPair += 1;
    }

    // Malformed input, stop processing
    if (lpFromToPair == PathBegin)
        goto AllDone;

    // Copy into our To string
    ToPath = StringNDuplicateW(PathBegin, (int)(lpFromToPair - PathBegin));

    // Success!
    AddPathChangeW(FromPath, ToPath);

    AllDone:
    free(FromPath);
    free(ToPath);
}

/*++

    Take a single string containing (multiple) path change pairs,
    split them up and call AddPathChangeW.
    The from/to pair is seperated by a : (colon)
    If a path contains spaces, the entire pair must be surrounded by quotes

    Example:
    "%windir%\Goofy Location:%SystemDir%\CorrectLocation" %windir%\Goofy2:%SystemDir%\CorrectLocation2

    will call
    AddPathChangeW("%windir%\Goofy Location", "%SystemDir%\CorrectLocation");
    AddPathChangeW("%windir%\Goofy2", "%SystemDir%\CorrectLocation2");

--*/
void CorrectPathChangesBase::AddCommandLineW(const WCHAR * lpCommandLine )
{
    if (!lpCommandLine || *lpCommandLine == 0)
        return;

    DPF("CorrectPathChangesBase", eDbgLevelInfo, "AddCommandLine(%S)\n", lpCommandLine);

    int argc;
    LPWSTR * argv = _CommandLineToArgvW(lpCommandLine, &argc);
    if (!argv)
        return;

    for (int i = 0; i < argc; ++i)
    {
        AddFromToPairW(argv[i]);
    }

    free(argv);
}

/*++

    Simply widen the string and call AddCommandLineW

--*/
void CorrectPathChangesBase::AddCommandLineA(const char * lpCommandLine )
{
    if (!lpCommandLine || *lpCommandLine == 0)
        return;

    WCHAR * wszCommandLine = ToUnicode(lpCommandLine);

    AddCommandLineW(wszCommandLine);

    free(wszCommandLine);
}

// Get the full path to wordpad.exe from the registry
BOOL GetWordpadPath(CString & csWordpad)
{
    CSTRING_TRY
    {
        csWordpad.Truncate(0);

        LONG lStatus = RegQueryValueExW(csWordpad,
                                        HKEY_CLASSES_ROOT,
                                        L"Applications\\wordpad.exe\\shell\\open\\command",
                                        NULL);
        if (ERROR_SUCCESS == lStatus)
        {
            // String is of the form "wordpad path" "%1"
            // We want to grab all the stuff between the first pair of quotes
            if (csWordpad[0] == L'"')
            {
                int nNextQuote = csWordpad.Find(L'"', 1);
                if (nNextQuote > 0)
                {
                    csWordpad.Truncate(nNextQuote);
                    csWordpad.Delete(0, 1);

                    return TRUE;
                }
            }
        }
    }
    CSTRING_CATCH
    {
        // Fall thru
    }

    return FALSE;
}

void CorrectPathChangesUser::InitializePathFixes()
{
    // The order of this list is important.  Early entries may create paths that are modified by later entries.

    // Hardcoded bad path
    AddPathChangeW( L"c:\\windows",                                   L"%WinDir%" );
    // robkenny 4/2/2001 Do not redirect Program Files, because it is common to
    // create this directory on many hard drives, especially when c:\ is nearly full
//    AddPathChangeW( L"c:\\program files",                             L"%ProgramFiles%" );

    // Moved system applications
    AddPathChangeW( L"%WinDir%\\rundll32.exe",                        L"%SystemDir%\\rundll32.exe" );
    AddPathChangeW( L"%WinDir%\\rundll.exe",                          L"%SystemDir%\\rundll32.exe" );
    AddPathChangeW( L"%WinDir%\\write.exe",                           L"%SystemDir%\\write.exe" );
    AddPathChangeW( L"%WinDir%\\dxdiag.exe",                          L"%SystemDir%\\dxdiag.exe" );

    CSTRING_TRY
    {
        CString csWordpad;
        if (GetWordpadPath(csWordpad))
        {
            AddPathChangeW( L"%WinDir%\\wordpad.exe",                         csWordpad);
            AddPathChangeW( L"%ProgramFiles%\\Accessories\\wordpad.exe",      csWordpad);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }


    // Win9x single user locations (also default)
    AddPathChangeW( L"%WinDir%\\Start Menu",                          L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Desktop",                             L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\Favorites",                           L"%UserFavorites%" );
    // These locations are properly internationalized.  Duplicates of above for English
    AddPathChangeW( L"%WinDir%\\%CSIDL_STARTMENU_NAME%",              L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\%CSIDL_DESKTOPDIRECTORY_NAME%",       L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\%CSIDL_FAVORITES_NAME%",              L"%UserFavorites%" );


    // Win9x & WinNT multi user locations
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\Start Menu",                                  L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\Desktop",                                     L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\Favorites",                                   L"%UserFavorites%" );
    // These locations are properly internationalized.  Duplicates of above for English
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\%CSIDL_STARTMENU_NAME%",                      L"%UserStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\%CSIDL_DESKTOPDIRECTORY_NAME%",               L"%UserDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%Username%\\%CSIDL_FAVORITES_NAME%",                      L"%UserFavorites%" );


    // WinNT all user location
    AddPathChangeW( L"%WinDir%\\Profiles\\All Users\\Start Menu",                                   L"%AllStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\All Users\\Desktop",                                      L"%AllDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\All Users\\Favorites",                                    L"%UserFavorites%" ); // Should be %AllFavorites%, but IE 5.0 doesn't look there.
    // These locations are properly internationalized.  Duplicates of above for English
    AddPathChangeW( L"%WinDir%\\Profiles\\%AllUsersProfile_NAME%\\%CSIDL_STARTMENU_NAME%",          L"%AllStartMenu%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%AllUsersProfile_NAME%\\%CSIDL_DESKTOPDIRECTORY_NAME%",   L"%AllDesktop%" );
    AddPathChangeW( L"%WinDir%\\Profiles\\%AllUsersProfile_NAME%\\%CSIDL_FAVORITES_NAME%",          L"%UserFavorites%" ); // Should be %AllFavorites%, but IE 5.0 doesn't look there.


    // Win9x deleted DirectX files
    AddPathChangeW( L"ddhelp.exe",                                    L"ddraw.dll" );
    AddPathChangeW( L"ddraw16.dll",                                   L"ddraw.dll" );
    AddPathChangeW( L"dsound.vxd",                                    L"ddraw.dll" );
}

// Does the current process have permission to write into this directory?
BOOL CanWriteHere(DWORD clsid)
{
    WCHAR   wszDir[MAX_PATH];
    HRESULT result = SHGetFolderPathW( NULL, clsid, NULL, SHGFP_TYPE_DEFAULT, wszDir );
    if (SUCCEEDED(result))
    {
        //WCHAR wszTempFile[MAX_PATH];

        // We do not use GetTempFileName() to test if we have permission
        // to the directory even though it does all that we need.  Unfortunately
        // the temp file will appear in the start menu since it is not hidden.
        // Emulate the behaviour of GetTempFileName but use our file attributes.


        // Loop a bunch of times attempting to create a temp file,
        // If we can create this file return immediately,
        // If we have insuffient permission return immediately
        // certain other errors will return immediately
        // otherwise we'll attempt to open the next temp file name

        // 100 is totally arbitrary: just need to attempt this a bunch of times
        static const int MaxTempFileAttempts = 100;

        int i;
        for (i = 0; i < MaxTempFileAttempts; ++i)
        {
            HANDLE hTempFile = INVALID_HANDLE_VALUE;

            CSTRING_TRY
            {
                CString csTempFile;
                csTempFile.Format(L"%s\\CFP%08x.tmp", wszDir, i);

                DPF("CanWriteHere", eDbgLevelSpew, "File(%S)\n", csTempFile.Get());

                hTempFile = CreateFileW(
                    csTempFile,
                    GENERIC_WRITE | DELETE,
                    0, // no sharing
                    NULL,
                    CREATE_NEW,
                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                    NULL
                    );
            }
            CSTRING_CATCH
            {
                // do nothing
            }

            if (hTempFile != INVALID_HANDLE_VALUE)
            {
                DPF("CanWriteHere", eDbgLevelSpew, "success\n");

                CloseHandle(hTempFile);
                return TRUE;
            }
            else
            {
                // Borrowed this code from GetTempFileName:
                DWORD LastError = GetLastError();
                DPF("CanWriteHere", eDbgLevelSpew, "Error(0x%08x)\n", LastError);

                switch (LastError)
                {
                    case ERROR_INVALID_PARAMETER     :
                    case ERROR_WRITE_PROTECT         :
                    case ERROR_FILE_NOT_FOUND        :
                    case ERROR_BAD_PATHNAME          :
                    case ERROR_INVALID_NAME          :
                    case ERROR_PATH_NOT_FOUND        :
                    case ERROR_NETWORK_ACCESS_DENIED :
                    case ERROR_DISK_CORRUPT          :
                    case ERROR_FILE_CORRUPT          :
                    case ERROR_DISK_FULL             :
                        // An error from which we cannot recover...
                        return FALSE;

                    case ERROR_ACCESS_DENIED         :
                        // It's possible for us to hit this if there's a
                        // directory with the name we're trying; in that
                        // case, we can usefully continue.
                        // CreateFile() uses BaseSetLastNTError() to set
                        // LastStatusValue to the actual NT error in the
                        // TEB; we just need to check it, and only abort
                        // if it's not a directory.
                        // This was bug #397477.
                        if (NtCurrentTeb()->LastStatusValue != STATUS_FILE_IS_A_DIRECTORY)
                        {
                            // Insuffient permission
                            return FALSE;
                        }
                }
            }
        }

    }

    return FALSE;
}

void CorrectPathChangesAllUser::InitializePathFixes()
{
    CorrectPathChangesUser::InitializePathFixes();

    // The choice to put these values into All Users instead of <UserName>
    // was not taken lightly.  The problem is: some apps create  ...\All Users\Start Menu\folder
    // then attempt to place files into c:\windows\Start Menu\folder or username\Start Menu\folder.
    // Yes the apps are WRONG, but we want them to work.  By directing all of these paths
    // to All Users we *know* where the files will be placed and can make sure they all are the same place.

    // Another note, IE 5.0 does *not* look in All Users\Favorites for links,
    // so we force all favorites to end up in the user favorites.  Sheesh.

    // We add these changes twice, the first to convert any long path names to the All User dir,
    // the second to convert any short path names to All User.

    if (CanWriteHere(CSIDL_COMMON_STARTMENU))
    {
        AddPathChangeW( L"%UserStartMenu%",                               L"%AllStartMenu%" );
    }
    else
    {
        DPF("CorrectPathChangesAllUser", eDbgLevelInfo, "*NOT* forcing %UserStartMenu% to %AllStartMenu% -- insufficient permission");
    }

    /*
    // 05/11/2001 robkenny:
    // We are nolonger modifying the Desktop directory
    if (CanWriteHere(CSIDL_COMMON_DESKTOPDIRECTORY))
    {
        AddPathChangeW( L"%UserDesktop%",                                 L"%AllDesktop%" );
    }
    else
    {
        DPF("CorrectPathChangesAllUser", eDbgLevelInfo, "*NOT* forcing %UserDesktop% to %AllDesktop% -- insufficient permission");
    }
    */


    /*
    // IE 5.0/5.5 doesn't use All Users 
    if (CanWriteHere(CSIDL_COMMON_FAVORITES))
    {
        AddPathChangeW( L"%UserFavorites%",                              L"%AllFavorites%" ); // IE 5.0 doesn't use All Users
    }
    else
    {
        DPF("CorrectPathChangesAllUser", eDbgLevelInfo, "*NOT* forcing %UserFavorites% to %AllFavorites% -- insufficient permission");
    }
    */
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\argvw.cpp ===
/***
*argvw.c - create Unicode version of argv arguments
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       processes program command line
*
*Revision History:
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
*
*******************************************************************************/

// This routine actually lives in shell32.dll,
// we have a private copy so we don't have to link to the library.

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <wchar.h>

#include "StrSafe.h"

namespace ShimLib
{

/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPCWSTR cmdstart,
    LPWSTR*argv,
    LPWSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPCWSTR p;
    WCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = (WCHAR) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


/***
*CommandLineToArgvW - set up Unicode "argv" for C programs
*
*Purpose:
*       Read the command line and create the argv array for C
*       programs.
*
*Entry:
*       Arguments are retrieved from the program command line
*
*Exit:
*       "argv" points to a null-terminated list of pointers to UNICODE
*       strings, each of which is an argument from the command line.
*       The list of pointers is also located on the heap or stack.
*
*Exceptions:
*       Terminates with out of memory error if no memory to allocate.
*
*******************************************************************************/

LPWSTR * _CommandLineToArgvW (LPCWSTR lpCmdLine, int*pNumArgs)
{
    LPWSTR*argv_U;
    LPCWSTR cmdstart;                 /* start of command line to parse */
    INT     numbytes;

    if (pNumArgs == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    cmdstart = lpCmdLine;

    /* first find out how much space is needed to store args */
    Parse_Cmdline (cmdstart, NULL, NULL, pNumArgs, &numbytes);

    /* allocate space for argv[] vector and strings */
    argv_U = (LPWSTR*) LocalAlloc( LMEM_ZEROINIT,
                                   (*pNumArgs+1) * sizeof(LPWSTR) + numbytes);
    if (!argv_U) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (NULL);
    }

    /* store args and argv ptrs in just allocated block */
    Parse_Cmdline (cmdstart, argv_U,
                   (LPWSTR) (((LPBYTE)argv_U) + *pNumArgs * sizeof(LPWSTR)),
                   pNumArgs, &numbytes);

    return (argv_U);
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\common.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    Common.cpp

 Abstract:

    Common functions for all modules

 Notes:

    None

 History:

    12/15/1999  linstev     Created
    01/10/2000  linstev     Format to new style
    03/14/2000  robkenny    Added StringWiden and StringNWiden,
                            StringSubstituteRoutine[A|W] was not using the proper compare routine
                            when calling recursively.
    07/06/2000  t-adams     Added IsImage16Bit
    10/18/2000  a-larrsh    Move PatternMatch to common removing redundent code in shims.
    10/25/2000  linstev     Cleaned up
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
    09/11/2001  mnikkel     Modified DebugPrintfList, DebugPrintf, ShimLogList and ShimLog to retain LastError
    09/25/2001  rparsons    Modified logging code to use NT calls. Added critical section.
    10/18/2001  rparsons    Removed critical section, added mutex for logging.
    02/15/2002  robkenny    Security changes.

--*/

#include "ShimHook.h"
#include "ShimLib.h"
#include "ShimHookMacro.h"
#include "StrSafe.h"
#include <stdio.h>



namespace ShimLib
{

#define MAX_LOG_LENGTH  1024
static char             g_szLog[MAX_LOG_LENGTH];

WCHAR                   g_wszFileLog[MAX_PATH];       // name of the log file
BOOL                    g_bFileLogEnabled        = FALSE;   // enable/disable file logging
static HANDLE           g_hMemoryHeap            = INVALID_HANDLE_VALUE;
BOOL                    g_bDebugLevelInitialized = FALSE;
DEBUGLEVEL              g_DebugLevel             = eDbgLevelBase;

inline HANDLE GetHeap()
{
    if (g_hMemoryHeap == INVALID_HANDLE_VALUE)
    {
        g_hMemoryHeap = HeapCreate(0, 0, 0);
    }

    return g_hMemoryHeap;
}

void * __cdecl ShimMalloc(size_t size)
{
    HANDLE heap = GetHeap();

    void* memory = HeapAlloc(heap, HEAP_ZERO_MEMORY, size);

    return memory;
}

void __cdecl ShimFree(void * memory)
{
    HANDLE heap = GetHeap();
    HeapFree(heap, 0, memory);
}

void * __cdecl ShimCalloc( size_t num, size_t size )
{
    size_t nBytes = size * num;
    void * callocMemory = ShimMalloc(nBytes);
    ZeroMemory(callocMemory, nBytes);

    return callocMemory;
}

void * __cdecl ShimRealloc(void * memory, size_t size)
{
    if (memory == NULL)
        return ShimMalloc(size);

    HANDLE heap = GetHeap();
    void * reallocMemory = HeapReAlloc(heap, 0, memory, size);

    return reallocMemory;
}


DEBUGLEVEL GetDebugLevel()
{
    CHAR cEnv[MAX_PATH];

    if (g_bDebugLevelInitialized) {
        return g_DebugLevel;
    }

    g_DebugLevel = eDbgLevelBase;

    DWORD cchEnv = GetEnvironmentVariableA(szDebugEnvironmentVariable,
                                           cEnv,
                                           MAX_PATH);
    if (cchEnv > 0 && cchEnv < MAX_PATH) {

        CHAR c = cEnv[0];

        if ((c >= '0') || (c <= '9')) {
            g_DebugLevel = (DEBUGLEVEL)((int)(c - '0'));
        }
    }

    g_bDebugLevelInitialized = TRUE;

    return g_DebugLevel;
}

/*++

 Function Description:

    Assert that prints file and line number.

 Arguments:


    IN LPCSTR      file name
    IN DWORD       line number
    IN BOOL        assertion
    IN LPCSTR      String to print if assertion is false

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

#if DBG
VOID
DebugAssert(
    LPCSTR      szFile,
    DWORD       dwLine,
    BOOL        bAssert,
    LPCSTR      szHelpString
    )
{
    if (!bAssert )
    {
        DPF("ShimLib", eDbgLevelError, "\n");
        DPF("ShimLib", eDbgLevelError, "ASSERT: %s\n", szHelpString);
        DPF("ShimLib", eDbgLevelError, "FILE: %s\n", szFile);
        DPF("ShimLib", eDbgLevelError, "LINE: %d\n", dwLine);
        DPF("ShimLib", eDbgLevelError, "\n");

        DebugBreak();
    }
}

#endif // DBG

/*++

 Function Description:

    Print a formatted string using DebugOutputString.

 Arguments:

    IN dwDetail -  Detail level above which no print will occur
    IN pszFmt   -  Format string

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/


VOID
DebugPrintfList(
    LPCSTR      szShimName,
    DEBUGLEVEL  dwDetail,
    LPCSTR       pszFmt,
    va_list     vaArgList
    )
{
#if DBG

    // This must be the first line of this routine to preserve LastError.
    DWORD dwLastError = GetLastError();

    extern DEBUGLEVEL GetDebugLevel();

    char szT[1024];

    szT[1022] = '\0';
    StringCchVPrintfA(szT, 1022, pszFmt, vaArgList);

    // make sure we have a '\n' at the end of the string

    int len = lstrlen(szT);

    if (szT[len-1] != '\n')
    {
        szT[len]   = L'\n';
        szT[len+1] = L'\0';
    }


    if (dwDetail <= GetDebugLevel())
    {
        switch (dwDetail)
        {
        case eDbgLevelError:
            OutputDebugStringA ("[FAIL] ");
            break;
        case eDbgLevelWarning:
            OutputDebugStringA ("[WARN] ");
            break;
        case eDbgLevelInfo:
            OutputDebugStringA ("[INFO] ");
            break;
        }

        OutputDebugStringA(szShimName);

        OutputDebugStringA(" - ");

        OutputDebugStringA(szT);
    }

    // This must be the last line of this routine to preserve LastError.
    SetLastError(dwLastError);

#endif
}

VOID
DebugPrintf(
    LPCSTR      szShimName,
    DEBUGLEVEL  dwDetail,
    LPCSTR      pszFmt,
    ...
    )
{
#if DBG

    // This must be the first line of this routine to preserve LastError.
    DWORD dwLastError = GetLastError();

    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    DebugPrintfList(szShimName, dwDetail, pszFmt, vaArgList);

    va_end(vaArgList);

    // This must be the last line of this routine to preserve LastError.
    SetLastError(dwLastError); 

#endif
}

/*++

 Function Description:

    Prints a log in the log file if logging is enabled

 Arguments:

    IN  pszFmt -  Format string

 Return Value:

    none

 History:

    03/03/2000 clupu  Created

--*/



/*++

 Function Description:

    Prints a log in the log file if logging is enabled

 Arguments:

    IN wszShimName  -  Name of shim that string originates from
    IN dwDetail     -  Detail level above which no print will occur
    IN pszFmt       -  Format string

 Return Value:

    none

 History:

    03/03/2000 clupu  Created
    09/25/2001  rparsons    Converted to NT calls

--*/

void
ShimLogList(
    LPCSTR      szShimName,
    DEBUGLEVEL  dwDbgLevel,
    LPCSTR      pszFmt,
    va_list     arglist
    )
{
    //
    // This must be the first line of this routine to preserve LastError.
    //
    DWORD dwLastError = GetLastError();

    int                 nLen = 0;
    NTSTATUS            status;
    SYSTEMTIME          lt;
    UNICODE_STRING      strLogFile = {0};
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    char                szNewLine[] = "\r\n";
    DWORD               dwWaitResult;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hLogMutex;

    //
    // Convert the path to the log file from DOS to NT.
    //
    RtlInitUnicodeString(&strLogFile, g_wszFileLog);

    status = RtlDosPathNameToNtPathName_U(strLogFile.Buffer, &strLogFile, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib", eDbgLevelError,
            "[ShimLogList] 0x%X Failed to convert log file '%ls' to NT path",
            status, g_wszFileLog);
        return;
    }

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to open log file %ls",
            status, g_wszFileLog);
        return;
    }

    SetFilePointer(hFile, 0, NULL, FILE_END);

    //
    // Print a header consisting of data, time, app name, and shim name.
    //
    GetLocalTime(&lt);

    StringCbPrintf(g_szLog, MAX_LOG_LENGTH, "%02d/%02d/%04d %02d:%02d:%02d %s %d - ",
            lt.wMonth, lt.wDay,    lt.wYear,
            lt.wHour,  lt.wMinute, lt.wSecond,
            szShimName,
            dwDbgLevel);

    nLen = lstrlen(g_szLog);

    //
    // Write the header out to the file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    //
    // Get a handle to the mutex and attempt to get ownership.
    //
    hLogMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, "SHIMLIB_LOG_MUTEX");

    if (!hLogMutex) {
        DPF("ShimLib", eDbgLevelError, "[ShimLogList] %lu Failed to open logging mutex", GetLastError());
        goto exit;
    }

    dwWaitResult = WaitForSingleObject(hLogMutex, 500);

    if (WAIT_OBJECT_0 == dwWaitResult) {
        //
        // Write the header to the log file.
        //
        status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)g_szLog,
                             (ULONG)nLen,
                             &liOffset,
                             NULL);
        
        if (!NT_SUCCESS(status)) {
            DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to write header to log file",
                status);
            goto exit;
        }
    
        //
        // Format our string using the specifiers passed.
        //
        StringCchVPrintfA(g_szLog, MAX_LOG_LENGTH - 1, pszFmt, arglist);
    
        //
        // Write the actual data out to the file.
        //
        IoStatusBlock.Status = 0;
        IoStatusBlock.Information = 0;
    
        liOffset.LowPart  = 0;
        liOffset.HighPart = 0;
    
        nLen = lstrlen(g_szLog);
    
        status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)g_szLog,
                             (ULONG)nLen,
                             &liOffset,
                             NULL);
        
        if (!NT_SUCCESS(status)) {
            DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to make entry in log file",
                status);
            goto exit;
        }
    
        //
        // Now write a new line to the log file.
        //
        IoStatusBlock.Status = 0;
        IoStatusBlock.Information = 0;
    
        liOffset.LowPart  = 0;
        liOffset.HighPart = 0;
    
        nLen = lstrlen(szNewLine);
    
        status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)szNewLine,
                             (ULONG)nLen,
                             &liOffset,
                             NULL);
        
        if (!NT_SUCCESS(status)) {
            DPF("ShimLib", eDbgLevelError, "[ShimLogList] 0x%X Failed to write new line to log file",
                status);
            goto exit;
        }
    }
    
    //
    // Dump it out to the debugger on checked builds.
    //
#if DBG
    DebugPrintf(szShimName, dwDbgLevel, g_szLog);
    DebugPrintf(szShimName, dwDbgLevel, "\n");
#endif // DBG

exit:

    if (INVALID_HANDLE_VALUE != hFile) {
        NtClose(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    if (hLogMutex) {
        ReleaseMutex(hLogMutex);
    }

    //
    // This must be the last line of this routine to preserve LastError.
    //
    SetLastError(dwLastError);
}


/*++

 Function Description:

    Initializes the support for file logging.

 Arguments:

    None.

 Return Value:

    TRUE if successful, FALSE if failed

 History:

    03/03/2000  clupu       Created

--*/
BOOL
InitFileLogSupport()
{
    BOOL                fReturn = FALSE;
    WCHAR               wszAppPatch[MAX_PATH];
    WCHAR*              pwsz = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hLogMutex = NULL;
    DWORD               dwLen = 0;
    DWORD               dwWait;
    NTSTATUS            status;
    UNICODE_STRING      strLogFile = {0};
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;

    //
    // Attempt to create a mutex. If the mutex already exists,
    // we don't need to go any further as the log file has
    // already been created.
    //
    hLogMutex = CreateMutex(NULL, FALSE, "SHIMLIB_LOG_MUTEX");

    if (hLogMutex == NULL) {
        DPF("ShimLib",
            eDbgLevelError,
            "[InitFileLogSupport] 0x%08X Failed to create logging mutex",
            GetLastError());
        return FALSE;
    }

    DWORD dwLastError = GetLastError();
    
    if (ERROR_ALREADY_EXISTS == dwLastError) {
        fReturn = TRUE;
        goto exit;
    }

    //
    // Ensure that we own the mutex before continuing.
    //
    dwWait = WaitForSingleObject(hLogMutex, 2000);

    if (WAIT_OBJECT_0 != dwWait) {
        //
        // Failed to obtain ownership.
        //
        DPF("ShimLib",
            eDbgLevelError,
            "[InitFileLogSupport] Wait on mutex failed");
        return FALSE;
    }

    //
    // We'll create the log file in %windir%\AppPatch.
    //
    if (!GetSystemWindowsDirectoryW(g_wszFileLog, MAX_PATH)) {
        DPF("ShimLib",
            eDbgLevelError,
            "[InitFileLogSupport] 0x%08X Failed to get windir path",
            GetLastError());
        goto exit;
    }

    StringCchCatW(g_wszFileLog, MAX_PATH, L"\\AppPatch\\");

    dwLen = lstrlenW(g_wszFileLog);
    pwsz = g_wszFileLog + dwLen;
    
    //
    // Query the environment variable and get the name of our log file.
    //
    if (!GetEnvironmentVariableW(wszFileLogEnvironmentVariable,
                                 pwsz,
                                 (MAX_PATH - dwLen))) {
        goto exit;
    }

    //
    // Convert the path to the log file from DOS to NT.
    //
    RtlInitUnicodeString(&strLogFile, g_wszFileLog);

    status = RtlDosPathNameToNtPathName_U(strLogFile.Buffer,
                                          &strLogFile,
                                          NULL,
                                          NULL);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib",
            eDbgLevelError,
            "[InitFileLogSupport] 0x%X Failed to convert log file '%ls' to NT path",
            status,
            g_wszFileLog);
        goto exit;
    }

    //
    // Attempt to create the log file. If it exists,
    // the contents will be cleared.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN_IF,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("ShimLib",
            eDbgLevelError,
            "[InitFileLogSupport] 0x%X Failed to open log file %ls",
            status,
            g_wszFileLog);
        goto exit;
    }

    NtClose(hFile);

    g_bFileLogEnabled = TRUE;
    fReturn = TRUE;

exit:

    ReleaseMutex(hLogMutex);

    return fReturn;
}


/*++

 Function Description:

    Determine the drive type a file resides on.

 Arguments:

    IN lpFileName - Filename or relative filename

 Return Value:

    See GetDriveType in MSDN

 History:

    10/25/2000 linstev  Created

--*/

UINT
GetDriveTypeFromFileNameA(LPCSTR lpFileName, char *lpDriveLetter)
{
    WCHAR * lpwszFileName = ToUnicode(lpFileName);
    if (lpwszFileName)
    {
        WCHAR szDrive;
        UINT uType = GetDriveTypeFromFileNameW(lpwszFileName, &szDrive);

        if (lpDriveLetter)
        {
            char * lpszFileName = ToAnsi(lpwszFileName);
            if (lpszFileName)
            {
                *lpDriveLetter = lpszFileName[0];

                free(lpszFileName);
            }
        }

        free(lpwszFileName);

        return uType;
    }
    else
    {
        return DRIVE_UNKNOWN;
    }
}

/*++

 Function Description:

    Determine the drive type a file resides on.

 Arguments:

    IN lpFileName - Filename or relative filename

 Return Value:

    See GetDriveType in MSDN

 History:

    10/25/2000 linstev  Created

--*/

UINT
GetDriveTypeFromFileNameW(LPCWSTR lpFileName, WCHAR *lpDriveLetter)
{
    if (lpFileName && (lpFileName[0] == L'\\') && (lpFileName[1] == L'\\'))
    {
        // UNC naming - always network
        if (lpDriveLetter)
        {
            *lpDriveLetter = L'\0';
        }
        return DRIVE_REMOTE;
    }

    WCHAR cDrive;

    if (lpFileName && lpFileName[0] && (lpFileName[1] == L':'))
    {
        // Format is Drive:Path\File, so just take the drive
        cDrive = lpFileName[0];
    }
    else
    {
        // Must be a relative path
        cDrive = 0;

        WCHAR *wzCurDir = NULL;
        DWORD dwCurDirSize = GetCurrentDirectoryW(0, wzCurDir);

        if (!dwCurDirSize)
        {
            goto EXIT;
        }

        wzCurDir = (LPWSTR) LocalAlloc(LPTR, dwCurDirSize * sizeof(WCHAR));
        if (!wzCurDir)
        {
            goto EXIT;
        }

        dwCurDirSize = GetCurrentDirectoryW(dwCurDirSize, wzCurDir);
        if (!dwCurDirSize || wzCurDir[0] == L'\\')
        {
            goto EXIT;
        }

        cDrive = wzCurDir[0];

    EXIT:
        if (wzCurDir)
        {
            LocalFree(wzCurDir);
        }
    }

    if (lpDriveLetter)
    {
        *lpDriveLetter = L'\0';
    }

    if (cDrive)
    {
        WCHAR wzDrive[4];
        wzDrive[0] = cDrive;
        wzDrive[1] = L':';
        wzDrive[2] = L'\\';
        wzDrive[3] = L'\0';
        if (lpDriveLetter)
        {
            *lpDriveLetter = cDrive;
        }

        return GetDriveTypeW(wzDrive);
    }
    else
    {
        return DRIVE_UNKNOWN;
    }
}

/*++

 Function Description:

    Widen and duplicate a string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy

 Return Value:

    String in malloc memory

 History:

    03/07/2000 robkenny Created
    05/16/2000 robkenny Moved MassagePath (shim specific) routines out of here.

--*/

WCHAR *
ToUnicode(const char *strToCopy)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    // Get the number of characters in the resulting string, includes NULL at end
    int nChars = MultiByteToWideChar(CP_ACP, 0, strToCopy, -1, NULL, 0);
    WCHAR *lpwsz = (WCHAR *) malloc(nChars * sizeof(WCHAR));
    if (lpwsz)
    {
        nChars = MultiByteToWideChar(CP_ACP, 0, strToCopy, -1, lpwsz, nChars);
        // If MultibyteToWideChar failed, return NULL
        if (nChars == 0)
        {
            free(lpwsz);
            lpwsz = NULL;
        }
    }

    return lpwsz;
}


/*++

 Function Description:

    Convert a WCHAR string to a char string

 Arguments:

    IN  lpOld - String to convert to char

 Return Value:

    char string in malloc memory

 History:

    06/19/2000 robkenny Created

--*/

char *
ToAnsi(const WCHAR *lpOld)
{
    if (lpOld == NULL)
    {
        return NULL;
    }

    // Get the number of bytes necessary for the WCHAR string
    int nBytes = WideCharToMultiByte(CP_ACP, 0, lpOld, -1, NULL, 0, NULL, NULL);
    char *lpsz = (char *) malloc(nBytes);
    if (lpsz)
    {
        nBytes = WideCharToMultiByte(CP_ACP, 0, lpOld, -1, lpsz, nBytes, NULL, NULL);
        // If WideCharToMultibyte failed, return NULL
        if (nBytes == 0)
        {
            free(lpsz);
            lpsz = NULL;
        }
    }

    return lpsz;
}

/*++

 Function Description:

    Duplicate the first nChars of strToCopy string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy
    IN  nChar     - Number of chars to duplicate, does not count NULL at end.

 Return Value:

    String in malloc memory

 History:

    06/02/2000 robkenny Created

--*/

char *
StringNDuplicateA(const char *strToCopy, int nChars)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    size_t nBytes = (nChars + 1) * sizeof(strToCopy[0]);

    char *strDuplicate = (char *) malloc(nBytes);
    if (strDuplicate)
    {
        memcpy(strDuplicate, strToCopy, nBytes);
        strDuplicate[nChars] = 0;
    }

    return strDuplicate;
}

/*++

 Function Description:

    Duplicate a string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy

 Return Value:

    String in malloc memory

 History:

    01/10/2000 linstev  Updated
    02/14/2000 robkenny Converted from VirtualAlloc to malloc
    06/02/2000 robkenny Use StringNDuplicateA

--*/

char *
StringDuplicateA(const char *strToCopy)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    char *strDuplicate = StringNDuplicateA(strToCopy, strlen(strToCopy));
    return strDuplicate;
}

/*++

 Function Description:

    Duplicate the first nChars of strToCopy string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy
    IN  nChar     - Number of chars to duplicate, does not count NULL at end.

 Return Value:

    String in malloc memory

 History:

    06/02/2000 robkenny Created

--*/

WCHAR *
StringNDuplicateW(const WCHAR *strToCopy, int nChars)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    size_t nBytes = (nChars + 1) * sizeof(strToCopy[0]);

    WCHAR *strDuplicate = (WCHAR *) malloc(nBytes);
    if (strDuplicate)
    {
        memcpy(strDuplicate, strToCopy, nBytes);
        strDuplicate[nChars] = 0;
    }

    return strDuplicate;
}

/*++

 Function Description:

    Duplicate a string into malloc memory.

 Arguments:

    IN  strToCopy - String to copy

 Return Value:

    String in malloc memory

 History:

    01/10/2000 linstev  Updated
    02/14/2000 robkenny Converted from VirtualAlloc to malloc
    06/02/2000 robkenny Use StringNDuplicateW

--*/

WCHAR *
StringDuplicateW(const WCHAR *strToCopy)
{
    if (strToCopy == NULL)
    {
        return NULL;
    }

    WCHAR *wstrDuplicate = StringNDuplicateW(strToCopy, wcslen(strToCopy));
    return wstrDuplicate;
}


/*++

 Function Description:

    Skip leading whitespace

 Arguments:

    IN  str - String to scan

 Return Value:

    None

 History:

    01/10/2000 linstev  Updated

--*/

VOID
SkipBlanksW(const WCHAR *& str)
{
    if (str)
    {
        // Skip leading whitespace
        static const WCHAR *WhiteSpaceString = L" \t";
        str += wcsspn(str, WhiteSpaceString);
    }
}

/*++

 Function Description:

    Find the first occurance of strCharSet in string
    Case insensitive

 Arguments:

    IN string            - String to search
    IN strCharSet        - String to search for

 Return Value:

    First occurance or NULL

 History:

    12/01/1999 robkenny Created
    12/15/1999 linstev  Reformatted

--*/

char*
__cdecl
stristr(
    IN const char* string,
    IN const char* strCharSet
    )
{
    char *pszRet = NULL;

    long  nstringLen     = strlen(string) + 1;
    long  nstrCharSetLen = strlen(strCharSet) + 1;

    char *szTemp_string     = (char *) malloc(nstringLen);
    char *szTemp_strCharSet = (char *) malloc(nstrCharSetLen);

    if ((!szTemp_string) || (!szTemp_strCharSet))
    {
        goto Fail;
    }

    StringCchCopyA(szTemp_string,     nstringLen,     string);
    StringCchCopyA(szTemp_strCharSet, nstrCharSetLen, strCharSet);

    _strlwr(szTemp_string);
    _strlwr(szTemp_strCharSet);

    pszRet = strstr(szTemp_string, szTemp_strCharSet);

    if (pszRet)
    {
        pszRet = ((char *) string) + (pszRet - szTemp_string);
    }

Fail:
    if (szTemp_string)
    {
        free(szTemp_string);
    }

    if (szTemp_strCharSet)
    {
        free(szTemp_strCharSet);
    }

    return pszRet;
}

/*++

 Function Description:

    Find the first occurance of strCharSet in string
    Case insensitive

 Arguments:

    IN string            - String to search
    IN strCharSet        - String to search for

 Return Value:

    First occurance or NULL

 History:

    12/01/1999 robkenny Created
    12/15/1999 linstev  Reformatted
    05/04/2001 maonis   Changed to use more efficient implementation.

--*/

#define _UPPER          0x1 /* upper case letter */
#define iswupper(_c)    (iswctype(_c,_UPPER))

WCHAR*
__cdecl
wcsistr(
    IN const WCHAR* wcs1,
    IN const WCHAR* wcs2
    )
{
    wchar_t *cp = (wchar_t *) wcs1;
    wchar_t *s1, *s2;
    wchar_t cs1, cs2;

    while (*cp)
    {
            s1 = cp;
            s2 = (wchar_t *) wcs2;

            cs1 = *s1;
            cs2 = *s2;

            if (iswupper(cs1))
                cs1 = towlower(cs1);

            if (iswupper(cs2))
                cs2 = towlower(cs2);


            while ( *s1 && *s2 && !(cs1-cs2) ) {

                s1++, s2++;

                cs1 = *s1;
                cs2 = *s2;

                if (iswupper(cs1))
                    cs1 = towlower(cs1);

                if (iswupper(cs2))
                    cs2 = towlower(cs2);
            }

            if (!*s2)
                    return(cp);

            cp++;
    }

    return(NULL);
}

/*++

 Function Description:

    Find the next token in a string. See strtok in MSDN.
    Implemented here so we don't need CRT.

 Arguments:

    OUT strToken   - string containing token(s)
    IN  strDelimit - token list

 Return Value:

    Return a pointer to the next token found.

 History:

    04/19/2000 linstev  Created

--*/

char *
__cdecl
_strtok(
    char *strToken,
    const char *strDelimit
    )
{
    unsigned char *str = (unsigned char *)strToken;
    const unsigned char *ctrl = (const unsigned char *)strDelimit;

    unsigned char map[32];
    int count;
    char *token;

    static char *nextoken;

    // Clear strDelimit map
    for (count = 0; count < 32; count++)
    {
        map[count] = 0;
    }

    // Set bits in delimiter table
    do
    {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    } while (*ctrl++);

    // If strToken==NULL, continue with previous strToken
    if (!str)
    {
        str = (unsigned char *)nextoken;
    }

    // Find beginning of token (skip over leading delimiters). Note that
    // there is no token iff this loop sets strToken to point to the terminal
    // null (*strToken == '\0')
    while ((map[*str >> 3] & (1 << (*str & 7))) && *str)
    {
        str++;
    }

    token = (char *)str;

    // Find the end of the token. If it is not the end of the strToken,
    // put a null there.
    for (; *str; str++)
    {
        if (map[*str >> 3] & (1 << (*str & 7)))
        {
            *str++ = '\0';
            break;
        }
    }

    // Update nextoken (or the corresponding field in the per-thread data
    // structure
    nextoken = (char *)str;

    // Determine if a token has been found
    if (token == (char *)str)
    {
        return NULL;
    }
    else
    {
        return token;
    }
}


/*++

 Function Description:

    Tests whether an executable is 16-Bit.

 Arguments:

    IN  szImageName - The name of the executable image.

 Return Value:

    TRUE if executable image is found to be 16-bit, FALSE otherwise.

 History:

    07/06/2000 t-adams  Created

--*/

BOOL
IsImage16BitA(LPCSTR lpApplicationName)
{
    DWORD dwBinaryType;

    if (GetBinaryTypeA(lpApplicationName, &dwBinaryType))
    {
        return (dwBinaryType == SCS_WOW_BINARY);
    }
    else
    {
        return FALSE;
    }
}

/*++

 Function Description:

    Tests whether an executable is 16-Bit.

 Arguments:

    IN  wstrImageName - The name of the executable image.

 Return Value:

    TRUE if executable image is found to be 16-bit, FALSE otherwise.

 History:

    07/06/2000 t-adams  Created

--*/

BOOL
IsImage16BitW(LPCWSTR lpApplicationName)
{
    DWORD dwBinaryType;

    if (GetBinaryTypeW(lpApplicationName, &dwBinaryType))
    {
        return (dwBinaryType == SCS_WOW_BINARY);
    }
    else
    {
        return FALSE;
    }
}

/*++

 Function Description:

    Match these two strings, with wildcards.
    ? matches a single character
    * matches 0 or more characters
    The compare is case in-sensitive

 Arguments:

    IN  pszPattern - Pattern for matching.
    IN  pszTestString - String to match against.

 Return Value:

    TRUE if pszTestString matches pszPattern.

 History:

    01/09/2001  markder     Replaced non-straightforward version.

--*/

BOOL
PatternMatchW(
    IN  LPCWSTR pszPattern,
    IN  LPCWSTR pszTestString)
{
    //
    // March through pszTestString. Each time through the loop,
    // pszTestString is advanced one character.
    //
    for (;;) {

        //
        // If pszPattern and pszTestString are both sitting on a NULL,
        // then they reached the end at the same time and the strings
        // must be equal.
        //
        if (*pszPattern == L'\0' && *pszTestString == L'\0') {
            return TRUE;
        }

        if (*pszPattern != L'*') {

            //
            // Non-asterisk mode. Look for a match on this character.
            //

            switch (*(pszPattern)) {

            case L'?':
                //
                // Match on any character, don't bother comparing.
                //
                pszPattern++;
                break;

            case L'\\':
                //
                // Backslash indicates to take the next character
                // verbatim. Advance the pointer before making a
                // comparison.
                //
                pszPattern++;

            default:
                //
                // Compare the characters. If equal, continue traversing.
                // Otherwise, the strings cannot be equal so return FALSE.
                //
                if (towupper(*pszPattern) == towupper(*pszTestString)) {
                    pszPattern++;
                } else {
                    return FALSE;
                }
            }

        } else {

            //
            // Asterisk mode. Look for a match on the character directly
            // after the asterisk.
            //

            switch (*(pszPattern + 1)) {

            case L'*':
                //
                // Asterisks exist side by side. Advance the pattern pointer
                // and go through loop again.
                //
                pszPattern++;
                continue;

            case L'\0':
                //
                // Asterisk exists at the end of the pattern string. Any
                // remaining part of pszTestString matches so we can
                // immediately return TRUE.
                //
                return TRUE;

            case L'?':
                //
                // Match on any character. If the remaining parts of
                // pszPattern and pszTestString match, then the entire
                // string matches. Otherwise, keep advancing the
                // pszTestString pointer.
                //
                if (PatternMatchW(pszPattern + 1, pszTestString)) {
                    return TRUE;
                }
                break;

            case L'\\':
                //
                // Backslash indicates to take the next character
                // verbatim. Advance the pointer before making a
                // comparison.
                //
                pszPattern++;
                break;
            }

            if (towupper(*(pszPattern + 1)) == towupper(*pszTestString)) {
                //
                // Characters match. If the remaining parts of
                // pszPattern and pszTestString match, then the entire
                // string matches. Otherwise, keep advancing the
                // pszTestString pointer.
                //
                if (PatternMatchW(pszPattern + 1, pszTestString)) {
                    return TRUE;
                }
            }
        }

        //
        // No more pszTestString left. Must not be a match.
        //
        if (!*pszTestString) {
            return FALSE;
        }

        pszTestString++;
    }
    return FALSE;
}

/*++

 Function Description:

    Determine if the current process is a SafeDisc process. We do this by
    simply by testing if both an .EXE and .ICD extension exist for the
    process name.

 Arguments:

    None.

 Return Value:

    TRUE if Safedisc 1.x is detected.

 History:

    01/23/2001  linstev   Created

--*/

BOOL
bIsSafeDisc1()
{
    BOOL bRet = FALSE;

    CSTRING_TRY
    {
        CString csFileName;
        csFileName.GetModuleFileNameW(NULL);

        if (csFileName.EndsWithNoCase(L".exe") == 0)
        {
            // Current file is .EXE, check for corresponding .ICD

            csFileName.Truncate(csFileName.GetLength() - 4);
            csFileName += L".icd";

            bRet = GetFileAttributesW(csFileName) != 0xFFFFFFFF;
        }

        if (bRet) {
            DPF("ShimLib", eDbgLevelInfo, "SafeDisc detected: %S", csFileName.Get());
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return bRet;
}

/*++

 Function Description:

    Determine if the current process is a SafeDisc process. We do this running the
    image header and looking for a particular signature.

 Arguments:

    None.

 Return Value:

    TRUE if Safedisc 2 is detected.

 History:

    07/28/2001  linstev   Created

--*/

BOOL
bIsSafeDisc2()
{
    PPEB Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD dwCnt = 0;

    //
    // Use the try-except in case the module list changes while we're looking at it
    //
    __try {
        //
        // Loop through the loaded modules. We use a count to make sure we
        // aren't looping infinitely
        //
        LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

        LdrNext = LdrHead->Flink;

        while ((LdrNext != LdrHead) && (dwCnt < 256)) {

            PLDR_DATA_TABLE_ENTRY LdrEntry;

            LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

            if ((SSIZE_T)LdrEntry->DllBase > 0) {
                //
                // A user mode dll, now check for temp name
                //
                WCHAR *wzName = LdrEntry->BaseDllName.Buffer;
                DWORD dwLen;

                if (wzName && (dwLen = wcslen(wzName)) && (dwLen > 4) && (_wcsicmp(wzName + dwLen - 4, L".tmp") == 0)) {
                    //
                    // Name ends in .tmp, so detect SafeDisc
                    //
                    DWORD_PTR hMod = (DWORD_PTR) LdrEntry->DllBase;
                    PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER) hMod;
                    PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)(hMod + pIDH->e_lfanew);
                    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY) (hMod + pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
                    LPSTR pName = (LPSTR)(hMod + pExport->Name);

                    if (_stricmp(pName, "SecServ.dll") == 0) {
                        //
                        // Export name says this is SafeDisc
                        //
                        DPF("ShimLib", eDbgLevelInfo, "SafeDisc 2 detected");
                        return TRUE;
                    }
                }
            }

            dwCnt++;
            LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DPF("ShimLib", eDbgLevelError, "Exception encounterd while detecting SafeDisc 2");
    }

    return FALSE;
}

/*++

 Function Description:

    Determine if the current process is NTVDM.

 Arguments:

    None.

 Return Value:

    TRUE if NTVDM is detected.

 History:

    01/14/2002  clupu   Created

--*/

BOOL
IsNTVDM(
    void
    )
{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY           Head;
    PPEB                  Peb = NtCurrentPeb();

    Head = &Peb->Ldr->InLoadOrderModuleList;
    Head = Head->Flink;

    Entry = CONTAINING_RECORD(Head, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);

    if (_wcsicmp(Entry->FullDllName.Buffer, L"ntvdm.exe") == 0) {
        return TRUE;
    }

    return FALSE;
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\cstring.cpp ===
/*++

 Copyright (c) 2001-2002 Microsoft Corporation

 Module Name:

    CString.cpp

 Abstract:
    A CString class, pure UNICODE internally.

   This code was ripped from MFC Strcore.cpp and Strex.cpp

 History:

    05/11/2001   robkenny     Added this header
    05/11/2001   robkenny     Fixed SplitPath.
    05/11/2001   robkenny     Do not Truncate(0) GetShortPathNameW,
                              GetLongPathNameW and GetFullPathNameW if
                              the API does not succeed.
    08/14/2001  robkenny      Moved code inside the ShimLib namespace.
    02/28/2002  robkenny      Security review.
    
--*/



#include "ShimHook.h"
#include "StrSafe.h"
#include "Win9xPath.h"


namespace ShimLib
{

typedef WCHAR  _TUCHAR;
struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };


#ifdef USE_SEH
const ULONG_PTR  CString::m_CStringExceptionValue = CString::eCStringExceptionValue;

// Exception filter for CString __try/__except blocks
// Return EXCEPTION_EXECUTE_HANDLER if this is a CString exception
// otherwise return EXCEPTION_CONTINUE_SEARCH
int CString::ExceptionFilter(PEXCEPTION_POINTERS pexi)
{
    if (pexi->ExceptionRecord->ExceptionCode            == CString::eCStringNoMemoryException &&
        pexi->ExceptionRecord->NumberParameters         == 1 &&
        pexi->ExceptionRecord->ExceptionInformation[0]  == CString::m_CStringExceptionValue
        )
    {
        // This is a CString exception, handle it
        return EXCEPTION_EXECUTE_HANDLER;
    }

    // Not our error
    return EXCEPTION_CONTINUE_SEARCH;
}
#endif


// The original code was written using a memcpy that incorrectly handled
// overlapping buffers, despite the documentation.
// Replace memcpy with memmove, which correctly handles overlapping buffers
#define memcpy memmove

const WCHAR * wcsinc(const WCHAR * s1)                                    
{ 
    return (s1) + 1; 
}

LPWSTR wcsinc(LPWSTR s1)                                    
{ 
    return (s1) + 1; 
}

// WCS routines that are only available in MSVCRT

wchar_t * __cdecl _wcsrev (
    wchar_t * string
    )
{
    wchar_t *start = string;
    wchar_t *left = string;
    wchar_t ch;

    while (*string++)         /* find end of string */
        ;
    string -= 2;

    while (left < string)
    {
        ch = *left;
        *left++ = *string;
        *string-- = ch;
    }

    return(start);
}


void __cdecl _wsplitpath (
        register const WCHAR *path,
        WCHAR *drive,
        WCHAR *dir,
        WCHAR *fname,
        WCHAR *ext
        )
{
        register WCHAR *p;
        WCHAR *last_slash = NULL, *dot = NULL;
        unsigned len;

        /* we assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *  <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *  0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *  ':'
         *  dir:
         *  0 to _MAX_DIR-1 characters in the form of an absolute path
         *  (leading '/' or '\') or relative path, the last of which, if
         *  any, must be a '/' or '\'.  E.g -
         *  absolute path:
         *      \top\next\last\     ; or
         *      /top/next/last/
         *  relative path:
         *      top\next\last\  ; or
         *      top/next/last/
         *  Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *  0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *  0 to _MAX_EXT-1 characters where, if any, the first must be a
         *  '.'
         *
         */

        /* extract drive letter and :, if any */

        if ((wcslen(path) >= (_MAX_DRIVE - 2)) && (*(path + _MAX_DRIVE - 2) == L':')) {
            if (drive) {
                wcsncpy(drive, path, _MAX_DRIVE - 1);
                *(drive + _MAX_DRIVE-1) = L'\0';
            }
            path += _MAX_DRIVE - 1;
        }
        else if (drive) {
            *drive = L'\0';
        }

        /* extract path string, if any.  Path now points to the first character
         * of the path, if any, or the filename or extension, if no path was
         * specified.  Scan ahead for the last occurence, if any, of a '/' or
         * '\' path separator character.  If none is found, there is no path.
         * We will also note the last '.' character found, if any, to aid in
         * handling the extension.
         */

        for (last_slash = NULL, p = (WCHAR *)path; *p; p++) {
            if (*p == L'/' || *p == L'\\')
                /* point to one beyond for later copy */
                last_slash = p + 1;
            else if (*p == L'.')
                dot = p;
        }

        if (last_slash) {

            /* found a path - copy up through last_slash or max. characters
             * allowed, whichever is smaller
             */

            if (dir) {
                len = __min((unsigned)(((char *)last_slash - (char *)path) / sizeof(WCHAR)),
                    (_MAX_DIR - 1));
                wcsncpy(dir, path, len);
                *(dir + len) = L'\0';
            }
            path = last_slash;
        }
        else if (dir) {

            /* no path found */

            *dir = L'\0';
        }

        /* extract file name and extension, if any.  Path now points to the
         * first character of the file name, if any, or the extension if no
         * file name was given.  Dot points to the '.' beginning the extension,
         * if any.
         */

        if (dot && (dot >= path)) {
            /* found the marker for an extension - copy the file name up to
             * the '.'.
             */
            if (fname) {
                len = __min((unsigned)(((char *)dot - (char *)path) / sizeof(WCHAR)),
                    (_MAX_FNAME - 1));
                wcsncpy(fname, path, len);
                *(fname + len) = L'\0';
            }
            /* now we can get the extension - remember that p still points
             * to the terminating nul character of path.
             */
            if (ext) {
                len = __min((unsigned)(((char *)p - (char *)dot) / sizeof(WCHAR)),
                    (_MAX_EXT - 1));
                wcsncpy(ext, dot, len);
                *(ext + len) = L'\0';
            }
        }
        else {
            /* found no extension, give empty extension and copy rest of
             * string into fname.
             */
            if (fname) {
                len = __min((unsigned)(((char *)p - (char *)path) / sizeof(WCHAR)),
                    (_MAX_FNAME - 1));
                wcsncpy(fname, path, len);
                *(fname + len) = L'\0';
            }
            if (ext) {
                *ext = L'\0';
            }
        }
}

// conversion helpers
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// AfxIsValidString() returns TRUE if the passed pointer
// references a string of at least the given length in characters.
// A length of -1 (the default parameter) means that the string
// buffer's minimum length isn't known, and the function will
// return TRUE no matter how long the string is. The memory
// used by the string can be read-only.

BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength /* = -1 */)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

// AfxIsValidAddress() returns TRUE if the passed parameter points
// to at least nBytes of accessible memory. If bReadWrite is TRUE,
// the memory must be writeable; if bReadWrite is FALSE, the memory
// may be const.

BOOL AFXAPI AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite /* = TRUE */)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

WCHAR CString::ChNil = L'\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
int                    CString::_afxInitData[] = { -1, 0, 0, 0 };
CStringData<WCHAR> *   CString::_afxDataNil    = (CStringData<WCHAR>*)&_afxInitData;
const WCHAR *          CString::_afxPchNil     = (const WCHAR *)(((BYTE*)&_afxInitData)+sizeof(CStringData<WCHAR>));

// special function to make afxEmptyString work even during initialization
//const CString& AFXAPI AfxGetEmptyString()
//  { return *(CString*)&CString::_afxPchNil; }


//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString(const CString& stringSrc)
{
    ASSERT(stringSrc.GetData()->nRefs != 0, "CString::CString(const CString& stringSrc)");
    if (stringSrc.GetData()->nRefs >= 0)
    {
        ASSERT(stringSrc.GetData() != _afxDataNil, "CString::CString(const CString& stringSrc)");
        // robkenny: increment before copy is safer
        InterlockedIncrement(&stringSrc.GetData()->nRefs);
        m_pchData = stringSrc.m_pchData;
        m_pchDataAnsi = NULL;
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

inline DWORD Round4(DWORD x)
{
    return (x + 3) & ~3;
}

inline DWORD RoundBin(int x)
{
    return Round4( ((DWORD)x) * sizeof(WCHAR) + sizeof(CStringData<WCHAR>) );
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0, "CString::AllocBuffer");
    ASSERT(nLen <= INT_MAX-1, "CString::AllocBuffer");    // max size (enough room for 1 extra)

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        int cchAllocSize = nLen;

        if (nLen < 64)
        {
            cchAllocSize = 64;
        }
        else if (nLen < 128)
        {
            cchAllocSize = 128;
        }
        else if (nLen < MAX_PATH)
        {
            cchAllocSize = MAX_PATH;
        }
        else if (nLen < 512)
        {
            cchAllocSize = 512;
        }


        // ------------------------------------------------------------------
        // Note:  We allocate an extra byte that is not added to nAllocLength
        // this is so that whenever the code checks to determine if the buffer
        // is large enough it doesn't have to remember to add one for the 
        // null character.
        // This is how the original CString was written.
        // ------------------------------------------------------------------

        // Calculate the number of bytes necessary for the CStringData thingy.
        DWORD ccbAllocSize = RoundBin(cchAllocSize + 1);

        // Check for overflow:
        // If they pass in a negative number, throw the exception
        // If ccbAllocSize is unsigned: the only way it can be smaller
        // than cchAllocSize would be if RoundBin overflowed.
        if ((cchAllocSize < 0) || (ccbAllocSize < (DWORD)cchAllocSize))
        {
            CSTRING_THROW_EXCEPTION
        }

        CStringData<WCHAR>* pData = (CStringData<WCHAR>*) new BYTE[ ccbAllocSize ];
        if (pData)
        {
            pData->nAllocLength = cchAllocSize;
            pData->nRefs = 1;
            pData->data()[nLen] = '\0';
            pData->nDataLength = nLen;
            m_pchData = pData->data();
        }
        else
        {
            CSTRING_THROW_EXCEPTION
        }
    }
}

void CString::Release()
{
    if (GetData() != _afxDataNil)
    {
        ASSERT(GetData()->nRefs != 0, "CString::Release()");
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            FreeData(GetData());
        Init();
    }
}

void CString::Release(CStringData<WCHAR>* pData)
{
    if (pData != _afxDataNil)
    {
        ASSERT(pData->nRefs != 0, "CString::Release(CStringData<WCHAR>* pData)");
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            FreeData(pData);
    }
}

void CString::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &ChNil;
    ASSERT(GetData()->nDataLength == 0, "CString::Empty()");
    ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0, "CString::Empty()");
}

void CString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringData<WCHAR>* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(WCHAR));
    }
    ASSERT(GetData()->nRefs <= 1, "CString::CopyBeforeWrite()");
}

void CString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
    ASSERT(GetData()->nRefs <= 1, "CString::AllocBeforeWrite(int nLen)");
}

CString::~CString()
//  free any attached data
{
    if (GetData() != _afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            FreeData(GetData());
    }
    if (m_pchDataAnsi)
    {
        free(m_pchDataAnsi);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // Copy nCopyIndex to nCopyIndex+nCopyLen into dest
    // Make sure dest has nExtraLen chars left over in the dest string
    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        WCHAR * lpszDestBuffer = dest.GetBuffer(nNewLen);
        memcpy(lpszDestBuffer, m_pchData+nCopyIndex, nCopyLen*sizeof(WCHAR));
        dest.ReleaseBuffer(nCopyLen);
    }
}

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);
    ASSERT(wcstr == NULL || result <= (int)count, "CString::_mbstowcsz");
    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}


//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCWSTR lpsz)
{
    Init();
    {
        int nLen = SafeStrlen(lpsz);
        if (nLen != 0)
        {
            AllocBuffer(nLen);
            memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors
CString::CString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? strlenChars(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}
CString::CString(LPCSTR lpsz, int nCharacters)
{
    Init();
    if (nCharacters != 0)
    {
        AllocBuffer(nCharacters);
        _mbstowcsz(m_pchData, lpsz, nCharacters);
        ReleaseBuffer(nCharacters);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support

#ifdef _DEBUG
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CString& string)
{
    dc << string.m_pchData;
    return dc;
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != _afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            ASSERT(stringSrc.GetData() != _afxDataNil, "CString::operator=(const CString& stringSrc)");
            // robkenny: increment before copy is safer
            InterlockedIncrement(&stringSrc.GetData()->nRefs);
            m_pchData = stringSrc.m_pchData;
            m_pchDataAnsi = NULL;
        }
    }
    return *this;
}

const CString& CString::operator=(LPCWSTR lpsz)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator=(LPCWSTR lpsz)");
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? strlenChars(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = WCHAR, LPCWSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data,
    int nSrc2Len, LPCWSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
    }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CString AFXAPI operator+(const CString& string, LPCWSTR lpsz)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator+(const CString& string, LPCWSTR lpsz)");
    CString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CString::SafeStrlen(lpsz), lpsz);
    return s;
}

CString AFXAPI operator+(LPCWSTR lpsz, const CString& string)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator+(LPCWSTR lpsz, const CString& string)");
    CString s;
    s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringData<WCHAR>* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        ASSERT(pOldData != NULL, "CString::ConcatInPlace");
        CString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(WCHAR));
        GetData()->nDataLength += nSrcLen;
        ASSERT(GetData()->nDataLength <= GetData()->nAllocLength, "CString::ConcatInPlace");
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CString& CString::operator+=(LPCWSTR lpsz)
{
    ASSERT(lpsz == NULL || AfxIsValidString(lpsz), "CString::operator+=(LPCWSTR lpsz)");
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CString& CString::operator+=(WCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPWSTR CString::GetBuffer(int nMinBufLength)
{
    ASSERT(nMinBufLength >= 0, "CString::GetBuffer");

    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
#ifdef _DEBUG
        // give a warning in case locked string becomes unlocked
        if (GetData() != _afxDataNil && GetData()->nRefs < 0)
            TRACE0("Warning: GetBuffer on locked CString creates unlocked CString!\n");
#endif
        // we have to grow the buffer
        CStringData<WCHAR>* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(WCHAR));
        GetData()->nDataLength = nOldLen;
        CString::Release(pOldData);
    }
    ASSERT(GetData()->nRefs <= 1, "CString::GetBuffer");

    // return a pointer to the character storage for this string
    ASSERT(m_pchData != NULL, "CString::GetBuffer");
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = wcslen(m_pchData); // zero terminated

    ASSERT(nNewLength <= GetData()->nAllocLength, "CString::ReleaseBuffer");
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPWSTR CString::GetBufferSetLength(int nNewLength)
{
    ASSERT(nNewLength >= 0, "CString::GetBufferSetLength");

    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CString::FreeExtra()
{
    ASSERT(GetData()->nDataLength <= GetData()->nAllocLength, "CString::FreeExtra");
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringData<WCHAR>* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(WCHAR));
        ASSERT(m_pchData[GetData()->nDataLength] == '\0', "CString::FreeExtra");
        CString::Release(pOldData);
    }
    ASSERT(GetData() != NULL, "CString::FreeExtra");
}

LPWSTR CString::LockBuffer()
{
    LPWSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CString::UnlockBuffer()
{
    ASSERT(GetData()->nRefs == -1, "CString::UnlockBuffer");
    if (GetData() != _afxDataNil)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(WCHAR ch) const
{
    return Find(ch, 0);
}

int CString::Find(WCHAR ch, int nStart) const
{
    int nLength = GetData()->nDataLength;
    if (nStart >= nLength)
        return -1;

    // find first single character
    LPWSTR lpsz = wcschr(m_pchData + nStart, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCWSTR lpszCharSet) const
{
    return FindOneOf(lpszCharSet, 0);
}

int CString::FindOneOf(LPCWSTR lpszCharSet, int nCount) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::FindOneOf");
    LPCWSTR lpsz = wcspbrk(m_pchData + nCount, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneNotOf(const WCHAR * lpszCharSet, int nCount) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::FindOneNotOf");
    while (wcschr(lpszCharSet, m_pchData[nCount]))
    {
        nCount += 1;
    }
    if (nCount >= GetLength())
    {
        // entire string contains lpszCharSet
        return -1;
    }
    return nCount;

}

void CString::MakeUpper()
{
    CopyBeforeWrite();
    _wcsupr(m_pchData);
}

void CString::MakeLower()
{
    CopyBeforeWrite();
    _wcslwr(m_pchData);
}

void CString::MakeReverse()
{
    CopyBeforeWrite();
    _wcsrev(m_pchData);
}

void CString::SetAt(int nIndex, WCHAR ch)
{
    ASSERT(nIndex >= 0, "CString::SetAt");
    ASSERT(nIndex < GetData()->nDataLength, "CString::SetAt");

    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

///////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(WCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
    }
}

CString::CString(int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
        GetData()->nDataLength = 0;
    }
}

CString::CString(LPCWSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        ASSERT(AfxIsValidAddress(lpch, nLength, FALSE), "CString::CString(LPCWSTR lpch, int nLength)");
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(WCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, WCHAR ch)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CString AFXAPI operator+(WCHAR ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CString::Delete(int nIndex, int nCount /* = 1 */)
{
    ASSERT(nIndex >= 0, "CString::Delete negative value of nIndex");
    ASSERT(nIndex <= GetData()->nDataLength, "CString::Delete nIndex larger than buffer size");
    ASSERT(nCount >= 0, "CString::Delete negative nCount");
    ASSERT(nCount <= GetData()->nDataLength - nIndex, "CString::Delete attempting to delete beyond end of buffer");

    if (nIndex < 0)
        nIndex = 0;
    int nNewLength = GetData()->nDataLength;
    if (nCount > 0 && nIndex < nNewLength)
        
    {
        // Don't let them delete beyond the end of the string.
        if (nCount > nNewLength - nIndex)
        {
            nCount = nNewLength - nIndex;
        }

        CopyBeforeWrite();
        int nBytesToCopy = nNewLength - nIndex - nCount + 1;

        memcpy(m_pchData + nIndex,
            m_pchData + nIndex + nCount, nBytesToCopy * sizeof(WCHAR));
        GetData()->nDataLength = nNewLength - nCount;
    }

    return nNewLength;
}

int CString::Insert(int nIndex, WCHAR ch)
{
    CopyBeforeWrite();

    if (nIndex < 0)
        nIndex = 0;

    int nNewLength = GetData()->nDataLength;
    if (nIndex > nNewLength)
        nIndex = nNewLength;
    nNewLength++;

    if (GetData()->nAllocLength < nNewLength)
    {
        CStringData<WCHAR>* pOldData = GetData();
        LPWSTR pstr = m_pchData;
        AllocBuffer(nNewLength);
        memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(WCHAR));
        CString::Release(pOldData);
    }

    // move existing bytes down
    memcpy(m_pchData + nIndex + 1,
        m_pchData + nIndex, (nNewLength-nIndex)*sizeof(WCHAR));
    m_pchData[nIndex] = ch;
    GetData()->nDataLength = nNewLength;

    return nNewLength;
}

int CString::Insert(int nIndex, LPCWSTR pstr)
{
    if (nIndex < 0)
        nIndex = 0;

    int nInsertLength = SafeStrlen(pstr);
    int nNewLength = GetData()->nDataLength;
    if (nInsertLength > 0)
    {
        CopyBeforeWrite();
        if (nIndex > nNewLength)
            nIndex = nNewLength;
        nNewLength += nInsertLength;

        if (GetData()->nAllocLength < nNewLength)
        {
            CStringData<WCHAR>* pOldData = GetData();
            LPWSTR lpwsz = m_pchData;
            AllocBuffer(nNewLength);
            memcpy(m_pchData, lpwsz, (pOldData->nDataLength+1)*sizeof(WCHAR));
            CString::Release(pOldData);
        }

        // move existing bytes down
        memcpy(m_pchData + nIndex + nInsertLength,
            m_pchData + nIndex,
            (nNewLength-nIndex-nInsertLength+1)*sizeof(WCHAR));
        memcpy(m_pchData + nIndex,
            pstr, nInsertLength*sizeof(WCHAR));
        GetData()->nDataLength = nNewLength;
    }

    return nNewLength;
}

int CString::Replace(WCHAR chOld, WCHAR chNew)
{
    int nCount = 0;

    // short-circuit the nop case
    if (chOld != chNew)
    {
        // otherwise modify each character that matches in the string
        CopyBeforeWrite();
        LPWSTR psz = m_pchData;
        LPWSTR pszEnd = psz + GetData()->nDataLength;
        while (psz < pszEnd)
        {
            // replace instances of the specified character only
            if (*psz == chOld)
            {
                *psz = chNew;
                nCount++;
            }
            psz = wcsinc(psz);
        }
    }
    return nCount;
}


int CString::Replace(LPCWSTR lpszOld, LPCWSTR lpszNew)
{
    return ReplaceRoutine(lpszOld, lpszNew, wcsstr);
}

int CString::ReplaceI(LPCWSTR lpszOld, LPCWSTR lpszNew)
{
    return ReplaceRoutine(lpszOld, lpszNew, wcsistr);
}

int CString::ReplaceRoutine(LPCWSTR lpszOld, LPCWSTR lpszNew, _pfn_wcsstr tcsstr)
{
    // can't have empty or NULL lpszOld

    int nSourceLen = SafeStrlen(lpszOld);
    if (nSourceLen == 0)
        return 0;
    int nReplacementLen = SafeStrlen(lpszNew);

    // loop once to figure out the size of the result string
    int nCount = 0;
    LPWSTR lpszStart = m_pchData;
    LPWSTR lpszEnd = m_pchData + GetData()->nDataLength;
    LPWSTR lpszTarget;
    while (lpszStart < lpszEnd)
    {
        while ((lpszTarget = tcsstr(lpszStart, lpszOld)) != NULL)
        {
            nCount++;
            lpszStart = lpszTarget + nSourceLen;
        }
        lpszStart += wcslen(lpszStart) + 1;
    }

    // if any changes were made, make them
    if (nCount > 0)
    {
        CopyBeforeWrite();

        // if the buffer is too small, just
        //   allocate a new buffer (slow but sure)
        int nOldLength = GetData()->nDataLength;
        const int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
        
        if (GetData()->nAllocLength < nNewLength + 1 || GetData()->nRefs > 1)
        {
            CStringData<WCHAR>* pOldData = GetData();
            LPWSTR pstr = m_pchData;
            AllocBuffer(nNewLength);
            memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(WCHAR));
            CString::Release(pOldData);
        }
        // else, we just do it in-place
        lpszStart = m_pchData;
        lpszEnd = m_pchData + GetData()->nDataLength;

        // loop again to actually do the work
        while (lpszStart < lpszEnd)
        {
            while ( (lpszTarget = tcsstr(lpszStart, lpszOld)) != NULL)
            {
                int nBalance = nOldLength - ((int)(lpszTarget - m_pchData) + nSourceLen);
                memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
                    nBalance * sizeof(WCHAR));
                memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(WCHAR));
                lpszStart = lpszTarget + nReplacementLen;
                lpszStart[nBalance] = '\0';
                nOldLength += (nReplacementLen - nSourceLen);
            }
            lpszStart += wcslen(lpszStart) + 1;
        }
        ASSERT(m_pchData[nNewLength] == '\0', "CString::ReplaceRoutine");
        GetData()->nDataLength = nNewLength;
    }

    return nCount;
}

int CString::Remove(WCHAR chRemove)
{
    CopyBeforeWrite();

    LPWSTR pstrSource = m_pchData;
    LPWSTR pstrDest = m_pchData;
    LPWSTR pstrEnd = m_pchData + GetData()->nDataLength;

    while (pstrSource < pstrEnd)
    {
        if (*pstrSource != chRemove)
        {
            *pstrDest = *pstrSource;
            pstrDest = wcsinc(pstrDest);
        }
        pstrSource = wcsinc(pstrSource);
    }
    *pstrDest = '\0';
    int nCount = (int)(pstrSource - pstrDest);
    GetData()->nDataLength -= nCount;

    return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    CString dest;
    Mid(nFirst, nCount, dest);
    return dest;
}

CString CString::Right(int nCount) const
{
    CString dest;
    Right(nCount, dest);
    return dest;
}

CString CString::Left(int nCount) const
{
    CString dest;
    Left(nCount, dest);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCWSTR lpszCharSet) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCWSTR lpszCharSet) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcscspn(m_pchData, lpszCharSet));
}

void CString::Mid(int nFirst, CString & csMid) const
{
    Mid(nFirst, GetData()->nDataLength - nFirst, csMid);
}

void CString::Mid(int nFirst, int nCount, CString & csMid) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    ASSERT(nFirst >= 0, "CString::Mid(int nFirst, int nCount)");
    ASSERT(nFirst + nCount <= GetData()->nDataLength, "CString::Mid(int nFirst, int nCount)");

    // optimize case of returning entire string
    if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
    {
        csMid = *this;
        return;
    }

    AllocCopy(csMid, nCount, nFirst, 0);
}

void CString::Right(int nCount, CString & csRight) const
{
    if (nCount < 0)
        nCount = 0;
    if (nCount >= GetData()->nDataLength)
        return;

    AllocCopy(csRight, nCount, GetData()->nDataLength-nCount, 0);
}

void CString::Left(int nCount, CString & csLeft) const
{
    if (nCount < 0)
        nCount = 0;
    if (nCount >= GetData()->nDataLength)
        return;

    AllocCopy(csLeft, nCount, 0, 0);
}

void CString::SpanIncluding(const WCHAR * lpszCharSet, CString & csSpanInc) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcsspn(m_pchData, lpszCharSet), csSpanInc);
}

void CString::SpanExcluding(const WCHAR * lpszCharSet, CString & csSpanExc) const
{
    ASSERT(AfxIsValidString(lpszCharSet), "CString::SpanIncluding");
    return Left(wcscspn(m_pchData, lpszCharSet), csSpanExc);
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(WCHAR ch) const
{
    // find last single character
    LPCWSTR lpsz = wcsrchr(m_pchData, (_TUCHAR) ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCWSTR lpszSub) const
{
    return Find(lpszSub, 0);
}

int CString::Find(LPCWSTR lpszSub, int nStart) const
{
    ASSERT(AfxIsValidString(lpszSub), "CString::Find");

    int nLength = GetData()->nDataLength;
    if (nStart > nLength)
        return -1;

    // find first matching substring
    LPWSTR lpsz = wcsstr(m_pchData + nStart, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}


/////////////////////////////////////////////////////////////////////////////
// CString formatting

#define TCHAR_ARG   WCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    WCHAR

#ifdef _X86_
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000
#define FORCE_INT64     0x40000

void CString::FormatV(const WCHAR * lpszFormat, va_list argList)
{
    ASSERT(AfxIsValidString(lpszFormat), "CString::FormatV");

    // Determine how many characters are necessary to contain the entire formatted string.
    int nMaxLen = _vscwprintf(lpszFormat, argList);

    nMaxLen += 1; // One extra for EOS
    GetBuffer(nMaxLen);

    // Pass the actual number of chars allocated to the format routine (typically is larger)
    nMaxLen = GetAllocLength();

    StringCchVPrintfW(m_pchData, nMaxLen, lpszFormat, argList);
    ReleaseBuffer();
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(const WCHAR * lpszFormat, ...)
{
    ASSERT(AfxIsValidString(lpszFormat), "CString::Format");

    va_list argList;
    va_start(argList, lpszFormat);

    FormatV(lpszFormat, argList);

    va_end(argList);
}

void CString::FormatV(const char * lpszFormat, va_list argList)
{
    // Determine how many characters are necessary to contain the entire formatted string.
    int nMaxLen = _vscprintf(lpszFormat, argList);

    nMaxLen += 1; // One extra for EOS
    
    char * buffer = (char *)malloc(nMaxLen);
    if (buffer == NULL)
    {
        CSTRING_THROW_EXCEPTION
    }

    StringCchVPrintfA(buffer, nMaxLen, lpszFormat, argList);

    *this = buffer;

    free(buffer);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(const char * lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);

    FormatV(lpszFormat, argList);

    va_end(argList);
}

// formatting (using FormatMessage style formatting)
void AFX_CDECL CString::FormatMessage(LPCWSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPWSTR lpszTemp;

    if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPWSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        CSTRING_THROW_EXCEPTION
    }
    else
    {
        // assign lpszTemp into the resulting string and free the temporary
        *this = lpszTemp;
        LocalFree(lpszTemp);
        va_end(argList);
    }
}

void CString::TrimRight(LPCWSTR lpszTargetList)
{
    // find beginning of trailing matches
    // by starting at beginning (DBCS aware)

    CopyBeforeWrite();
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;

    while (*lpsz != '\0')
    {
        if (wcschr(lpszTargetList, *lpsz) != NULL)
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at left-most matching character
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimRight(WCHAR chTarget)
{
    // find beginning of trailing matches
    // by starting at beginning (DBCS aware)

    CopyBeforeWrite();
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;

    while (*lpsz != '\0')
    {
        if (*lpsz == chTarget)
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at left-most matching character
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimRight()
{
    // find beginning of trailing spaces by starting at beginning (DBCS aware)

    CopyBeforeWrite();
    LPWSTR lpsz = m_pchData;
    LPWSTR lpszLast = NULL;

    while (*lpsz != '\0')
    {
        if (iswspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = wcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimLeft(LPCWSTR lpszTargets)
{
    // if we're not trimming anything, we're not doing any work
    if (SafeStrlen(lpszTargets) == 0)
        return;

    CopyBeforeWrite();
    LPCWSTR lpsz = m_pchData;

    while (*lpsz != '\0')
    {
        if (wcschr(lpszTargets, *lpsz) == NULL)
            break;
        lpsz = wcsinc(lpsz);
    }

    if (lpsz != m_pchData)
    {
        // fix up data and length
        int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        GetData()->nDataLength = nDataLength;
    }
}

void CString::TrimLeft(WCHAR chTarget)
{
    // find first non-matching character

    CopyBeforeWrite();
    LPCWSTR lpsz = m_pchData;

    while (chTarget == *lpsz)
        lpsz = wcsinc(lpsz);

    if (lpsz != m_pchData)
    {
        // fix up data and length
        int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        GetData()->nDataLength = nDataLength;
    }
}

void CString::TrimLeft()
{
    // find first non-space character

    CopyBeforeWrite();
    LPCWSTR lpsz = m_pchData;

    while (iswspace(*lpsz))
        lpsz = wcsinc(lpsz);

    if (lpsz != m_pchData)
    {
        // fix up data and length
        int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        GetData()->nDataLength = nDataLength;
    }
}

void CString::SplitPath(
    CString * csDrive,
    CString * csDir,
    CString * csName,
    CString * csExt) const
{
    WCHAR * drive = NULL;
    WCHAR * dir   = NULL;
    WCHAR * name  = NULL;
    WCHAR * ext   = NULL;

    if (csDrive)
    {
        drive = csDrive->GetBuffer(_MAX_DRIVE);
    } 
    if (csDir)
    {
        dir = csDir->GetBuffer(_MAX_DIR);
    } 
    if (csName)
    {
        name = csName->GetBuffer(_MAX_FNAME);
    } 
    if (csExt)
    {
        ext = csExt->GetBuffer(_MAX_EXT);
    } 
    _wsplitpath(Get(), drive, dir, name, ext);

    if (csDrive)
    {
        csDrive->ReleaseBuffer(-1);
    } 
    if (csDir)
    {
        csDir->ReleaseBuffer(-1);
    } 
    if (csName)
    {
        csName->ReleaseBuffer(-1);
    } 
    if (csExt)
    {
        csExt->ReleaseBuffer(-1);
    } 
}

void CString::MakePath(
    const CString * csDrive,
    const CString * csDir,
    const CString * csName,
    const CString * csExt)
{
    Truncate(0);

    if (csDrive && !csDrive->IsEmpty())
    {
        ConcatInPlace(SafeStrlen(csDrive->Get()), csDrive->Get());
    }
    if (csDir && !csDir->IsEmpty())
    {
        ConcatInPlace(SafeStrlen(csDir->Get()), csDir->Get());
    }
    if (csName && !csName->IsEmpty())
    {
        // Make sure there is a \ between the two
        if (!IsEmpty() && !IsPathSep(GetLength()) && !csName->IsPathSep(0) )
        {
            ConcatInPlace(1, L"\\");
        }
        ConcatInPlace(SafeStrlen(csName->Get()), csName->Get());
    }
    if (csExt && !csExt->IsEmpty())
    {
        // Make sure the extension has a dot
        if (csExt->GetAt(0) != L'.')
        {
            ConcatInPlace(1, L".");
        }
        ConcatInPlace(SafeStrlen(csExt->Get()), csExt->Get());
    }
}

void CString::AppendPath(const WCHAR * lpszPath)
{
    int nLen = GetLength();
    BOOL bThisHasSep = (nLen > 0) ? IsPathSep(nLen - 1) : FALSE;
    BOOL bThatHasSep = ShimLib::IsPathSep(*lpszPath);
    
    if (lpszPath == NULL || *lpszPath == 0)
    {
        return;
    }
    else if (nLen == 0)
    {
        // No path seperator is necessary
    }
    else if ((nLen == 2) && (GetAt(1) == L':') && !bThatHasSep )
    {
        // We must place a path seperator between the two
        ConcatInPlace(1, L"\\");
    }
    else if (!bThisHasSep && !bThatHasSep )
    {
        // We must place a path seperator between the two
        ConcatInPlace(1, L"\\");
    }
    else if (bThisHasSep && bThatHasSep )
    {
        // Both have seperators, remove one
        do
        {
            lpszPath += 1;
        }
        while (ShimLib::IsPathSep(*lpszPath));
    }
    ConcatInPlace(SafeStrlen(lpszPath), lpszPath);
}

// Find the trailing path component
// Return index of the last path seperator or -1 if none found
int CString::FindLastPathComponent() const
{
    for (int nLen = GetLength() - 1; nLen >= 0; --nLen)
    {
        if (IsPathSep(nLen))
        {
            return nLen;
        }
    }

    return -1;
}

// Remove the trailing path component from the string
void CString::StripPath()
{
    int nLastPathComponent = FindLastPathComponent();
    if (nLastPathComponent != -1)
    {
        Truncate(nLastPathComponent);
    }
    else
    {
        Truncate(0);
    }
}

char * CString::GetAnsi() const
{
    // Since we don't know if the original (WCHAR) data has changed
    // we need to update the ansi string each time.
    if (m_pchDataAnsi)
    {
        free(m_pchDataAnsi);
        m_pchDataAnsi = NULL;
    }
    
    // Get the number of bytes necessary for the WCHAR string
    int nBytes = WideCharToMultiByte(CP_ACP, 0, m_pchData, -1, NULL, 0, NULL, NULL);
    m_pchDataAnsi = (char *) malloc(nBytes);
    if (m_pchDataAnsi)
    {
        WideCharToMultiByte(CP_ACP, 0, m_pchData, -1, m_pchDataAnsi, nBytes, NULL, NULL);
    }
    else
    {
        CSTRING_THROW_EXCEPTION
    }

    return m_pchDataAnsi; 
}

void CString::GetLastPathComponent(CString & pathComponent) const
{
    int nPath = FindLastPathComponent();
    if (nPath < 0)
    {
        pathComponent = *this;
    }
    else
    {
        Mid(nPath+1, pathComponent);
    }
}

// Get what's not the "file" portion of this path
void CString::GetNotLastPathComponent(CString & pathComponent) const
{
    int nPath = FindLastPathComponent();
    if (nPath < 1)
    {
        pathComponent.Truncate(0);
    }
    else
    {
        Left(nPath, pathComponent);
    }
}

// Get the Drive portion of this path,
// Either C: or \\server\disk format.
void CString::GetDrivePortion(CString & csDrivePortion) const
{
    const WCHAR * lpwszPath = Get();

    const WCHAR * lpwszNonDrivePortion = ShimLib::GetDrivePortion(lpwszPath);

    if (lpwszPath == lpwszNonDrivePortion)
    {
        csDrivePortion.Truncate(0);
    }
    else
    {
        Left((int)(lpwszNonDrivePortion - lpwszPath), csDrivePortion);
    }
}

// Return number of chars in the string, 0 for error
DWORD CString::GetModuleFileNameW(
  HMODULE hModule    // handle to module
)
{
    Truncate(0);

    // There is no method of determining the necessary size of the buffer before calling
    // GetModulefileName.  So we'll keep calling it until the number of chars is smaller
    // than our buffer size.  There is a limit of ~32000 chars (\\?\ type paths)

    for (DWORD cchNeeded = MAX_PATH; cchNeeded < 32000; cchNeeded *= 2)
    {
        WCHAR * lpsz = GetBuffer(cchNeeded);

        // Return value is number of chars placed into the buffer
        DWORD cchActual = ::GetModuleFileNameW(hModule, lpsz, cchNeeded);
        ReleaseBuffer(cchActual);

        // If GetModuleFileNameW returns fewer characters than our buffer, then we have the entire string.
        if (cchActual < cchNeeded)
        {
            break;
        }
        // Try again with a larger buffer...
    }


    return GetLength();
}

DWORD CString::GetSystemDirectoryW(void)
{
    Truncate(0);

    UINT cchNeeded = ::GetSystemDirectoryW(NULL, 0);
    if (cchNeeded)
    {
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(cchNeeded);

        DWORD cchActual = ::GetSystemDirectoryW(lpszPath, cchNeeded);
        if (cchActual < cchNeeded)
        {
            ReleaseBuffer(cchActual);
        }
        else
        {
            // error
            ReleaseBuffer(0);
        }
    } 

    return GetLength();
}

DWORD CString::GetSystemWindowsDirectoryW(void)
{
    Truncate(0);

    UINT cchNeeded = ::GetSystemWindowsDirectoryW(NULL, 0);
    if (cchNeeded)
    {
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(cchNeeded);

        DWORD cchActual = ::GetSystemWindowsDirectoryW(lpszPath, cchNeeded);
        if (cchActual < cchNeeded)
        {
            ReleaseBuffer(cchActual);
        }
        else
        {
            // error
            ReleaseBuffer(0);
        }
    } 

    return GetLength();
}


DWORD CString::GetWindowsDirectoryW(void)
{
    Truncate(0);

    UINT cchNeeded = ::GetWindowsDirectoryW(NULL, 0);
    if (cchNeeded)
    {
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(cchNeeded);

        DWORD cchActual = ::GetWindowsDirectoryW(lpszPath, cchNeeded);
        if (cchActual < cchNeeded)
        {
            ReleaseBuffer(cchActual);
        }
        else
        {
            // error
            ReleaseBuffer(0);
        }
    } 

    return GetLength();
}

DWORD CString::GetShortPathNameW(void)
{
    DWORD cchNeeded = ::GetShortPathNameW(Get(), NULL, 0);
    if (cchNeeded)
    {
        CString csCopy;
        
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = csCopy.GetBuffer(cchNeeded);

        DWORD cchActual = ::GetShortPathNameW(Get(), lpszPath, cchNeeded);
        if (cchActual > 0 && cchActual < cchNeeded)
        {
            csCopy.ReleaseBuffer(cchActual);
            *this = csCopy;

            return GetLength();
        }
        else
        {
            // error
            csCopy.ReleaseBuffer(0);
        }
    } 

    return 0;
}

DWORD CString::GetLongPathNameW(void)
{
    DWORD cchNeeded = ::GetLongPathNameW(Get(), NULL, 0);
    if (cchNeeded)
    {
        CString csCopy;
        
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = csCopy.GetBuffer(cchNeeded);

        DWORD cchActual = ::GetLongPathNameW(Get(), lpszPath, cchNeeded);
        if (cchActual > 0 && cchActual < cchNeeded)
        {
            csCopy.ReleaseBuffer(cchActual);
            *this = csCopy;

            return GetLength();
        }
        else
        {
            // error
            csCopy.ReleaseBuffer(0);
        }
    } 

    return 0;
}

DWORD CString::GetFullPathNameW(void)
{
    DWORD cchNeeded = ::GetFullPathNameW(Get(), 0, NULL, NULL);
    if (cchNeeded)
    {
        CString csCopy;
        
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = csCopy.GetBuffer(cchNeeded);

        DWORD cchActual = ::GetFullPathNameW(Get(), cchNeeded, lpszPath, NULL);
        if (cchActual > 0 && cchActual < cchNeeded)
        {
            csCopy.ReleaseBuffer(cchActual);
            *this = csCopy;

            return GetLength();
        }
        else
        {
            // error
            csCopy.ReleaseBuffer(0);
        }
    } 

    return 0;
}

DWORD CString::GetTempPathW(void)
{
    Truncate(0);

    DWORD cchNeeded = ::GetTempPathW(0, NULL);
    if (cchNeeded)
    {
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(cchNeeded);

        DWORD cchActual = ::GetTempPathW(cchNeeded, lpszPath);
        if (cchActual < cchNeeded)
        {
            ReleaseBuffer(cchActual);
        }
        else
        {
            // error
            ReleaseBuffer(0);
        }
    } 

    return GetLength();
}

DWORD CString::GetTempFileNameW(
  LPCWSTR lpPathName,      // directory name
  LPCWSTR lpPrefixString,  // file name prefix
  UINT uUnique            // integer
)
{
    // There is no method of determining the necessary size of the buffer before calling GetTempFileNameW
    // All you can do is to make sure you buffer has enough space for lpPathName plus an 8.3 filename.

    DWORD cchNeeded  = SafeStrlen(lpPathName);
    // extra for       \   8   .   3   null
    cchNeeded       += 1 + 8 + 1 + 3 + 1;

    WCHAR * lpsz = GetBuffer(cchNeeded);
    (void) ::GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpsz);

    ReleaseBuffer(-1);

    return GetLength();
}


DWORD CString::GetCurrentDirectoryW(void)
{
    Truncate(0);

    DWORD cchNeeded = ::GetCurrentDirectoryW(0, NULL);
    if (cchNeeded)
    {
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(cchNeeded);

        DWORD cchActual = ::GetCurrentDirectoryW(cchNeeded, lpszPath);
        if (cchActual < cchNeeded)
        {
            ReleaseBuffer(cchActual);
        }
        else
        {
            // error
            ReleaseBuffer(0);
        }
    } 

    return GetLength();
}

DWORD CString::GetLocaleInfoW(LCID Locale, LCTYPE LCType)
{
    Truncate(0);

    DWORD cchNeeded = ::GetLocaleInfoW(Locale, LCType, NULL, 0);
    if (cchNeeded)
    {
        cchNeeded += 1;   // One for the NULL

        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = GetBuffer(cchNeeded);

        DWORD cchActual = ::GetLocaleInfoW(Locale, LCType, lpszPath, cchNeeded);
        if (cchActual < cchNeeded)
        {
            ReleaseBuffer(cchActual);
        }
        else
        {
            // error
            ReleaseBuffer(0);
        }
    } 

    return GetLength();
}

DWORD CString::ExpandEnvironmentStringsW( )
{
    // ExpandEnvironmentStrings returns a count that includes the null char.

    DWORD cchNeeded = ::ExpandEnvironmentStringsW(Get(), NULL, 0);
    if (cchNeeded)
    {
        CString csCopy;
        
        // Get a pointer to the actual lpsz data
        WCHAR * lpszPath = csCopy.GetBuffer(cchNeeded);

        DWORD cchActual = ::ExpandEnvironmentStringsW(Get(), lpszPath, cchNeeded);

        if (cchActual > 0 && cchActual <= cchNeeded)
        {
            csCopy.ReleaseBuffer(cchActual-1);
            *this = csCopy;

            return GetLength();
        }
        else
        {
            // error
            csCopy.ReleaseBuffer(0);
        }
    } 

    return 0;
}


// delete all characters to the right of nIndex
void CString::Truncate(int nIndex)
{
    ASSERT(nIndex >= 0, "CString::Truncate");

    CopyBeforeWrite();

    if (nIndex < GetLength())
    {
        SetAt(nIndex, L'\0');
        GetData()->nDataLength = nIndex;
    }
}

BOOL CString::PatternMatch(const WCHAR * lpszPattern) const
{
    return PatternMatchW(lpszPattern, Get());
}




/*++

    Read a *string* registry value.
   
    If the type is not REG_SZ or REG_EXPAND_SZ then this routine returns STATUS_INVALID_PARAMETER.

    REG_EXPAND_SZ type is automatically expanded.
    
    This API does not use ADVAPI, so it is safe to use in DllMain.

--*/
DWORD CString::NtReqQueryValueExW(
    const WCHAR * lpszKey,
    const WCHAR * lpszValue)
{
    HANDLE KeyHandle;

    // Convert the key name into a UNICODE_STRING
    UNICODE_STRING      strKeyName = {0};
    RtlInitUnicodeString(&strKeyName, lpszKey);

    OBJECT_ATTRIBUTES ObjectAttributes;
    InitializeObjectAttributes(&ObjectAttributes,
                               &strKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NTSTATUS status = NtOpenKey(&KeyHandle,
                                KEY_QUERY_VALUE,
                                &ObjectAttributes);
    if (status == STATUS_SUCCESS)
    {
        // Make a UNICODE_STRING of the key value
        UNICODE_STRING      strValueName = {0};
        RtlInitUnicodeString(&strValueName, lpszValue ? lpszValue : L"");


        // Determine the size of the key data
        DWORD dwValueLength;
        status = NtQueryValueKey(KeyHandle,
                                 &strValueName,
                                 KeyValueFullInformation,
                                 NULL,
                                 0,
                                 &dwValueLength);
        if (status == STATUS_BUFFER_TOO_SMALL)
        {
            PKEY_VALUE_FULL_INFORMATION pKeyValueInfo = 
                (PKEY_VALUE_FULL_INFORMATION) RtlAllocateHeap(RtlProcessHeap(),
                                                              HEAP_ZERO_MEMORY,
                                                              dwValueLength);
            if (pKeyValueInfo)
            {

                status = NtQueryValueKey(KeyHandle,
                                         &strValueName,
                                         KeyValueFullInformation,
                                         pKeyValueInfo,
                                         dwValueLength,
                                         &dwValueLength);
                if (status == STATUS_SUCCESS)
                {
                    // Save the registry type
                    if (pKeyValueInfo->Type == REG_EXPAND_SZ ||
                        pKeyValueInfo->Type == REG_SZ)
                    {
                        CSTRING_TRY
                        {
                            DWORD cchValueSize = pKeyValueInfo->DataLength / sizeof(WCHAR);

                            // Grab an extra character in case the reg value doesn't have EOS
                            // We are being extra cautious
                            WCHAR * lpszBuffer = GetBuffer(cchValueSize + 1);

                            RtlMoveMemory(lpszBuffer, ((PBYTE) pKeyValueInfo) + pKeyValueInfo->DataOffset, pKeyValueInfo->DataLength);

                            // cchValueSize might count the EOS character,
                            // (ReleaseBuffer expects the string length)
                            if (cchValueSize > 0 && lpszBuffer[cchValueSize-1] == 0)
                            {
                                cchValueSize -= 1;

                                // cchValueSize now contains the string length.
                            }
                            ReleaseBuffer(cchValueSize);

                            // Check to see if we need to convert REG_EXPAND_SZ to REG_SZ
                            if (pKeyValueInfo->Type == REG_EXPAND_SZ)
                            {
                                ExpandEnvironmentStringsW();
                            }
                        }
                        CSTRING_CATCH
                        {
                            // We catch these CString exceptions so we can free memory and close the handles.
                            status = STATUS_NO_MEMORY;
                        }
                    }
                    else
                    {
                        // Registry entry is not a string type
                        status = STATUS_INVALID_PARAMETER;
                    }
                }

                RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);
            }
        }

        NtClose(KeyHandle);
    }

    return status;
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\internal.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    Internal.cpp

 Abstract:

    Common functions that use internals.

 Notes:

    None

 History:

    01/10/2000  linstev     Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include "StrSafe.h"


namespace ShimLib
{


/*++

 Function Description:
    
    Determine the device type from an open handle.

 Arguments:

    IN hFile - Handle to an open file

 Return Value: 
    
    Same as GetDriveType

 History:

    01/10/2000 linstev  Updated

--*/

// These are in winbase, which we don't want to include
#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6

UINT  
GetDriveTypeFromHandle(HANDLE hFile)
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;

    Status = NtQueryVolumeInformationFile(
        hFile,
        &IoStatusBlock,
        &DeviceInformation,
        sizeof(DeviceInformation),
        FileFsDeviceInformation);

    UINT uRet = DRIVE_UNKNOWN;

    if (NT_SUCCESS(Status))
    {
        switch (DeviceInformation.DeviceType) 
        {
        case FILE_DEVICE_NETWORK:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
            uRet = DRIVE_REMOTE;
            break;

        case FILE_DEVICE_CD_ROM:
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
            uRet = DRIVE_CDROM;
            break;

        case FILE_DEVICE_VIRTUAL_DISK:
            uRet = DRIVE_RAMDISK;
            break;

        case FILE_DEVICE_DISK:
        case FILE_DEVICE_DISK_FILE_SYSTEM:
            if (DeviceInformation.Characteristics & FILE_REMOVABLE_MEDIA) 
            {
                uRet = DRIVE_REMOVABLE;
            }
            else 
            {
                uRet = DRIVE_FIXED;
            }
            break;

        default:
            uRet = DRIVE_UNKNOWN;
            break;
        }
    }

    return uRet;
}

/*++

 Function Description:
    
    Cause a break

 Arguments:

    None

 Return Value: 
    
    None

 History:

    10/25/2000 linstev  Added this comment

--*/

void APPBreakPoint(void)
{
    DbgBreakPoint();
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\parsedde.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    ParseDde.cpp

 Abstract:
    Useful routines for parsing DDE commands.

 History:

    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
    03/12/2002  robkenny    Security review.
    

--*/

//
// This code was copied from:
// \\index1\src\shell\shell32\unicpp\dde.cpp
// with minimal processing.
//

#include "Windows.h"
#include "StrSafe.h"
#include "ParseDDE.h"
#include <ShlObj.h>


namespace ShimLib
{
//--------------------------------------------------------------------------
// Returns a pointer to the first non-whitespace character in a string.
LPSTR SkipWhite(LPSTR lpsz)
    {
    /* prevent sign extension in case of DBCS */
    while (*lpsz && (UCHAR)*lpsz <= ' ')
        lpsz++;

    return(lpsz);
    }

LPSTR GetCommandName(LPSTR lpCmd, const char * lpsCommands[], UINT *lpW)
    {
    CHAR chT;
    UINT iCmd = 0;
    LPSTR lpT;

    /* Eat any white space. */
    lpCmd = SkipWhite(lpCmd);
    lpT = lpCmd;

    /* Find the end of the token. */
    while (IsCharAlpha(*lpCmd))
        lpCmd = CharNextA(lpCmd);

    /* Temporarily NULL terminate it. */
    chT = *lpCmd;
    *lpCmd = 0;

    /* Look up the token in a list of commands. */
    *lpW = (UINT)-1;
    while (*lpsCommands)
        {
        const char * knownCommand = *lpsCommands;
        if (!_strcmpi(knownCommand, lpT))
            {
            *lpW = iCmd;
            break;
            } 
        iCmd++;
        ++lpsCommands;
        }

    *lpCmd = chT;

    return(lpCmd);
    }
//--------------------------------------------------------------------------
// Reads a parameter out of a string removing leading and trailing whitespace.
// Terminated by , or ).  ] [ and ( are not allowed.  Exception: quoted
// strings are treated as a whole parameter and may contain []() and ,.
// Places the offset of the first character of the parameter into some place
// and NULL terminates the parameter.
// If fIncludeQuotes is false it is assumed that quoted strings will contain single
// commands (the quotes will be removed and anything following the quotes will
// be ignored until the next comma). If fIncludeQuotes is TRUE, the contents of
// the quoted string will be ignored as before but the quotes won't be
// removed and anything following the quotes will remain.
LPSTR GetOneParameter(LPCSTR lpCmdStart, LPSTR lpCmd,
    UINT *lpW, BOOL fIncludeQuotes)
    {
    LPSTR     lpT;

    switch (*lpCmd)
        {
        case ',':
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
            *lpCmd++ = 0;                /* comma: becomes a NULL string */
            break;

        case '"':
            if (fIncludeQuotes)
            {
                //TraceMsg(TF_DDE, "GetOneParameter: Keeping quotes.");

                // quoted string... don't trim off "
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                ++lpCmd;
                while (*lpCmd && *lpCmd != '"')
                    lpCmd = CharNextA(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                lpT = lpCmd;
                ++lpCmd;

                goto skiptocomma;
            }
            else
            {
                // quoted string... trim off "
                ++lpCmd;
                *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
                while (*lpCmd && *lpCmd != '"')
                    lpCmd = CharNextA(lpCmd);
                if (!*lpCmd)
                    return(NULL);
                *lpCmd++ = 0;
                lpCmd = SkipWhite(lpCmd);

                // If there's a comma next then skip over it, else just go on as
                // normal.
                if (*lpCmd == ',')
                    lpCmd++;
            }
            break;

        case ')':
            return(lpCmd);                /* we ought not to hit this */

        case '(':
        case '[':
        case ']':
            return(NULL);                 /* these are illegal */

        default:
            lpT = lpCmd;
            *lpW = (UINT) (lpCmd - lpCmdStart);  // compute offset
skiptocomma:
            while (*lpCmd && *lpCmd != ',' && *lpCmd != ')')
            {
                /* Check for illegal characters. */
                if (*lpCmd == ']' || *lpCmd == '[' || *lpCmd == '(' )
                    return(NULL);

                /* Remove trailing whitespace */
                /* prevent sign extension */
                if (*lpCmd > ' ')
                    lpT = lpCmd;

                lpCmd = CharNextA(lpCmd);
            }

            /* Eat any trailing comma. */
            if (*lpCmd == ',')
                lpCmd++;

            /* NULL terminator after last nonblank character -- may write over
             * terminating ')' but the caller checks for that because this is
             * a hack.
             */

#ifdef UNICODE
            lpT[1] = 0;
#else
            lpT[IsDBCSLeadByte(*lpT) ? 2 : 1] = 0;
#endif
            break;
        }

    // Return next unused character.
    return(lpCmd);
    }

// Extracts an alphabetic string and looks it up in a list of possible
// commands, returning a pointer to the character after the command and
// sticking the command index somewhere.
UINT* GetDDECommands(LPSTR lpCmd, const char * lpsCommands[], BOOL fLFN)
{
  UINT cParm, cCmd = 0;
  UINT *lpW;
  UINT *lpRet;
  LPCSTR lpCmdStart = lpCmd;
  BOOL fIncludeQuotes = FALSE;

  if (lpCmd == NULL)
      return NULL;

  lpRet = lpW = (UINT*)GlobalAlloc(GPTR, 512L);
  if (!lpRet)
      return 0;

  while (*lpCmd)
    {
      /* Skip leading whitespace. */
      lpCmd = SkipWhite(lpCmd);

      /* Are we at a NULL? */
      if (!*lpCmd)
        {
          /* Did we find any commands yet? */
          if (cCmd)
              goto GDEExit;
          else
              goto GDEErrExit;
        }

      /* Each command should be inside square brackets. */
      if (*lpCmd != '[')
          goto GDEErrExit;
      lpCmd++;

      /* Get the command name. */
      lpCmd = GetCommandName(lpCmd, lpsCommands, lpW);
      if (*lpW == (UINT)-1)
          goto GDEErrExit;

      // We need to leave quotes in for the first param of an AddItem.
      if (fLFN && *lpW == 2)
      {
          //TraceMsg(TF_DDE, "GetDDECommands: Potential LFN AddItem command...");
          fIncludeQuotes = TRUE;
      }

      lpW++;

      /* Start with zero parms. */
      cParm = 0;
      lpCmd = SkipWhite(lpCmd);

      /* Check for opening '(' */
      if (*lpCmd == '(')
        {
          lpCmd++;

          /* Skip white space and then find some parameters (may be none). */
          lpCmd = SkipWhite(lpCmd);

          while (*lpCmd != ')')
            {
              if (!*lpCmd)
                  goto GDEErrExit;

              // Only the first param of the AddItem command needs to
              // handle quotes from LFN guys.
              if (fIncludeQuotes && (cParm != 0))
                  fIncludeQuotes = FALSE;

              /* Get the parameter. */
              lpCmd = GetOneParameter(lpCmdStart, lpCmd, lpW + (++cParm), fIncludeQuotes);
              if (!lpCmd)
                  goto GDEErrExit;

              /* HACK: Did GOP replace a ')' with a NULL? */
              if (!*lpCmd)
                  break;

              /* Find the next one or ')' */
              lpCmd = SkipWhite(lpCmd);
            }

          // Skip closing bracket.
          lpCmd++;

          /* Skip the terminating stuff. */
          lpCmd = SkipWhite(lpCmd);
        }

      /* Set the count of parameters and then skip the parameters. */
      *lpW++ = cParm;
      lpW += cParm;

      /* We found one more command. */
      cCmd++;

      /* Commands must be in square brackets. */
      if (*lpCmd != ']')
          goto GDEErrExit;
      lpCmd++;
    }

GDEExit:
  /* Terminate the command list with -1. */
  *lpW = (UINT)-1;

  return lpRet;

GDEErrExit:
  GlobalFree(lpW);
  return(0);
}

BOOL SHTestTokenMembership (HANDLE hToken, ULONG ulRID)

{
    static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

    BOOL    fResult;
    PSID    pSIDLocalGroup;

    fResult = FALSE;
    if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 ulRID,
                                 0, 0, 0, 0, 0, 0,
                                 &pSIDLocalGroup) != FALSE)
    {
        if (CheckTokenMembership(hToken, pSIDLocalGroup, &fResult) == FALSE)
        {
            //TraceMsg(TF_WARNING, "shell32: SHTestTokenMembership call to advapi32!CheckTokenMembership failed with error %d", GetLastError());
            fResult = FALSE;
        }
        (void*)FreeSid(pSIDLocalGroup);
    }
    return(fResult);
}

BOOL IsUserAnAdmin()
{
    return(SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS));
}


// Map the group name to a proper path taking care of the startup group and
// app hacks on the way.
void GetGroupPath(LPCSTR pszName, CString & csPath, DWORD /*dwFlags*/, INT iCommonGroup)
{
    BOOL   bCommonGroup;

    if (IsUserAnAdmin()) {
        if (iCommonGroup == 0) {
            bCommonGroup = FALSE;

        } else if (iCommonGroup == 1) {
            bCommonGroup = TRUE;

        } else {
            //
            // Administrators get common groups created by default
            // when the setup application doesn't specificly state
            // what kind of group to create.  This feature can be
            // turned off in the cabinet state flags.
            //
            //CABINETSTATE cs;
            //ReadCabinetState(&cs, sizeof(cs));
            //if (cs.fAdminsCreateCommonGroups) {
            //    bFindPersonalGroup = TRUE;
            //    bCommonGroup = FALSE;   // This might get turned on later
            //                            // if find is unsuccessful
            //} else {
            //    bCommonGroup = FALSE;
            //}

            bCommonGroup = TRUE;
        }
    } else {
        //
        // Regular users can't create common group items.
        //
        bCommonGroup = FALSE;
    }

    // Build a path to the directory
    if (bCommonGroup) {
        SHGetSpecialFolderPathW(csPath, CSIDL_COMMON_PROGRAMS, NULL);
    } else {
        SHGetSpecialFolderPathW(csPath, CSIDL_PROGRAMS, NULL);
    }

    CString csName(pszName);
    csPath.AppendPath(csName);
}


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\cstringapi.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    CStringPI.cpp

 Abstract:

    Win32 API wrappers for CString

 Created:

    02/27/2001  robkenny    Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "ShimLib.h"
#include "Shlobj.h"
#include "StrSafe.h"


namespace ShimLib
{

/*====================================================================================*/
/*++

    Read a registry value into this CString.
    REG_EXPAND_SZ is automatically expanded and the type is changed to REG_SZ
   
    If the type is not REG_SZ or REG_EXPAND_SZ then csValue is unmodified
    and *lpType returns the value of the key.
    
--*/

LONG RegQueryValueExW(
        CString & csValue,
        HKEY hKeyRoot,
        const WCHAR * lpszKey,
        const WCHAR * lpszValue)
{
    HKEY hKey;

    LONG success = RegOpenKeyExW(hKeyRoot, lpszKey, 0, KEY_READ, &hKey);
    if (success == ERROR_SUCCESS)
    {    
        DWORD ccbValueSize = 0;
        DWORD dwType;
        success = ::RegQueryValueExW(hKey, lpszValue, 0, &dwType, NULL, &ccbValueSize);
        if (success == ERROR_SUCCESS)
        {
            if (dwType == REG_SZ || dwType == REG_EXPAND_SZ)
            {
                // MSDN says: Buffer might not be null terminated, so be very careful
                //
                // Of course, RegQueryValueEx does have a hack that takes care of the EOS,
                // but only if the buffer is large enough, which of course it never is
                // when you query for the size of the buffer!
                //
                // So, the moral of the story is don't trust RegQueryValueEx
                // to properly terminate the string.

                // cchBuffer is the number of characters, rounded up for paranoia
                // Can we ever get an odd number of bytes for a REG_SZ?
                DWORD cchBuffer = (ccbValueSize + 1) / sizeof(WCHAR);

                WCHAR * lpszBuffer = NULL;
                CSTRING_TRY
                {
                    // Grab an extra character in case the reg value doesn't have EOS
                    // We are being extra cautious
                    lpszBuffer = csValue.GetBuffer(cchBuffer + 1);

                    // Recalculate ccbValueSize based on the number of chars we just allocated.
                    // Notice that this size is 1 WCHAR smaller than we just asked for, this
                    // is so we'll always have room for 1 more character after the next call
                    // to RegQueryValueExW
                    ccbValueSize = cchBuffer * sizeof(WCHAR);
                }
                CSTRING_CATCH
                {
                    // Close the registry key and pass the exception onto the caller.
                    ::RegCloseKey(hKey);

                    CSTRING_THROW_EXCEPTION
                }

                success = ::RegQueryValueExW(hKey, lpszValue, 0, &dwType, (BYTE*)lpszBuffer, &ccbValueSize);
                if (success == ERROR_SUCCESS)
                {
                    // Make sure the registy value is still of the proper type
                    // It could have been modified by another process or thread....
                    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ)
                    {
                        // Convert the data byte size into number of chars;
                        // if ccbValueSize is odd we'll ignore the last byte.
                        DWORD cchValueSize = ccbValueSize / sizeof(WCHAR);

                        // cchValueSize might count the EOS character,
                        // (ReleaseBuffer expects the string length)
                        if (cchValueSize > 0 && lpszBuffer[cchValueSize-1] == 0)
                        {
                            cchValueSize -= 1;

                            // cchValueSize now contains the string length.
                        }

                        // ReleaseBuffer ensures the string is properly terminated.
                        csValue.ReleaseBuffer(cchValueSize);

                        if (dwType == REG_EXPAND_SZ)
                        {
                            CSTRING_TRY
                            {
                                csValue.ExpandEnvironmentStringsW();
                            }
                            CSTRING_CATCH
                            {
                                // Error expanding the environment string
                                success = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                    }
                }
                if (success != ERROR_SUCCESS)
                {
                    csValue.ReleaseBuffer(0);
                }
            }
            else
            {
                // Key is of the wrong type, return an error
                success = ERROR_INVALID_PARAMETER;
            }
        }

        ::RegCloseKey(hKey);
    }

    if (success != ERROR_SUCCESS)
    {
        csValue.Truncate(0);
    }
    
    return success;
}



/*====================================================================================*/


BOOL SHGetSpecialFolderPathW(
    CString & csFolder,
    int nFolder,
    HWND hwndOwner
)
{
    // Force the size to MAX_PATH because there is no way to determine necessary buffer size.

    WCHAR * lpsz = csFolder.GetBuffer(MAX_PATH);

    BOOL bSuccess = ::SHGetSpecialFolderPathW(hwndOwner, lpsz, nFolder, FALSE);
    csFolder.ReleaseBuffer(-1);  // Don't know the length of the resulting string

    return bSuccess;
}

/*====================================================================================*/
CStringToken::CStringToken(const CString & csToken, const CString & csDelimit)
{
    m_nPos          = 0;
    m_csToken       = csToken;
    m_csDelimit     = csDelimit;
}

/*++

    Grab the next token
--*/

BOOL CStringToken::GetToken(CString & csNextToken, int & nPos) const
{
    // Already reached the end of the string
    if (nPos > m_csToken.GetLength())
    {
        csNextToken.Truncate(0);
        return FALSE;
    }

    int nNextToken;

    // Skip past all the leading seperators
    nPos = m_csToken.FindOneNotOf(m_csDelimit, nPos);
    if (nPos < 0)
    {
        // Nothing but seperators
        csNextToken.Truncate(0);
        nPos = m_csToken.GetLength() + 1;
        return FALSE;
    }

    // Find the next seperator
    nNextToken = m_csToken.FindOneOf(m_csDelimit, nPos);
    if (nNextToken < 0)
    {
        // Did not find a seperator, return remaining string
        m_csToken.Mid(nPos, csNextToken);
        nPos = m_csToken.GetLength() + 1;
        return TRUE;
    }

    // Found a seperator, return the string
    m_csToken.Mid(nPos, nNextToken - nPos, csNextToken);
    nPos = nNextToken;

    return TRUE;
}

/*++

    Grab the next token

--*/

BOOL CStringToken::GetToken(CString & csNextToken)
{
    return GetToken(csNextToken, m_nPos);
}

/*++

    Count the number of remaining tokens.

--*/

int CStringToken::GetCount() const
{
    int nTokenCount = 0;
    int nNextToken = m_nPos;

    CString csTok;
    
    while (GetToken(csTok, nNextToken))
    {
        nTokenCount += 1;
    }

    return nTokenCount;
}

/*====================================================================================*/
/*====================================================================================*/

/*++

    A simple class to assist in command line parsing

--*/

CStringParser::CStringParser(const WCHAR * lpszCl, const WCHAR * lpszSeperators)
{
    m_ncsArgList    = 0;
    m_csArgList     = NULL;

    if (!lpszCl || !*lpszCl)
    {
        return; // no command line == no tokens
    }

    CString csCl(lpszCl);
    CString csSeperator(lpszSeperators);

    if (csSeperator.Find(L' ', 0) >= 0)
    {
        // Special processing for blank seperated cl
        SplitWhite(csCl);
    }
    else
    {
        SplitSeperator(csCl, csSeperator); 
    }
}

CStringParser::~CStringParser()
{
    if (m_csArgList)
    {
        delete [] m_csArgList;
    }
}

/*++

    Split up the command line based on the seperators

--*/

void CStringParser::SplitSeperator(const CString & csCl, const CString & csSeperator)
{
    CStringToken    csParser(csCl, csSeperator); 
    CString         csTok;

    m_ncsArgList = csParser.GetCount();
    m_csArgList = new CString[m_ncsArgList];
    if (!m_csArgList)
    {
        CSTRING_THROW_EXCEPTION
    }
    
    // Break the command line into seperate tokens
    for (int i = 0; i < m_ncsArgList; ++i)
    {
        csParser.GetToken(m_csArgList[i]);
    }
}

/*++

    Split up the command line based on whitespace,
    this works exactly like the CMD's command line.

--*/

void CStringParser::SplitWhite(const CString & csCl)
{
    LPWSTR * argv = _CommandLineToArgvW(csCl, &m_ncsArgList);
    if (!argv)
    {
        CSTRING_THROW_EXCEPTION
    }

    m_csArgList = new CString[m_ncsArgList];
    if (!m_csArgList)
    {
        CSTRING_THROW_EXCEPTION
    }

    for (int i = 0; i < m_ncsArgList; ++i)
    {
        m_csArgList[i] = argv[i];
    }
    LocalFree(argv);
}

/*====================================================================================*/
/*====================================================================================*/


};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\hookcallback.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    HookCallback.cpp

 Abstract:

    Hooking mechanism for callbacks.

 Notes:

    Use the HookCallback mechanism to hook any type of callback
    function, like an application-defined WindowProc. HookCallback
    will register your hook and insert an extra parameter -- pfnOld.
    This will allow you to call the actual callback from your stub
    function. pfnOld is inserted as the first parameter. Do not pass
    pfnOld to the original callback, use the real prototype for the
    callback.

    See the shim DisableW2KOwnerDrawButtonStates for example usage.

 History:

    02/16/2000  markder     Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include "ShimHook.h"


namespace ShimLib
{

#pragma pack(push)
#pragma pack(1)
typedef struct _JUMPTABLEENTRY
{
    BYTE                PopEax;
    BYTE                PushDword;
    PVOID               pfnOld;
    BYTE                PushEax;
    BYTE                Jmp[2];
    PVOID               ppfnNew;
    PVOID               pfnNew;
    _JUMPTABLEENTRY*    pNextEntry;
} JUMPTABLEENTRY, *PJUMPTABLEENTRY;
#pragma pack(pop)


PJUMPTABLEENTRY g_pCallbackJumpTable = NULL;

// defines from user.h to tell if a windowproc is actually a handle to a CPD
#define HMINDEXBITS             0x0000FFFF      // bits where index is stored
#define CPDHANDLE_HI            ((ULONG_PTR)~HMINDEXBITS)
#define ISCPDTAG(x)             (((ULONG_PTR)(x) & CPDHANDLE_HI) == CPDHANDLE_HI)

/*++

 Function Description:
    
    Registers a callback hook.

 Arguments:

    IN pfnOld   -  The original callback function address.
    IN pfnNew   -  The new (stub) callback function address.

 Return Value: 
    
    The address to be passed in as the callback. If you wanted
    to hook the progress routine that is called when you use
    the MoveFileWithProgress API, simply hook the API through the
    normal shim mechanism and then use this function to obtain a new
    address to pass in as lpProgressRoutine.


 Notes:
    This was reviewed for security and was noted that the linked list is not
    entirely safe when called from multiple threads.  However, the worst case is
    that we allocate an extra chunk of memory with a duplicate jump, or that one
    JUMPTABLEENTRY is not added to the list.  The list's integrity is always maintained.
    Since this list is never deallocated, nor can it be, we don't have a problem with
    memory leaks.

 History:

    11/01/1999 markder  Created

--*/

PVOID 
HookCallback(PVOID pfnOld, PVOID pfnNew)
{
    PJUMPTABLEENTRY pJT = g_pCallbackJumpTable;

    if (pfnOld == NULL)
    {
        // NULL has been passed in. Ignore this call.
        pJT = NULL;
        goto eh;
    }

    if (ISCPDTAG(pfnOld) || IsBadCodePtr((FARPROC)pfnOld)) 
    {

        // This isn't a normal procedure call, and must be from a system DLL.
        // We should ignore it.

        pJT = (PJUMPTABLEENTRY)pfnOld;
        goto eh;
    }

    // Check to see if we have already made an entry for this pfnOld. If so,
    // just pass back the existing jump table.
    while (pJT != NULL)
    {
        if (pJT->pfnOld == pfnOld)
            break;

        pJT = pJT->pNextEntry;
    }

    if (pJT == NULL)
    {
        // Note that this table is allocated and never freed because
        // the entries will be used right up until the very last message
        // is sent to a window. There is no opportunity for cleanup.
        pJT = (PJUMPTABLEENTRY) HeapAlloc(GetProcessHeap(),
                                          HEAP_GENERATE_EXCEPTIONS,
                                          sizeof(JUMPTABLEENTRY) );

        // Fill in assembler. Each hard-coded hex value is the i386
        // opcode for the particular instruction.
        pJT->PopEax     = 0x58;     // Pop off return address
        pJT->PushDword  = 0x68;     // Push pfnOld as extra parameter
        pJT->pfnOld     = pfnOld;   
        pJT->PushEax    = 0x50;     // Push return address back on
        pJT->Jmp[0]     = 0xFF;     // Jump to pfnNew
        pJT->Jmp[1]     = 0x25;
        pJT->ppfnNew    = &(pJT->pfnNew);

        // Fill in data members
        pJT->pfnNew     = pfnNew;
        pJT->pNextEntry = g_pCallbackJumpTable;

        // Add to top of list
        g_pCallbackJumpTable = pJT;
    }

eh:
    DPF("ShimLib", eDbgLevelInfo, "CallbackHook( pfnOld = 0x%08X, pfnNew = 0x%08X ) returned 0x%08X\n", pfnOld, pfnNew, pJT);

    return pJT;
}




};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\utils.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    Utils.cpp

 Abstract:

    Common functions for all modules

 Notes:

    None

 History:

    11/03/2001  clupu     Created

--*/

#include "ShimHook.h"
#include "StrSafe.h"

namespace ShimLib
{

void
DumpUnloadOrder(
    PPEB Peb
    )
{
    PLIST_ENTRY LdrNext;
    
    if (GetDebugLevel() > eDbgLevelInfo) {
        return;
    }
    
    //
    // Dump the order the shims will unload
    //
    LdrNext = Peb->Ldr->InInitializationOrderModuleList.Blink;

    DPF("ShimLib", eDbgLevelInfo, "\n[SeiDumpUnloadOrder] Unload order:\n");
    
    while (LdrNext != &Peb->Ldr->InInitializationOrderModuleList) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);
        
        LdrNext = LdrNext->Blink;

        //
        // Dump the entry to be called
        //
        DPF("ShimLib",
            eDbgLevelInfo,
            "[SeiDumpUnloadOrder] \"%40S\" 0x%x\n",
            LdrEntry->BaseDllName.Buffer,
            LdrEntry->DllBase);
    }
}

/*++

 Function Description:
    
    Call this function if you want to push the specified DLL to the
    end of the list of modules to be unloaded.
    
    NOTE: Make sure that the module that will be pushed at the end
          will not call any APIs that reside in other modules during
          its DLL_PROCESS_DETACH callout.

 Arguments:

    IN hMod          - handle to the module to push.
                       Specify NULL to push the calling DLL.

 Return Value: 
    
    TRUE if successful, FALSE otherwise.

 History:

    11/01/2001 clupu Created

--*/
BOOL
MakeShimUnloadLast(
    HMODULE hMod
    )
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    BOOL        bRet = FALSE;
    
    if (hMod == NULL) {
        hMod = g_hinstDll;
    }
    
    //
    // Dump the unload order if SHIM_DEBUG_LEVEL is at least eDbgLevelInfo
    //
    DumpUnloadOrder(Peb);

    LdrHead = &Peb->Ldr->InInitializationOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLIST_ENTRY           LdrCrt;
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        
        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InInitializationOrderLinks);

        LdrCrt = LdrNext;
        
        LdrNext = LdrEntry->InInitializationOrderLinks.Flink;
        
        if (LdrEntry->DllBase == hMod) {
            //
            // This is the module we're looking for. Get him out of the list
            // and insert it at the beginning of the list.
            //
            RemoveEntryList(LdrCrt);
            InsertHeadList(LdrHead, LdrCrt);
            bRet = TRUE;
            break;
        }
    }
    
    DumpUnloadOrder(Peb);
    
    return bRet;
}

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\rtlutils.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    rtlutils.cpp

 Abstract:
    
    Contains functions from ntdll on XP
    that are not available on W2K.

 History:

    09/10/2001  rparsons    Created

--*/

#include "rtlutils.h"

namespace ShimLib
{

#define IS_PATH_SEPARATOR_U(ch) (((ch) == L'\\') || ((ch) == L'/'))

extern const UNICODE_STRING RtlpDosDevicesPrefix    = RTL_CONSTANT_STRING( L"\\??\\" );
extern const UNICODE_STRING RtlpDosDevicesUncPrefix = RTL_CONSTANT_STRING( L"\\??\\UNC\\" );

const UNICODE_STRING RtlpEmptyString = RTL_CONSTANT_STRING(L"");

//
// Taken from %SDXROOT%\public\sdk\inc\ntrtl.h
//
#if DBG
#undef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)
#else
#undef ASSERT
#define ASSERT( exp )         ((void) 0)
#endif
        
#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)
                                


                                
//
// These functions were taken from:
// %SDXROOT%\base\ntdll\ldrinit.c
//
PVOID
ShimAllocateStringRoutine(
    SIZE_T NumberOfBytes
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, NumberOfBytes);
}

VOID
ShimFreeStringRoutine(
    PVOID Buffer
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
}

//
// These functions were pulled from:
// %SDXROOT%\base\ntdll\curdir.c
//

RTL_PATH_TYPE
NTAPI
ShimDetermineDosPathNameType_Ustr(
    IN PCUNICODE_STRING String
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.)

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    RtlPathTypeUnknown - The path type can not be determined

    RtlPathTypeUncAbsolute - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    RtlPathTypeLocalDevice - The path specifies a local device in the format
        \\.\rest-of-path or \\?\rest-of-path.  This can be used for any device
        where the nt and Win32 names are the same. For example mailslots.

    RtlPathTypeRootLocalDevice - The path specifies the root of the local
        devices in the format \\. or \\?

    RtlPathTypeDriveAbsolute - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    RtlPathTypeDriveRelative - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    RtlPathTypeRooted - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    RtlPathTypeRelative - The path is relative (i.e. not absolute or rooted).

--*/

{
    RTL_PATH_TYPE ReturnValue;
    const PCWSTR DosFileName = String->Buffer;

#define ENOUGH_CHARS(_cch) (String->Length >= ((_cch) * sizeof(WCHAR)))

    if ( ENOUGH_CHARS(1) && IS_PATH_SEPARATOR_U(*DosFileName) ) {
        if ( ENOUGH_CHARS(2) && IS_PATH_SEPARATOR_U(*(DosFileName+1)) ) {
            if ( ENOUGH_CHARS(3) && (DosFileName[2] == '.' ||
                                     DosFileName[2] == '?') ) {

                if ( ENOUGH_CHARS(4) && IS_PATH_SEPARATOR_U(*(DosFileName+3)) ){
                    // "\\.\" or "\\?\"
                    ReturnValue = RtlPathTypeLocalDevice;
                    }
                //
                // Bogosity ahead, the code is confusing length and nuls,
                // because it was copy/pasted from the PCWSTR version.
                //
                else if ( ENOUGH_CHARS(4) && (*(DosFileName+3)) == UNICODE_NULL ){
                    // "\\.\0" or \\?\0"
                    ReturnValue = RtlPathTypeRootLocalDevice;
                    }
                else {
                    // "\\.x" or "\\." or "\\?x" or "\\?"
                    ReturnValue = RtlPathTypeUncAbsolute;
                    }
                }
            else {
                // "\\x"
                ReturnValue = RtlPathTypeUncAbsolute;
                }
            }
        else {
            // "\x"
            ReturnValue = RtlPathTypeRooted;
            }
        }
    //
    // the "*DosFileName" is left over from the PCWSTR version
    // Win32 and DOS don't allow embedded nuls and much code limits
    // drive letters to strictly 7bit a-zA-Z so it's ok.
    //
    else if (ENOUGH_CHARS(2) && *DosFileName && *(DosFileName+1)==L':') {
        if (ENOUGH_CHARS(3) && IS_PATH_SEPARATOR_U(*(DosFileName+2))) {
            // "x:\"
            ReturnValue = RtlPathTypeDriveAbsolute;
            }
        else  {
            // "c:x"
            ReturnValue = RtlPathTypeDriveRelative;
            }
        }
    else {
        // "x", first char is not a slash / second char is not colon
        ReturnValue = RtlPathTypeRelative;
        }
    return ReturnValue;

#undef ENOUGH_CHARS
}

NTSTATUS
NTAPI
ShimNtPathNameToDosPathName(
    IN     ULONG                      Flags,
    IN OUT PRTL_UNICODE_STRING_BUFFER Path,
    OUT    ULONG*                     Disposition OPTIONAL,
    IN OUT PWSTR*                     FilePart OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SIZE_T NtFilePartOffset = 0;
    SIZE_T DosFilePartOffset = 0;
    BOOLEAN Unc = FALSE;
    const static UNICODE_STRING DosUncPrefix = RTL_CONSTANT_STRING(L"\\\\");
    PCUNICODE_STRING NtPrefix = NULL;
    PCUNICODE_STRING DosPrefix = NULL;
    RTL_STRING_LENGTH_TYPE Cch = 0;

    if (ARGUMENT_PRESENT(Disposition)) {
        *Disposition = 0;
    }

    if (   !RTL_SOFT_VERIFY(Path != NULL)
        || !RTL_SOFT_VERIFY(Flags == 0)
        ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (ARGUMENT_PRESENT(FilePart) && *FilePart != NULL) {
        NtFilePartOffset = *FilePart - Path->String.Buffer;
        if (!RTL_SOFT_VERIFY(NtFilePartOffset < RTL_STRING_GET_LENGTH_CHARS(&Path->String))
            ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesUncPrefix), &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesUncPrefix;
        DosPrefix = &DosUncPrefix;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC;
        }
    }
    else if (RtlPrefixUnicodeString(RTL_CONST_CAST(PUNICODE_STRING)(&RtlpDosDevicesPrefix), &Path->String, TRUE)
        ) {
        NtPrefix = &RtlpDosDevicesPrefix;
        DosPrefix = &RtlpEmptyString;
        if (ARGUMENT_PRESENT(Disposition)) {
            *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE;
        }
    }
    else {
        //
        // It is not recognizably an Nt path produced by RtlDosPathNameToNtPathName_U.
        //
        if (ARGUMENT_PRESENT(Disposition)) {
            RTL_PATH_TYPE PathType = ShimDetermineDosPathNameType_Ustr(&Path->String);
            switch (PathType) {
                case RtlPathTypeUnknown:
                case RtlPathTypeRooted: // NT paths are identified as this
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                //
                // "already" dospaths, but not gotten from this function, let's
                // give a less good disposition
                //
                case RtlPathTypeDriveRelative:
                case RtlPathTypeRelative:
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS;
                    break;

                // these are pretty clearly dospaths already
                case RtlPathTypeUncAbsolute:
                case RtlPathTypeDriveAbsolute:
                case RtlPathTypeLocalDevice: // "\\?\" or "\\.\" or "\\?\blah" or "\\.\blah" 
                case RtlPathTypeRootLocalDevice: // "\\?" or "\\."
                    *Disposition = RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS;
                    break;
            }
        }
        goto Exit;
    }

    Cch =
              RTL_STRING_GET_LENGTH_CHARS(&Path->String)
            + RTL_STRING_GET_LENGTH_CHARS(DosPrefix)
            - RTL_STRING_GET_LENGTH_CHARS(NtPrefix);

    Status =
        ShimEnsureUnicodeStringBufferSizeChars(Path, Cch);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // overlapping buffer shuffle...careful.
    //
    RtlMoveMemory(
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(DosPrefix),
        Path->String.Buffer + RTL_STRING_GET_LENGTH_CHARS(NtPrefix),
        Path->String.Length - NtPrefix->Length
        );
    RtlMoveMemory(
        Path->String.Buffer,
        DosPrefix->Buffer,
        DosPrefix->Length
        );
    Path->String.Length = Cch * sizeof(Path->String.Buffer[0]);
    RTL_NUL_TERMINATE_STRING(&Path->String);

    if (NtFilePartOffset != 0) {
        // review/test..
        *FilePart = Path->String.Buffer + (NtFilePartOffset - RTL_STRING_GET_LENGTH_CHARS(NtPrefix) + RTL_STRING_GET_LENGTH_CHARS(DosPrefix));
    }
    Status = STATUS_SUCCESS;
Exit:
    /* KdPrintEx((
        DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
        "%s(%d):%s(%wZ): 0x%08lx\n", __FILE__, __LINE__, __FUNCTION__, Path, Status)); */
    return Status;
}

NTSTATUS
ShimValidateUnicodeString(
    ULONG Flags,
    const UNICODE_STRING *String
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Flags == 0);

    if (Flags != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (String != NULL) {
        if (((String->Length % 2) != 0) ||
            ((String->MaximumLength % 2) != 0) ||
            (String->Length > String->MaximumLength)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (((String->Length != 0) ||
             (String->MaximumLength != 0)) &&
            (String->Buffer == NULL)) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

//
// This function was taken from:
// %SDXROOT%\base\ntos\rtl\nls.c
//

NTSTATUS
ShimDuplicateUnicodeString(
    ULONG Flags,
    PCUNICODE_STRING StringIn,
    PUNICODE_STRING StringOut
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Length = 0;
    USHORT NewMaximumLength = 0;
    PWSTR Buffer = NULL;

    if (((Flags & ~(
            RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
            RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING)) != 0) ||
        (StringOut == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // It doesn't make sense to force allocation of a null string unless you
    // want null termination.
    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) &&
        !(Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = ShimValidateUnicodeString(0, StringIn);
    if (!NT_SUCCESS(Status))
        goto Exit;

    if (StringIn != NULL)
        Length = StringIn->Length;

    if ((Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) &&
        (Length == UNICODE_STRING_MAX_BYTES)) {
        Status = STATUS_NAME_TOO_LONG;
        goto Exit;
    }

    if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE)
        NewMaximumLength = (USHORT) (Length + sizeof(WCHAR));
    else
        NewMaximumLength = Length;

    // If it's a zero length string in, force the allocation length to zero
    // unless the caller said that they want zero length strings allocated.
    if (((Flags & RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING) == 0) &&
        (Length == 0)) {
        NewMaximumLength = 0;
    }

    if (NewMaximumLength != 0) {
        Buffer = (PWSTR)(RtlAllocateStringRoutine)(NewMaximumLength);
        if (Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        // If there's anything to copy, copy it.  We explicitly test Length because
        // StringIn could be a NULL pointer, so dereferencing it to get the Buffer
        // pointer would access violate.
        if (Length != 0) {
            RtlCopyMemory(
                Buffer,
                StringIn->Buffer,
                Length);
        }

        if (Flags & RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE) {
            Buffer[Length / sizeof(WCHAR)] = L'\0';
        }
    }

    StringOut->Buffer = Buffer;
    StringOut->MaximumLength = NewMaximumLength;
    StringOut->Length = Length;

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

//
// This function was pulled from:
// %SDXROOT%\base\ntdll\buffer.c
//
NTSTATUS
NTAPI
ShimpEnsureBufferSize(
    IN ULONG           Flags,
    IN OUT PRTL_BUFFER Buffer,
    IN SIZE_T          Size
    )
/*++

Routine Description:

    This function ensures Buffer can hold Size bytes, or returns
    an error. It either bumps Buffer->Size closer to Buffer->StaticSize,
    or heap allocates.

Arguments:

    Buffer - a Buffer object, see also RtlInitBuffer.

    Size - the number of bytes the caller wishes to store in Buffer->Buffer.


Return Value:

     STATUS_SUCCESS
     STATUS_NO_MEMORY

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Temp = NULL;

    if ((Flags & ~(RTL_ENSURE_BUFFER_SIZE_NO_COPY)) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    if (Buffer == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Size <= Buffer->Size) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    // Size <= Buffer->StaticSize does not imply static allocation, it
    // could be heap allocation that the client poked smaller.
    if (Buffer->Buffer == Buffer->StaticBuffer && Size <= Buffer->StaticSize) {
        Buffer->Size = Size;
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    //
    // The realloc case was messed up in Whistler, and got removed.
    // Put it back in Blackcomb.
    //
    Temp = (PUCHAR)RtlAllocateStringRoutine(Size);
    if (Temp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    if ((Flags & RTL_ENSURE_BUFFER_SIZE_NO_COPY) == 0) {
        RtlCopyMemory(Temp, Buffer->Buffer, Buffer->Size);
    }

    if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buffer)) {
        RtlFreeStringRoutine(Buffer->Buffer);
        Buffer->Buffer = NULL;
    }
    ASSERT(Temp != NULL);
    Buffer->Buffer = Temp;
    Buffer->Size = Size;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

} // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\shimhook.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ShimHook.cpp

 Abstract:

    Strictly Shim hooking routines.

 Notes:

    None

 History:

    11/01/1999  markder     Created
    11/11/1999  markder     Added comments
    01/10/2000  linstev     Format to new style
    03/14/2000  robkenny    Changed DPF from eDebugLevelInfo to eDebugLevelSpew
    03/31/2000  robkenny    Added our own private versions of malloc/free new/delete
    10/29/2000  markder     Added version 2 support
    08/14/2001  robkenny    Moved generic routines to ShimLib.cpp
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include "ShimHook.h"
#include "ShimHookMacro.h"
#include "StrSafe.h"

namespace ShimLib
{

HINSTANCE               g_hinstDll;
BOOL                    g_bMultiShim;
PHOOKAPI                g_pAPIHooks;   
PSHIM_COM_HOOK          g_pCOMHooks;   
DWORD                   g_dwAPIHookCount;   
DWORD                   g_dwCOMHookCount;   
DWORD                   g_dwCOMHookBuffer;
DWORD                   g_dwShimVersion;
CHAR *                  g_szCommandLine;

/*++

 Global variables for COM hook support

 The following variables are pointers to the first entry in linked lists that
 are maintained by the mechanism in order to properly manage the hooking
 process.

 There will be one SHIM_IFACE_FN_MAP for every COM interface function pointer
 that was overwritten with one of our hooks.

 There will be one SHIM_HOOKED_OBJECT entry every COM interface that is handed
 out. This is required to differentiate between different classes that expose
 the same interface, but one is hooked and one isn't.

--*/
PSHIM_IFACE_FN_MAP      g_pIFaceFnMaps;
PSHIM_HOOKED_OBJECT     g_pObjectCache;
PLDR_DATA_TABLE_ENTRY   g_DllLoadingEntry;



PHOOKAPI    GetHookAPIs( IN LPSTR pszCmdLine, IN LPWSTR pwszShim, IN OUT DWORD *pdwHooksCount ); 
void        PatchFunction( PVOID* pVtbl, DWORD dwVtblIndex, PVOID pfnNew );
ULONG       COMHook_AddRef( PVOID pThis );
ULONG       COMHook_Release( PVOID pThis );
HRESULT     COMHook_QueryInterface( PVOID pThis, REFIID iid, PVOID* ppvObject );
HRESULT     COMHook_IClassFactory_CreateInstance( PVOID pThis, IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
VOID        HookObject(IN CLSID *pCLSID, IN REFIID riid, OUT LPVOID *ppv, OUT PSHIM_HOOKED_OBJECT pOb, IN BOOL bClassFactory);



void
NotifyShims(
    int      nReason,
    UINT_PTR extraInfo
    )
{
    switch (nReason) {
    case SN_STATIC_DLLS_INITIALIZED:
        InitializeHooksEx(SHIM_STATIC_DLLS_INITIALIZED, NULL, NULL, NULL);
        break;
    case SN_PROCESS_DYING:
        InitializeHooksEx(SHIM_PROCESS_DYING, NULL, NULL, NULL);
        break;
    case SN_DLL_LOADING:
        
        g_DllLoadingEntry = (PLDR_DATA_TABLE_ENTRY)extraInfo;
        
        InitializeHooksEx(SHIM_DLL_LOADING, NULL, NULL, NULL);
        break;
    }
}


/*++

 Function Description:

    Called by the shim mechanism. Initializes the global APIHook array and
    returns necessary information to the shim mechanism.

 Arguments:

    IN dwGetProcAddress  -  Function pointer to GetProcAddress
    IN dwLoadLibraryA    -  Function pointer to LoadLibraryA
    IN dwFreeLibrary     -  Function pointer to FreeLibrary
    IN OUT pdwHooksCount -  Receive the number of APIHooks in the returned array

 Return Value:

    Pointer to global HOOKAPI array.

 History:

    11/01/1999 markder  Created

--*/

PHOOKAPI
GetHookAPIs(
    IN LPSTR pszCmdLine,
    IN LPWSTR pwszShim,
    IN OUT DWORD * pdwHooksCount
    )
{
    PHOOKAPI    pHookAPIs = NULL;

    pHookAPIs = InitializeHooksEx(DLL_PROCESS_ATTACH, pwszShim, pszCmdLine, pdwHooksCount);

    DPF("ShimLib", eDbgLevelBase, 
        "[Shim] %S%s%s%s\n", 
        pwszShim,
        pszCmdLine[0] != '\0' ? "(\"" : "",
        pszCmdLine,
        pszCmdLine[0] != '\0' ? "\")" : "");

    return pHookAPIs;
}

/*++

 Function Description:

    Adds an entry to the g_IFaceFnMaps linked list.

 Arguments:

    IN  pVtbl  - Pointer to an interface vtable to file under
    IN  pfnNew - Pointer to the new (stub) function
    IN  pfnOld - Pointer to the old (original) function

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
AddIFaceFnMap(
    IN PVOID pVtbl,
    IN PVOID pfnNew,
    IN PVOID pfnOld
    )
{
    PSHIM_IFACE_FN_MAP pNewMap = (PSHIM_IFACE_FN_MAP) ShimMalloc( sizeof(SHIM_IFACE_FN_MAP) );

    if (pNewMap == NULL)
    {
        DPF("ShimLib", eDbgLevelError, "[AddIFaceFnMap]  Could not allocate space for new SHIM_IFACE_FN_MAP.\n");
        return;
    }

    DPF("ShimLib", eDbgLevelSpew, "[AddIFaceFnMap]  pVtbl: 0x%p pfnNew: 0x%p pfnOld: 0x%p\n",
        pVtbl,
        pfnNew,
        pfnOld);

    pNewMap->pVtbl  = pVtbl;
    pNewMap->pfnNew = pfnNew;
    pNewMap->pfnOld = pfnOld;

    pNewMap->pNext = g_pIFaceFnMaps;
    g_pIFaceFnMaps = pNewMap;
}

/*++

 Function Description:

  Searches the g_pIFaceFnMaps linked list for a match on pVtbl and pfnNew, and
  returns the corresponding pfnOld. This is typically called from inside a
  stubbed function to determine what original function pointer to call for the
  particular vtable that was used by the caller.

  It is also used by PatchFunction to determine if a vtable's function pointer
  has already been stubbed.

 Arguments:

    IN  pVtbl  - Pointer to an interface vtable to file under
    IN  pfnNew - Pointer to the new (stub) function
    IN  bThrowExceptionIfNull - Flag that specifies whether it should be
                 possible to not find the original function in our function
                 map

 Return Value:

    Returns the original function pointer

 History:

    11/01/1999 markder  Created

--*/

PVOID
LookupOriginalCOMFunction(
    IN PVOID pVtbl,
    IN PVOID pfnNew,
    IN BOOL bThrowExceptionIfNull
    )
{
    PSHIM_IFACE_FN_MAP pMap = g_pIFaceFnMaps;
    PVOID pReturn = NULL;

    DPF("ShimLib", eDbgLevelSpew, "[LookupOriginalCOMFunction] pVtbl: 0x%p pfnNew: 0x%p ",
        pVtbl,
        pfnNew);

    // Scan the linked list for a match and return if found.
    while (pMap)
    {
        if (pMap->pVtbl == pVtbl && pMap->pfnNew == pfnNew)
        {
            pReturn = pMap->pfnOld;
            break;
        }

        pMap = (PSHIM_IFACE_FN_MAP) pMap->pNext;
    }

    DPF("ShimLib", eDbgLevelSpew, " --> Returned: 0x%p\n", pReturn);

    if (!pReturn && bThrowExceptionIfNull)
    {
        // If we have hit this point, there is something seriously wrong.
        // Either there is a bug in the AddRef/Release stubs or the app
        // obtained an interface pointer in some way that we don't catch.
        DPF("ShimLib", eDbgLevelError,"ERROR: Shim COM APIHooking mechanism failed.\n");
        APPBreakPoint();
    }

    return pReturn;
}

/*++

 Function Description:

  Stores the original function pointer in the function map and overwrites it in
  the vtable with the new one.

 Arguments:

    IN  pVtbl       - Pointer to an interface vtable to file under
    IN  dwVtblIndex - The index of the target function within the vtable.
    IN  pfnNew      - Pointer to the new (stub) function

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
PatchFunction(
    IN PVOID* pVtbl,
    IN DWORD dwVtblIndex,
    IN PVOID pfnNew
    )
{
    DWORD dwOldProtect = 0;
    DWORD dwOldProtect2 = 0;

    DPF("ShimLib", eDbgLevelSpew, "[PatchFunction] pVtbl: 0x%p, dwVtblIndex: %d, pfnOld: 0x%p, pfnNew: 0x%p\n",
        pVtbl,
        dwVtblIndex,
        pVtbl[dwVtblIndex],
        pfnNew);

    // if not patched yet
    if (!LookupOriginalCOMFunction( pVtbl, pfnNew, FALSE))
    {
        AddIFaceFnMap( pVtbl, pfnNew, pVtbl[dwVtblIndex]);

        // Make the code page writable and overwrite function pointers in vtable
        if (VirtualProtect(pVtbl + dwVtblIndex,
                sizeof(DWORD),
                PAGE_READWRITE,
                &dwOldProtect))
        {
            pVtbl[dwVtblIndex] = pfnNew;

            // Return the code page to its original state
            VirtualProtect(pVtbl + dwVtblIndex,
                sizeof(DWORD),
                dwOldProtect,
                &dwOldProtect2);
        }
    }

}

/*++

 Function Description:

    This stub exists to keep track of an interface's reference count changes.
    Note that the bAddRefTrip flag is cleared, which allows
    APIHook_QueryInterface to determine whether an AddRef was performed inside
    the original QueryInterface function call.

 Arguments:

    IN  pThis - The object's 'this' pointer

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

ULONG
APIHook_AddRef(
    IN PVOID pThis
    )
{
    PSHIM_HOOKED_OBJECT pHookedOb = g_pObjectCache;
    _pfn_AddRef pfnOld;
    ULONG ulReturn;

    pfnOld = (_pfn_AddRef) LookupOriginalCOMFunction( *((PVOID*)(pThis)),
        APIHook_AddRef,
        TRUE);

    ulReturn = (*pfnOld)(pThis);

    while (pHookedOb)
    {
        if (pHookedOb->pThis == pThis)
        {
            pHookedOb->dwRef++;
            pHookedOb->bAddRefTrip = FALSE;
            DPF("ShimLib", eDbgLevelSpew, "[AddRef] pThis: 0x%p dwRef: %d ulReturn: %d\n",
                pThis,
                pHookedOb->dwRef,
                ulReturn);
            break;
        }

        pHookedOb = (PSHIM_HOOKED_OBJECT) pHookedOb->pNext;
    }

    return ulReturn;
}

/*++

 Function Description:

    This stub exists to keep track of an interface's reference count changes.

 Arguments:

    IN  pThis - The object's 'this' pointer

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

ULONG
APIHook_Release(
    IN PVOID pThis
    )
{
    PSHIM_HOOKED_OBJECT *ppHookedOb = &g_pObjectCache;
    PSHIM_HOOKED_OBJECT pTemp;
    _pfn_Release pfnOld;
    ULONG ulReturn;

    pfnOld = (_pfn_Release) LookupOriginalCOMFunction(*((PVOID*)(pThis)),
        APIHook_Release,
        TRUE);

    ulReturn = (*pfnOld)( pThis );

    while ((*ppHookedOb))
    {
        if ((*ppHookedOb)->pThis == pThis)
        {
            (*ppHookedOb)->dwRef--;

            DPF("ShimLib", eDbgLevelSpew, "[Release] pThis: 0x%p dwRef: %d ulReturn: %d %s\n",
                pThis,
                (*ppHookedOb)->dwRef,
                ulReturn,
                ((*ppHookedOb)->dwRef?"":" --> Deleted"));

            if (!((*ppHookedOb)->dwRef))
            {
                pTemp = (*ppHookedOb);
                *ppHookedOb = (PSHIM_HOOKED_OBJECT) (*ppHookedOb)->pNext;
                ShimFree(pTemp);
            }

            break;
        }

        ppHookedOb = (PSHIM_HOOKED_OBJECT*) &((*ppHookedOb)->pNext);
    }

    return ulReturn;
}

/*++

 Function Description:

    This stub catches the application attempting to obtain a new interface
    pointer to the same object. The function searches the object cache
    to obtain a CLSID for the object and, if found, APIHooks all required
    functions in the new vtable (via the HookObject call).

 Arguments:

    IN  pThis     - The object's 'this' pointer
    IN  iid       - Reference to the identifier of the requested interface
    IN  ppvObject - Address of output variable that receives the interface
                    pointer requested in riid.

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_QueryInterface(
    PVOID pThis,
    REFIID iid,
    PVOID* ppvObject
    )
{
    HRESULT hrReturn = E_FAIL;
    _pfn_QueryInterface pfnOld = NULL;
    PSHIM_HOOKED_OBJECT pOb = g_pObjectCache;

    pfnOld = (_pfn_QueryInterface) LookupOriginalCOMFunction(
        *((PVOID*)pThis),
        APIHook_QueryInterface,
        TRUE);

    while (pOb)
    {
        if (pOb->pThis == pThis)
        {
            pOb->bAddRefTrip = TRUE;
            break;
        }
        pOb = (PSHIM_HOOKED_OBJECT) pOb->pNext;
    }

    if (S_OK == (hrReturn = (*pfnOld) (pThis, iid, ppvObject)))
    {
        if (pOb)
        {
            if (pOb->pThis == *((PVOID*)ppvObject))
            {
                // Same object. Detect whether QueryInterface used IUnknown::AddRef
                // or an internal function.
                DPF("ShimLib",  eDbgLevelSpew,"[HookObject] Existing object%s. pThis: 0x%p\n",
                    (pOb->bAddRefTrip?" (AddRef'd) ":""),
                    pOb->pThis);

                if (pOb->bAddRefTrip)
                {
                    (pOb->dwRef)++;      // AddRef the object
                    pOb->bAddRefTrip = FALSE;
                }

                // We are assured that the CLSID for the object will be the same.
                HookObject(pOb->pCLSID, iid, ppvObject, pOb, pOb->bClassFactory);
            }
            else
            {
                HookObject(pOb->pCLSID, iid, ppvObject, NULL, pOb->bClassFactory);
            }
        }
    }

    return hrReturn;
}

/*++

 Function Description:

    This stub catches the most interesting part of the object creation process:
    The actual call to IClassFactory::CreateInstance. Since no CLSID is passed
    in to this function, the stub must decide whether to APIHook the object by
    looking up the instance of the class factory in the object cache. IF IT
    EXISTS IN THE CACHE, that indicates that it creates an object that we wish
    to APIHook.

 Arguments:

    IN  pThis     - The object's 'this' pointer
    IN  pUnkOuter - Pointer to whether object is or isn't part of an aggregate
    IN  riid      - Reference to the identifier of the interface
    OUT ppvObject - Address of output variable that receives the interface
                    pointer requested in riid

 Return Value:

    Return value is obtained from original function

 History:

    11/01/1999 markder  Created

--*/

HRESULT
APIHook_IClassFactory_CreateInstance(
    PVOID pThis,
    IUnknown *pUnkOuter,
    REFIID riid,
    VOID **ppvObject
    )
{
    HRESULT hrReturn = E_FAIL;
    _pfn_CreateInstance pfnOldCreateInst = NULL;
    PSHIM_HOOKED_OBJECT pOb = g_pObjectCache;

    pfnOldCreateInst = (_pfn_CreateInstance) LookupOriginalCOMFunction(
                                                *((PVOID*)pThis),
                                                APIHook_IClassFactory_CreateInstance,
                                                FALSE);

    if (pfnOldCreateInst == NULL) {
        DPF("ShimLib", eDbgLevelError, "[CreateInstance] Cannot find CreateInstance\n", pThis);
        return E_FAIL;
    }
    
    if (S_OK == (hrReturn = (*pfnOldCreateInst)(pThis, pUnkOuter, riid, ppvObject)))
    {
        while (pOb)
        {
            if (pOb->pThis == pThis)
            {
                // This class factory instance creates an object that we APIHook.
                DPF("ShimLib", eDbgLevelSpew, "[CreateInstance] Hooking object! pThis: 0x%p\n", pThis);
                HookObject(pOb->pCLSID, riid, ppvObject, NULL, FALSE);
                break;
            }

            pOb = (PSHIM_HOOKED_OBJECT) pOb->pNext;
        }
    }

    return hrReturn;
}


VOID
HookCOMInterface(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv,
    BOOL bClassFactory
    )
{
    DWORD i = 0;

    // Determine if we need to hook this object
    for (i = 0; i < g_dwCOMHookCount; i++)
    {
        if (g_pCOMHooks[i].pCLSID &&
            IsEqualGUID( (REFCLSID) *(g_pCOMHooks[i].pCLSID), rclsid))
        {
            // Yes, we are hooking an interface on this object.
            HookObject((CLSID*) &rclsid, riid, ppv, NULL, bClassFactory);
            break;
        }
    }
}

/*++

 Function Description:

    Free memory associated with Hooks and dump info

 Arguments:

    None

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
DumpCOMHooks()
{
    PSHIM_IFACE_FN_MAP pMap = g_pIFaceFnMaps;
    PSHIM_HOOKED_OBJECT pHookedOb = g_pObjectCache;

    // Dump function map
    DPF("ShimLib", eDbgLevelSpew, "\n--- Shim COM Hook Function Map ---\n\n");

    while (pMap)
    {
        DPF("ShimLib", eDbgLevelSpew, "pVtbl: 0x%p pfnNew: 0x%p pfnOld: 0x%p\n",
            pMap->pVtbl,
            pMap->pfnNew,
            pMap->pfnOld);

        pMap = (PSHIM_IFACE_FN_MAP) pMap->pNext;
    }

    // Dump class factory cache
    DPF("ShimLib", eDbgLevelSpew, "\n--- Shim Object Cache (SHOULD BE EMPTY!!) ---\n\n");

    while (pHookedOb)
    {
        DPF("ShimLib", eDbgLevelSpew, "pThis: 0x%p dwRef: %d\n",
            pHookedOb->pThis,
            pHookedOb->dwRef);

        pHookedOb = (PSHIM_HOOKED_OBJECT) pHookedOb->pNext;
    }
}

/*++

 Function Description:

    This function adds the object's important info to the object cache and then
    patches all required functions. IUnknown is hooked for all objects
    regardless.

 Arguments:

    IN  rclsid - CLSID for the class object
    IN  riid   - Reference to the identifier of the interface that communicates
                 with the class object
    OUT ppv    - Address of the pThis pointer that uniquely identifies an
                 instance of the COM interface
    OUT pOb    - New obj pointer
    IN  bClassFactory - Is this a class factory call

 Return Value:

    None

 History:

    11/01/1999 markder  Created

--*/

VOID
HookObject(
    IN CLSID *pCLSID,
    IN REFIID riid,
    OUT LPVOID *ppv,
    OUT PSHIM_HOOKED_OBJECT pOb,
    IN BOOL bClassFactory
    )
{
    // Here's how a COM object looks in memory:
    //
    //      pv                        - The pointer to the object's interface. In C++ terms, it 
    //       |                          is sort of like the "this" pointer but objects
    //       |                          will hand back different pointers for different interfaces.
    //       |
    //       `-> pVtbl                - The COM virtual function table pointer. This is the
    //            |                     first 32-bit member of the interface structure.
    //            |
    //            |-> QueryInterface  - First function in the root interface, IUnknown. This
    //            |                     function allows calling members to request a different
    //            |                     interface that may be implemented by the object.
    //            |
    //            |-> AddRef          - Increments the reference count for this interface.
    //            |
    //            |-> Release         - Decrements the reference count for this interface.
    //            |
    //            |-> InterfaceFn1    - Beginning of the interface-specific functions.
    //            |-> InterfaceFn2    
    //            |-> InterfaceFn3
    //            |        .
    //            |        .
    //            |        .
    //

    // The COM hooking mechanism is interested in the virtual function table pointer, and to get
    // it we must dereference the ppv pointer twice.
    PVOID *pVtbl = ((PVOID*)(*((PVOID*)(*ppv))));

    DWORD i = 0;

    if (!pOb)
    {
        // If pOb is NULL, then the object does not exist in the cache yet.
        // Make a new entry for the object.

        DPF("ShimLib", eDbgLevelSpew, "[HookObject] New %s! pThis: 0x%p\n",
            (bClassFactory?"class factory":"object"),
            *ppv);

        pOb = (PSHIM_HOOKED_OBJECT) ShimMalloc(sizeof(SHIM_HOOKED_OBJECT));

        if( pOb == NULL )
        {
            DPF("ShimLib", eDbgLevelError, "[HookObject] Could not allocate memory for SHIM_HOOKED_OBJECT.\n");
            return;
        }

        pOb->pCLSID = pCLSID;
        pOb->pThis = *ppv;
        pOb->dwRef = 1;
        pOb->bAddRefTrip = FALSE;
        pOb->pNext = g_pObjectCache;
        pOb->bClassFactory = bClassFactory;

        g_pObjectCache = pOb;
    }

    // IUnknown must always be hooked since it is possible to get
    // a new interface pointer using it, and we need to process each interface
    // handed out. We must also keep track of the reference count so that
    // we can clean up our interface function map.

    PatchFunction(pVtbl, 0, APIHook_QueryInterface);
    PatchFunction(pVtbl, 1, APIHook_AddRef);
    PatchFunction(pVtbl, 2, APIHook_Release);

    if (bClassFactory && IsEqualGUID(IID_IClassFactory, riid))
    {
        // If we are processing a class factory, all we care about
        // hooking is CreateInstance, since it is an API that produces
        // the actual object we are interested in.
        PatchFunction(pVtbl, 3, APIHook_IClassFactory_CreateInstance);
    }
    else
    {
        for (i = 0; i < g_dwCOMHookCount; i++)
        {
            if (!(g_pCOMHooks[i].pCLSID) || !pCLSID)
            {
                // A CLSID was not specified -- hook any object that exposes
                // the specified interface.
                if (IsEqualGUID( (REFIID) *(g_pCOMHooks[i].pIID), riid))
                {
                    PatchFunction(
                        pVtbl,
                        g_pCOMHooks[i].dwVtblIndex,
                        g_pCOMHooks[i].pfnNew);
                }
            }
            else
            {
                // A CLSID was specified -- hook only interfaces on the
                // specified object.
                if (IsEqualGUID((REFCLSID) *(g_pCOMHooks[i].pCLSID), *pCLSID) &&
                    IsEqualGUID((REFIID) *(g_pCOMHooks[i].pIID), riid))
                {
                    PatchFunction(
                        pVtbl,
                        g_pCOMHooks[i].dwVtblIndex,
                        g_pCOMHooks[i].pfnNew);
                }
            }
        }
    }
}


BOOL InitHooks(DWORD dwCount)
{
    g_dwAPIHookCount = dwCount;
    g_pAPIHooks = (PHOOKAPI) ShimMalloc( g_dwAPIHookCount * sizeof(HOOKAPI) );
    if (g_pAPIHooks)
    {
        ZeroMemory(g_pAPIHooks, g_dwAPIHookCount * sizeof(HOOKAPI) );
    }

    return g_pAPIHooks != NULL;
}

BOOL InitComHooks(DWORD dwCount)
{
    //DECLARE_APIHOOK(DDraw.dll, DirectDrawCreate);
    //DECLARE_APIHOOK(DDraw.dll, DirectDrawCreateEx);

    g_dwCOMHookCount = dwCount;
    g_pCOMHooks = (PSHIM_COM_HOOK) ShimMalloc( g_dwCOMHookCount * sizeof(SHIM_COM_HOOK) );
    if (g_pCOMHooks)
    {
        ZeroMemory(g_pCOMHooks, g_dwCOMHookCount * sizeof(SHIM_COM_HOOK) );
    }

    return g_pCOMHooks != NULL;
    
}

VOID AddComHook(REFCLSID clsid, REFIID iid, PVOID hook, DWORD vtblndx)
{
    if (g_dwCOMHookBuffer <= g_dwCOMHookCount) {

        // Buffer is too small, must resize.
        DWORD           dwNewBuffer = g_dwCOMHookBuffer * 2;
        PSHIM_COM_HOOK  pNewBuffer  = NULL;

        if (dwNewBuffer == 0) {
            // 50 is the initial allocation, but it should be at least g_dwCOMHookCount
            dwNewBuffer = max(50, g_dwCOMHookCount);
        }

        pNewBuffer = (PSHIM_COM_HOOK) ShimMalloc( sizeof(SHIM_COM_HOOK) * dwNewBuffer );

        if (pNewBuffer == NULL) {
            DPF("ShimLib", eDbgLevelError, 
                "[AddComHook] Could not allocate SHIM_COM_HOOK array.");
            return;
        }

        // Copy over original array, then free the old one.

        if (g_pCOMHooks != NULL) {
            memcpy(pNewBuffer, g_pCOMHooks, sizeof(SHIM_COM_HOOK) * g_dwCOMHookBuffer);
            ShimFree(g_pCOMHooks);
        }

        g_pCOMHooks = pNewBuffer;
        g_dwCOMHookBuffer = dwNewBuffer;
    }
    
    g_pCOMHooks[g_dwCOMHookCount].pCLSID        = (CLSID*) &clsid;           
    g_pCOMHooks[g_dwCOMHookCount].pIID          = (IID*)  &iid;              
    g_pCOMHooks[g_dwCOMHookCount].dwVtblIndex   = vtblndx;                   
    g_pCOMHooks[g_dwCOMHookCount].pfnNew        = hook;            

    g_dwCOMHookCount++;

    return;
}


}; // end of namespace ShimLib

/*++

 Function Description:

    Called on process detach with old shim mechanism.

 Arguments:

    See MSDN

 Return Value:

    See MSDN

 History:

    11/01/1999 markder  Created

--*/

BOOL
DllMain(
    HINSTANCE hinstDLL,
    DWORD fdwReason,
    LPVOID /*lpvReserved*/
    )
{
    using namespace ShimLib;

    switch (fdwReason) {
    
    case DLL_PROCESS_ATTACH:
        g_hinstDll          = hinstDLL;
        g_pAPIHooks         = NULL;
        g_dwAPIHookCount    = 0;
        g_dwCOMHookCount    = 0;
        g_dwCOMHookBuffer   = 0;
        g_pCOMHooks         = NULL;
        g_pIFaceFnMaps      = NULL;
        g_pObjectCache      = NULL;
        g_szCommandLine     = "";
        g_bMultiShim        = FALSE;
        g_dwShimVersion     = 1;

        InitFileLogSupport();
        break;
    
    case DLL_PROCESS_DETACH:
        if (g_dwCOMHookCount > 0) {
            DumpCOMHooks();
        }

        InitializeHooks(DLL_PROCESS_DETACH);
        InitializeHooksEx(DLL_PROCESS_DETACH, NULL, NULL, NULL);

        break;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\veriflog.cpp ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        VerifLog.cpp

    Abstract:

        This module implements the code for manipulating the AppVerifier log file.

    Author:

        dmunsil     created     04/26/2001

    Revision History:

    08/14/2001  robkenny    Moved code inside the ShimLib namespace.
    09/21/2001  rparsons    Logging code now uses NT calls.
    09/25/2001  rparsons    Added critical section.
--*/

#include "avrfutil.h"
#include "ShimHook.h"
#include "VerifLog.h"
#include "strsafe.h"
#include "string.h"


namespace ShimLib
{


typedef struct _VLOG_GLOBAL_DATA {
    BOOL                    bLoggingDisabled;      // was logging disabled?
    PRTL_CRITICAL_SECTION   pcsLogging;
    WCHAR                   szSessionLog[MAX_PATH];
    WCHAR                   szProcessLog[MAX_PATH];
} VLOG_GLOBAL_DATA, *PVLOG_GLOBAL_DATA;


PVLOG_GLOBAL_DATA g_pData = NULL;
HANDLE  g_hMap = NULL;                      // mapping handle for global data
BOOL    g_bVerifierLogInited = FALSE;   // have we been through the init sequence?
BOOL    g_bLoggingDisabled = TRUE;   // have we been through the init sequence?
BOOL    g_bLogBreakIn = FALSE;
CString g_strSessionLog;
CString g_strProcessLog;
PRTL_CRITICAL_SECTION g_pcsLogging;
LPVOID  g_pDllBase;                 // our own DLL base
LPVOID  g_pDllEnd;                  // one past the DLL's last byte
DWORD   g_dwSizeOfImage;            // our own DLL image size


void
CheckForDebuggerBreakIn(
    void
    )
{
    WCHAR szExe[MAX_PATH];

    if (!GetCurrentExeName(szExe, ARRAYSIZE(szExe))) {
        g_bLogBreakIn = FALSE;
    }

    g_bLogBreakIn = GetShimSettingDWORD(L"General", szExe, AV_BREAKIN, FALSE);
}

BOOL
GetModuleNameAndOffset(
    LPVOID  lpAddress,          // IN return address to search for
    LPWSTR  lpwszModuleName,    // OUT name of module that contains address
    DWORD   dwBufferChars,      // IN size in chars of module name buffer
    PDWORD  pdwOffset           // OUT offset within module
    )
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD       i;
    BOOL        bRet = FALSE;

    if (!lpAddress || !lpwszModuleName || !pdwOffset) {
        return FALSE;
    }

    //
    // search for the module
    //

    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        //
        // Is this it?
        //
        if (lpAddress >= LdrEntry->DllBase && lpAddress < ((PBYTE)(LdrEntry->DllBase) + LdrEntry->SizeOfImage)) {

            //
            // we special-case shimeng and ntdll, because we don't want them to be filtered out by the
            // "system dll" filter.
            //
            if (_wcsicmp(LdrEntry->BaseDllName.Buffer, L"shimeng.dll") == 0 || _wcsicmp(LdrEntry->BaseDllName.Buffer, L"ntdll.dll") == 0) {
                StringCchCopyW(lpwszModuleName, dwBufferChars, L"?");
                *pdwOffset = 0;

            } else {

                StringCchCopyW(lpwszModuleName, dwBufferChars, LdrEntry->BaseDllName.Buffer);
    
                *pdwOffset = (DWORD)((PBYTE)lpAddress - (PBYTE)(LdrEntry->DllBase));
            }
            bRet = TRUE;
            break;

        }

        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }

    return bRet;

}

void
GetCallingModule(
    LPWSTR szModule,
    DWORD  dwChars,
    PDWORD pdwOffset
    )
{
    PVOID   apRetAddresses[10];
    USHORT  unAddresses, i;
    BOOL    bFound = FALSE;
    ULONG   ulHash;

    //
    // On W2K, RtlCaptureStackBackTrace tries to dereference the fourth
    // argument (the returned hash) without ensuring that it's valid.
    // This causes on an access violation. On XP, the problem has been
    // fixed. We get a hash value back, but we'll never use it.
    //
    unAddresses = RtlCaptureStackBackTrace(3, 10, apRetAddresses, &ulHash);

    for (i = 0; i != unAddresses; i++) {
        PVOID pAddress = apRetAddresses[i];

        if (pAddress < g_pDllBase || pAddress >= g_pDllEnd) {
            bFound = GetModuleNameAndOffset(pAddress, szModule, dwChars, pdwOffset);
            if (bFound) {
                break;
            }
        }
    }

    if (!bFound) {
        if (pdwOffset) {
            *pdwOffset = 0;
        }
        if (szModule) {
            StringCchCopyW(szModule, dwChars, L"?");
        }
    }

    return;
}


/*++

 Function Description:

    Initializes the globals holding this module's base address and size

 Return Value:

    none.

 History:

    09/26/2001 dmunsil  Created

--*/
void
GetCurrentModuleInfo(void)
{
    PPEB        Peb = NtCurrentPeb();
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD       i;

    //
    // the base address is just the hInst
    //
    g_pDllBase = (LPVOID)g_hinstDll;

    //
    // now go find the size of the image by looking through the
    // loader's module list
    //

    LdrHead = &Peb->Ldr->InMemoryOrderModuleList;

    LdrNext = LdrHead->Flink;

    while (LdrNext != LdrHead) {

        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        //
        // Is this it?
        //
        if (LdrEntry->DllBase == g_pDllBase) {
            g_dwSizeOfImage = LdrEntry->SizeOfImage;
            g_pDllEnd = (PVOID)((PBYTE)g_pDllBase + g_dwSizeOfImage);
            break;
        }

        LdrNext = LdrEntry->InMemoryOrderLinks.Flink;
    }
}

/*++

 Function Description:

    Initializes the support for file logging.

 Return Value:

    TRUE if successful, FALSE if failed

 History:

    04/26/2001 dmunsil  Created
    09/27/2001 rparsons Converted to use NT calls

--*/
BOOL
InitVerifierLogSupport(void)
{
    CString strProcessPath;
    CString strProcessName;
    CString strTemp;
    SYSTEMTIME LocalTime;
    CString strTime;
    CString strShared;
    char *szTemp;
    int nTemp;
    BOOL bAlreadyInited;
    BOOL bSuccess = FALSE;
    DWORD cchSize;
    DWORD dwID;
    DWORD dwErr;
    WCHAR wszVLogPath[MAX_PATH];
    NTSTATUS status;
    UNICODE_STRING strLogFile = {0};
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    //
    // if we've already been inited, get out
    //
    if (g_bVerifierLogInited) {
        return FALSE;
    }
    g_bVerifierLogInited = TRUE;

    CheckForDebuggerBreakIn();

    //
    // get the current module's base address and size
    //
    GetCurrentModuleInfo();

    //
    // first check for a shared memory block
    //
    dwID = GetCurrentProcessId();
    strShared.Format(L"VeriferLog_%08X", dwID);

    g_hMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, strShared.GetAnsi());
    if (g_hMap) {
        bAlreadyInited = TRUE;
    } else {
        bAlreadyInited = FALSE;
        g_hMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                          NULL,
                          PAGE_READWRITE,
                          0,
                          sizeof(VLOG_GLOBAL_DATA),
                          strShared.GetAnsi());
    }

    if (!g_hMap) {
        DPF("VerifierLog", eDbgLevelError, "Cannot get shared global data.");
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    g_pData = (PVLOG_GLOBAL_DATA)MapViewOfFile(g_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
    if (!g_pData) {
        DPF("VerifierLog", eDbgLevelError, "Cannot map shared global data.");
        g_bLoggingDisabled = TRUE;
        return FALSE;
    }

    if (bAlreadyInited) {
        if (g_pData->szProcessLog[0] == 0 || g_pData->szSessionLog[0] == 0) {
            g_bLoggingDisabled = TRUE;
            g_pData->bLoggingDisabled = TRUE;
            return FALSE;
        }
        g_bLoggingDisabled = g_pData->bLoggingDisabled;

        g_strSessionLog = g_pData->szSessionLog;
        g_strProcessLog = g_pData->szProcessLog;
        g_pcsLogging    = g_pData->pcsLogging;
        return TRUE;
    } else {
        //
        // we need to init the file mapping, so temporarily disable logging, just in case.
        //
        g_pData->bLoggingDisabled = TRUE;
    
        //
        // Initialize the critical section. We allocate memory so that we'll point
        // to one CS for every shim. Note that we don't free this as there are
        // several places we can exit.
        //
        g_pcsLogging = (PRTL_CRITICAL_SECTION)ShimMalloc(sizeof(RTL_CRITICAL_SECTION));

        if (!g_pcsLogging) {
            DPF("VerifierLog", eDbgLevelError, "No memory for critical section.");
            return FALSE;
        }

        status = RtlInitializeCriticalSectionAndSpinCount(g_pcsLogging, 0x80000000 | 4000);

        if (!NT_SUCCESS(status)) {
            DPF("VerifierLog", eDbgLevelError, "Failed to init critical section.");
            return FALSE;
        }
    
        //
        // First, check that log directory exists; if not, we're not logging
        //
        cchSize = GetAppVerifierLogPath(wszVLogPath, ARRAYSIZE(wszVLogPath));
    
        if (cchSize > ARRAYSIZE(wszVLogPath) || cchSize == 0) {
            DPF("VerifierLog", eDbgLevelError, "Buffer for log path is too small.");
            g_bLoggingDisabled = TRUE;
            return FALSE;
        }
    
        if (GetFileAttributesW(wszVLogPath) == -1) {
            DPF("VerifierLog", eDbgLevelInfo, "No log directory %ls. Logging disabled.", wszVLogPath);
            g_bLoggingDisabled = TRUE;
            return FALSE;
        }
    
        //
        // Next, check for the existence of session.log. If it's not there,
        // we're not logging
        //
        g_strSessionLog = wszVLogPath;
        g_strSessionLog += L"\\session.log";
        if (GetFileAttributesW(g_strSessionLog.Get()) == -1) {
            DPF("VerifierLog", eDbgLevelInfo, "No session log file '%ls'. Logging disabled.", g_strSessionLog.Get());
            g_bLoggingDisabled = TRUE;
            return FALSE;
        }
    
        //
        // get the process log file name
        //
        if (strProcessPath.GetModuleFileNameW(NULL) == 0) {
            DPF("VerifierLog", eDbgLevelError, "Cannot get module file name.");
            g_bLoggingDisabled = TRUE;
            return FALSE;
        }
    
        //
        // strip out just the name minus path and extension
        //
        strProcessPath.SplitPath(NULL, NULL, &strProcessName, NULL);
    
        //
        // combine into log name, find first available
        //
        nTemp = 0;
        do {
            g_strProcessLog.Format(L"%ls\\%ls%d.%ls", wszVLogPath, strProcessName.Get(), nTemp, L"log");
            nTemp++;
        } while (GetFileAttributesW(g_strProcessLog.Get()) != -1);
    
        //
        // Convert the path to the log file from DOS to NT.
        //
        bSuccess = RtlDosPathNameToNtPathName_U(g_strProcessLog.Get(), &strLogFile, NULL, NULL);
    
        if (!bSuccess) {
            DPF("VerifierLog",
                eDbgLevelError,
                "Failed to convert log file '%ls' to NT path",
                g_strProcessLog.Get());
            return FALSE;
        }
    
        //
        // Attempt to get a handle to our log file.
        // Truncate the file if it already exists.
        //
        InitializeObjectAttributes(&ObjectAttributes,
                                   &strLogFile,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
    
        status = NtCreateFile(&hFile,
                              GENERIC_ALL | SYNCHRONIZE,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              0,
                              FILE_OPEN_IF,
                              FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                              NULL,
                              0);
    
        RtlFreeUnicodeString(&strLogFile);
    
        if (!NT_SUCCESS(status)) {
            DPF("VerifierLog", eDbgLevelError, "0x%X Failed to open log file %ls",
                status, g_strProcessLog.Get());
            g_bLoggingDisabled = TRUE;
            return FALSE;
        }
    
        NtClose(hFile);
    
        //
        // put the info in the session log and the process log
        //
        g_pData->bLoggingDisabled = FALSE;
        g_bLoggingDisabled = FALSE;
    
        //
        // I realize these pointers point to process-specific memory, but since
        // this mapping is only shared by this process, it seems safe.
        //
        StringCchCopyW(g_pData->szProcessLog, ARRAYSIZE(g_pData->szProcessLog), g_strProcessLog);
        StringCchCopyW(g_pData->szSessionLog, ARRAYSIZE(g_pData->szSessionLog), g_strSessionLog);
    
        GetLocalTime(&LocalTime);
        strTime.Format(L"%d/%d/%d %d:%02d:%02d",
                       LocalTime.wMonth,
                       LocalTime.wDay,
                       LocalTime.wYear,
                       LocalTime.wHour,
                       LocalTime.wMinute,
                       LocalTime.wSecond
                       );
    
        strTemp.Format(L"# LOG_BEGIN %ls '%ls' '%ls'", strTime.Get(),
                  strProcessPath.Get(), g_strProcessLog.Get());
        szTemp = strTemp.GetAnsi();
        WriteToProcessLog(szTemp);
        WriteToSessionLog(szTemp);
    }

    return TRUE;
}

/*++

 Function Description:

    clean up all our shared file resources

 History:

    04/26/2001 dmunsil  Created

--*/
void
ReleaseVerifierLogSupport(void)
{
    g_bLoggingDisabled = TRUE;
    if (g_pData) {
        UnmapViewOfFile(g_pData);
        g_pData = NULL;
        if (g_hMap) {
            CloseHandle(g_hMap);
            g_hMap = NULL;
        }
    }
}

/*++

 Function Description:

    Logs a problem that the verifier has found

 History:

    04/26/2001 dmunsil  Created

--*/

void
CVerifierLog::VLog(
    VLOG_LEVEL eLevel,
    DWORD dwLogNum,
    LPCSTR pszFmt,
    ...
    )
{
    char szT[1024];
    char *szTemp;
    int nLen;
    int nRemain;
    va_list arglist;
    DWORD dwOffset = 0;
    WCHAR szModule[256];
    
    if (g_bLoggingDisabled) {
        return;
    }

    GetCallingModule(szModule, 256, &dwOffset);

    StringCchPrintfA(szT,
                     ARRAYSIZE(szT),
                     "| %ls %d | %d %ls %X'",
                     m_strShimName.Get(),
                     dwLogNum,
                     eLevel,
                     szModule,
                     dwOffset);

    nLen = lstrlen(szT);
    szTemp = szT + nLen;
    nRemain = 1024 - nLen;

    if (nRemain > 0) {
        va_start(arglist, pszFmt);
        StringCchVPrintfA(szTemp, nRemain, pszFmt, arglist);
        va_end(arglist);
    }

    WriteToProcessLog(szT);

    if (g_bLogBreakIn) {
        OutputDebugString(szT);
        DbgBreakPoint();
    }
}

/*++

 Function Description:

    Dumps the header for a shim that tells how many log entries it has.

 History:

    04/26/2001 dmunsil  Created

--*/
void
CVerifierLog::DumpShimHeader(void)
{
    char szT[1024];

    if (m_bHeaderDumped) {
        return;
    }

    StringCchPrintfA(szT, ARRAYSIZE(szT), "# SHIM_BEGIN %ls %d", m_strShimName.Get(), m_dwEntries);
    WriteToProcessLog(szT);

    m_bHeaderDumped = TRUE;
}


/*++

 Function Description:

    Dumps into the log the text string associated with
    each log entry. These are dumped before logging begins, just to
    provide the strings necessary for the verifier UI to display them

 Return Value:

 History:

    04/26/2001 dmunsil  Created

--*/
void
CVerifierLog::DumpLogEntry(
    DWORD   dwLogNum,
    UINT    unResTitle,
    UINT    unResDescription,
    UINT    unResURL
    )
{
    WCHAR szRes[1024];
    char szLine[4096];

    if (g_bLoggingDisabled) {
        return;
    }

    //
    // dump the header, if necessary
    //
    DumpShimHeader();

    if (!VLogLoadString(g_hinstDll, unResTitle, szRes, 1024)) {
        DPF("VerifierLog", eDbgLevelError, "No string resource found for title.");
        szRes[0] = 0;
    }
    StringCchPrintfA(szLine, ARRAYSIZE(szLine), "# LOGENTRY %ls %d '%ls", m_strShimName.Get(), dwLogNum, szRes);
    WriteToProcessLog(szLine);

    if (!VLogLoadString(g_hinstDll, unResDescription, szRes, 1024)) {
        DPF("VerifierLog", eDbgLevelWarning, "No string resource found for description.");
        szRes[0] = 0;
    }
    if (szRes[0]) {
        WriteToProcessLog("# DESCRIPTION BEGIN");
        StringCchPrintfA(szLine, ARRAYSIZE(szLine), "%ls", szRes);
        WriteToProcessLog(szLine);
        WriteToProcessLog("# DESCRIPTION END");
    }

    if (!VLogLoadString(g_hinstDll, unResURL, szRes, 1024)) {
        DPF("VerifierLog", eDbgLevelWarning, "No string resource found for URL.");
        szRes[0] = 0;
    }

    if (szRes[0]) {
        StringCchPrintfA(szLine, ARRAYSIZE(szLine), "# URL '%ls", szRes);
        WriteToProcessLog(szLine);
    }

}

/*++

 Function Description:

    Writes a line of text to the process log file

 Return Value:

 History:

    04/26/2001 dmunsil  Created
    09/21/2001 rparsons Converted to NT calls

--*/
void
WriteToProcessLog(
    LPCSTR szLine
    )
{
    int                 nLen = 0;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    UNICODE_STRING      strLogFile = {0};
    NTSTATUS            status;
    char                szNewLine[] = "\r\n";
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    BOOL                bSuccess = FALSE;

    if (g_bLoggingDisabled) {
        return;
    }

    //
    // Convert the path to the log file from DOS to NT.
    //
    bSuccess = RtlDosPathNameToNtPathName_U(g_strProcessLog.Get(), &strLogFile, NULL, NULL);

    if (!bSuccess) {
        DPF("VerifierLog",
            eDbgLevelError,
            "[WriteToProcessLog] Failed to convert log file '%ls' to NT path",
            g_strProcessLog.Get());
        return;
    }

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToProcessLog] 0x%X Failed to open log file %ls",
            status, g_strProcessLog.Get());
        return;
    }

    //
    // Make sure we have no '\n' or '\r' at the end of the string.
    //
    nLen = lstrlen(szLine);

    while (nLen && (szLine[nLen - 1] == '\n' || szLine[nLen - 1] == '\r')) {
        nLen--;
    }

    //
    // Write the data out to the file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    //
    // Enter a critical section to ensure that log entries are in the proper order.
    //
    RtlEnterCriticalSection(g_pcsLogging);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToProcessLog] 0x%X Failed to make entry in log file",
            status);
        goto exit;
    }

    //
    // Now write a new line to the log file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    nLen = lstrlen(szNewLine);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szNewLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToProcessLog] 0x%X Failed to write new line to log file",
            status);
        goto exit;
    }

    //
    // Dump it out to the debugger on checked builds.
    //
#if DBG
    DebugPrintf("VerifierLog", eDbgLevelInfo, szLine);
    DebugPrintf("VerifierLog", eDbgLevelInfo, szNewLine);
#endif // DBG

exit:

    if (INVALID_HANDLE_VALUE != hFile) {
        NtClose(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    RtlLeaveCriticalSection(g_pcsLogging);
}


/*++

 Function Description:

    Writes a line of text to the session log file

 Return Value:

 History:

    04/26/2001 dmunsil  Created
    09/21/2001 rparsons Converted to NT calls

--*/
void
WriteToSessionLog(
    LPCSTR szLine
    )
{
    int                 nLen = 0;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    UNICODE_STRING      strLogFile = {0};
    NTSTATUS            status;
    char                szNewLine[] = "\r\n";
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    BOOL                bSuccess = FALSE;

    if (g_bLoggingDisabled) {
        return;
    }

    //
    // Convert the path to the log file from DOS to NT.
    //
    bSuccess = RtlDosPathNameToNtPathName_U(g_strSessionLog.Get(), &strLogFile, NULL, NULL);

    if (!bSuccess) {
        DPF("VerifierLog",
            eDbgLevelError,
            "[WriteToSessionLog] Failed to convert log file '%ls' to NT path",
            g_strSessionLog.Get());
        return;
    }

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    RtlFreeUnicodeString(&strLogFile);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToSessionLog] 0x%X Failed to open log file %ls",
            status, g_strProcessLog.Get());
        return;
    }

    //
    // Make sure we have no '\n' or '\r' at the end of the string.
    //
    nLen = lstrlen(szLine);

    while (nLen && (szLine[nLen - 1] == '\n' || szLine[nLen - 1] == '\r')) {
        nLen--;
    }

    //
    // Write the data out to the file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    //
    // Enter a critical section to ensure that log entries are in the proper order.
    //
    RtlEnterCriticalSection(g_pcsLogging);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToSessionLog] 0x%X Failed to make entry in log file",
            status);
        goto exit;
    }

    //
    // Now write a new line to the log file.
    //
    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    nLen = lstrlen(szNewLine);

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)szNewLine,
                         (ULONG)nLen,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPF("VerifierLog", eDbgLevelError, "[WriteToSessionLog] 0x%X Failed to write new line to log file",
            status);
        goto exit;
    }

    //
    // Dump it out to the debugger on checked builds.
    //
#if DBG
    DebugPrintf("VerifierLog", eDbgLevelInfo, szLine);
    DebugPrintf("VerifierLog", eDbgLevelInfo, szNewLine);
#endif // DBG

exit:

    if (INVALID_HANDLE_VALUE != hFile) {
        NtClose(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    RtlLeaveCriticalSection(g_pcsLogging);
}


int VLogLoadString(
    HMODULE   hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        DPF("VLogLoadString", eDbgLevelWarning, "LoadStringOrError: lpBuffer == NULL");
        return 0;
    }


    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FindResourceW(hModule, (LPWSTR)ULongToPtr( ((LONG)(((USHORT)wID >> 4) + 1)) ), (LPWSTR)RT_STRING)) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);

        /*
         * Lock the resource.
         */
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) {

            /*
             * Move past the other strings in this segment.
             * (16 strings in a segment -> & 0x0F)
             */
            wID &= 0x0F;
            while (TRUE) {
                cch = *((WCHAR *)lpsz++);       // PASCAL like string count
                                                // first WCHAR is count of WCHARs
                if (wID-- == 0) break;
                lpsz += cch;                    // Step to start if next string
            }

            /*
             * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
             */
            if (cchBufferMax == 0) {
                *(LPWSTR *)lpBuffer = lpsz;
            } else {

                /*
                 * Account for the NULL
                 */
                cchBufferMax--;

                /*
                 * Don't copy more than the max allowed.
                 */
                if (cch > cchBufferMax)
                    cch = cchBufferMax;

                /*
                 * Copy the string into the buffer.
                 */
                RtlCopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
            }

            /*
             * Unlock resource, but don't free it - better performance this
             * way.
             */
            UnlockResource(hStringSeg);
        }
    }

    /*
     * Append a NULL.
     */
    if (cchBufferMax != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}




};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\win9xpath.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    Win9xPath.cpp

 Abstract:

    Munge a path the same was as Win9x.

    Much of this code was copied from Win9x:
    \\redrum\slm\proj\win\src\CORE\win32\KERNEL\dirutil.c
    \\redrum\slm\proj\win\src\CORE\win32\KERNEL\fileopcc.c 


    Path changes:
    1.  Translate all / to \
    2.  Remove all . and .. from the path, also removes some spaces
        (This is really bad Win9x code)
    3.  Remove all spaces before a \, except spaces following a .
        ( "abc  \xyz" -> "abc\xyz" or ".  \xyz" -> ".  \xyz")

 Notes:

    None

 History:

    10/05/2000  robkenny    Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/


#include "ShimLib.h"
#include "Win9xPath.h"

namespace ShimLib
{

#define WHACK       L'\\'
#define SPACE       L' '
#define DOT         L'.'
#define QUESTION    L'?'
#define EOS         L'\0'

#define     chNetIni    L'\\'
#define     chDirSep    L'\\'
#define     chDirSep2   L'/'
#define     chRelDir    L'.'

#define IsWhackWhack( lpstr )               (lpstr[0] == WHACK && lpstr[1] == WHACK)
#define IsWhackWhackDotWhack( lpstr )       (lpstr[0] == WHACK && lpstr[1] == WHACK && lpstr[2] == DOT      && lpstr[3] == WHACK)
#define IsWhackWhackQuestionWhack( lpstr )  (lpstr[0] == WHACK && lpstr[1] == WHACK && lpstr[2] == QUESTION && lpstr[3] == WHACK)


#define CopySz OverlapCpy       // Must be safe for overlapping strings

// Home grown version of wcscpy that works if src and dst overlap
void OverlapCpy(WCHAR * dst, const WCHAR * src)
{
    while (*dst++ = *src++)
    {
        ;
    }

}




/***    PchGetNetDir    - Validates a net drive spcification and returns
**                        a pointer to directory portion.
**
**  Synopsis
**      WCHAR * = PchGetNetDir (pchNetName)
**
**  Input:
**      pchNetName      - pointer to a string previously validated as
**                        the start of a net name (begins with \\)
**
**  Output:
**      returns pointer to the start of the directory portion of a net path
**
**  Errors:
**      returns NULL if the net name is invalid
**
**  Description:
**      This function takes a name starting with \\ and confirms that
**      it has one following \. It returns the position of the directory
**      portion. For the string
**
**               \\server\share[\path[\]]
**
**      it returns
**
**               [\path[\]]
*/

const WCHAR * PchGetNetDir (const WCHAR * pchNetName)
    {
    register const WCHAR * pch = pchNetName;

    // Skip starting slashes
    pch +=2;

    // Skip to first backslash
    for (;*pch != chNetIni; pch++) {
        if (*pch == EOS) {
            // No code required.
            return (NULL);
        }
    }

    pch++; // skip past 1st backslash

    // Skip to second backslash
    for (;(*pch != chDirSep) && (*pch != chDirSep2); pch++) {
       if (*pch == EOS) {
           // ok if share with no following \path
           return ((*(pch-1)==chNetIni) ? NULL : pch);
       }
    }
    return (pch);
}

/***    DwRemoveDots    - Remove any dots from a path name
**
**  Synopsis
**      DWORD DwRemoveDots (pchPath)
**
**  Input:
**      pchPath         - A path string
**
**
**  Output:
**      returns the number of double dot levels removed from front
**
**  Errors:
**      returns dwInvalid if invalid path
**
**  Description:
**      Removes ..\ and .\ sequences from a path string. The path
**      string should not include the root drive or net name portion.
**      The return value of is the number of levels removed from the
**      start of the string. Levels removed from inside the string
**      will not be returned. For example:
**
**          String          Result              Return
**
**          ..\..\dir1      dir1                2
**          dir1\..\dir2    dir2                0
**          dir1\..\..\dir2 dir2                1
**          .\dir1          dir1                0
**          dir1\.\dir2     dir1\dir2           0
**
**      A backslash at the start of the string will be ignored.
*/

DWORD DwRemoveDots (WCHAR * pchPath)
    {
    BOOL            fInside = FALSE;
    DWORD           cLevel = 0;
    DWORD           cBackup;
    register WCHAR * pchR;
    register WCHAR * pchL;

    // Check for invalid characters
//    if (!FFixPathChars(pchPath)) {
//        // No code required.
//        return dwInvalid;
//    }
//
    // Skip slashes
    for (; *pchPath == chDirSep; pchPath++)
        ;
    pchL = pchR = pchPath;

    // Loop through handling each directory part
    while (*pchR) {
        // This part starts with dot. Is it one or more?
        if (*pchR++ == chRelDir) {
            for (cBackup = 0; *pchR == chRelDir; cBackup++, pchR++)
                ;
            if (cBackup) {
                // More than one dot. Back up the left pointer.
                if ((*pchR != chDirSep) && (*pchR != EOS)) {
                    // we got a [.]+X (X != '\') might be an LFN
                    // process this as a name
                    goto name_processing;
                }
                // Doesn't advance for ending ..
                for (; *pchR == chDirSep; pchR++)
                    ;
                if (fInside) {
                    for (; cBackup; cBackup--) {
                        if (pchL <= pchPath) {
                            cLevel += cBackup;
                            fInside = FALSE;
                            break;
                        }
                        // Remove the previous part
                        for (pchL -= 2; *pchL != chDirSep; pchL--) {
                            if (pchL <= pchPath) {
                                fInside = FALSE;
                                pchL--;
                                break;
                            }
                        }
                        pchL++;
                    }
                } else {
                    cLevel += cBackup;
                }
                // Subtract ending backslash if not root
                if ((*pchR == EOS) && (pchL != pchPath))
                    pchL--;
                CopySz(pchL, pchR);
                pchR = pchL;
            } else {
                // This part starts with one dot. Throw it away.
                if (*pchR != chDirSep) {
                    // Special case "\." by converting it to ""
                    // unless it is a root, when it becomes "\".
                    if (*pchR == EOS) {
                        if (pchL == pchPath)
                            *(pchR-1) = EOS;   // root
                        else
                            *(pchR-2) = EOS;   // not root
                        return cLevel;
                    }
                    // we started with a '.' and then there was no '\'
                    // might be an LFN name
                    goto name_processing;
                }
                pchR++;
                CopySz(pchL, pchR);
                pchR = pchL;
            }
        } else {
name_processing:
            // This part is a name. Skip it.
            fInside = TRUE;
            for (; TRUE; pchR++) {
                if (*pchR == chDirSep) {
                    if (*(pchR-1) == chRelDir) {
                        // This name has one or more dots at the end.
                        // Remove the last dot (NT3.5 does this).
                        pchL = pchR-1;
                        CopySz(pchL, pchR);
                        pchR = pchL;    // point to chDirSep again
                    }
                    for (; *pchR == chDirSep; pchR++)
                        ;
                    break;
                } else if (*pchR == EOS) {
                    // Remove trailing dots.
                    // NB Can't fall off the beginning since the first WCHAR
                    // of the current path element was not chRelDir.
                    for (; *(pchR-1) == chRelDir; pchR--)
                        ;
                    // Overstore the first trailing dot, if there is one.
                    *pchR = EOS;
                    break;
                }
            }
            pchL = pchR;
        }
    }
    return cLevel;
}


// Get the Drive portion of this path,
// Either C: or \\server\disk format.
const WCHAR * GetDrivePortion(const WCHAR * uncorrected)
{
    if (uncorrected && uncorrected[0])
    {
        // Look for DOS style
        if (uncorrected[1] == ':')
        {
            uncorrected += 2;
        }
        // Look for UNC
        else if (IsWhackWhack(uncorrected))
        {
            const WCHAR * pchDir = PchGetNetDir(uncorrected);
            if (pchDir == NULL)
            {
                if (IsWhackWhackDotWhack(uncorrected) || IsWhackWhackQuestionWhack(uncorrected))
                {
                    uncorrected += 4;
                }
            }
            else
            {
                uncorrected = pchDir;
            }
        }
    }

    return uncorrected;
}

// Remove blank directory names "abc\   \def" -> "abc\def"
void RemovePreceedingBlanks(WCHAR * directoryPortion)
{
    if (directoryPortion == NULL || directoryPortion[0] == 0)
    {
        return;
    }

    WCHAR * blank = wcschr(directoryPortion, SPACE);
    while (blank != NULL)
    {
        // Find the end of the spaces
        WCHAR * blankEnd = blank;
        while (*blankEnd == SPACE && *blankEnd != WHACK)
        {
            ++blankEnd;
        }

        // Do not remove spaces *after* a period
        BOOL bPrevCharDot = (blank > directoryPortion) && (blank[-1] == DOT);
        if (bPrevCharDot)
        {
            blank = blankEnd;
            continue;
        }

        // If the the blank is a \ then we simply move the string down
        if (*blankEnd == WHACK)
        {
            BOOL bPrevCharWhack = blank[-1] == WHACK;

            // If the previous WCHAR is a \
            // we remove the \ at the end of the spaces as well
            if (bPrevCharWhack)
                blankEnd += 1;

            CopySz(blank, blankEnd);

            // Note: we don't change the value of blank,
            // since we moved all the data to it!
        }
        else
        {
            blank = blankEnd + 1;
        }
        
        // Keep on truckin'
        blank = wcschr(blank, SPACE);
    }
}


// Win9x performs some special process on path names,
// particularly they remove spaces before slashes.
WCHAR * W9xPathMassageW(const WCHAR * uncorrect)
{
    if (uncorrect == NULL)
        return NULL;

    // Make a buffer large enough for the resulting string
    //
    // We are okay using a buffer that is exactly the same size as the original,
    // since all changes made *reduce* the size of the string.
    //
    WCHAR * correctBuffer = StringDuplicateW(uncorrect);
    if (!correctBuffer)
        return NULL;

    // Convert all '/' to '\'
    // Win9x allows //robkenny/d as a valid UNC name
    for (WCHAR * whack = correctBuffer; *whack; ++whack)
    {
        if (*whack == chDirSep2)
            *whack = chDirSep;
    }

    // We need to skip past the drive portion of the path
    WCHAR * directoryPortion = (WCHAR *)GetDrivePortion(correctBuffer);

    // Remove blank directory names "abc\   \def" -> "abc\def"
    // These are remove entirely rather than just removing the spaces,
    // because we could end up changing "\ \abc" -> "\\abc"
    RemovePreceedingBlanks(directoryPortion);

    // DwRemoveDots is used to remove all .\ and any ..\ in the middle of a path.
    DWORD dwUpDirs = DwRemoveDots(directoryPortion);
    if (dwUpDirs > 0)
    {
        // We need to add some ..\ to the front of the directoryPortion string
        // This is sorta wierd, removing the dots and adding them back again.
        // But the DwRemoveDots routine was copied strait from Win9x, and I
        // didn't want to change it in any way, as to preserve all peculiarities.
        // So we have to add back the leading parent directories that were removed.
        
        DWORD dwLen = (dwUpDirs * 3) + wcslen(correctBuffer) + 1;
        WCHAR * moreCorrectBuffer = (WCHAR*)malloc(dwLen * sizeof(WCHAR));
        if (moreCorrectBuffer)
        {
            moreCorrectBuffer[0] = 0;
            
            // Copy any drive portion
            wcsncpy(moreCorrectBuffer, correctBuffer, directoryPortion - correctBuffer);

            // add as many "..\" as were removed by DwRemoveDots
            while (dwUpDirs-- > 0)
            {
                wcscat(moreCorrectBuffer, L"..\\");
            }

            // finally the remainder of the string
            wcscat(moreCorrectBuffer, directoryPortion);

            delete correctBuffer;
            correctBuffer = moreCorrectBuffer;
        }
        else
        {
            delete correctBuffer;
            correctBuffer = NULL;
        }
    }

    return correctBuffer;
}




};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\win9xpath.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Win9xPath.h

 History:

    10/20/2000  robkenny    Created

--*/


#include <windows.h>

namespace ShimLib
{

inline bool bIsPathSep(char ch)
{
    return ch == '\\' || ch == '/';
}

inline bool bIsPathSep(WCHAR ch)
{
    return ch == L'\\' || ch == L'/';
}

const WCHAR * GetDrivePortion(const WCHAR * uncorrected);

// Non-const version of above routine.
inline WCHAR * GetDrivePortion(WCHAR * uncorrected)
{
    return (WCHAR *)GetDrivePortion((const WCHAR*)uncorrected);
}

WCHAR * W9xPathMassageW(const WCHAR * uncorrect);

};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lib\secutils.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    secutils.cpp

 Abstract:
    The utility functions for the shims.

 History:

    02/09/2001  maonis      Created
    08/14/2001  robkenny    Moved code inside the ShimLib namespace.

--*/

#include "secutils.h"
#include "StrSafe.h"

namespace ShimLib
{
/*++

 Function Description:

    Determine if the log on user is a member of the group.

 Arguments:

    IN dwGroup - specify the alias of the group.
    OUT pfIsMember - TRUE if it's a member, FALSE if not.

 Return Value:

    TRUE - we successfully determined if it's a member.
    FALSE otherwise.
 
 DevNote: 
    
    We are assuming the calling thread is not impersonating.

 History:

    02/12/2001 maonis  Created

--*/

BOOL 
SearchGroupForSID(
    DWORD dwGroup, 
    BOOL* pfIsMember
    )
{
    PSID pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL fRes = TRUE;
    
    if (!AllocateAndInitializeSid(
        &SIDAuth, 
        2, 
        SECURITY_BUILTIN_DOMAIN_RID,
        dwGroup,
        0, 
        0, 
        0, 
        0, 
        0, 
        0,
        &pSID))
    {
        DPF("SecurityUtils", eDbgLevelError, "[SearchGroupForSID] AllocateAndInitializeSid failed %d", GetLastError());
        return FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember))
    {
        DPF("SecurityUtils", eDbgLevelError, "[SearchGroupForSID] CheckTokenMembership failed: %d", GetLastError());
        fRes = FALSE;
    }

    FreeSid(pSID);

    return fRes;
}

/*++

 Function Description:

    Determine if we should shim this app or not.

    If the user is 
    1) a member of the Users and
    2) not a member of the Administrators group and
    3) not a member of the Power Users group and
    3) not a member of the Guest group

    we'll apply the shim.

 Arguments:

    None.

 Return Value:

    TRUE - we should apply the shim.
    FALSE otherwise.
 
 History:

    02/12/2001 maonis  Created

--*/

BOOL 
ShouldApplyShim()
{
    BOOL fIsUser, fIsAdmin, fIsPowerUser, fIsGuest;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_USERS, &fIsUser) || 
        !SearchGroupForSID(DOMAIN_ALI